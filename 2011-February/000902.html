<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r949 - in trunk: . doc doc/eluadoc doc/en mux_src src	src/lua src/modules src/platform/i386 src/platform/lm3s	src/platform/lpc17xx src/platform/stm32
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2011-February/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r949%20-%20in%20trunk%3A%20.%20doc%20doc/eluadoc%20doc/en%20mux_src%20src%0A%09src/lua%20src/modules%20src/platform/i386%20src/platform/lm3s%0A%09src/platform/lpc17xx%20src/platform/stm32&In-Reply-To=%3C20110202175213.B36C9481348%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000901.html">
   <LINK REL="Next"  HREF="000903.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r949 - in trunk: . doc doc/eluadoc doc/en mux_src src	src/lua src/modules src/platform/i386 src/platform/lm3s	src/platform/lpc17xx src/platform/stm32</H1>
    <B>bogdanm at mail.berlios.de</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r949%20-%20in%20trunk%3A%20.%20doc%20doc/eluadoc%20doc/en%20mux_src%20src%0A%09src/lua%20src/modules%20src/platform/i386%20src/platform/lm3s%0A%09src/platform/lpc17xx%20src/platform/stm32&In-Reply-To=%3C20110202175213.B36C9481348%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r949 - in trunk: . doc doc/eluadoc doc/en mux_src src	src/lua src/modules src/platform/i386 src/platform/lm3s	src/platform/lpc17xx src/platform/stm32">bogdanm at mail.berlios.de
       </A><BR>
    <I>Wed Feb  2 18:52:13 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="000901.html">[Elua-svn] r948 - tags
</A></li>
        <LI>Next message: <A HREF="000903.html">[Elua-svn] r950 - branches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#902">[ date ]</a>
              <a href="thread.html#902">[ thread ]</a>
              <a href="subject.html#902">[ subject ]</a>
              <a href="author.html#902">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2011-02-02 18:52:12 +0100 (Wed, 02 Feb 2011)
New Revision: 949

Added:
   trunk/doc/eluadoc/arch_platform_can.lua
   trunk/doc/eluadoc/arch_platform_i2c.lua
   trunk/doc/eluadoc/refman_ps_mbed_pio.lua
   trunk/doc/en/downloads.txt
   trunk/doc/en/installing_avr32.txt
   trunk/doc/en/modules_mbed.txt
   trunk/utils/
Removed:
   trunk/doc/en/downloads.html
   trunk/doc/en/installing_avr32.html
   trunk/mux_src/main.c.allthreads
   trunk/mux_src/main.c.old
Modified:
   trunk/
   trunk/CHANGELOG
   trunk/LICENSE
   trunk/SConstruct
   trunk/doc/README.TXT
   trunk/doc/buildall.lua
   trunk/doc/docdata.lua
   trunk/doc/eluadoc.lua
   trunk/doc/eluadoc/refman_gen_adc.lua
   trunk/doc/eluadoc/refman_gen_cpu.lua
   trunk/doc/eluadoc/refman_gen_elua.lua
   trunk/doc/en/arch_rfs.txt
   trunk/doc/en/asciidoc.conf
   trunk/doc/en/building.txt
   trunk/doc/en/comunity.txt
   trunk/doc/en/dl_old.html
   trunk/doc/en/examples.html
   trunk/doc/en/faq.html
   trunk/doc/en/inthandlers.txt
   trunk/doc/en/linenoise.txt
   trunk/doc/en/media.txt
   trunk/doc/en/news.txt
   trunk/doc/en/overview.txt
   trunk/doc/en/sermux.txt
   trunk/doc/en/status.txt
   trunk/doc/en/using.html
   trunk/doc/en/xhtml11.conf
   trunk/src/elua_mmc.c
   trunk/src/lua/luaconf.h
   trunk/src/modules/cpu.c
   trunk/src/platform/i386/platform.c
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lpc17xx/mbed_pio.c
   trunk/src/platform/stm32/platform.c
Log:
merged pre0.8 branch back to trunk


Property changes on: trunk
___________________________________________________________________
Modified: svn:ignore
   - .sconsign.dblite
mkfs.pyc
*.elf
*.bin
luac*
*.hex
*.tmp
*.map
core
build-setup.conf
config.log
.sconf_temp
*.exe
*.obj
mux
rfs_server


   + .sconsign.dblite
mkfs.pyc
*.elf
*.bin
luac*
*.hex
*.tmp
*.map
core
build-setup.conf
config.log
.sconf_temp
*.exe
*.obj
mux
rfs_server
dist


Modified: trunk/CHANGELOG
===================================================================
--- trunk/CHANGELOG	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/CHANGELOG	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,14 +1,29 @@
-??.???.???? Bogdan Marinescu &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">bogdanm at egmail.com</A>&gt;
+02.02.2011  Bogdan Marinescu &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">bogdan.marinescu at gmail.com</A>&gt;
             Dado Sutter      &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">dadosutter at gmail.com</A>&gt;
             James Snyder     &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">jbsnyder at gmail.com</A>&gt;
 
-  * Changes after v0.8
-  * GPIO INT support for STM32
-  * 
+  * Official release 0.8
+  * Added the RFS (Remote File System), a new file system which allows sharing
+    a directory on the PC with the eLua board.
+  * Added a serial multiplexer which allows using more virtual serial ports over a single 
+    physical UART connection.
+  * Added Lua and C interrupt handlers support.
+  * Added linenoise support (eLua and Lua shell command line history and navigation)
+  * Added generic I2C support and docs
+  * Added hardware flow control and runtime configurable buffers for UARTs.
+  * Added support for new boards: mbed, EVK-1101, Mizar32, EK-LM3S1968
+  * Added SPI and SD/MMC support for EVK1100 and EVK1101 (AVR32) 
+  * Added I2C support for STR-E912 (STR912) 
+  * Added support for require() and autorun from SD/MMC
+  * Added external memory support for STR912
+  * Added long filename support for SD/MMC
+  * Added version() function to elua module
+  * Added RTC (real time clock) platform specific support for str9
+  * Added support for AsciiDoc in the doc builder
+  * Tutorials and new projects added to the eLua User Labs wiki
+  * Demo files were moved out of the distro to <A HREF="http://wiki.eluaproject.net/Projects">http://wiki.eluaproject.net/Projects</A>
+  * Added a 'media' page with eLua related media on the project site
 
-
-
-
 15.01.2010  Bogdan Marinescu &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">bogdanm at eluaproject.net</A>&gt;
             Dado Sutter      &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">dado at eluaproject.net</A>&gt;
             James Snyder     &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">jbsnyder at fanplastic.org</A>&gt;

Modified: trunk/LICENSE
===================================================================
--- trunk/LICENSE	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/LICENSE	2011-02-02 17:52:12 UTC (rev 949)
@@ -33,6 +33,9 @@
 Manufacturer provided CPU support libraries are licensed under their own
 terms, check src/platform/*platform-name* for details.
 
+linenoise (<A HREF="https://github.com/antirez/linenoise,">https://github.com/antirez/linenoise,</A> eLua's readline replacement) 
+is released under a BSD license. 
+
 The rest of the eLua code is licensed under MIT, listed below:
 
 The MIT License

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/SConstruct	2011-02-02 17:52:12 UTC (rev 949)
@@ -139,7 +139,6 @@
 #        }
 
 romfs = {
-
         }
 
 # List of board/romfs data combinations
@@ -159,7 +158,7 @@
 #              'STM3210E-EVAL' : [ 'bisect', 'hello', 'info' ],
 #              'ATEVK1100' : [ 'bisect', 'hangman', 'led', 'hello', 'info', 'dataflash' ],
 #              'ATEVK1101' : [ 'bisect', 'led', 'hello', 'info', 'dataflash' ],
-#              'ET-STM32' : [ 'hello', 'hangman', 'info', 'bisect','adcscope','adcpoll', 'dualpwm', 'pwmled' ],
+#              'ET-STM32' : [ 't' ],
 #              'EAGLE-100' : [ 'bisect', 'hangman', 'lhttpd', 'led', 'hello', 'info' ],
 #              'ELUA-PUC' : [ 'bisect', 'hangman', 'led', 'hello', 'info', 'pwmled', 'adcscope', 'adcpoll', 'inttest' ],
 #              'MBED' : [ 'bisect', 'hangman', 'hello', 'info', 'led', 'pwmled', 'dualpwm', 'life', 'adcscope', 'adcpoll' ],
@@ -460,12 +459,6 @@
     flist = []
     for sample in file_list[ comp['board'] ]:
       flist += romfs[ sample ]
-    # Automatically includes the autorun.lua file in the ROMFS
-    if os.path.isfile( os.path.join( romdir, 'autorun.lua' ) ):
-      flist += [ 'autorun.lua' ]
-    # Automatically includes platform specific Lua module 
-    if os.path.isfile( os.path.join( romdir, comp['board'] + '.lua' ) ):
-      flist += [comp['board'] + '.lua']
     import mkfs
     mkfs.mkfs( romdir, &quot;romfiles&quot;, flist, comp['romfs'], compcmd )
     print

Modified: trunk/doc/README.TXT
===================================================================
--- trunk/doc/README.TXT	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/README.TXT	2011-02-02 17:52:12 UTC (rev 949)
@@ -3,9 +3,18 @@
 
 To generate the doc:
 - make sure you have Lua installed in your machine (www.lua.org)
+- make sure you have 'lfs' (Lua file system) and 'md5' modules installed on your machine. To install them:
+  - in Windows: the simplest way is to install Lua for Windows (<A HREF="http://code.google.com/p/luaforwindows/">http://code.google.com/p/luaforwindows/</A>) which comes with these modules installed
+  - in Ubuntu:
+    1. install luarocks
+      $ sudo apt-get install luarocks
+    2. install both modules using luarocks
+      $ sudo luarocks install lfs md5
+- make sure you have asciidoc (<A HREF="http://www.methods.co.nz/asciidoc/INSTALL.html">http://www.methods.co.nz/asciidoc/INSTALL.html</A>) installed.       
 - go to the /doc directory of this distro (you're probably here already :)
 - run the script with
   $ lua buildall.lua
-- the doc/site structure is generated in a new sub-folder called dist, where you can go and open any .html document. The left-side menu is actually part of the global layout and is included in every page of the doc/site.
+- the doc/site structure is generated in a new sub-folder called dist, where you can go and open any .html document. The left-side menu is actually 
+  part of the global layout and is included in every page of the doc/site.
 - enjoy eLua !
 

Modified: trunk/doc/buildall.lua
===================================================================
--- trunk/doc/buildall.lua	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/buildall.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -279,8 +279,16 @@
 
 -- Helper function: format a link starting from language and link
 -- Links marked as &quot;#&quot; (&quot;null&quot; links) are left alone
+-- Links that begin with &quot;http(s)://&quot; are unchanged
+
 local function get_link( lang, link )
-  return link == &quot;#&quot; and &quot;#&quot; or string.format( &quot;%s_%s&quot;, lang, link )
+  if link == &quot;#&quot; then
+    return &quot;#&quot;
+  elseif link:find( &quot;https?://&quot; ) == 1 then
+    return link
+  else
+    return string.format( &quot;%s_%s&quot;, lang, link )
+  end
 end
 
 -- Helper for gen_html_nav: generate the submenu(s) for a given top level menu item
@@ -666,33 +674,35 @@
 flist = get_file_list()
 for _, lang in ipairs( languages ) do
   for fname, entry in pairs( flist ) do
-    io.write( string.format( &quot;Processing %s %s...&quot;, fname, entry.item[ name_idx ] and &quot;&quot; or &quot;(hidden entry)&quot; ) )
-    local res, err = gen_html_page( fname, lang )
-    if err == &quot;#cached#&quot; then
-      -- This file is already in the cache
-      print( &quot; (cached)&quot; )         
-    elseif not res then
-      print( &quot;***&quot; .. err ) 
-    else
-      local g = io.open( string.format( &quot;cache/%s_%s&quot;, lang, fname ), &quot;wb&quot; )
-      if not g then
-        print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
+    if fname:find( &quot;https?://&quot; ) ~= 1 then -- not a filename but a direct link
+      io.write( string.format( &quot;Processing %s %s...&quot;, fname, entry.item[ name_idx ] and &quot;&quot; or &quot;(hidden entry)&quot; ) )
+      local res, err = gen_html_page( fname, lang )
+      if err == &quot;#cached#&quot; then
+        -- This file is already in the cache
+        print( &quot; (cached)&quot; )         
+      elseif not res then
+        print( &quot;***&quot; .. err ) 
       else
-        g:write( res )
-        g:close()
+        local g = io.open( string.format( &quot;cache/%s_%s&quot;, lang, fname ), &quot;wb&quot; )
+        if not g then
+          print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
+        else
+          g:write( res )
+          g:close()
+        end
       end
+      -- Copy file from cache to destination directory
+      local srcf = io.open( string.format( &quot;cache/%s_%s&quot;, lang, fname ), &quot;rb&quot; )
+      local destf = io.open( string.format( &quot;%s/%s_%s&quot;, destdir, lang, fname ), &quot;wb&quot; )
+      if not srcf or not destf then
+        print &quot;Unable to copy file from cache to dist&quot;
+        return
+      end
+      local content = srcf:read( &quot;*a&quot; )
+      destf:write( content )
+      srcf:close()
+      destf:close()    
     end
-    -- Copy file from cache to destination directory
-    local srcf = io.open( string.format( &quot;cache/%s_%s&quot;, lang, fname ), &quot;rb&quot; )
-    local destf = io.open( string.format( &quot;%s/%s_%s&quot;, destdir, lang, fname ), &quot;wb&quot; )
-    if not srcf or not destf then
-      print &quot;Unable to copy file from cache to dist&quot;
-      return
-    end
-    local content = srcf:read( &quot;*a&quot; )
-    destf:write( content )
-    srcf:close()
-    destf:close()    
   end
 end
 regular_print()
@@ -723,3 +733,4 @@
 print &quot;done&quot;
 
 print( string.format( &quot;\nEnjoy your documentation in %s :)&quot;, destdir ) )
+

Modified: trunk/doc/docdata.lua
===================================================================
--- trunk/doc/docdata.lua	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/docdata.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -45,7 +45,8 @@
       { { &quot;Discussion Lists&quot;, &quot;Listas de Discuss&#227;o&quot; }, &quot;comunity.html#lists&quot; },
       { &quot;Forums&quot;, &quot;comunity.html#forums&quot; },
       { &quot;IRC&quot;, &quot;comunity.html#irc&quot; },
-      { &quot;User Labs Wiki&quot;, &quot;comunity.html#userswiki&quot; },      
+      { &quot;Twitter&quot;, &quot;comunity.html#twitter&quot; }, 
+      { &quot;Wiki&quot;, &quot;comunity.html#userswiki&quot; },      
       { { &quot;Credits&quot;, &quot;Cr&#233;ditos&quot; }, &quot;comunity.html#credits&quot; },
       { &quot;Donations&quot;, &quot;comunity.html#donations&quot; },
       { nil, &quot;forum.html&quot;, nil, &quot;Forum&quot; } -- &quot;hidden&quot; entry (doesn't appear in the menu)
@@ -58,6 +59,15 @@
   -- Media
   { &quot;Media&quot;, &quot;media.html&quot; },  
 
+  -- Wiki
+  { &quot;eLua Wiki&quot;, &quot;<A HREF="http://wiki.eluaproject.net">http://wiki.eluaproject.net</A>&quot; },
+
+  -- Web builder
+  { &quot;eLua Web builder&quot;, &quot;<A HREF="http://builder.eluaproject.net">http://builder.eluaproject.net</A>&quot; },
+
+  -- Tracker
+  { &quot;eLua bug tracker&quot;, &quot;<A HREF="http://tracker.eluaproject.net">http://tracker.eluaproject.net</A>&quot; },
+
   -- &quot;Status&quot;
   { &quot;Status&quot;, &quot;status.html&quot;, 
     {
@@ -83,6 +93,7 @@
       },
       { { &quot;Old versions&quot;, &quot;Vers&#245;es Anteriores&quot; }, &quot;dl_old.html&quot;, 
         {
+          { &quot;0.7&quot;, &quot;dl_old.html#v070&quot; },
           { &quot;0.6&quot;, &quot;dl_old.html#v060&quot; },
           { &quot;0.5&quot;, &quot;dl_old.html#v050&quot; },
           { &quot;0.4.1&quot;, &quot;dl_old.html#v041&quot; },
@@ -202,7 +213,8 @@
   { { &quot;Platform modules&quot;, &quot;M&#243;dulos Espec&#237;ficos&quot; }, &quot;refman_dep.html&quot;, 
     {
       { &quot;lm3s&quot;, &quot;modules_lm3s.html&quot;, &quot;refman_ps_lm3s&quot; },
-      { &quot;str9&quot;, &quot;modules_str9.html&quot;, &quot;refman_ps_str9&quot; }
+      { &quot;str9&quot;, &quot;modules_str9.html&quot;, &quot;refman_ps_str9&quot; },
+      { &quot;mbed&quot;, &quot;modules_mbed.html&quot;, &quot;refman_ps_mbed&quot; }
     }
   }
 }

Copied: trunk/doc/eluadoc/arch_platform_can.lua (from rev 948, branches/pre0.8/doc/eluadoc/arch_platform_can.lua)
===================================================================
--- trunk/doc/eluadoc/arch_platform_can.lua	                        (rev 0)
+++ trunk/doc/eluadoc/arch_platform_can.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -0,0 +1,77 @@
+-- eLua platform interface - CAN
+-- Make a full description for each language
+
+data_en = 
+{
+  -- Menu name
+  menu_name = &quot;CAN&quot;,
+
+  -- Title
+  title = &quot;eLua platform interface - CAN&quot;,
+
+  -- Overview
+  overview = &quot;This part of the platform interface groups functions related to the CAN interface(s) of the MCU..&quot;,
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[// eLua CAN ID types
+enum
+{
+  ELUA_CAN_ID_STD = 0,
+  ELUA_CAN_ID_EXT
+};
+]],
+      name = &quot;CAN ID types&quot;,
+      desc = &quot;Constants used to define whether the message ID is standard or extended..&quot;
+    }
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_can_exists#( unsigned id );&quot;,
+      desc = [[Checks if the platform has the hardware CAN specified as argument. Implemented in %src/common.c%, it uses the $NUM_CAN$ macro that must be defined in the
+  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
+  ~#define NUM_CAN   1      $// The platform has one CAN interface$~&lt;p&gt; ]],
+      args = &quot;$id$ - CAN interface ID.&quot;,
+      ret = &quot;1 if the CAN interface exists, 0 otherwise&quot;
+    },
+
+    { sig = &quot;u32 #platform_can_setup#( unsigned id, u23 clock );&quot;,
+      desc = [[This function is used to initialize the CAN hardware and set the bus clock.]],
+      args = 
+      {
+        &quot;$id$ - CAN interface ID.&quot;,
+        &quot;$clock$ - the clock of the CAN bus, maximum speed is generally 1000000 (1 Mbit)&quot;
+      },
+      ret = &quot;the actual speed set for the CAN interface. Depending on the hardware, this may have a different value than the $clock$ argument.&quot;
+    },
+
+    {  sig = &quot;void #platform_can_send#( unsigned id, u32 canid, u8 idtype, u8 len, const u8 *data );&quot;,
+       desc = &quot;Send message over the CAN bus.&quot;,
+       args =
+       {
+          &quot;$id$ - CAN interface ID.&quot;,
+          &quot;$canid$ - CAN identifier number.&quot;,
+          &quot;$canidtype$ - identifier type as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">can_id_types at here</A>@&quot;,
+          &quot;$len$ - message length in bytes (8 or fewer)&quot;,
+          &quot;$message$ - pointer to message, 8 or fewer bytes in length&quot;
+       },
+    },
+
+     {  sig = &quot;int #platform_can_recv#( unsigned id, u32 *canid, u8 *idtype, u8 *len, u8 *data );&quot;,
+        desc = &quot;Receive CAN bus message.&quot;,
+        args =
+       {
+          &quot;$id$ - CAN interface ID.&quot;,
+          &quot;$canid$ - pointer where CAN identifier number will be written.&quot;,
+          &quot;$canidtype$ - pointer where identifier type as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">can_id_types at here</A>@ will be written&quot;,
+          &quot;$len$ - pointer where message length in bytes will be written&quot;,
+          &quot;$message$ - pointer to message buffer (8 bytes in lenth)&quot;
+       },
+       ret = &quot;PLATFORM_OK for success, PLATFORM_UNDERFLOW for error. (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">arch_platform_ll.html at here</A>@ for details)&quot;
+    },
+  }
+}
+

Copied: trunk/doc/eluadoc/arch_platform_i2c.lua (from rev 948, branches/pre0.8/doc/eluadoc/arch_platform_i2c.lua)
===================================================================
--- trunk/doc/eluadoc/arch_platform_i2c.lua	                        (rev 0)
+++ trunk/doc/eluadoc/arch_platform_i2c.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -0,0 +1,104 @@
+-- eLua platform interface - I2C
+-- Make a full description for each language
+
+data_en = 
+{
+  -- Menu name
+  menu_name = &quot;I2C&quot;,
+
+  -- Title
+  title = &quot;eLua platform interface - I2C&quot;,
+
+  -- Overview
+  overview = &quot;This part of the platform interface groups functions related to the I2C interface(s) of the MCU. Currently only the I2C master mode is supported by eLua.&quot;,
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[// I2C speed
+enum
+{
+  PLATFORM_I2C_SPEED_SLOW = 100000,
+  PLATFORM_I2C_SPEED_FAST = 400000
+};]],
+      name = &quot;I2C speed&quot;,
+      desc = &quot;Constants used to configure the speed of the I2C interface.&quot;
+    },
+
+    { text = [[// I2C direction
+enum
+{
+  PLATFORM_I2C_DIRECTION_TRANSMITTER,
+  PLATFORM_I2C_DIRECTION_RECEIVER
+};
+]],
+      name = &quot;I2C transfer direction&quot;,
+      desc = &quot;Constants used to select the I2C master transfer direction (transmitter or receiver).&quot;
+    }, 
+
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_i2c_exists#( unsigned id );&quot;,
+      desc = [[Checks if the platform has the hardware I2C specified as argument. Implemented in %src/common.c%, it uses the $NUM_I2C$ macro that must be defined in the
+  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
+  ~#define NUM_I2C   1      $// The platform has one I2C interface$~&lt;p&gt; ]],
+      args = &quot;$id$ - I2C interface ID.&quot;,
+      ret = &quot;1 if the I2C interface exists, 0 otherwise&quot;
+    },
+
+    { sig = &quot;u32 #platform_i2c_setup#( unsigned id, u23 speed );&quot;,
+      desc = [[This function is used to initialize the parameters of the I2C interface. &lt;span class=&quot;warning&quot;&gt;NOTE&lt;/span&gt;: currently, only master I2C mode is implemented in eLua.]],
+      args = 
+      {
+        &quot;$id$ - I2C interface ID.&quot;,
+        &quot;$speed$ - the speed of the interface, can be either $PLATFORM_I2C_SPEED_SLOW$ or $PLATFORM_I2C_SPEED_FAST$ as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">i2c_speed at here</A>@&quot;
+      },
+      ret = &quot;the actual speed set for the I2C interface. Depending on the hardware, this may have a different value than the $speed$ argument.&quot;
+    },
+
+    {  sig = &quot;void #platform_i2c_send_start#( unsigned id );&quot;,
+       desc = &quot;Send an I2C START condition on the specified interface.&quot;,
+       args = &quot;$id$ - I2C interface ID.&quot;
+    },
+
+     { sig = &quot;void #platform_i2c_send_stop#( unsigned id );&quot;,
+       desc = &quot;Send an I2C STOP condition on the specified interface.&quot;,
+       args = &quot;$id$ - I2C interface ID.&quot;
+    },
+   
+    { sig = &quot;int #platform_i2c_send_address#( unsigned id, u16 address, int direction );&quot;,
+      desc = [[Send an address on the I2C with the specified transfer direction (transmitter or receiver).]],
+      args =
+      {
+        &quot;$id$ - I2C interface ID.&quot;,
+        &quot;$address$ - I2C peripheral address.&quot;,
+        &quot;$direction$ - transfer direction, either $PLATFORM_I2C_DIRECTION_TRANSMITTER$ or $PLATFORM_I2C_DIRECTION_RECEIVER$ as defined @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">i2c_transfer_direction at here</A>@.&quot;
+      },
+      ret = &quot;1 for success, 0 for error.&quot;
+    },
+
+    { sig = &quot;int #platform_i2c_send_byte#( unsigned id, u8 data );&quot;,
+      desc = &quot;Send a byte on the I2C interface.&quot;,
+      args = 
+      {
+        &quot;$id$ - I2C interface ID.&quot;,
+        &quot;$data$ - the byte to send.&quot;,
+      },
+      ret = &quot;1 for success, 0 for error.&quot;,
+    },
+
+    { sig = &quot;int #platform_i2c_recv_byte#( unsigned id, int ack );&quot;,
+      desc = &quot;Receive a byte from the I2C interface and send a positive (ACK) or negative (NAK) acknowledgement.&quot;,
+      args =
+      {
+        &quot;$id$ - I2C interface ID.&quot;,
+        &quot;$ack$ - 1 to send ACK, 0 to send NAK. If $ACK$ is 0 a STOP condition will automatically be generated after the NAK.&quot;
+      },
+      ret = &quot;1 for success, 0 for error.&quot;
+    }
+  }
+}
+

Modified: trunk/doc/eluadoc/refman_gen_adc.lua
===================================================================
--- trunk/doc/eluadoc/refman_gen_adc.lua	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/eluadoc/refman_gen_adc.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -12,7 +12,9 @@
   -- Overview
   overview = [[This module contains functions that access analog to digital converter (ADC) peripherals.&lt;/p&gt;
   &lt;p&gt;When utilizing this module, acquiring ADC data is a two step process: requesting sample conversions (using $adc.sample$) and extraction of conversion results from a conversion buffer (using $adc.getsample$, $adc.getsamples$ or $adc.insertsamples$). Various configuration parameters are available to set conversion rate, how results are extracted from the buffer and how these results are processed prior to extraction.&lt;/p&gt;
-  &lt;p&gt;This module can be utilized if the device in use has a supported ADC peripheral (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">status.html at status</A>@ for details) and if ADC functionality is enabled at build time (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at building</A>@).]],
+  &lt;p&gt;This module can be utilized if the device in use has a supported ADC peripheral (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">status.html at status</A>@ for details) and if ADC functionality is enabled at build time (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at building</A>@).&lt;/p&gt;
+&lt;p&gt;&lt;span class=&quot;warning&quot;&gt;IMPORTANT&lt;/span&gt;: Platform support varies for this module (see @status.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">plat_notes at status</A> notes@ for details) .
+  ]],
 
   -- Functions
   funcs = 

Modified: trunk/doc/eluadoc/refman_gen_cpu.lua
===================================================================
--- trunk/doc/eluadoc/refman_gen_cpu.lua	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/eluadoc/refman_gen_cpu.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -85,7 +85,7 @@
     },
 
     { sig = &quot;#cpu.cli#( [id], [resnum1], [resnum2], ... [resnumn])&quot;,
-      desc = &quot;Disables the global CPU interrupt flag if called without arguments, or a specific interrupt (and the interrupt's capability of triggering Lua interrupt handlers) for a list of resource IDs if called with arguments.&quot;,
+      desc = &quot;Disables the global CPU interrupt flag if called without arguments, or a specific interrupt for a list of resource IDs if called with arguments.&quot;,
       args =
       {
         &quot;$id$ - the interrupt ID. If specified, at least one resource ID must also be specified.&quot;,
@@ -95,20 +95,8 @@
       }
     },
 
-    { sig = &quot;#cpu.hw_cli#( [id], [resnum1], [resnum2], ... [resnumn])&quot;,
-      desc = &quot;Disables the global CPU interrupt flag if called without arguments, or a specific interrupt for a list of resource IDs if called with arguments. The interrupt is only disabled at hardware level, this function doesn't affect the interrupt's ability of triggering Lua interrupt handlers.&quot;,
-      args =
-      {
-        &quot;$id$ - the interrupt ID. If specified, at least one resource ID must also be specified.&quot;,
-        &quot;$resnum1$ - the first resource ID, required if $id$ is specified.&quot;,
-        &quot;$resnum2 (optional)$ - the second resource ID.&quot;,
-        &quot;$resnumn (optional)$ - the #n#-th resource ID.&quot;
-      }
-    },
-   
-
     { sig = &quot;#cpu.sei#( [id], [resnum1], [resnum2], ... [resnumn])&quot;,
-      desc = &quot;Enables the global CPU interrupt flag if called without arguments, or a specific interrupt (and the interrupt's capability of triggering Lua interrupt handlers) for a list of resource IDs if called with arguments.&quot;,
+      desc = &quot;Enables the global CPU interrupt flag if called without arguments, or a specific interrupt for a list of resource IDs if called with arguments.&quot;,
       args =
       {
         &quot;$id$ - the interrupt ID. If specified, at least one resource ID must also be specified.&quot;,
@@ -118,17 +106,6 @@
       }     
     },
     
-    { sig = &quot;#cpu.hw_sei#( [id], [resnum1], [resnum2], ... [resnumn])&quot;,
-      desc = &quot;Enables the global CPU interrupt flag if called without arguments, or a specific interrupt for a list of resource IDs if called with arguments. The interrupt is only enabled at hardware level, this function doesn't affect the interrupt's ability of triggering Lua interrupt handlers.&quot;,
-      args =
-      {
-        &quot;$id$ - the interrupt ID. If specified, at least one resource ID must also be specified.&quot;,
-        &quot;$resnum1$ - the first resource ID, required if $id$ is specified.&quot;,
-        &quot;$resnum2 (optional)$ - the second resource ID.&quot;,
-        &quot;$resnumn (optional)$ - the #n#-th resource ID.&quot;
-      }     
-    },
-
     { sig = &quot;clock = #cpu.clock#()&quot;,
       desc = &quot;Get the CPU core frequency.&quot;,
       ret = &quot;$clock$ - the CPU clock (in Hertz).&quot;

Modified: trunk/doc/eluadoc/refman_gen_elua.lua
===================================================================
--- trunk/doc/eluadoc/refman_gen_elua.lua	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/eluadoc/refman_gen_elua.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -26,8 +26,13 @@
     
     { sig = &quot;#elua.save_history#( filename )&quot;,
       desc = &quot;Save the interpreter line history. Only available if linenoise is enabled, check @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">linenoise.html at here</A>@ for details.&quot;,
-      args = &quot;$filename$ - the name of the file where the history will be saved. *CAUTION*: the file will be overwritten.&quot;,
+      args = &quot;$filename$ - the name of the file where the history will be saved. $CAUTION$: the file will be overwritten.&quot;,
     },    
+
+    { sig = &quot;version = #elua.version#()&quot;,
+      desc = &quot;Returns the current eLua version as a string&quot;,
+      ret = &quot;the eLua version currently running.&quot;
+    },
   },
 }
 

Copied: trunk/doc/eluadoc/refman_ps_mbed_pio.lua (from rev 948, branches/pre0.8/doc/eluadoc/refman_ps_mbed_pio.lua)
===================================================================
--- trunk/doc/eluadoc/refman_ps_mbed_pio.lua	                        (rev 0)
+++ trunk/doc/eluadoc/refman_ps_mbed_pio.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -0,0 +1,146 @@
+-- eLua reference manual - platform data
+
+data_en = 
+{
+
+  -- Title
+  title = &quot;eLua reference manual - MBED pio module&quot;,
+
+  -- Menu name
+  menu_name = &quot;pio&quot;,
+
+  -- Overview
+  overview = [[&lt;p&gt;This module provide a function for accessing pin configuration
+ features on the LPC17xx family of CPUs, and provides provides a pin
+ mapping which corresponds to the pins and LEDs on the MBED platform.
+ The pin configuration function allows the user to reconfigure pin
+ function (as decribed in section 8.5 of the
+ @<A HREF="http://ics.nxp.com/support/documents/microcontrollers/pdf/user.manual.lpc17xx.pdf@lpc17xx">http://ics.nxp.com/support/documents/microcontrollers/pdf/user.manual.lpc17xx.pdf@lpc17xx</A> user manual@,
+ configure the pin as an open drain, and configure the
+ pin as pullup, pulldown or tristate.  Note that this module is a
+ supplement of the platform independent @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">refman_gen_pio.html at pio</A>@
+ module, not a replacement. Use this module only for setting up the
+ MBED PIO pins, and the @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">refman_gen_pio.html at pio</A>@ module for all the
+ other PIO related operations.  Below is a subset of available pin functions:&lt;/p&gt;
+
+&lt;ul&gt;
+&lt;li&gt;PWM
+&lt;table style=&quot;text-align: left; margin-left: 2em;&quot;&gt;
+&lt;tbody&gt;
+&lt;tr&gt;
+  &lt;th&gt;MBED Pin&lt;/th&gt;
+  &lt;th&gt;ID&lt;/th&gt;
+  &lt;th&gt;Function&lt;/th&gt;
+&lt;/tr&gt;
+&lt;/tr&gt;
+  &lt;td&gt;LED1&lt;/th&gt;
+  &lt;td&gt;1&lt;/th&gt;
+  &lt;td&gt;FUNCTION_2&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;LED2&lt;/th&gt;
+  &lt;td&gt;2&lt;/th&gt;
+  &lt;td&gt;FUNCTION_2&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;LED3&lt;/th&gt;
+  &lt;td&gt;3&lt;/th&gt;
+  &lt;td&gt;FUNCTION_2&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;LED4&lt;/th&gt;
+  &lt;td&gt;4&lt;/th&gt;
+  &lt;td&gt;FUNCTION_2&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p21&lt;/th&gt;
+  &lt;td&gt;6&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p22&lt;/th&gt;
+  &lt;td&gt;5&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p23&lt;/th&gt;
+  &lt;td&gt;4&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p24&lt;/th&gt;
+  &lt;td&gt;3&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p25&lt;/th&gt;
+  &lt;td&gt;2&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p26&lt;/th&gt;
+  &lt;td&gt;1&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;/tbody&gt;
+&lt;/table&gt;
+&lt;/li&gt;
+
+&lt;li&gt;UART
+&lt;table style=&quot;text-align: left; margin-left: 2em;&quot;&gt;
+&lt;tbody&gt;
+&lt;tr&gt;
+  &lt;th&gt;MBED Pin&lt;/th&gt;
+  &lt;th&gt;ID&lt;/th&gt;
+  &lt;th&gt;Function&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p13&lt;/th&gt;
+  &lt;td&gt;1 (TX)&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p14&lt;/th&gt;
+  &lt;td&gt;1 (RX)&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p28&lt;/th&gt;
+  &lt;td&gt;2 (TX)&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;p27&lt;/th&gt;
+  &lt;td&gt;2 (RX)&lt;/th&gt;
+  &lt;td&gt;FUNCTION_1&lt;/th&gt;
+&lt;/tr&gt;
+&lt;/tbody&gt;
+&lt;/table&gt;
+&lt;/li&gt;
+&lt;/ul&gt;
+
+ &lt;p&gt;In addition, this module provides pin mapping as found on the mbed
+ board so that $mbed.pio.p5$ through $mbed.pio.p30$ map onto the mbed
+ pins as described in the
+ @<A HREF="http://mbed.org/handbook/mbed-NXP-LPC1768@mbed">http://mbed.org/handbook/mbed-NXP-LPC1768@mbed</A> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">handbook at .</A> LED pins
+ are also usable, for example LED1 would correspond to
+ $mbed.pio.LED1$.&lt;/p&gt;]],
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;#mbed.pio.configpin#( pin, function, mode, resistor)&quot;,
+      desc = &quot;Configure the pin.&quot;,
+      args = 
+      {
+        &quot;$pin$ - the pin, as encoded in the @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">refman_gen_pio.html at pio</A>@ or $mbed.pio$ module.&quot;,
+        &quot;$function$ - alternate pin function, Must be either $mbed.pio.FUNCTION_0 (default)$, $mbed.pio.FUNCTION_1$, $mbed.pio.FUNCTION_2$, or $mbed.pio.FUNCTION_3$&quot;,
+        &quot;$mode$ - open drain mode, can be either $mbed.pio.MODE_DEFAULT$ (no open drain) or $mbed.pio.MODE_OD$ (open drain).&quot;,
+        &quot;$resistor$ - alternate pin function. Must be either $mbed.pio.RES_PULLUP$ (default), $mbed.pio.RES_TRISTATE$, $mbed.pio.RES_PULLDOWN$.&quot;
+      }
+    },
+
+  },
+}
+
+data_pt = data_en

Modified: trunk/doc/eluadoc.lua
===================================================================
--- trunk/doc/eluadoc.lua	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/eluadoc.lua	2011-02-02 17:52:12 UTC (rev 949)
@@ -9,15 +9,16 @@
 -- Data structure declarations
 
 -- List here all the sections for which we're generating the documentation
-local doc_sections = { &quot;arch_platform&quot;, &quot;refman_gen&quot;, &quot;refman_ps_lm3s&quot;, &quot;refman_ps_str9&quot; }
+local doc_sections = { &quot;arch_platform&quot;, &quot;refman_gen&quot;, &quot;refman_ps_lm3s&quot;, &quot;refman_ps_str9&quot;, &quot;refman_ps_mbed&quot; }
 
 -- List here all the components of each section
 local components = 
 { 
-  arch_platform = { &quot;ll&quot;, &quot;pio&quot;, &quot;spi&quot;, &quot;uart&quot;, &quot;timers&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;eth&quot;, &quot;adc&quot; },
+  arch_platform = { &quot;ll&quot;, &quot;pio&quot;, &quot;spi&quot;, &quot;uart&quot;, &quot;timers&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;eth&quot;, &quot;adc&quot;, &quot;i2c&quot;, &quot;can&quot; },
   refman_gen = { &quot;bit&quot;, &quot;pd&quot;, &quot;cpu&quot;, &quot;pack&quot;, &quot;adc&quot;, &quot;term&quot;, &quot;pio&quot;, &quot;uart&quot;, &quot;spi&quot;, &quot;tmr&quot;, &quot;pwm&quot;, &quot;net&quot;, &quot;can&quot;, &quot;rpc&quot;, &quot;elua&quot;, &quot;i2c&quot; },
   refman_ps_lm3s = { &quot;disp&quot; },
-  refman_ps_str9 = { &quot;pio&quot;, &quot;rtc&quot; }
+  refman_ps_str9 = { &quot;pio&quot;, &quot;rtc&quot; },
+  refman_ps_mbed = { &quot;pio&quot; }
 }
 
 -------------------------------------------------------------------------------

Modified: trunk/doc/en/arch_rfs.txt
===================================================================
--- trunk/doc/en/arch_rfs.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/arch_rfs.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -117,7 +117,7 @@
 - if you find a bug in the RFS server and wish to report it, try to reproduce the problem again, but this time run *rfs_server* with *-v* (verbose).
   The resulting logs may help us identify the problem.  
   
-If you like the RFS, but dislike the idea of having to connect your eLua board to the PC with two serial connections (one for the console and another
+IMPORTANT: If you like the RFS, but dislike the idea of having to connect your eLua board to the PC with two serial connections (one for the console and another
 one for the RFS) check link:sermux.html[here] for a possible solution to this. 
 
 // $$FOOTER$$

Modified: trunk/doc/en/asciidoc.conf
===================================================================
--- trunk/doc/en/asciidoc.conf	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/asciidoc.conf	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,76 +1,103 @@
-#
-# asciidoc.conf
-#
-# Asciidoc global configuration file.
-# Contains backend independent configuration settings that are applied to all
-# AsciiDoc documents.
-#
-
-[miscellaneous]
-tabsize=2
-textwidth=80
-newline=\n
-
-[specialwords]
-emphasizedwords=
-strongwords=eLua
-monospacedwords=
-
-# Colored table cells
-# o: white background, orange text color
-# g: gray background, black text color, bold text, text is centered
-[tabledef-default]
-orange-style=tags=&quot;orange&quot;
-graybg-style=tags=&quot;graybg&quot;
-
-[tabletags-orange]
-bodydata=&lt;td style=&quot;color: rgb(255, 102, 0)&quot;&gt;|&lt;/td&gt;
-
-[tabletags-graybg]
-bodydata=&lt;td style=&quot;background-color: silver; font-weight: bold;&quot; align=&quot;center&quot;&gt;|&lt;/td&gt;
-
-[replacements]
-# Status images
-_sok=image:images/stat_ok.png[Status: OK]
-_sni=image:images/stat_not_implemented.png[Status: not implemented]
-_snt=image:images/stat_not_tested.png[Status: testing]
-_sna=image:images/stat_not_applicable.png[Status: not applicable]
-
-# CPUs 
-_LM3S8962=<A HREF="http://www.luminarymicro.com/products/LM3S8962.html[LM3S8962">http://www.luminarymicro.com/products/LM3S8962.html[LM3S8962</A>]
-_LM3S6965=<A HREF="http://www.luminarymicro.com/products/lm3s6965.html[LM3S6965">http://www.luminarymicro.com/products/lm3s6965.html[LM3S6965</A>]
-_LM3S6918=<A HREF="http://www.luminarymicro.com/products/lm3s6918.html[LM3S6918">http://www.luminarymicro.com/products/lm3s6918.html[LM3S6918</A>]
-_LM3S9B92=<A HREF="http://www.luminarymicro.com/products/lm3s6918.html[LM3S9B92">http://www.luminarymicro.com/products/lm3s6918.html[LM3S9B92</A>]
-_AT32UC3A0512=<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4117[AT32UC3A0512">http://www.atmel.com/dyn/products/product_card.asp?part_id=4117[AT32UC3A0512</A>]
-_AT91SAM7X256=<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755[AT91SAM7X256">http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755[AT91SAM7X256</A>]
-_AT91SAM7X512=<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104[AT91SAM7X512">http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104[AT91SAM7X512</A>]
-_LPC2468=<A HREF="http://www.nxp.com/#/pip/pip=%5Bpip=LPC2468_4%5D|pp=%5Bt=pip,i=LPC2468_4%5D[LPC2468">http://www.nxp.com/#/pip/pip=%5Bpip=LPC2468_4%5D|pp=%5Bt=pip,i=LPC2468_4%5D[LPC2468</A>]
-_LPC2888=<A HREF="http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html[LPC2888">http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html[LPC2888</A>]
-_STR711FR2=<A HREF="http://www.st.com/mcu/devicedocs-STR711FR2.html[STR711FR2">http://www.st.com/mcu/devicedocs-STR711FR2.html[STR711FR2</A>]
-_STR912FAW44=<A HREF="http://www.st.com/mcu/devicedocs-STR912FAW44-101.html[STR912FAW44">http://www.st.com/mcu/devicedocs-STR912FAW44-101.html[STR912FAW44</A>]
-_STM32F103ZE=<A HREF="http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html[STM32F103ZE">http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html[STM32F103ZE</A>]
-_STM32F103RE=<A HREF="http://www.st.com/mcu/devicedocs-STM32F103RE-110.html[STM32F103RE">http://www.st.com/mcu/devicedocs-STM32F103RE-110.html[STM32F103RE</A>]
-_i386=<A HREF="http://www.intel.com/[i386">http://www.intel.com/[i386</A>]
-_LPC1768=<A HREF="http://www.nxp.com/#/pip/pip=%5Bpip=LPC1769_68_67_66_65_64_63%5D|pp=%5Bt=pip,i=LPC1769_68_67_66_65_64_63%5D[LPC1768">http://www.nxp.com/#/pip/pip=%5Bpip=LPC1769_68_67_66_65_64_63%5D|pp=%5Bt=pip,i=LPC1769_68_67_66_65_64_63%5D[LPC1768</A>]
-
-# Boards
-_EK-LM3S8962=<A HREF="http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html[EK-LM3S8962">http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html[EK-LM3S8962</A>]
-_EK-LM3S6965=<A HREF="http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html[EK-LM3S6965">http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html[EK-LM3S6965</A>]
-_Eagle-100=<A HREF="http://www.micromint.com/index.php/SBC/eagle-100.html[Eagle">http://www.micromint.com/index.php/SBC/eagle-100.html[Eagle</A> 100]
-_EK-LM3S9B92=<A HREF="http://www.luminarymicro.com/products/ek-lm3s9b92.html[EK-LM3S9B92">http://www.luminarymicro.com/products/ek-lm3s9b92.html[EK-LM3S9B92</A>]
-_ATEVK1100=<A HREF="http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114[ATEVK1100">http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114[ATEVK1100</A>]
-_SAM7-EX256=<A HREF="http://www.olimex.com/dev/sam7-ex256.html[SAM7-EX256">http://www.olimex.com/dev/sam7-ex256.html[SAM7-EX256</A>]
-_PUC-RioDemo=<A HREF="http://www.giga.puc-rio.br/site/embedded/eluademoboard[PUC-Rio">http://www.giga.puc-rio.br/site/embedded/eluademoboard[PUC-Rio</A> Demo]
-_LPC-H2888=<A HREF="http://www.olimex.com/dev/lpc-h2888.html[LPC-H2888">http://www.olimex.com/dev/lpc-h2888.html[LPC-H2888</A>]
-_MOD711=<A HREF="http://www.sctec.com.br/content/view/101/30/[MOD711">http://www.sctec.com.br/content/view/101/30/[MOD711</A>]
-_STR9-comStick=<A HREF="http://www.hitex.com/index.php?id=383[STR9-comStick">http://www.hitex.com/index.php?id=383[STR9-comStick</A>]
-_STR-E912=<A HREF="http://www.olimex.com/dev/str-e912.html[STR-E912">http://www.olimex.com/dev/str-e912.html[STR-E912</A>]
-_STM3210E-EVAL=<A HREF="http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html[STM3210E-EVAL">http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html[STM3210E-EVAL</A>]
-_ET-STM32Stamp=<A HREF="http://www.futurlec.com/ET-STM32_Stamp.shtml[ET-STM32">http://www.futurlec.com/ET-STM32_Stamp.shtml[ET-STM32</A> Stamp]
-_mbed=<A HREF="http://mbed.org/[mbed">http://mbed.org/[mbed</A>]
-
-# Modules
-_mcpu=link:refman_gen_cpu.html[CPU]
-
-# Miscellaneous
-_br=&lt;br /&gt;
+#
+# asciidoc.conf
+#
+# Asciidoc global configuration file.
+# Contains backend independent configuration settings that are applied to all
+# AsciiDoc documents.
+#
+
+[miscellaneous]
+tabsize=2
+textwidth=80
+newline=\n
+
+[specialwords]
+emphasizedwords=
+strongwords=eLua
+monospacedwords=
+
+# Colored table cells
+# o: white background, orange text color
+# g: gray background, black text color, bold text, text is centered
+[tabledef-default]
+orange-style=tags=&quot;orange&quot;
+graybg-style=tags=&quot;graybg&quot;
+
+[tabletags-orange]
+bodydata=&lt;td style=&quot;color: rgb(255, 102, 0)&quot;&gt;|&lt;/td&gt;
+
+[tabletags-graybg]
+bodydata=&lt;td style=&quot;background-color: silver; font-weight: bold;&quot; align=&quot;center&quot;&gt;|&lt;/td&gt;
+
+[replacements]
+# Status images
+_sok=image:images/stat_ok.png[Status: OK]
+_sni=image:images/stat_not_implemented.png[Status: not implemented]
+_snt=image:images/stat_not_tested.png[Status: testing]
+_sna=image:images/stat_not_applicable.png[Status: not applicable]
+
+# CPUs 
+_LM3S8962=<A HREF="http://www.luminarymicro.com/products/LM3S8962.html[LM3S8962">http://www.luminarymicro.com/products/LM3S8962.html[LM3S8962</A>]
+_LM3S6965=<A HREF="http://www.luminarymicro.com/products/lm3s6965.html[LM3S6965">http://www.luminarymicro.com/products/lm3s6965.html[LM3S6965</A>]
+_LM3S6918=<A HREF="http://www.luminarymicro.com/products/lm3s6918.html[LM3S6918">http://www.luminarymicro.com/products/lm3s6918.html[LM3S6918</A>]
+_LM3S9B92=<A HREF="http://www.luminarymicro.com/products/lm3s6918.html[LM3S9B92">http://www.luminarymicro.com/products/lm3s6918.html[LM3S9B92</A>]
+_AT32UC3A0512=<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4117[AT32UC3A0512">http://www.atmel.com/dyn/products/product_card.asp?part_id=4117[AT32UC3A0512</A>]
+_AT91SAM7X256=<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755[AT91SAM7X256">http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755[AT91SAM7X256</A>]
+_AT91SAM7X512=<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104[AT91SAM7X512">http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104[AT91SAM7X512</A>]
+_LPC2468=<A HREF="http://www.nxp.com/#/pip/pip=%5Bpip=LPC2468_4%5D|pp=%5Bt=pip,i=LPC2468_4%5D[LPC2468">http://www.nxp.com/#/pip/pip=%5Bpip=LPC2468_4%5D|pp=%5Bt=pip,i=LPC2468_4%5D[LPC2468</A>]
+_LPC2888=<A HREF="http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html[LPC2888">http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html[LPC2888</A>]
+_STR711FR2=<A HREF="http://www.st.com/mcu/devicedocs-STR711FR2.html[STR711FR2">http://www.st.com/mcu/devicedocs-STR711FR2.html[STR711FR2</A>]
+_STR912FAW44=<A HREF="http://www.st.com/mcu/devicedocs-STR912FAW44-101.html[STR912FAW44">http://www.st.com/mcu/devicedocs-STR912FAW44-101.html[STR912FAW44</A>]
+_STM32F103ZE=<A HREF="http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html[STM32F103ZE">http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html[STM32F103ZE</A>]
+_STM32F103RE=<A HREF="http://www.st.com/mcu/devicedocs-STM32F103RE-110.html[STM32F103RE">http://www.st.com/mcu/devicedocs-STM32F103RE-110.html[STM32F103RE</A>]
+_I386=<A HREF="http://www.intel.com/[i386">http://www.intel.com/[i386</A>]
+_LPC1768=<A HREF="http://www.nxp.com/#/pip/pip=%5Bpip=LPC1769_68_67_66_65_64_63%5D|pp=%5Bt=pip,i=LPC1769_68_67_66_65_64_63%5D[LPC1768">http://www.nxp.com/#/pip/pip=%5Bpip=LPC1769_68_67_66_65_64_63%5D|pp=%5Bt=pip,i=LPC1769_68_67_66_65_64_63%5D[LPC1768</A>]
+_AT32UC3B0256=<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4174[AT32UC3B0256">http://www.atmel.com/dyn/products/product_card.asp?part_id=4174[AT32UC3B0256</A>]
+_AT32UC3A0128=<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4126[AT32UC3A0128">http://www.atmel.com/dyn/products/product_card.asp?part_id=4126[AT32UC3A0128</A>]
+_LM3S1968=<A HREF="http://www.luminarymicro.com/products/lm3s1968_microcontroller.html[LM3S1968">http://www.luminarymicro.com/products/lm3s1968_microcontroller.html[LM3S1968</A>]
+
+# Boards
+_EK-LM3S8962=<A HREF="http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html[EK-LM3S8962">http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html[EK-LM3S8962</A>]
+_EK-LM3S6965=<A HREF="http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html[EK-LM3S6965">http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html[EK-LM3S6965</A>]
+_Eagle-100=<A HREF="http://www.micromint.com/index.php/SBC/eagle-100.html[Eagle">http://www.micromint.com/index.php/SBC/eagle-100.html[Eagle</A> 100]
+_EK-LM3S9B92=<A HREF="http://www.luminarymicro.com/products/ek-lm3s9b92.html[EK-LM3S9B92">http://www.luminarymicro.com/products/ek-lm3s9b92.html[EK-LM3S9B92</A>]
+_ATEVK1100=<A HREF="http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114[ATEVK1100">http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114[ATEVK1100</A>]
+_SAM7-EX256=<A HREF="http://www.olimex.com/dev/sam7-ex256.html[SAM7-EX256">http://www.olimex.com/dev/sam7-ex256.html[SAM7-EX256</A>]
+_PUC-RioDemo=<A HREF="http://www.giga.puc-rio.br/site/embedded/eluademoboard[PUC-Rio">http://www.giga.puc-rio.br/site/embedded/eluademoboard[PUC-Rio</A> Demo]
+_LPC-H2888=<A HREF="http://www.olimex.com/dev/lpc-h2888.html[LPC-H2888">http://www.olimex.com/dev/lpc-h2888.html[LPC-H2888</A>]
+_MOD711=<A HREF="http://www.sctec.com.br/content/view/101/30/[MOD711">http://www.sctec.com.br/content/view/101/30/[MOD711</A>]
+_STR9-comStick=<A HREF="http://www.hitex.com/index.php?id=383[STR9-comStick">http://www.hitex.com/index.php?id=383[STR9-comStick</A>]
+_STR-E912=<A HREF="http://www.olimex.com/dev/str-e912.html[STR-E912">http://www.olimex.com/dev/str-e912.html[STR-E912</A>]
+_STM3210E-EVAL=<A HREF="http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html[STM3210E-EVAL">http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html[STM3210E-EVAL</A>]
+_ET-STM32Stamp=<A HREF="http://www.futurlec.com/ET-STM32_Stamp.shtml[ET-STM32">http://www.futurlec.com/ET-STM32_Stamp.shtml[ET-STM32</A> Stamp]
+_mbed=<A HREF="http://mbed.org/[mbed">http://mbed.org/[mbed</A>]
+_Mizar32=<A HREF="http://www.simplemachines.it/index.php?option=com_content&amp;view=article&amp;id=13&amp;Itemid=24[Mizar32">http://www.simplemachines.it/index.php?option=com_content&amp;view=article&amp;id=13&amp;Itemid=24[Mizar32</A>]
+_ATEVK1101=<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4175[ATEVK1101">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4175[ATEVK1101</A>]
+_EK-LM3S1968=<A HREF="http://www.luminarymicro.com/products/lm3s1968_evaluation_kits.html[EK-LM3S1968">http://www.luminarymicro.com/products/lm3s1968_evaluation_kits.html[EK-LM3S1968</A>]
+
+# Generic modules
+_mcpu=link:refman_gen_cpu.html[cpu]
+_mpio=link:refman_gen_pio.html[pio]
+_mtmr=link:refman_gen_tmr.html[tmr]
+_mpwm=link:refman_gen_pwm.html[pwm]
+_muart=link:refman_gen_uart.html[uart]
+_mspi=link:refman_gen_spi.html[spi]
+_mnet=link:refman_gen_net.html[net]
+_madc=link:refman_gen_adc.html[adc]
+_mpd=link:refman_gen_pd.html[pd]
+_mterm=link:refman_gen_term.html[term]
+_mbit=link:refman_gen_bit.html[bit]
+_mpack=link:refman_gen_pack.html[pack]
+_mcan=link:refman_gen_can.html[can]
+_mrpc=link:refman_gen_rpc.html[mrpc]
+_melua=link:refman_gen_elua.html[elua]
+_mi2c=link:refman_gen_i2c.html[i2c]
+
+# Platform dependent modules
+_mlm3sdisp=link:refman_ps_lm3s_disp.html[lm3s.disp]
+_mstr9pio=link:refman_ps_str9_pio.html[str9.pio]
+_mstr9rtc=link:refman_ps_str9_rtc.html[str9.rtc]
+_mmbedpio=link:refman_ps_mbed_pio.html[mbed.pio]
+
+# Miscellaneous
+_br=&lt;br /&gt;

Modified: trunk/doc/en/building.txt
===================================================================
--- trunk/doc/en/building.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/building.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -144,8 +144,21 @@
 o|BUILD_LINENOISE        |Enables linenoise support, check link:linenoise.html[here] for details. To enable:
 
   #define BUILD_LINENOISE
+
+xref:static[Static configuration data dependencies]: *LINENOISE_HISTORY_SIZE_LUA, LINENOISE_HISTORY_SIZE_SHELL, LINENOISE_AUTOSAVE_FNAME*
+
+o|BUILD_RFS              |Enables support for the remote file system, check link:arch_rfs.html[here] for details. To enable:
+
+  #define BUILD_RFS
+
+xref:static[Static configuration data dependencies]: *RFS_BUFFER_SIZE, RFS_UART_ID, RFS_UART_SPEED, RFS_TIMER_ID, RFS_FLOW_TYPE, RFS_TIMEOUT*
+
+o|BUILD_SERMUX           |Enables support for the serial multiplexer, check link:sermux.html[here] for details. To enable
+
+  #define BUILD_SERMUX
+
+xref:static[Static configuration data dependencies]: *SERMUX_PHYS_ID, SERMUX_PHYS_SPEED, SERMUX_FLOW_TYPE, SERMUX_NUM_VUART, SERMUX_BUFFER_SIZES*
   
-xref:static[Static configuration data dependencies]: *LINENOISE_HISTORY_SIZE_LUA, LINENOISE_HISTORY_SIZE_SHELL, LINENOISE_AUTOSAVE_FNAME*
 |===================================================================
 
 [[confmodules]]
@@ -267,6 +280,27 @@
 
 o|LINENOISE_AUTOSAVE_FNAME  |If linenoise support is enabled, the history will automatically be saved everytime the Lua interpreter exits in the filename specified 
 by this macro. Check link:linenoise.html[here] for details. This macro is optional; if it's not defined, the history will not be saved automatically.
+
+o|RFS_BUFFER_SIZE     |Size of the RFS buffer. Needs to be one of the *BUF_SIZE_xxx* constants defined in _inc/buf.h_
+o|RFS_UART_ID         |The ID of the UART that will be used by RFS. This is the physical connection over which the PC directory will be shared.
+o|RFS_UART_SPEED      |Communication speed of the RFS UART interface. 
+o|RFS_TIMER_ID        |The ID of a timer that will be used by RFS for internal operations
+o|RFS_FLOW_TYPE       |Flow control type on the serial RFS interface, see link:arch_platform_uart.html#flow_control_type[here] for details. 
+If not specified it defaults to \'no flow control'.
+o|RFS_TIMEOUT         |RFS operations timeout (in microseconds). If during a RFS operation no data is received from the PC side for the
+specified timeout, the RFS operation terminates with error.                        
+
+o|BUILD_SERMUX         |Enable serial multiplexer support in eLua. 
+o|SERMUX_PHYS_ID       |The ID of the physical UART interface used by the serial multiplexer.
+o|SERMUX_PHYS_SPEED    |Communication speed of the multiplexer UART interface. 
+o|SERMUX_FLOW_TYPE     |Flow control type on the physical serial multiplexer interface, see link:arch_platform_uart.html#flow_control_type[here] for details. 
+If not specified it defaults to \'no flow control'.
+o|SERMUX_NUM_VUART     |The number of virtual UART interfaces. This number can't be higher than 8. 
+o|SERMUX_BUFFER_SIZES  |An array of *SERMUX_NUM_VUART* integers that specify the buffer sizes for the virtual
+UART interfaces. Note that a virtual UART *MUST* have a buffer associated with it. The sizes are specified as
+*BUF_SIZE_xxx* constants defined in _inc/buf.h_                       
+
+
 |===================================================================
 
 The rest of the static configuration data parameters are meant to be modified mainly by developers and thus they're not listed here. +

Modified: trunk/doc/en/comunity.txt
===================================================================
--- trunk/doc/en/comunity.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/comunity.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -2,12 +2,9 @@
 [[lists]]
 Mailing lists
 -------------
-Currently eLua currently has a single *developers and users discussion list* You are very welcomed
-to join us at <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev.">https://lists.berlios.de/mailman/listinfo/elua-dev.</A> Please note that the list is moderated in order to avoid spam, so you
-need to join it if you want to post. Messages from non-members are rarely accepted.
+Currently eLua currently has a single developers and users discussion list. You are very welcomed
+to subscribe and join us at <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev.">https://lists.berlios.de/mailman/listinfo/elua-dev.</A>
 
-Our development repository is currently maintained in a Subversion server. If you want to track SVN activity, you can also subscribe to our 
-*SVN Activity List* at <A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn.">https://lists.berlios.de/mailman/listinfo/elua-svn.</A>
 
 [[forums]]
 Forums
@@ -18,14 +15,20 @@
 [[irc]]
 IRC
 ---
-`#elua` is the official IRC channel of eLua, it can be found on <A HREF="http://freenode.net[freenode">http://freenode.net[freenode</A>]. If you can't use an IRC client (for example because
+*#elua* is the official IRC channel of eLua, it can be found on <A HREF="http://freenode.net[freenode">http://freenode.net[freenode</A>]. If you can't use an IRC client (for example because
 your firewall blocks IRC ports) you can still try to access the IRC channel using the <A HREF="http://wiki.eluaproject.net/IRC[Web">http://wiki.eluaproject.net/IRC[Web</A> based client].
 The conversations on the IRC channel are logged and are available at <A HREF="http://irclogs.ls-themes.org/freenode/elua/logs.">http://irclogs.ls-themes.org/freenode/elua/logs.</A> + 
 And since you're on frenode, you might want to check the `#lua` channel as well (for discussions regarding the Lua language in general).
 
+[[twitter]]
+Twitter
+-------
+You can follow eLua news on our <A HREF="http://twitter.com/#!/eluaproject[Twitter">http://twitter.com/#!/eluaproject[Twitter</A>
+channel]
+
 [[userswiki]]
-eLua User Labs
---------------
+eLua Wiki
+---------
 eLua users maintain a wiki with projects, code examples, tutorials and media at <A HREF="http://wiki.eluaproject.net.">http://wiki.eluaproject.net.</A>
 
 [[credits]]
@@ -49,7 +52,7 @@
 - Sergio Sorrenti and Martin Guy - AVR32 support, <A HREF="http://www.simplemachines.it/index.php?option=com_content&amp;view=article&amp;id=13&amp;Itemid=24[Mizar32">http://www.simplemachines.it/index.php?option=com_content&amp;view=article&amp;id=13&amp;Itemid=24[Mizar32</A>] port, testing
 - T&#233;o Benjamin, Ives Cunha, Rafael Barmak - Pong, TetrIves, SpaceShip games and <A HREF="http://wiki.eluaproject.net/Manfredo[Manfredo">http://wiki.eluaproject.net/Manfredo[Manfredo</A>], a GPS guided robot, powered by eLua.
 - Vagner Nascimento and Carlos Eduardo Deodoro - eLua Web Builder
-- The eLua users community on our <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev[discussion">https://lists.berlios.de/mailman/listinfo/elua-dev[discussion</A> list] and <A HREF="http://wiki.eluaproject.net[eLua">http://wiki.eluaproject.net[eLua</A> User Labs]
+- The eLua users community on our <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev[discussion">https://lists.berlios.de/mailman/listinfo/elua-dev[discussion</A> list] and <A HREF="http://wiki.eluaproject.net[eLua">http://wiki.eluaproject.net[eLua</A> Wiki]
 
 \... and the constant help and support from:
  
@@ -61,11 +64,19 @@
 [[donations]]
 Donations
 ---------
+We would like to thank the following donations for the development of the
+project. If you feel like contributing with any kind of donation, you can
+contact us in our
+<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev[Discussion">https://lists.berlios.de/mailman/listinfo/elua-dev[Discussion</A> List] or the
+authors link:overview.html#authors[privately]
+
 - Cristina Sampaio and <A HREF="http://www.ti.com/ww/br[Texas">http://www.ti.com/ww/br[Texas</A> Instruments Brasil] - EK-LM3S6965 LM3S Cortex-M3 kits
 - Jos&#233; Palazzi and <A HREF="http://www.freescale.com/webapp/sps/site/homepage.jsp?code=BRAZIL[Freescale">http://www.freescale.com/webapp/sps/site/homepage.jsp?code=BRAZIL[Freescale</A> Brazil] - Coldfire dev kits, eLua support
-- <A HREF="http://www.olimex.com/[Olimex">http://www.olimex.com/[Olimex</A>] - Dev kits and accessories
+- <A HREF="http://www.luminarymicro.com/[Luminary">http://www.luminarymicro.com/[Luminary</A> Micro] - LM3S evaluation kits
+- <A HREF="http://mbed.org/[mbed">http://mbed.org/[mbed</A>] - NXP1768 mbed kit
 - Raul Nunes &amp; <A HREF="http://www.puc-rio.br[PUC-Rio">http://www.puc-rio.br[PUC-Rio</A>] - ET-STM32 and Netduino kits, PUC-Rio eLua Demo Board
-- Sergio Sorrenti and <A HREF="http://www.simplemachines.it[SimpleMachines">http://www.simplemachines.it[SimpleMachines</A>] - EVK-1101 kits, Dragon AVR32 programmers, Mizar32 and shields, strong eLua support 
+- Sergio Sorrenti and <A HREF="http://www.simplemachines.it[SimpleMachines">http://www.simplemachines.it[SimpleMachines</A>] - EVK-1101 kits, Dragon AVR32 programmers, Mizar32 and shields, strong eLua support
+- <A HREF="http://www.st.com[ST">http://www.st.com[ST</A> Microelectronics] - a STM3210E-EVAL and a STR9-comStick
 
 // $$FOOTER$$
 

Modified: trunk/doc/en/dl_old.html
===================================================================
--- trunk/doc/en/dl_old.html	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/dl_old.html	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,6 +1,164 @@
 $$HEADER$$
 &lt;h3&gt;Downloading eLua Old Versions&lt;/h3&gt;
 &lt;p&gt;The tables below have links to the previous official versions of &lt;b&gt;eLua&lt;/b&gt; (both source code and binaries).&lt;/p&gt;
+
+&lt;a name=&quot;v070&quot; /&gt;&lt;h2&gt;0.7&lt;/h2&gt;
+&lt;table class=&quot;table_center&quot;&gt;
+&lt;tbody&gt;
+&lt;tr&gt;
+&lt;th&gt;Version&lt;/th&gt;
+&lt;th&gt;MCU&lt;/th&gt;
+
+&lt;th&gt;Board&lt;/th&gt;
+&lt;th&gt;Lua number type&lt;/th&gt;
+&lt;th&gt;Image file&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.luminarymicro.com/products/LM3S8962.html">http://www.luminarymicro.com/products/LM3S8962.html</A>&quot;&gt;LM3S8962&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html</A>&quot;&gt;EK-LM3S8962&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s8962.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s8962.bin</A>&quot;&gt;elua0.7_lua_lm3s8962.bin&lt;/a&gt;&lt;/td&gt;
+
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s6965.html">http://www.luminarymicro.com/products/lm3s6965.html</A>&quot;&gt;LM3S6965&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html</A>&quot;&gt;EK-LM3S6965&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6965.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6965.bin</A>&quot;&gt;elua0.7_lua_lm3s6965.bin&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.luminarymicro.com/products/LM3S6918.html">http://www.luminarymicro.com/products/LM3S6918.html</A>&quot;&gt;LM3S6918&lt;/a&gt;&lt;/td&gt;
+
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.micromint.com/index.php/SBC/eagle-100.html">http://www.micromint.com/index.php/SBC/eagle-100.html</A>&quot;&gt;Micromint Eagle
+100&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6918.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6918.bin</A>&quot;&gt;elua0.7_lua_lm3s918.bin&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s9b92.html">http://www.luminarymicro.com/products/lm3s9b92.html</A>&quot;&gt;LM3S9B92&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.luminarymicro.com/products/ek-lm3s9b92.html">http://www.luminarymicro.com/products/ek-lm3s9b92.html</A>&quot;&gt;EK-LM3S9B92&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s9b92.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s9b92.bin</A>&quot;&gt;elua0.7_lua_lm3s9b92.bin&lt;/a&gt;&lt;/td&gt;
+
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755">http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755</A>&quot;&gt;AT91SAM7X256&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.olimex.com/dev/sam7-ex256.html">http://www.olimex.com/dev/sam7-ex256.html</A>&quot;&gt;SAM7-EX256&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x256.bin">http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x256.bin</A>&quot;&gt;elua0.7_lua_at91sam7x256.bin&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104">http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104</A>&quot;&gt;AT91SAM7X512&lt;/a&gt;&lt;/td&gt;
+
+&lt;td&gt;None&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x512.bin">http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x512.bin</A>&quot;&gt;elua0.7_lua_at91sam7x512.bin&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4117">http://www.atmel.com/dyn/products/product_card.asp?part_id=4117</A>&quot;&gt;AT32UC3A0512&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114">http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114</A>&quot;&gt;ATEVK1100&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_at32uc3a0512.hex">http://prdownload.berlios.de/elua/elua0.7_lua_at32uc3a0512.hex</A>&quot;&gt;elua0.7_lua_at32uc3a0512.hex&lt;/a&gt;&lt;/td&gt;
+
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html">http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html</A>&quot;&gt;LPC2888&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.olimex.com/dev/lpc-h2888.html">http://www.olimex.com/dev/lpc-h2888.html</A>&quot;&gt;LPC-H2888&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lpc2888.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lpc2888.bin</A>&quot;&gt;elua0.7_lua_lpc2888.bin&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.nxp.com/#/pip/pip=[pip=LPC2468_4">http://www.nxp.com/#/pip/pip=[pip=LPC2468_4</A>]%7Cpp=[t=pip,i=LPC2468_4]&quot;&gt;LPC2468&lt;/a&gt;&lt;/td&gt;
+
+&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.giga.puc-rio.br/site/embedded/eluademoboard">http://www.giga.puc-rio.br/site/embedded/eluademoboard</A>&quot;&gt;PUC-Rio
+eLua board&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lpc2468.hex">http://prdownload.berlios.de/elua/elua0.7_lua_lpc2468.hex</A>&quot;&gt;elua0.7_lua_lpc2468.hex&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STR711FR2.html">http://www.st.com/mcu/devicedocs-STR711FR2.html</A>&quot;&gt;STR711FR2&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.sctec.com.br/content/view/101/30/">http://www.sctec.com.br/content/view/101/30/</A>&quot;&gt;MOD711&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_str711fr2.bin">http://prdownload.berlios.de/elua/elua0.7_lua_str711fr2.bin</A>&quot;&gt;elua0.7_lua_str711fr2.bin&lt;/a&gt;&lt;/td&gt;
+
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STR912FAW44-101.html">http://www.st.com/mcu/devicedocs-STR912FAW44-101.html</A>&quot;&gt;STR912FAW44&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.olimex.com/dev/str-e912.html">http://www.olimex.com/dev/str-e912.html</A>&quot;&gt;STR-E912&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_str912faw44.bin">http://prdownload.berlios.de/elua/elua0.7_lua_str912faw44.bin</A>&quot;&gt;elua0.7_lua_str912faw44.bin&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STM32F103RE-110.html">http://www.st.com/mcu/devicedocs-STM32F103RE-110.html</A>&quot;&gt;STM32F103RE&lt;/a&gt;&lt;/td&gt;
+
+&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.futurlec.com/ET-STM32_Stamp.shtml">http://www.futurlec.com/ET-STM32_Stamp.shtml</A>&quot;&gt;ET-STM32
+Stamp&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103re.bin">http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103re.bin</A>&quot;&gt;elua0.7_lua_stm32f103re.bin&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html">http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html</A>&quot;&gt;STM32F103ZE&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html">http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html</A>&quot;&gt;STM3210E-EVAL&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103ze.bin">http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103ze.bin</A>&quot;&gt;elua0.7_lua_stm32f103ze.bin&lt;/a&gt;&lt;/td&gt;
+
+&lt;/tr&gt;
+&lt;tr&gt;
+&lt;td&gt;0.7&lt;/td&gt;
+&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.intel.com">http://www.intel.com</A>&quot;&gt;i386 (generic)&lt;/a&gt;&lt;/td&gt;
+&lt;td&gt;PCs/emulators&lt;/td&gt;
+&lt;td&gt;double&lt;/td&gt;
+&lt;td&gt;&lt;a
+href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_i386.elf">http://prdownload.berlios.de/elua/elua0.7_lua_i386.elf</A>&quot;&gt;elua0.7_lua_i386.elf&lt;/a&gt;&lt;/td&gt;
+&lt;/tr&gt;
+&lt;/tbody&gt;
+&lt;/table&gt;
+
 &lt;a name=&quot;v060&quot; /&gt;&lt;h2&gt;0.6&lt;/h2&gt;
 &lt;table class=&quot;table_center&quot;&gt;
 &lt;tbody&gt;

Deleted: trunk/doc/en/downloads.html
===================================================================
--- trunk/doc/en/downloads.html	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/downloads.html	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,226 +0,0 @@
-$$HEADER$$
-&lt;h3&gt;Downloading eLua&lt;/h3&gt;
-&lt;p&gt;You have a few options for downloading &lt;b&gt;eLua&lt;/b&gt;:&lt;/p&gt;
-&lt;ul&gt;
-  &lt;li&gt;download a binary &lt;b&gt;eLua&lt;/b&gt; image for the platform of your choice. Binary images are provided with each official release
-  and also for some specific applications (ie: games). This is generally the best option if you have a
-  board that's officially
-  supported by &lt;b&gt;eLua&lt;/b&gt; (see &lt;a href=&quot;status.html&quot;&gt;here&lt;/a&gt; for details) and you want to have &lt;b&gt;eLua&lt;/b&gt; up and running on your board as quickly as possible.&lt;/li&gt;
-  &lt;li&gt;download the source code to build &lt;b&gt;eLua&lt;/b&gt; yourself. You can either download the source code of an official release or get the &quot;bleeding edge&quot; version from the SVN repository. Download the source code instead of a
-  binary image if you need to make adjustments to the source code to support your board, or if you want to customize the &lt;b&gt;eLua&lt;/b&gt; image, or if you simply want to take a look at what 
-  happens behind the &lt;i&gt;eLua# &lt;/i&gt; prompt :)&lt;/li&gt;
-&lt;/ul&gt;
-&lt;a name=&quot;binaries&quot; /&gt;&lt;h3&gt;Binary images&lt;/h3&gt;
-&lt;p&gt;Pre-built images of &lt;b&gt;eLua&lt;/b&gt; can be downloaded for each official release. Only the latest official &lt;b&gt;eLua&lt;/b&gt; release is covered in this
-paragraph. If you want to download a pre-built image from an older release (although this isn't generally advisable), check &lt;a href=&quot;dl_old.html&quot;&gt;this page&lt;/a&gt;. 
-&lt;/p&gt;
-&lt;p&gt;Choose the corresponding image file from the table below, flash it into your
-board, connect a serial terminal (or Ethernet if you board supports) and enjoy &lt;b&gt;eLua&lt;/b&gt;. 
-Please also note that &lt;b&gt;eLua binaries&lt;/b&gt;, like the &lt;a href=&quot;#source&quot;&gt;source code distribution&lt;/a&gt;,
-include some example programs in it's file system, so you can run and play (yes! we have games too! :) them , following the instructions in our &lt;a href=&quot;using.html&quot;&gt;Using eLua&lt;/a&gt; page. 
-The available example programs are described in our &lt;a href=&quot;examples.html&quot;&gt;examples page&lt;/a&gt;.
-&lt;/p&gt;
-&lt;p&gt;
-If you need a customized binary image for an already supported platform (for example with an autorun program, with some code of yours in the file system, with your LAN IP settings) and the
-&lt;a href=&quot;building.html&quot;&gt;instructions for building eLua&lt;/a&gt; didn't work for you, feel free to
-ask for one in &lt;a href=&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>&quot;&gt;our discussion
-list&lt;/a&gt; explaining what you need. We may find some time to
-build one for you and eventually make it available here too.
-&lt;/p&gt;
-&lt;h2&gt;Official Latest Release Binaries&lt;/h2&gt;
-&lt;p&gt;
-To understand what's in a file name (for example &lt;i&gt;elua_lualong_lm3s8962.bin&lt;/i&gt;) check our &lt;a href=&quot;building.html&quot;&gt;building eLua&lt;/a&gt; page.
-&lt;/p&gt;
-&lt;table class=&quot;table_center&quot;&gt;
-&lt;tbody&gt;
-&lt;tr&gt;
-&lt;th&gt;Version&lt;/th&gt;
-&lt;th&gt;MCU&lt;/th&gt;
-&lt;th&gt;Board&lt;/th&gt;
-&lt;th&gt;Lua number type&lt;/th&gt;
-&lt;th&gt;Image file&lt;/th&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/LM3S8962.html">http://www.luminarymicro.com/products/LM3S8962.html</A>&quot;&gt;LM3S8962&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html</A>&quot;&gt;EK-LM3S8962&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s8962.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s8962.bin</A>&quot;&gt;elua0.7_lua_lm3s8962.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s6965.html">http://www.luminarymicro.com/products/lm3s6965.html</A>&quot;&gt;LM3S6965&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html</A>&quot;&gt;EK-LM3S6965&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6965.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6965.bin</A>&quot;&gt;elua0.7_lua_lm3s6965.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/LM3S6918.html">http://www.luminarymicro.com/products/LM3S6918.html</A>&quot;&gt;LM3S6918&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.micromint.com/index.php/SBC/eagle-100.html">http://www.micromint.com/index.php/SBC/eagle-100.html</A>&quot;&gt;Micromint Eagle 100&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6918.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s6918.bin</A>&quot;&gt;elua0.7_lua_lm3s918.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s9b92.html">http://www.luminarymicro.com/products/lm3s9b92.html</A>&quot;&gt;LM3S9B92&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/ek-lm3s9b92.html">http://www.luminarymicro.com/products/ek-lm3s9b92.html</A>&quot;&gt;EK-LM3S9B92&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lm3s9b92.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lm3s9b92.bin</A>&quot;&gt;elua0.7_lua_lm3s9b92.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755">http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755</A>&quot;&gt;AT91SAM7X256&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.olimex.com/dev/sam7-ex256.html">http://www.olimex.com/dev/sam7-ex256.html</A>&quot;&gt;SAM7-EX256&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x256.bin">http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x256.bin</A>&quot;&gt;elua0.7_lua_at91sam7x256.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104">http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104</A>&quot;&gt;AT91SAM7X512&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;None&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x512.bin">http://prdownload.berlios.de/elua/elua0.7_lua_at91sam7x512.bin</A>&quot;&gt;elua0.7_lua_at91sam7x512.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4117">http://www.atmel.com/dyn/products/product_card.asp?part_id=4117</A>&quot;&gt;AT32UC3A0512&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114">http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114</A>&quot;&gt;ATEVK1100&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_at32uc3a0512.hex">http://prdownload.berlios.de/elua/elua0.7_lua_at32uc3a0512.hex</A>&quot;&gt;elua0.7_lua_at32uc3a0512.hex&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html">http://www.standardics.nxp.com/microcontrollers/to/pip/LPC2880FET180.html</A>&quot;&gt;LPC2888&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.olimex.com/dev/lpc-h2888.html">http://www.olimex.com/dev/lpc-h2888.html</A>&quot;&gt;LPC-H2888&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lpc2888.bin">http://prdownload.berlios.de/elua/elua0.7_lua_lpc2888.bin</A>&quot;&gt;elua0.7_lua_lpc2888.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.nxp.com/#/pip/pip=[pip=LPC2468_4">http://www.nxp.com/#/pip/pip=[pip=LPC2468_4</A>]|pp=[t=pip,i=LPC2468_4]&quot;&gt;LPC2468&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.giga.puc-rio.br/site/embedded/eluademoboard">http://www.giga.puc-rio.br/site/embedded/eluademoboard</A>&quot;&gt;PUC-Rio eLua board&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a
-href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_lpc2468.hex">http://prdownload.berlios.de/elua/elua0.7_lua_lpc2468.hex</A>&quot;&gt;elua0.7_lua_lpc2468.hex&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STR711FR2.html">http://www.st.com/mcu/devicedocs-STR711FR2.html</A>&quot;&gt;STR711FR2&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.sctec.com.br/content/view/101/30/">http://www.sctec.com.br/content/view/101/30/</A>&quot;&gt;MOD711&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_str711fr2.bin">http://prdownload.berlios.de/elua/elua0.7_lua_str711fr2.bin</A>&quot;&gt;elua0.7_lua_str711fr2.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STR912FAW44-101.html">http://www.st.com/mcu/devicedocs-STR912FAW44-101.html</A>&quot;&gt;STR912FAW44&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.olimex.com/dev/str-e912.html">http://www.olimex.com/dev/str-e912.html</A>&quot;&gt;STR-E912&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_str912faw44.bin">http://prdownload.berlios.de/elua/elua0.7_lua_str912faw44.bin</A>&quot;&gt;elua0.7_lua_str912faw44.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STM32F103RE-110.html">http://www.st.com/mcu/devicedocs-STM32F103RE-110.html</A>&quot;&gt;STM32F103RE&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.futurlec.com/ET-STM32_Stamp.shtml">http://www.futurlec.com/ET-STM32_Stamp.shtml</A>&quot;&gt;ET-STM32 Stamp&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103re.bin">http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103re.bin</A>&quot;&gt;elua0.7_lua_stm32f103re.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html">http://www.st.com/mcu/devicedocs-STM32F103ZE-110.html</A>&quot;&gt;STM32F103ZE&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html">http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html</A>&quot;&gt;STM3210E-EVAL&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103ze.bin">http://prdownload.berlios.de/elua/elua0.7_lua_stm32f103ze.bin</A>&quot;&gt;elua0.7_lua_stm32f103ze.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://www.intel.com">http://www.intel.com</A>&quot;&gt;i386 (generic)&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;PCs/emulators&lt;/td&gt;
-&lt;td&gt;double&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7_lua_i386.elf">http://prdownload.berlios.de/elua/elua0.7_lua_i386.elf</A>&quot;&gt;elua0.7_lua_i386.elf&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/tbody&gt;
-&lt;/table&gt;
-&lt;p&gt;
-&lt;b&gt;NOTE:&lt;/b&gt; &lt;i&gt;Lua number type&lt;/i&gt; refers to the built Lua interpreter number type, float or integer, as explained in the &lt;a href=&quot;building.html&quot;&gt;building eLua&lt;/a&gt; page.
-&lt;h2&gt;Official Custom Build Binaries&lt;/h2&gt;
-&lt;p&gt;
-Besides the regular &lt;b&gt;eLua&lt;/b&gt; binary images (above), which also come bundled
-with examples on the rom file system, we offer here some custom build
-images with programs for specific boards and/or specific
-aplications. They are ready to be flashed directly on your kits and usually
-run automatically using our autorun feature (see &lt;a
-href=&quot;<A HREF="http://www.eluaproject.net/en_arch_overview.html#boot">http://www.eluaproject.net/en_arch_overview.html#boot</A>&quot;&gt;booting
-&lt;b&gt;eLua&lt;/b&gt;&lt;/a&gt; for details).
-If you own one of the supported boards listed below, just
-download a binary image, flash it on the kit and enjoy it. If you write nice
-and ilustrative programs, don't hesitate to share and we'll publish
-them in ready-to-use, custom built, binary images too.
-&lt;/p&gt;
-&lt;table class=&quot;table_center&quot;&gt;
-&lt;tbody&gt;
-&lt;tr&gt;
-&lt;th&gt;Aplication description&lt;/th&gt;
-&lt;th&gt;Board&lt;/th&gt;
-&lt;th&gt;Image file&lt;/th&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;EK-LM3S8962 Games &amp; Demos&lt;/td&gt;
-&lt;td&gt;&lt;a
-href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html</A>&quot;&gt;EK-LM3S8962&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;&lt;a
-href=&quot;./downloads/elua_games_EK-LM3S8962.bin&quot;&gt;elua_games_EK-LM3S8962.bin&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;EK-LM3S6965 Games &amp; Demos&lt;/td&gt;
-&lt;td&gt;&lt;a
-href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html</A>&quot;&gt;EK-LM3S6965&lt;/a&gt;&lt;/td&gt;
-&lt;td&gt;(comming soon!)&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/table&gt;
-&lt;p/&gt;
-&lt;a name=&quot;source&quot; /&gt;&lt;h3&gt;Source code&lt;/h3&gt;
-&lt;p&gt;If all you want is to take a quick peek at &lt;b&gt;eLua&lt;/b&gt;'s source code, but you don't need to download it, it's probably enough to use the 
-&lt;a href=&quot;<A HREF="http://svn.berlios.de/wsvn/elua">http://svn.berlios.de/wsvn/elua</A>&quot;&gt;BerliOS WebSVN interface&lt;/a&gt;. You can browse through the complete source of &lt;b&gt;eLua&lt;/b&gt; using this method.&lt;br /&gt;
-If you need to download the source code of &lt;b&gt;eLua&lt;/b&gt; you can either:&lt;/p&gt;
-&lt;ul&gt;
-  &lt;li&gt;download the source code archive of an official release&lt;/li&gt;
-  &lt;li&gt;checkout the latest (bleeding edge) source code from the SVN repository in read-only mode (anonymous) mode&lt;/li&gt;
-  &lt;li&gt;checkout the latest (bleeding edge) source code from the SVN repository in read-write mode (for developers)&lt;/li&gt;
-&lt;/ul&gt;
-&lt;a name=&quot;official&quot; /&gt;&lt;h2&gt;Source code archives&lt;/h2&gt;&lt;/a&gt;
-&lt;p&gt;Check the table below for the download link of the source code associated with the latest official release of &lt;b&gt;eLua&lt;/b&gt;. If you want to get the source
-code of an older version, check out &lt;a href=&quot;dl_old.html&quot;&gt;this page.&lt;/p&gt;
-&lt;!-- [NEWVER] --&gt;
-&lt;table class=&quot;table_center&quot;&gt;
-&lt;tbody&gt;
-&lt;tr&gt;
-&lt;th&gt;Version&lt;/th&gt;
-&lt;th&gt;Source code archive&lt;/th&gt;
-&lt;/tr&gt;
-&lt;tr&gt;
-&lt;td&gt;0.7&lt;/td&gt;
-&lt;td&gt;&lt;a href=&quot;<A HREF="http://prdownload.berlios.de/elua/elua0.7.tgz">http://prdownload.berlios.de/elua/elua0.7.tgz</A>&quot;&gt;eLua 0.7&lt;/a&gt;&lt;/td&gt;
-&lt;/tr&gt;
-&lt;/tbody&gt;&lt;/table&gt;
-&lt;a name=&quot;svnpublic&quot; /&gt;&lt;h2&gt;SVN public repository (anonymous read-only mode)&lt;/h2&gt;
-&lt;p&gt;If you'd rather have the very last development (&quot;bleeding edge&quot;) version, just check it out from our Subversion Repository:&lt;/p&gt;
-&lt;pre&gt;$ svn checkout <A HREF="svn://svn.berlios.de/elua/trunk&lt;/pre">svn://svn.berlios.de/elua/trunk&lt;/pre</A>&gt;
-&lt;p&gt;Once checked out, the repository can be easily updated by the svn client command:&lt;/p&gt;
-&lt;pre&gt;$ svn update&lt;/pre&gt;
-&lt;a name=&quot;svndev&quot; /&gt;&lt;h2&gt;SVN public repository (authenticated login r/w mode, for developers)&lt;/h2&gt;
-&lt;p&gt;Follow the steps below if you need write access to the &lt;b&gt;eLua&lt;/b&gt; repository:&lt;/p&gt;
-&lt;ul&gt;
-  &lt;li&gt;if you don't have an account on &lt;a href=&quot;<A HREF="http://developer.berlios.de/">http://developer.berlios.de/</A>&quot;&gt;developer.berlios.de&lt;/a&gt;
-  and you plan to contribute with code for the project, please create one.&lt;/li&gt;
-  &lt;li&gt;&lt;a href=&quot;overview.html#contacts&quot;&gt;contact us&lt;/a&gt; specifying your BerliOS ID and we'll give you write
-  (commit) access to the subversion repository.&lt;/li&gt;
-&lt;/ul&gt;
-&lt;p&gt;Then checkout the repository:&lt;/p&gt;
-&lt;pre&gt;$ export SVN_SSH='ssh -l &lt;yourberliosid&gt;'
-$ svn checkout svn+<A HREF="ssh://svn.berlios.de/svnroot/repos/elua/trunk&lt;/pre">ssh://svn.berlios.de/svnroot/repos/elua/trunk&lt;/pre</A>&gt;
-&lt;p&gt;Once checked out, the repository can be easily updated:&lt;/p&gt;
-&lt;pre&gt;$ svn update&lt;/pre&gt;
-
-$$FOOTER$$
-

Copied: trunk/doc/en/downloads.txt (from rev 948, branches/pre0.8/doc/en/downloads.txt)
===================================================================
--- trunk/doc/en/downloads.txt	                        (rev 0)
+++ trunk/doc/en/downloads.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -0,0 +1,114 @@
+// $$HEADER$$
+
+Downloading eLua
+----------------
+You have a few options for downloading eLua:
+
+- download a binary eLua image for the platform of your choice. Binary images are provided with each official release. This is generally the best option if you have a
+  board that's officially supported by eLua (see link:status.html[here] for details) and you want to have eLua up and running on your board as quickly as possible.
+- download the source code to build eLua yourself. You can either download the source code of an official release or get the &quot;bleeding edge&quot; version from the SVN repository. 
+  Download the source code instead of a binary image if you need to make adjustments to the source code to support your board, or if you want to customize the eLua image, 
+  or if you simply want to take a look at what  happens behind the _eLua#_ prompt :)
+
+[[binaries]]
+Binary images
+-------------
+Pre-built images of eLua can be downloaded for each official release. Only the latest official eLua release is covered in this paragraph. If you want to download a 
+pre-built image from an older release (although this isn't generally advisable), check link:dl_old.html[this page]. +
+ +
+Choose the corresponding image file from the table below, flash it into your board, connect a serial terminal (or Ethernet if you board supports it) and enjoy eLua. +
+ +
+If you need a customized binary image for an already supported platform (for example with an autorun program, with some code of yours in the file system, with your LAN IP settings) 
+and the link:building.html[instructions for building eLua] didn't work for you, feel free to ask for one in <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev[our">https://lists.berlios.de/mailman/listinfo/elua-dev[our</A> discussion
+list] explaining what you need. We may find some time to build one for you and eventually make it available here too. Alternatively you can try our 
+<A HREF="http://builder.eluaproject.net[web">http://builder.eluaproject.net[web</A> builder service] that makes building an eLua image much easier.
+
+Latest official release binaries
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+To understand what's in a file name (for example _elua_lualong_lm3s8962.bin_) check our link:building.html[building eLua] page.
+
+[width=&quot;80%&quot;, cols=&quot;&lt;1, &lt;2, &lt;3, &lt;3, &lt;4&quot;, options=&quot;header&quot;]
+|=====================================================================================
+^| Version ^| MCU           ^|    Board             ^| Lua number type  ^| Image file
+| 0.8       |  _LM3S8962     |    _EK-LM3S8962       |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_lm3s8962.bin[elua0.8_lua_lm3s8962.bin">http://prdownload.berlios.de/elua/elua0.8_lua_lm3s8962.bin[elua0.8_lua_lm3s8962.bin</A>]
+| 0.8       |  _LM3S6965     |    _EK-LM3S6965       |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_lm3s6965.bin[elua0.8_lua_lm3s6965.bin">http://prdownload.berlios.de/elua/elua0.8_lua_lm3s6965.bin[elua0.8_lua_lm3s6965.bin</A>]
+| 0.8       |  _LM3S6918     |    _Eagle-100         |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_lm3s6918.bin[elua0.8_lua_lm3s6918.bin">http://prdownload.berlios.de/elua/elua0.8_lua_lm3s6918.bin[elua0.8_lua_lm3s6918.bin</A>]
+| 0.8       |  _LM3S9B92     |    _EK-LM3S9B92       |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_lm3s9b92.bin[elua0.8_lua_lm3s9b92.bin">http://prdownload.berlios.de/elua/elua0.8_lua_lm3s9b92.bin[elua0.8_lua_lm3s9b92.bin</A>]
+| 0.8       |  _LM3S1968     |    _EK-LM3S1968       |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_lm3s1968.bin[elua0.8_lua_lm3s1968.bin">http://prdownload.berlios.de/elua/elua0.8_lua_lm3s1968.bin[elua0.8_lua_lm3s1968.bin</A>]
+| 0.8       |  _AT91SAM7X256 |    _SAM7-EX256        |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_at91sam7x256.bin[elua0.8_lua_at91sam7x256.bin">http://prdownload.berlios.de/elua/elua0.8_lua_at91sam7x256.bin[elua0.8_lua_at91sam7x256.bin</A>]
+| 0.8       |  _AT91SAM7X512 |    None               |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_at91sam7x512.bin[elua0.8_lua_at91sam7x512.bin">http://prdownload.berlios.de/elua/elua0.8_lua_at91sam7x512.bin[elua0.8_lua_at91sam7x512.bin</A>]
+| 0.8       |  _AT32UC3A0512 |    _ATEVK1100         |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_at32uc3a0512.hex[elua0.8_lua_at32uc3a0512.hex">http://prdownload.berlios.de/elua/elua0.8_lua_at32uc3a0512.hex[elua0.8_lua_at32uc3a0512.hex</A>]
+| 0.8       |  _AT32UC3B0256 |    _ATEVK1101         |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_at32uc3b0256.hex[elua0.8_lua_at32uc3b0256.hex">http://prdownload.berlios.de/elua/elua0.8_lua_at32uc3b0256.hex[elua0.8_lua_at32uc3b0256.hex</A>]
+| 0.8       |  _AT32UC3A0128 |    _Mizar32           |  long             | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lualong_at32uc3a0128.hex[elua0.8_lualong_at32uc3a0128.hex">http://prdownload.berlios.de/elua/elua0.8_lualong_at32uc3a0128.hex[elua0.8_lualong_at32uc3a0128.hex</A>]
+| 0.8       |  _LPC2888      |    _LPC-H2888         |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_lpc2888.bin[elua0.8_lua_lpc2888.bin">http://prdownload.berlios.de/elua/elua0.8_lua_lpc2888.bin[elua0.8_lua_lpc2888.bin</A>]
+| 0.8       |  _LPC2468      |    _PUC-RioDemo       |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_lpc2468.hex[elua0.8_lua_lpc2468.hex">http://prdownload.berlios.de/elua/elua0.8_lua_lpc2468.hex[elua0.8_lua_lpc2468.hex</A>]
+| 0.8       |  _STR711FR2    |    _MOD711            |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_str711fr2.bin[elua0.8_lua_str711fr2.bin">http://prdownload.berlios.de/elua/elua0.8_lua_str711fr2.bin[elua0.8_lua_str711fr2.bin</A>]
+| 0.8       |  _STR912FAW44  |    _STR-E912          |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_str912faw44.bin[elua0.8_lua_str912faw44.bin">http://prdownload.berlios.de/elua/elua0.8_lua_str912faw44.bin[elua0.8_lua_str912faw44.bin</A>]
+| 0.8       |  _STM32F103RE  |    _ET-STM32Stamp     |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_stm32f103re.bin[elua0.8_lua_stm32f103re.bin">http://prdownload.berlios.de/elua/elua0.8_lua_stm32f103re.bin[elua0.8_lua_stm32f103re.bin</A>]
+| 0.8       |  _STM32F103ZE  |    _STM3210E-EVAL     |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_stm32f103ze.bin[elua0.8_lua_stm32f103ze.bin">http://prdownload.berlios.de/elua/elua0.8_lua_stm32f103ze.bin[elua0.8_lua_stm32f103ze.bin</A>]
+| 0.8       |  _I386         |    PCs/emulators      |  double           | <A HREF="http://prdownload.berlios.de/elua/elua0.8_lua_i386.elf[elua0.8_lua_i386.elf">http://prdownload.berlios.de/elua/elua0.8_lua_i386.elf[elua0.8_lua_i386.elf</A>]
+|=====================================================================================
+
+NOTE: __Lua number type__ refers to the built Lua interpreter number type, float or integer, as explained in the link:building.html[building eLua] page.
+
+[[source]]
+Source code
+-----------
+If all you want is to take a quick peek at eLua's source code, but you don't need to download it, it's probably enough to use the 
+<A HREF="http://svn.berlios.de/wsvn/elua[BerliOS">http://svn.berlios.de/wsvn/elua[BerliOS</A> WebSVN interface]. You can browse through the complete source of eLua using this method. +
+If you need to download the source code of eLua you can either:
+
+- download the source code archive of an official release
+- checkout the latest (bleeding edge) source code from the SVN repository in read-only mode (anonymous) mode
+- checkout the latest (bleeding edge) source code from the SVN repository in read-write mode (for developers)
+
+[[official]]
+Source code archives
+~~~~~~~~~~~~~~~~~~~~
+Check the table below for the download link of the source code associated with the latest official release of eLua. If you want to get the source
+code of an older version check out link:dl_old.html[this page].
+
+[width=&quot;35%&quot;, cols=&quot;&lt;1, &lt;3&quot;, options=&quot;header&quot;]
+|=================================
+^| Version ^| Source code archive
+| 0.8       | <A HREF="http://prdownload.berlios.de/elua/elua0.8.tgz[eLua">http://prdownload.berlios.de/elua/elua0.8.tgz[eLua</A> 0.8]
+|=====================================================================================
+
+[[svnpublic]]
+SVN public repository (anonymous read-only mode)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+If you'd rather have the very last development (&quot;bleeding edge&quot;) version, just check it out from our Subversion Repository:
+
+----------------------------------------------
+$ svn checkout <A HREF="svn://svn.berlios.de/elua/trunk">svn://svn.berlios.de/elua/trunk</A>
+----------------------------------------------
+
+Once checked out, the repository can be easily updated by the svn client command:
+
+------------
+$ svn update
+------------
+
+[[svndev]]
+SVN public repository (authenticated login r/w mode, for developers)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Follow the steps below if you need write access to the eLua repository:
+
+- if you don't have an account on <A HREF="http://developer.berlios.de[developer.berlios.de">http://developer.berlios.de[developer.berlios.de</A>] and you plan to contribute with code for the project, please create one.
+- link:overview.html#contacts[contact us] specifying your BerliOS ID and we'll give you write (commit) access to the subversion repository.
+
+Then checkout the repository:
+
+----------------------------------------------------------------
+$ export SVN_SSH='ssh -l &lt;your_berlios_id&gt;'
+$ svn checkout svn+<A HREF="ssh://svn.berlios.de/svnroot/repos/elua/trunk">ssh://svn.berlios.de/svnroot/repos/elua/trunk</A>
+----------------------------------------------------------------
+
+Once checked out, the repository can be easily updated:
+
+------------
+$ svn update
+------------
+
+// $$FOOTER$$ 
+

Modified: trunk/doc/en/examples.html
===================================================================
--- trunk/doc/en/examples.html	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/examples.html	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,219 +1,22 @@
 $$HEADER$$
-&lt;h3&gt;Lua Code Examples&lt;/h3&gt;
-&lt;p&gt;&lt;b&gt;eLua&lt;/b&gt; distros come bundled with nice and fun
-(yes! we have games too! :) Lua programs examples in the File System. They are also included in the &lt;b&gt;eLua&lt;/b&gt;
-source code distribution, under the &lt;i&gt;/romfs&lt;/i&gt; subdirectory. As previously explained, you can run them directly from &lt;b&gt;eLua&lt;/b&gt;'s file
-system or you can use the eLua shell and send them via XMODEM, as
-described &lt;a href=&quot;using.html#shell&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;hello&quot; /&gt;
-&lt;h3&gt;hello.lua: the ubiquitous &quot;Hello, World!&quot;&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;all targets&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;to call this a &quot;program&quot; is a gross overstatement, but it's a
-tradition, so we respect it :) It just prints &quot;Hello, World!&quot; on the terminal and
-returns to the shell. Run it from the file system only if you feel too lazy to fire up
-the lua interpreter inside eLua and write it yourself :)&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;info&quot; /&gt;
-&lt;h3&gt;info.lua: getting the platform data&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;all targets&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;this isn't really more advanced than &quot;Hello, World!&quot;, but it does show
-an &lt;b&gt;eLua&lt;/b&gt; specific module: the platform data module (&lt;b&gt;pd&lt;/b&gt;). You can read
-more about the platform modules &lt;a href=&quot;refman_gen_pd.html&quot;&gt;here&lt;/a&gt;. The program will display the platform
-name, the CPU name, the board name and the CPU clock and then will exit
-to the shell.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;led&quot; /&gt;
-&lt;h3&gt;led.lua: the old LED blinker, the new eLua way&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt; all targets except i386&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt; now we get to do something &quot;more embedded&quot;: blink a LED. The code illustrates a few interesting &lt;b&gt;eLua&lt;/b&gt; features:&lt;/p&gt;
-&lt;ul&gt;&lt;li&gt;&lt;b&gt;cross platform code&lt;/b&gt;: the code assigns a different pin
-to the LED starting from the board name. You can see how the platform
-data module makes it very easy to write such portable code.&lt;/li&gt;
-&lt;li&gt;&lt;b&gt;uart, pio, tmr, pd modules&lt;/b&gt;: they are all used here.&lt;/li&gt;&lt;/ul&gt;
-&lt;p&gt;Watch it blink, then press any key to return to the eLua shell.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;hangman=&quot; /&gt;
-&lt;h3&gt;hangman.lua: taking advantage of your terminal&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;all targets&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;the geekiest example from the &lt;b&gt;eLua&lt;/b&gt; distribution (or would it be morse.lua? :), it makes use of
-the &lt;a href=&quot;refman_gen_term.html&quot;&gt;term module&lt;/a&gt; to let the user play a BSD-like &quot;hangman&quot; directly in his terminal emulator. Run the example
-and enjoy. Currently it has a very small list of words, as this was
-written mainly as a proof of eLua's capabilities, but it's very easy to
-add new words/replace the existing ones.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;pwmled=&quot; /&gt;
-&lt;h3&gt;pwmled.lua: LED blinker, advanced class&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;this uses the PWM module to fade the on-board LED in and out, in an
-infinite loop. Not much to say here, the code is very simple, yet the
-results are quite spectacular. Press any key to end the sample and
-return to the shell.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;dualpwm=&quot; /&gt;
-&lt;h3&gt;dualpwm.lua: because a single LED is just not enough&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;MOD711, ET-STM32&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;My &lt;a href=&quot;<A HREF="http://www.sctec.com.br/content/view/101/30/">http://www.sctec.com.br/content/view/101/30/</A>&quot;&gt;MOD711 board&lt;/a&gt; needed a
-&quot;motherboard&quot; for a few components (mainly the RS232-TTL level converter and a reset button) so I also added two LEDs to it, connected
-to two different PWM channels. With this program, the two LEDs fade at the same type, but in different directions.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;tvbgone&quot; /&gt;
-&lt;h3&gt;tvbgone.lua: yes, eLua can do real time!&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;this is more complex, but also very important for &lt;b&gt;eLua&lt;/b&gt;, because it
-proves that real time applications (with relatively strict timing
-requirements) can run from &lt;b&gt;eLua&lt;/b&gt; directly. It's the famous TV-B-Gone
-project adapted from &lt;a href=&quot;<A HREF="http://www.ladyada.net/make/tvbgone/">http://www.ladyada.net/make/tvbgone/</A>&quot;&gt;LadyAda's kit&lt;/a&gt;.
-If you're not familiar with TV-B-Gone, it knows how to do one thing
-very well: power off your TV :) Basically it contains a lot of remote
-control codes (for a lot of TVs) that are continuously sent via an IR
-LED. This code uses the PWM module (new in &lt;b&gt;eLua&lt;/b&gt; 0.4) and it also does
-file I/O from Lua, since the remote control codes are kept in a
-separate file (which is also part of the ROM file system). To read the
-binary file, the &quot;pack&quot; module (also new in 0.4) is used. To ensure
-that we don't get any unexpected delays, the Lua garbage collector is
-turned off. Take a look at this sample, it's both a very good proof of
-the capabilities of eLua and a good learning resource.&lt;br&gt;
-To use it on EK-LM3S8962 or EK-LM3S6965 connect an IR LED
-with a resistor between the &quot;PWM2&quot; and &quot;GND&quot; pins of the extension
-connector. Get close to your TV and press the &quot;select&quot; button on your
-board to start sending the IR codes. The on-board LED stays lit while
-the codes are transmitted and shuts off afterwards. Press the &quot;down&quot;
-button on your board to exit the application and return to the shell.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;piano&quot; /&gt;
-&lt;h3&gt;piano.lua: because PWM is great&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965, SAM7-EX256&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;yet another use for the PWM module, this sample can be used to &quot;play&quot;
-notes via the on-board speaker using the PC keyboard. The on-screen
-keyboard shows what keys you must press for different notes, and you
-can set your octave and inter-note delay. Press ESC to end your &lt;b&gt;eLua&lt;/b&gt;
-musical session :)&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;bisect&quot; /&gt;
-&lt;h3&gt;bisect.lua: floating point at its best&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;all targets&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;this is taken directly from the official Lua distribution, and it's
-here to show that &lt;b&gt;eLua&lt;/b&gt; can do floating point just like on a desktop
-machine, albeit slower. Run it on your target, then run it again, but
-this time on the PC, and compare the results. Yes, they are identical.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;life&quot; /&gt;
-&lt;h3&gt;life.lua: the game of life&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;i386&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;another example taken directly from the Lua distribution, this time
-the well known &lt;a href=&quot;<A HREF="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</A>&quot;&gt;game of life&lt;/a&gt;.
-Start it and enjoy. Only included on i386 by default because it's faster on i386, but it can run on other
-platform too (although it requires quite a bit of memory, which is not a problem for boards with external
-memory). &lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;morse&quot; /&gt;
-&lt;h3&gt;morse.lua: because PWM is great, part II&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt; EK-LM3S8962, EK-LM3S6965, SAM7-EX256&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;this uses the same PWM module for Morse code generation. Just enter a
-text, and listen to it getting Morsed on your board's speaker and on a blinking Led. The
-letters and Morse codes are also shown on the terminal. Use '+' and
-'-'' to change the frequency, up and down arrows to change the speed,
-'s' to mute/unmute, and ESC to exit.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;lhttpd&quot; /&gt;
-&lt;h3&gt;lhttpd.lua: only with (e)Lua ...&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965, EAGLE-100, EK-LM3S9B92&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;this is one of those things that can show the real potential of a
-language (and hopefully the real potential of &lt;b&gt;eLua&lt;/b&gt; in this case). As
-you have probably guessed by now, it's a web server&nbsp;written in Lua.
-Except that it is much more than this: it's a &lt;b&gt;scripting web server!&lt;/b&gt; That's
-right, you can embed parts of Lua code into your pages, and the server
-will parse them and replace the Lua code with its output. To output
-something from Lua code embedded in a web page, simply use &quot;print&quot; in
-your Lua code. You can also write your pages completely in Lua (again,
-using &quot;print&quot;), the server knows how to handle this too. When is the
-last time you heard about a scripting web server in 256k of Flash/64k
-of RAM?&nbsp;&lt;/p&gt;&lt;p&gt;The full list of features is given below:&lt;/p&gt;
-&lt;ul&gt;
-&lt;li&gt;completely written&nbsp;in Lua&lt;/li&gt;
-&lt;li&gt;can handle a single connection at a time (for now)&lt;/li&gt;
-&lt;li&gt;can serve text and images (so far)&lt;/li&gt;
-&lt;li&gt;gets its files from the ROM file system (this will be extended when more
- filesystems are added)&lt;/li&gt;
-&lt;li&gt;can execute embedded Lua code and replace it with its output (via &quot;print&quot; statements). Embed Lua
- code in your HTML files between tags, make sure
-your HTML file extension is &quot;.pht&quot;, and the server will preprocess it
-and replace the Lua code with its output&lt;/li&gt;
-&lt;li&gt;if a file with &quot;.lua&quot; extension is requested, it doesn't send the file, but
- executes it and sends its output (via &quot;print&quot; statements)&lt;/li&gt;&lt;/ul&gt;
-&lt;p&gt;This is still work in progress, but it already works quite well.
-Take a look at &lt;i&gt;romfs/index.pht&lt;/i&gt; and &lt;i&gt;romfs/test.lua&lt;/i&gt; from the source
-distribution for an example of how to include Lua code in your HTML
-files.&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;adcscope&quot; /&gt;
-&lt;h3&gt;adcscope.lua: ADCs and eLua, part I&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965, ET-STM32&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;This uses the ADC module to acquire samples as quickly as possible on available ADC channels, and display them using the term module.  Additionally, for different channels, different length moving average filters are used to smooth the data being acquired (see the adcchannels and adcsmoothing variables).  While running the script also provides the average length of time required to get conversion results from each channel and the amount of memory used by garbage collectable objects in the running Lua environment.
+&lt;h3&gt;eLua Code Examples&lt;/h3&gt;
+&lt;p&gt;
+Previous to v0.8, official eLua distributions included some games, demos and code examples in
+the ROM File System.
 &lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;adcpoll&quot; /&gt;
-&lt;h3&gt;adcpoll.lua: ADCs and eLua, part II&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965, ET-STM32&lt;/p&gt;
-&lt;p&gt;&lt;strong&gt;Description: &lt;/strong&gt;This is another example of the ADC and term modules.  This version uses hardware timers to acquire samples deterministically at a rate of 4 samples per second.  When run, note that data from some channels appear before that of others.  This is due to the moving average (smoothing) filter being enabled.  This filter will only return conversion results after enough samples are acquired to fill the filter length.  In addition, this example utilizes a polling mechanism.  When adc.getsample or adc.getsamples return nil, no samples were available to be returned.  Values for each channel, in this example, are only displayed when there is a non-nil value returned by adc.getsample.
+&lt;p&gt;
+These examples grew to independent projects and are now maintained by the
+community in dedicated pages on the &lt;a href=&quot;<A HREF="http://wiki.eluaproject.net/Projects">http://wiki.eluaproject.net/Projects</A>&quot;&gt;eLua
+Wiki projects section&lt;/a&gt;. 
 &lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;logo&quot; /&gt;
-&lt;h3&gt;logo.lua: graphics and eLua&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965&lt;/p&gt;
-&lt;p&gt;&lt;b&gt;Description: &lt;/b&gt;a complex example, proving that &lt;b&gt;eLua&lt;/b&gt; can do even animations! The &lt;b&gt;eLua&lt;/b&gt; logo is shown
-on the on-board OLED display and then &lt;b&gt;rotated in realtime&lt;/b&gt;. You can get about 3fps with this example. Not bad for a bitmap
-rotation application that uses quite a lot of emulated floating point computations at 50MHz. Optimizations are still
-possible, but are left (for now) as an exercise for the &lt;b&gt;eLua&lt;/b&gt; apprentice. Take a look at the code to discover
-how a highly optimized eLua program looks like, but don't spend too much time with it if your math feels rusty :)
+&lt;p&gt;
+There you will also find some tutorials on &lt;a href=&quot;<A HREF="http://wiki.eluaproject.net/Boards">http://wiki.eluaproject.net/Boards</A>&quot;&gt;how to use them on your kits&lt;/a&gt;
+ and &lt;a href=<A HREF="http://wiki.eluaproject.net/Tutorials">http://wiki.eluaproject.net/Tutorials</A>&gt;many others&lt;/a&gt;.
 &lt;/p&gt;
-&lt;br /&gt;
-
-
-&lt;a name=&quot;pong&quot; /&gt;
-&lt;h3&gt;pong.lua: eLua meets a classic&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965&lt;/p&gt;
-&lt;p&gt;&lt;b&gt;Description: &lt;/b&gt;a tribute to the classics, as well as an addictive way of spending your time, this examples proves
-without any doubt that you can write games with &lt;strong&gt;eLua&lt;/strong&gt;. This variant of the well known &quot;pong&quot; games plays on 
-the OLED display of your LM3S board, using the on-board switches to control your paddle. Hit the ball, collect or avoid the 
-&quot;bonuses&quot;, a keep on trying to beat that highscore :) The code is just complex enough to give you a fair idea about the
-possibilities of &lt;b&gt;eLua&lt;/b&gt;.
+&lt;p&gt;The wiki is maintained by eLua users and you are very welcomed to
+register and add your own tutorial contribution or to comment on any other.
 &lt;/p&gt;
 &lt;br /&gt;
 
-&lt;a name=&quot;spaceship&quot; /&gt;
-&lt;h3&gt;spaceship.lua: even more fun&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965&lt;/p&gt;
-&lt;p&gt;&lt;b&gt;Description: &lt;/b&gt;tired of hitting a ball? What about hitting a spaceship instead? Or, even better, more spaceships? Defend
-your base with this little game that also plays on the OLED display of your LM3S board and uses the on-board switches as
-paddles. Once again, take a look at the code to get a feeling of &lt;b&gt;eLua&lt;/b&gt;.
-&lt;/p&gt;
-&lt;br /&gt;
-
-&lt;a name=&quot;tetrives&quot; /&gt;
-&lt;h3&gt;tetrives.lua: don't let it get too addictive&lt;/h3&gt;
-&lt;p&gt;&lt;strong&gt;Runs on: &lt;/strong&gt;EK-LM3S8962, EK-LM3S6965&lt;/p&gt;
-&lt;p&gt;&lt;b&gt;Description: &lt;/b&gt;tetris doesn't need any introduction at all, so just start the game, grab the on-board switches and start
-making lines after lines on your OLED display. Once you're done playing, you might want to take a look at the code. This example 
-is fairly complex, large, uses &lt;b&gt;eLua&lt;/b&gt; specific techniques (explicit memory management with calls to the garbage collector) and might 
-serve as a good base for your own code.
-&lt;/p&gt;
-
 $$FOOTER$$
 

Modified: trunk/doc/en/faq.html
===================================================================
--- trunk/doc/en/faq.html	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/faq.html	2011-02-02 17:52:12 UTC (rev 949)
@@ -2,6 +2,6 @@
 &lt;h3&gt;eLua Frequently Asked Questions&lt;/h3&gt;
 &lt;br /&gt;
 &lt;b&gt;eLua&lt;/b&gt; has a list of frequently asked questions maintained by the
-community in the &lt;b&gt;eLua User Labs&lt;/b&gt; at &lt;a href=&quot;<A HREF="http://wiki.eluaproject.net/FAQ">http://wiki.eluaproject.net/FAQ</A>&quot;&gt;wiki.eluaproject.net/FAQ&lt;/a&gt;
+community in the &lt;b&gt;eLua Wiki&lt;/b&gt; at &lt;a href=&quot;<A HREF="http://wiki.eluaproject.net/FAQ">http://wiki.eluaproject.net/FAQ</A>&quot;&gt;wiki.eluaproject.net/FAQ&lt;/a&gt;
 $$FOOTER$$
 

Deleted: trunk/doc/en/installing_avr32.html
===================================================================
--- trunk/doc/en/installing_avr32.html	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/installing_avr32.html	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,76 +0,0 @@
-$$HEADER$$
-&lt;h3&gt;Installing &lt;b&gt;eLua&lt;/b&gt; on the AVR32 CPUs from Atmel&lt;/h3&gt;
-&lt;p&gt;&lt;a href=&quot;<A HREF="http://www.atmel.com/products/AVR32/">http://www.atmel.com/products/AVR32/</A>&quot;&gt;AVR32&lt;/a&gt; is a family of high performance 32-bit CPUs from &lt;a 
-  href=&quot;<A HREF="http://www.atmel.com">http://www.atmel.com</A>&quot;&gt;Atmel&lt;/a&gt;. They were built as direct competitors for the various ARM core implementation of the market, and offer very good
-  performance (91 MIPS @ 66MHz) and power efficieny (1.3mW/MHz). Atmel claims that their AVR32 core outperforms ARMv5 (in ARM and Thumb mode) in terms of 
-  both performance and code size. It's a proprietary architecture (so it's only implemented by Atmel), yet it has a very good support package, and an
-  open source toolchain based on GCC, which made it an ideal candidate for the first non-ARM (and also the first big endian) &lt;b&gt;eLua&lt;/b&gt; target. Atmel
-  also sells a number of development boards based on their AVR23 CPUs. The one used for &lt;b&gt;eLua&lt;/b&gt; is the 
-  &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114">http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114</A>&quot;&gt;ATEVK1100 board&lt;/a&gt;, built around the 
-  &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4117">http://www.atmel.com/dyn/products/product_card.asp?part_id=4117</A>&quot;&gt;AT32UC3A0512 AVR32 MCU&lt;/a&gt; (512k internal Flash/64k internal ARM).
-  It's a very powerful board, featuring (among other things) an external 32 MByte SDRAM memory, which is more than enough to run any &lt;b&gt;eLua&lt;/b&gt; 
-  program I can think of :).&lt;/p&gt;
-&lt;h3&gt;Prerequisites&lt;/h3&gt; 
- &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the AT32UC3A0512 CPU, make sure that:&lt;/p&gt;
- &lt;ul&gt;
- &lt;li&gt;you're using Linux or Windows. It's easier to install and use Atmel's programming software on Windows, so use Windows version if you want to save
-   yourself from quite a bit of hassle.&lt;/li&gt;
- &lt;li&gt;you installed Atmel's &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886</A>&quot;&gt;FLIP programming software&lt;/a&gt;, which is what you need
-    in order to install your &lt;b&gt;eLua&lt;/b&gt; image. Installation in easy under Windows (you just need to run a setup package), but quite tricky under Linux. 
-    The next paragraph outlines the procedure for installing FLIP in Linux.&lt;/li&gt;
- &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the AT32UC3A0512 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;). 
-    Note that unlike other platforms, the ATEVK1100 needs a .hex file for programming, not a .bin.&lt;/li&gt;
- &lt;/ul&gt;
-&lt;h2&gt;Installing FLIP in Ubuntu Linux&lt;/h2&gt;
-&lt;p&gt;Follow the steps below to install FLIP under Linux:&lt;/p&gt;
-&lt;ol&gt;
-  &lt;li&gt;download the Linux version of FLIP from &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886</A>&quot;&gt;the Atmel FLIP page&lt;/a&gt;. Save it 
-  (or move it later) to your &lt;i&gt;/usr/local/&lt;/i&gt; directory (you need to have superuser privileges to do that). At the moment of writing this tutorial, the
-  latest FLIP version is 3.2.1, so this is what we're going to use here.&lt;/li&gt;
-  &lt;li&gt;untar the FLIP archive:
-  &lt;pre&gt;&lt;code&gt;$ cd /usr/local
-$ sudo tar xvzf flip_linux_3-2-1.tgz&lt;/code&gt;&lt;/pre&gt;
-  This will create the &lt;i&gt;/usr/local/flip.3.2.1&lt;/i&gt; directory.&lt;/li&gt;
-  &lt;li&gt;you need to install OpenJDK if it is not installed:
-  &lt;pre&gt;&lt;code&gt;$ sudo apt-get install openjdk-6-jre&lt;/code&gt;&lt;/pre&gt;
-  &lt;/li&gt;
-  &lt;li&gt;edit &lt;i&gt;/usr/local/flip.3.2.1/bin/batchisp3.sh&lt;/i&gt; and add the two bolded lines before at the beginning of the file:
-  &lt;pre&gt;&lt;code&gt;#!/bin/bash -f
-
-&lt;b&gt;export JAVA_HOME=/usr/lib/jvm/java-6-openjdk/jre/
-export FLIP_HOME=/usr/local/flip.3.2.1/bin/&lt;/b&gt;
-
-if [ &quot;$FLIP_HOME&quot; = &quot;&quot; ]; then&lt;/code&gt;&lt;/pre&gt;
-  &lt;/li&gt;
-  &lt;li&gt;you need to edit a binary file this time (&lt;i&gt;/usr/local/flip.3.2.1/libatlibusbdfu.so&lt;/i&gt;). This happens because FLIP comes compiled for RedHat by
-  default, and Ubuntu some different system paths. See &lt;a href=&quot;<A HREF="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;amp;file=viewtopic&amp;amp;t=56562">http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=56562</A>&quot;&gt;this topic&lt;/a&gt; 
-  for full details. All you have to do is change all the &lt;b&gt;/sys/bus/usb&lt;/b&gt; strings inside &lt;i&gt;libatlibusbdfu.so&lt;/i&gt; to &lt;b&gt;/dev/bus/usb&lt;/b&gt;.&lt;/li&gt;
-  &lt;li&gt;add the FLIP directory to your PATH:
-  &lt;pre&gt;&lt;code&gt;$ export PATH=/usr/local/flip.3.2.1/bin:$PATH&lt;/code&gt;&lt;/pre&gt;
-  &lt;/li&gt;
-  &lt;li&gt;FLIP interferes with a program that comes pre-installed on Ubuntu system, called &lt;b&gt;brltty&lt;/b&gt;. It's meant to help the visually 
-  impaired, so if you're not one of them, simply remove it (as it seems to interfere with a lot of other USB devices too):
-  &lt;pre&gt;&lt;code&gt;$ sudo apt-get remove brltty&lt;/code&gt;&lt;/pre&gt;
-  &lt;/li&gt;
-&lt;/ol&gt;
-
- &lt;h3&gt;Burning &lt;b&gt;eLua&lt;/b&gt; to the EVK1100 board&lt;/h3&gt;
-&lt;p&gt;After you installed FLIP and added it to your $PATH, burning the &lt;b&gt;eLua&lt;/b&gt; image should be quite easy:&lt;/p&gt;
-&lt;ul&gt;
-  &lt;li&gt;connect your ATEVK1100 board with the PC using an USB cable&lt;/li&gt;
-  &lt;li&gt;put your board in DFU mode (this is required for FLIP interaction). To do this:
-    &lt;ol&gt;
-      &lt;li&gt;press &lt;b&gt;on&lt;/b&gt; the on-board joystick (and keep it pressed)&lt;/li&gt;
-      &lt;li&gt;press the RESET button on the board briefly&lt;/li&gt;
-      &lt;li&gt;release the RESET button&lt;/li&gt;
-      &lt;li&gt;release the joystick&lt;/li&gt;
-    &lt;/ol&gt;
-  &lt;/li&gt;
-  &lt;li&gt;if you're using Windows and it asks you for a driver, you should install it manually from &lt;i&gt;c:\Program Files\Atmel\Flip &lt;version&gt;\usb&lt;/i&gt;&lt;/li&gt;
-  &lt;li&gt;Execute this from the command line (the command is the same on Windows and Linux, with a single exception: the FLIP executable name is &lt;b&gt;batchisp3&lt;/b&gt; in Linux and &lt;b&gt;batchisp&lt;/b&gt; (without a 3) in Windows):
-  &lt;pre&gt;&lt;code&gt;$ batchisp3 -hardware usb -device at32uc3a0512 -operation erase f memory flash blankcheck 
-  loadbuffer &lt;image name&gt;.hex program verify start reset 0&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
-&lt;/ul&gt;
-&lt;p&gt;That's all, your &lt;b&gt;eLua&lt;/b&gt; image is (finally) installed on your ATEVK1100 board.&lt;/p&gt;
-$$FOOTER$$
-

Copied: trunk/doc/en/installing_avr32.txt (from rev 948, branches/pre0.8/doc/en/installing_avr32.txt)
===================================================================
--- trunk/doc/en/installing_avr32.txt	                        (rev 0)
+++ trunk/doc/en/installing_avr32.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -0,0 +1,109 @@
+// $$HEADER$$
+Installing eLua on the AVR32 CPUs from Atmel
+--------------------------------------------
+<A HREF="http://www.atmel.com/products/AVR32/[AVR32">http://www.atmel.com/products/AVR32/[AVR32</A>] is a family of high performance 32-bit CPUs from &quot;<A HREF="http://www.atmel.com[Atmel">http://www.atmel.com[Atmel</A>].
+They were built as direct competitors for the various ARM core implementation of the market, and offer very good
+performance (91 MIPS @ 66MHz) and power efficieny (1.3mW/MHz). Atmel claims that their AVR32 core outperforms ARMv5 
+(in ARM and Thumb mode) in terms of both performance and code size. It's a proprietary architecture (so it's only implemented by Atmel), 
+yet it has a very good support package, and an open source toolchain based on GCC, which made it an ideal candidate for the first 
+non-ARM (and also the first big endian) eLua target. Atmel also sells a number of development boards based on their AVR23 CPUs. 
+The one used for eLua is the _ATEVK1100 board built around the _AT32UC3A0512 AVR32 MCU (512k internal Flash/64k internal ARM).
+It's a very powerful board, featuring (among other things) an external 32 MByte SDRAM memory, which is more than enough to run lots and
+lots of eLua programs.
+
+NOTE: eLua version 0.8 added support for the AVR32 based _ATEVK1101 and _Mizar32 boards. The instructions below apply for the _ATEVK1101
+board too; for _Mizar32 read the note xref:buildnote[here].
+
+Prerequisites
+-------------
+Before you'll be able to use eLua on the AT32UC3A0512 CPU, make sure that:
+
+* you're using Linux or Windows. It's easier to install and use Atmel's programming software on Windows, so use Windows version if you want to save
+  yourself from quite a bit of hassle.
+* you installed Atmel's <A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886[FLIP">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886[FLIP</A> programming software], which is what you need
+  in order to burn your eLua&lt; image. Installation in easy under Windows (you just need to run a setup package), but quite tricky under Linux. 
+  The next paragraph outlines the procedure for installing FLIP in Linux.
+* you already have your eLua image for the AT32UC3A0512 CPU (link:building.html[built] or link:downloads.html[downloaded]). Note that unlike other 
+  platforms the ATEVK1100 needs a .hex file for programming, not a .bin.
+
+Installing FLIP in Ubuntu Linux
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+[[buildnote]]
+IMPORTANT: The instructions below are somewhat hard to put in practice and reports suggests that they don't work well on all Ubuntu versions.
+For updated (and simpler) instructions on how to make FLIP work under Linux and for alternative Linux programming software check
+<A HREF="http://code.google.com/p/mizar32/wiki/FlashingFirmware[the">http://code.google.com/p/mizar32/wiki/FlashingFirmware[the</A> Mizar32 wiki page].
+
+Follow the steps below to install FLIP under Linux:
+
+1. download the Linux version of FLIP from <A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886[the">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886[the</A> Atmel FLIP page]. Save it 
+  (or move it later) to your _/usr/local/_ directory (you need to have superuser privileges to do that). At the moment of writing this tutorial, 
+  the latest FLIP version is 3.2.1, so this is what we're going to use here.
+
+2. untar the FLIP archive: 
++
+------------------------------------
+$ cd /usr/local
+$ sudo tar xvzf flip_linux_3-2-1.tgz
+------------------------------------
++
+This will create the _/usr/local/flip.3.2.1_ directory.
+
+3. you need to install OpenJDK if it is not installed:
++
+------------------------------------
+$ sudo apt-get install openjdk-6-jre
+------------------------------------
+
+4. edit _/usr/local/flip.3.2.1/bin/batchisp3.sh_ and add the two bolded lines before at the beginning of the file:
++
+[subs=&quot;quotes&quot;]
+-------------------------------------------------
+#!/bin/bash -f
+
+*export JAVA_HOME=/usr/lib/jvm/java-6-openjdk/jre/*
+*export FLIP_HOME=/usr/local/flip.3.2.1/bin/*
+
+if [ &quot;$FLIP_HOME&quot; = &quot;&quot; ]; then
+-------------------------------------------------
+
+5. you need to edit a binary file this time (_/usr/local/flip.3.2.1/libatlibusbdfu.so_). This happens because FLIP comes compiled for RedHat 
+   by default and Ubuntu some different system paths. See <A HREF="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;amp;file=viewtopic&amp;amp;t=56562[this">http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=56562[this</A> topic]
+   for full details. All you have to do is change all the */sys/bus/usb* strings inside _libatlibusbdfu.so&lt;_ to */dev/bus/usb*.
+
+6. add the FLIP directory to your PATH:
++
+---------------------------------------------
+$ export PATH=/usr/local/flip.3.2.1/bin:$PATH
+---------------------------------------------
+
+7. FLIP interferes with a program that comes pre-installed on Ubuntu system, called *brltty*. It's meant to help the visually 
+  impaired, so if you don't need it simply remove it (as it seems to interfere with a lot of other USB devices too):
++
+----------------------------
+$ sudo apt-get remove brltty
+----------------------------
+
+Burning eLua to the EVK1100 board
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+After you installed FLIP and added it to your $PATH, burning the eLua image should be quite easy:
+
+* connect your ATEVK1100 board with the PC using an USB cable
+* put your board in DFU mode (this is required for FLIP interaction). To do this:
++
+  1. press *on* the on-board joystick and keep it pressed
+  2. press the RESET button on the board briefly
+  3. release the RESET button
+  4. release the joystick
+
+* if you're using Windows and it asks you for a driver, you should install it manually from __c:\Program Files\Atmel\Flip &lt;version&gt;\usb__
+* execute this from the command line (the command is the same on Windows and Linux, with a single exception: the FLIP executable name is *batchisp3* in Linux 
+  and *batchisp* (without a 3) in Windows):
++
+--------------------------------------------------------------------------------------------------------------------------------------------------
+$ batchisp3 -hardware usb -device at32uc3a0512 -operation erase f memory flash blankcheck loadbuffer &lt;image name&gt;.hex program verify start reset 0
+--------------------------------------------------------------------------------------------------------------------------------------------------
+
+That's all, your eLua image is (finally) installed on your ATEVK1100 board.
+
+// $$FOOTER$$
+

Modified: trunk/doc/en/inthandlers.txt
===================================================================
--- trunk/doc/en/inthandlers.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/inthandlers.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -2,41 +2,42 @@
 eLua interrupt handlers
 -----------------------
 
-Starting with version link:TODO[0.8], eLua supports interrupt handlers written in Lua. Once an interrupt handler is set in the Lua code, it will be called each time a supported 
+Starting with link:downloads.html[vesion 0.8] eLua supports interrupt handlers written in Lua. Once an interrupt handler is set in the Lua code, it will be called each time a supported 
 interrupt is generated. A *supported interrupt* is any interrupt that is handled by the platform C code (see link:arch_ints.html[here] for more details).
 
 [red]*IMPORTANT*: before learning how to use interrupt handlers in Lua, please keep in mind that Lua interrupt handlers don't work the same way as 
-regular \(C) interrupt handlers. As Lua doesn't have direct suport for interrupts, they have to be emulated. eLua emulates them using a  queue that is populated with 
+regular \(C) interrupt handlers. As Lua doesn't have direct support for interrupts, they have to be emulated. eLua emulates them using a  queue that is populated with 
 interrupt data by the C support code. As long as the queue is not empty, a Lua hook is set to run every 2 Lua bytecode instructions. This hook function is the Lua interrupt 
 handler. After all the interrupts are handled and the queue is emptied, the hook is automatically disabled. Consequently:
 
 * When the interrupt queue is full (a situation that might appear when interrupts are added to the queue faster than the Lua code can handle them) subsequent interrupts are
     ignored (not added to the queue) and an error message is printed on the eLua console device. The interrupt queue size can be configured at build time, as explained
-    link:TODO[here]. Even if the interrupt queue is large, one most remember that Lua code is significantly slower than C code, thus not all C interrupts make
+    link:building.html[here]. Even if the interrupt queue is large, one most remember that Lua code is significantly slower than C code, thus not all C interrupts make
     suitable candidates for Lua interrupt handlers. For example, a serial interrupt that is generated each time a char is received at 115200 baud might be too fast for Lua
     (this is largely dependent on the platform). On the other hand, a GPIO interrupt-on-change on a GPIO line connected with a matrix keyboard is a very good candidate for
     a Lua handler. Experimenting with different interrupt types is the best way to find the interrupts that work well with Lua.
 
 * A more subtle point is that the Lua virtual machine must *run* for the interrupt handlers to work. A simple analogy is that a CPU must have a running clock in order
-    to function properly (and in order to take care of the hardware interrupts). If the clock is stopped, the CPU doesn't run and the interrupt handlers aren't called anymore,
+    to function properly (and in order to take care of the hardware interrupts). If the clock is stopped the CPU doesn't run and the interrupt handlers aren't called anymore,
     although the occurence of the interrupt might be recorded inside the CPU. This is the exact same situation with Lua: if the virtual machine doesn't run, the interrupts
     are still recorded in the interrupt queue, but the Lua handler won't be called until the virtual machine runs again. In this case though, the &quot;clock&quot; of the Lua VM is a 
     C function that is executed for every VM instruction. If this function blocks for some reason, the VM instructions are not executed anymore. It's not hard to make
-    this function block; for example, it blocks everytime the Lua code waits for some user input at the console, or when a TODO tmr.delay is executed, or when TODO uart.read is called 
-    with an infinite or very large timeout; in general, any function from a Lua library that doesn't return immediately (or after a short ammount of time) will block the VM. 
-    Care must be taken to avoid such operations as much as possible, otherwise the interrupt support code won't run properly.
+    this function block; for example, it blocks everytime the Lua code waits for some user input at the console, or when a link:refman_gen_tmr.html#tmr.delay[tmr.delay] is executed, 
+    or when link:refman_gen_uart.html#uart.read[uart.read] is called  with an infinite or very large timeout; in general, any function from a Lua library that doesn't return 
+    immediately or after a short ammount of time will block the VM. Care must be taken to avoid such operations as much as possible, otherwise the interrupt support code won't run properly.
 
 * There is a single interrupt handler per interrupt type in Lua (the same holds true for C interrupt support), as opposed to the many hardware interrupts 
    handlers usually found on the eLua targets. It is however easy to differentiate between different interrupt sources, as will be explained in the next 
-   paragraph.
+   section.
 
-* Lua interrupt handlers are never reentrant.
+* Lua interrupt handlers are not reentrant.
 
 While this might seem restrictive, Lua interrupt handlers work quite well in practical situations. As an added bonus, since they are implemented by C support code, there's nothing
 preventing eLua from implementing &quot;custom interrupts&quot; (software generated interrupts that don't correspond to a hardware interrupt on the CPU), such as serial interrupt on
-char match (generate an interrupt when a certain char is received on the serial port, for example a newline), timer interrupts for link:TODO[virtual timers], TCP/UDP data
-packet received interrupt and many others.
+char match (generate an interrupt when a certain char is received on the serial port, for example a newline), timer interrupts for link:arch_platform_timers.html#virtual_timers[virtual timers], TCP/UDP data packet received interrupt and many others.
 
+IMPORTANT: An up-to-date list of all interrupts supported by eLua can be found link:arch_ints.html#intlist[here].
+
 Using interrupt handlers in Lua
 --------------------------------
 To enable Lua interrupt handler, define *BUILD_LUA_INT_HANDLERS* and *PLTATFORM_INT_QUEUE_LOG_SIZE* in _platform_conf.h_ (see link:building.html[here] for details). Setting up interrupt 
@@ -47,8 +48,8 @@
   set for the interrupt). In most cases, your interrupt handler should call the previous handler to ensure proper interrupt management.  
 
 * use _cpu.sei( int_id, resnum1, [resnum2], ..., [resnumn])_ and _cpu.cli( int_id, resnum1, [resnum2], ..., [resnumn])_ to enable/disable specific CPU interrupts 
-    that will trigger the interrupt handler. You can also use _cpu.sei()_ and _cpu.cli_ (without parameters) to enable/disable global interrupts on the CPU, although this
-    is not recommended.
+  that will trigger the interrupt handler. You can also use _cpu.sei()_ and _cpu.cli_ (without parameters) to enable/disable global interrupts on the CPU, although this
+  is not recommended.
 
 The interrupt handler receives the *resource ID* that specifies the resource that fired the interrupt. It can be a timer ID for a timer overflow interrupt, 
 a GPIO port/pin combination for a GPIO interrupt on pin change, a SPI interface ID for a SPI data available interrupt, and so on.
@@ -76,7 +77,7 @@
 end
 
 -- This is the GPIO interrupt on change (falling edge) interrupt
-[bblue]*local function gpio_negedge_handler( id, resnum )*
+[bblue]*local function gpio_negedge_handler( resnum )*
     local port, pin = pio.decode( resnum )
   print( string.format( &quot;GPIO NEGEDGE interrupt on port %d, pin %d&quot;, port, pin ) )
   if prev_gpio then prev_gpio( resnum ) end
@@ -124,9 +125,10 @@
 It defaults to *true*, and in most cases it shouldn't be changed. Using this feature, it becomes easy to wait for one or more interrupt flag(s) to be set. To use interrupt 
 polling:
 
-* Disable the interrrupt(s) to be polled with _cpu.hw_cli_ or _cpu.cli_. _cpu.hw_cli_ disables interrupts only in hardware, as opposed to _cpu.cli_ that also clears
-  an internal flag which makes the interrupt able to trigger a Lua handler. Use _cpu.cli_ if you already set an interrupt handler with _cpu.hw_sei_ or _cpu.hw_cli_ otherwise.
+* Disable the interrrupt(s) to be polled with _cpu.cli_.
 
+* (optional) disable the interrupt handler for the interrupt with _cpu.set_interrupt_handler( id, nil )_
+
 * Use _cpu.get_int_flag_ to get the interrupt flag.
 
 The *int_select* function below is a possible implementation of a function that gets an array of interrupts and returns the first one that gets active:
@@ -144,8 +146,8 @@
  end
 end
 
-[bblue]*cpu.hw_cli( cpu.INT_GPIO_NEGEDGE, pio.P0_0 )*
-[bblue]*cpu.hw_cli( cpu.INT_TMR_MATCH, tmr.VIRT0 )*
+[bblue]*cpu.cli( cpu.INT_GPIO_NEGEDGE, pio.P0_0 )*
+[bblue]*cpu.cli( cpu.INT_TMR_MATCH, tmr.VIRT0 )*
 local ints = { { cpu.INT_GPIO_NEGEDGE, pio.P0_0 }, { cpu.INT_TMR_MATCH, tmr.VIRT0 } }
 -- int_select will wait for either INT_GPIO_NEGEDGE or INT_TMR_MATCH to become active
 print( int_select( ints ) )
@@ -170,7 +172,7 @@
 *elua_int_c_handler* is a function that doesn't return anything and receives a single parameter of type *elua_int_resnum* to differentiate between the sources (GPIO pin, UART id, timer id
 and so on) that can trigger the interrupt *inttype*. This is similar in functionality with the Lua handlers. 
 
-To work with interrupts from C code use these functions defined by the link:TODO[CPU platform interface]:
+To work with interrupts from C code use these functions defined by the link:arch_platform_cpu.html[CPU platform interface]:
 
 int platform_cpu_set_interrupt( elua_int_id id, elua_int_resnum resnum, int status )::
   Enable (*status* = *PLATFORM_CPU_ENABLE*) or disable (*status* = *PLATFORM_CPU_DISABLE*) interrupt *id* for resource *resnum*. 
@@ -214,5 +216,38 @@
 
 ------------------------------
 
+Sharing an interrupt between Lua and C
+--------------------------------------
+
+As seen above the eLua interrupt subsystem consists of two parts: the C side interrupt support and the Lua side interrupt support. When an interrupt handler is
+enabled on both sides (C and Lua) the interrupt subsystem knows to enqueue the interrupt for the Lua handler and to call the C interrupt handler directly. When the
+same interrupt (with the same ID) is handled by both the C and Lua code it becomes a *shared* interrupt. Shared interrupts might be problematic in some scenarios.
+To avoid potential issues one should should try to remember a few simple rules:
+
+Always check your resource number.::
+  The Lua side might enable an interrupt for a resource number while the C side might enable the same interrupt for another
+  resource number. The effect of this is that both interrupt handlers (in Lua and C) will be called with both resource numbers (since there is a single interrupt
+  handler per interrupt ID). Thus each side should check for the resource number that it needs before acting on the interrupt.
+
+Disable your handlers when you don't need them anymore.::
+  Starting from the same scenario as above (a shared interrupt with a resource number on the C side and another resource number on the Lua side) let's assume that
+  at some point you don't need to receive interrupts on the Lua side anymore. You might think that calling _cpu.cli_ with the Lua resource number is enough to acomplish this 
+  but this is not the case. Since the C side still has a resource number active your Lua handler will still be called with the resource number from the C side. If you
+  followed the first rule (above) your code will behave as expected but it will run slower because of the interrupt support overhead. To completely inhibit the
+  interrupt handler on the Lua side call _cpu.set_int_handler_ with *nil* for the \'handler' argument. After this the Lua interrupt subsystem will not queue 
+  interrupts for the given interrupt ID and thus the handler won't be called anymore. You can re-enable the handler by calling _cpu.set_int_handler_ with an
+  actual function for the \'handler' argument.
+  +
+  The same holds true for the C side. To disable the handler on the C side call _elua_int_set_c_handler_ with NULL for the \'handler' argument. To re-enable the
+  C handler call _elua_int_set_c_handler_ with an actual function for the \'handler' argument.
+
+Use cpu.cli and cpu.sei carefully.::
+  The _cpu.cli_ and _cpu.sei_ functions in the link:refman_gen_cpu.html[CPU module] are wrappers for the _platform_cpu_set_interrupt_ function described above.
+  This means that eventually they manipulate hardware interrupts directly. If you disable an interrupt ID/resource number pair (with _cpu.cli_) that is
+  used by the C side the C interrupt handler won't be called anymore and eLua will most likely malfuction. Most of the time this isn't an issue since the Lua
+  code is not supposed to enable/disable interrupts used by the C code. It might become a real issue when Lua and C share the same interrupt ID/resource number pair.
+  In this case it is recommended that the Lua code doesn't call _cpu.cli_ at all, instead it should simply set an interrupt handler and service the interrupt.
+  By contrast, _cpu.sei_ can be called even if the interrupt is already enabled.
+
 // $$FOOTER$$
 

Modified: trunk/doc/en/linenoise.txt
===================================================================
--- trunk/doc/en/linenoise.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/linenoise.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -15,11 +15,11 @@
 Linenoise in eLua
 -----------------
 Starting with version 0.8 eLua contains a port of the linenoise library. To use it make sure it is included 
-in the build, reffer to the link:build.html[build instructions] for details. Note that linenoise requires
+in the build, reffer to the link:building.html[build instructions] for details. Note that linenoise requires
 ANSI terminal support (*BUILD_TERM*), so you need to enable that too. To use it, simply start the Lua interpreter.
 The table below contains a list of keys that can be used to take advantage of linenoise:
 
-[width=&quot;100%&quot;, cols=&quot;&lt;2,&lt;5&quot;, options=&quot;header&quot;]
+[width=&quot;80%&quot;, cols=&quot;&lt;2,&lt;5&quot;, options=&quot;header&quot;]
 |=============================================
 ^| Key(s)                    ^| Action
 | Left and right              | Move left and right in the current prompt line
@@ -38,5 +38,9 @@
 However, you won't be able to save history from the eLua shell. +
 The reason why this component isn't enabled by default is that it takes RAM (like all good things in eLua :) ) so
 keep this in mind when deciding if you want it or not.      
+
+IMPORTANT: linenoise support seems to be dependent on the terminal emulator used with eLua on the PC side. It was tested
+(and works properly) with <A HREF="http://www.ayera.com/teraterm/[TeraTerm">http://www.ayera.com/teraterm/[TeraTerm</A>] under Windows and with _screen_ in Linux. Other
+terminal emulators might not work equally well.
  
 // $$FOOTER$$

Modified: trunk/doc/en/media.txt
===================================================================
--- trunk/doc/en/media.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/media.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -8,21 +8,26 @@
 [width=&quot;80%&quot;, cols=&quot;&lt;5, &lt;5&quot;, options=&quot;header&quot;]
 |=============================================================================================
 ^|        Description                           ^|                Link(s)
-| eLua on <A HREF="http://twit.tv/floss116[FLOSS">http://twit.tv/floss116[FLOSS</A> Weekly 116] | <A HREF="http://www.youtube.com/watch?v=SV87Mc-BVx0">http://www.youtube.com/watch?v=SV87Mc-BVx0</A>
-| Testing CAN support and LuaRPC with eLua       | <A HREF="http://www.youtube.com/watch?v=2AdSavanq20">http://www.youtube.com/watch?v=2AdSavanq20</A>
-| eLua on LM3S6965                               | <A HREF="http://www.youtube.com/watch?v=W_aXsutL4rQ">http://www.youtube.com/watch?v=W_aXsutL4rQ</A>
-.4+| <A HREF="http://wiki.eluaproject.net/Anubisway[eLua">http://wiki.eluaproject.net/Anubisway[eLua</A> self balancing robot] |  <A HREF="http://www.youtube.com/watch?v=g9qRdDGtroc">http://www.youtube.com/watch?v=g9qRdDGtroc</A>
-| <A HREF="http://www.youtube.com/watch?v=MRcIIrxZ4BI">http://www.youtube.com/watch?v=MRcIIrxZ4BI</A> 
-| <A HREF="http://www.youtube.com/watch?v=pIP1FdYoGvY">http://www.youtube.com/watch?v=pIP1FdYoGvY</A>
-| <A HREF="http://www.youtube.com/watch?v=G8dojuUDQ1c">http://www.youtube.com/watch?v=G8dojuUDQ1c</A>
-| eLua spaceship game                            | <A HREF="http://www.youtube.com/watch?v=QtokEt3-ZII">http://www.youtube.com/watch?v=QtokEt3-ZII</A>
-| eLua pong game                                 | <A HREF="http://www.youtube.com/watch?v=gvlW0_CjSIw">http://www.youtube.com/watch?v=gvlW0_CjSIw</A>
-| eLua tetrives game                             | <A HREF="http://www.youtube.com/watch?v=6y8HEjA6k7U">http://www.youtube.com/watch?v=6y8HEjA6k7U</A>
-| eLua snake game                                | <A HREF="http://www.youtube.com/watch?v=_d9dcU4hu1U">http://www.youtube.com/watch?v=_d9dcU4hu1U</A>
-| eLua logo and LED examples                     | <A HREF="http://www.youtube.com/watch?v=3MZy6QyuyxU">http://www.youtube.com/watch?v=3MZy6QyuyxU</A>
+| eLua on <A HREF="http://twit.tv/floss116[FLOSS">http://twit.tv/floss116[FLOSS</A> Weekly 116]. A technical presentation by James Snyder
+                                                 | <A HREF="http://www.youtube.com/watch?v=SV87Mc-BVx0">http://www.youtube.com/watch?v=SV87Mc-BVx0</A>
+| Testing CAN support and LuaRPC with eLua. First results of CAN and Remote Procedure Calls in eLua (technical) 
+                                                 | <A HREF="http://www.youtube.com/watch?v=2AdSavanq20">http://www.youtube.com/watch?v=2AdSavanq20</A>
+| eLua on EK-LM3S6965. A quick technical presentation by James Snyder | <A HREF="http://www.youtube.com/watch?v=W_aXsutL4rQ">http://www.youtube.com/watch?v=W_aXsutL4rQ</A>
+.4+| <A HREF="http://wiki.eluaproject.net/Anubisway[eLua">http://wiki.eluaproject.net/Anubisway[eLua</A> self balancing vehicle]. A Segway-like two-wheel self-balancing robot developed by undergraduate students of PUC-Rio, powered by eLua 
+                                                 |  <A HREF="http://www.youtube.com/watch?v=g9qRdDGtroc">http://www.youtube.com/watch?v=g9qRdDGtroc</A>
+                                                 | <A HREF="http://www.youtube.com/watch?v=MRcIIrxZ4BI">http://www.youtube.com/watch?v=MRcIIrxZ4BI</A> 
+                                                 | <A HREF="http://www.youtube.com/watch?v=pIP1FdYoGvY">http://www.youtube.com/watch?v=pIP1FdYoGvY</A>
+                                                 | <A HREF="http://www.youtube.com/watch?v=G8dojuUDQ1c">http://www.youtube.com/watch?v=G8dojuUDQ1c</A>
+| <A HREF="http://wiki.eluaproject.net/Spaceship[eLua">http://wiki.eluaproject.net/Spaceship[eLua</A> spaceship game]          | <A HREF="http://www.youtube.com/watch?v=QtokEt3-ZII">http://www.youtube.com/watch?v=QtokEt3-ZII</A>
+| <A HREF="http://wiki.eluaproject.net/Pong[eLua">http://wiki.eluaproject.net/Pong[eLua</A> pong game]                    | <A HREF="http://www.youtube.com/watch?v=gvlW0_CjSIw">http://www.youtube.com/watch?v=gvlW0_CjSIw</A>
+| <A HREF="http://wiki.eluaproject.net/TetrIves[eLua">http://wiki.eluaproject.net/TetrIves[eLua</A> tetrives game]            | <A HREF="http://www.youtube.com/watch?v=6y8HEjA6k7U">http://www.youtube.com/watch?v=6y8HEjA6k7U</A>
+| <A HREF="http://wiki.eluaproject.net/Snake[eLua">http://wiki.eluaproject.net/Snake[eLua</A> snake game]                  | <A HREF="http://www.youtube.com/watch?v=_d9dcU4hu1U">http://www.youtube.com/watch?v=_d9dcU4hu1U</A>
+| <A HREF="http://wiki.eluaproject.net/Logo[eLua">http://wiki.eluaproject.net/Logo[eLua</A> logo and LED examples]        | <A HREF="http://www.youtube.com/watch?v=3MZy6QyuyxU">http://www.youtube.com/watch?v=3MZy6QyuyxU</A>
 | <A HREF="http://www.circuitcellar.com/iMCU/winners/003185.html[eLua">http://www.circuitcellar.com/iMCU/winners/003185.html[eLua</A> based programmable LED display] | <A HREF="http://www.youtube.com/watch?v=s63d34uMN_I">http://www.youtube.com/watch?v=s63d34uMN_I</A>
 |=============================================================================================
 
-For more eLua demos, tutorials and projects visit the <A HREF="http://wiki.eluaproject.net[eLua">http://wiki.eluaproject.net[eLua</A> wiki].
+For more eLua demos, tutorials and projects visit the
+<A HREF="http://wiki.eluaproject.net/Projects[eLua">http://wiki.eluaproject.net/Projects[eLua</A> wiki
+projects page].
 
 // $$FOOTER$$

Copied: trunk/doc/en/modules_mbed.txt (from rev 948, branches/pre0.8/doc/en/modules_mbed.txt)
===================================================================
--- trunk/doc/en/modules_mbed.txt	                        (rev 0)
+++ trunk/doc/en/modules_mbed.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -0,0 +1,7 @@
+// $$HEADER$$
+Reference manual - MBED platform dependent modules
+--------------------------------------------------
+
+This paragraph presents all the modules specific to the link:status.html[lpc17xx] (mbed) platform.
+
+// $$FOOTER$$

Modified: trunk/doc/en/news.txt
===================================================================
--- trunk/doc/en/news.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/news.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -2,22 +2,47 @@
 eLua Project News
 -----------------
 
-January 13, 2011
-~~~~~~~~~~~~~~~~
+February 2nd, 2011
+~~~~~~~~~~~~~~~~~~
+.eLua v0.8 released
+We are proud to annunce the release of eLua v0.8 (codename &quot;FINALLY! It was about time for a new release&quot; :) ). This is the changelog:
+
+* Added the link:arch_rfs.html[RFS] (Remote File System), a new file system which allows sharing
+  a directory on the PC with the eLua board.
+* Added a link:sermux.html[serial multiplexer] which allows using more virtual serial ports over a single physical UART connection.
+* Added Lua and C interrupt handlers support, see link:inthandlers.html[here] for more details.
+* Added <A HREF="https://github.com/antirez/linenoise[linenoise">https://github.com/antirez/linenoise[linenoise</A>] support (eLua and Lua shell command line history and navigation,
+  more details link:linenoise.html[here]).
+* Added generic link:refman_gen_i2c.html[I2C support and docs]
+* Added hardware flow control and runtime configurable buffers for link:refman_gen_uart.html[UARTs].
+* Added support for new boards: _mbed, _ATEVK1101, _Mizar32, _EK-LM3S1968
+* Added SPI and SD/MMC support for EVK1100 and EVK1101 (AVR32) 
+* Added I2C support for STR-E912 (STR912) 
+* Added support for require() and autorun from SD/MMC
+* Added external memory support for STR912
+* Added long filename support for SD/MMC
+* Added RTC (real time clock) platform specific support for str9 (see the documentation of the _mstr9rtc module).
+* Added support for <A HREF="http://www.methods.co.nz/asciidoc[AsciiDoc">http://www.methods.co.nz/asciidoc[AsciiDoc</A>] in the documentation system
+* Tutorials and new projects added to the <A HREF="http://wiki.eluaproject.net[eLua">http://wiki.eluaproject.net[eLua</A> Wiki]
+* Demo files were moved out of the distro to <A HREF="http://wiki.eluaproject.net/Projects">http://wiki.eluaproject.net/Projects</A>
+* Added a link:media.html[media page] with eLua related media on the project site
+
+January 13th, 2011
+~~~~~~~~~~~~~~~~~~
+.eLua issue tracker
 We're glad to announce another eLua project service, the eLua Issue
 Tracker.
 It is a regular web service where users can follow up closely what
 developers are working on, features to come and, of course, report bugs and
-follow up fixes.
+follow up fixes. +
 The eLua Issue Tracker lives at <A HREF="http://tracker.eluaproject.net">http://tracker.eluaproject.net</A>
 It is currently used to manage the development of two main projects; eLua
 itself and the eLua Web Builder.
 Other eLua-related projects can be added and the tool is available for the
-community for this.
+community for this. +
  Please feel free to register and to send comments and suggestions here to
 the list too. 
 
-
 August 4th, 2010
 ~~~~~~~~~~~~~~~~
 .eLua Web Builder
@@ -43,188 +68,5 @@
 Registered users are able to create new pages or make edits to many of the existing pages. We have prepared some initial content, and now welcome the rest of the
 eLua community to add, explore and refine.
 
-January 18th, 2010
-~~~~~~~~~~~~~~~~~~
-Version 0.7 is released. Here's the changelog:
-
-- Compiling eLua under Windows is now officially supported, tutorial added link:building_win.html[Here]
-- Added <A HREF="http://fanplastic.org/2009/05/11/lua-rpc/">http://fanplastic.org/2009/05/11/lua-rpc/</A>&quot;&gt;[LuaRPC] support. Remote procedure calls in the embedded world. (see link:using.html#rpc[here] for details)
-- Added generic and portable SD/MMC Card FAT File System support, (see link:fatfs.html[here] for details)
-- New shell cat/type command, lists text file contents
-- New ROMFS build modes: compress and compile (see link:arch_romfs.html#mode[here] for details)
-- Added support for <A HREF="http://www.olimex.com/dev/str-e912.html[Olimex">http://www.olimex.com/dev/str-e912.html[Olimex</A> STR-E912] board
-- Added the STR9 platform specific link:refman_ps_str9_pio.html[pio module].
-- Added Robert Jakabosky's EGC (Emergency Garbage Collector) patch to eLua (see link:elua_egc.html[here] for details)
-- Added support for the <A HREF="http://www.giga.puc-rio.br/site/embedded/eluademoboard[PUC-Rio">http://www.giga.puc-rio.br/site/embedded/eluademoboard[PUC-Rio</A> eLua board], NXP LPC2468 MCU
-- Added basic CAN module
-- New full CSS based site/doc menu by James Snyder
-- Reference Manual doc folders restructured for easier management
-- More portuguese content translations
-- ADC module doc enhancements
-- More tutorials and general doc enhancements
-
-October 6th, 2009
-~~~~~~~~~~~~~~~~~
-Version 0.6 is (finally) released. Here is the changelog:
-
-- License changed to MIT
-- Web page and documentation completely redesigned
-- Documentation available offline
-- Site/doc (partially) translated to brazilian portuguese
-- Added support for AVR32 CPUs
-- Added support for STM32 Cortex-M3 CPUs
-- Added support for LM3S9Bxx Cortex-M2 CPUs
-- Added ADC module with support for moving average filters
-- Added support for multiple toolchains
-- Added an ls (or dir) shell command
-- Added new examples: pong, tetrives, spaceship (games), logo (graphics), adcpoll, adcscope (ADC operations)
-- Added the LTR (Lua Tiny RAM) patch
-- ROM FS content can be specified per board now
-- API semantic revisions (old code might not be compatible)
-
-July 27th, 2009
-~~~~~~~~~~~~~~~
-We would like to invite all eLua users to the Lua Workshop 2009. This will be the first one to be held at PUC-Rio, in Rio de Janeiro, Brazil, on october 6-7 2009.
-Bogdan and Dado will make a presentation and show demos on the first day of the event. eLua demos will also be presented in the second day of the event.
-The activities on October 7th will be dedicated to the use of Lua in games, as part of Lua Games 2009, a pre-event of SBGames 2009.
-We will also proudly offer a &quot;little surprise&quot; for the eLua community.
-
-February 2nd, 2009
-~~~~~~~~~~~~~~~~~~
-We know that we haven't had an official release in a while now, but there's a lot of stuff going on with the project. The next release will
-definitely happen before the end of February and it will come with a lot of interesting new features, including support for two new
-platforms, a completely redesigned documentation system, and a few surprises that I won't mention just yet :) So stay tuned, we're working
-hard to make eLua better for you.
-
-November 1st, 2008
-~~~~~~~~~~~~~~~~~~
-Version 0.5 is released! Among other goodies, it brings TCP/IP support to eLua. Here's the changelog:
-
-- Added support for STR7 CPUs from ST 
-- Added TCP/IP support using the uIP stack 
-- Added support for console and shell over TCP/IP besides the previous serial link\
-- Added the &quot;net&quot; module (eLua's interface to TCP/IP functions) 
-- Added the &quot;cpu&quot; module (eLua's interface to the target CPU) 
-- New samples: morse.lua (Morse code encoder), lhttpd.lua (Lua scripting HTTP server) 
-- Added support for cross-compiling Lua code (compile on PC, run on target)
-- XMODEM can now receive Lua bytecode in addition to Lua source code 
-- The XMODEM buffer is now dynamic (grows as needed) instead of fixed size
-- Project documentation updated
-
-Also, there's a new tutorial about link:installing_str7.html[how to use eLua with STR7 CPUs]. The rest of the project page was updated to reflect the current project status, 
-most notably the link:faq.html[FAQ], link:examples.html[examples] and link:status.html[status] pages).
-
-IMPORTANT: You'll need to update your binutils to version 2.19 to use this release with Cortex CPUs. The link:tc_cortex.html[Cortex GCC tutorial] was updated with this information.
-
-Enjoy this new release. The next one will be focused on reducing the memory footprint (both Flash and RAM) of eLua, and (hopefully) will also come with a nice surprise :)
-
-October 16th, 2008
-~~~~~~~~~~~~~~~~~~
-The link:tut_openocd.html[OpenOCD tutorial] was updated with a new section about how to use OpenOCD with a STR7 CPU from ST. Also, the link:overview.html[about page] was updated 
-with more information about the authors of eLua. Expect a new eLua version towards the end of October.
-
-September 10th, 2008
-~~~~~~~~~~~~~~~~~~~~
-Version 0.4.1 is released! This is a minor release, its main purpose is to &quot;keep in sync&quot; with Lua, thus eLua now has the latest official
-Lua version (5.1.4). You probably don't need to upgrade to this version (since 5.1.4 only fixes some minor/exotic bugs in 5.1.3) so I'm only
-providing the source code, without any binaries. Here's the changelog:
-
-- Changed the file system structure; now you can build both Lua versions (floating point and int only) from the same directory
-- Made the math library configurable using the existent &quot;platform libraries&quot; mechanism
-- The&quot;os&quot; and &quot;package&quot; modules are no longer loaded by Lua, since they can't be used anyway. Because of this, the code size of eLua was reduced.
-- Project documentation updated
-
-September 2nd, 2008
-~~~~~~~~~~~~~~~~~~~
-Version 0.4 is released! Here's the changelog:
-
-- Added support for LPC2888 (preliminary)
-- Added PWM module
-- New samples: TV-B-Gone (power off your TV), piano (play piano from your PC keyboard), pwmled (fade led on/off), all based on the new PWM module
-- Added support for multiple memory spaces (this can be used to take advantage of both the internal CPU RAM and external RAM chips on boards that have external RAM)
-- Autorun: if &quot;autorun.lua&quot; is found in the filesystem, it is executed before starting the shell
-- Added &quot;pack&quot; (binary data packing/unpacking) and &quot;bit&quot; (binary operations) modules
-- Build system updated, easier to use, now it knows how to handle &quot;boards&quot; as well as CPUs
-- Modified the existing platform modules to take less RAM and to report an error when an unavailable resource is requested
-- Project documentation updated
-
-September 2nd, 2008
-~~~~~~~~~~~~~~~~~~~
-The eLua site was updated in anticipation of the new 0.4 release, which will come soon (very soon, in fact). Now there's a link:faq.html[FAQ page]. Also, the 
-link:status.html[status and roadmap], link:building.html[building eLua], link:examples.html[example programs] and link:tut_openocd.html[using OpenOCD] pages were updated. 
-And there's yet another new page on link:installing_lpc2888.html[how to use eLua with LPC2888 CPUs]. Expect the 0.4 release later today.
-
-August 9th, 2008
-~~~~~~~~~~~~~~~~
-OK, this took less time than I expected :) The page on how to use eLua with STR9 CPUs is available link:installing_str9.html[here].
-
-August 9th, 2008
-~~~~~~~~~~~~~~~~
-Version 0.3 is released! The project page was updated, with more sections to come soon, including a tutorial on how to use eLua with STR9 CPUs. Here's the changelog for version 0.3:
-
-- Now you can play hangman directly from eLua :), thanks to the new  &quot;term&quot; module that handles ANSI escape sequences
-- Added support for ST STR912FAW44
-- Added support for Cortex LM3S6965
-- More intuitive and flexible build system (new syntax, component selection at build time)
-- eLua examples are now part of the repository
-- Project documentation updated
-
-August 6th, 2008
-~~~~~~~~~~~~~~~~
-The web page was updated with an link:tut_openocd.html[OpenOCD tutorial] that will continue to grow as more and more targets are added. This update is also an informal 
-announcement of the soon to come eLua 0.3 release, which (among other things) brings support for the <A HREF="http://www.hitex.com/index.php?id=383[STR9-comStick">http://www.hitex.com/index.php?id=383[STR9-comStick</A>].
-
-July 29th, 2008
-~~~~~~~~~~~~~~~
-eLua has a new home at BerliOS. Besides the new menu system on the home page, the biggest news is that the code repository is now based on SVN (as opposed to CVS until now). 
-If you're a developer, this is probably good news for you. If not, check the download page to learn about the new eLua download locations.
-
-July 28th, 2008
-~~~~~~~~~~~~~~~
-I got a report that compiling a simple C\++ program for a Cortex CPU with a compiler built after link:tc_cortex.html[my instructions] failed with a linker error. 
-I checked and I found out that the gcc's C\++ library (libstdc++) wasn't even built properly for Cortex-M4. My bad. I updated the tutorial page. The only modification 
-is in step 4, where you need to give more flags to the &quot;make&quot; commands, not just the CFLAGS. Thanks for reporting this.
-
-July 27th, 2008
-~~~~~~~~~~~~~~~
-Version 0.2 is released! Also, as you probably figured out by now, the project page was seriously updated. Here's the changelog for version 0.2:
-
-- Added support for Cortex LM3S8962
-- New platform modules (UART, SPI, Timer, platform data)
-- First release of the eLua shell
-- Lua source files can now be sent to target with XMODEM
-- You can download binary file images from the &quot;files&quot; section, so you don't need to compile eLua yourself
-
-
-July 25th, 2008
-~~~~~~~~~~~~~~~
-Project page updated to reflect the current eLua link:status.html[status and roadmap]. Now there is a separate status and roadmap page. Also, version 0.2 is
-about to be released soon, with many new features, improvements and support for a new platform. More documentation is on the way, too.
-
-July 15th, 2008
-~~~~~~~~~~~~~~~
-Added a link:tut_bootstick.html[tutorial] on how to make your own eLua USB bootable stick! Get it while it's hot! :)
-
-July 11th, 2008
-~~~~~~~~~~~~~~~
-eLua version 0.1 is finally out! Be sure to check the link:downloads.html[download page] and also the project page. The build instructions are included in the
-eLua archive. Also, new tutorials (building cross compilers for ARM and i386) were added, and the link:tut_bootpc.html[boot into Lua] page was updated to reflect 
-the fact that you can build the eLua ELF file yourself now!
-
-July 7th, 2008
-~~~~~~~~~~~~~~
-I'm still &quot;brushing&quot; the source code and adding more documentation before commiting the first version to CVS. Meanwhile, I prepared a (hopefully) nice surprise for all 
-of you who showed interest in eLua (and for those of you who didn't, hopefully this will make you curious :) ). So, if you ever wanted to boot your PC directly in Lua, 
-take a look link:tut_bootpc.html[here]. That's right: no OS, just GRUB loading a multiboot compliant ELF file! The ELF file is built from the exact source tree I'm using to build
-eLua for embedded devices, I only needed to change the platform layer (more about this after uploading the sources and adding some documentation). +
-I hope you'll enjoy this at least as much as I do. While this is only a proof of concept, I am not going to abandon the &quot;standalone Lua on PC&quot; idea, because it could have 
-some very interesting applications (think &quot;BIOS scripting with Lua&quot;, <A HREF="http://en.wikipedia.org/wiki/Open_Firmware[Open">http://en.wikipedia.org/wiki/Open_Firmware[Open</A> Firmware] with Lua instead of Forth, educational 
-applications and many others.)
-
-July 5th, 2008
-~~~~~~~~~~~~~~
-The web page is up! For now you can only read the link:overview.html[project description]. Also, a tutorial about how to compile a GCC toolchain for the Cortex architecture 
-is available link:tc_cortex.html[here].
-
 // $$FOOTER$$
 

Modified: trunk/doc/en/overview.txt
===================================================================
--- trunk/doc/en/overview.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/overview.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -5,137 +5,78 @@
 
 eLua stands for *Embedded Lua* and the project aims to offer the full
 implementation of the <A HREF="http://www.lua.org[Lua">http://www.lua.org[Lua</A> Programming Language] to
-the embedded world.
+the embedded world, extending it with
+specific features for efficient and portable software embedded development.
 
-eLua is not a stripped down set of Lua to fit in the embedded
-environment. Much on the contrary, it strives to offer the same
-features as the desktop version of Lua, complementing them with
-specific features for embedded use and discarting the need of an
-operating system running on the microcontrollers.  Besides offering
-different flavors of the full Lua implementation (like the possibility
-of choosing between an integer-only and a floating point numbers
-implementation), a lot of work was and will be done in the direction
-of making Lua more &quot;embedded-friendly&quot; by augmenting the core language
-with features that allow lower memory requirements and faster embedded
-performance.
-
-Why Lua? Extremely well crafted, Lua is the perfect example of a
-minimal, yet fully functional language.  Although generally advertised
-as a &quot;scripting language&quot; (and used accordingly especially in the game
-industry), it is also fully capable of running stand-alone programs
-and web services (ex: Adobe Lightroom, World of Warcraft, ...). Its
-limited resource requirements make it suitable to a lot of
-microcontroller families. The intrinsic high portability of the
-original Lua code (which is ANSI C and runs virtually on every
-platform), combined with the highly portable software architecture of
-eLua, allow for easy porting of the project to a large variety of
-architectures. The peripheral access libraries/modules exported by
-eLua are also portable by design, so one could run a Lua program
-(without or with very few modifications) on every eLua supported
-platform.  This brings an unprecedent level of portability to the
-embedded aplications world. eLua inherits the minimalistic and
-functional design of Lua, staying in line with the well known *KISS*,
-_Keep it Small and Simple_ philosophy.
-
-The aim of the project is to have a fully functional Lua development
-environment *on the microcontroller itself*, without the need to
-install a specific development environment on the PC side, other than
-a serial or ehternet console/terminal emulator.
-
-We can't end this short presentation without presenting our project
-motto: No matter what you do with eLua, always remember to have Fun
-with it :)
-
 [[features]]
 General Features
 ----------------
 
-As already stated, eLua allows you to run Lua completely on the target
-microcontroller. A fast-growing set of complementary modules is also
-provided, for programming eLua microcontroller's peripherals.
+*eLua* allows you to develop and run Lua programs on a wide variety of microcontrollers.
 
+Some aspects of eLua are:
 
-The following important features are ready or being implemented:
+* *Transforms hardware in commodity:* Design and code your products for
+  eLua and make them as hardware-independent as possible. Upgrade or
+  completely change your hardware in the future and save time and money,
+  using the approved source code with little or no modifications.
+* *Source code portability:* Like in Lua, you program in C, Lua or a
+  mixture of both and your program runs in a wide varied of (sometimes
+  radically different) platforms and architectures supported.
+  Full control of the platform.: eLua runs on the &quot;bare-metal&quot;.  There
+  is no Operating System between your programs and the microcontroller.
+  Develop on targets: fully functional Lua and a dedicated shell on the
+  microcontroller itself. No need to install a specific development
+  environment on the PC side, other than a serial or ehternet
+  console/terminal emulator. You can also use any text editor, save your
+  programs in sd/mmc and other media and use them directly in your
+  platforms.
+* *Flexible products:* Add modern high level script-language capabilities
+  to your projects, resulting in highly adaptable, field-programable and
+  reconfigurable designs. Efficient (and cheap!) future evolution to
+  your systems.
+* *Learn embedded:* Simple interactive and interpreted experimenting
+  cycle. Use your desktop programming skills to become an embedded
+  systems developer in no time and with a lot of fun.
+* *Embedded RAD:* Prototype and experiment on a Rapid Aplication Develop
+  model. Test your ideas directly on the target platforms and cheap
+  development kits. No need for simulators or future code adaptations.
+* *Ready to use kits:* A big (and growing!) number of Open Source hardware
+  and commercially available platforms supported. Prototype cheap and
+  fast and design your final hardware later using the produced code.
+* *Longevity:* Add user configuration and scripting capabilities to your
+  projects, making them adaptable to the always changing contexts of
+  industrial processes, evolving engineering, automation standards,
+  field optimizations etc...
+* *Worry-free Licence:* eLua is free and open-source software and we
+  promote it as much as we can. But our MIT licence (the same as Lua's)
+  allows you to use eLua in your commercial and private-code products as
+  well. Nothing to ask, no royalties to pay, just tell the world you're
+  using eLua.
 
-* a flexible, configurable build system and a free web build service.
-
-* access to the Lua interpreter on the target MCU via a variety of
-  physical transports (RS-232, Ethernet, ...).
-
-* a (mostly) platform independent MCU peripheral library (PIO, UART,
-  PWM, SPI, TMR, ADC, NET, CAN, DAC, I2C, ...)
-
-* a very low footprint embedded ROM file system, easy to port to
-  different types of memory chips and other storage devices
-
-* a small FAT R/W file system layer for SD/MMC cards
-
-* a minimal command &quot;shell&quot;, for file operations, environment
-  configuration and other facilities
-
-* tcp/ip network support
-
-* RPC (remote procedure calls) support. Distributed processing in the
-  embedded world
-
-* an embedded http server
-
-* extended (romable) Lua types, optimized for embedded performance
-
-* terminal/console over serial and ethernet protocols
-
-* debugging (directly on the MCU or remotely with the PC)
-
-* RFS support. Remote file sharing on the embedded world
-
-* full and stand alone implementation on all MCUs. No dependency on
-  embedded operating systems. eLua runs on bare-metal
-
-* online and offline access to (same format) documentation and tutorials
-
-* online user-maintained wiki with projects, tutorials, code and experience sharing, ...
-
-* online issue tracker service. Report issues, ask for features, follow closely the development community activity
-
-
 For more information about the functionality (implemented and planned)
 in eLua check link:status.html[our status page].
 
-Porting eLua to another compatible platform should be as easy and
-painless as possible. Currently this is restricted to platforms for
-which the gcc+newlib combo is available. This restriction will
-disappear in the near future, as eLua will have its own libc and thus
-it will be available on a much broader range of MCUs.
 
-The Lua implementation is the full desktop Lua version and comes in
-two flavors: &quot;regular Lua&quot; (using floating point as the number type)
-and &quot;integer Lua&quot; (using integers). &quot;Regular Lua&quot; will be able to
-perform floating point operations (slower because the floating point
-operations will be emulated in software on the MCU), while &quot;integer
-Lua&quot; will only be able to perform operations with integer numbers (but
-support for fixed and even floating point can be added with separate
-modules) and thus will be faster.
-
 [[audience]]
 Audience
 --------
 
-eLua has a wide and varied audience, starting from newcomers to the
-embedded world who want an easy and powerful environment for
-prototyping, rapid application development and quick production, and
-ranging towards highly skilled developers that want to extend their
-programs with the Lua library facilities and portable features.
+*eLua* has a wide and varied audience, starting from newcomers to the embedded
+world who want an easy and powerful environment for prototyping, rapid
+application development and quick production, and ranging towards highly
+skilled developers that want to extend their programs with the high-level
+Lua libraries and portable features.
 
-eLua allows embedded-oriented programmers to use the simplicity and
-power of the Lua programming language and to hide the low-level
-complexities and platform/architecture-dependent features. With eLua,
-the programmer can focus on the actual implementation of his program,
-without having to worry about accessing the low-level peripheral
-configuration and data registers, as the platform libraries already
-take care of this. This increases productivity and eliminates the
-often frustrating task of dealing with platform-specific drivers.
+*eLua* allows embedded-oriented programmers to use the simplicity and power of
+the Lua programming language and to hide the low-level complexities and
+platform/architecture-dependent features. With eLua, the programmer can
+focus on the actual implementation of his program, without having to worry
+about accessing the low-level peripheral configuration and data registers,
+as the platform libraries already take care of this. This increases
+productivity and eliminates the often frustrating task of dealing with
+platform-specific drivers.
 
-
 The list below summarizes eLua's target audience:
 
 * Embedded developers that are looking for a fast, easy to use and
@@ -161,6 +102,19 @@
   diferent models, brands and architectures have no impact on the main
   application software.
 
+Current Status
+--------------
+The project is very active and the worldwide distributed collaboration has 
+been growing steadly. Manufacturers, user's companies and other organizations
+are also starting to collaborate and support the project.
+
+The current official version is *eLua v0.8* and we have released 9 versions
+since the project was published.
+
+Supported platforms and features include a wide range of microcontroller
+families and architectures. A list of currently supported platforms, 
+peripherals and features can be seen in our link:status.html[Status page]
+
 [[authors]]
 Authors
 -------
@@ -209,7 +163,7 @@
 
 The Lua code (with all the eLua specific changes) is included in the
 source tree and is, of course, licensed under the same 
-<A HREF="http://en.wikipedia.org/wiki/MIT_License:[MIT">http://en.wikipedia.org/wiki/MIT_License:[MIT</A> license that Lua uses].
+<A HREF="http://en.wikipedia.org/wiki/MIT_License[MIT">http://en.wikipedia.org/wiki/MIT_License[MIT</A> license that Lua uses].
 
 Other (few) components have different licenses. Please see the file
 LICENSE in the source distribution for details.
@@ -251,7 +205,7 @@
 <A HREF="https://github.com/antirez/linenoise[linenoise">https://github.com/antirez/linenoise[linenoise</A>] (eLua's readline replacement) 
 is released under a BSD license. 
 
-The rest of the eLua code is licensed under MIT.
+The rest of the eLua code is licensed under <A HREF="http://en.wikipedia.org/wiki/MIT_License[MIT">http://en.wikipedia.org/wiki/MIT_License[MIT</A>].
 
 // $$FOOTER$$
 

Modified: trunk/doc/en/sermux.txt
===================================================================
--- trunk/doc/en/sermux.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/sermux.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -4,7 +4,7 @@
 *(v0.8 and above)* The *serial multiplexer* is an optional eLua component that allows
 using several serial ports over a single physical serial link connection. It can be a 
 very convenient feature, since some eLua components (such as link:using.html#rpc[the RPC mechanism] 
-or link:arfs_rfs.html[the remote file system]) need a serial link to the PC and 
+or link:arch_rfs.html[the remote file system]) need a serial link to the PC and 
 it's very incovenient (or even impossible sometimes) to connect the eLua board 
 to the PC with 2 or more serial cables. A common use scenario for the serial
 multiplexer is to have the eLua shell and RFS running over a single physical 

Modified: trunk/doc/en/status.txt
===================================================================
--- trunk/doc/en/status.txt	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/status.txt	2011-02-02 17:52:12 UTC (rev 949)
@@ -26,6 +26,7 @@
 | _LM3S6965      |  Cortex-M3    o|    LM3S               |  _EK-LM3S6965     | _sok
 | _LM3S6918      |  Cortex-M3    o|    LM3S               |  _Eagle-100       | _sok
 | _LM3S9B92      |  Cortex-M3    o|    LM3S               |  _EK-LM3S9B92     | _sok
+| _LM3S1968      |  Cortex-M3    o|    LM3S               |  _EK-LM3S1968     | _sok
 | _AT32UC3A0512  |  AVR32        o|    AVR32              |  _ATEVK1100       | _sok
 | _AT32UC3B0256  |  AVR32        o|    AVR32              |  _ATEVK1101       | _sok
 | _AT91SAM7X256  |  ARM7TDMI     o|    AT91SAM7X          |  _SAM7-EX256      | _sok
@@ -38,7 +39,8 @@
 | _STR912FAW44   |  ARM966E-S    o|    STR9               |  _STR-E912        | _sok
 | _STM32F103ZE   |  Cortex-M3    o|    STM32              |  _STM3210E-EVAL   | _sok
 | _STM32F103RE   |  Cortex-M3    o|    STM32              |  _ET-STM32Stamp   | _sok
-| _i386          |  x86          o|    i386               |  PCs/emulators    | _sok
+| _AT32UC3A0128  |  AVR32        o|    AVR32              |  _Mizar32         | _sok
+| _I386          |  x86          o|    i386               |  PCs/emulators    | _sok
 |=====================================================================================
 
 [[plat_modules]]
@@ -46,58 +48,71 @@
 -------------------
 The relationship between a module and its implementation on a particular platform is given in the next table.
 
-[width=&quot;70%&quot;, cols=&quot;&lt;4, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1&quot;, options=&quot;header&quot;]
-|===================================================================================================================================
-^| MCU            15+| Module
-|               g|  pio g|  spi g|  uart g|  tmr g|  pwm g|  net g|  cpu g|  adc g|   pd g| term g|  bit g| pack g|  can g|  rpc g| mmc
-| _LM3S8962      | _sok  | _snt  | _sok   | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sni  | _snt  | _snt 
-| _LM3S6965      | _sok  | _snt  | _sok   | _sok  | _snt  | _snt  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sna  | _sok  | _sok
-| _LM3S6918      | _sok  | _snt  | _sok   | _sok  | _sna  | _snt  | _sok  | _snt  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sni
-| _LM3S9B92      | _sok  | _snt  | _sok   | _sok  | _sok  | _sok  | _sok  | _snt  | _sok  | _sok  | _sok  | _sok  | _sni  | _snt  | _sok
-| _AT32UC3A0512  | _sok  | _sni  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _sni  | _sni
-| _AT32UC3B0256  | _sok  | _sni  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _sni  | _sni
-| _AT91SAM7X256  | _sok  | _sni  | _sok   | _sok  | _sok  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _sni  | _sni
-| _AT91SAM7X512  | _snt  | _sni  | _snt   | _snt  | _snt  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _sni  | _sni
-| _LPC1768       | _sok  | _sni  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _sni  | _sni
-| _LPC2468       | _sok  | _sni  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _sni  | _sni
-| _LPC2888       | _sok  | _sni  | _sok   | _sok  | _sna  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _sni  | _sni
-| _STR711FR2     | _sok  | _sni  | _sok   | _sok  | _snt  | _sna  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _sni  | _sni
-| _STR912FAW44   | _sok  | _sni  | _sok   | _sok  | _sok  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _sni  | _sni
-| _STM32F103ZE   | _sok  | _sni  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _sni  | _sni 
-| _STM32F103RE   | _sok  | _sni  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _snt  | _sni  | _sni
-| _i386          | _sna  | _sna  | _sni   | _sni  | _sna  | _sni  | _sni  | _sna  | _sok  | _sni  | _sni  | _sni  | _sna  | _sni  | _sni
-|===================================================================================================================================
+[width=&quot;70%&quot;, cols=&quot;&lt;4, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1, ^1&quot;, options=&quot;header&quot;]
+|================================================================================================================================================
+^| MCU            16+| Module
+|               g|  pio g|  spi g|  uart g|  tmr g|  pwm g|  net g|  cpu g|  adc g|   pd g| term g|  bit g| pack g|  can g|  rpc g| mmc  g|  i2c
+| _LM3S8962      | _sok  | _sok  | _sok   | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _snt  | _snt  | _sni
+| _LM3S6965      | _sok  | _sok  | _sok   | _sok  | _sok  | _snt  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sna  | _sok  | _sok  | _sni
+| _LM3S6918      | _sok  | _snt  | _sok   | _sok  | _sna  | _snt  | _sok  | _snt  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sni  | _sni
+| _LM3S9B92      | _sok  | _snt  | _sok   | _sok  | _sok  | _sok  | _sok  | _snt  | _sok  | _sok  | _sok  | _sok  | _sok  | _snt  | _sok  | _sni
+| _LM3S1968      | _sok  | _snt  | _sok   | _sok  | _sok  | _sna  | _sok  | _snt  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sni  | _sni
+| _AT32UC3A0512  | _sok  | _sok  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sok  | _sni
+| _AT32UC3A0128  | _sok  | _sok  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sok  | _sni
+| _AT32UC3B0256  | _sok  | _sok  | _sok   | _sok  | _sni  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sok  | _sni
+| _AT91SAM7X256  | _sok  | _sni  | _sok   | _sok  | _sok  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _snt  | _sni  | _sni
+| _AT91SAM7X512  | _snt  | _sni  | _snt   | _snt  | _snt  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sni  | _snt  | _sni  | _sni
+| _LPC1768       | _sok  | _sni  | _sok   | _sok  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sni  | _snt  | _sni  | _sni
+| _LPC2468       | _sok  | _sni  | _sok   | _sok  | _sni  | _sni  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sni  | _snt  | _sni  | _sni
+| _LPC2888       | _sok  | _sni  | _sok   | _sok  | _sna  | _sni  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sni  | _sni
+| _STR711FR2     | _sok  | _sni  | _sok   | _sok  | _snt  | _sna  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sna  | _snt  | _sni  | _sni
+| _STR912FAW44   | _sok  | _sni  | _sok   | _sok  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sni  | _snt  | _sni  | _sok
+| _STM32F103ZE   | _sok  | _sok  | _sok   | _sok  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sni  | _sok  | _sok  | _sni
+| _STM32F103RE   | _sok  | _sok  | _sok   | _sok  | _sok  | _sni  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sok  | _sni
+| _I386          | _sna  | _sna  | _sni   | _sni  | _sna  | _sni  | _sni  | _sna  | _sok  | _sok  | _sok  | _sok  | _sna  | _sni  | _sna  | _sna
+|================================================================================================================================================
 
+[[plat_notes]]
+Platform Status Notes
+~~~~~~~~~~~~~~~~~~~~~
+The eLua peripheral modules attempt to provide similar functionality on all platforms for which they are implemented, however some module function varies between platforms. Some known inconsistencies are listed below.
+
+.adc
+* STM32: Only timer 2 is supported for clocked conversions.
+* STR9: Clocked conversions are not supported by hardware.
+* LPC17xx: Only timer 1 is supported for clocked conversions.
+* LPC24xx: Only timer 1 is supported for clocked conversions.
+
+
 [[gen_modules]]
 eLua modules
 ------------
 The following table shows a list of the generic modules currently implemented (and planned to be implemented) in eLua.
 
 [width=&quot;70%&quot;, cols=&quot;&lt;1, &lt;5, ^1&quot;, options=&quot;header&quot;]
-|=========================================================================
-|Name     ^|Description                                           | Status 
-o|pio      | programmable input/output                            | _sok
-o|tmr      | periodic timer                                       | _sok
-o|pwm 	   | pulse width modulation                               | _sok
-o|uart 	   | universal asynchronous receiver transmitter          | _sok
-o|spi 	   | serial peripheral interface                          | _sok
-o|net  	   | TCP/IP networking                                    | _sok
-o|adc 	   | analog to digital converter                          | _sok 
-o|dac 	   | digital to analog converter                          | _sni
-o|cpu 	   | low level system access                              | _sok
-o|pd 	   | platform data                                        | _sok
-o|term 	   | ANSI terminal access                                 | _sok
-o|bit 	   | bitwise operations                                   | _sok
-o|pack 	   | pack/unpack binary data                              | _sok
-o|cmp 	   | analog comparator                                    | _sni
-o|i2c 	   | inter-integrated circuit protocol                    | _sni
-o|cnt 	   | event counter                                        | _sni
-o|can 	   | controller area network                              | _snt
-o|rpc 	   | remote procedure call                                | _snt
-o|i2s 	   | inter-IC sound                                       | _sni
-o|mmc 	   | SD/MMC card FAT file system                          | _sok
-o|disp 	   | LCD, OLED and other displays support                 | _sok
-|=========================================================================
+|===========================================================================
+|Name       ^|Description                                           | Status 
+o|_mpio      | Programmable input/output                            | _sok
+o|_mtmr      | Physical and virtual timers                          | _sok
+o|_mpwm      | Pulse width modulation                               | _sok
+o|_muart     | Universal asynchronous receiver transmitter          | _sok
+o|_mspi      | Serial peripheral interface                          | _sok
+o|_mnet      | TCP/IP networking                                    | _sok
+o|_madc      | Analog to digital converter                          | _sok 
+o|dac 	     | Digital to analog converter                          | _sni
+o|_mcpu      | Low level system access                              | _sok
+o|_mpd       | Platform data                                        | _sok
+o|_mterm     | ANSI terminal access                                 | _sok
+o|_mbit      | Bitwise operations                                   | _sok
+o|_mpack     | Pack/unpack binary data                              | _sok
+o|cmp 	     | Analog comparator                                    | _sni
+o|_mi2c      | Inter-integrated circuit protocol                    | _sok
+o|cnt 	     | Event counter                                        | _sni
+o|_mcan      | Controller area network                              | _snt
+o|_mrpc      | Remote procedure call                                | _sok
+o|i2s 	     | Inter-IC sound                                       | _sni
+o|_melua     | eLua system control                                  | _sok
+|===========================================================================
 
 For some platforms, a number of platform dependent modules are implemented (or in the works) and are listed below. To understand the difference between generic 
 modules and platform specific modules, check link:arch_overview.html[the eLua architecture page].
@@ -105,10 +120,10 @@
 [width=&quot;70%&quot;, cols=&quot;&lt;.^1, &lt;.^4, &lt;.^3, ^.^1&quot;, options=&quot;header&quot;]
 |=======================================================================================
 ^|    Name   ^| Description                   ^|      Boards                   ^| Status
-o| disp       | OLED display support           | _EK-LM3S8962 _br _EK-LM3S6965  | _sok
-o| str9.pio   | Extended PIO configuration     | _STR-E912 _br _STR9-comStick   | _sok
-o| str9.rtc   | Real time clock                | _STR-E912                      | _sok
-o| str9.rtc   | Real time clock                |  _STR9-comStick                | _snt
+o| _mlm3sdisp | OLED display support           | _EK-LM3S8962 _br _EK-LM3S6965  | _sok
+o| _mstr9pio  | Extended PIO configuration     | _STR-E912 _br _STR9-comStick   | _sok
+o| _mmbedpio  | Extended PIO configuration     | _mbed                          | _sok
+o| _mstr9rtc  | Real time clock                | _STR-E912 _br _STR9-comStick   | _sok
 |=======================================================================================
 
 [[roadmap]]
@@ -124,23 +139,23 @@
 | Various Lua examples and eLua apps running properly                 | _sok
 | Lua floating point or integer number selection                      | _sok
 | eLua FP module (for integer Lua)                                    | _sni
-| XMODEM protocol support for console file transfer                   | _sok
-| Embedded ROM (Flash) file system                                    | _sok
+| link:using.html#shell[XMODEM protocol support for console file transfer] | _sok
+| link:arch_romfs.html[Embedded ROM (Flash) file system]              | _sok
 | link:fatfs.html[FAT File System layer for mmc/sd cards]             | _sok
 | link:using.html#rpc[LuaRPC - Remote Procedure Calls]                | _snt
 | link:using.html#uart[Terminal / Console over UART or Ethernet]      | _sok
 | link:using.html#shell[eLua command shell]                           | _sok
-| Lua interrupt handlers                                              | _snt
-| C interrupt handlers                                                | _snt
+| link:inthandlers.html[Lua interrupt handlers]                       | _sok
+| link:inthandlers.html[C interrupt handlers]                         | _sok
 | link:arch_ltr.html[eLua LTR (Lua Tiny RAM) patch]                   | _sok
 | link:elua_egc.html[eLua EGC (Emergency Garbage Collection) patch]   | _sok
 | Loadable binary modules                                             | _sni
 | Embedded text editor                                                | _sni
 | Embedded help/doc subsystem                                         | _sni
 | Lua debugging (remote/on target)                                    | _sni
-| Remote (PC) File Sharing                                            | _snt
+| link:arch_rfs.html[Remote (PC) File Sharing]                        | _sok
 | GUI/IDE interface for eLua                                          | _sni
-| eLua web build service                                              | _sok
+| <A HREF="http://builder.eluaproject.net[eLua">http://builder.eluaproject.net[eLua</A> web build service]              | _sok
 |=============================================================================
 
 // $$FOOTER$$                                                    

Modified: trunk/doc/en/using.html
===================================================================
--- trunk/doc/en/using.html	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/using.html	2011-02-02 17:52:12 UTC (rev 949)
@@ -141,6 +141,11 @@
 &lt;pre&gt;&lt;code&gt;$ cat &lt;i&gt;filename1&lt;/i&gt; [&lt;i&gt;filename2 filename3 ...&lt;/i&gt;]
 $ type &lt;i&gt;filename1&lt;/i&gt; [&lt;i&gt;filename2 filename3 ...&lt;/i&gt;]&lt;/code&gt;&lt;/pre&gt;
 
+&lt;h2&gt;cp&lt;/h2&gt;
+&lt;p&gt;Copies a file to another file. This command can be used to copy files between different file systems (for example between the MMC file system and the RFS file system).&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;$ cp &lt;i&gt;source&lt;/i&gt; &lt;i&gt;destination&lt;/i&gt;&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;Note that both &lt;b&gt;source&lt;/b&gt; and &lt;b&gt;destination&lt;/b&gt; must be file names.&lt;/p&gt;
+
 &lt;h2&gt;exit&lt;/h2&gt;
 &lt;p&gt;Exits the shell. This only makes sense if &lt;b&gt;eLua&lt;/b&gt; is compiled with terminal support over TCP/IP , as it closes the telnet session to the &lt;b&gt;eLua&lt;/b&gt; board. Otherwise it just
   terminates the shell and blocks forever until you reset your board.&lt;/p&gt;

Modified: trunk/doc/en/xhtml11.conf
===================================================================
--- trunk/doc/en/xhtml11.conf	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/doc/en/xhtml11.conf	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,22 +1,22 @@
-# Document sections.
-[sect0]
-&lt;h1{id? id=&quot;{id}&quot;}&gt;{title}&lt;/h1&gt;
-|
-
-[sect1]
-&lt;h3{id? id=&quot;{id}&quot;}&gt;{numbered?{sectnum} }{title}&lt;/h3&gt;
-&lt;div class=&quot;sectionbody&quot;&gt;
-|
-&lt;/div&gt;
-
-[sect2]
-&lt;h2{id? id=&quot;{id}&quot;}&gt;{numbered?{sectnum} }{title}&lt;/h2&gt;
-|
-
-[sect3]
-&lt;h4{id? id=&quot;{id}&quot;}&gt;{numbered?{sectnum} }{title}&lt;/h4&gt;
-|
-
-[sect4]
-&lt;h5{id? id=&quot;{id}&quot;}&gt;{title}&lt;/h5&gt;
-
+# Document sections.
+[sect0]
+&lt;h1{id? id=&quot;{id}&quot;}&gt;{title}&lt;/h1&gt;
+|
+
+[sect1]
+&lt;h3{id? id=&quot;{id}&quot;}&gt;{numbered?{sectnum} }{title}&lt;/h3&gt;
+&lt;div class=&quot;sectionbody&quot;&gt;
+|
+&lt;/div&gt;
+
+[sect2]
+&lt;h2{id? id=&quot;{id}&quot;}&gt;{numbered?{sectnum} }{title}&lt;/h2&gt;
+|
+
+[sect3]
+&lt;h4{id? id=&quot;{id}&quot;}&gt;{numbered?{sectnum} }{title}&lt;/h4&gt;
+|
+
+[sect4]
+&lt;h5{id? id=&quot;{id}&quot;}&gt;{title}&lt;/h5&gt;
+

Deleted: trunk/mux_src/main.c.allthreads
===================================================================
--- trunk/mux_src/main.c.allthreads	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/mux_src/main.c.allthreads	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,349 +0,0 @@
-// Service multiplexer 
-
-#include &lt;stdio.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;semaphore.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;limits.h&gt;
-#include &quot;config.h&quot;
-#include &quot;log.h&quot;
-#include &quot;type.h&quot;
-#include &quot;serial.h&quot;
-
-// ****************************************************************************
-// Data structures and local variables
-
-#define TRANSPORT_TYPE_ERROR        0
-#define TRANSPORT_TYPE_SER          1
-
-// Service ID of the transport thread
-#define TRANSPORT_SERVICE_ID        -1
-
-// Send/receive/init function pointers
-typedef u32 ( *p_recv_func )( u8 *p, u32 size );
-typedef u32 ( *p_send_func )( const u8 *p, u32 size );
-typedef int ( *p_init_func )( void );
-
-// Serial thread buffer structure
-typedef struct 
-{
-  pthread_t tid;
-  const char *pname;
-  ser_handler fd;
-  int service_id;
-} THREAD_DATA;
-
-// Serial transport data structure
-typedef struct 
-{
-  ser_handler fd;
-  const char *pname;
-  long speed;
-} TRANSPORT_SER;
-
-// Service/transport data
-typedef struct 
-{
-  int id;
-  u8 data;
-} DATA;
-
-static THREAD_DATA *threads;
-static unsigned vport_num;
-
-static void *transport_data;
-static int transport_type;
-static p_recv_func transport_recv;
-static p_send_func transport_send;
-static p_init_func transport_init;
-
-static long service_baud;
-static sem_t mux_w_sem, mux_r_sem;
-static DATA mux_data;
-static int service_id_in = -1, service_id_out = -1;
-
-// ***************************************************************************
-// Serial transport implementation
-
-static u32 transport_ser_recv( u8 *p, u32 size ) 
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_read( pser-&gt;fd, p, size, SER_INF_TIMEOUT );
-}
-
-static u32 transport_ser_send( const u8 *p, u32 size )
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_write( pser-&gt;fd, p, size );
-}
-
-static int transport_ser_init()
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  if( ( pser-&gt;fd = ser_open( pser-&gt;pname ) ) == ( ser_handler )-1 )
-  {
-    fprintf( stderr, &quot;Unable to open %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  if( ser_setup( pser-&gt;fd, pser-&gt;speed, 8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-  {
-    fprintf( stderr, &quot;Unable to setup serial port %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  while( ser_read_byte( pser-&gt;fd, SER_NO_TIMEOUT ) != -1 );
-  printf( &quot;Running serial transport on port %s at %u baud (8N1)\n&quot;, pser-&gt;pname, ( unsigned )pser-&gt;speed );
-  return 1;
-}
-
-// ****************************************************************************
-// Utility functions and helpers
-
-static void transport_send_byte( u8 data )
-{
-  transport_send( &amp;data, 1 );
-}
-
-static int transport_read_byte() 
-{
-  u8 c;
-
-  return transport_recv( &amp;c, 1 ) == 1 ? c : -1;
-}
-
-// Secure atoi
-static int secure_atoi( const char *str, long *pres )
-{
-  char *end_ptr;
-  long s1;
-  
-  errno = 0;
-  s1 = strtol( str, &amp;end_ptr, 10 );
-  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
-    return 0;
-  else if( end_ptr == str )
-    return 0;
-  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
-    return 0;
-  else if( '\0' != *end_ptr )
-    return 0;
-  *pres = s1;
-  return 1;  
-}
-
-// Transport parser
-static int parse_transport( const char* s )
-{
-  const char *c;
-  static TRANSPORT_SER tser; 
-
-  if( strstr( s, &quot;ser:&quot; ) == s )
-  {
-    s += strlen( &quot;ser:&quot; );
-    if( ( c = strchr( s, ',' ) ) == NULL )
-    {
-      fprintf( stderr, &quot;Invalid serial transport syntax\n&quot; );
-      return 0;
-    }
-    if( secure_atoi( c + 1, &amp;tser.speed ) == 0 )
-    {
-      fprintf( stderr, &quot;Invalid port speed\n&quot; );
-      return 0;
-    }
-    tser.pname = strndup( s, c - s );
-    transport_data = &tser;
-    transport_send = transport_ser_send;
-    transport_recv = transport_ser_recv;
-    transport_init = transport_ser_init;
-    transport_type = TRANSPORT_TYPE_SER;
-    return 1;
-  }
-  fprintf( stderr, &quot;Error: unsupported transport\n&quot; );
-  return 0;
-}
-
-// ***************************************************************************
-// Service thread
-
-static void* service_thread( void* data )
-{
-  THREAD_DATA *pdata = ( THREAD_DATA*) data;
-  int sdata;
-
-  log_msg( &quot;Starting service thread for port %s\n&quot;, pdata-&gt;pname );
-  while( 1 ) 
-  {
-    if( ( sdata = ser_read_byte( pdata-&gt;fd, SER_INF_TIMEOUT ) ) == -1 )
-      continue;
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = pdata-&gt;service_id;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-// ****************************************************************************
-// Transport thread
-
-static void* transport_thread( void* data )
-{
-  int sdata;
-
-  log_msg( &quot;Starting transport thread\n&quot; );
-  while( 1 ) 
-  {
-    if( ( sdata = transport_read_byte() ) == -1 )
-      continue;
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = TRANSPORT_SERVICE_ID;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-// ****************************************************************************
-// Program entry point
-
-#define MAIN_TRANSPORT_IDX    1
-#define SERVICE_BAUD_IDX      2
-#define FIRST_SERVICE_IDX     3
-
-int main( int argc, char **argv )
-{
-  unsigned i;
-  THREAD_DATA *tdata;
-  int c;
-  int temp, sdata;
-  int got_esc = 0;
-  DATA data;
-
-  // Interpret arguments
-  if( argc &lt; 4 )
-  {
-    fprintf( stderr, &quot;Usage: %s &lt;transport&gt; &lt;baud&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]\n&quot;, argv[ 0 ] );
-    return 1;
-  }
-  i = argc - 1;
-  if( !strcasecmp( argv[ i ], &quot;-v&quot; ) )
-  {
-    i --;
-    log_init( LOG_ALL );
-  }
-  else
-    log_init( LOG_NONE ); 
-  if( ( vport_num = i - 2 ) &gt; SERVICE_MAX )
-  {
-    fprintf( stderr, &quot;Too many service ports, maximum is %d\n&quot;, SERVICE_MAX );
-    return 1;
-  }
-  if( parse_transport( argv[ MAIN_TRANSPORT_IDX ] ) == 0 )
-    return 1;
-  if( secure_atoi( argv[ SERVICE_BAUD_IDX ], &amp;service_baud ) == 0 )
-  {
-    fprintf( stderr, &quot;Invalid service baud\n&quot; );
-    return 1;
-  }
-  if( transport_init() == 0 )
-    return 1;
-
-  // Create global sync objects
-  sem_init( &amp;mux_w_sem, 0, 1 );
-  sem_init( &amp;mux_r_sem, 0, 0 );
-
-  // Open all the service ports and create their corresponding threads
-  if( ( threads = ( THREAD_DATA* )malloc( sizeof( THREAD_DATA ) * ( vport_num + 1 ) ) ) == NULL )
-  {
-    fprintf( stderr, &quot;Not enough memory\n&quot; );
-    return 1;
-  }
-  for( i = 0; i &lt;= vport_num; i ++ ) 
-  {
-    tdata = threads + i;
-    if( i &lt; vport_num )
-    {
-      if( ( tdata-&gt;fd = ser_open( argv[ i + FIRST_SERVICE_IDX ] ) ) == ( ser_handler )-1 )
-      {
-        fprintf( stderr, &quot;Unable to open port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
-        return 1;
-      }
-      if( ser_setup( tdata-&gt;fd, service_baud, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-      {
-        fprintf( stderr, &quot;Unable to setup serial port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
-        return 1;
-      }
-      tdata-&gt;pname = argv[ i + FIRST_SERVICE_IDX ];
-      tdata-&gt;service_id = i + SERVICE_ID_FIRST;
-    }
-    if( pthread_create( &amp;tdata-&gt;tid, NULL, i == vport_num ? transport_thread : service_thread, ( void* )tdata ) )
-    {
-      fprintf( stderr, &quot;Unable to create thread\n&quot; );
-      return 1;
-    }
-  }
-
-  printf( &quot;Starting service multiplexer on %u port(s)\n&quot;, vport_num );
-  // Main service thread
-  while( 1 )
-  {
-    sem_wait( &amp;mux_r_sem );
-    data = mux_data;
-    sem_post( &amp;mux_w_sem );
-    if( data.id == TRANSPORT_SERVICE_ID )
-    {
-      // Read one byte, interpret it
-      c = data.data;
-      if( c != ESCAPE_CHAR )
-      {
-        if( c &gt;= SERVICE_ID_FIRST &amp;&amp; c &lt;= SERVICE_ID_LAST )
-          service_id_in = c;
-        else
-        {
-          if( got_esc )
-          {
-            // Got an escape last time, check the char now (with the 5th bit flipped)
-            c ^= ESCAPE_XOR_MASK;
-            if( c != ESCAPE_CHAR &amp;&amp; c &lt; SERVICE_ID_FIRST &amp;&amp; c &gt; SERVICE_ID_LAST )
-            {
-               fprintf( stderr, &quot;Protocol error: invalid escape sequence\n&quot; );
-               return 1;
-            }
-            got_esc = 0;
-          }  
-          if( service_id_in == -1 )
-          {
-            fprintf( stderr, &quot;Protocol error: service ID not specified\n&quot; );
-            return 1;
-          }
-          ser_write_byte( threads[ service_id_in - SERVICE_ID_FIRST ].fd, c );
-        }
-      }
-      else
-        got_esc = 1;
-    }
-    else
-    {
-      temp = data.id;
-      sdata = data.data;
-      if( temp != service_id_out )
-        transport_send_byte( temp );
-      // Then send the actual data byte, escaping it if needed
-      if( sdata == ESCAPE_CHAR || ( sdata &gt;= SERVICE_ID_FIRST &amp;&amp; sdata &lt;= SERVICE_ID_LAST ) )
-      {
-        transport_send_byte( ESCAPE_CHAR );
-        transport_send_byte( ( u8 )sdata ^ ESCAPE_XOR_MASK );
-      }
-      else
-        transport_send_byte( sdata );
-      service_id_out = temp;
-    }
-  }
-
-  return 0;
-}
-

Deleted: trunk/mux_src/main.c.old
===================================================================
--- trunk/mux_src/main.c.old	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/mux_src/main.c.old	2011-02-02 17:52:12 UTC (rev 949)
@@ -1,755 +0,0 @@
-// Service multiplexer 
-
-#include &lt;stdio.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;semaphore.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;limits.h&gt;
-#include &quot;config.h&quot;
-#include &quot;log.h&quot;
-#include &quot;type.h&quot;
-#include &quot;serial.h&quot;
-#include &quot;os_io.h&quot;
-#include &quot;pnet.h&quot;
-
-// External RFS functions
-extern int rfs_server_init( unsigned server_port, const char* dirname );
-extern void rfs_server_cleanup();
-extern void* rfs_thread( void* data );
-extern volatile int rfs_thread_should_die;
-
-// ****************************************************************************
-// Data structures and local variables
-
-#define TRANSPORT_TYPE_ERROR        0
-#define TRANSPORT_TYPE_SER          1
-#define TRANSPORT_TYPE_UDP          2
-#define TRANSPORT_TYPE_TEXTCTRL     3
-
-// Service ID of the transport thread
-#define TRANSPORT_SERVICE_ID        ( -1 )
-#define THREAD_STOP_SERVICE_ID      ( -2 )  
-
-// Thread indexes in the threads array
-#ifdef MUX_THREAD_MODE
-#define TEXTCTRL_THREAD_IDX         1
-#else
-#define TEXTCTRL_THREAD_IDX         ( -1 )
-#endif
-#define RFS_UDP_THREAD_IDX          0
-        
-// Send/receive/init function pointers for transport
-typedef u32 ( *p_recv_func )( u8 *p, u32 size );
-typedef u32 ( *p_send_func )( const u8 *p, u32 size );
-typedef int ( *p_init_func )( void );
-typedef void ( *p_cleanup_func )( void );
-
-// Thread function type
-typedef void* ( *p_thread_func )( void* );
-
-// Thread structure
-typedef struct 
-{
-  pthread_t tid;
-  int thread_created;
-  volatile int thread_should_die;
-  int type;  
-  union
-  {
-    const char *pname;
-    unsigned port;
-  };
-  union
-  {
-    ser_handler fd;
-    SOCKET s;
-  };
-  int service_id;
-  struct sockaddr_in server;
-  union
-  {
-    sem_t udp_sem;
-    sem_t textctrl_sem;
-  };
-  int textctrl_data;
-  u8 *udp_buf;
-} THREAD_DATA;
-
-// Serial transport data structure
-typedef struct 
-{
-  ser_handler fd;
-  char *pname;
-  long speed;
-} TRANSPORT_SER;
-
-// Service/transport data
-typedef struct 
-{
-  int id;
-  u8 data;
-} DATA;
-
-static THREAD_DATA *threads;
-static unsigned vport_num;
-
-static void *transport_data;
-static int transport_type;
-static p_recv_func transport_recv;
-static p_send_func transport_send;
-static p_init_func transport_init;
-static p_cleanup_func transport_cleanup;
-static long service_baud;
-static sem_t mux_w_sem, mux_r_sem;
-static DATA mux_data;
-static int service_id_in = -1, service_id_out = -1;
-static pthread_t rfs_thread_id;
-static int rfs_thread_created;
-volatile int mux_thread_running;
-
-// *****************************************************************************
-// wxTextCtrl &quot;transport&quot; helpers
-
-#ifdef MUX_THREAD_MODE
-
-// wxTextCtrl buffer data
-typedef struct
-{
-  int *pdata;
-  unsigned r_idx, w_idx, total;  
-  sem_t count_sem;
-} TEXTCTRL_DATA;
-
-static TEXTCTRL_DATA textctrl_data;
-
-int mux_textctrl_init( unsigned total )
-{                                  
-  if( ( textctrl_data.pdata = ( int* )malloc( total * sizeof( int ) ) ) == NULL )
-  {
-    log_err( &quot;Unable to alloc textctrl buffer\n&quot; );
-    return 0;
-  }
-  textctrl_data.r_idx = textctrl_data.w_idx = 0;
-  textctrl_data.total = total;
-  sem_init( &amp;textctrl_data.count_sem, 0, 0 );
-  return 1;
-}
-
-void mux_textctrl_cleanup()
-{
-  free( textctrl_data.pdata );
-  sem_destroy( &amp;textctrl_data.count_sem );
-}
-
-void textctrl_get_char( int c )
-{
-#if 0
-  textctrl_data.pdata[ textctrl_data.w_idx ] = c;
-  textctrl_data.w_idx = ( textctrl_data.w_idx + 1 ) % textctrl_data.total;
-  printf( &quot;!&quot; );
-  sem_post( &amp;textctrl_data.count_sem );
-#else
-  THREAD_DATA *pdata = threads + TEXTCTRL_THREAD_IDX;
-  pdata-&gt;textctrl_data = c;
-  sem_post( &amp;pdata-&gt;textctrl_sem );
-#endif
-}
-
-extern void textctrl_put_char( int c );
-
-#else // #ifdef MUX_THREAD_MODE
-
-static void textctrl_put_char( int c )
-{
-}
-
-static void textctrl_get_char( int c )
-{
-}
-
-#endif // #ifdef MUX_THREAD_MODE
-
-// *****************************************************************************
-// Serial transport implementation
-
-static u32 transport_ser_recv( u8 *p, u32 size ) 
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_read( pser-&gt;fd, p, size, SER_TIMEOUT_MS );
-}
-
-static u32 transport_ser_send( const u8 *p, u32 size )
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_write( pser-&gt;fd, p, size );
-}
-
-static int transport_ser_init()
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  if( ( pser-&gt;fd = ser_open( pser-&gt;pname ) ) == ( ser_handler )-1 )
-  {
-    log_err( &quot;Unable to open %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  if( ser_setup( pser-&gt;fd, pser-&gt;speed, 8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-  {
-    log_err( &quot;Unable to setup serial port %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  while( ser_read_byte( pser-&gt;fd, SER_NO_TIMEOUT ) != -1 );
-  log_msg( &quot;Running serial transport on port %s at %u baud (8N1)\n&quot;, pser-&gt;pname, ( unsigned )pser-&gt;speed );
-  return 1;
-}
-
-static void transport_ser_cleanup()
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  if( pser-&gt;fd &amp;&amp; pser-&gt;fd != ( ser_handler )-1 )
-    ser_close( pser-&gt;fd );
-  free( pser-&gt;pname );
-}
-
-// ****************************************************************************
-// Utility functions and helpers
-
-static void transport_send_byte( u8 data )
-{
-  transport_send( &amp;data, 1 );
-}
-
-static int transport_read_byte() 
-{
-  u8 c;
-
-  return transport_recv( &amp;c, 1 ) == 1 ? c : -1;
-}
-
-// Secure atoi
-static int secure_atoi( const char *str, long *pres )
-{
-  char *end_ptr;
-  long s1;
-  
-  errno = 0;
-  s1 = strtol( str, &amp;end_ptr, 10 );
-  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
-    return 0;
-  else if( end_ptr == str )
-    return 0;
-  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
-    return 0;
-  else if( '\0' != *end_ptr )
-    return 0;
-  *pres = s1;
-  return 1;  
-}
-
-// Local strndup function to compensate the lack of strndup in Windows
-static char* l_strndup( const char* s, size_t n )
-{
-  char* p;
-  
-  if( ( p = ( char* )malloc( n + 1 ) ) == NULL )
-    return NULL;
-  p [ 0 ] = p[ n ] = '\0';
-  strncpy( p, s, n );
-  return p;
-} 
-
-// Transport parser
-static int parse_transport( const char* s )
-{
-  const char *c;
-  static TRANSPORT_SER tser; 
-
-  if( strstr( s, &quot;ser:&quot; ) == s )
-  {
-    s += strlen( &quot;ser:&quot; );
-    if( ( c = strchr( s, ',' ) ) == NULL )
-    {
-      log_err( &quot;Invalid serial transport syntax\n&quot; );
-      return 0;
-    }
-    if( secure_atoi( c + 1, &amp;tser.speed ) == 0 )
-    {
-      log_err( &quot;Invalid port speed\n&quot; );
-      return 0;
-    }
-    tser.pname = l_strndup( s, c - s );
-    transport_data = &tser;
-    transport_send = transport_ser_send;
-    transport_recv = transport_ser_recv;
-    transport_init = transport_ser_init;
-    transport_cleanup = transport_ser_cleanup;
-    transport_type = TRANSPORT_TYPE_SER;
-    return 1;
-  }
-  log_err( &quot;Error: unsupported transport\n&quot; );
-  return 0;
-}
-
-// ***************************************************************************
-// Service threads
-
-static void* service_thread_ser( void* data )
-{
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;
-  int sdata;
-
-  log_msg( &quot;Starting serial service thread for port %s\n&quot;, pdata-&gt;pname );
-  while( 1 ) 
-  {
-    if( ( sdata = ser_read_byte( pdata-&gt;fd, SER_TIMEOUT_MS ) ) == -1 )
-    {
-      if( pdata-&gt;thread_should_die )
-        break;
-      else
-        continue;
-    }
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = pdata-&gt;service_id;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-static void* service_thread_udp( void* data )
-{
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;
-  socklen_t fromlen;
-  struct sockaddr_in from;
-  int readbytes, i;
-  fd_set fds;
-  struct timeval tv;
-    
-  log_msg( &quot;Starting UDP service thread for port %d\n&quot;, pdata-&gt;port );
-  while( 1 ) 
-  {
-    FD_ZERO( &amp;fds );
-    FD_SET( pdata-&gt;s, &amp;fds );
-    tv.tv_sec = 0;
-    tv.tv_usec = NET_TIMEOUT_MS * 1000;
-    if( select( pdata-&gt;s + 1, &amp;fds, NULL, NULL, &amp;tv ) &lt;= 0 )
-    {
-      if( pdata-&gt;thread_should_die )
-        break;
-      else
-        continue;
-    }
-    fromlen = sizeof( from );
-    readbytes = recvfrom( pdata-&gt;s, pdata-&gt;udp_buf, UDP_BUF_SIZE, 0, ( struct sockaddr* )&amp;from, &amp;fromlen );
-    for( i = 0; i &lt; readbytes; i ++ )
-    {
-      if( pdata-&gt;thread_should_die )
-        break;    
-      sem_wait( &amp;mux_w_sem );
-      mux_data.data = pdata-&gt;udp_buf[ i ];
-      mux_data.id = pdata-&gt;service_id;
-      sem_post( &amp;mux_r_sem );
-    }
-    if( pdata-&gt;thread_should_die )
-      break;       
-  }
-  return NULL;  
-}
-
-static void* service_thread_textctrl( void* data )
-{
-#ifdef MUX_THREAD_MODE
-  int c;
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;  
-    
-  log_msg( &quot;Starting wxTextCtrl service thread\n&quot; );
-  while( 1 )
-  {
-#if 0  
-    sem_wait( &amp;textctrl_data.count_sem );
-    if( ( c = textctrl_data.pdata[ textctrl_data.r_idx ] ) == -1 )
-      break;
-    textctrl_data.r_idx = ( textctrl_data.r_idx + 1 ) % textctrl_data.total;
-#else
-    sem_wait( &amp;pdata-&gt;textctrl_sem );
-    if( ( c = pdata-&gt;textctrl_data ) == -1 )
-      break;
-#endif
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = c;
-    mux_data.id = pdata-&gt;service_id;
-    sem_post( &amp;mux_r_sem );      
-  }
-#endif  
-  return NULL;
-}
-
-static const p_thread_func mux_service_funcs[] = { NULL, service_thread_ser, service_thread_udp, service_thread_textctrl };
-
-// *****************************************************************************
-// Transport thread
-
-static void* transport_thread( void* data )
-{                     
-  int sdata;
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;
-  
-  log_msg( &quot;Starting transport thread\n&quot; );  
-  while( 1 ) 
-  {
-    if( ( sdata = transport_read_byte() ) == -1 )
-    {    
-      if( pdata-&gt;thread_should_die )
-        break;
-      else
-        continue;
-    }    
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = TRANSPORT_SERVICE_ID;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-// *****************************************************************************
-// Transport aware byte send function
-
-static void byte_send( THREAD_DATA *data, u8 d )
-{   
-  if( data-&gt;type == TRANSPORT_TYPE_SER )
-    ser_write_byte( data-&gt;fd, d );
-  else if( data-&gt;type == TRANSPORT_TYPE_UDP )
-    sendto( data-&gt;s, &amp;d, 1, 0, ( struct sockaddr* )&amp;data-&gt;server, sizeof( data-&gt;server ) );
-  else 
-    textctrl_put_char( d );            
-}
-
-// ****************************************************************************
-// Program entry point
-
-#define MAIN_TRANSPORT_IDX    1
-#define SERVICE_BAUD_IDX      2
-#define RFS_DIRNAME_IDX       3
-#define FIRST_SERVICE_IDX     4
-
-int mux_init( int argc, char **argv )
-{
-  unsigned i;
-  THREAD_DATA *tdata;
-  struct hostent *hp;
-        
-  // Setup networking in Windows
-#ifdef WIN32_BUILD
-  // The socket subsystem must be initialized if working in Windows
-  WORD wVersionRequested;
-  WSADATA wsaData;
-  int err;
- 
-  wVersionRequested = MAKEWORD( 2, 0 );
-  err = WSAStartup( wVersionRequested, &amp;wsaData );  
-  if( err != 0 )
-  {
-    log_err( &quot;Unable to initialize the socket subsystem\n&quot; );
-    return 1;
-  }
-#endif // #ifdef WIN32_BUILD  
-
-  // Interpret arguments
-  if( argc &lt; FIRST_SERVICE_IDX + 1 )
-  {
-    log_err( &quot;Usage: %s &lt;transport&gt; &lt;baud&gt; &lt;rfs_dir_name&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]\n&quot;, argv[ 0 ] );
-    return 1;
-  }
-  i = argc - 1;
-  if( !strcasecmp( argv[ i ], &quot;-v&quot; ) )
-  {
-    i --;
-    log_init( LOG_ALL );
-  }
-  else                            
-    log_init( LOG_NONE ); 
-  if( ( vport_num = i - 3 ) &gt; SERVICE_MAX )
-  {
-    log_err( &quot;Too many service ports, maximum is %d\n&quot;, SERVICE_MAX );
-    return 1;
-  }
-  if( parse_transport( argv[ MAIN_TRANSPORT_IDX ] ) == 0 )
-    return 1;
-  if( secure_atoi( argv[ SERVICE_BAUD_IDX ], &amp;service_baud ) == 0 )
-  {
-    log_err( &quot;Invalid service baud\n&quot; );
-    return 1;
-  }
-  if( !os_isdir( argv[ RFS_DIRNAME_IDX ] ) )
-  {
-    log_err( &quot;Invalid directory %s\n&quot;, argv[ RFS_DIRNAME_IDX ] );
-    return 1;
-  }  
-  if( transport_init() == 0 )
-    return 1;
-  if( rfs_server_init( RFS_SERVER_PORT, argv[ RFS_DIRNAME_IDX ] ) == 0 )
-    return 1;
-      
-  // Create global sync objects
-  sem_init( &amp;mux_w_sem, 0, 1 );
-  sem_init( &amp;mux_r_sem, 0, 0 );
-
-  // Open all the service ports and create their corresponding threads
-  if( ( threads = ( THREAD_DATA* )malloc( sizeof( THREAD_DATA ) * ( vport_num + 2 ) ) ) == NULL )
-  {
-    log_err( &quot;Not enough memory\n&quot; );
-    return 1;
-  }
-  memset( threads, 0, sizeof( THREAD_DATA ) * ( vport_num + 2 ) );
-  // Thread map:
-  // index 0 : UDP thread (ALWAYS first service ID!)
-  // 1 ... vport_num : actual serial ports
-  //   (1 is connected to the console wxTextCtrl in frontend mode)
-  // vport_num + 1: transport thread
-  for( i = 0; i &lt;= vport_num + 1; i ++ ) 
-  {
-    tdata = threads + i;
-    tdata-&gt;thread_should_die = 0;
-    if( i &lt;= vport_num )
-    {    
-      if( i == TEXTCTRL_THREAD_IDX )
-      {
-        sem_init( &amp;tdata-&gt;textctrl_sem, 0, 0 );          
-        tdata-&gt;type = TRANSPORT_TYPE_TEXTCTRL;
-      } 
-      else if( i == RFS_UDP_THREAD_IDX )    
-      {      
-        tdata-&gt;s = INVALID_SOCKET_VALUE;
-        if( ( tdata-&gt;udp_buf = ( u8* )malloc( UDP_BUF_SIZE ) ) == NULL )
-        {
-          log_err( &quot;Unable to allocate UDP buffer\n&quot; );
-          return 1;
-        }
-        // UDP thread  
-        if( ( tdata-&gt;s = socket( AF_INET, SOCK_DGRAM, 0 ) ) == INVALID_SOCKET_VALUE )
-        {
-          log_err( &quot;Error creating socket\n&quot; );
-          return 1;
-        }
-        tdata-&gt;server.sin_family = AF_INET;
-        hp = gethostbyname( &quot;127.0.0.1&quot; );
-        memcpy( &amp;tdata-&gt;server.sin_addr, hp-&gt;h_addr, hp-&gt;h_length );
-        tdata-&gt;server.sin_port = htons( RFS_SERVER_PORT );
-        tdata-&gt;type = TRANSPORT_TYPE_UDP;
-        tdata-&gt;port = RFS_SERVER_PORT;
-        sem_init( &amp;tdata-&gt;udp_sem, 0, 0 );                  
-      }
-      else
-      {   
-        // Serial thread
-        if( ( tdata-&gt;fd = ser_open( argv[ i  - 1 + FIRST_SERVICE_IDX ] ) ) == ( ser_handler )-1 )
-        {
-          log_err( &quot;Unable to open port %s\n&quot;, argv[ i - 1 + FIRST_SERVICE_IDX ] );
-          return 1;
-        }
-        if( ser_setup( tdata-&gt;fd, service_baud, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-        {
-          log_err( &quot;Unable to setup serial port %s\n&quot;, argv[ i - 1 + FIRST_SERVICE_IDX ] );
-          return 1;
-        }
-        tdata-&gt;type = TRANSPORT_TYPE_SER;
-        tdata-&gt;pname = argv[ i - 1 + FIRST_SERVICE_IDX ];        
-      }
-      tdata-&gt;service_id = i + SERVICE_ID_FIRST;         
-    }
-    if( pthread_create( &amp;tdata-&gt;tid, NULL, i &lt;= vport_num ? mux_service_funcs[ tdata-&gt;type ] : transport_thread, tdata ) )
-    {
-      log_err( &quot;Unable to create transport thread\n&quot; );
-      return 1;
-    }
-    tdata-&gt;thread_created = 1;
-  }
-  // Create rfs_server thread
-  if( pthread_create( &amp;rfs_thread_id, NULL, rfs_thread, argv[ RFS_DIRNAME_IDX ] ) )
-  {
-    log_err( &quot;Unable to create RFS thread\n&quot; );
-    return 1;
-  }
-  rfs_thread_created = 1;
-  return 0;  
-}
-
-void mux_cleanup()
-{
-  unsigned i;
-  THREAD_DATA *tdata;
-                            
-  if( threads )
-  {
-    // Thread map:
-    // index 0 : UDP thread (ALWAYS first service ID!)
-    // 1 ... vport_num : actual serial ports
-    // vport_num + 1: transport thread
-    for( i = 0; i &lt;= vport_num + 1; i ++ ) 
-    {
-      tdata = threads + i;
-      if( tdata-&gt;thread_created == 1 )
-      {
-        if( i == TEXTCTRL_THREAD_IDX )
-          textctrl_get_char( -1 );
-        tdata-&gt;thread_should_die = 1;
-        pthread_join( tdata-&gt;tid, NULL );
-      }
-      if( i &lt;= vport_num )
-      {
-        if( i == TEXTCTRL_THREAD_IDX )
-          sem_destroy( &amp;tdata-&gt;textctrl_sem );
-        else if( i == RFS_UDP_THREAD_IDX )
-        {        
-          free( tdata-&gt;udp_buf );
-          if( tdata-&gt;s != INVALID_SOCKET_VALUE )
-            socket_close( tdata-&gt;s );             
-          sem_destroy( &amp;tdata-&gt;udp_sem );                   
-        }
-        else
-        {  
-          // Serial thread
-          if( tdata-&gt;fd &amp;&amp; tdata-&gt;fd != ( ser_handler )-1 )
-            ser_close( tdata-&gt;fd );         
-        }    
-      }
-    }
-    free( threads );
-    threads = NULL;
-  }
-  if( rfs_thread_created )
-  {
-    rfs_thread_should_die = 1;
-    pthread_join( rfs_thread_id, NULL );
-  }
-  rfs_server_cleanup();
-  transport_cleanup();
-  
-  sem_destroy( &amp;mux_w_sem );
-  sem_destroy( &amp;mux_r_sem );
-  
-  // Re-init globals
-  vport_num = 0;
-  transport_type = TRANSPORT_TYPE_ERROR;
-  service_baud = 0;
-  service_id_in = -1;
-  service_id_out = -1;
-  rfs_thread_created = 0;
-  mux_thread_running = 0;
-}
-
-#if defined( MUX_STANDALONE_MODE )
-
-#define RETVAL  1
-#define RETVAL_TYPE int
-
-#elif defined( MUX_THREAD_MODE )
-
-#define RETVAL  NULL
-#define RETVAL_TYPE void*
-
-void mux_thread_stop()
-{
-  sem_wait( &amp;mux_w_sem );
-  mux_data.id = THREAD_STOP_SERVICE_ID;
-  sem_post( &amp;mux_r_sem );
-}
-    
-#else
-#error &quot;Operating mode (standalone or thread) not defined&quot;
-#endif
-
-RETVAL_TYPE mux_thread( void *pdata ) 
-{
-  int c, prev_sent = -1;
-  int temp, sdata;
-  int got_esc = 0;
-  DATA data;
-                                                                                     
-  log_msg( &quot;Starting service multiplexer on %u port(s) and RFS server\n&quot;, vport_num );
-  // Main service thread
-  while( 1 )
-  {
-    sem_wait( &amp;mux_r_sem );
-    data = mux_data;
-    sem_post( &amp;mux_w_sem );
-    if( data.id == THREAD_STOP_SERVICE_ID )
-      break;        
-    if( data.id == TRANSPORT_SERVICE_ID )
-    {
-      // Read one byte, interpret it
-      c = data.data;
-      if( c != ESCAPE_CHAR )
-      {
-        if( c &gt;= SERVICE_ID_FIRST &amp;&amp; c &lt;= SERVICE_ID_LAST )
-          service_id_in = c;
-        else if( c == FORCE_SID_CHAR &amp;&amp; prev_sent != -1 )
-        {
-          // Re-transmit the last data AND the service ID
-          transport_send_byte( service_id_out );
-          if( prev_sent &amp; ESC_MASK )
-            transport_send_byte( ESCAPE_CHAR );
-          transport_send_byte( prev_sent &amp; 0xFF );
-        }
-        else
-        {
-          if( got_esc )
-          {
-            // Got an escape last time, check the char now (with the 5th bit flipped)
-            c ^= ESCAPE_XOR_MASK;
-            if( c != ESCAPE_CHAR &amp;&amp; c != FORCE_SID_CHAR &amp;&amp; ( c &lt; SERVICE_ID_FIRST || c &gt; SERVICE_ID_LAST ) )
-            {
-               log_err( &quot;Protocol error: invalid escape sequence\n&quot; );
-               break;
-            }
-            got_esc = 0;
-          }  
-          if( service_id_in == -1 )
-          {
-            transport_send_byte( FORCE_SID_CHAR );
-            log_msg( &quot;Requested resend of service ID\n&quot; );
-          }
-          else
-            byte_send( threads + service_id_in - SERVICE_ID_FIRST, c );
-        }
-      }
-      else
-        got_esc = 1;
-    }
-    else
-    {
-      temp = data.id;
-      sdata = data.data;
-      if( temp != service_id_out )
-        transport_send_byte( temp );
-      prev_sent = sdata;
-      // Then send the actual data byte, escaping it if needed
-      if( sdata == ESCAPE_CHAR || sdata == FORCE_SID_CHAR || ( sdata &gt;= SERVICE_ID_FIRST &amp;&amp; sdata &lt;= SERVICE_ID_LAST ) )
-      {
-        transport_send_byte( ESCAPE_CHAR );
-        transport_send_byte( ( u8 )sdata ^ ESCAPE_XOR_MASK );
-        prev_sent = ESC_MASK | ( ( u8 )sdata ^ ESCAPE_XOR_MASK );
-      }
-      else
-        transport_send_byte( sdata );
-      service_id_out = temp;
-    }
-  }
-  mux_thread_running = 0;
-  return RETVAL;
-}
-
-#ifdef MUX_STANDALONE_MODE
-int main( int argc, char **argv )
-{
-  if( mux_init( argc, argv ) )
-    return RETVAL;
-  return mux_thread( NULL );
-}
-#endif

Modified: trunk/src/elua_mmc.c
===================================================================
--- trunk/src/elua_mmc.c	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/src/elua_mmc.c	2011-02-02 17:52:12 UTC (rev 949)
@@ -59,6 +59,9 @@
 static volatile UINT Timer2 = 0;    /* decrement timer */
 
 static
+BYTE TriesLeft = 2;
+
+static
 BYTE CardType;            /* b0:MMC, b1:SDC, b2:Block addressing */
 
 static
@@ -316,47 +319,54 @@
     if (drv) return STA_NOINIT;            /* Supports only single drive */
     if (Stat &amp; STA_NODISK) return Stat;    /* No card in the socket */
     
-    power_on();                           /* Force socket power on */
+    do
+    {
+      power_on();                           /* Force socket power on */
 
-    SELECT();                /* CS = L */
-    ty = 0;
-    if (send_cmd(CMD0, 0) == 1) {            /* Enter Idle state */
+      SELECT();                /* CS = L */
+      ty = 0;
+      if (send_cmd(CMD0, 0) == 1) {            /* Enter Idle state */
         Timer1 = 1000/MMCFS_TICK_MS;     /* Initialization timeout of 1000 msec */
         if (send_cmd(CMD8, 0x1AA) == 1) {    /* SDC Ver2+ */
-            for (n = 0; n &lt; 4; n++) ocr[n] = rcvr_spi();
-            if (ocr[2] == 0x01 &amp;&amp; ocr[3] == 0xAA) {    /* The card can work at vdd range of 2.7-3.6V */
-                do {
-                    if (send_cmd(CMD55, 0) &lt;= 1 &amp;&amp; send_cmd(CMD41, 1UL &lt;&lt; 30) == 0)    break;    /* ACMD41 with HCS bit */
-                } while (Timer1);
-                if (Timer1 &amp;&amp; send_cmd(CMD58, 0) == 0) {    /* Check CCS bit */
-                    for (n = 0; n &lt; 4; n++) ocr[n] = rcvr_spi();
-                    ty = (ocr[0] &amp; 0x40) ? 6 : 2;
-                }
-            }
+	  for (n = 0; n &lt; 4; n++) ocr[n] = rcvr_spi();
+	  if (ocr[2] == 0x01 &amp;&amp; ocr[3] == 0xAA) {    /* The card can work at vdd range of 2.7-3.6V */
+	    do {
+	      if (send_cmd(CMD55, 0) &lt;= 1 &amp;&amp; send_cmd(CMD41, 1UL &lt;&lt; 30) == 0)    break;    /* ACMD41 with HCS bit */
+	    } while (Timer1);
+	    if (Timer1 &amp;&amp; send_cmd(CMD58, 0) == 0) {    /* Check CCS bit */
+	      for (n = 0; n &lt; 4; n++) ocr[n] = rcvr_spi();
+	      ty = (ocr[0] &amp; 0x40) ? 6 : 2;
+	    }
+	  }
         } else {                            /* SDC Ver1 or MMC */
-            ty = (send_cmd(CMD55, 0) &lt;= 1 &amp;&amp; send_cmd(CMD41, 0) &lt;= 1) ? 2 : 1;    /* SDC : MMC */
-            do {
-                if (ty == 2) {
-                    if (send_cmd(CMD55, 0) &lt;= 1 &amp;&amp; send_cmd(CMD41, 0) == 0) break;    /* ACMD41 */
-                } else {
-                    if (send_cmd(CMD1, 0) == 0) break;                                /* CMD1 */
-                }
-            } while (Timer1);
-            if (!Timer1 || send_cmd(CMD16, 512) != 0)    /* Select R/W block length */
-                ty = 0;
+	  ty = (send_cmd(CMD55, 0) &lt;= 1 &amp;&amp; send_cmd(CMD41, 0) &lt;= 1) ? 2 : 1;    /* SDC : MMC */
+	  do {
+	    if (ty == 2) {
+	      if (send_cmd(CMD55, 0) &lt;= 1 &amp;&amp; send_cmd(CMD41, 0) == 0) break;    /* ACMD41 */
+	    } else {
+	      if (send_cmd(CMD1, 0) == 0) break;                                /* CMD1 */
+	    }
+	  } while (Timer1);
+	  if (!Timer1 || send_cmd(CMD16, 512) != 0)    /* Select R/W block length */
+	    ty = 0;
         }
-    }
-    CardType = ty;
-    DESELECT();            /* CS = H */
-    rcvr_spi();            /* Idle (Release DO) */
+      }
+      CardType = ty;
+      DESELECT();            /* CS = H */
+      rcvr_spi();            /* Idle (Release DO) */
 
-    if (ty) {            /* Initialization succeded */
-        Stat &amp;= ~STA_NOINIT;        /* Clear STA_NOINIT */
-        set_max_speed();
-    } else {            /* Initialization failed */
-        power_off();
-    }
+      if (TriesLeft)
+	TriesLeft--;
 
+      if (ty) {            /* Initialization succeded */
+	Stat &amp;= ~STA_NOINIT;        /* Clear STA_NOINIT */
+	set_max_speed();
+      } else {            /* Initialization failed */
+	power_off();
+      }
+
+    } while( TriesLeft &gt; 0 &amp;&amp; ty == 0 );
+
     return Stat;
 }
 

Modified: trunk/src/lua/luaconf.h
===================================================================
--- trunk/src/lua/luaconf.h	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/src/lua/luaconf.h	2011-02-02 17:52:12 UTC (rev 949)
@@ -90,7 +90,7 @@
 //## Modified for eLua
 //## Defaults search modules path to our ROM File System
 #ifndef LUA_RPC
-#define LUA_PATH_DEFAULT &quot;/mmc/?.lua;/mmc/?.lc;/rom/?.lua;/rom/?.lc&quot;
+#define LUA_PATH_DEFAULT &quot;/rfs/?.lua;/rfs/?.lc;/mmc/?.lua;/mmc/?.lc;/rom/?.lua;/rom/?.lc&quot;
 #else
 #define LUA_PATH_DEFAULT  \
 		&quot;.\\?.lua;&quot;  LUA_LDIR&quot;?.lua;&quot;  LUA_LDIR&quot;?\\init.lua;&quot; \

Modified: trunk/src/modules/cpu.c
===================================================================
--- trunk/src/modules/cpu.c	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/src/modules/cpu.c	2011-02-02 17:52:12 UTC (rev 949)
@@ -81,10 +81,8 @@
   return 1;
 }
 
-// cli helper, does either hw_cli (clear interrupt only in hardware) or full cli (also clear the Lua interrupt flag)
-// Lua: [hw_]cli() - to disable all interrupts
-// or [hw_]cli( id1, resnum1, [resnum2], ..., [resnumn] ) - to disable a specific id/resnum(s)
-static int cpuh_cli( lua_State *L, int hwmode )
+// Either disables or enables the given interrupt(s)
+static int cpuh_int_helper( lua_State *L, int mode )
 {
 #ifdef BUILD_LUA_INT_HANDLERS
   unsigned i;
@@ -100,95 +98,37 @@
     for( i = 2; i &lt;= lua_gettop( L ); i ++ )
     {
       resnum = ( elua_int_resnum )luaL_checkinteger( L, i );
-      res = platform_cpu_set_interrupt( id, resnum, PLATFORM_CPU_DISABLE );
+      res = platform_cpu_set_interrupt( id, resnum, mode );
       if( res == PLATFORM_INT_INVALID )
         return luaL_error( L, &quot;%d is not a valid interrupt ID&quot;, ( int )id );
       else if( res == PLATFORM_INT_NOT_HANDLED )
-        return luaL_error( L, &quot;cli operation not implemented for interrupt %d with resource %d&quot;, ( int )id, ( int )resnum );
+        return luaL_error( L, &quot;'%s' not implemented for interrupt %d with resource %d&quot;, mode == PLATFORM_CPU_ENABLE ? &quot;sei&quot; : &quot;cli&quot;, ( int )id, ( int )resnum );
       else if( res == PLATFORM_INT_BAD_RESNUM )
         return luaL_error( L, &quot;resource %d not valid for interrupt %d&quot;, ( int )resnum, ( int )id );
     }
-    if( !hwmode )
-      elua_int_disable( id );
   }
   else
 #else // #ifdef BUILD_LUA_INT_HANDLERS
   if( lua_gettop( L ) &gt; 0 )
     return luaL_error( L, &quot;Lua interrupt support not available.&quot; );
 #endif // #ifdef BUILD_LUA_INT_HANDLERS
-  platform_cpu_set_global_interrupts( PLATFORM_CPU_DISABLE );
+  platform_cpu_set_global_interrupts( mode );
   return 0;
-}
 
-
-// sei helper, does either hw_sei (set interrupt only in hardware) or full sei (also set the Lua interrupt flag)
-// Lua: [hw_]sei() - to enable all interrupts
-// or [hw_]sei( id1, resnum1, [resnum2], ..., [resnumn] ) - to enable a specific id/resnum(s)
-static int cpuh_sei( lua_State *L, int hwmode )
-{
-#ifdef BUILD_LUA_INT_HANDLERS  
-  unsigned i;
-  elua_int_id id;
-  elua_int_resnum resnum;  
-  int res;
-
-  if( lua_gettop( L ) &gt; 0 )
-  {
-    id = ( elua_int_id )luaL_checkinteger( L, 1 );
-    if( id &lt; ELUA_INT_FIRST_ID || id &gt; INT_ELUA_LAST )
-      return luaL_error( L, &quot;invalid interrupt ID&quot; );
-    if( !hwmode )
-    {
-      // Check if we have a handler for this interrupt
-      lua_rawgeti( L, LUA_REGISTRYINDEX, LUA_INT_HANDLER_KEY ); // inttable
-      lua_rawgeti( L, -1, id ); // inttable f
-      if( lua_isnil( L, -1 ) )
-        return luaL_error( L, &quot;no handler is set for this interrupt, set a handler before enabling it.\n&quot; );
-      lua_pop( L, 2 ); 
-    }
-    for( i = 2; i &lt;= lua_gettop( L ); i ++ )
-    {
-      resnum = ( elua_int_resnum )luaL_checkinteger( L, i );
-      res = platform_cpu_set_interrupt( id, resnum, PLATFORM_CPU_ENABLE );
-      if( res == PLATFORM_INT_INVALID )
-        return luaL_error( L, &quot;%d is not a valid interrupt ID&quot;, ( int )id );
-      else if( res == PLATFORM_INT_NOT_HANDLED )
-        return luaL_error( L, &quot;sei operation not implemented for interrupt %d with resnum %d&quot;, ( int )id, ( int )resnum );
-      else if( res == PLATFORM_INT_BAD_RESNUM )
-        return luaL_error( L, &quot;resource %d not valid for interrupt %d&quot;, ( int )resnum, ( int )id );
-    }
-    if( !hwmode )
-      elua_int_enable( id );
-  }
-  else
-#else // #ifdef BUILD_LUA_INT_HANDLERS
-  if( lua_gettop( L ) &gt; 0 )
-    return luaL_error( L, &quot;Lua interrupt support not available.&quot; );
-#endif // #ifdef BUILD_LUA_INT_HANDLERS  
-  platform_cpu_set_global_interrupts( PLATFORM_CPU_ENABLE );
-  return 0;
 }
 
+// Lua: cpu.cli( id, resnum1, [resnum2], ... [resnumn] )
 static int cpu_cli( lua_State *L )
 {
-  return cpuh_cli( L, 0 );
+  return cpuh_int_helper( L, PLATFORM_CPU_DISABLE );
 }
 
-static int cpu_hw_cli( lua_State *L )
-{
-  return cpuh_cli( L, 1 );
-}
-
+// Lua: cpu.sei( id, resnum1, [resnum2], ... [resnumn] )
 static int cpu_sei( lua_State *L )
 {
-  return cpuh_sei( L, 0 );
+  return cpuh_int_helper( L, PLATFORM_CPU_ENABLE );
 }
 
-static int cpu_hw_sei( lua_State *L )
-{
-  return cpuh_sei( L, 1 );
-}
-
 // Lua: frequency = clock()
 static int cpu_clock( lua_State *L )
 {
@@ -239,8 +179,10 @@
     return luaL_error( L, &quot;invalid interrupt ID&quot; );
   if( lua_type( L, 2 ) == LUA_TFUNCTION || lua_type( L, 2 ) == LUA_TLIGHTFUNCTION || lua_type( L, 2 ) == LUA_TNIL )
   {
-    if( lua_type( L, 2 ) == LUA_TNIL &amp;&amp; elua_int_is_enabled( id ) )
-      return luaL_error( L, &quot;interrupt is enabled, disable it before setting its handler to nil.\n&quot; );
+    if( lua_type( L, 2 ) == LUA_TNIL )
+      elua_int_disable( id );
+    else
+      elua_int_enable( id );
     lua_settop( L, 2 ); // id f
     lua_rawgeti( L, LUA_REGISTRYINDEX, LUA_INT_HANDLER_KEY ); // id f inttable
     lua_rawgeti( L, -1, id ); // id f inttable prevf
@@ -309,9 +251,7 @@
   { LSTRKEY( &quot;w8&quot; ), LFUNCVAL( cpu_w8 ) },
   { LSTRKEY( &quot;r8&quot; ), LFUNCVAL( cpu_r8 ) },
   { LSTRKEY( &quot;cli&quot; ), LFUNCVAL( cpu_cli ) },
-  { LSTRKEY( &quot;hw_cli&quot; ), LFUNCVAL( cpu_hw_cli ) },
   { LSTRKEY( &quot;sei&quot; ), LFUNCVAL( cpu_sei ) },
-  { LSTRKEY( &quot;hw_sei&quot; ), LFUNCVAL( cpu_hw_sei ) },
   { LSTRKEY( &quot;clock&quot; ), LFUNCVAL( cpu_clock ) },
 #ifdef BUILD_LUA_INT_HANDLERS
   { LSTRKEY( &quot;set_int_handler&quot; ), LFUNCVAL( cpu_set_int_handler ) },

Modified: trunk/src/platform/i386/platform.c
===================================================================
--- trunk/src/platform/i386/platform.c	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/src/platform/i386/platform.c	2011-02-02 17:52:12 UTC (rev 949)
@@ -186,19 +186,6 @@
 }
 
 // ****************************************************************************
-// &quot;Dummy&quot; CPU functions
-
-int platform_cpu_set_global_interrupts( int status )
-{
-  return 0;
-}
-
-int platform_cpu_get_global_interrupts()
-{
-  return 0;
-}
-
-// ****************************************************************************
 // Allocator support
 
 u32 platform_get_lastmem()

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/src/platform/lm3s/platform.c	2011-02-02 17:52:12 UTC (rev 949)
@@ -247,6 +247,7 @@
   {
     status = CANStatusGet(CAN0_BASE, CAN_STS_CONTROL);
     can_err_flag = 1;
+    can_tx_flag = 0;
   }
   else if( status == 1 ) // Message receive
   {

Modified: trunk/src/platform/lpc17xx/mbed_pio.c
===================================================================
--- trunk/src/platform/lpc17xx/mbed_pio.c	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/src/platform/lpc17xx/mbed_pio.c	2011-02-02 17:52:12 UTC (rev 949)
@@ -88,6 +88,15 @@
 {
 #if LUA_OPTIMIZE_MEMORY &gt; 0
   { LSTRKEY( &quot;__metatable&quot; ), LROVAL( mbed_pio_map ) },
+  { LSTRKEY(  &quot;RES_PULLUP&quot; ), LNUMVAL( PINSEL_PINMODE_PULLUP )},
+  { LSTRKEY(  &quot;RES_TRISTATE&quot; ), LNUMVAL( PINSEL_PINMODE_TRISTATE )},
+  { LSTRKEY(  &quot;RES_PULLDOWN&quot; ), LNUMVAL( PINSEL_PINMODE_PULLDOWN )},
+  { LSTRKEY(  &quot;FUNCTION_0&quot; ), LNUMVAL( PINSEL_FUNC_0 )},
+  { LSTRKEY(  &quot;FUNCTION_1&quot; ), LNUMVAL( PINSEL_FUNC_1 )},
+  { LSTRKEY(  &quot;FUNCTION_2&quot; ), LNUMVAL( PINSEL_FUNC_2 )},
+  { LSTRKEY(  &quot;FUNCTION_3&quot; ), LNUMVAL( PINSEL_FUNC_3 )},
+  { LSTRKEY(  &quot;MODE_DEFAULT&quot; ), LNUMVAL( PINSEL_PINMODE_NORMAL )},
+  { LSTRKEY(  &quot;MODE_OD&quot; ), LNUMVAL( PINSEL_PINMODE_OPENDRAIN )},
 #endif
   { LSTRKEY( &quot;configpin&quot; ),  LFUNCVAL( configpin ) },
   { LSTRKEY( &quot;__index&quot; ), LFUNCVAL( mbed_pio_mt_index ) },
@@ -100,6 +109,15 @@
   return 0;
 #else
   luaL_register( L, PS_LIB_TABLE_NAME, mbed_pio_map );
+  MOD_REG_NUMBER( L, &quot;RES_PULLUP&quot;, PINSEL_PINMODE_PULLUP );
+  MOD_REG_NUMBER( L, &quot;RES_TRISTATE&quot;, PINSEL_PINMODE_TRISTATE );
+  MOD_REG_NUMBER( L, &quot;RES_PULLDOWN&quot;, PINSEL_PINMODE_PULLDOWN );
+  MOD_REG_NUMBER( L, &quot;FUNCTION_0&quot;, PINSEL_FUNC_0 );
+  MOD_REG_NUMBER( L, &quot;FUNCTION_1&quot;, PINSEL_FUNC_1 );
+  MOD_REG_NUMBER( L, &quot;FUNCTION_2&quot;, PINSEL_FUNC_2 );
+  MOD_REG_NUMBER( L, &quot;FUNCTION_3&quot;, PINSEL_FUNC_3 );
+  MOD_REG_NUMBER( L, &quot;MODE_DEFAULT&quot;, PINSEL_PINMODE_NORMAL );
+  MOD_REG_NUMBER( L, &quot;MODE_OD&quot;, PINSEL_PINMODE_OPENDRAIN );
   
   // Set it as its own metatable
   lua_pushvalue( L, -1 );

Modified: trunk/src/platform/stm32/platform.c
===================================================================
--- trunk/src/platform/stm32/platform.c	2011-02-02 17:43:03 UTC (rev 948)
+++ trunk/src/platform/stm32/platform.c	2011-02-02 17:52:12 UTC (rev 949)
@@ -536,6 +536,9 @@
 static GPIO_TypeDef *const usart_gpio_tx_port[] = { GPIOA, GPIOA, GPIOB, GPIOC, GPIOC };
 static const u16 usart_gpio_rx_pin[] = { GPIO_Pin_10, GPIO_Pin_3, GPIO_Pin_11, GPIO_Pin_11, GPIO_Pin_2 };
 static const u16 usart_gpio_tx_pin[] = { GPIO_Pin_9, GPIO_Pin_2, GPIO_Pin_10, GPIO_Pin_10, GPIO_Pin_12 };
+static GPIO_TypeDef *const usart_gpio_hwflow_port[] = { GPIOA, GPIOA, GPIOB };
+static const u16 usart_gpio_cts_pin[] = { GPIO_Pin_11, GPIO_Pin_0, GPIO_Pin_13 };
+static const u16 usart_gpio_rts_pin[] = { GPIO_Pin_12, GPIO_Pin_1, GPIO_Pin_14 };
 
 static void usart_init(u32 id, USART_InitTypeDef * initVals)
 {
@@ -652,22 +655,37 @@
 {
   USART_TypeDef *usart = stm32_usart[ id ]; 
   int temp = 0;
+  GPIO_InitTypeDef GPIO_InitStructure;
 
+  if( id &gt;= 3 ) // on STM32 only USART1 through USART3 have hardware flow control ([TODO] but only on high density devices?)
+    return PLATFORM_ERR;  
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  
   if( type == PLATFORM_UART_FLOW_NONE )
   {
     usart-&gt;CR3 &amp;= ~USART_HardwareFlowControl_RTS_CTS;
+    GPIO_InitStructure.GPIO_Pin = usart_gpio_rts_pin[ id ] | usart_gpio_cts_pin[ id ];
+    GPIO_Init( usart_gpio_hwflow_port[ id ], &amp;GPIO_InitStructure );      
     return PLATFORM_OK;
   }
-  if( id &gt;= 3 ) // on STM32 only USART1 through USART3 have hardware flow control ([TODO] but only on high density devices?)
-    return PLATFORM_ERR;
   if( type &amp; PLATFORM_UART_FLOW_RTS )
+  {
     temp |= USART_HardwareFlowControl_RTS;
+    GPIO_InitStructure.GPIO_Speed = usart_gpio_rts_pin[ id ];
+    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
+    GPIO_Init( usart_gpio_hwflow_port[ id ], &amp;GPIO_InitStructure );
+  }
   if( type &amp; PLATFORM_UART_FLOW_CTS )
+  {
     temp |= USART_HardwareFlowControl_CTS;
+    GPIO_InitStructure.GPIO_Speed = usart_gpio_cts_pin[ id ];
+    GPIO_Init( usart_gpio_hwflow_port[ id ], &amp;GPIO_InitStructure );
+  }
   usart-&gt;CR3 |= temp;
   return PLATFORM_OK;
 }
 
+
 // ****************************************************************************
 // Timers
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000901.html">[Elua-svn] r948 - tags
</A></li>
	<LI>Next message: <A HREF="000903.html">[Elua-svn] r950 - branches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#902">[ date ]</a>
              <a href="thread.html#902">[ thread ]</a>
              <a href="subject.html#902">[ subject ]</a>
              <a href="author.html#902">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
