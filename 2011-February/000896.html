<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r943 - branches/pre0.8/mux_src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2011-February/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r943%20-%20branches/pre0.8/mux_src&In-Reply-To=%3C20110202144722.E9C7B48133C%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000895.html">
   <LINK REL="Next"  HREF="000897.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r943 - branches/pre0.8/mux_src</H1>
    <B>bogdanm at mail.berlios.de</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r943%20-%20branches/pre0.8/mux_src&In-Reply-To=%3C20110202144722.E9C7B48133C%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r943 - branches/pre0.8/mux_src">bogdanm at mail.berlios.de
       </A><BR>
    <I>Wed Feb  2 15:47:22 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="000895.html">[Elua-svn] r942 - in branches/pre0.8: . src/platform/i386 utils
</A></li>
        <LI>Next message: <A HREF="000897.html">[Elua-svn] r944 - branches/pre0.8/doc/en
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#896">[ date ]</a>
              <a href="thread.html#896">[ thread ]</a>
              <a href="subject.html#896">[ subject ]</a>
              <a href="author.html#896">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2011-02-02 15:47:22 +0100 (Wed, 02 Feb 2011)
New Revision: 943

Removed:
   branches/pre0.8/mux_src/main.c.allthreads
   branches/pre0.8/mux_src/main.c.old
Log:
released obsolete files from sermux sources

Deleted: branches/pre0.8/mux_src/main.c.allthreads
===================================================================
--- branches/pre0.8/mux_src/main.c.allthreads	2011-02-02 14:45:17 UTC (rev 942)
+++ branches/pre0.8/mux_src/main.c.allthreads	2011-02-02 14:47:22 UTC (rev 943)
@@ -1,349 +0,0 @@
-// Service multiplexer 
-
-#include &lt;stdio.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;semaphore.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;limits.h&gt;
-#include &quot;config.h&quot;
-#include &quot;log.h&quot;
-#include &quot;type.h&quot;
-#include &quot;serial.h&quot;
-
-// ****************************************************************************
-// Data structures and local variables
-
-#define TRANSPORT_TYPE_ERROR        0
-#define TRANSPORT_TYPE_SER          1
-
-// Service ID of the transport thread
-#define TRANSPORT_SERVICE_ID        -1
-
-// Send/receive/init function pointers
-typedef u32 ( *p_recv_func )( u8 *p, u32 size );
-typedef u32 ( *p_send_func )( const u8 *p, u32 size );
-typedef int ( *p_init_func )( void );
-
-// Serial thread buffer structure
-typedef struct 
-{
-  pthread_t tid;
-  const char *pname;
-  ser_handler fd;
-  int service_id;
-} THREAD_DATA;
-
-// Serial transport data structure
-typedef struct 
-{
-  ser_handler fd;
-  const char *pname;
-  long speed;
-} TRANSPORT_SER;
-
-// Service/transport data
-typedef struct 
-{
-  int id;
-  u8 data;
-} DATA;
-
-static THREAD_DATA *threads;
-static unsigned vport_num;
-
-static void *transport_data;
-static int transport_type;
-static p_recv_func transport_recv;
-static p_send_func transport_send;
-static p_init_func transport_init;
-
-static long service_baud;
-static sem_t mux_w_sem, mux_r_sem;
-static DATA mux_data;
-static int service_id_in = -1, service_id_out = -1;
-
-// ***************************************************************************
-// Serial transport implementation
-
-static u32 transport_ser_recv( u8 *p, u32 size ) 
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_read( pser-&gt;fd, p, size, SER_INF_TIMEOUT );
-}
-
-static u32 transport_ser_send( const u8 *p, u32 size )
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_write( pser-&gt;fd, p, size );
-}
-
-static int transport_ser_init()
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  if( ( pser-&gt;fd = ser_open( pser-&gt;pname ) ) == ( ser_handler )-1 )
-  {
-    fprintf( stderr, &quot;Unable to open %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  if( ser_setup( pser-&gt;fd, pser-&gt;speed, 8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-  {
-    fprintf( stderr, &quot;Unable to setup serial port %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  while( ser_read_byte( pser-&gt;fd, SER_NO_TIMEOUT ) != -1 );
-  printf( &quot;Running serial transport on port %s at %u baud (8N1)\n&quot;, pser-&gt;pname, ( unsigned )pser-&gt;speed );
-  return 1;
-}
-
-// ****************************************************************************
-// Utility functions and helpers
-
-static void transport_send_byte( u8 data )
-{
-  transport_send( &amp;data, 1 );
-}
-
-static int transport_read_byte() 
-{
-  u8 c;
-
-  return transport_recv( &amp;c, 1 ) == 1 ? c : -1;
-}
-
-// Secure atoi
-static int secure_atoi( const char *str, long *pres )
-{
-  char *end_ptr;
-  long s1;
-  
-  errno = 0;
-  s1 = strtol( str, &amp;end_ptr, 10 );
-  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
-    return 0;
-  else if( end_ptr == str )
-    return 0;
-  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
-    return 0;
-  else if( '\0' != *end_ptr )
-    return 0;
-  *pres = s1;
-  return 1;  
-}
-
-// Transport parser
-static int parse_transport( const char* s )
-{
-  const char *c;
-  static TRANSPORT_SER tser; 
-
-  if( strstr( s, &quot;ser:&quot; ) == s )
-  {
-    s += strlen( &quot;ser:&quot; );
-    if( ( c = strchr( s, ',' ) ) == NULL )
-    {
-      fprintf( stderr, &quot;Invalid serial transport syntax\n&quot; );
-      return 0;
-    }
-    if( secure_atoi( c + 1, &amp;tser.speed ) == 0 )
-    {
-      fprintf( stderr, &quot;Invalid port speed\n&quot; );
-      return 0;
-    }
-    tser.pname = strndup( s, c - s );
-    transport_data = &tser;
-    transport_send = transport_ser_send;
-    transport_recv = transport_ser_recv;
-    transport_init = transport_ser_init;
-    transport_type = TRANSPORT_TYPE_SER;
-    return 1;
-  }
-  fprintf( stderr, &quot;Error: unsupported transport\n&quot; );
-  return 0;
-}
-
-// ***************************************************************************
-// Service thread
-
-static void* service_thread( void* data )
-{
-  THREAD_DATA *pdata = ( THREAD_DATA*) data;
-  int sdata;
-
-  log_msg( &quot;Starting service thread for port %s\n&quot;, pdata-&gt;pname );
-  while( 1 ) 
-  {
-    if( ( sdata = ser_read_byte( pdata-&gt;fd, SER_INF_TIMEOUT ) ) == -1 )
-      continue;
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = pdata-&gt;service_id;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-// ****************************************************************************
-// Transport thread
-
-static void* transport_thread( void* data )
-{
-  int sdata;
-
-  log_msg( &quot;Starting transport thread\n&quot; );
-  while( 1 ) 
-  {
-    if( ( sdata = transport_read_byte() ) == -1 )
-      continue;
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = TRANSPORT_SERVICE_ID;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-// ****************************************************************************
-// Program entry point
-
-#define MAIN_TRANSPORT_IDX    1
-#define SERVICE_BAUD_IDX      2
-#define FIRST_SERVICE_IDX     3
-
-int main( int argc, char **argv )
-{
-  unsigned i;
-  THREAD_DATA *tdata;
-  int c;
-  int temp, sdata;
-  int got_esc = 0;
-  DATA data;
-
-  // Interpret arguments
-  if( argc &lt; 4 )
-  {
-    fprintf( stderr, &quot;Usage: %s &lt;transport&gt; &lt;baud&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]\n&quot;, argv[ 0 ] );
-    return 1;
-  }
-  i = argc - 1;
-  if( !strcasecmp( argv[ i ], &quot;-v&quot; ) )
-  {
-    i --;
-    log_init( LOG_ALL );
-  }
-  else
-    log_init( LOG_NONE ); 
-  if( ( vport_num = i - 2 ) &gt; SERVICE_MAX )
-  {
-    fprintf( stderr, &quot;Too many service ports, maximum is %d\n&quot;, SERVICE_MAX );
-    return 1;
-  }
-  if( parse_transport( argv[ MAIN_TRANSPORT_IDX ] ) == 0 )
-    return 1;
-  if( secure_atoi( argv[ SERVICE_BAUD_IDX ], &amp;service_baud ) == 0 )
-  {
-    fprintf( stderr, &quot;Invalid service baud\n&quot; );
-    return 1;
-  }
-  if( transport_init() == 0 )
-    return 1;
-
-  // Create global sync objects
-  sem_init( &amp;mux_w_sem, 0, 1 );
-  sem_init( &amp;mux_r_sem, 0, 0 );
-
-  // Open all the service ports and create their corresponding threads
-  if( ( threads = ( THREAD_DATA* )malloc( sizeof( THREAD_DATA ) * ( vport_num + 1 ) ) ) == NULL )
-  {
-    fprintf( stderr, &quot;Not enough memory\n&quot; );
-    return 1;
-  }
-  for( i = 0; i &lt;= vport_num; i ++ ) 
-  {
-    tdata = threads + i;
-    if( i &lt; vport_num )
-    {
-      if( ( tdata-&gt;fd = ser_open( argv[ i + FIRST_SERVICE_IDX ] ) ) == ( ser_handler )-1 )
-      {
-        fprintf( stderr, &quot;Unable to open port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
-        return 1;
-      }
-      if( ser_setup( tdata-&gt;fd, service_baud, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-      {
-        fprintf( stderr, &quot;Unable to setup serial port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
-        return 1;
-      }
-      tdata-&gt;pname = argv[ i + FIRST_SERVICE_IDX ];
-      tdata-&gt;service_id = i + SERVICE_ID_FIRST;
-    }
-    if( pthread_create( &amp;tdata-&gt;tid, NULL, i == vport_num ? transport_thread : service_thread, ( void* )tdata ) )
-    {
-      fprintf( stderr, &quot;Unable to create thread\n&quot; );
-      return 1;
-    }
-  }
-
-  printf( &quot;Starting service multiplexer on %u port(s)\n&quot;, vport_num );
-  // Main service thread
-  while( 1 )
-  {
-    sem_wait( &amp;mux_r_sem );
-    data = mux_data;
-    sem_post( &amp;mux_w_sem );
-    if( data.id == TRANSPORT_SERVICE_ID )
-    {
-      // Read one byte, interpret it
-      c = data.data;
-      if( c != ESCAPE_CHAR )
-      {
-        if( c &gt;= SERVICE_ID_FIRST &amp;&amp; c &lt;= SERVICE_ID_LAST )
-          service_id_in = c;
-        else
-        {
-          if( got_esc )
-          {
-            // Got an escape last time, check the char now (with the 5th bit flipped)
-            c ^= ESCAPE_XOR_MASK;
-            if( c != ESCAPE_CHAR &amp;&amp; c &lt; SERVICE_ID_FIRST &amp;&amp; c &gt; SERVICE_ID_LAST )
-            {
-               fprintf( stderr, &quot;Protocol error: invalid escape sequence\n&quot; );
-               return 1;
-            }
-            got_esc = 0;
-          }  
-          if( service_id_in == -1 )
-          {
-            fprintf( stderr, &quot;Protocol error: service ID not specified\n&quot; );
-            return 1;
-          }
-          ser_write_byte( threads[ service_id_in - SERVICE_ID_FIRST ].fd, c );
-        }
-      }
-      else
-        got_esc = 1;
-    }
-    else
-    {
-      temp = data.id;
-      sdata = data.data;
-      if( temp != service_id_out )
-        transport_send_byte( temp );
-      // Then send the actual data byte, escaping it if needed
-      if( sdata == ESCAPE_CHAR || ( sdata &gt;= SERVICE_ID_FIRST &amp;&amp; sdata &lt;= SERVICE_ID_LAST ) )
-      {
-        transport_send_byte( ESCAPE_CHAR );
-        transport_send_byte( ( u8 )sdata ^ ESCAPE_XOR_MASK );
-      }
-      else
-        transport_send_byte( sdata );
-      service_id_out = temp;
-    }
-  }
-
-  return 0;
-}
-

Deleted: branches/pre0.8/mux_src/main.c.old
===================================================================
--- branches/pre0.8/mux_src/main.c.old	2011-02-02 14:45:17 UTC (rev 942)
+++ branches/pre0.8/mux_src/main.c.old	2011-02-02 14:47:22 UTC (rev 943)
@@ -1,755 +0,0 @@
-// Service multiplexer 
-
-#include &lt;stdio.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;semaphore.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;limits.h&gt;
-#include &quot;config.h&quot;
-#include &quot;log.h&quot;
-#include &quot;type.h&quot;
-#include &quot;serial.h&quot;
-#include &quot;os_io.h&quot;
-#include &quot;pnet.h&quot;
-
-// External RFS functions
-extern int rfs_server_init( unsigned server_port, const char* dirname );
-extern void rfs_server_cleanup();
-extern void* rfs_thread( void* data );
-extern volatile int rfs_thread_should_die;
-
-// ****************************************************************************
-// Data structures and local variables
-
-#define TRANSPORT_TYPE_ERROR        0
-#define TRANSPORT_TYPE_SER          1
-#define TRANSPORT_TYPE_UDP          2
-#define TRANSPORT_TYPE_TEXTCTRL     3
-
-// Service ID of the transport thread
-#define TRANSPORT_SERVICE_ID        ( -1 )
-#define THREAD_STOP_SERVICE_ID      ( -2 )  
-
-// Thread indexes in the threads array
-#ifdef MUX_THREAD_MODE
-#define TEXTCTRL_THREAD_IDX         1
-#else
-#define TEXTCTRL_THREAD_IDX         ( -1 )
-#endif
-#define RFS_UDP_THREAD_IDX          0
-        
-// Send/receive/init function pointers for transport
-typedef u32 ( *p_recv_func )( u8 *p, u32 size );
-typedef u32 ( *p_send_func )( const u8 *p, u32 size );
-typedef int ( *p_init_func )( void );
-typedef void ( *p_cleanup_func )( void );
-
-// Thread function type
-typedef void* ( *p_thread_func )( void* );
-
-// Thread structure
-typedef struct 
-{
-  pthread_t tid;
-  int thread_created;
-  volatile int thread_should_die;
-  int type;  
-  union
-  {
-    const char *pname;
-    unsigned port;
-  };
-  union
-  {
-    ser_handler fd;
-    SOCKET s;
-  };
-  int service_id;
-  struct sockaddr_in server;
-  union
-  {
-    sem_t udp_sem;
-    sem_t textctrl_sem;
-  };
-  int textctrl_data;
-  u8 *udp_buf;
-} THREAD_DATA;
-
-// Serial transport data structure
-typedef struct 
-{
-  ser_handler fd;
-  char *pname;
-  long speed;
-} TRANSPORT_SER;
-
-// Service/transport data
-typedef struct 
-{
-  int id;
-  u8 data;
-} DATA;
-
-static THREAD_DATA *threads;
-static unsigned vport_num;
-
-static void *transport_data;
-static int transport_type;
-static p_recv_func transport_recv;
-static p_send_func transport_send;
-static p_init_func transport_init;
-static p_cleanup_func transport_cleanup;
-static long service_baud;
-static sem_t mux_w_sem, mux_r_sem;
-static DATA mux_data;
-static int service_id_in = -1, service_id_out = -1;
-static pthread_t rfs_thread_id;
-static int rfs_thread_created;
-volatile int mux_thread_running;
-
-// *****************************************************************************
-// wxTextCtrl &quot;transport&quot; helpers
-
-#ifdef MUX_THREAD_MODE
-
-// wxTextCtrl buffer data
-typedef struct
-{
-  int *pdata;
-  unsigned r_idx, w_idx, total;  
-  sem_t count_sem;
-} TEXTCTRL_DATA;
-
-static TEXTCTRL_DATA textctrl_data;
-
-int mux_textctrl_init( unsigned total )
-{                                  
-  if( ( textctrl_data.pdata = ( int* )malloc( total * sizeof( int ) ) ) == NULL )
-  {
-    log_err( &quot;Unable to alloc textctrl buffer\n&quot; );
-    return 0;
-  }
-  textctrl_data.r_idx = textctrl_data.w_idx = 0;
-  textctrl_data.total = total;
-  sem_init( &amp;textctrl_data.count_sem, 0, 0 );
-  return 1;
-}
-
-void mux_textctrl_cleanup()
-{
-  free( textctrl_data.pdata );
-  sem_destroy( &amp;textctrl_data.count_sem );
-}
-
-void textctrl_get_char( int c )
-{
-#if 0
-  textctrl_data.pdata[ textctrl_data.w_idx ] = c;
-  textctrl_data.w_idx = ( textctrl_data.w_idx + 1 ) % textctrl_data.total;
-  printf( &quot;!&quot; );
-  sem_post( &amp;textctrl_data.count_sem );
-#else
-  THREAD_DATA *pdata = threads + TEXTCTRL_THREAD_IDX;
-  pdata-&gt;textctrl_data = c;
-  sem_post( &amp;pdata-&gt;textctrl_sem );
-#endif
-}
-
-extern void textctrl_put_char( int c );
-
-#else // #ifdef MUX_THREAD_MODE
-
-static void textctrl_put_char( int c )
-{
-}
-
-static void textctrl_get_char( int c )
-{
-}
-
-#endif // #ifdef MUX_THREAD_MODE
-
-// *****************************************************************************
-// Serial transport implementation
-
-static u32 transport_ser_recv( u8 *p, u32 size ) 
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_read( pser-&gt;fd, p, size, SER_TIMEOUT_MS );
-}
-
-static u32 transport_ser_send( const u8 *p, u32 size )
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  return ser_write( pser-&gt;fd, p, size );
-}
-
-static int transport_ser_init()
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  if( ( pser-&gt;fd = ser_open( pser-&gt;pname ) ) == ( ser_handler )-1 )
-  {
-    log_err( &quot;Unable to open %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  if( ser_setup( pser-&gt;fd, pser-&gt;speed, 8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-  {
-    log_err( &quot;Unable to setup serial port %s\n&quot;, pser-&gt;pname );
-    return 0;
-  }
-  while( ser_read_byte( pser-&gt;fd, SER_NO_TIMEOUT ) != -1 );
-  log_msg( &quot;Running serial transport on port %s at %u baud (8N1)\n&quot;, pser-&gt;pname, ( unsigned )pser-&gt;speed );
-  return 1;
-}
-
-static void transport_ser_cleanup()
-{
-  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
-
-  if( pser-&gt;fd &amp;&amp; pser-&gt;fd != ( ser_handler )-1 )
-    ser_close( pser-&gt;fd );
-  free( pser-&gt;pname );
-}
-
-// ****************************************************************************
-// Utility functions and helpers
-
-static void transport_send_byte( u8 data )
-{
-  transport_send( &amp;data, 1 );
-}
-
-static int transport_read_byte() 
-{
-  u8 c;
-
-  return transport_recv( &amp;c, 1 ) == 1 ? c : -1;
-}
-
-// Secure atoi
-static int secure_atoi( const char *str, long *pres )
-{
-  char *end_ptr;
-  long s1;
-  
-  errno = 0;
-  s1 = strtol( str, &amp;end_ptr, 10 );
-  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
-    return 0;
-  else if( end_ptr == str )
-    return 0;
-  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
-    return 0;
-  else if( '\0' != *end_ptr )
-    return 0;
-  *pres = s1;
-  return 1;  
-}
-
-// Local strndup function to compensate the lack of strndup in Windows
-static char* l_strndup( const char* s, size_t n )
-{
-  char* p;
-  
-  if( ( p = ( char* )malloc( n + 1 ) ) == NULL )
-    return NULL;
-  p [ 0 ] = p[ n ] = '\0';
-  strncpy( p, s, n );
-  return p;
-} 
-
-// Transport parser
-static int parse_transport( const char* s )
-{
-  const char *c;
-  static TRANSPORT_SER tser; 
-
-  if( strstr( s, &quot;ser:&quot; ) == s )
-  {
-    s += strlen( &quot;ser:&quot; );
-    if( ( c = strchr( s, ',' ) ) == NULL )
-    {
-      log_err( &quot;Invalid serial transport syntax\n&quot; );
-      return 0;
-    }
-    if( secure_atoi( c + 1, &amp;tser.speed ) == 0 )
-    {
-      log_err( &quot;Invalid port speed\n&quot; );
-      return 0;
-    }
-    tser.pname = l_strndup( s, c - s );
-    transport_data = &tser;
-    transport_send = transport_ser_send;
-    transport_recv = transport_ser_recv;
-    transport_init = transport_ser_init;
-    transport_cleanup = transport_ser_cleanup;
-    transport_type = TRANSPORT_TYPE_SER;
-    return 1;
-  }
-  log_err( &quot;Error: unsupported transport\n&quot; );
-  return 0;
-}
-
-// ***************************************************************************
-// Service threads
-
-static void* service_thread_ser( void* data )
-{
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;
-  int sdata;
-
-  log_msg( &quot;Starting serial service thread for port %s\n&quot;, pdata-&gt;pname );
-  while( 1 ) 
-  {
-    if( ( sdata = ser_read_byte( pdata-&gt;fd, SER_TIMEOUT_MS ) ) == -1 )
-    {
-      if( pdata-&gt;thread_should_die )
-        break;
-      else
-        continue;
-    }
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = pdata-&gt;service_id;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-static void* service_thread_udp( void* data )
-{
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;
-  socklen_t fromlen;
-  struct sockaddr_in from;
-  int readbytes, i;
-  fd_set fds;
-  struct timeval tv;
-    
-  log_msg( &quot;Starting UDP service thread for port %d\n&quot;, pdata-&gt;port );
-  while( 1 ) 
-  {
-    FD_ZERO( &amp;fds );
-    FD_SET( pdata-&gt;s, &amp;fds );
-    tv.tv_sec = 0;
-    tv.tv_usec = NET_TIMEOUT_MS * 1000;
-    if( select( pdata-&gt;s + 1, &amp;fds, NULL, NULL, &amp;tv ) &lt;= 0 )
-    {
-      if( pdata-&gt;thread_should_die )
-        break;
-      else
-        continue;
-    }
-    fromlen = sizeof( from );
-    readbytes = recvfrom( pdata-&gt;s, pdata-&gt;udp_buf, UDP_BUF_SIZE, 0, ( struct sockaddr* )&amp;from, &amp;fromlen );
-    for( i = 0; i &lt; readbytes; i ++ )
-    {
-      if( pdata-&gt;thread_should_die )
-        break;    
-      sem_wait( &amp;mux_w_sem );
-      mux_data.data = pdata-&gt;udp_buf[ i ];
-      mux_data.id = pdata-&gt;service_id;
-      sem_post( &amp;mux_r_sem );
-    }
-    if( pdata-&gt;thread_should_die )
-      break;       
-  }
-  return NULL;  
-}
-
-static void* service_thread_textctrl( void* data )
-{
-#ifdef MUX_THREAD_MODE
-  int c;
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;  
-    
-  log_msg( &quot;Starting wxTextCtrl service thread\n&quot; );
-  while( 1 )
-  {
-#if 0  
-    sem_wait( &amp;textctrl_data.count_sem );
-    if( ( c = textctrl_data.pdata[ textctrl_data.r_idx ] ) == -1 )
-      break;
-    textctrl_data.r_idx = ( textctrl_data.r_idx + 1 ) % textctrl_data.total;
-#else
-    sem_wait( &amp;pdata-&gt;textctrl_sem );
-    if( ( c = pdata-&gt;textctrl_data ) == -1 )
-      break;
-#endif
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = c;
-    mux_data.id = pdata-&gt;service_id;
-    sem_post( &amp;mux_r_sem );      
-  }
-#endif  
-  return NULL;
-}
-
-static const p_thread_func mux_service_funcs[] = { NULL, service_thread_ser, service_thread_udp, service_thread_textctrl };
-
-// *****************************************************************************
-// Transport thread
-
-static void* transport_thread( void* data )
-{                     
-  int sdata;
-  THREAD_DATA *pdata = ( THREAD_DATA* )data;
-  
-  log_msg( &quot;Starting transport thread\n&quot; );  
-  while( 1 ) 
-  {
-    if( ( sdata = transport_read_byte() ) == -1 )
-    {    
-      if( pdata-&gt;thread_should_die )
-        break;
-      else
-        continue;
-    }    
-    sem_wait( &amp;mux_w_sem );
-    mux_data.data = sdata;
-    mux_data.id = TRANSPORT_SERVICE_ID;
-    sem_post( &amp;mux_r_sem );
-  }
-  return NULL;
-}
-
-// *****************************************************************************
-// Transport aware byte send function
-
-static void byte_send( THREAD_DATA *data, u8 d )
-{   
-  if( data-&gt;type == TRANSPORT_TYPE_SER )
-    ser_write_byte( data-&gt;fd, d );
-  else if( data-&gt;type == TRANSPORT_TYPE_UDP )
-    sendto( data-&gt;s, &amp;d, 1, 0, ( struct sockaddr* )&amp;data-&gt;server, sizeof( data-&gt;server ) );
-  else 
-    textctrl_put_char( d );            
-}
-
-// ****************************************************************************
-// Program entry point
-
-#define MAIN_TRANSPORT_IDX    1
-#define SERVICE_BAUD_IDX      2
-#define RFS_DIRNAME_IDX       3
-#define FIRST_SERVICE_IDX     4
-
-int mux_init( int argc, char **argv )
-{
-  unsigned i;
-  THREAD_DATA *tdata;
-  struct hostent *hp;
-        
-  // Setup networking in Windows
-#ifdef WIN32_BUILD
-  // The socket subsystem must be initialized if working in Windows
-  WORD wVersionRequested;
-  WSADATA wsaData;
-  int err;
- 
-  wVersionRequested = MAKEWORD( 2, 0 );
-  err = WSAStartup( wVersionRequested, &amp;wsaData );  
-  if( err != 0 )
-  {
-    log_err( &quot;Unable to initialize the socket subsystem\n&quot; );
-    return 1;
-  }
-#endif // #ifdef WIN32_BUILD  
-
-  // Interpret arguments
-  if( argc &lt; FIRST_SERVICE_IDX + 1 )
-  {
-    log_err( &quot;Usage: %s &lt;transport&gt; &lt;baud&gt; &lt;rfs_dir_name&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]\n&quot;, argv[ 0 ] );
-    return 1;
-  }
-  i = argc - 1;
-  if( !strcasecmp( argv[ i ], &quot;-v&quot; ) )
-  {
-    i --;
-    log_init( LOG_ALL );
-  }
-  else                            
-    log_init( LOG_NONE ); 
-  if( ( vport_num = i - 3 ) &gt; SERVICE_MAX )
-  {
-    log_err( &quot;Too many service ports, maximum is %d\n&quot;, SERVICE_MAX );
-    return 1;
-  }
-  if( parse_transport( argv[ MAIN_TRANSPORT_IDX ] ) == 0 )
-    return 1;
-  if( secure_atoi( argv[ SERVICE_BAUD_IDX ], &amp;service_baud ) == 0 )
-  {
-    log_err( &quot;Invalid service baud\n&quot; );
-    return 1;
-  }
-  if( !os_isdir( argv[ RFS_DIRNAME_IDX ] ) )
-  {
-    log_err( &quot;Invalid directory %s\n&quot;, argv[ RFS_DIRNAME_IDX ] );
-    return 1;
-  }  
-  if( transport_init() == 0 )
-    return 1;
-  if( rfs_server_init( RFS_SERVER_PORT, argv[ RFS_DIRNAME_IDX ] ) == 0 )
-    return 1;
-      
-  // Create global sync objects
-  sem_init( &amp;mux_w_sem, 0, 1 );
-  sem_init( &amp;mux_r_sem, 0, 0 );
-
-  // Open all the service ports and create their corresponding threads
-  if( ( threads = ( THREAD_DATA* )malloc( sizeof( THREAD_DATA ) * ( vport_num + 2 ) ) ) == NULL )
-  {
-    log_err( &quot;Not enough memory\n&quot; );
-    return 1;
-  }
-  memset( threads, 0, sizeof( THREAD_DATA ) * ( vport_num + 2 ) );
-  // Thread map:
-  // index 0 : UDP thread (ALWAYS first service ID!)
-  // 1 ... vport_num : actual serial ports
-  //   (1 is connected to the console wxTextCtrl in frontend mode)
-  // vport_num + 1: transport thread
-  for( i = 0; i &lt;= vport_num + 1; i ++ ) 
-  {
-    tdata = threads + i;
-    tdata-&gt;thread_should_die = 0;
-    if( i &lt;= vport_num )
-    {    
-      if( i == TEXTCTRL_THREAD_IDX )
-      {
-        sem_init( &amp;tdata-&gt;textctrl_sem, 0, 0 );          
-        tdata-&gt;type = TRANSPORT_TYPE_TEXTCTRL;
-      } 
-      else if( i == RFS_UDP_THREAD_IDX )    
-      {      
-        tdata-&gt;s = INVALID_SOCKET_VALUE;
-        if( ( tdata-&gt;udp_buf = ( u8* )malloc( UDP_BUF_SIZE ) ) == NULL )
-        {
-          log_err( &quot;Unable to allocate UDP buffer\n&quot; );
-          return 1;
-        }
-        // UDP thread  
-        if( ( tdata-&gt;s = socket( AF_INET, SOCK_DGRAM, 0 ) ) == INVALID_SOCKET_VALUE )
-        {
-          log_err( &quot;Error creating socket\n&quot; );
-          return 1;
-        }
-        tdata-&gt;server.sin_family = AF_INET;
-        hp = gethostbyname( &quot;127.0.0.1&quot; );
-        memcpy( &amp;tdata-&gt;server.sin_addr, hp-&gt;h_addr, hp-&gt;h_length );
-        tdata-&gt;server.sin_port = htons( RFS_SERVER_PORT );
-        tdata-&gt;type = TRANSPORT_TYPE_UDP;
-        tdata-&gt;port = RFS_SERVER_PORT;
-        sem_init( &amp;tdata-&gt;udp_sem, 0, 0 );                  
-      }
-      else
-      {   
-        // Serial thread
-        if( ( tdata-&gt;fd = ser_open( argv[ i  - 1 + FIRST_SERVICE_IDX ] ) ) == ( ser_handler )-1 )
-        {
-          log_err( &quot;Unable to open port %s\n&quot;, argv[ i - 1 + FIRST_SERVICE_IDX ] );
-          return 1;
-        }
-        if( ser_setup( tdata-&gt;fd, service_baud, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
-        {
-          log_err( &quot;Unable to setup serial port %s\n&quot;, argv[ i - 1 + FIRST_SERVICE_IDX ] );
-          return 1;
-        }
-        tdata-&gt;type = TRANSPORT_TYPE_SER;
-        tdata-&gt;pname = argv[ i - 1 + FIRST_SERVICE_IDX ];        
-      }
-      tdata-&gt;service_id = i + SERVICE_ID_FIRST;         
-    }
-    if( pthread_create( &amp;tdata-&gt;tid, NULL, i &lt;= vport_num ? mux_service_funcs[ tdata-&gt;type ] : transport_thread, tdata ) )
-    {
-      log_err( &quot;Unable to create transport thread\n&quot; );
-      return 1;
-    }
-    tdata-&gt;thread_created = 1;
-  }
-  // Create rfs_server thread
-  if( pthread_create( &amp;rfs_thread_id, NULL, rfs_thread, argv[ RFS_DIRNAME_IDX ] ) )
-  {
-    log_err( &quot;Unable to create RFS thread\n&quot; );
-    return 1;
-  }
-  rfs_thread_created = 1;
-  return 0;  
-}
-
-void mux_cleanup()
-{
-  unsigned i;
-  THREAD_DATA *tdata;
-                            
-  if( threads )
-  {
-    // Thread map:
-    // index 0 : UDP thread (ALWAYS first service ID!)
-    // 1 ... vport_num : actual serial ports
-    // vport_num + 1: transport thread
-    for( i = 0; i &lt;= vport_num + 1; i ++ ) 
-    {
-      tdata = threads + i;
-      if( tdata-&gt;thread_created == 1 )
-      {
-        if( i == TEXTCTRL_THREAD_IDX )
-          textctrl_get_char( -1 );
-        tdata-&gt;thread_should_die = 1;
-        pthread_join( tdata-&gt;tid, NULL );
-      }
-      if( i &lt;= vport_num )
-      {
-        if( i == TEXTCTRL_THREAD_IDX )
-          sem_destroy( &amp;tdata-&gt;textctrl_sem );
-        else if( i == RFS_UDP_THREAD_IDX )
-        {        
-          free( tdata-&gt;udp_buf );
-          if( tdata-&gt;s != INVALID_SOCKET_VALUE )
-            socket_close( tdata-&gt;s );             
-          sem_destroy( &amp;tdata-&gt;udp_sem );                   
-        }
-        else
-        {  
-          // Serial thread
-          if( tdata-&gt;fd &amp;&amp; tdata-&gt;fd != ( ser_handler )-1 )
-            ser_close( tdata-&gt;fd );         
-        }    
-      }
-    }
-    free( threads );
-    threads = NULL;
-  }
-  if( rfs_thread_created )
-  {
-    rfs_thread_should_die = 1;
-    pthread_join( rfs_thread_id, NULL );
-  }
-  rfs_server_cleanup();
-  transport_cleanup();
-  
-  sem_destroy( &amp;mux_w_sem );
-  sem_destroy( &amp;mux_r_sem );
-  
-  // Re-init globals
-  vport_num = 0;
-  transport_type = TRANSPORT_TYPE_ERROR;
-  service_baud = 0;
-  service_id_in = -1;
-  service_id_out = -1;
-  rfs_thread_created = 0;
-  mux_thread_running = 0;
-}
-
-#if defined( MUX_STANDALONE_MODE )
-
-#define RETVAL  1
-#define RETVAL_TYPE int
-
-#elif defined( MUX_THREAD_MODE )
-
-#define RETVAL  NULL
-#define RETVAL_TYPE void*
-
-void mux_thread_stop()
-{
-  sem_wait( &amp;mux_w_sem );
-  mux_data.id = THREAD_STOP_SERVICE_ID;
-  sem_post( &amp;mux_r_sem );
-}
-    
-#else
-#error &quot;Operating mode (standalone or thread) not defined&quot;
-#endif
-
-RETVAL_TYPE mux_thread( void *pdata ) 
-{
-  int c, prev_sent = -1;
-  int temp, sdata;
-  int got_esc = 0;
-  DATA data;
-                                                                                     
-  log_msg( &quot;Starting service multiplexer on %u port(s) and RFS server\n&quot;, vport_num );
-  // Main service thread
-  while( 1 )
-  {
-    sem_wait( &amp;mux_r_sem );
-    data = mux_data;
-    sem_post( &amp;mux_w_sem );
-    if( data.id == THREAD_STOP_SERVICE_ID )
-      break;        
-    if( data.id == TRANSPORT_SERVICE_ID )
-    {
-      // Read one byte, interpret it
-      c = data.data;
-      if( c != ESCAPE_CHAR )
-      {
-        if( c &gt;= SERVICE_ID_FIRST &amp;&amp; c &lt;= SERVICE_ID_LAST )
-          service_id_in = c;
-        else if( c == FORCE_SID_CHAR &amp;&amp; prev_sent != -1 )
-        {
-          // Re-transmit the last data AND the service ID
-          transport_send_byte( service_id_out );
-          if( prev_sent &amp; ESC_MASK )
-            transport_send_byte( ESCAPE_CHAR );
-          transport_send_byte( prev_sent &amp; 0xFF );
-        }
-        else
-        {
-          if( got_esc )
-          {
-            // Got an escape last time, check the char now (with the 5th bit flipped)
-            c ^= ESCAPE_XOR_MASK;
-            if( c != ESCAPE_CHAR &amp;&amp; c != FORCE_SID_CHAR &amp;&amp; ( c &lt; SERVICE_ID_FIRST || c &gt; SERVICE_ID_LAST ) )
-            {
-               log_err( &quot;Protocol error: invalid escape sequence\n&quot; );
-               break;
-            }
-            got_esc = 0;
-          }  
-          if( service_id_in == -1 )
-          {
-            transport_send_byte( FORCE_SID_CHAR );
-            log_msg( &quot;Requested resend of service ID\n&quot; );
-          }
-          else
-            byte_send( threads + service_id_in - SERVICE_ID_FIRST, c );
-        }
-      }
-      else
-        got_esc = 1;
-    }
-    else
-    {
-      temp = data.id;
-      sdata = data.data;
-      if( temp != service_id_out )
-        transport_send_byte( temp );
-      prev_sent = sdata;
-      // Then send the actual data byte, escaping it if needed
-      if( sdata == ESCAPE_CHAR || sdata == FORCE_SID_CHAR || ( sdata &gt;= SERVICE_ID_FIRST &amp;&amp; sdata &lt;= SERVICE_ID_LAST ) )
-      {
-        transport_send_byte( ESCAPE_CHAR );
-        transport_send_byte( ( u8 )sdata ^ ESCAPE_XOR_MASK );
-        prev_sent = ESC_MASK | ( ( u8 )sdata ^ ESCAPE_XOR_MASK );
-      }
-      else
-        transport_send_byte( sdata );
-      service_id_out = temp;
-    }
-  }
-  mux_thread_running = 0;
-  return RETVAL;
-}
-
-#ifdef MUX_STANDALONE_MODE
-int main( int argc, char **argv )
-{
-  if( mux_init( argc, argv ) )
-    return RETVAL;
-  return mux_thread( NULL );
-}
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000895.html">[Elua-svn] r942 - in branches/pre0.8: . src/platform/i386 utils
</A></li>
	<LI>Next message: <A HREF="000897.html">[Elua-svn] r944 - branches/pre0.8/doc/en
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#896">[ date ]</a>
              <a href="thread.html#896">[ thread ]</a>
              <a href="subject.html#896">[ subject ]</a>
              <a href="author.html#896">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
