<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r269 - in branches/eagle_mmc/src: fatfs platform/lm3s
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r269%20-%20in%20branches/eagle_mmc/src%3A%20fatfs%20platform/lm3s&In-Reply-To=%3C200903260217.n2Q2HnTE025058%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000224.html">
   <LINK REL="Next"  HREF="000225.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r269 - in branches/eagle_mmc/src: fatfs platform/lm3s</H1>
    <B>jalvarez at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r269%20-%20in%20branches/eagle_mmc/src%3A%20fatfs%20platform/lm3s&In-Reply-To=%3C200903260217.n2Q2HnTE025058%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r269 - in branches/eagle_mmc/src: fatfs platform/lm3s">jalvarez at mail.berlios.de
       </A><BR>
    <I>Thu Mar 26 03:17:49 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000224.html">[Elua-svn] r268 - in trunk/doc: . en wb
</A></li>
        <LI>Next message: <A HREF="000225.html">[Elua-svn] r270 - in trunk/src: . platform/lm3s platform/stm32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#226">[ date ]</a>
              <a href="thread.html#226">[ thread ]</a>
              <a href="subject.html#226">[ subject ]</a>
              <a href="author.html#226">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jalvarez
Date: 2009-03-26 03:17:48 +0100 (Thu, 26 Mar 2009)
New Revision: 269

Added:
   branches/eagle_mmc/src/platform/lm3s/jtag.c
   branches/eagle_mmc/src/platform/lm3s/jtag.h
Modified:
   branches/eagle_mmc/src/fatfs/diskio.h
   branches/eagle_mmc/src/fatfs/ff.c
   branches/eagle_mmc/src/fatfs/ff.h
   branches/eagle_mmc/src/fatfs/integer.h
Log:
1. Rolled back FatFs to 0.04b. The mmc.c driver in use was originally
developed by LMI for 0.04b and does not implement some functionality in
FatFs 0.06. Although it worked fine on my test system, there could be
potential problems with some boards and/or cards.

2. eLua currently does not switch the JTAG pins to GPIO. This causes
some GPIO pins (PB7 and PC0-3 on the LM3S6918) to be non-functional for
eLua applications. Added jtag.c and jtag.h to src/platform/lm3s to
implement a workaround. Will check with the mailing list for the proper
way to handle this within eLua before changing the base code.



Modified: branches/eagle_mmc/src/fatfs/diskio.h
===================================================================
--- branches/eagle_mmc/src/fatfs/diskio.h	2009-03-25 23:29:27 UTC (rev 268)
+++ branches/eagle_mmc/src/fatfs/diskio.h	2009-03-26 02:17:48 UTC (rev 269)
@@ -1,11 +1,10 @@
 /*-----------------------------------------------------------------------
-/  Low level disk interface modlue include file  R0.06   (C)ChaN, 2007
+/  Low level disk interface modlue include file  R0.04a   (C)ChaN, 2007
 /-----------------------------------------------------------------------*/
 
 #ifndef _DISKIO
 
 #define _READONLY	0	/* 1: Read-only mode */
-#define _USE_IOCTL	1
 
 #include &quot;integer.h&quot;
 
@@ -47,21 +46,15 @@
 
 /* Command code for disk_ioctrl() */
 
-/* Generic command */
-#define CTRL_SYNC			0	/* Mandatory for read/write configuration */
-#define GET_SECTOR_COUNT	1	/* Mandatory for only f_mkfs() */
+#define GET_SECTOR_COUNT	1
 #define GET_SECTOR_SIZE		2
-#define GET_BLOCK_SIZE		3	/* Mandatory for only f_mkfs() */
+#define CTRL_SYNC			3
 #define CTRL_POWER			4
 #define CTRL_LOCK			5
 #define CTRL_EJECT			6
-/* MMC/SDC command */
-#define MMC_GET_TYPE		10
-#define MMC_GET_CSD			11
-#define MMC_GET_CID			12
-#define MMC_GET_OCR			13
-#define MMC_GET_SDSTAT		14
-/* ATA/CF command */
+#define MMC_GET_CSD			10
+#define MMC_GET_CID			11
+#define MMC_GET_OCR			12
 #define ATA_GET_REV			20
 #define ATA_GET_MODEL		21
 #define ATA_GET_SN			22

Modified: branches/eagle_mmc/src/fatfs/ff.c
===================================================================
--- branches/eagle_mmc/src/fatfs/ff.c	2009-03-25 23:29:27 UTC (rev 268)
+++ branches/eagle_mmc/src/fatfs/ff.c	2009-03-26 02:17:48 UTC (rev 269)
@@ -1,62 +1,45 @@
-/*----------------------------------------------------------------------------/
-/  FatFs - FAT file system module  R0.06                     (C)ChaN, 2008
-/-----------------------------------------------------------------------------/
+/*--------------------------------------------------------------------------/
+/  FatFs - FAT file system module  R0.04b                    (C)ChaN, 2007
+/---------------------------------------------------------------------------/
 / The FatFs module is an experimenal project to implement FAT file system to
 / cheap microcontrollers. This is a free software and is opened for education,
 / research and development under license policy of following trems.
 /
-/  Copyright (C) 2008, ChaN, all right reserved.
+/  Copyright (C) 2007, ChaN, all right reserved.
 /
 / * The FatFs module is a free software and there is no warranty.
 / * You can use, modify and/or redistribute it for personal, non-profit or
-/   commercial use without restriction under your responsibility.
+/   profit use without any restriction under your responsibility.
 / * Redistributions of source code must retain the above copyright notice.
 /
-/-----------------------------------------------------------------------------/
-/ Feb 26,'06 R0.00  Prototype.
-/
-/ Apr 29,'06 R0.01  First stable version.
-/
-/ Jun 01,'06 R0.02  Added FAT12 support.
-/                   Removed unbuffered mode.
-/                   Fixed a problem on small (&lt;32M) patition.
-/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
-/
-/ Sep 22,'06 R0.03  Added f_rename().
-/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
-/ Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.
-/                   Fixed f_mkdir() creates incorrect directory on FAT32.
-/
-/ Feb 04,'07 R0.04  Supported multiple drive system.
-/                   Changed some interfaces for multiple drive system.
-/                   Changed f_mountdrv() to f_mount().
-/                   Added f_mkfs().
-/ Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.
-/                   Added a capability of extending file size to f_lseek().
-/                   Added minimization level 3.
-/                   Fixed an endian sensitive code in f_mkfs().
-/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
-/                   Added FSInfo support.
-/                   Fixed DBCS name can result FR_INVALID_NAME.
-/                   Fixed short seek (&lt;= csize) collapses the file object.
-/
-/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
-/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
-/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
-/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
-/                   Fixed off by one error at FAT sub-type determination.
-/                   Fixed btr in f_read() can be mistruncated.
-/                   Fixed cached sector is not flushed when create and close
-/                   without write.
-/
-/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
-/                   Improved performance of f_lseek() on moving to the same
-/                   or following cluster.
+/---------------------------------------------------------------------------/
+/  Feb 26, 2006  R0.00  Prototype.
+/  Apr 29, 2006  R0.01  First stable version.
+/  Jun 01, 2006  R0.02  Added FAT12 support.
+/                       Removed unbuffered mode.
+/                       Fixed a problem on small (&lt;32M) patition.
+/  Jun 10, 2006  R0.02a Added a configuration option (_FS_MINIMUM).
+/  Sep 22, 2006  R0.03  Added f_rename().
+/                       Changed option _FS_MINIMUM to _FS_MINIMIZE.
+/  Dec 11, 2006  R0.03a Improved cluster scan algolithm to write files fast.
+/                       Fixed f_mkdir() creates incorrect directory on FAT32.
+/  Feb 04, 2007  R0.04  Supported multiple drive system.
+/                       Changed some interfaces for multiple drive system.
+/                       Changed f_mountdrv() to f_mount().
+/                       Added f_mkfs().
+/  Apr 01, 2007  R0.04a Supported multiple partitions on a plysical drive.
+/                       Added a capability of extending file size to f_lseek().
+/                       Added minimization level 3.
+/                       Fixed an endian sensitive code in f_mkfs().
+/  May 05, 2007  R0.04b Added a configuration option _USE_NTFLAG.
+/                       Added FSInfo support.
+/                       Fixed DBCS name can result FR_INVALID_NAME.
+/                       Fixed short seek (&lt;= csize) collapses the file object.
 /---------------------------------------------------------------------------*/
 
 #include &lt;string.h&gt;
-#include &quot;ff.h&quot;			/* FatFs declarations */
-#include &quot;diskio.h&quot;		/* Include file for user provided disk functions */
+#include &quot;ff.h&quot;            /* FatFs declarations */
+#include &quot;diskio.h&quot;        /* Include file for user provided disk functions */
 
 
 /*--------------------------------------------------------------------------
@@ -66,9 +49,9 @@
 ---------------------------------------------------------------------------*/
 
 static
-FATFS *FatFs[_DRIVES];	/* Pointer to the file system objects (logical drives) */
+FATFS *FatFs[_DRIVES];    /* Pointer to the file system objects (logical drives) */
 static
-WORD fsid;				/* File system mount ID */
+WORD fsid;                /* File system mount ID */
 
 
 
@@ -77,37 +60,37 @@
 /*-----------------------------------------------------------------------*/
 
 static
-BOOL move_window (	/* TRUE: successful, FALSE: failed */
-	FATFS *fs,		/* File system object */
-	DWORD sector	/* Sector number to make apperance in the fs-&gt;win[] */
-)					/* Move to zero only writes back dirty window */
+BOOL move_window (        /* TRUE: successful, FALSE: failed */
+    FATFS *fs,            /* File system object */
+    DWORD sector        /* Sector number to make apperance in the fs-&gt;win[] */
+)                        /* Move to zero only writes back dirty window */
 {
-	DWORD wsect;
+    DWORD wsect;
 
 
-	wsect = fs-&gt;winsect;
-	if (wsect != sector) {	/* Changed current window */
+    wsect = fs-&gt;winsect;
+    if (wsect != sector) {    /* Changed current window */
 #if !_FS_READONLY
-		BYTE n;
-		if (fs-&gt;winflag) {	/* Write back dirty window if needed */
-			if (disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1) != RES_OK)
-				return FALSE;
-			fs-&gt;winflag = 0;
-			if (wsect &lt; (fs-&gt;fatbase + fs-&gt;sects_fat)) {	/* In FAT area */
-				for (n = fs-&gt;n_fats; n &gt;= 2; n--) {	/* Refrect the change to FAT copy */
-					wsect += fs-&gt;sects_fat;
-					disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1);
-				}
-			}
-		}
+        BYTE n;
+        if (fs-&gt;winflag) {    /* Write back dirty window if needed */
+            if (disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1) != RES_OK)
+                return FALSE;
+            fs-&gt;winflag = 0;
+            if (wsect &lt; (fs-&gt;fatbase + fs-&gt;sects_fat)) {    /* In FAT area */
+                for (n = fs-&gt;n_fats; n &gt;= 2; n--) {    /* Refrect the change to FAT copy */
+                    wsect += fs-&gt;sects_fat;
+                    disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1);
+                }
+            }
+        }
 #endif
-		if (sector) {
-			if (disk_read(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
-				return FALSE;
-			fs-&gt;winsect = sector;
-		}
-	}
-	return TRUE;
+        if (sector) {
+            if (disk_read(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
+                return FALSE;
+            fs-&gt;winsect = sector;
+        }
+    }
+    return TRUE;
 }
 
 
@@ -119,30 +102,27 @@
 
 #if !_FS_READONLY
 static
-FRESULT sync (	/* FR_OK: successful, FR_RW_ERROR: failed */
-	FATFS *fs	/* File system object */
+FRESULT sync (            /* FR_OK: successful, FR_RW_ERROR: failed */
+    FATFS *fs            /* File system object */
 )
 {
-	fs-&gt;winflag = 1;
-	if (!move_window(fs, 0)) return FR_RW_ERROR;
+    fs-&gt;winflag = 1;
+    if (!move_window(fs, 0)) return FR_RW_ERROR;
 #if _USE_FSINFO
-	/* Update FSInfo sector if needed */
-	if (fs-&gt;fs_type == FS_FAT32 &amp;&amp; fs-&gt;fsi_flag) {
-		fs-&gt;winsect = 0;
-		memset(fs-&gt;win, 0, 512);
-		ST_WORD(&amp;fs-&gt;win[BS_55AA], 0xAA55);
-		ST_DWORD(&amp;fs-&gt;win[FSI_LeadSig], 0x41615252);
-		ST_DWORD(&amp;fs-&gt;win[FSI_StrucSig], 0x61417272);
-		ST_DWORD(&amp;fs-&gt;win[FSI_Free_Count], fs-&gt;free_clust);
-		ST_DWORD(&amp;fs-&gt;win[FSI_Nxt_Free], fs-&gt;last_clust);
-		disk_write(fs-&gt;drive, fs-&gt;win, fs-&gt;fsi_sector, 1);
-		fs-&gt;fsi_flag = 0;
-	}
+    if (fs-&gt;fs_type == FS_FAT32 &amp;&amp; fs-&gt;fsi_flag) {        /* Update FSInfo sector if needed */
+        fs-&gt;winsect = 0;
+        memset(fs-&gt;win, 0, 512);
+        ST_WORD(&amp;fs-&gt;win[BS_55AA], 0xAA55);
+        ST_DWORD(&amp;fs-&gt;win[FSI_LeadSig], 0x41615252);
+        ST_DWORD(&amp;fs-&gt;win[FSI_StrucSig], 0x61417272);
+        ST_DWORD(&amp;fs-&gt;win[FSI_Free_Count], fs-&gt;free_clust);
+        ST_DWORD(&amp;fs-&gt;win[FSI_Nxt_Free], fs-&gt;last_clust);
+        disk_write(0, fs-&gt;win, fs-&gt;fsi_sector, 1);
+        fs-&gt;fsi_flag = 0;
+    }
 #endif
-	/* Make sure that no pending write process in the physical drive */
-	if (disk_ioctl(fs-&gt;drive, CTRL_SYNC, NULL) != RES_OK)
-		return FR_RW_ERROR;
-	return FR_OK;
+    if (disk_ioctl(fs-&gt;drive, CTRL_SYNC, NULL) != RES_OK) return FR_RW_ERROR;
+    return FR_OK;
 }
 #endif
 
@@ -154,37 +134,37 @@
 /*-----------------------------------------------------------------------*/
 
 static
-DWORD get_cluster (	/* 0,&gt;=2: successful, 1: failed */
-	FATFS *fs,		/* File system object */
-	DWORD clust		/* Cluster# to get the link information */
+DWORD get_cluster (        /* 0,&gt;=2: successful, 1: failed */
+    FATFS *fs,            /* File system object */
+    DWORD clust            /* Cluster# to get the link information */
 )
 {
-	WORD wc, bc;
-	DWORD fatsect;
+    WORD wc, bc;
+    DWORD fatsect;
 
 
-	if (clust &gt;= 2 &amp;&amp; clust &lt; fs-&gt;max_clust) {		/* Is it a valid cluster#? */
-		fatsect = fs-&gt;fatbase;
-		switch (fs-&gt;fs_type) {
-		case FS_FAT12 :
-			bc = (WORD)clust * 3 / 2;
-			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
-			wc = fs-&gt;win[bc &amp; (SS(fs) - 1)]; bc++;
-			if (!move_window(fs, fatsect + (bc / SS(fs)))) break;
-			wc |= (WORD)fs-&gt;win[bc &amp; (SS(fs) - 1)] &lt;&lt; 8;
-			return (clust &amp; 1) ? (wc &gt;&gt; 4) : (wc &amp; 0xFFF);
+    if (clust &gt;= 2 &amp;&amp; clust &lt; fs-&gt;max_clust) {        /* Valid cluster# */
+        fatsect = fs-&gt;fatbase;
+        switch (fs-&gt;fs_type) {
+        case FS_FAT12 :
+            bc = (WORD)clust * 3 / 2;
+            if (!move_window(fs, fatsect + (bc / S_SIZ))) break;
+            wc = fs-&gt;win[bc &amp; (S_SIZ - 1)]; bc++;
+            if (!move_window(fs, fatsect + (bc / S_SIZ))) break;
+            wc |= (WORD)fs-&gt;win[bc &amp; (S_SIZ - 1)] &lt;&lt; 8;
+            return (clust &amp; 1) ? (wc &gt;&gt; 4) : (wc &amp; 0xFFF);
 
-		case FS_FAT16 :
-			if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) break;
-			return LD_WORD(&amp;fs-&gt;win[((WORD)clust * 2) &amp; (SS(fs) - 1)]);
+        case FS_FAT16 :
+            if (!move_window(fs, fatsect + (clust / (S_SIZ / 2)))) break;
+            return LD_WORD(&amp;fs-&gt;win[((WORD)clust * 2) &amp; (S_SIZ - 1)]);
 
-		case FS_FAT32 :
-			if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) break;
-			return LD_DWORD(&amp;fs-&gt;win[((WORD)clust * 4) &amp; (SS(fs) - 1)]) &amp; 0x0FFFFFFF;
-		}
-	}
+        case FS_FAT32 :
+            if (!move_window(fs, fatsect + (clust / (S_SIZ / 4)))) break;
+            return LD_DWORD(&amp;fs-&gt;win[((WORD)clust * 4) &amp; (S_SIZ - 1)]) &amp; 0x0FFFFFFF;
+        }
+    }
 
-	return 1;	/* Out of cluster range, or an error occured */
+    return 1;    /* There is no cluster information, or an error occured */
 }
 
 
@@ -196,46 +176,46 @@
 
 #if !_FS_READONLY
 static
-BOOL put_cluster (	/* TRUE: successful, FALSE: failed */
-	FATFS *fs,		/* File system object */
-	DWORD clust,	/* Cluster# to change (must be 2 to fs-&gt;max_clust-1) */
-	DWORD val		/* New value to mark the cluster */
+BOOL put_cluster (        /* TRUE: successful, FALSE: failed */
+    FATFS *fs,            /* File system object */
+    DWORD clust,        /* Cluster# to change */
+    DWORD val            /* New value to mark the cluster */
 )
 {
-	WORD bc;
-	BYTE *p;
-	DWORD fatsect;
+    WORD bc;
+    BYTE *p;
+    DWORD fatsect;
 
 
-	fatsect = fs-&gt;fatbase;
-	switch (fs-&gt;fs_type) {
-	case FS_FAT12 :
-		bc = (WORD)clust * 3 / 2;
-		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
-		p = &amp;fs-&gt;win[bc &amp; (SS(fs) - 1)];
-		*p = (clust &amp; 1) ? ((*p &amp; 0x0F) | ((BYTE)val &lt;&lt; 4)) : (BYTE)val;
-		bc++;
-		fs-&gt;winflag = 1;
-		if (!move_window(fs, fatsect + (bc / SS(fs)))) return FALSE;
-		p = &amp;fs-&gt;win[bc &amp; (SS(fs) - 1)];
-		*p = (clust &amp; 1) ? (BYTE)(val &gt;&gt; 4) : ((*p &amp; 0xF0) | ((BYTE)(val &gt;&gt; 8) &amp; 0x0F));
-		break;
+    fatsect = fs-&gt;fatbase;
+    switch (fs-&gt;fs_type) {
+    case FS_FAT12 :
+        bc = (WORD)clust * 3 / 2;
+        if (!move_window(fs, fatsect + (bc / S_SIZ))) return FALSE;
+        p = &amp;fs-&gt;win[bc &amp; (S_SIZ - 1)];
+        *p = (clust &amp; 1) ? ((*p &amp; 0x0F) | ((BYTE)val &lt;&lt; 4)) : (BYTE)val;
+        bc++;
+        fs-&gt;winflag = 1;
+        if (!move_window(fs, fatsect + (bc / S_SIZ))) return FALSE;
+        p = &amp;fs-&gt;win[bc &amp; (S_SIZ - 1)];
+        *p = (clust &amp; 1) ? (BYTE)(val &gt;&gt; 4) : ((*p &amp; 0xF0) | ((BYTE)(val &gt;&gt; 8) &amp; 0x0F));
+        break;
 
-	case FS_FAT16 :
-		if (!move_window(fs, fatsect + (clust / (SS(fs) / 2)))) return FALSE;
-		ST_WORD(&amp;fs-&gt;win[((WORD)clust * 2) &amp; (SS(fs) - 1)], (WORD)val);
-		break;
+    case FS_FAT16 :
+        if (!move_window(fs, fatsect + (clust / (S_SIZ / 2)))) return FALSE;
+        ST_WORD(&amp;fs-&gt;win[((WORD)clust * 2) &amp; (S_SIZ - 1)], (WORD)val);
+        break;
 
-	case FS_FAT32 :
-		if (!move_window(fs, fatsect + (clust / (SS(fs) / 4)))) return FALSE;
-		ST_DWORD(&amp;fs-&gt;win[((WORD)clust * 4) &amp; (SS(fs) - 1)], val);
-		break;
+    case FS_FAT32 :
+        if (!move_window(fs, fatsect + (clust / (S_SIZ / 4)))) return FALSE;
+        ST_DWORD(&amp;fs-&gt;win[((WORD)clust * 4) &amp; (S_SIZ - 1)], val);
+        break;
 
-	default :
-		return FALSE;
-	}
-	fs-&gt;winflag = 1;
-	return TRUE;
+    default :
+        return FALSE;
+    }
+    fs-&gt;winflag = 1;
+    return TRUE;
 }
 #endif /* !_FS_READONLY */
 
@@ -248,27 +228,27 @@
 
 #if !_FS_READONLY
 static
-BOOL remove_chain (	/* TRUE: successful, FALSE: failed */
-	FATFS *fs,		/* File system object */
-	DWORD clust		/* Cluster# to remove chain from */
+BOOL remove_chain (        /* TRUE: successful, FALSE: failed */
+    FATFS *fs,            /* File system object */
+    DWORD clust            /* Cluster# to remove chain from */
 )
 {
-	DWORD nxt;
+    DWORD nxt;
 
 
-	while (clust &gt;= 2 &amp;&amp; clust &lt; fs-&gt;max_clust) {
-		nxt = get_cluster(fs, clust);
-		if (nxt == 1) return FALSE;
-		if (!put_cluster(fs, clust, 0)) return FALSE;
-		if (fs-&gt;free_clust != 0xFFFFFFFF) {
-			fs-&gt;free_clust++;
+    while (clust &gt;= 2 &amp;&amp; clust &lt; fs-&gt;max_clust) {
+        nxt = get_cluster(fs, clust);
+        if (nxt == 1) return FALSE;
+        if (!put_cluster(fs, clust, 0)) return FALSE;
+        if (fs-&gt;free_clust != 0xFFFFFFFF) {
+            fs-&gt;free_clust++;
 #if _USE_FSINFO
-			fs-&gt;fsi_flag = 1;
+            fs-&gt;fsi_flag = 1;
 #endif
-		}
-		clust = nxt;
-	}
-	return TRUE;
+        }
+        clust = nxt;
+    }
+    return TRUE;
 }
 #endif
 
@@ -281,50 +261,50 @@
 
 #if !_FS_READONLY
 static
-DWORD create_chain (	/* 0: No free cluster, 1: Error, &gt;=2: New cluster number */
-	FATFS *fs,			/* File system object */
-	DWORD clust			/* Cluster# to stretch, 0 means create new */
+DWORD create_chain (    /* 0: no free cluster, 1: error, &gt;=2: new cluster number */
+    FATFS *fs,            /* File system object */
+    DWORD clust            /* Cluster# to stretch, 0 means create new */
 )
 {
-	DWORD cstat, ncl, scl, mcl = fs-&gt;max_clust;
+    DWORD cstat, ncl, scl, mcl = fs-&gt;max_clust;
 
 
-	if (clust == 0) {		/* Create new chain */
-		scl = fs-&gt;last_clust;			/* Get suggested start point */
-		if (scl == 0 || scl &gt;= mcl) scl = 1;
-	}
-	else {					/* Stretch existing chain */
-		cstat = get_cluster(fs, clust);	/* Check the cluster status */
-		if (cstat &lt; 2) return 1;		/* It is an invalid cluster */
-		if (cstat &lt; mcl) return cstat;	/* It is already followed by next cluster */
-		scl = clust;
-	}
+    if (clust == 0) {        /* Create new chain */
+        scl = fs-&gt;last_clust;            /* Get suggested start point */
+        if (scl == 0 || scl &gt;= mcl) scl = 1;
+    }
+    else {                    /* Stretch existing chain */
+        cstat = get_cluster(fs, clust);    /* Check the cluster status */
+        if (cstat &lt; 2) return 1;        /* It is an invalid cluster */
+        if (cstat &lt; mcl) return cstat;    /* It is already followed by next cluster */
+        scl = clust;
+    }
 
-	ncl = scl;				/* Start cluster */
-	for (;;) {
-		ncl++;							/* Next cluster */
-		if (ncl &gt;= mcl) {				/* Wrap around */
-			ncl = 2;
-			if (ncl &gt; scl) return 0;	/* No free custer */
-		}
-		cstat = get_cluster(fs, ncl);	/* Get the cluster status */
-		if (cstat == 0) break;			/* Found a free cluster */
-		if (cstat == 1) return 1;		/* Any error occured */
-		if (ncl == scl) return 0;		/* No free custer */
-	}
+    ncl = scl;                /* Start cluster */
+    for (;;) {
+        ncl++;                            /* Next cluster */
+        if (ncl &gt;= mcl) {                /* Wrap around */
+            ncl = 2;
+            if (ncl &gt; scl) return 0;    /* No free custer */
+        }
+        cstat = get_cluster(fs, ncl);    /* Get the cluster status */
+        if (cstat == 0) break;            /* Found a free cluster */
+        if (cstat == 1) return 1;        /* Any error occured */
+        if (ncl == scl) return 0;        /* No free custer */
+    }
 
-	if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;			/* Mark the new cluster &quot;in use&quot; */
-	if (clust != 0 &amp;&amp; !put_cluster(fs, clust, ncl)) return 1;	/* Link it to previous one if needed */
+    if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;        /* Mark the new cluster &quot;in use&quot; */
+    if (clust &amp;&amp; !put_cluster(fs, clust, ncl)) return 1;    /* Link it to previous one if needed */
 
-	fs-&gt;last_clust = ncl;				/* Update fsinfo */
-	if (fs-&gt;free_clust != 0xFFFFFFFF) {
-		fs-&gt;free_clust--;
+    fs-&gt;last_clust = ncl;                /* Update fsinfo */
+    if (fs-&gt;free_clust != 0xFFFFFFFF) {
+        fs-&gt;free_clust--;
 #if _USE_FSINFO
-		fs-&gt;fsi_flag = 1;
+        fs-&gt;fsi_flag = 1;
 #endif
-	}
+    }
 
-	return ncl;		/* Return new cluster number */
+    return ncl;        /* Return new cluster number */
 }
 #endif /* !_FS_READONLY */
 
@@ -336,14 +316,14 @@
 /*-----------------------------------------------------------------------*/
 
 static
-DWORD clust2sect (	/* !=0: sector number, 0: failed - invalid cluster# */
-	FATFS *fs,		/* File system object */
-	DWORD clust		/* Cluster# to be converted */
+DWORD clust2sect (    /* !=0: sector number, 0: failed - invalid cluster# */
+    FATFS *fs,        /* File system object */
+    DWORD clust        /* Cluster# to be converted */
 )
 {
-	clust -= 2;
-	if (clust &gt;= (fs-&gt;max_clust - 2)) return 0;		/* Invalid cluster# */
-	return clust * fs-&gt;csize + fs-&gt;database;
+    clust -= 2;
+    if (clust &gt;= (fs-&gt;max_clust - 2)) return 0;        /* Invalid cluster# */
+    return clust * fs-&gt;sects_clust + fs-&gt;database;
 }
 
 
@@ -354,31 +334,32 @@
 /*-----------------------------------------------------------------------*/
 
 static
-BOOL next_dir_entry (	/* TRUE: successful, FALSE: could not move next */
-	DIR *dj				/* Pointer to directory object */
+BOOL next_dir_entry (    /* TRUE: successful, FALSE: could not move next */
+    DIR *dirobj            /* Pointer to directory object */
 )
 {
-	DWORD clust;
-	WORD idx;
+    DWORD clust;
+    WORD idx;
+    FATFS *fs = dirobj-&gt;fs;
 
 
-	idx = dj-&gt;index + 1;
-	if ((idx &amp; ((SS(dj-&gt;fs) - 1) / 32)) == 0) {		/* Table sector changed? */
-		dj-&gt;sect++;				/* Next sector */
-		if (dj-&gt;clust == 0) {	/* In static table */
-			if (idx &gt;= dj-&gt;fs-&gt;n_rootdir) return FALSE;	/* Reached to end of table */
-		} else {					/* In dynamic table */
-			if (((idx / (SS(dj-&gt;fs) / 32)) &amp; (dj-&gt;fs-&gt;csize - 1)) == 0) {	/* Cluster changed? */
-				clust = get_cluster(dj-&gt;fs, dj-&gt;clust);			/* Get next cluster */
-				if (clust &lt; 2 || clust &gt;= dj-&gt;fs-&gt;max_clust)	/* Reached to end of table */
-					return FALSE;
-				dj-&gt;clust = clust;				/* Initialize for new cluster */
-				dj-&gt;sect = clust2sect(dj-&gt;fs, clust);
-			}
-		}
-	}
-	dj-&gt;index = idx;	/* Lower several bits of dj-&gt;index indicates offset in dj-&gt;sect */
-	return TRUE;
+    idx = dirobj-&gt;index + 1;
+    if ((idx &amp; ((S_SIZ - 1) / 32)) == 0) {        /* Table sector changed? */
+        dirobj-&gt;sect++;            /* Next sector */
+        if (!dirobj-&gt;clust) {        /* In static table */
+            if (idx &gt;= fs-&gt;n_rootdir) return FALSE;    /* Reached to end of table */
+        } else {                    /* In dynamic table */
+            if (((idx / (S_SIZ / 32)) &amp; (fs-&gt;sects_clust - 1)) == 0) {    /* Cluster changed? */
+                clust = get_cluster(fs, dirobj-&gt;clust);        /* Get next cluster */
+                if (clust &lt; 2 || clust &gt;= fs-&gt;max_clust)    /* Reached to end of table */
+                    return FALSE;
+                dirobj-&gt;clust = clust;                /* Initialize for new cluster */
+                dirobj-&gt;sect = clust2sect(fs, clust);
+            }
+        }
+    }
+    dirobj-&gt;index = idx;    /* Lower 4 bit of dirobj-&gt;index indicates offset in dirobj-&gt;sect */
+    return TRUE;
 }
 
 
@@ -390,39 +371,39 @@
 
 #if _FS_MINIMIZE &lt;= 1
 static
-void get_fileinfo (	/* No return code */
-	FILINFO *finfo, /* Ptr to store the file information */
-	const BYTE *dir	/* Ptr to the directory entry */
+void get_fileinfo (        /* No return code */
+    FILINFO *finfo,     /* Ptr to store the file information */
+    const BYTE *dir        /* Ptr to the directory entry */
 )
 {
-	BYTE n, c, a;
-	char *p;
+    BYTE n, c, a;
+    char *p;
 
 
-	p = &amp;finfo-&gt;fname[0];
-	a = _USE_NTFLAG ? dir[DIR_NTres] : 0;		/* NT flag */
-	for (n = 0; n &lt; 8; n++) {	/* Convert file name (body) */
-		c = dir[n];
-		if (c == ' ') break;
-		if (c == 0x05) c = 0xE5;
-		if (a &amp; 0x08 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z') c += 0x20;
-		*p++ = c;
-	}
-	if (dir[8] != ' ') {		/* Convert file name (extension) */
-		*p++ = '.';
-		for (n = 8; n &lt; 11; n++) {
-			c = dir[n];
-			if (c == ' ') break;
-			if (a &amp; 0x10 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z') c += 0x20;
-			*p++ = c;
-		}
-	}
-	*p = '\0';
+    p = &amp;finfo-&gt;fname[0];
+    a = _USE_NTFLAG ? dir[DIR_NTres] : 0;        /* NT flag */
+    for (n = 0; n &lt; 8; n++) {    /* Convert file name (body) */
+        c = dir[n];
+        if (c == ' ') break;
+        if (c == 0x05) c = 0xE5;
+        if (a &amp; 0x08 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z') c += 0x20;
+        *p++ = c;
+    }
+    if (dir[8] != ' ') {        /* Convert file name (extension) */
+        *p++ = '.';
+        for (n = 8; n &lt; 11; n++) {
+            c = dir[n];
+            if (c == ' ') break;
+            if (a &amp; 0x10 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z') c += 0x20;
+            *p++ = c;
+        }
+    }
+    *p = '\0';
 
-	finfo-&gt;fattrib = dir[DIR_Attr];					/* Attribute */
-	finfo-&gt;fsize = LD_DWORD(&amp;dir[DIR_FileSize]);	/* Size */
-	finfo-&gt;fdate = LD_WORD(&amp;dir[DIR_WrtDate]);		/* Date */
-	finfo-&gt;ftime = LD_WORD(&amp;dir[DIR_WrtTime]);		/* Time */
+    finfo-&gt;fattrib = dir[DIR_Attr];                    /* Attribute */
+    finfo-&gt;fsize = LD_DWORD(&amp;dir[DIR_FileSize]);    /* Size */
+    finfo-&gt;fdate = LD_WORD(&amp;dir[DIR_WrtDate]);        /* Date */
+    finfo-&gt;ftime = LD_WORD(&amp;dir[DIR_WrtTime]);        /* Time */
 }
 #endif /* _FS_MINIMIZE &lt;= 1 */
 
@@ -434,60 +415,60 @@
 /*-----------------------------------------------------------------------*/
 
 static
-char make_dirfile (		/* 1: error - detected an invalid format, '\0'or'/': next character */
-	const char **path,	/* Pointer to the file path pointer */
-	char *dirname		/* Pointer to directory name buffer {Name(8), Ext(3), NT flag(1)} */
+char make_dirfile (            /* 1: error - detected an invalid format, '\0'or'/': next character */
+    const char **path,        /* Pointer to the file path pointer */
+    char *dirname            /* Pointer to directory name buffer {Name(8), Ext(3), NT flag(1)} */
 )
 {
-	BYTE n, t, c, a, b;
+    BYTE n, t, c, a, b;
 
 
-	memset(dirname, ' ', 8+3);	/* Fill buffer with spaces */
-	a = 0; b = 0x18;	/* NT flag */
-	n = 0; t = 8;
-	for (;;) {
-		c = *(*path)++;
-		if (c == '\0' || c == '/') {		/* Reached to end of str or directory separator */
-			if (n == 0) break;
-			dirname[11] = _USE_NTFLAG ? (a &amp; b) : 0;
-			return c;
-		}
-		if (c &lt;= ' ' || c == 0x7F) break;		/* Reject invisible chars */
-		if (c == '.') {
-			if (!(a &amp; 1) &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 8) {	/* Enter extension part */
-				n = 8; t = 11; continue;
-			}
-			break;
-		}
-		if (_USE_SJIS &amp;&amp;
-			((c &gt;= 0x81 &amp;&amp; c &lt;= 0x9F) ||	/* Accept S-JIS code */
-		    (c &gt;= 0xE0 &amp;&amp; c &lt;= 0xFC))) {
-			if (n == 0 &amp;&amp; c == 0xE5)		/* Change heading \xE5 to \x05 */
-				c = 0x05;
-			a ^= 0x01; goto md_l2;
-		}
-		if (c == '&quot;') break;				/* Reject &quot; */
-		if (c &lt;= ')') goto md_l1;			/* Accept ! # $ % &amp; ' ( ) */
-		if (c &lt;= ',') break;				/* Reject * + , */
-		if (c &lt;= '9') goto md_l1;			/* Accept - 0-9 */
-		if (c &lt;= '?') break;				/* Reject : ; &lt; = &gt; ? */
-		if (!(a &amp; 1)) {	/* These checks are not applied to S-JIS 2nd byte */
-			if (c == '|') break;			/* Reject | */
-			if (c &gt;= '[' &amp;&amp; c &lt;= ']') break;/* Reject [ \ ] */
-			if (_USE_NTFLAG &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
-				(t == 8) ? (b &amp;= 0xF7) : (b &amp;= 0xEF);
-			if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {		/* Convert to upper case */
-				c -= 0x20;
-				if (_USE_NTFLAG) (t == 8) ? (a |= 0x08) : (a |= 0x10);
-			}
-		}
-	md_l1:
-		a &amp;= 0xFE;
-	md_l2:
-		if (n &gt;= t) break;
-		dirname[n++] = c;
-	}
-	return 1;
+    memset(dirname, ' ', 8+3);    /* Fill buffer with spaces */
+    a = 0; b = 0x18;    /* NT flag */
+    n = 0; t = 8;
+    for (;;) {
+        c = *(*path)++;
+        if (c == '\0' || c == '/') {        /* Reached to end of str or directory separator */
+            if (n == 0) break;
+            dirname[11] = _USE_NTFLAG ? (a &amp; b) : 0;
+            return c;
+        }
+        if (c &lt;= ' ' || c == 0x7F) break;        /* Reject invisible chars */
+        if (c == '.') {
+            if (!(a &amp; 1) &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 8) {    /* Enter extension part */
+                n = 8; t = 11; continue;
+            }
+            break;
+        }
+        if (_USE_SJIS &amp;&amp;
+            ((c &gt;= 0x81 &amp;&amp; c &lt;= 0x9F) ||    /* Accept S-JIS code */
+            (c &gt;= 0xE0 &amp;&amp; c &lt;= 0xFC))) {
+            if (n == 0 &amp;&amp; c == 0xE5)        /* Change heading \xE5 to \x05 */
+                c = 0x05;
+            a ^= 1; goto md_l2;
+        }
+        if (c == '&quot;') break;                /* Reject &quot; */
+        if (c &lt;= ')') goto md_l1;            /* Accept ! # $ % &amp; ' ( ) */
+        if (c &lt;= ',') break;                /* Reject * + , */
+        if (c &lt;= '9') goto md_l1;            /* Accept - 0-9 */
+        if (c &lt;= '?') break;                /* Reject : ; &lt; = &gt; ? */
+        if (!(a &amp; 1)) {    /* These checks are not applied to S-JIS 2nd byte */
+            if (c == '|') break;            /* Reject | */
+            if (c &gt;= '[' &amp;&amp; c &lt;= ']') break;/* Reject [ \ ] */
+            if (_USE_NTFLAG &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
+                (t == 8) ? (b &amp;= ~0x08) : (b &amp;= ~0x10);
+            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {        /* Convert to upper case */
+                c -= 0x20;
+                if (_USE_NTFLAG) (t == 8) ? (a |= 0x08) : (a |= 0x10);
+            }
+        }
+    md_l1:
+        a &amp;= ~1;
+    md_l2:
+        if (n &gt;= t) break;
+        dirname[n++] = c;
+    }
+    return 1;
 }
 
 
@@ -498,55 +479,55 @@
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT trace_path (	/* FR_OK(0): successful, !=0: error code */
-	DIR *dj,			/* Pointer to directory object to return last directory */
-	char *fn,			/* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
-	const char *path,	/* Full-path string to trace a file or directory */
-	BYTE **dir			/* Pointer to pointer to found entry to retutn */
+FRESULT trace_path (    /* FR_OK(0): successful, !=0: error code */
+    DIR *dirobj,        /* Pointer to directory object to return last directory */
+    char *fn,            /* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
+    const char *path,    /* Full-path string to trace a file or directory */
+    BYTE **dir            /* Directory pointer in Win[] to retutn */
 )
 {
-	DWORD clust;
-	char ds;
-	BYTE *dptr = NULL;
-	FATFS *fs = dj-&gt;fs;
+    DWORD clust;
+    char ds;
+    BYTE *dptr = NULL;
+    FATFS *fs = dirobj-&gt;fs;    /* Get logical drive from the given DIR structure */
 
 
-	/* Initialize directory object */
-	clust = fs-&gt;dirbase;
-	if (fs-&gt;fs_type == FS_FAT32) {
-		dj-&gt;clust = dj-&gt;sclust = clust;
-		dj-&gt;sect = clust2sect(fs, clust);
-	} else {
-		dj-&gt;clust = dj-&gt;sclust = 0;
-		dj-&gt;sect = clust;
-	}
-	dj-&gt;index = 0;
+    /* Initialize directory object */
+    clust = fs-&gt;dirbase;
+    if (fs-&gt;fs_type == FS_FAT32) {
+        dirobj-&gt;clust = dirobj-&gt;sclust = clust;
+        dirobj-&gt;sect = clust2sect(fs, clust);
+    } else {
+        dirobj-&gt;clust = dirobj-&gt;sclust = 0;
+        dirobj-&gt;sect = clust;
+    }
+    dirobj-&gt;index = 0;
 
-	if (*path == '\0') {					/* Null path means the root directory */
-		*dir = NULL; return FR_OK;
-	}
+    if (*path == '\0') {                    /* Null path means the root directory */
+        *dir = NULL; return FR_OK;
+    }
 
-	for (;;) {
-		ds = make_dirfile(&amp;path, fn);			/* Get a paragraph into fn[] */
-		if (ds == 1) return FR_INVALID_NAME;
-		for (;;) {
-			if (!move_window(fs, dj-&gt;sect)) return FR_RW_ERROR;
-			dptr = &amp;fs-&gt;win[(dj-&gt;index &amp; ((SS(fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
-			if (dptr[DIR_Name] == 0)						/* Has it reached to end of dir? */
-				return !ds ? FR_NO_FILE : FR_NO_PATH;
-			if (dptr[DIR_Name] != 0xE5						/* Matched? */
-				&amp;&amp; !(dptr[DIR_Attr] &amp; AM_VOL)
-				&amp;&amp; !memcmp(&amp;dptr[DIR_Name], fn, 8+3) ) break;
-			if (!next_dir_entry(dj))						/* Next directory pointer */
-				return !ds ? FR_NO_FILE : FR_NO_PATH;
-		}
-		if (!ds) { *dir = dptr; return FR_OK; }				/* Matched with end of path */
-		if (!(dptr[DIR_Attr] &amp; AM_DIR)) return FR_NO_PATH;	/* Cannot trace because it is a file */
-		clust = ((DWORD)LD_WORD(&amp;dptr[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
-		dj-&gt;clust = dj-&gt;sclust = clust;				/* Restart scanning at the new directory */
-		dj-&gt;sect = clust2sect(fs, clust);
-		dj-&gt;index = 2;
-	}
+    for (;;) {
+        ds = make_dirfile(&amp;path, fn);            /* Get a paragraph into fn[] */
+        if (ds == 1) return FR_INVALID_NAME;
+        for (;;) {
+            if (!move_window(fs, dirobj-&gt;sect)) return FR_RW_ERROR;
+            dptr = &amp;fs-&gt;win[(dirobj-&gt;index &amp; ((S_SIZ - 1) / 32)) * 32];    /* Pointer to the directory entry */
+            if (dptr[DIR_Name] == 0)                        /* Has it reached to end of dir? */
+                return !ds ? FR_NO_FILE : FR_NO_PATH;
+            if (dptr[DIR_Name] != 0xE5                        /* Matched? */
+                &amp;&amp; !(dptr[DIR_Attr] &amp; AM_VOL)
+                &amp;&amp; !memcmp(&amp;dptr[DIR_Name], fn, 8+3) ) break;
+            if (!next_dir_entry(dirobj))                    /* Next directory pointer */
+                return !ds ? FR_NO_FILE : FR_NO_PATH;
+        }
+        if (!ds) { *dir = dptr; return FR_OK; }                /* Matched with end of path */
+        if (!(dptr[DIR_Attr] &amp; AM_DIR)) return FR_NO_PATH;    /* Cannot trace because it is a file */
+        clust = ((DWORD)LD_WORD(&amp;dptr[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
+        dirobj-&gt;clust = dirobj-&gt;sclust = clust;                /* Restart scanning at the new directory */
+        dirobj-&gt;sect = clust2sect(fs, clust);
+        dirobj-&gt;index = 2;
+    }
 }
 
 
@@ -558,52 +539,50 @@
 
 #if !_FS_READONLY
 static
-FRESULT reserve_direntry (	/* FR_OK: successful, FR_DENIED: no free entry, FR_RW_ERROR: a disk error occured */
-	DIR *dj,				/* Target directory to create new entry */
-	BYTE **dir				/* Pointer to pointer to created entry to retutn */
+FRESULT reserve_direntry (    /* FR_OK: successful, FR_DENIED: no free entry, FR_RW_ERROR: a disk error occured */
+    DIR *dirobj,            /* Target directory to create new entry */
+    BYTE **dir                /* Pointer to pointer to created entry to retutn */
 )
 {
-	DWORD clust, sector;
-	BYTE c, n, *dptr;
-	FATFS *fs = dj-&gt;fs;
+    DWORD clust, sector;
+    BYTE c, n, *dptr;
+    FATFS *fs = dirobj-&gt;fs;
 
 
-	/* Re-initialize directory object */
-	clust = dj-&gt;sclust;
-	if (clust != 0) {	/* Dyanmic directory table */
-		dj-&gt;clust = clust;
-		dj-&gt;sect = clust2sect(fs, clust);
-	} else {			/* Static directory table */
-		dj-&gt;sect = fs-&gt;dirbase;
-	}
-	dj-&gt;index = 0;
+    /* Re-initialize directory object */
+    clust = dirobj-&gt;sclust;
+    if (clust) {    /* Dyanmic directory table */
+        dirobj-&gt;clust = clust;
+        dirobj-&gt;sect = clust2sect(fs, clust);
+    } else {        /* Static directory table */
+        dirobj-&gt;sect = fs-&gt;dirbase;
+    }
+    dirobj-&gt;index = 0;
 
-	do {
-		if (!move_window(fs, dj-&gt;sect)) return FR_RW_ERROR;
-		dptr = &amp;fs-&gt;win[(dj-&gt;index &amp; ((SS(dj-&gt;fs) - 1) / 32)) * 32];	/* Pointer to the directory entry */
-		c = dptr[DIR_Name];
-		if (c == 0 || c == 0xE5) {		/* Found an empty entry */
-			*dir = dptr; return FR_OK;
-		}
-	} while (next_dir_entry(dj));		/* Next directory pointer */
-	/* Reached to end of the directory table */
+    do {
+        if (!move_window(fs, dirobj-&gt;sect)) return FR_RW_ERROR;
+        dptr = &amp;fs-&gt;win[(dirobj-&gt;index &amp; ((S_SIZ - 1) / 32)) * 32];    /* Pointer to the directory entry */
+        c = dptr[DIR_Name];
+        if (c == 0 || c == 0xE5) {            /* Found an empty entry! */
+            *dir = dptr; return FR_OK;
+        }
+    } while (next_dir_entry(dirobj));                /* Next directory pointer */
+    /* Reached to end of the directory table */
 
-	/* Abort when it is a static table or could not stretch dynamic table */
-	if (clust == 0 || !(clust = create_chain(fs, dj-&gt;clust))) return FR_DENIED;
-	if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;
+    /* Abort when static table or could not stretch dynamic table */
+    if (!clust || !(clust = create_chain(fs, dirobj-&gt;clust))) return FR_DENIED;
+    if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;
 
-	/* Cleanup the expanded table */
-	fs-&gt;winsect = sector = clust2sect(fs, clust);
-	memset(fs-&gt;win, 0, SS(fs));
-	for (n = fs-&gt;csize; n; n--) {
-		if (disk_write(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
-			return FR_RW_ERROR;
-		sector++;
-	}
-	fs-&gt;winflag = 1;
-	*dir = fs-&gt;win;
-
-	return FR_OK;
+    fs-&gt;winsect = sector = clust2sect(fs, clust);        /* Cleanup the expanded table */
+    memset(fs-&gt;win, 0, S_SIZ);
+    for (n = fs-&gt;sects_clust; n; n--) {
+        if (disk_write(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
+            return FR_RW_ERROR;
+        sector++;
+    }
+    fs-&gt;winflag = 1;
+    *dir = fs-&gt;win;
+    return FR_OK;
 }
 #endif /* !_FS_READONLY */
 
@@ -611,26 +590,26 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Load boot record and check if it is an FAT boot record                */
+/* Load boot record and check if it is a FAT boot record                 */
 /*-----------------------------------------------------------------------*/
 
 static
-BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record or error */
-	FATFS *fs,	/* File system object */
-	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
+BYTE check_fs (        /* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record or error */
+    FATFS *fs,        /* File system object */
+    DWORD sect        /* Sector# (lba) to check if it is a FAT boot record or not */
 )
 {
-	if (disk_read(fs-&gt;drive, fs-&gt;win, sect, 1) != RES_OK)	/* Load boot record */
-		return 2;
-	if (LD_WORD(&amp;fs-&gt;win[BS_55AA]) != 0xAA55)				/* Check record signature (always placed at offset 510 even if the sector size is &gt;512) */
-		return 2;
+    if (disk_read(fs-&gt;drive, fs-&gt;win, sect, 1) != RES_OK)    /* Load boot record */
+        return 2;
+    if (LD_WORD(&amp;fs-&gt;win[BS_55AA]) != 0xAA55)                /* Check record signature (always offset 510) */
+        return 2;
 
-	if (!memcmp(&amp;fs-&gt;win[BS_FilSysType], &quot;FAT&quot;, 3))			/* Check FAT signature */
-		return 0;
-	if (!memcmp(&amp;fs-&gt;win[BS_FilSysType32], &quot;FAT32&quot;, 5) &amp;&amp; !(fs-&gt;win[BPB_ExtFlags] &amp; 0x80))
-		return 0;
+    if (!memcmp(&amp;fs-&gt;win[BS_FilSysType], &quot;FAT&quot;, 3))            /* Check FAT signature */
+        return 0;
+    if (!memcmp(&amp;fs-&gt;win[BS_FilSysType32], &quot;FAT32&quot;, 5) &amp;&amp; !(fs-&gt;win[BPB_ExtFlags] &amp; 0x80))
+        return 0;
 
-	return 1;
+    return 1;
 }
 
 
@@ -641,119 +620,118 @@
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
-	const char **path,	/* Pointer to pointer to the path name (drive number) */
-	FATFS **rfs,		/* Pointer to pointer to the found file system object */
-	BYTE chk_wp			/* !=0: Check media write protection for write access */
+FRESULT auto_mount (        /* FR_OK(0): successful, !=0: any error occured */
+    const char **path,        /* Pointer to pointer to the path name (drive number) */
+    FATFS **rfs,            /* Pointer to pointer to the found file system object */
+    BYTE chk_wp                /* !=0: Check media write protection for wrinting fuctions */
 )
 {
-	BYTE drv, fmt, *tbl;
-	DSTATUS stat;
-	DWORD bootsect, fatsize, totalsect, maxclust;
-	const char *p = *path;
-	FATFS *fs;
+    BYTE drv, fmt, *tbl;
+    DSTATUS stat;
+    DWORD bootsect, fatsize, totalsect, maxclust;
+    const char *p = *path;
+    FATFS *fs;
 
 
-	/* Get drive number from the path name */
-	while (*p == ' ') p++;		/* Strip leading spaces */
-	drv = p[0] - '0';			/* Is there a drive number? */
-	if (drv &lt;= 9 &amp;&amp; p[1] == ':')
-		p += 2;				/* Found a drive number, get and strip it */
-	else
-		drv = 0;			/* No drive number is given, use drive number 0 as default */
-	if (*p == '/') p++;		/* Strip heading slash */
-	*path = p;				/* Return pointer to the path name */
+    /* Get drive number from the path name */
+    while (*p == ' ') p++;        /* Strip leading spaces */
+    drv = p[0] - '0';            /* Is there a drive number? */
+    if (drv &lt;= 9 &amp;&amp; p[1] == ':')
+        p += 2;            /* Found a drive number, get and strip it */
+    else
+        drv = 0;        /* No drive number is given, select drive 0 in default */
+    if (*p == '/') p++;    /* Strip heading slash */
+    *path = p;            /* Return pointer to the path name */
 
-	/* Check if the drive number is valid or not */
-	if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;	/* Is the drive number valid? */
-	*rfs = fs = FatFs[drv];					/* Returen pointer to the corresponding file system object */
-	if (!fs) return FR_NOT_ENABLED;			/* Is the file system object registered? */
+    /* Check if the drive number is valid or not */
+    if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;    /* Is the drive number valid? */
+    if (!(fs = FatFs[drv])) return FR_NOT_ENABLED;    /* Is the file system object registered? */
+    *rfs = fs;            /* Returen pointer to the corresponding file system object */
 
-	if (fs-&gt;fs_type) {						/* If the logical drive has been mounted */
-		stat = disk_status(fs-&gt;drive);
-		if (!(stat &amp; STA_NOINIT)) {			/* and physical drive is kept initialized (has not been changed), */
+    /* Check if the logical drive has been mounted or not */
+    if (fs-&gt;fs_type) {
+        stat = disk_status(fs-&gt;drive);
+        if (!(stat &amp; STA_NOINIT)) {                /* If the physical drive is kept initialized */
 #if !_FS_READONLY
-			if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))	/* Check write protection if needed */
-				return FR_WRITE_PROTECTED;
+            if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))    /* Check write protection if needed */
+                return FR_WRITE_PROTECTED;
 #endif
-			return FR_OK;					/* The file system object is valid */
-		}
-	}
+            return FR_OK;                        /* The file system object is valid */
+        }
+    }
 
-	/* The logical drive must be re-mounted. Following code attempts to mount the logical drive */
+    /* The logical drive has not been mounted, following code attempts to mount the logical drive */
 
-	memset(fs, 0, sizeof(FATFS));		/* Clean-up the file system object */
-	fs-&gt;drive = LD2PD(drv);				/* Bind the logical drive and a physical drive */
-	stat = disk_initialize(fs-&gt;drive);	/* Initialize low level disk I/O layer */
-	if (stat &amp; STA_NOINIT)				/* Check if the drive is ready */
-		return FR_NOT_READY;
-#if S_MAX_SIZ &gt; 512						/* Get disk sector size if needed */
-	if (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;SS(fs)) != RES_OK || SS(fs) &gt; S_MAX_SIZ)
-		return FR_NO_FILESYSTEM;
+    memset(fs, 0, sizeof(FATFS));        /* Clean-up the file system object */
+    fs-&gt;drive = LD2PD(drv);                /* Bind the logical drive and a physical drive */
+    stat = disk_initialize(fs-&gt;drive);    /* Initialize low level disk I/O layer */
+    if (stat &amp; STA_NOINIT)                /* Check if the drive is ready */
+        return FR_NOT_READY;
+#if S_MAX_SIZ &gt; 512                        /* Check disk sector size */
+    if (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;S_SIZ) != RES_OK || S_SIZ &gt; S_MAX_SIZ)
+        return FR_NO_FILESYSTEM;
 #endif
 #if !_FS_READONLY
-	if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))	/* Check write protection if needed */
-		return FR_WRITE_PROTECTED;
+    if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))    /* Check write protection if needed */
+        return FR_WRITE_PROTECTED;
 #endif
-	/* Search FAT partition on the drive */
-	fmt = check_fs(fs, bootsect = 0);	/* Check sector 0 as an SFD format */
-	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
-		/* Check a partition listed in top of the partition table */
-		tbl = &amp;fs-&gt;win[MBR_Table + LD2PT(drv) * 16];	/* Partition table */
-		if (tbl[4]) {									/* Is the partition existing? */
-			bootsect = LD_DWORD(&amp;tbl[8]);				/* Partition offset in LBA */
-			fmt = check_fs(fs, bootsect);				/* Check the partition */
-		}
-	}
-	if (fmt || LD_WORD(&amp;fs-&gt;win[BPB_BytsPerSec]) != SS(fs))	/* No valid FAT patition is found */
-		return FR_NO_FILESYSTEM;
+    /* Search FAT partition on the drive */
+    fmt = check_fs(fs, bootsect = 0);    /* Check sector 0 as an SFD format */
+    if (fmt == 1) {                        /* Not a FAT boot record, it may be patitioned */
+        /* Check a partition listed in top of the partition table */
+        tbl = &amp;fs-&gt;win[MBR_Table + LD2PT(drv) * 16];    /* Partition table */
+        if (tbl[4]) {                                /* Is the partition existing? */
+            bootsect = LD_DWORD(&amp;tbl[8]);            /* Partition offset in LBA */
+            fmt = check_fs(fs, bootsect);            /* Check the partition */
+        }
+    }
+    if (fmt || LD_WORD(&amp;fs-&gt;win[BPB_BytsPerSec]) != S_SIZ)    /* No valid FAT patition is found */
+        return FR_NO_FILESYSTEM;
 
-	/* Initialize the file system object */
-	fatsize = LD_WORD(&amp;fs-&gt;win[BPB_FATSz16]);			/* Number of sectors per FAT */
-	if (!fatsize) fatsize = LD_DWORD(&amp;fs-&gt;win[BPB_FATSz32]);
-	fs-&gt;sects_fat = fatsize;
-	fs-&gt;n_fats = fs-&gt;win[BPB_NumFATs];					/* Number of FAT copies */
-	fatsize *= fs-&gt;n_fats;								/* (Number of sectors in FAT area) */
-	fs-&gt;fatbase = bootsect + LD_WORD(&amp;fs-&gt;win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
-	fs-&gt;csize = fs-&gt;win[BPB_SecPerClus];				/* Number of sectors per cluster */
-	fs-&gt;n_rootdir = LD_WORD(&amp;fs-&gt;win[BPB_RootEntCnt]);	/* Nmuber of root directory entries */
-	totalsect = LD_WORD(&amp;fs-&gt;win[BPB_TotSec16]);		/* Number of sectors on the file system */
-	if (!totalsect) totalsect = LD_DWORD(&amp;fs-&gt;win[BPB_TotSec32]);
-	fs-&gt;max_clust = maxclust = (totalsect				/* max_clust = Last cluster# + 1 */
-		- LD_WORD(&amp;fs-&gt;win[BPB_RsvdSecCnt]) - fatsize - fs-&gt;n_rootdir / (SS(fs)/32)
-		) / fs-&gt;csize + 2;
+    /* Initialize the file system object */
+    fatsize = LD_WORD(&amp;fs-&gt;win[BPB_FATSz16]);            /* Number of sectors per FAT */
+    if (!fatsize) fatsize = LD_DWORD(&amp;fs-&gt;win[BPB_FATSz32]);
+    fs-&gt;sects_fat = fatsize;
+    fs-&gt;n_fats = fs-&gt;win[BPB_NumFATs];                    /* Number of FAT copies */
+    fatsize *= fs-&gt;n_fats;                                /* (Number of sectors in FAT area) */
+    fs-&gt;fatbase = bootsect + LD_WORD(&amp;fs-&gt;win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
+    fs-&gt;sects_clust = fs-&gt;win[BPB_SecPerClus];            /* Number of sectors per cluster */
+    fs-&gt;n_rootdir = LD_WORD(&amp;fs-&gt;win[BPB_RootEntCnt]);    /* Nmuber of root directory entries */
+    totalsect = LD_WORD(&amp;fs-&gt;win[BPB_TotSec16]);        /* Number of sectors on the file system */
+    if (!totalsect) totalsect = LD_DWORD(&amp;fs-&gt;win[BPB_TotSec32]);
+    fs-&gt;max_clust = maxclust = (totalsect                /* Last cluster# + 1 */
+        - LD_WORD(&amp;fs-&gt;win[BPB_RsvdSecCnt]) - fatsize - fs-&gt;n_rootdir / (S_SIZ/32)
+        ) / fs-&gt;sects_clust + 2;
 
-	fmt = FS_FAT12;										/* Determine the FAT sub type */
-	if (maxclust &gt;= 0xFF7) fmt = FS_FAT16;
-	if (maxclust &gt;= 0xFFF7) fmt = FS_FAT32;
+    fmt = FS_FAT12;                                        /* Determine the FAT sub type */
+    if (maxclust &gt; 0xFF7) fmt = FS_FAT16;
+    if (maxclust &gt; 0xFFF7) fmt = FS_FAT32;
+    fs-&gt;fs_type = fmt;
 
-	if (fmt == FS_FAT32)
-		fs-&gt;dirbase = LD_DWORD(&amp;fs-&gt;win[BPB_RootClus]);	/* Root directory start cluster */
-	else
-		fs-&gt;dirbase = fs-&gt;fatbase + fatsize;			/* Root directory start sector (lba) */
-	fs-&gt;database = fs-&gt;fatbase + fatsize + fs-&gt;n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
+    if (fmt == FS_FAT32)
+        fs-&gt;dirbase = LD_DWORD(&amp;fs-&gt;win[BPB_RootClus]);    /* Root directory start cluster */
+    else
+        fs-&gt;dirbase = fs-&gt;fatbase + fatsize;            /* Root directory start sector (lba) */
+    fs-&gt;database = fs-&gt;fatbase + fatsize + fs-&gt;n_rootdir / (S_SIZ/32);    /* Data start sector (lba) */
 
 #if !_FS_READONLY
-	/* Initialize allocation information */
-	fs-&gt;free_clust = 0xFFFFFFFF;
+    fs-&gt;free_clust = 0xFFFFFFFF;
 #if _USE_FSINFO
-	/* Get fsinfo if needed */
-	if (fmt == FS_FAT32) {
-		fs-&gt;fsi_sector = bootsect + LD_WORD(&amp;fs-&gt;win[BPB_FSInfo]);
-		if (disk_read(fs-&gt;drive, fs-&gt;win, fs-&gt;fsi_sector, 1) == RES_OK &amp;&amp;
-			LD_WORD(&amp;fs-&gt;win[BS_55AA]) == 0xAA55 &amp;&amp;
-			LD_DWORD(&amp;fs-&gt;win[FSI_LeadSig]) == 0x41615252 &amp;&amp;
-			LD_DWORD(&amp;fs-&gt;win[FSI_StrucSig]) == 0x61417272) {
-			fs-&gt;last_clust = LD_DWORD(&amp;fs-&gt;win[FSI_Nxt_Free]);
-			fs-&gt;free_clust = LD_DWORD(&amp;fs-&gt;win[FSI_Free_Count]);
-		}
-	}
+    /* Load fsinfo sector if needed */
+    if (fmt == FS_FAT32) {
+        fs-&gt;fsi_sector = bootsect + LD_WORD(&amp;fs-&gt;win[BPB_FSInfo]);
+        if (disk_read(0, fs-&gt;win, fs-&gt;fsi_sector, 1) == RES_OK &amp;&amp;
+            LD_WORD(&amp;fs-&gt;win[BS_55AA]) == 0xAA55 &amp;&amp;
+            LD_DWORD(&amp;fs-&gt;win[FSI_LeadSig]) == 0x41615252 &amp;&amp;
+            LD_DWORD(&amp;fs-&gt;win[FSI_StrucSig]) == 0x61417272) {
+            fs-&gt;last_clust = LD_DWORD(&amp;fs-&gt;win[FSI_Nxt_Free]);
+            fs-&gt;free_clust = LD_DWORD(&amp;fs-&gt;win[FSI_Free_Count]);
+        }
+    }
 #endif
 #endif
-
-	fs-&gt;fs_type = fmt;			/* FAT syb-type */
-	fs-&gt;id = ++fsid;			/* File system mount ID */
-	return FR_OK;
+    fs-&gt;id = ++fsid;                                    /* File system mount ID */
+    return FR_OK;
 }
 
 
@@ -764,17 +742,17 @@
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT validate (		/* FR_OK(0): The object is valid, !=0: Invalid */
-	const FATFS *fs,	/* Pointer to the file system object */
-	WORD id				/* Member id of the target object to be checked */
+FRESULT validate (        /* FR_OK(0): The object is valid, !=0: Not valid */
+    const FATFS *fs,    /* Pointer to the file system object */
+    WORD id                /* id member of the target object to be checked */
 )
 {
-	if (!fs || !fs-&gt;fs_type || fs-&gt;id != id)
-		return FR_INVALID_OBJECT;
-	if (disk_status(fs-&gt;drive) &amp; STA_NOINIT)
-		return FR_NOT_READY;
+    if (!fs || fs-&gt;id != id)
+        return FR_INVALID_OBJECT;
+    if (disk_status(fs-&gt;drive) &amp; STA_NOINIT)
+        return FR_NOT_READY;
 
-	return FR_OK;
+    return FR_OK;
 }
 
 
@@ -793,18 +771,20 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_mount (
-	BYTE drv,		/* Logical drive number to be mounted/unmounted */
-	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
+    BYTE drv,        /* Logical drive number to be mounted/unmounted */
+    FATFS *fs        /* Pointer to new file system object (NULL for unmount)*/
 )
 {
-	if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
+    FATFS *fsobj;
 
-	if (FatFs[drv]) FatFs[drv]-&gt;fs_type = 0;	/* Clear old object */
 
-	FatFs[drv] = fs;			/* Register and clear new object */
-	if (fs) fs-&gt;fs_type = 0;
+    if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
+    fsobj = FatFs[drv];
+    FatFs[drv] = fs;
+    if (fsobj) memset(fsobj, 0, sizeof(FATFS));
+    if (fs) memset(fs, 0, sizeof(FATFS));
 
-	return FR_OK;
+    return FR_OK;
 }
 
 
@@ -815,88 +795,92 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_open (
-	FIL *fp,			/* Pointer to the blank file object */
-	const char *path,	/* Pointer to the file name */
-	BYTE mode			/* Access mode and file open mode flags */
+    FIL *fp,            /* Pointer to the blank file object */
+    const char *path,    /* Pointer to the file name */
+    BYTE mode            /* Access mode and file open mode flags */
 )
 {
-	FRESULT res;
-	DIR dj;
-	BYTE *dir;
-	char fn[8+3+1];
+    FRESULT res;
+    BYTE *dir;
+    DIR dirobj;
+    char fn[8+3+1];
+    FATFS *fs;
 
 
-	fp-&gt;fs = NULL;		/* Clear file object */
+    fp-&gt;fs = NULL;
 #if !_FS_READONLY
-	mode &amp;= (FA_READ|FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW);
-	res = auto_mount(&amp;path, &amp;dj.fs, (BYTE)(mode &amp; (FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)));
+    mode &amp;= (FA_READ|FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW);
+    res = auto_mount(&amp;path, &amp;fs, (BYTE)(mode &amp; (FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)));
 #else
-	mode &amp;= FA_READ;
-	res = auto_mount(&amp;path, &amp;dj.fs, 0);
+    mode &amp;= FA_READ;
+    res = auto_mount(&amp;path, &amp;fs, 0);
 #endif
-	if (res != FR_OK) return res;
-	res = trace_path(&amp;dj, fn, path, &amp;dir);	/* Trace the file path */
+    if (res != FR_OK) return res;
+    dirobj.fs = fs;
 
+    /* Trace the file path */
+    res = trace_path(&amp;dirobj, fn, path, &amp;dir);
 #if !_FS_READONLY
-	/* Create or Open a file */
-	if (mode &amp; (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)) {
-		DWORD ps, rs;
-		if (res != FR_OK) {		/* No file, create new */
-			if (res != FR_NO_FILE) return res;
-			res = reserve_direntry(&amp;dj, &amp;dir);
-			if (res != FR_OK) return res;
-			memset(dir, 0, 32);		/* Initialize the new entry with open name */
-			memcpy(&amp;dir[DIR_Name], fn, 8+3);
-			dir[DIR_NTres] = fn[11];
-			mode |= FA_CREATE_ALWAYS;
-		}
-		else {					/* Any object is already existing */
-			if (mode &amp; FA_CREATE_NEW)			/* Cannot create new */
-				return FR_EXIST;
-			if (!dir || (dir[DIR_Attr] &amp; (AM_RDO|AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
-				return FR_DENIED;
-			if (mode &amp; FA_CREATE_ALWAYS) {		/* Resize it to zero if needed */
-				rs = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);	/* Get start cluster */
-				ST_WORD(&amp;dir[DIR_FstClusHI], 0);	/* cluster = 0 */
-				ST_WORD(&amp;dir[DIR_FstClusLO], 0);
-				ST_DWORD(&amp;dir[DIR_FileSize], 0);	/* size = 0 */
-				dj.fs-&gt;winflag = 1;
-				ps = dj.fs-&gt;winsect;			/* Remove the cluster chain */
-				if (!remove_chain(dj.fs, rs) || !move_window(dj.fs, ps))
-					return FR_RW_ERROR;
-				dj.fs-&gt;last_clust = rs - 1;		/* Reuse the cluster hole */
-			}
-		}
-		if (mode &amp; FA_CREATE_ALWAYS) {
-			dir[DIR_Attr] = 0;					/* Reset attribute */
-			ps = get_fattime();
-			ST_DWORD(&amp;dir[DIR_CrtTime], ps);	/* Created time */
-			dj.fs-&gt;winflag = 1;
-			mode |= FA__WRITTEN;				/* Set file changed flag */
-		}
-	}
-	/* Open an existing file */
-	else {
+    /* Create or Open a file */
+    if (mode &amp; (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)) {
+        DWORD ps, rs;
+        if (res != FR_OK) {        /* No file, create new */
+            if (res != FR_NO_FILE) return res;
+            res = reserve_direntry(&amp;dirobj, &amp;dir);
+            if (res != FR_OK) return res;
+            memset(dir, 0, 32);                        /* Initialize the new entry with open name */
+            memcpy(&amp;dir[DIR_Name], fn, 8+3);
+            dir[DIR_NTres] = fn[11];
+            mode |= FA_CREATE_ALWAYS;
+        }
+        else {                    /* Any object is already existing */
+            if (mode &amp; FA_CREATE_NEW)            /* Cannot create new */
+                return FR_EXIST;
+            if (dir == NULL || (dir[DIR_Attr] &amp; (AM_RDO|AM_DIR)))    /* Cannot overwrite it (R/O or DIR) */
+                return FR_DENIED;
+            if (mode &amp; FA_CREATE_ALWAYS) {        /* Resize it to zero if needed */
+                rs = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);    /* Get start cluster */
+                ST_WORD(&amp;dir[DIR_FstClusHI], 0);    /* cluster = 0 */
+                ST_WORD(&amp;dir[DIR_FstClusLO], 0);
+                ST_DWORD(&amp;dir[DIR_FileSize], 0);    /* size = 0 */
+                fs-&gt;winflag = 1;
+                ps = fs-&gt;winsect;                /* Remove the cluster chain */
+                if (!remove_chain(fs, rs) || !move_window(fs, ps))
+                    return FR_RW_ERROR;
+                fs-&gt;last_clust = rs - 1;        /* Reuse the cluster hole */
+            }
+        }
+        if (mode &amp; FA_CREATE_ALWAYS) {
+            dir[DIR_Attr] = AM_ARC;                /* New attribute */
+            ps = get_fattime();
+            ST_DWORD(&amp;dir[DIR_WrtTime], ps);    /* Updated time */
+            ST_DWORD(&amp;dir[DIR_CrtTime], ps);    /* Created time */
+            fs-&gt;winflag = 1;
+        }
+    }
+    /* Open an existing file */
+    else {
 #endif /* !_FS_READONLY */
-		if (res != FR_OK) return res;			/* Trace failed */
-		if (!dir || (dir[DIR_Attr] &amp; AM_DIR))	/* It is a directory */
-			return FR_NO_FILE;
+        if (res != FR_OK) return res;        /* Trace failed */
+        if (dir == NULL || (dir[DIR_Attr] &amp; AM_DIR))    /* It is a directory */
+            return FR_NO_FILE;
 #if !_FS_READONLY
-		if ((mode &amp; FA_WRITE) &amp;&amp; (dir[DIR_Attr] &amp; AM_RDO)) /* R/O violation */
-			return FR_DENIED;
-	}
-	fp-&gt;dir_sect = dj.fs-&gt;winsect;		/* Pointer to the directory entry */
-	fp-&gt;dir_ptr = dir;
+        if ((mode &amp; FA_WRITE) &amp;&amp; (dir[DIR_Attr] &amp; AM_RDO)) /* R/O violation */
+            return FR_DENIED;
+    }
+
+    fp-&gt;dir_sect = fs-&gt;winsect;            /* Pointer to the directory entry */
+    fp-&gt;dir_ptr = dir;
 #endif
-	fp-&gt;flag = mode;					/* File access mode */
-	fp-&gt;org_clust =						/* File start cluster */
-		((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
-	fp-&gt;fsize = LD_DWORD(&amp;dir[DIR_FileSize]);	/* File size */
-	fp-&gt;fptr = 0; fp-&gt;csect = 255;		/* File pointer */
-	fp-&gt;curr_sect = 0;
-	fp-&gt;fs = dj.fs; fp-&gt;id = dj.fs-&gt;id;	/* Owner file system object of the file */
+    fp-&gt;flag = mode;                    /* File access mode */
+    fp-&gt;org_clust =                        /* File start cluster */
+        ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
+    fp-&gt;fsize = LD_DWORD(&amp;dir[DIR_FileSize]);    /* File size */
+    fp-&gt;fptr = 0;                        /* File ptr */
+    fp-&gt;sect_clust = 1;                    /* Sector counter */
+    fp-&gt;fs = fs; fp-&gt;id = fs-&gt;id;        /* Owner file system object of the file */
 
-	return FR_OK;
+    return FR_OK;
 }
 
 
@@ -907,71 +891,71 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_read (
-	FIL *fp, 		/* Pointer to the file object */
-	void *buff,		/* Pointer to data buffer */
-	UINT btr,		/* Number of bytes to read */
-	UINT *br		/* Pointer to number of bytes read */
+    FIL *fp,         /* Pointer to the file object */
+    void *buff,        /* Pointer to data buffer */
+    WORD btr,        /* Number of bytes to read */
+    WORD *br        /* Pointer to number of bytes read */
 )
 {
-	FRESULT res;
-	DWORD clust, sect, remain;
-	UINT rcnt, cc;
-	BYTE *rbuff = buff;
+    DWORD clust, sect, remain;
+    WORD rcnt;
+    BYTE cc, *rbuff = buff;
+    FRESULT res;
+    FATFS *fs = fp-&gt;fs;
 
 
-	*br = 0;
-	res = validate(fp-&gt;fs, fp-&gt;id);					/* Check validity of the object */
-	if (res != FR_OK) return res;
-	if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
-	if (!(fp-&gt;flag &amp; FA_READ)) return FR_DENIED;	/* Check access mode */
-	remain = fp-&gt;fsize - fp-&gt;fptr;
-	if (btr &gt; remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
+    *br = 0;
+    res = validate(fs, fp-&gt;id);                        /* Check validity of the object */
+    if (res) return res;
+    if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;    /* Check error flag */
+    if (!(fp-&gt;flag &amp; FA_READ)) return FR_DENIED;    /* Check access mode */
+    remain = fp-&gt;fsize - fp-&gt;fptr;
+    if (btr &gt; remain) btr = (WORD)remain;            /* Truncate read count by number of bytes left */
 
-	for ( ;  btr;									/* Repeat until all data transferred */
-		rbuff += rcnt, fp-&gt;fptr += rcnt, *br += rcnt, btr -= rcnt) {
-		if ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {			/* On the sector boundary? */
-			if (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {		/* On the cluster boundary? */
-				clust = (fp-&gt;fptr == 0) ?			/* On the top of the file? */
-					fp-&gt;org_clust : get_cluster(fp-&gt;fs, fp-&gt;curr_clust);
-				if (clust &lt; 2 || clust &gt;= fp-&gt;fs-&gt;max_clust) goto fr_error;
-				fp-&gt;curr_clust = clust;				/* Update current cluster */
-				fp-&gt;csect = 0;						/* Reset sector address in the cluster */
-			}
-			sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust) + fp-&gt;csect;	/* Get current sector */
-			cc = btr / SS(fp-&gt;fs);					/* When remaining bytes &gt;= sector size, */
-			if (cc) {								/* Read maximum contiguous sectors directly */
-				if (fp-&gt;csect + cc &gt; fp-&gt;fs-&gt;csize)	/* Clip at cluster boundary */
-					cc = fp-&gt;fs-&gt;csize - fp-&gt;csect;
-				if (disk_read(fp-&gt;fs-&gt;drive, rbuff, sect, (BYTE)cc) != RES_OK)
-					goto fr_error;
-				fp-&gt;csect += (BYTE)cc;				/* Next sector address in the cluster */
-				rcnt = SS(fp-&gt;fs) * cc;				/* Number of bytes transferred */
-				continue;
-			}
-			if (sect != fp-&gt;curr_sect) {			/* Is window offset changed? */
+    for ( ;  btr;                                    /* Repeat until all data transferred */
+        rbuff += rcnt, fp-&gt;fptr += rcnt, *br += rcnt, btr -= rcnt) {
+        if ((fp-&gt;fptr &amp; (S_SIZ - 1)) == 0) {        /* On the sector boundary */
+            if (--fp-&gt;sect_clust) {                    /* Decrement left sector counter */
+                sect = fp-&gt;curr_sect + 1;            /* Get current sector */
+            } else {                                /* On the cluster boundary, get next cluster */
+                clust = (fp-&gt;fptr == 0) ?
+                    fp-&gt;org_clust : get_cluster(fs, fp-&gt;curr_clust);
+                if (clust &lt; 2 || clust &gt;= fs-&gt;max_clust)
+                    goto fr_error;
+                fp-&gt;curr_clust = clust;                /* Current cluster */
+                sect = clust2sect(fs, clust);        /* Get current sector */
+                fp-&gt;sect_clust = fs-&gt;sects_clust;    /* Re-initialize the left sector counter */
+            }
 #if !_FS_READONLY
-				if (fp-&gt;flag &amp; FA__DIRTY) {			/* Write back file I/O buffer if needed */
-					if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-						goto fr_error;
-					fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
-				}
+            if (fp-&gt;flag &amp; FA__DIRTY) {                /* Flush file I/O buffer if needed */
+                if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
+                    goto fr_error;
+                fp-&gt;flag &amp;= ~FA__DIRTY;
+            }
 #endif
-				if (disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buffer, sect, 1) != RES_OK)	/* Fill file I/O buffer with file data */
-					goto fr_error;
-				fp-&gt;curr_sect = sect;
-			}
-			fp-&gt;csect++;							/* Next sector address in the cluster */
-		}
-		rcnt = SS(fp-&gt;fs) - (fp-&gt;fptr % SS(fp-&gt;fs));	/* Get partial sector from file I/O buffer */
-		if (rcnt &gt; btr) rcnt = btr;
-		memcpy(rbuff, &amp;fp-&gt;buffer[fp-&gt;fptr % SS(fp-&gt;fs)], rcnt);
-	}
+            fp-&gt;curr_sect = sect;                    /* Update current sector */
+            cc = btr / S_SIZ;                        /* When left bytes &gt;= S_SIZ, */
+            if (cc) {                                /* Read maximum contiguous sectors directly */
+                if (cc &gt; fp-&gt;sect_clust) cc = fp-&gt;sect_clust;
+                if (disk_read(fs-&gt;drive, rbuff, sect, cc) != RES_OK)
+                    goto fr_error;
+                fp-&gt;sect_clust -= cc - 1;
+                fp-&gt;curr_sect += cc - 1;
+                rcnt = cc * S_SIZ; continue;
+            }
+            if (disk_read(fs-&gt;drive, fp-&gt;buffer, sect, 1) != RES_OK)    /* Load the sector into file I/O buffer */
+                goto fr_error;
+        }
+        rcnt = S_SIZ - ((WORD)fp-&gt;fptr &amp; (S_SIZ - 1));                /* Copy fractional bytes from file I/O buffer */
+        if (rcnt &gt; btr) rcnt = btr;
+        memcpy(rbuff, &amp;fp-&gt;buffer[fp-&gt;fptr &amp; (S_SIZ - 1)], rcnt);
+    }
 
-	return FR_OK;
+    return FR_OK;
 
-fr_error:	/* Abort this file due to an unrecoverable error */
-	fp-&gt;flag |= FA__ERROR;
-	return FR_RW_ERROR;
+fr_error:    /* Abort this file due to an unrecoverable error */
+    fp-&gt;flag |= FA__ERROR;
+    return FR_RW_ERROR;
 }
 
 
@@ -983,120 +967,121 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_write (
-	FIL *fp,			/* Pointer to the file object */
-	const void *buff,	/* Pointer to the data to be written */
-	UINT btw,			/* Number of bytes to write */
-	UINT *bw			/* Pointer to number of bytes written */
+    FIL *fp,            /* Pointer to the file object */
+    const void *buff,    /* Pointer to the data to be written */
+    WORD btw,            /* Number of bytes to write */
+    WORD *bw            /* Pointer to number of bytes written */
 )
 {
-	FRESULT res;
-	DWORD clust, sect;
-	UINT wcnt, cc;
-	const BYTE *wbuff = buff;
+    DWORD clust, sect;
+    WORD wcnt;
+    BYTE cc;
+    FRESULT res;
+    const BYTE *wbuff = buff;
+    FATFS *fs = fp-&gt;fs;
 
 
-	*bw = 0;
-	res = validate(fp-&gt;fs, fp-&gt;id);					/* Check validity of the object */
-	if (res != FR_OK) return res;
-	if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
-	if (!(fp-&gt;flag &amp; FA_WRITE)) return FR_DENIED;	/* Check access mode */
-	if (fp-&gt;fsize + btw &lt; fp-&gt;fsize) return FR_OK;	/* File size cannot reach 4GB */
+    *bw = 0;
+    res = validate(fs, fp-&gt;id);                        /* Check validity of the object */
+    if (res) return res;
+    if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;    /* Check error flag */
+    if (!(fp-&gt;flag &amp; FA_WRITE)) return FR_DENIED;    /* Check access mode */
+    if (fp-&gt;fsize + btw &lt; fp-&gt;fsize) return FR_OK;    /* File size cannot reach 4GB */
 
-	for ( ;  btw;									/* Repeat until all data transferred */
-		wbuff += wcnt, fp-&gt;fptr += wcnt, *bw += wcnt, btw -= wcnt) {
-		if ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {			/* On the sector boundary? */
-			if (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {		/* On the cluster boundary? */
-				if (fp-&gt;fptr == 0) {				/* On the top of the file? */
-					clust = fp-&gt;org_clust;			/* Follow from the origin */
-					if (clust == 0)					/* When there is no cluster chain, */
-						fp-&gt;org_clust = clust = create_chain(fp-&gt;fs, 0);	/* Create a new cluster chain */
-				} else {							/* Middle or end of the file */
-					clust = create_chain(fp-&gt;fs, fp-&gt;curr_clust);			/* Trace or streach cluster chain */
-				}
-				if (clust == 0) break;				/* Could not allocate a new cluster (disk full) */
-				if (clust == 1 || clust &gt;= fp-&gt;fs-&gt;max_clust) goto fw_error;
-				fp-&gt;curr_clust = clust;				/* Update current cluster */
-				fp-&gt;csect = 0;						/* Reset sector address in the cluster */
-			}
-			sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust) + fp-&gt;csect;	/* Get current sector */
-			cc = btw / SS(fp-&gt;fs);					/* When remaining bytes &gt;= sector size, */
-			if (cc) {								/* Write maximum contiguous sectors directly */
-				if (fp-&gt;csect + cc &gt; fp-&gt;fs-&gt;csize)	/* Clip at cluster boundary */
-					cc = fp-&gt;fs-&gt;csize - fp-&gt;csect;
-				if (disk_write(fp-&gt;fs-&gt;drive, wbuff, sect, (BYTE)cc) != RES_OK)
-					goto fw_error;
-				fp-&gt;csect += (BYTE)cc;				/* Next sector address in the cluster */
-				wcnt = SS(fp-&gt;fs) * cc;				/* Number of bytes transferred */
-				continue;
-			}
-			if (sect != fp-&gt;curr_sect) {			/* Is window offset changed? */
-				if (fp-&gt;flag &amp; FA__DIRTY) {			/* Write back file I/O buffer if needed */
-					if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-						goto fw_error;
-					fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
-				}
-				if (fp-&gt;fptr &lt; fp-&gt;fsize &amp;&amp;  		/* Fill file I/O buffer with file data */
-					disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buffer, sect, 1) != RES_OK)
-						goto fw_error;
-				fp-&gt;curr_sect = sect;
-			}
-			fp-&gt;csect++;							/* Next sector address in the cluster */
-		}
-		wcnt = SS(fp-&gt;fs) - (fp-&gt;fptr % SS(fp-&gt;fs));	/* Put partial sector into file I/O buffer */
-		if (wcnt &gt; btw) wcnt = btw;
-		memcpy(&amp;fp-&gt;buffer[fp-&gt;fptr % SS(fp-&gt;fs)], wbuff, wcnt);
-		fp-&gt;flag |= FA__DIRTY;
-	}
+    for ( ;  btw;                                    /* Repeat until all data transferred */
+        wbuff += wcnt, fp-&gt;fptr += wcnt, *bw += wcnt, btw -= wcnt) {
+        if ((fp-&gt;fptr &amp; (S_SIZ - 1)) == 0) {        /* On the sector boundary */
+            if (--fp-&gt;sect_clust) {                    /* Decrement left sector counter */
+                sect = fp-&gt;curr_sect + 1;            /* Get current sector */
+            } else {                                /* On the cluster boundary, get next cluster */
+                if (fp-&gt;fptr == 0) {                /* Is top of the file */
+                    clust = fp-&gt;org_clust;
+                    if (clust == 0)                    /* No cluster is created yet */
+                        fp-&gt;org_clust = clust = create_chain(fs, 0);    /* Create a new cluster chain */
+                } else {                            /* Middle or end of file */
+                    clust = create_chain(fs, fp-&gt;curr_clust);            /* Trace or streach cluster chain */
+                }
+                if (clust == 0) break;                /* Disk full */
+                if (clust == 1 || clust &gt;= fs-&gt;max_clust) goto fw_error;
+                fp-&gt;curr_clust = clust;                /* Current cluster */
+                sect = clust2sect(fs, clust);        /* Get current sector */
+                fp-&gt;sect_clust = fs-&gt;sects_clust;    /* Re-initialize the left sector counter */
+            }
+            if (fp-&gt;flag &amp; FA__DIRTY) {                /* Flush file I/O buffer if needed */
+                if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
+                    goto fw_error;
+                fp-&gt;flag &amp;= ~FA__DIRTY;
+            }
+            fp-&gt;curr_sect = sect;                    /* Update current sector */
+            cc = btw / S_SIZ;                        /* When left bytes &gt;= S_SIZ, */
+            if (cc) {                                /* Write maximum contiguous sectors directly */
+                if (cc &gt; fp-&gt;sect_clust) cc = fp-&gt;sect_clust;
+                if (disk_write(fs-&gt;drive, wbuff, sect, cc) != RES_OK)
+                    goto fw_error;
+                fp-&gt;sect_clust -= cc - 1;
+                fp-&gt;curr_sect += cc - 1;
+                wcnt = cc * S_SIZ; continue;
+            }
+            if (fp-&gt;fptr &lt; fp-&gt;fsize &amp;&amp;              /* Fill sector buffer with file data if needed */
+                disk_read(fs-&gt;drive, fp-&gt;buffer, sect, 1) != RES_OK)
+                    goto fw_error;
+        }
+        wcnt = S_SIZ - ((WORD)fp-&gt;fptr &amp; (S_SIZ - 1));    /* Copy fractional bytes to file I/O buffer */
+        if (wcnt &gt; btw) wcnt = btw;
+        memcpy(&amp;fp-&gt;buffer[fp-&gt;fptr &amp; (S_SIZ - 1)], wbuff, wcnt);
+        fp-&gt;flag |= FA__DIRTY;
+    }
 
-	if (fp-&gt;fptr &gt; fp-&gt;fsize) fp-&gt;fsize = fp-&gt;fptr;	/* Update file size if needed */
-	fp-&gt;flag |= FA__WRITTEN;						/* Set file changed flag */
-	return FR_OK;
+    if (fp-&gt;fptr &gt; fp-&gt;fsize) fp-&gt;fsize = fp-&gt;fptr;    /* Update file size if needed */
+    fp-&gt;flag |= FA__WRITTEN;                        /* Set file changed flag */
+    return FR_OK;
 
-fw_error:	/* Abort this file due to an unrecoverable error */
-	fp-&gt;flag |= FA__ERROR;
-	return FR_RW_ERROR;
+fw_error:    /* Abort this file due to an unrecoverable error */
+    fp-&gt;flag |= FA__ERROR;
+    return FR_RW_ERROR;
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Synchronize the file object                                           */
+/* Synchronize between File and Disk                                     */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_sync (
-	FIL *fp		/* Pointer to the file object */
+    FIL *fp        /* Pointer to the file object */
 )
 {
-	FRESULT res;
-	DWORD tim;
-	BYTE *dir;
+    DWORD tim;
+    BYTE *dir;
+    FRESULT res;
+    FATFS *fs = fp-&gt;fs;
 
 
-	res = validate(fp-&gt;fs, fp-&gt;id);		/* Check validity of the object */
-	if (res == FR_OK) {
-		if (fp-&gt;flag &amp; FA__WRITTEN) {	/* Has the file been written? */
-			/* Write back data buffer if needed */
-			if (fp-&gt;flag &amp; FA__DIRTY) {
-				if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-					return FR_RW_ERROR;
-				fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
-			}
-			/* Update the directory entry */
-			if (!move_window(fp-&gt;fs, fp-&gt;dir_sect))
-				return FR_RW_ERROR;
-			dir = fp-&gt;dir_ptr;
-			dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
-			ST_DWORD(&amp;dir[DIR_FileSize], fp-&gt;fsize);		/* Update file size */
-			ST_WORD(&amp;dir[DIR_FstClusLO], fp-&gt;org_clust);	/* Update start cluster */
-			ST_WORD(&amp;dir[DIR_FstClusHI], fp-&gt;org_clust &gt;&gt; 16);
-			tim = get_fattime();					/* Updated time */
-			ST_DWORD(&amp;dir[DIR_WrtTime], tim);
-			fp-&gt;flag &amp;= (BYTE)~FA__WRITTEN;
-			res = sync(fp-&gt;fs);
-		}
-	}
-	return res;
+    res = validate(fs, fp-&gt;id);            /* Check validity of the object */
+    if (res == FR_OK) {
+        if (fp-&gt;flag &amp; FA__WRITTEN) {    /* Has the file been written? */
+            /* Write back data buffer if needed */
+            if (fp-&gt;flag &amp; FA__DIRTY) {
+                if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
+                    return FR_RW_ERROR;
+                fp-&gt;flag &amp;= ~FA__DIRTY;
+            }
+            /* Update the directory entry */
+            if (!move_window(fs, fp-&gt;dir_sect))
+                return FR_RW_ERROR;
+            dir = fp-&gt;dir_ptr;
+            dir[DIR_Attr] |= AM_ARC;                        /* Set archive bit */
+            ST_DWORD(&amp;dir[DIR_FileSize], fp-&gt;fsize);        /* Update file size */
+            ST_WORD(&amp;dir[DIR_FstClusLO], fp-&gt;org_clust);    /* Update start cluster */
+            ST_WORD(&amp;dir[DIR_FstClusHI], fp-&gt;org_clust &gt;&gt; 16);
+            tim = get_fattime();                    /* Updated time */
+            ST_DWORD(&amp;dir[DIR_WrtTime], tim);
+            fp-&gt;flag &amp;= ~FA__WRITTEN;
+            res = sync(fs);
+        }
+    }
+    return res;
 }
 
 #endif /* !_FS_READONLY */
@@ -1109,19 +1094,20 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_close (
-	FIL *fp		/* Pointer to the file object to be closed */
+    FIL *fp        /* Pointer to the file object to be closed */
 )
 {
-	FRESULT res;
+    FRESULT res;
 
 
 #if !_FS_READONLY
-	res = f_sync(fp);
+    res = f_sync(fp);
 #else
-	res = validate(fp-&gt;fs, fp-&gt;id);
+    res = validate(fp-&gt;fs, fp-&gt;id);
 #endif
-	if (res == FR_OK) fp-&gt;fs = NULL;
-	return res;
+    if (res == FR_OK)
+        fp-&gt;fs = NULL;
+    return res;
 }
 
 
@@ -1133,93 +1119,81 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_lseek (
-	FIL *fp,		/* Pointer to the file object */
-	DWORD ofs		/* File pointer from top of file */
+    FIL *fp,        /* Pointer to the file object */
+    DWORD ofs        /* File pointer from top of file */
 )
 {
-	FRESULT res;
-	DWORD clust, csize, nsect, ifptr;
+    DWORD clust, csize;
+    BYTE csect;
+    FRESULT res;
+    FATFS *fs = fp-&gt;fs;
 
 
-	res = validate(fp-&gt;fs, fp-&gt;id);		/* Check validity of the object */
-	if (res != FR_OK) return res;
-	if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;
-	if (ofs &gt; fp-&gt;fsize					/* In read-only mode, clip offset with the file size */
+    res = validate(fs, fp-&gt;id);            /* Check validity of the object */
+    if (res) return res;
+    if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;
 #if !_FS_READONLY
-		 &amp;&amp; !(fp-&gt;flag &amp; FA_WRITE)
+    if (fp-&gt;flag &amp; FA__DIRTY) {            /* Write-back dirty buffer if needed */
+        if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
+            goto fk_error;
+        fp-&gt;flag &amp;= ~FA__DIRTY;
+    }
+    if (ofs &gt; fp-&gt;fsize &amp;&amp; !(fp-&gt;flag &amp; FA_WRITE))
+#else
+    if (ofs &gt; fp-&gt;fsize)
 #endif
-		) ofs = fp-&gt;fsize;
+        ofs = fp-&gt;fsize;
+    fp-&gt;fptr = 0; fp-&gt;sect_clust = 1;        /* Set file R/W pointer to top of the file */
 
-	ifptr = fp-&gt;fptr;
-	fp-&gt;fptr = 0; fp-&gt;csect = 255;
-	nsect = 0;
-	if (ofs &gt; 0) {
-		csize = (DWORD)fp-&gt;fs-&gt;csize * SS(fp-&gt;fs);	/* Cluster size (byte) */
-		if (ifptr &gt; 0 &amp;&amp;
-			(ofs - 1) / csize &gt;= (ifptr - 1) / csize) {/* When seek to same or following cluster, */
-			fp-&gt;fptr = (ifptr - 1) &amp; ~(csize - 1);	/* start from the current cluster */
-			ofs -= fp-&gt;fptr;
-			clust = fp-&gt;curr_clust;
-		} else {									/* When seek to back cluster, */
-			clust = fp-&gt;org_clust;					/* start from the first cluster */
+    /* Move file R/W pointer if needed */
+    if (ofs) {
+        clust = fp-&gt;org_clust;    /* Get start cluster */
 #if !_FS_READONLY
-			if (clust == 0) {						/* If no cluster chain, create a new chain */
-				clust = create_chain(fp-&gt;fs, 0);
-				if (clust == 1) goto fk_error;
-				fp-&gt;org_clust = clust;
-			}
+        if (!clust) {            /* If the file does not have a cluster chain, create new cluster chain */
+            clust = create_chain(fs, 0);
+            if (clust == 1) goto fk_error;
+            fp-&gt;org_clust = clust;
+        }
 #endif
-			fp-&gt;curr_clust = clust;
-		}
-		if (clust != 0) {
-			while (ofs &gt; csize) {					/* Cluster following loop */
+        if (clust) {            /* If the file has a cluster chain, it can be followed */
+            csize = (DWORD)fs-&gt;sects_clust * S_SIZ;        /* Cluster size in unit of byte */
+            for (;;) {                                    /* Loop to skip leading clusters */
+                fp-&gt;curr_clust = clust;                    /* Update current cluster */
+                if (ofs &lt;= csize) break;
 #if !_FS_READONLY
-				if (fp-&gt;flag &amp; FA_WRITE) {			/* Check if in write mode or not */
-					clust = create_chain(fp-&gt;fs, clust);	/* Force streached if in write mode */
-					if (clust == 0) {				/* When disk gets full, clip file size */
-						ofs = csize; break;
-					}
-				} else
+                if (fp-&gt;flag &amp; FA_WRITE)                /* Check if in write mode or not */
+                    clust = create_chain(fs, clust);    /* Force streached if in write mode */
+                else
 #endif
-					clust = get_cluster(fp-&gt;fs, clust);	/* Follow cluster chain if not in write mode */
-				if (clust &lt; 2 || clust &gt;= fp-&gt;fs-&gt;max_clust) goto fk_error;
-				fp-&gt;curr_clust = clust;
-				fp-&gt;fptr += csize;
-				ofs -= csize;
-			}
-			fp-&gt;fptr += ofs;
-			fp-&gt;csect = (BYTE)(ofs / SS(fp-&gt;fs));	/* Sector offset in the cluster */
-			if (ofs &amp; (SS(fp-&gt;fs) - 1)) {
-				nsect = clust2sect(fp-&gt;fs, clust) + fp-&gt;csect;	/* Current sector */
-				fp-&gt;csect++;
-			}
-		}
-	}
-	if (nsect &amp;&amp; nsect != fp-&gt;curr_sect) {
+                    clust = get_cluster(fs, clust);        /* Only follow cluster chain if not in write mode */
+                if (clust == 0) {                        /* Stop if could not follow the cluster chain */
+                    ofs = csize; break;
+                }
+                if (clust == 1 || clust &gt;= fs-&gt;max_clust) goto fk_error;
+                fp-&gt;fptr += csize;                        /* Update R/W pointer */
+                ofs -= csize;
+            }
+            csect = (BYTE)((ofs - 1) / S_SIZ);            /* Sector offset in the cluster */
+            fp-&gt;curr_sect = clust2sect(fs, clust) + csect;    /* Current sector */
+            if ((ofs &amp; (S_SIZ - 1)) &amp;&amp;                    /* Load current sector if needed */
+                disk_read(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
+                goto fk_error;
+            fp-&gt;sect_clust = fs-&gt;sects_clust - csect;    /* Left sector counter in the cluster */
+            fp-&gt;fptr += ofs;                            /* Update file R/W pointer */
+        }
+    }
 #if !_FS_READONLY
-		if (fp-&gt;flag &amp; FA__DIRTY) {			/* Write-back dirty buffer if needed */
-			if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-				goto fk_error;
-			fp-&gt;flag &amp;= (BYTE)~FA__DIRTY;
-		}
+    if ((fp-&gt;flag &amp; FA_WRITE) &amp;&amp; fp-&gt;fptr &gt; fp-&gt;fsize) {    /* Set updated flag if in write mode */
+        fp-&gt;fsize = fp-&gt;fptr;
+        fp-&gt;flag |= FA__WRITTEN;
+    }
 #endif
-		if (disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buffer, nsect, 1) != RES_OK)
-			goto fk_error;
-		fp-&gt;curr_sect = nsect;
-	}
 
-#if !_FS_READONLY
-	if (fp-&gt;fptr &gt; fp-&gt;fsize) {			/* Set changed flag if the file was extended */
-		fp-&gt;fsize = fp-&gt;fptr;
-		fp-&gt;flag |= FA__WRITTEN;
-	}
-#endif
+    return FR_OK;
 
-	return FR_OK;
-
-fk_error:	/* Abort this file due to an unrecoverable error */
-	fp-&gt;flag |= FA__ERROR;
-	return FR_RW_ERROR;
+fk_error:    /* Abort this file due to an unrecoverable error */
+    fp-&gt;flag |= FA__ERROR;
+    return FR_RW_ERROR;
 }
 
 
@@ -1231,33 +1205,34 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_opendir (
-	DIR *dj,			/* Pointer to directory object to create */
-	const char *path	/* Pointer to the directory path */
+    DIR *dirobj,        /* Pointer to directory object to create */
+    const char *path    /* Pointer to the directory path */
 )
 {
-	FRESULT res;
-	BYTE *dir;
-	char fn[8+3+1];
+    BYTE *dir;
+    char fn[8+3+1];
+    FRESULT res;
+    FATFS *fs;
 
 
-	res = auto_mount(&amp;path, &amp;dj-&gt;fs, 0);
-	if (res == FR_OK) {
-		res = trace_path(dj, fn, path, &amp;dir);	/* Trace the directory path */
-		if (res == FR_OK) {						/* Trace completed */
-			if (dir) {							/* It is not the root dir */
-				if (dir[DIR_Attr] &amp; AM_DIR) {	/* The entry is a directory */
-					dj-&gt;clust = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
-					dj-&gt;sect = clust2sect(dj-&gt;fs, dj-&gt;clust);
-					dj-&gt;index = 2;
-				} else {						/* The entry is not a directory */
-					res = FR_NO_FILE;
-				}
-			}
-			dj-&gt;id = dj-&gt;fs-&gt;id;
-		}
-	}
+    res = auto_mount(&amp;path, &amp;fs, 0);
+    if (res != FR_OK) return res;
+    dirobj-&gt;fs = fs;
 
-	return res;
+    res = trace_path(dirobj, fn, path, &amp;dir);    /* Trace the directory path */
+    if (res == FR_OK) {                        /* Trace completed */
+        if (dir != NULL) {                    /* It is not the root dir */
+            if (dir[DIR_Attr] &amp; AM_DIR) {        /* The entry is a directory */
+                dirobj-&gt;clust = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
+                dirobj-&gt;sect = clust2sect(fs, dirobj-&gt;clust);
+                dirobj-&gt;index = 2;
+            } else {                        /* The entry is not a directory */
+                res = FR_NO_FILE;
+            }
+        }
+        dirobj-&gt;id = fs-&gt;id;
+    }
+    return res;
 }
 
 
@@ -1268,30 +1243,31 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_readdir (
-	DIR *dj,			/* Pointer to the directory object */
-	FILINFO *finfo		/* Pointer to file information to return */
+    DIR *dirobj,        /* Pointer to the directory object */
+    FILINFO *finfo        /* Pointer to file information to return */
 )
 {
-	BYTE *dir, c, res;
+    BYTE *dir, c, res;
+    FATFS *fs = dirobj-&gt;fs;
 
 
-	res = validate(dj-&gt;fs, dj-&gt;id);			/* Check validity of the object */
-	if (res != FR_OK) return res;
+    res = validate(fs, dirobj-&gt;id);            /* Check validity of the object */
+    if (res) return res;
 
-	finfo-&gt;fname[0] = 0;
-	while (dj-&gt;sect) {
-		if (!move_window(dj-&gt;fs, dj-&gt;sect))
-			return FR_RW_ERROR;
-		dir = &amp;dj-&gt;fs-&gt;win[(dj-&gt;index &amp; ((SS(dj-&gt;fs) - 1) &gt;&gt; 5)) * 32];	/* pointer to the directory entry */
-		c = dir[DIR_Name];
-		if (c == 0) break;							/* Has it reached to end of dir? */
-		if (c != 0xE5 &amp;&amp; !(dir[DIR_Attr] &amp; AM_VOL))	/* Is it a valid entry? */
-			get_fileinfo(finfo, dir);
-		if (!next_dir_entry(dj)) dj-&gt;sect = 0;		/* Next entry */
-		if (finfo-&gt;fname[0]) break;					/* Found valid entry */
-	}
+    finfo-&gt;fname[0] = 0;
+    while (dirobj-&gt;sect) {
+        if (!move_window(fs, dirobj-&gt;sect))
+            return FR_RW_ERROR;
+        dir = &amp;fs-&gt;win[(dirobj-&gt;index &amp; ((S_SIZ - 1) &gt;&gt; 5)) * 32];    /* pointer to the directory entry */
+        c = *dir;
+        if (c == 0) break;                                /* Has it reached to end of dir? */
+        if (c != 0xE5 &amp;&amp; !(dir[DIR_Attr] &amp; AM_VOL))        /* Is it a valid entry? */
+            get_fileinfo(finfo, dir);
+        if (!next_dir_entry(dirobj)) dirobj-&gt;sect = 0;    /* Next entry */
+        if (finfo-&gt;fname[0]) break;                        /* Found valid entry */
+    }
 
-	return FR_OK;
+    return FR_OK;
 }
 
 
@@ -1303,182 +1279,146 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_stat (
-	const char *path,	/* Pointer to the file path */
-	FILINFO *finfo		/* Pointer to file information to return */
+    const char *path,    /* Pointer to the file path */
+    FILINFO *finfo        /* Pointer to file information to return */
 )
 {
-	FRESULT res;
-	DIR dj;
-	BYTE *dir;
-	char fn[8+3+1];
+    BYTE *dir;
+    char fn[8+3+1];
+    FRESULT res;
+    DIR dirobj;
+    FATFS *fs;
 
 
-	res = auto_mount(&amp;path, &amp;dj.fs, 0);
-	if (res == FR_OK) {
-		res = trace_path(&amp;dj, fn, path, &amp;dir);	/* Trace the file path */
-		if (res == FR_OK) {						/* Trace completed */
-			if (dir)	/* Found an object */
-				get_fileinfo(finfo, dir);
-			else		/* It is root dir */
-				res = FR_INVALID_NAME;
-		}
-	}
+    res = auto_mount(&amp;path, &amp;fs, 0);
+    if (res != FR_OK) return res;
+    dirobj.fs = fs;
 
-	return res;
+    res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
+    if (res == FR_OK) {                            /* Trace completed */
+        if (dir)    /* Found an object */
+            get_fileinfo(finfo, dir);
+        else        /* It is root dir */
+            res = FR_INVALID_NAME;
+    }
+
+    return res;
 }
 
 
 
 #if !_FS_READONLY
 /*-----------------------------------------------------------------------*/
-/* Truncate File                                                         */
-/*-----------------------------------------------------------------------*/
-
-FRESULT f_truncate (
-	FIL *fp		/* Pointer to the file object */
-)
-{
-	FRESULT res;
-	DWORD ncl;
-
-
-	res = validate(fp-&gt;fs, fp-&gt;id);		/* Check validity of the object */
-	if (res != FR_OK) return res;
-	if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;	/* Check error flag */
-	if (!(fp-&gt;flag &amp; FA_WRITE)) return FR_DENIED;	/* Check access mode */
-
-	if (fp-&gt;fsize &gt; fp-&gt;fptr) {
-		fp-&gt;fsize = fp-&gt;fptr;	/* Set file size to current R/W point */
-		fp-&gt;flag |= FA__WRITTEN;
-		if (fp-&gt;fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
-			if (!remove_chain(fp-&gt;fs, fp-&gt;org_clust)) goto ft_error;
-			fp-&gt;org_clust = 0;
-		} else {				/* When truncate a part of the file, remove remaining clusters */
-			ncl = get_cluster(fp-&gt;fs, fp-&gt;curr_clust);
-			if (ncl &lt; 2) goto ft_error;
-			if (ncl &lt; fp-&gt;fs-&gt;max_clust) {
-				if (!put_cluster(fp-&gt;fs, fp-&gt;curr_clust, 0x0FFFFFFF)) goto ft_error;
-				if (!remove_chain(fp-&gt;fs, ncl)) goto ft_error;
-			}
-		}
-	}
-
-	return FR_OK;
-
-ft_error:	/* Abort this file due to an unrecoverable error */
-	fp-&gt;flag |= FA__ERROR;
-	return FR_RW_ERROR;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
 /* Get Number of Free Clusters                                           */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_getfree (
-	const char *drv,	/* Pointer to the logical drive number (root dir) */
-	DWORD *nclust,		/* Pointer to the variable to return number of free clusters */
-	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
+    const char *drv,    /* Logical drive number */
+    DWORD *nclust,        /* Pointer to the double word to return number of free clusters */
+    FATFS **fatfs        /* Pointer to pointer to the file system object to return */
 )
 {
-	FRESULT res;
-	DWORD n, clust, sect;
-	BYTE fat, f, *p;
+    DWORD n, clust, sect;
+    BYTE fat, f, *p;
+    FRESULT res;
+    FATFS *fs;
 
 
-	/* Get drive number */
-	res = auto_mount(&amp;drv, fatfs, 0);
-	if (res != FR_OK) return res;
+    /* Get drive number */
+    res = auto_mount(&amp;drv, &amp;fs, 0);
+    if (res != FR_OK) return res;
+    *fatfs = fs;
 
-	/* If number of free cluster is valid, return it without cluster scan. */
-	if ((*fatfs)-&gt;free_clust &lt;= (*fatfs)-&gt;max_clust - 2) {
-		*nclust = (*fatfs)-&gt;free_clust;
-		return FR_OK;
-	}
+    /* If number of free cluster is valid, return it without cluster scan. */
+    if (fs-&gt;free_clust &lt;= fs-&gt;max_clust - 2) {
+        *nclust = fs-&gt;free_clust;
+        return FR_OK;
+    }
 
-	/* Get number of free clusters */
-	fat = (*fatfs)-&gt;fs_type;
-	n = 0;
-	if (fat == FS_FAT12) {
-		clust = 2;
-		do {
-			if ((WORD)get_cluster(*fatfs, clust) == 0) n++;
-		} while (++clust &lt; (*fatfs)-&gt;max_clust);
-	} else {
-		clust = (*fatfs)-&gt;max_clust;
-		sect = (*fatfs)-&gt;fatbase;
-		f = 0; p = 0;
-		do {
-			if (!f) {
-				if (!move_window(*fatfs, sect++)) return FR_RW_ERROR;
-				p = (*fatfs)-&gt;win;
-			}
-			if (fat == FS_FAT16) {
-				if (LD_WORD(p) == 0) n++;
-				p += 2; f += 1;
-			} else {
-				if (LD_DWORD(p) == 0) n++;
-				p += 4; f += 2;
-			}
-		} while (--clust);
-	}
-	(*fatfs)-&gt;free_clust = n;
+    /* Count number of free clusters */
+    fat = fs-&gt;fs_type;
+    n = 0;
+    if (fat == FS_FAT12) {
+        clust = 2;
+        do {
+            if ((WORD)get_cluster(fs, clust) == 0) n++;
+        } while (++clust &lt; fs-&gt;max_clust);
+    } else {
+        clust = fs-&gt;max_clust;
+        sect = fs-&gt;fatbase;
+        f = 0; p = 0;
+        do {
+            if (!f) {
+                if (!move_window(fs, sect++)) return FR_RW_ERROR;
+                p = fs-&gt;win;
+            }
+            if (fat == FS_FAT16) {
+                if (LD_WORD(p) == 0) n++;
+                p += 2; f += 1;
+            } else {
+                if (LD_DWORD(p) == 0) n++;
+                p += 4; f += 2;
+            }
+        } while (--clust);
+    }
+    fs-&gt;free_clust = n;
 #if _USE_FSINFO
-	if (fat == FS_FAT32) (*fatfs)-&gt;fsi_flag = 1;
+    if (fat == FS_FAT32) fs-&gt;fsi_flag = 1;
 #endif
 
-	*nclust = n;
-	return FR_OK;
+    *nclust = n;
+    return FR_OK;
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Delete a File or Directory                                            */
+/* Delete a File or a Directory                                          */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_unlink (
-	const char *path		/* Pointer to the file or directory path */
+    const char *path            /* Pointer to the file or directory path */
 )
 {
-	FRESULT res;
-	DIR dj;
-	BYTE *dir, *sdir;
-	DWORD dclust, dsect;
-	char fn[8+3+1];
+    BYTE *dir, *sdir;
+    DWORD dclust, dsect;
+    char fn[8+3+1];
+    FRESULT res;
+    DIR dirobj;
+    FATFS *fs;
 
 
-	res = auto_mount(&amp;path, &amp;dj.fs, 1);
-	if (res != FR_OK) return res;
-	res = trace_path(&amp;dj, fn, path, &amp;dir);	/* Trace the file path */
-	if (res != FR_OK) return res;			/* Trace failed */
-	if (!dir) return FR_INVALID_NAME;		/* It is the root directory */
-	if (dir[DIR_Attr] &amp; AM_RDO) return FR_DENIED;	/* It is a R/O object */
-	dsect = dj.fs-&gt;winsect;
-	dclust = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
+    res = auto_mount(&amp;path, &amp;fs, 1);
+    if (res != FR_OK) return res;
+    dirobj.fs = fs;
 
-	if (dir[DIR_Attr] &amp; AM_DIR) {			/* It is a sub-directory */
-		dj.clust = dclust;					/* Check if the sub-dir is empty or not */
-		dj.sect = clust2sect(dj.fs, dclust);
-		dj.index = 2;
-		do {
-			if (!move_window(dj.fs, dj.sect)) return FR_RW_ERROR;
-			sdir = &amp;dj.fs-&gt;win[(dj.index &amp; ((SS(dj.fs) - 1) &gt;&gt; 5)) * 32];
-			if (sdir[DIR_Name] == 0) break;
-			if (sdir[DIR_Name] != 0xE5 &amp;&amp; !(sdir[DIR_Attr] &amp; AM_VOL))
-				return FR_DENIED;	/* The directory is not empty */
-		} while (next_dir_entry(&amp;dj));
-	}
+    res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
+    if (res != FR_OK) return res;                /* Trace failed */
+    if (dir == NULL) return FR_INVALID_NAME;    /* It is the root directory */
+    if (dir[DIR_Attr] &amp; AM_RDO) return FR_DENIED;    /* It is a R/O object */
+    dsect = fs-&gt;winsect;
+    dclust = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
 
-	if (!move_window(dj.fs, dsect)) return FR_RW_ERROR;	/* Mark the directory entry 'deleted' */
-	dir[DIR_Name] = 0xE5;
-	dj.fs-&gt;winflag = 1;
-	if (!remove_chain(dj.fs, dclust)) return FR_RW_ERROR;	/* Remove the cluster chain */
+    if (dir[DIR_Attr] &amp; AM_DIR) {                /* It is a sub-directory */
+        dirobj.clust = dclust;                    /* Check if the sub-dir is empty or not */
+        dirobj.sect = clust2sect(fs, dclust);
+        dirobj.index = 2;
+        do {
+            if (!move_window(fs, dirobj.sect)) return FR_RW_ERROR;
+            sdir = &amp;fs-&gt;win[(dirobj.index &amp; ((S_SIZ - 1) &gt;&gt; 5)) * 32];
+            if (sdir[DIR_Name] == 0) break;
+            if (sdir[DIR_Name] != 0xE5 &amp;&amp; !(sdir[DIR_Attr] &amp; AM_VOL))
+                return FR_DENIED;    /* The directory is not empty */
+        } while (next_dir_entry(&amp;dirobj));
+    }
 
-	return sync(dj.fs);
+    if (!move_window(fs, dsect)) return FR_RW_ERROR;    /* Mark the directory entry 'deleted' */
+    dir[DIR_Name] = 0xE5;
+    fs-&gt;winflag = 1;
+    if (!remove_chain(fs, dclust)) return FR_RW_ERROR;    /* Remove the cluster chain */
+
+    return sync(fs);
 }
 
 
@@ -1489,61 +1429,66 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_mkdir (
-	const char *path		/* Pointer to the directory path */
+    const char *path        /* Pointer to the directory path */
 )
 {
-	FRESULT res;
-	DIR dj;
-	BYTE *dir, *fw, n;
-	char fn[8+3+1];
-	DWORD sect, dsect, dclust, pclust, tim;
+    BYTE *dir, *fw, n;
+    char fn[8+3+1];
+    DWORD sect, dsect, dclust, pclust, tim;
+    FRESULT res;
+    DIR dirobj;
+    FATFS *fs;
 
 
-	res = auto_mount(&amp;path, &amp;dj.fs, 1);
-	if (res != FR_OK) return res;
-	res = trace_path(&amp;dj, fn, path, &amp;dir);	/* Trace the file path */
-	if (res == FR_OK) return FR_EXIST;		/* Any file or directory is already existing */
-	if (res != FR_NO_FILE) return res;
+    res = auto_mount(&amp;path, &amp;fs, 1);
+    if (res != FR_OK) return res;
+    dirobj.fs = fs;
 
-	res = reserve_direntry(&amp;dj, &amp;dir); 		/* Reserve a directory entry */
-	if (res != FR_OK) return res;
-	sect = dj.fs-&gt;winsect;
-	dclust = create_chain(dj.fs, 0);		/* Allocate a cluster for new directory table */
-	if (dclust == 1) return FR_RW_ERROR;
-	dsect = clust2sect(dj.fs, dclust);
-	if (!dsect) return FR_DENIED;
-	if (!move_window(dj.fs, dsect)) return FR_RW_ERROR;
+    res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
+    if (res == FR_OK) return FR_EXIST;            /* Any file or directory is already existing */
+    if (res != FR_NO_FILE) return res;
 
-	fw = dj.fs-&gt;win;
-	memset(fw, 0, SS(dj.fs));				/* Clear the new directory table */
-	for (n = 1; n &lt; dj.fs-&gt;csize; n++) {
-		if (disk_write(dj.fs-&gt;drive, fw, ++dsect, 1) != RES_OK)
-			return FR_RW_ERROR;
-	}
-	memset(&amp;fw[DIR_Name], ' ', 8+3);		/* Create &quot;.&quot; entry */
-	fw[DIR_Name] = '.';
-	fw[DIR_Attr] = AM_DIR;
-	tim = get_fattime();
-	ST_DWORD(&amp;fw[DIR_WrtTime], tim);
-	memcpy(&amp;fw[32], &amp;fw[0], 32); fw[33] = '.';	/* Create &quot;..&quot; entry */
-	ST_WORD(&amp;fw[   DIR_FstClusLO], dclust);
-	ST_WORD(&amp;fw[   DIR_FstClusHI], dclust &gt;&gt; 16);
-	pclust = dj.sclust;
-	if (dj.fs-&gt;fs_type == FS_FAT32 &amp;&amp; pclust == dj.fs-&gt;dirbase) pclust = 0;
-	ST_WORD(&amp;fw[32+DIR_FstClusLO], pclust);
-	ST_WORD(&amp;fw[32+DIR_FstClusHI], pclust &gt;&gt; 16);
-	dj.fs-&gt;winflag = 1;
+    res = reserve_direntry(&amp;dirobj, &amp;dir);         /* Reserve a directory entry */
+    if (res != FR_OK) return res;
+    sect = fs-&gt;winsect;
+    dclust = create_chain(fs, 0);                /* Allocate a cluster for new directory table */
+    if (dclust == 1) return FR_RW_ERROR;
+    dsect = clust2sect(fs, dclust);
+    if (!dsect) return FR_DENIED;
+    if (!move_window(fs, dsect)) return FR_RW_ERROR;
 
-	if (!move_window(dj.fs, sect)) return FR_RW_ERROR;
-	memset(&amp;dir[0], 0, 32);						/* Initialize the new entry */
-	memcpy(&amp;dir[DIR_Name], fn, 8+3);			/* Name */
-	dir[DIR_NTres] = fn[11];
-	dir[DIR_Attr] = AM_DIR;						/* Attribute */
-	ST_DWORD(&amp;dir[DIR_WrtTime], tim);			/* Crated time */
-	ST_WORD(&amp;dir[DIR_FstClusLO], dclust);		/* Table start cluster */
-	ST_WORD(&amp;dir[DIR_FstClusHI], dclust &gt;&gt; 16);
+    fw = fs-&gt;win;
+    memset(fw, 0, S_SIZ);                        /* Clear the new directory table */
+    for (n = 1; n &lt; fs-&gt;sects_clust; n++) {
+        if (disk_write(fs-&gt;drive, fw, ++dsect, 1) != RES_OK)
+            return FR_RW_ERROR;
+    }
+    memset(&amp;fw[DIR_Name], ' ', 8+3);            /* Create &quot;.&quot; entry */
+    fw[DIR_Name] = '.';
+    fw[DIR_Attr] = AM_DIR;
+    tim = get_fattime();
+    ST_DWORD(&amp;fw[DIR_WrtTime], tim);
+    memcpy(&amp;fw[32], &amp;fw[0], 32); fw[33] = '.';    /* Create &quot;..&quot; entry */
+    pclust = dirobj.sclust;
+#if _FAT32
+    ST_WORD(&amp;fw[   DIR_FstClusHI], dclust &gt;&gt; 16);
+    if (fs-&gt;fs_type == FS_FAT32 &amp;&amp; pclust == fs-&gt;dirbase) pclust = 0;
+    ST_WORD(&amp;fw[32+DIR_FstClusHI], pclust &gt;&gt; 16);
+#endif
+    ST_WORD(&amp;fw[   DIR_FstClusLO], dclust);
+    ST_WORD(&amp;fw[32+DIR_FstClusLO], pclust);
+    fs-&gt;winflag = 1;
 
-	return sync(dj.fs);
+    if (!move_window(fs, sect)) return FR_RW_ERROR;
+    memset(&amp;dir[0], 0, 32);                        /* Initialize the new entry */
+    memcpy(&amp;dir[DIR_Name], fn, 8+3);            /* Name */
+    dir[DIR_NTres] = fn[11];
+    dir[DIR_Attr] = AM_DIR;                        /* Attribute */
+    ST_DWORD(&amp;dir[DIR_WrtTime], tim);            /* Crated time */
+    ST_WORD(&amp;dir[DIR_FstClusLO], dclust);        /* Table start cluster */
+    ST_WORD(&amp;dir[DIR_FstClusHI], dclust &gt;&gt; 16);
+
+    return sync(fs);
 }
 
 
@@ -1554,483 +1499,279 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_chmod (
-	const char *path,	/* Pointer to the file path */
-	BYTE value,			/* Attribute bits */
-	BYTE mask			/* Attribute mask to change */
+    const char *path,    /* Pointer to the file path */
+    BYTE value,            /* Attribute bits */
+    BYTE mask            /* Attribute mask to change */
 )
 {
-	FRESULT res;
-	DIR dj;
-	BYTE *dir;
-	char fn[8+3+1];
+    FRESULT res;
+    BYTE *dir;
+    DIR dirobj;
+    char fn[8+3+1];
+    FATFS *fs;
 
 
-	res = auto_mount(&amp;path, &amp;dj.fs, 1);
-	if (res == FR_OK) {
-		res = trace_path(&amp;dj, fn, path, &amp;dir);	/* Trace the file path */
-		if (res == FR_OK) {				/* Trace completed */
-			if (!dir) {
-				res = FR_INVALID_NAME;	/* Root directory */
-			} else {
-				mask &amp;= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
-				dir[DIR_Attr] = (value &amp; mask) | (dir[DIR_Attr] &amp; (BYTE)~mask);	/* Apply attribute change */
-				res = sync(dj.fs);
-			}
-		}
-	}
-	return res;
+    res = auto_mount(&amp;path, &amp;fs, 1);
+    if (res == FR_OK) {
+        dirobj.fs = fs;
+        res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
+        if (res == FR_OK) {            /* Trace completed */
+            if (dir == NULL) {
+                res = FR_INVALID_NAME;
+            } else {
+                mask &amp;= AM_RDO|AM_HID|AM_SYS|AM_ARC;    /* Valid attribute mask */
+                dir[DIR_Attr] = (value &amp; mask) | (dir[DIR_Attr] &amp; (BYTE)~mask);    /* Apply attribute change */
+                res = sync(fs);
+            }
+        }
+    }
+    return res;
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Change Timestamp                                                      */
-/*-----------------------------------------------------------------------*/
-
-FRESULT f_utime (
-	const char *path,		/* Pointer to the file/directory name */
-	const FILINFO *finfo	/* Pointer to the timestamp to be set */
-)
-{
-	FRESULT res;
-	DIR dj;
-	BYTE *dir;
-	char fn[8+3+1];
-
-
-	res = auto_mount(&amp;path, &amp;dj.fs, 1);
-	if (res == FR_OK) {
-		res = trace_path(&amp;dj, fn, path, &amp;dir);	/* Trace the file path */
-		if (res == FR_OK) {				/* Trace completed */
-			if (!dir) {
-				res = FR_INVALID_NAME;	/* Root directory */
-			} else {
-				ST_WORD(&amp;dir[DIR_WrtTime], finfo-&gt;ftime);
-				ST_WORD(&amp;dir[DIR_WrtDate], finfo-&gt;fdate);
-				res = sync(dj.fs);
-			}
-		}
-	}
-	return res;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
 /* Rename File/Directory                                                 */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_rename (
-	const char *path_old,	/* Pointer to the old name */
-	const char *path_new	/* Pointer to the new name */
+    const char *path_old,    /* Pointer to the old name */
+    const char *path_new    /* Pointer to the new name */
 )
 {
-	FRESULT res;
-	DIR dj;
-	DWORD sect_old;
-	BYTE *dir_old, *dir_new, direntry[32-11];
-	char fn[8+3+1];
+    FRESULT res;
+    DWORD sect_old;
+    BYTE *dir_old, *dir_new, direntry[32-11];
+    DIR dirobj;
+    char fn[8+3+1];
+    FATFS *fs;
 
 
-	res = auto_mount(&amp;path_old, &amp;dj.fs, 1);
-	if (res != FR_OK) return res;
+    res = auto_mount(&amp;path_old, &amp;fs, 1);
+    if (res != FR_OK) return res;
+    dirobj.fs = fs;
 
-	res = trace_path(&amp;dj, fn, path_old, &amp;dir_old);	/* Check old object */
-	if (res != FR_OK) return res;				/* The old object is not found */
-	if (!dir_old) return FR_NO_FILE;
-	sect_old = dj.fs-&gt;winsect;					/* Save the object information */
-	memcpy(direntry, &amp;dir_old[DIR_Attr], 32-11);
+    res = trace_path(&amp;dirobj, fn, path_old, &amp;dir_old);    /* Check old object */
+    if (res != FR_OK) return res;            /* The old object is not found */
+    if (!dir_old) return FR_NO_FILE;
+    sect_old = fs-&gt;winsect;                    /* Save the object information */
+    memcpy(direntry, &amp;dir_old[DIR_Attr], 32-11);
 
-	res = trace_path(&amp;dj, fn, path_new, &amp;dir_new);	/* Check new object */
-	if (res == FR_OK) return FR_EXIST;			/* The new object name is already existing */
-	if (res != FR_NO_FILE) return res;			/* Is there no old name? */
-	res = reserve_direntry(&amp;dj, &amp;dir_new); 		/* Reserve a directory entry */
-	if (res != FR_OK) return res;
+    res = trace_path(&amp;dirobj, fn, path_new, &amp;dir_new);    /* Check new object */
+    if (res == FR_OK) return FR_EXIST;            /* The new object name is already existing */
+    if (res != FR_NO_FILE) return res;            /* Is there no old name? */
+    res = reserve_direntry(&amp;dirobj, &amp;dir_new);     /* Reserve a directory entry */
+    if (res != FR_OK) return res;
 
-	memcpy(&amp;dir_new[DIR_Attr], direntry, 32-11);	/* Create new entry */
-	memcpy(&amp;dir_new[DIR_Name], fn, 8+3);
-	dir_new[DIR_NTres] = fn[11];
-	dj.fs-&gt;winflag = 1;
+    memcpy(&amp;dir_new[DIR_Attr], direntry, 32-11);    /* Create new entry */
+    memcpy(&amp;dir_new[DIR_Name], fn, 8+3);
+    dir_new[DIR_NTres] = fn[11];
+    fs-&gt;winflag = 1;
 
-	if (!move_window(dj.fs, sect_old)) return FR_RW_ERROR;	/* Delete old entry */
-	dir_old[DIR_Name] = 0xE5;
+    if (!move_window(fs, sect_old)) return FR_RW_ERROR;    /* Remove old entry */
+    dir_old[DIR_Name] = 0xE5;
 
-	return sync(dj.fs);
+    return sync(fs);
 }
 
-#endif /* !_FS_READONLY */
-#endif /* _FS_MINIMIZE == 0 */
-#endif /* _FS_MINIMIZE &lt;= 1 */
-#endif /* _FS_MINIMIZE &lt;= 2 */
 
 
-
-#if _USE_MKFS &amp;&amp; !_FS_READONLY
+#if _USE_MKFS
 /*-----------------------------------------------------------------------*/
 /* Create File System on the Drive                                       */
 /*-----------------------------------------------------------------------*/
-#define N_ROOTDIR	512			/* Multiple of 32 and &lt;= 2048 */
-#define N_FATS		1			/* 1 or 2 */
-#define MAX_SECTOR	64000000UL	/* Maximum partition size */
-#define MIN_SECTOR	2000UL		/* Minimum partition size */
 
+#define N_ROOTDIR 512
+#define N_FATS 1
+#define MAX_SECTOR 64000000UL
+#define MIN_SECTOR 2000UL
+#define ERASE_BLK 32
 
 
 FRESULT f_mkfs (
-	BYTE drv,			/* Logical drive number */
-	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
-	WORD allocsize		/* Allocation unit size [bytes] */
+    BYTE drv,            /* Logical drive number */
+    BYTE partition,        /* Partitioning rule 0:FDISK, 1:SFD */
+    BYTE allocsize        /* Allocation unit size [sectors] */
 )
 {
-	BYTE fmt, m, *tbl;
-	DWORD b_part, b_fat, b_dir, b_data;		/* Area offset (LBA) */
-	DWORD n_part, n_rsv, n_fat, n_dir;		/* Area size */
-	DWORD n_clust, n;
-	FATFS *fs;
-	DSTATUS stat;
+    BYTE fmt, m, *tbl;
+    DWORD b_part, b_fat, b_dir, b_data;        /* Area offset (LBA) */
+    DWORD n_part, n_rsv, n_fat, n_dir;        /* Area size */
+    DWORD n_clust, n;
+    FATFS *fs;
+    DSTATUS stat;
 
 
-	/* Check validity of the parameters */
-	if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
-	if (partition &gt;= 2) return FR_MKFS_ABORTED;
-	for (n = 512; n &lt;= 32768U &amp;&amp; n != allocsize; n &lt;&lt;= 1);
-	if (n != allocsize) return FR_MKFS_ABORTED;
+    /* Check and mounted drive and clear work area */
+    if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
+    fs = FatFs[drv];
+    if (!fs) return FR_NOT_ENABLED;
+    memset(fs, 0, sizeof(FATFS));
+    drv = LD2PD(drv);
 
-	/* Check mounted drive and clear work area */
-	fs = FatFs[drv];
-	if (!fs) return FR_NOT_ENABLED;
-	fs-&gt;fs_type = 0;
-	drv = LD2PD(drv);
+    /* Check validity of the parameters */
+    for (n = 1; n &lt;= 64 &amp;&amp; allocsize != n; n &lt;&lt;= 1);
+    if (n &gt; 64 || partition &gt;= 2) return FR_MKFS_ABORTED;
 
-	/* Get disk statics */
-	stat = disk_initialize(drv);
-	if (stat &amp; STA_NOINIT) return FR_NOT_READY;
-	if (stat &amp; STA_PROTECT) return FR_WRITE_PROTECTED;
-	if (disk_ioctl(drv, GET_SECTOR_COUNT, &amp;n_part) != RES_OK || n_part &lt; MIN_SECTOR)
-		return FR_MKFS_ABORTED;
-	if (n_part &gt; MAX_SECTOR) n_part = MAX_SECTOR;
-	b_part = (!partition) ? 63 : 0;		/* Boot sector */
-	n_part -= b_part;
-#if S_MAX_SIZ &gt; 512						/* Check disk sector size */
-	if (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;SS(fs)) != RES_OK
-		|| SS(fs) &gt; S_MAX_SIZ
-		|| SS(fs) &gt; allocsize)
-		return FR_MKFS_ABORTED;
+    /* Get disk statics */
+    stat = disk_initialize(drv);
+    if (stat &amp; STA_NOINIT) return FR_NOT_READY;
+    if (stat &amp; STA_PROTECT) return FR_WRITE_PROTECTED;
+    if (disk_ioctl(drv, GET_SECTOR_COUNT, &amp;n_part) != RES_OK || n_part &lt; MIN_SECTOR)
+        return FR_MKFS_ABORTED;
+    if (n_part &gt; MAX_SECTOR) n_part = MAX_SECTOR;
+    b_part = (!partition) ? 63 : 0;
+    n_part -= b_part;
+#if S_MAX_SIZ &gt; 512                        /* Check disk sector size */
+    if (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;S_SIZ) != RES_OK
+        || S_SIZ &gt; S_MAX_SIZ
+        || (DWORD)S_SIZ * allocsize &gt; 32768U)
+        return FR_MKFS_ABORTED;
 #endif
-	allocsize /= SS(fs);		/* Number of sectors per cluster */
 
-	/* Pre-compute number of clusters and FAT type */
-	n_clust = n_part / allocsize;
-	fmt = FS_FAT12;
-	if (n_clust &gt;= 0xFF5) fmt = FS_FAT16;
-	if (n_clust &gt;= 0xFFF5) fmt = FS_FAT32;
+    /* Pre-compute number of clusters and FAT type */
+    n_clust = n_part / allocsize;
+    fmt = FS_FAT12;
+    if (n_clust &gt;= 0xFF7) fmt = FS_FAT16;
+    if (n_clust &gt;= 0xFFF7) fmt = FS_FAT32;
+    switch (fmt) {
+    case FS_FAT12:
+        n_fat = ((n_clust * 3 + 1) / 2 + 3 + S_SIZ - 1) / S_SIZ;
+        n_rsv = 1 + partition;
+        n_dir = N_ROOTDIR * 32 / S_SIZ;
+        break;
+    case FS_FAT16:
+        n_fat = ((n_clust * 2) + 4 + S_SIZ - 1) / S_SIZ;
+        n_rsv = 1 + partition;
+        n_dir = N_ROOTDIR * 32 / S_SIZ;
+        break;
+    default:
+        n_fat = ((n_clust * 4) + 8 + S_SIZ - 1) / S_SIZ;
+        n_rsv = 33 - partition;
+        n_dir = 0;
+    }
+    b_fat = b_part + n_rsv;            /* FATs start sector */
+    b_dir = b_fat + n_fat * N_FATS;    /* Directory start sector */
+    b_data = b_dir + n_dir;            /* Data start sector */
 
-	/* Determine offset and size of FAT structure */
-	switch (fmt) {
-	case FS_FAT12:
-		n_fat = ((n_clust * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
-		n_rsv = 1 + partition;
-		n_dir = N_ROOTDIR * 32 / SS(fs);
-		break;
-	case FS_FAT16:
-		n_fat = ((n_clust * 2) + 4 + SS(fs) - 1) / SS(fs);
-		n_rsv = 1 + partition;
-		n_dir = N_ROOTDIR * 32 / SS(fs);
-		break;
-	default:
-		n_fat = ((n_clust * 4) + 8 + SS(fs) - 1) / SS(fs);
-		n_rsv = 33 - partition;
-		n_dir = 0;
-	}
-	b_fat = b_part + n_rsv;			/* FATs start sector */
-	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
-	b_data = b_dir + n_dir;			/* Data start sector */
-
-	/* Align data start sector to erase block boundary (for flash memory media) */
-	if (disk_ioctl(drv, GET_BLOCK_SIZE, &amp;n) != RES_OK) return FR_MKFS_ABORTED;
-	n = (b_data + n - 1) &amp; ~(n - 1);
-	n_fat += (n - b_data) / N_FATS;
-	/* b_dir and b_data are no longer used below */
-
-	/* Determine number of cluster and final check of validity of the FAT type */
-	n_clust = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
-	if (   (fmt == FS_FAT16 &amp;&amp; n_clust &lt; 0xFF5)
-		|| (fmt == FS_FAT32 &amp;&amp; n_clust &lt; 0xFFF5))
-		return FR_MKFS_ABORTED;
-
-	/* Create partition table if needed */
-	if (!partition) {
-		DWORD n_disk = b_part + n_part;
-
-		tbl = &amp;fs-&gt;win[MBR_Table];
-		ST_DWORD(&amp;tbl[0], 0x00010180);	/* Partition start in CHS */
-		if (n_disk &lt; 63UL * 255 * 1024) {	/* Partition end in CHS */
-			n_disk = n_disk / 63 / 255;
-			tbl[7] = (BYTE)n_disk;
-			tbl[6] = (BYTE)((n_disk &gt;&gt; 2) | 63);
-		} else {
-			ST_WORD(&amp;tbl[6], 0xFFFF);
-		}
-		tbl[5] = 254;
-		if (fmt != FS_FAT32)			/* System ID */
-			tbl[4] = (n_part &lt; 0x10000) ? 0x04 : 0x06;
-		else
-			tbl[4] = 0x0c;
-		ST_DWORD(&amp;tbl[8], 63);			/* Partition start in LBA */
-		ST_DWORD(&amp;tbl[12], n_part);		/* Partition size in LBA */
-		ST_WORD(&amp;tbl[64], 0xAA55);		/* Signature */
-		if (disk_write(drv, fs-&gt;win, 0, 1) != RES_OK)
-			return FR_RW_ERROR;
-	}
-
-	/* Create boot record */
-	tbl = fs-&gt;win;								/* Clear buffer */
-	memset(tbl, 0, SS(fs));
-	ST_DWORD(&amp;tbl[BS_jmpBoot], 0x90FEEB);		/* Boot code (jmp $, nop) */
-	ST_WORD(&amp;tbl[BPB_BytsPerSec], SS(fs));		/* Sector size */
-	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
-	ST_WORD(&amp;tbl[BPB_RsvdSecCnt], n_rsv);		/* Reserved sectors */
-	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
-	ST_WORD(&amp;tbl[BPB_RootEntCnt], SS(fs) / 32 * n_dir); /* Number of rootdir entries */
-	if (n_part &lt; 0x10000) {						/* Number of total sectors */
-		ST_WORD(&amp;tbl[BPB_TotSec16], n_part);
-	} else {
-		ST_DWORD(&amp;tbl[BPB_TotSec32], n_part);
-	}
-	tbl[BPB_Media] = 0xF8;						/* Media descripter */
-	ST_WORD(&amp;tbl[BPB_SecPerTrk], 63);			/* Number of sectors per track */
-	ST_WORD(&amp;tbl[BPB_NumHeads], 255);			/* Number of heads */
-	ST_DWORD(&amp;tbl[BPB_HiddSec], b_part);		/* Hidden sectors */
-	n = get_fattime();							/* Use current time as a VSN */
-	if (fmt != FS_FAT32) {
-		ST_DWORD(&amp;tbl[BS_VolID], n);			/* Volume serial number */
-		ST_WORD(&amp;tbl[BPB_FATSz16], n_fat);		/* Number of secters per FAT */
-		tbl[BS_DrvNum] = 0x80;					/* Drive number */
-		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
-		memcpy(&amp;tbl[BS_VolLab], &quot;NO NAME    FAT     &quot;, 19);	/* Volume lavel, FAT signature */
-	} else {
-		ST_DWORD(&amp;tbl[BS_VolID32], n);			/* Volume serial number */
-		ST_DWORD(&amp;tbl[BPB_FATSz32], n_fat);		/* Number of secters per FAT */
-		ST_DWORD(&amp;tbl[BPB_RootClus], 2);		/* Root directory cluster (2) */
-		ST_WORD(&amp;tbl[BPB_FSInfo], 1);			/* FSInfo record (bs+1) */
-		ST_WORD(&amp;tbl[BPB_BkBootSec], 6);		/* Backup boot record (bs+6) */
-		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
-		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
-		memcpy(&amp;tbl[BS_VolLab32], &quot;NO NAME    FAT32   &quot;, 19);	/* Volume lavel, FAT signature */
-	}
-	ST_WORD(&amp;tbl[BS_55AA], 0xAA55);			/* Signature */
-	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
-		return FR_RW_ERROR;
-	if (fmt == FS_FAT32)
-		disk_write(drv, tbl, b_part+6, 1);
-
-	/* Initialize FAT area */
-	for (m = 0; m &lt; N_FATS; m++) {
-		memset(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
-		if (fmt != FS_FAT32) {
-			n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
-			ST_DWORD(&amp;tbl[0], n);			/* Reserve cluster #0-1 (FAT12/16) */
-		} else {
-			ST_DWORD(&amp;tbl[0], 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
-			ST_DWORD(&amp;tbl[4], 0xFFFFFFFF);
-			ST_DWORD(&amp;tbl[8], 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
-		}
-		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
-			return FR_RW_ERROR;
-		memset(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
-		for (n = 1; n &lt; n_fat; n++) {
-			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
-				return FR_RW_ERROR;
-		}
-	}
-
-	/* Initialize Root directory */
-	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
-	do {
-		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
-			return FR_RW_ERROR;
-	} while (--m);
-
-	/* Create FSInfo record if needed */
-	if (fmt == FS_FAT32) {
-		ST_WORD(&amp;tbl[BS_55AA], 0xAA55);
-		ST_DWORD(&amp;tbl[FSI_LeadSig], 0x41615252);
-		ST_DWORD(&amp;tbl[FSI_StrucSig], 0x61417272);
-		ST_DWORD(&amp;tbl[FSI_Free_Count], n_clust - 1);
-		ST_DWORD(&amp;tbl[FSI_Nxt_Free], 0xFFFFFFFF);
-		disk_write(drv, tbl, b_part+1, 1);
-		disk_write(drv, tbl, b_part+7, 1);
-	}
-
-	return (disk_ioctl(drv, CTRL_SYNC, NULL) == RES_OK) ? FR_OK : FR_RW_ERROR;
-}
-
-#endif /* _USE_MKFS &amp;&amp; !_FS_READONLY */
-
-
-
-
-#if _USE_STRFUNC &gt;= 1
-/*-----------------------------------------------------------------------*/
-/* Get a string from the file                                            */
-/*-----------------------------------------------------------------------*/
-char* fgets (
-	char* buff,	/* Pointer to the string buffer to read */
-	int len,	/* Size of string buffer */
-	FIL* fil	/* Pointer to the file object */
-)
-{
-	int i = 0;
-	char *p = buff;
-	UINT rc;
-
-
-	while (i &lt; len - 1) {			/* Read bytes until buffer gets filled */
-		f_read(fil, p, 1, &amp;rc);
-		if (rc != 1) break;			/* Break when no data to read */
-#if _USE_STRFUNC &gt;= 2
-		if (*p == '\r') continue;	/* Strip '\r' */
+#ifdef ERASE_BLK
+    /* Round up data start sector to erase block boundary */
+    n = (b_data + ERASE_BLK - 1) &amp; ~(ERASE_BLK - 1);
+    b_dir += n - b_data;
+    n_fat += (n - b_data) / N_FATS;
 #endif
-		i++;
-		if (*p++ == '\n') break;	/* Break when reached end of line */
-	}
-	*p = 0;
-	return i ? buff : 0;			/* When no data read (eof or error), return with error. */
-}
+    /* Determine number of cluster and final check of validity of the FAT type */
+    n_clust = (n_part - n_rsv - n_fat * 2 - n_dir) / allocsize;
+    if (   (fmt == FS_FAT16 &amp;&amp; n_clust &lt; 0xFF7)
+        || (fmt == FS_FAT32 &amp;&amp; n_clust &lt; 0xFFF7))
+        return FR_MKFS_ABORTED;
 
+    /* Create partition table if needed */
+    if (!partition) {
+        DWORD n_disk = b_part + n_part;
 
+        tbl = &amp;fs-&gt;win[MBR_Table];
+        ST_DWORD(&amp;tbl[0], 0x00010180);    /* Partition start in CHS */
+        if (n_disk &lt; 63UL * 255 * 1024) {    /* Partition end in CHS */
+            n_disk = n_disk / 63 / 255;
+            tbl[7] = (BYTE)n_disk;
+            tbl[6] = (BYTE)((n_disk &gt;&gt; 2) | 63);
+        } else {
+            ST_WORD(&amp;tbl[6], 0xFFFF);
+        }
+        tbl[5] = 254;
+        if (fmt != FS_FAT32)            /* System ID */
+            tbl[4] = (n_part &lt; 0x10000) ? 0x04 : 0x06;
+        else
+            tbl[4] = 0x0c;
+        ST_DWORD(&amp;tbl[8], 63);            /* Partition start in LBA */
+        ST_DWORD(&amp;tbl[12], n_part);        /* Partition size in LBA */
+        ST_WORD(&amp;tbl[64], 0xAA55);        /* Signature */
+        if (disk_write(drv, fs-&gt;win, 0, 1) != RES_OK)
+            return FR_RW_ERROR;
+    }
 
-#if !_FS_READONLY
-#include &lt;stdarg.h&gt;
-/*-----------------------------------------------------------------------*/
-/* Put a character to the file                                           */
-/*-----------------------------------------------------------------------*/
-int fputc (
-	int chr,	/* A character to be output */
-	FIL* fil	/* Ponter to the file object */
-)
-{
-	UINT bw;
-	char c;
+    /* Create boot record */
+    memset(tbl = fs-&gt;win, 0, S_SIZ);
+    ST_DWORD(&amp;tbl[BS_jmpBoot], 0x90FEEB);        /* Boot code (jmp $, nop) */
+    ST_WORD(&amp;tbl[BPB_BytsPerSec], S_SIZ);        /* Sector size */
+    tbl[BPB_SecPerClus] = (BYTE)allocsize;        /* Sectors per cluster */
+    ST_WORD(&amp;tbl[BPB_RsvdSecCnt], n_rsv);        /* Reserved sectors */
+    tbl[BPB_NumFATs] = N_FATS;                    /* Number of FATs */
+    ST_WORD(&amp;tbl[BPB_RootEntCnt], S_SIZ / 32 * n_dir); /* Number of rootdir entries */
+    if (n_part &lt; 0x10000) {                        /* Number of total sectors */
+        ST_WORD(&amp;tbl[BPB_TotSec16], n_part);
+    } else {
+        ST_DWORD(&amp;tbl[BPB_TotSec32], n_part);
+    }
+    tbl[BPB_Media] = 0xF8;                        /* Media descripter */
+    ST_WORD(&amp;tbl[BPB_SecPerTrk], 63);            /* Number of sectors per track */
+    ST_WORD(&amp;tbl[BPB_NumHeads], 255);            /* Number of heads */
+    ST_DWORD(&amp;tbl[BPB_HiddSec], b_part);        /* Hidden sectors */
+    if (fmt != FS_FAT32) {
+        ST_WORD(&amp;tbl[BPB_FATSz16], n_fat);        /* Number of secters per FAT */
+        tbl[BS_DrvNum] = 0x80;                    /* Drive number */
+        tbl[BS_BootSig] = 0x29;                    /* Extended boot signature */
+        memcpy(&amp;tbl[BS_VolLab], &quot;NO NAME    FAT     &quot;, 19);    /* Volume lavel, FAT signature */
+    } else {
+        ST_DWORD(&amp;tbl[BPB_FATSz32], n_fat);        /* Number of secters per FAT */
+        ST_DWORD(&amp;tbl[BPB_RootClus], 2);        /* Root directory cluster (2) */
+        ST_WORD(&amp;tbl[BPB_FSInfo], 1);            /* FSInfo record (bs+1) */
+        ST_WORD(&amp;tbl[BPB_BkBootSec], 6);        /* Backup boot record (bs+6) */
+        tbl[BS_DrvNum32] = 0x80;                /* Drive number */
+        tbl[BS_BootSig32] = 0x29;                /* Extended boot signature */
+        memcpy(&amp;tbl[BS_VolLab32], &quot;NO NAME    FAT32   &quot;, 19);    /* Volume lavel, FAT signature */
+    }
+    ST_WORD(&amp;tbl[BS_55AA], 0xAA55);            /* Signature */
+    if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
+        return FR_RW_ERROR;
+    if (fmt == FS_FAT32)
+        disk_write(drv, tbl, b_part+6, 1);
 
+    /* Initialize FAT area */
+    for (m = 0; m &lt; N_FATS; m++) {
+        memset(tbl, 0, S_SIZ);        /* 1st sector of the FAT  */
+        if (fmt != FS_FAT32) {
+            n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
+            ST_DWORD(&amp;tbl[0], n);            /* Reserve cluster #0-1 (FAT12/16) */
+        } else {
+            ST_DWORD(&amp;tbl[0], 0xFFFFFFF8);    /* Reserve cluster #0-1 (FAT32) */
+            ST_DWORD(&amp;tbl[4], 0xFFFFFFFF);
+            ST_DWORD(&amp;tbl[8], 0x0FFFFFFF);    /* Reserve cluster #2 for root dir */
+        }
+        if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
+            return FR_RW_ERROR;
+        memset(tbl, 0, S_SIZ);        /* Following FAT entries are filled by zero */
+        for (n = 1; n &lt; n_fat; n++) {
+            if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
+                return FR_RW_ERROR;
+        }
+    }
 
-#if _USE_STRFUNC &gt;= 2
-	if (chr == '\n') fputc ('\r', fil);	/* LF -&gt; CRLF conversion */
-#endif
-	if (!fil) {	/* Special value may be used to switch the destination to any other device */
-	/*	put_console(chr);	*/
-		return chr;
-	}
-	c = (char)chr;
-	f_write(fil, &amp;c, 1, &amp;bw);	/* Write a byte to the file */
-	return bw ? chr : EOF;		/* Return the resulut */
-}
+    /* Initialize Root directory */
+    for (m = 0; m &lt; 64; m++) {
+        if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
+            return FR_RW_ERROR;
+    }
 
+    /* Create FSInfo record if needed */
+    if (fmt == FS_FAT32) {
+        ST_WORD(&amp;tbl[BS_55AA], 0xAA55);
+        ST_DWORD(&amp;tbl[FSI_LeadSig], 0x41615252);
+        ST_DWORD(&amp;tbl[FSI_StrucSig], 0x61417272);
+        ST_DWORD(&amp;tbl[FSI_Free_Count], n_clust - 1);
+        ST_DWORD(&amp;tbl[FSI_Nxt_Free], 0xFFFFFFFF);
+        disk_write(drv, tbl, b_part+1, 1);
+        disk_write(drv, tbl, b_part+7, 1);
+    }
 
-
-
-/*-----------------------------------------------------------------------*/
-/* Put a string to the file                                              */
-/*-----------------------------------------------------------------------*/
-int fputs (
-	const char* str,	/* Pointer to the string to be output */
-	FIL* fil			/* Pointer to the file object */
-)
-{
-	int n;
-
-
-	for (n = 0; *str; str++, n++) {
-		if (fputc(*str, fil) == EOF) return EOF;
-	}
-	return n;
+    return (disk_ioctl(drv, CTRL_SYNC, NULL) == RES_OK) ? FR_OK : FR_RW_ERROR;
 }
 
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Put a formatted string to the file                                    */
-/*-----------------------------------------------------------------------*/
-int fprintf (
-	FIL* fil,			/* Pointer to the file object */
-	const char* str,	/* Pointer to the format string */
-	...					/* Optional arguments... */
-)
-{
-	va_list arp;
-	UCHAR c, f, r;
-	ULONG val;
-	char s[16];
-	int i, w, res, cc;
-
-
-	va_start(arp, str);
-
-	for (cc = res = 0; cc != EOF; res += cc) {
-		c = *str++;
-		if (c == 0) break;			/* End of string */
-		if (c != '%') {				/* Non escape cahracter */
-			cc = fputc(c, fil);
-			if (cc != EOF) cc = 1;
-			continue;
-		}
-		w = f = 0;
-		c = *str++;
-		if (c == '0') {				/* Flag: '0' padding */
-			f = 1; c = *str++;
-		}
-		while (c &gt;= '0' &amp;&amp; c &lt;= '9') {	/* Precision */
-			w = w * 10 + (c - '0');
-			c = *str++;
-		}
-		if (c == 'l') {				/* Prefix: Size is long int */
-			f |= 2; c = *str++;
-		}
-		if (c == 's') {				/* Type is string */
-			cc = fputs(va_arg(arp, char*), fil);
-			continue;
-		}
-		if (c == 'c') {				/* Type is character */
-			cc = fputc(va_arg(arp, char), fil);
-			if (cc != EOF) cc = 1;
-			continue;
-		}
-		r = 0;
-		if (c == 'd') r = 10;		/* Type is signed decimal */
-		if (c == 'u') r = 10;		/* Type is unsigned decimal */
-		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
-		if (r == 0) break;			/* Unknown type */
-		if (f &amp; 2) {				/* Get the value */
-			val = (ULONG)va_arg(arp, long);
-		} else {
-			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
-		}
-		/* Put numeral string */
-		if (c == 'd') {
-			if (val &gt;= 0x80000000) {
-				val = 0 - val;
-				f |= 4;
-			}
-		}
-		i = sizeof(s) - 1; s[i] = 0;
-		do {
-			c = (UCHAR)(val % r + '0');
-			if (c &gt; '9') c += 7;
-			s[--i] = c;
-			val /= r;
-		} while (i &amp;&amp; val);
-		if (i &amp;&amp; (f &amp; 4)) s[--i] = '-';
-		w = sizeof(s) - 1 - w;
-		while (i &amp;&amp; i &gt; w) s[--i] = (f &amp; 1) ? '0' : ' ';
-		cc = fputs(&amp;s[i], fil);
-	}
-
-	va_end(arp);
-	return (cc == EOF) ? cc : res;
-}
-
+#endif /* _USE_MKFS */
 #endif /* !_FS_READONLY */
-#endif /* _USE_STRFUNC &gt;= 1*/
+#endif /* _FS_MINIMIZE == 0 */
+#endif /* _FS_MINIMIZE &lt;= 1 */
+#endif /* _FS_MINIMIZE &lt;= 2 */
+

Modified: branches/eagle_mmc/src/fatfs/ff.h
===================================================================
--- branches/eagle_mmc/src/fatfs/ff.h	2009-03-25 23:29:27 UTC (rev 268)
+++ branches/eagle_mmc/src/fatfs/ff.h	2009-03-26 02:17:48 UTC (rev 269)
@@ -1,64 +1,61 @@
 /*--------------------------------------------------------------------------/
-/  FatFs - FAT file system module include file  R0.06        (C)ChaN, 2008
+/  FatFs - FAT file system module include file  R0.04b       (C)ChaN, 2007
 /---------------------------------------------------------------------------/
 / FatFs module is an experimenal project to implement FAT file system to
 / cheap microcontrollers. This is a free software and is opened for education,
 / research and development under license policy of following trems.
 /
-/  Copyright (C) 2008, ChaN, all right reserved.
+/  Copyright (C) 2007, ChaN, all right reserved.
 /
 / * The FatFs module is a free software and there is no warranty.
 / * You can use, modify and/or redistribute it for personal, non-profit or
-/   commercial use without any restriction under your responsibility.
+/   profit use without any restriction under your responsibility.
 / * Redistributions of source code must retain the above copyright notice.
 /
 /---------------------------------------------------------------------------*/
 
 #ifndef _FATFS
 
-#define _MCU_ENDIAN		1
+#define _MCU_ENDIAN        1
 /* The _MCU_ENDIAN defines which access method is used to the FAT structure.
 /  1: Enable word access.
 /  2: Disable word access and use byte-by-byte access instead.
 /  When the architectural byte order of the MCU is big-endian and/or address
-/  miss-aligned access results incorrect behavior, the _MCU_ENDIAN must be set to 2.
-/  If it is not the case, it can also be set to 1 for good code efficiency. */
+/  miss-aligned access is prohibited, the _MCU_ENDIAN must be set to 2.
+/  If it is not the case, it can be set to 1 for good code efficiency. */
 
-#define _FS_READONLY	0
+#define _FS_READONLY    0
 /* Setting _FS_READONLY to 1 defines read only configuration. This removes
-/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
-/  f_truncate and useless f_getfree. */
+/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename
+/  and useless f_getfree. */
 
-#define _FS_MINIMIZE	0
+#define _FS_MINIMIZE    0
 /* The _FS_MINIMIZE option defines minimization level to remove some functions.
 /  0: Full function.
-/  1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename are removed.
+/  1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod and f_rename are removed.
 /  2: f_opendir and f_readdir are removed in addition to level 1.
 /  3: f_lseek is removed in addition to level 2. */
 
-#define	_USE_STRFUNC	0
-/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
+#define _DRIVES        2
+/* Number of logical drives to be used. This affects the size of internal table. */
 
-#define	_USE_MKFS	0
+#define    _USE_MKFS    0
 /* When _USE_MKFS is set to 1 and _FS_READONLY is set to 0, f_mkfs function is
 /  enabled. */
 
-#define _DRIVES		2
-/* Number of logical drives to be used. This affects the size of internal table. */
-
-#define	_MULTI_PARTITION	0
+#define    _MULTI_PARTITION    0
 /* When _MULTI_PARTITION is set to 0, each logical drive is bound to same
 /  physical drive number and can mount only 1st primaly partition. When it is
 /  set to 1, each logical drive can mount a partition listed in Drives[]. */
 
-#define _USE_FSINFO	0
+#define _USE_FSINFO    0
 /* To enable FSInfo support on FAT32 volume, set _USE_FSINFO to 1. */
 
-#define	_USE_SJIS	1
+#define    _USE_SJIS    1
 /* When _USE_SJIS is set to 1, Shift-JIS code transparency is enabled, otherwise
 /  only US-ASCII(7bit) code can be accepted as file/directory name. */
 
-#define	_USE_NTFLAG	1
+#define    _USE_NTFLAG    1
 /* When _USE_NTFLAG is set to 1, upper/lower case of the file name is preserved.
 /  Note that the files are always accessed in case insensitive. */
 
@@ -68,104 +65,104 @@
 
 
 /* Definitions corresponds to multiple sector size (not tested) */
-#define	S_MAX_SIZ	512U			/* Do not change */
-#if S_MAX_SIZ &gt; 512U
-#define	SS(fs)	((fs)-&gt;s_size)
+#define    S_MAX_SIZ    512            /* Do not change */
+#if S_MAX_SIZ &gt; 512
+#define    S_SIZ    (fs-&gt;s_size)
 #else
-#define	SS(fs)	512U
+#define    S_SIZ    512
 #endif
 
 
 /* File system object structure */
 typedef struct _FATFS {
-	WORD	id;				/* File system mount ID */
-	WORD	n_rootdir;		/* Number of root directory entries */
-	DWORD	winsect;		/* Current sector appearing in the win[] */
-	DWORD	sects_fat;		/* Sectors per fat */
-	DWORD	max_clust;		/* Maximum cluster# + 1 */
-	DWORD	fatbase;		/* FAT start sector */
-	DWORD	dirbase;		/* Root directory start sector (cluster# for FAT32) */
-	DWORD	database;		/* Data start sector */
+    WORD    id;                /* File system mount ID */
+    WORD    n_rootdir;        /* Number of root directory entries */
+    DWORD    winsect;        /* Current sector appearing in the win[] */
+    DWORD    sects_fat;        /* Sectors per fat */
+    DWORD    max_clust;        /* Maximum cluster# + 1 */
+    DWORD    fatbase;        /* FAT start sector */
+    DWORD    dirbase;        /* Root directory start sector (cluster# for FAT32) */
+    DWORD    database;        /* Data start sector */
 #if !_FS_READONLY
-	DWORD	last_clust;		/* Last allocated cluster */
-	DWORD	free_clust;		/* Number of free clusters */
+    DWORD    last_clust;        /* Last allocated cluster */
+    DWORD    free_clust;        /* Number of free clusters */
 #if _USE_FSINFO
-	DWORD	fsi_sector;		/* fsinfo sector */
-	BYTE	fsi_flag;		/* fsinfo dirty flag (1:must be written back) */
-	BYTE	pad2;
+    DWORD    fsi_sector;        /* fsinfo sector */
+    BYTE    fsi_flag;        /* fsinfo dirty flag (1:must be written back) */
+    BYTE    pad2;
 #endif
 #endif
-	BYTE	fs_type;		/* FAT sub type */
-	BYTE	csize;			/* Number of sectors per cluster */
-#if S_MAX_SIZ &gt; 512U
-	WORD	s_size;			/* Sector size */
+    BYTE    fs_type;        /* FAT sub type */
+    BYTE    sects_clust;    /* Sectors per cluster */
+#if S_MAX_SIZ &gt; 512
+    WORD    s_size;            /* Sector size */
 #endif
-	BYTE	n_fats;			/* Number of FAT copies */
-	BYTE	drive;			/* Physical drive number */
-	BYTE	winflag;		/* win[] dirty flag (1:must be written back) */
-	BYTE	pad1;
-	BYTE	win[S_MAX_SIZ];	/* Disk access window for Directory/FAT */
+    BYTE    n_fats;            /* Number of FAT copies */
+    BYTE    drive;            /* Physical drive number */
+    BYTE    winflag;        /* win[] dirty flag (1:must be written back) */
+    BYTE    pad1;
+    BYTE    win[S_MAX_SIZ];    /* Disk access window for Directory/FAT */
 } FATFS;
 
 
 /* Directory object structure */
 typedef struct _DIR {
-	WORD	id;			/* Owner file system mount ID */
-	WORD	index;		/* Current index */
-	FATFS*	fs;			/* Pointer to the owner file system object */
-	DWORD	sclust;		/* Start cluster */
-	DWORD	clust;		/* Current cluster */
-	DWORD	sect;		/* Current sector */
+    WORD    id;            /* Owner file system mount ID */
+    WORD    index;        /* Current index */
+    FATFS*    fs;            /* Pointer to the owner file system object */
+    DWORD    sclust;        /* Start cluster */
+    DWORD    clust;        /* Current cluster */
+    DWORD    sect;        /* Current sector */
 } DIR;
 
 
 /* File object structure */
 typedef struct _FIL {
-	WORD	id;				/* Owner file system mount ID */
-	BYTE	flag;			/* File status flags */
-	BYTE	csect;			/* Sector address in the cluster */
-	FATFS*	fs;				/* Pointer to the owner file system object */
-	DWORD	fptr;			/* File R/W pointer */
-	DWORD	fsize;			/* File size */
-	DWORD	org_clust;		/* File start cluster */
-	DWORD	curr_clust;		/* Current cluster */
-	DWORD	curr_sect;		/* Current sector */
+    WORD    id;                /* Owner file system mount ID */
+    BYTE    flag;            /* File status flags */
+    BYTE    sect_clust;        /* Left sectors in cluster */
+    FATFS*    fs;                /* Pointer to the owner file system object */
+    DWORD    fptr;            /* File R/W pointer */
+    DWORD    fsize;            /* File size */
+    DWORD    org_clust;        /* File start cluster */
+    DWORD    curr_clust;        /* Current cluster */
+    DWORD    curr_sect;        /* Current sector */
 #if _FS_READONLY == 0
-	DWORD	dir_sect;		/* Sector containing the directory entry */
-	BYTE*	dir_ptr;		/* Ponter to the directory entry in the window */
+    DWORD    dir_sect;        /* Sector containing the directory entry */
+    BYTE*    dir_ptr;        /* Ponter to the directory entry in the window */
 #endif
-	BYTE	buffer[S_MAX_SIZ];	/* File R/W buffer */
+    BYTE    buffer[S_MAX_SIZ];    /* File R/W buffer */
 } FIL;
 
 
 /* File status structure */
 typedef struct _FILINFO {
-	DWORD fsize;			/* Size */
-	WORD fdate;				/* Date */
-	WORD ftime;				/* Time */
-	BYTE fattrib;			/* Attribute */
-	char fname[8+1+3+1];	/* Name (8.3 format) */
+    DWORD fsize;            /* Size */
+    WORD fdate;                /* Date */
+    WORD ftime;                /* Time */
+    BYTE fattrib;            /* Attribute */
+    char fname[8+1+3+1];    /* Name (8.3 format) */
 } FILINFO;
 
 
 
 /* Definitions corresponds to multi partition */
 
-#if _MULTI_PARTITION != 0	/* Multiple partition cfg */
+#if _MULTI_PARTITION != 0    /* Multiple partition cfg */
 
 typedef struct _PARTITION {
-	BYTE pd;	/* Physical drive # (0-255) */
-	BYTE pt;	/* Partition # (0-3) */
+    BYTE pd;    /* Physical drive # (0-255) */
+    BYTE pt;    /* Partition # (0-3) */
 } PARTITION;
 extern
-const PARTITION Drives[];			/* Logical drive# to physical location conversion table */
-#define LD2PD(drv) (Drives[drv].pd)	/* Get physical drive# */
-#define LD2PT(drv) (Drives[drv].pt)	/* Get partition# */
+const PARTITION Drives[];            /* Logical drive# to physical location conversion table */
+#define LD2PD(drv) (Drives[drv].pd)    /* Get physical drive# */
+#define LD2PT(drv) (Drives[drv].pt)    /* Get partition# */
 
-#else						/* Single partition cfg */
+#else                        /* Single partition cfg */
 
-#define LD2PD(drv) (drv)		/* Physical drive# is equal to logical drive# */
-#define LD2PT(drv) 0			/* Always mounts the 1st partition */
+#define LD2PD(drv) (drv)        /* Physical drive# is equal to logical drive# */
+#define LD2PT(drv) 0            /* Always mounts the 1st partition */
 
 #endif
 
@@ -173,20 +170,20 @@
 /* File function return code (FRESULT) */
 
 typedef enum {
-	FR_OK = 0,			/* 0 */
-	FR_NOT_READY,		/* 1 */
-	FR_NO_FILE,			/* 2 */
-	FR_NO_PATH,			/* 3 */
-	FR_INVALID_NAME,	/* 4 */
-	FR_INVALID_DRIVE,	/* 5 */
-	FR_DENIED,			/* 6 */
-	FR_EXIST,			/* 7 */
-	FR_RW_ERROR,		/* 8 */
-	FR_WRITE_PROTECTED,	/* 9 */
-	FR_NOT_ENABLED,		/* 10 */
-	FR_NO_FILESYSTEM,	/* 11 */
-	FR_INVALID_OBJECT,	/* 12 */
-	FR_MKFS_ABORTED		/* 13 */
+    FR_OK = 0,            /* 0 */
+    FR_NOT_READY,        /* 1 */
+    FR_NO_FILE,            /* 2 */
+    FR_NO_PATH,            /* 3 */
+    FR_INVALID_NAME,    /* 4 */
+    FR_INVALID_DRIVE,    /* 5 */
+    FR_DENIED,            /* 6 */
+    FR_EXIST,            /* 7 */
+    FR_RW_ERROR,        /* 8 */
+    FR_WRITE_PROTECTED,    /* 9 */
+    FR_NOT_ENABLED,        /* 10 */
+    FR_NO_FILESYSTEM,    /* 11 */
+    FR_INVALID_OBJECT,    /* 12 */
+    FR_MKFS_ABORTED        /* 13 */
 } FRESULT;
 
 
@@ -194,145 +191,138 @@
 /*-----------------------------------------------------*/
 /* FatFs module application interface                  */
 
-FRESULT f_mount (BYTE, FATFS*);						/* Mount/Unmount a logical drive */
-FRESULT f_open (FIL*, const char*, BYTE);			/* Open or create a file */
-FRESULT f_read (FIL*, void*, UINT, UINT*);			/* Read data from a file */
-FRESULT f_write (FIL*, const void*, UINT, UINT*);	/* Write data to a file */
-FRESULT f_lseek (FIL*, DWORD);						/* Move file pointer of a file object */
-FRESULT f_close (FIL*);								/* Close an open file object */
-FRESULT f_opendir (DIR*, const char*);				/* Open an existing directory */
-FRESULT f_readdir (DIR*, FILINFO*);					/* Read a directory item */
-FRESULT f_stat (const char*, FILINFO*);				/* Get file status */
-FRESULT f_getfree (const char*, DWORD*, FATFS**);	/* Get number of free clusters on the drive */
-FRESULT f_truncate (FIL*);							/* Truncate file */
-FRESULT f_sync (FIL*);								/* Flush cached data of a writing file */
-FRESULT f_unlink (const char*);						/* Delete an existing file or directory */
-FRESULT	f_mkdir (const char*);						/* Create a new directory */
-FRESULT f_chmod (const char*, BYTE, BYTE);			/* Change file/dir attriburte */
-FRESULT f_utime (const char*, const FILINFO*);		/* Change file/dir timestamp */
-FRESULT f_rename (const char*, const char*);		/* Rename/Move a file or directory */
-FRESULT f_mkfs (BYTE, BYTE, WORD);					/* Create a file system on the drive */
-#if _USE_STRFUNC
-#define feof(fp) ((fp)-&gt;fptr == (fp)-&gt;fsize)
-#define EOF -1
-int fputc (int, FIL*);								/* Put a character to the file */
-int fputs (const char*, FIL*);						/* Put a string to the file */
-int fprintf (FIL*, const char*, ...);				/* Put a formatted string to the file */
-char* fgets (char*, int, FIL*);						/* Get a string from the file */
-#endif
+FRESULT f_mount (BYTE, FATFS*);                        /* Mount/Unmount a logical drive */
+FRESULT f_open (FIL*, const char*, BYTE);            /* Open or create a file */
+FRESULT f_read (FIL*, void*, WORD, WORD*);            /* Read data from a file */
+FRESULT f_write (FIL*, const void*, WORD, WORD*);    /* Write data to a file */
+FRESULT f_lseek (FIL*, DWORD);                        /* Move file pointer of a file object */
+FRESULT f_close (FIL*);                                /* Close an open file object */
+FRESULT f_opendir (DIR*, const char*);                /* Open an existing directory */
+FRESULT f_readdir (DIR*, FILINFO*);                    /* Read a directory item */
+FRESULT f_stat (const char*, FILINFO*);                /* Get file status */
+FRESULT f_getfree (const char*, DWORD*, FATFS**);    /* Get number of free clusters on the drive */
+FRESULT f_sync (FIL*);                                /* Flush cached data of a writing file */
+FRESULT f_unlink (const char*);                        /* Delete an existing file or directory */
+FRESULT    f_mkdir (const char*);                        /* Create a new directory */
+FRESULT f_chmod (const char*, BYTE, BYTE);            /* Change file/dir attriburte */
+FRESULT f_rename (const char*, const char*);        /* Rename/Move a file or directory */
+FRESULT f_mkfs (BYTE, BYTE, BYTE);                    /* Create a file system on the drive */
 
+
 /* User defined function to give a current time to fatfs module */
 
-DWORD get_fattime (void);	/* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
-							/* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
+DWORD get_fattime (void);    /* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
+                            /* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
 
 
 
 /* File access control and file status flags (FIL.flag) */
 
-#define	FA_READ				0x01
-#define	FA_OPEN_EXISTING	0x00
+#define    FA_READ                0x01
+#define    FA_OPEN_EXISTING    0x00
 #if _FS_READONLY == 0
-#define	FA_WRITE			0x02
-#define	FA_CREATE_NEW		0x04
-#define	FA_CREATE_ALWAYS	0x08
-#define	FA_OPEN_ALWAYS		0x10
-#define FA__WRITTEN			0x20
-#define FA__DIRTY			0x40
+#define    FA_WRITE            0x02
+#define    FA_CREATE_NEW        0x04
+#define    FA_CREATE_ALWAYS    0x08
+#define    FA_OPEN_ALWAYS        0x10
+#define FA__WRITTEN            0x20
+#define FA__DIRTY            0x40
 #endif
-#define FA__ERROR			0x80
+#define FA__ERROR            0x80
 
 
 /* FAT sub type (FATFS.fs_type) */
 
-#define FS_FAT12	1
-#define FS_FAT16	2
-#define FS_FAT32	3
+#define FS_FAT12    1
+#define FS_FAT16    2
+#define FS_FAT32    3
 
 
 /* File attribute bits for directory entry */
 
-#define	AM_RDO	0x01	/* Read only */
-#define	AM_HID	0x02	/* Hidden */
-#define	AM_SYS	0x04	/* System */
-#define	AM_VOL	0x08	/* Volume label */
-#define AM_LFN	0x0F	/* LFN entry */
-#define AM_DIR	0x10	/* Directory */
-#define AM_ARC	0x20	/* Archive */
+#define    AM_RDO    0x01    /* Read only */
+#define    AM_HID    0x02    /* Hidden */
+#define    AM_SYS    0x04    /* System */
+#define    AM_VOL    0x08    /* Volume label */
+#define AM_LFN    0x0F    /* LFN entry */
+#define AM_DIR    0x10    /* Directory */
+#define AM_ARC    0x20    /* Archive */
 
 
 
 /* Offset of FAT structure members */
 
-#define BS_jmpBoot			0
-#define BS_OEMName			3
-#define BPB_BytsPerSec		11
-#define BPB_SecPerClus		13
-#define BPB_RsvdSecCnt		14
-#define BPB_NumFATs			16
-#define BPB_RootEntCnt		17
-#define BPB_TotSec16		19
-#define BPB_Media			21
-#define BPB_FATSz16			22
-#define BPB_SecPerTrk		24
-#define BPB_NumHeads		26
-#define BPB_HiddSec			28
-#define BPB_TotSec32		32
-#define BS_55AA				510
+#define BS_jmpBoot            0
+#define BS_OEMName            3
+#define BPB_BytsPerSec        11
+#define BPB_SecPerClus        13
+#define BPB_RsvdSecCnt        14
+#define BPB_NumFATs            16
+#define BPB_RootEntCnt        17
+#define BPB_TotSec16        19
+#define BPB_Media            21
+#define BPB_FATSz16            22
+#define BPB_SecPerTrk        24
+#define BPB_NumHeads        26
+#define BPB_HiddSec            28
+#define BPB_TotSec32        32
+#define BS_55AA                510
 
-#define BS_DrvNum			36
-#define BS_BootSig			38
-#define BS_VolID			39
-#define BS_VolLab			43
-#define BS_FilSysType		54
+#define BS_DrvNum            36
+#define BS_BootSig            38
+#define BS_VolID            39
+#define BS_VolLab            43
+#define BS_FilSysType        54
 
-#define BPB_FATSz32			36
-#define BPB_ExtFlags		40
-#define BPB_FSVer			42
-#define BPB_RootClus		44
-#define BPB_FSInfo			48
-#define BPB_BkBootSec		50
-#define BS_DrvNum32			64
-#define BS_BootSig32		66
-#define BS_VolID32			67
-#define BS_VolLab32			71
-#define BS_FilSysType32		82
+#define BPB_FATSz32            36
+#define BPB_ExtFlags        40
+#define BPB_FSVer            42
+#define BPB_RootClus        44
+#define BPB_FSInfo            48
+#define BPB_BkBootSec        50
+#define BS_DrvNum32            64
+#define BS_BootSig32        66
+#define BS_VolID32            67
+#define BS_VolLab32            71
+#define BS_FilSysType32        82
 
-#define	FSI_LeadSig			0
-#define	FSI_StrucSig		484
-#define	FSI_Free_Count		488
-#define	FSI_Nxt_Free		492
+#define    FSI_LeadSig            0
+#define    FSI_StrucSig        484
+#define    FSI_Free_Count        488
+#define    FSI_Nxt_Free        492
 
-#define MBR_Table			446
+#define MBR_Table            446
 
-#define	DIR_Name			0
-#define	DIR_Attr			11
-#define	DIR_NTres			12
-#define	DIR_CrtTime			14
-#define	DIR_CrtDate			16
-#define	DIR_FstClusHI		20
-#define	DIR_WrtTime			22
-#define	DIR_WrtDate			24
-#define	DIR_FstClusLO		26
-#define	DIR_FileSize		28
+#define    DIR_Name            0
+#define    DIR_Attr            11
+#define    DIR_NTres            12
+#define    DIR_CrtTime            14
+#define    DIR_CrtDate            16
+#define    DIR_FstClusHI        20
+#define    DIR_WrtTime            22
+#define    DIR_WrtDate            24
+#define    DIR_FstClusLO        26
+#define    DIR_FileSize        28
 
 
 
 /* Multi-byte word access macros  */
 
-#if _MCU_ENDIAN == 1	/* Use word access */
-#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
-#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
-#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
-#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
-#elif _MCU_ENDIAN == 2	/* Use byte-by-byte access */
-#define	LD_WORD(ptr)		(WORD)(((WORD)*(volatile BYTE*)((ptr)+1)&lt;&lt;8)|(WORD)*(volatile BYTE*)(ptr))
-#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*(volatile BYTE*)((ptr)+3)&lt;&lt;24)|((DWORD)*(volatile BYTE*)((ptr)+2)&lt;&lt;16)|((WORD)*(volatile BYTE*)((ptr)+1)&lt;&lt;8)|*(volatile BYTE*)(ptr))
-#define	ST_WORD(ptr,val)	*(volatile BYTE*)(ptr)=(BYTE)(val); *(volatile BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8)
-#define	ST_DWORD(ptr,val)	*(volatile BYTE*)(ptr)=(BYTE)(val); *(volatile BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8); *(volatile BYTE*)((ptr)+2)=(BYTE)((DWORD)(val)&gt;&gt;16); *(volatile BYTE*)((ptr)+3)=(BYTE)((DWORD)(val)&gt;&gt;24)
+#if _MCU_ENDIAN == 1    /* Use word access */
+#define    LD_WORD(ptr)        (WORD)(*(WORD*)(BYTE*)(ptr))
+#define    LD_DWORD(ptr)        (DWORD)(*(DWORD*)(BYTE*)(ptr))
+#define    ST_WORD(ptr,val)    *(WORD*)(BYTE*)(ptr)=(WORD)(val)
+#define    ST_DWORD(ptr,val)    *(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
 #else
+#if _MCU_ENDIAN == 2    /* Use byte-by-byte access */
+#define    LD_WORD(ptr)        (WORD)(((WORD)*(BYTE*)((ptr)+1)&lt;&lt;8)|(WORD)*(BYTE*)(ptr))
+#define    LD_DWORD(ptr)        (DWORD)(((DWORD)*(BYTE*)((ptr)+3)&lt;&lt;24)|((DWORD)*(BYTE*)((ptr)+2)&lt;&lt;16)|((WORD)*(BYTE*)((ptr)+1)&lt;&lt;8)|*(BYTE*)(ptr))
+#define    ST_WORD(ptr,val)    *(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8)
+#define    ST_DWORD(ptr,val)    *(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8); *(BYTE*)((ptr)+2)=(BYTE)((DWORD)(val)&gt;&gt;16); *(BYTE*)((ptr)+3)=(BYTE)((DWORD)(val)&gt;&gt;24)
+#else
 #error Do not forget to set _MCU_ENDIAN properly!
 #endif
+#endif
 
 
 #define _FATFS

Modified: branches/eagle_mmc/src/fatfs/integer.h
===================================================================
--- branches/eagle_mmc/src/fatfs/integer.h	2009-03-25 23:29:27 UTC (rev 268)
+++ branches/eagle_mmc/src/fatfs/integer.h	2009-03-26 02:17:48 UTC (rev 269)
@@ -4,23 +4,22 @@
 
 #ifndef _INTEGER
 
-/* These types must be 16-bit, 32-bit or larger integer */
-typedef int				INT;
+typedef signed int		INT;
 typedef unsigned int	UINT;
 
 #ifndef __TYPE_H__
-/* These types must be 8-bit integer */
+/* These types are assumed as 8-bit integer */
 typedef signed char		CHAR;
 typedef unsigned char	UCHAR;
 typedef unsigned char	BYTE;
 
-/* These types must be 16-bit integer */
-typedef short			SHORT;
+/* These types are assumed as 16-bit integer */
+typedef signed short	SHORT;
 typedef unsigned short	USHORT;
 typedef unsigned short	WORD;
 
-/* These types must be 32-bit integer */
-typedef long			LONG;
+/* These types are assumed as 32-bit integer */
+typedef signed long		LONG;
 typedef unsigned long	ULONG;
 typedef unsigned long	DWORD;
 

Added: branches/eagle_mmc/src/platform/lm3s/jtag.c
===================================================================
--- branches/eagle_mmc/src/platform/lm3s/jtag.c	2009-03-25 23:29:27 UTC (rev 268)
+++ branches/eagle_mmc/src/platform/lm3s/jtag.c	2009-03-26 02:17:48 UTC (rev 269)
@@ -0,0 +1,66 @@
+/*
+  jtag.c - JTAG utilities for LM3s hosts
+*/
+
+#include &quot;jtag.h&quot;
+
+/* -------------------- JTAG functions -------------------- */
+/* Enable JTAG pins */
+void JtagEnable(void)
+{
+    /* Change PB7 and PC0-3 for JTAG */
+    HWREG(GPIO_PORTB_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_CR) = 0x80;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_AFSEL) |= 0x80;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_CR) = 0x00;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_LOCK) = 0;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x01;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) |= 0x01;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x02;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) |= 0x02;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x04;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) |= 0x04;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x08;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) |= 0x08;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x00;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = 0;
+}
+
+/* Set JTAG pins for use as GPIO */
+void JtagDisable(void)
+{
+    /* Enable GPIO ports B and C */
+    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
+    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
+    /* Change PB7 and PC0-3 for GPIO input */
+    HWREG(GPIO_PORTB_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_CR) = 0x80;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_AFSEL) &amp;= 0x7f;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_CR) = 0x00;
+    HWREG(GPIO_PORTB_BASE + GPIO_O_LOCK) = 0;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x01;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) &amp;= 0xfe;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x02;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) &amp;= 0xfd;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x04;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) &amp;= 0xfb;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x08;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_AFSEL) &amp;= 0xf7;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_CR) = 0x00;
+    HWREG(GPIO_PORTC_BASE + GPIO_O_LOCK) = 0;
+    GPIOPinTypeGPIOInput(GPIO_PORTB_BASE, GPIO_PIN_7);
+    GPIOPinTypeGPIOInput(GPIO_PORTC_BASE, (GPIO_PIN_0 | GPIO_PIN_1 |
+                                           GPIO_PIN_2 | GPIO_PIN_3));
+}

Added: branches/eagle_mmc/src/platform/lm3s/jtag.h
===================================================================
--- branches/eagle_mmc/src/platform/lm3s/jtag.h	2009-03-25 23:29:27 UTC (rev 268)
+++ branches/eagle_mmc/src/platform/lm3s/jtag.h	2009-03-26 02:17:48 UTC (rev 269)
@@ -0,0 +1,22 @@
+/*
+  jtag.h - JTAG declarations for LM3S hosts
+*/
+
+#ifndef _JTAG_H
+#define _JTAG_H
+
+#include &quot;hw_gpio.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;gpio.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;sysctl.h&quot;
+
+/* API function declarations */
+
+/* -------------------- JTAG functions -------------------- */
+void JtagEnable(void);
+void JtagDisable(void);
+
+#endif /* _JTAG_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000224.html">[Elua-svn] r268 - in trunk/doc: . en wb
</A></li>
	<LI>Next message: <A HREF="000225.html">[Elua-svn] r270 - in trunk/src: . platform/lm3s platform/stm32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#226">[ date ]</a>
              <a href="thread.html#226">[ thread ]</a>
              <a href="subject.html#226">[ subject ]</a>
              <a href="author.html#226">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
