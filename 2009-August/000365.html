<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r409 - tags/pre0.6/doc
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r409%20-%20tags/pre0.6/doc&In-Reply-To=%3C200908251142.n7PBgPoe029576%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000364.html">
   <LINK REL="Next"  HREF="000366.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r409 - tags/pre0.6/doc</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r409%20-%20tags/pre0.6/doc&In-Reply-To=%3C200908251142.n7PBgPoe029576%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r409 - tags/pre0.6/doc">bogdanm at mail.berlios.de
       </A><BR>
    <I>Tue Aug 25 13:42:25 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000364.html">[Elua-svn] r408 - tags/pre0.6/doc
</A></li>
        <LI>Next message: <A HREF="000366.html">[Elua-svn] r410 - in tags/pre0.6/doc: . eluadoc en
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#365">[ date ]</a>
              <a href="thread.html#365">[ thread ]</a>
              <a href="subject.html#365">[ subject ]</a>
              <a href="author.html#365">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2009-08-25 13:42:25 +0200 (Tue, 25 Aug 2009)
New Revision: 409

Added:
   tags/pre0.6/doc/eluadoc.lua
   tags/pre0.6/doc/eluadoc/
Removed:
   tags/pre0.6/doc/luadoc.lua
   tags/pre0.6/doc/luadoc/
Modified:
   tags/pre0.6/doc/buildall.lua
Log:
renamed luadoc to eluadoc to avoid name conflist to the well knows Lua documentation tool

Modified: tags/pre0.6/doc/buildall.lua
===================================================================
--- tags/pre0.6/doc/buildall.lua	2009-08-24 14:46:01 UTC (rev 408)
+++ tags/pre0.6/doc/buildall.lua	2009-08-25 11:42:25 UTC (rev 409)
@@ -1,5 +1,5 @@
 require &quot;lfs&quot;
-require &quot;luadoc&quot;
+require &quot;eluadoc&quot;
 
 -- Languages in the system
 -- NOTE: &quot;en&quot; must ALWAYS be the first entry in this array!
@@ -436,10 +436,10 @@
   return
 end
 
--- Add the content generated from luadoc to our menu(s)
+-- Add the content generated from eluadoc to our menu(s)
 print &quot;Generating HTML documentation...&quot;
 indent_print()
-local automenus, genfiles = luadoc.gen_html_doc()
+local automenus, genfiles = eluadoc.gen_html_doc()
 if not automenus then return end
 regular_print()
 -- Replace content generated by gen_html_doc in the menu
@@ -512,8 +512,8 @@
 regular_print()
 print &quot;done&quot;
 
--- And delete the files generated by luadoc
-print &quot;\nCleaning up files generated by luadoc...&quot;
+-- And delete the files generated by eluadoc
+print &quot;\nCleaning up files generated by eluadoc...&quot;
 indent_print()
 for _, v in pairs( genfiles ) do 
   print( string.format( &quot;Deleting %s...&quot;, v ) )

Copied: tags/pre0.6/doc/eluadoc (from rev 405, tags/pre0.6/doc/luadoc)

Copied: tags/pre0.6/doc/eluadoc.lua (from rev 407, tags/pre0.6/doc/luadoc.lua)
===================================================================
--- tags/pre0.6/doc/luadoc.lua	2009-08-24 14:32:47 UTC (rev 407)
+++ tags/pre0.6/doc/eluadoc.lua	2009-08-25 11:42:25 UTC (rev 409)
@@ -0,0 +1,376 @@
+-------------------------------------------------------------------------------
+-- eLua doc builder module (for the eluadoc/ directory)
+
+module( ..., package.seeall )
+
+local sf = string.format
+
+-------------------------------------------------------------------------------
+-- Data structure declarations
+
+-- List here all the sections for which we're generating the documentation
+local doc_sections = { &quot;arch_platform&quot;, &quot;refman_gen&quot;, &quot;refman_ps_lm3s&quot; }
+
+-- List here all the components of each section
+local components = 
+{ 
+  arch_platform = { &quot;ll&quot;, &quot;pio&quot;, &quot;spi&quot;, &quot;uart&quot;, &quot;timers&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;eth&quot;, &quot;adc&quot; },
+  refman_gen = { &quot;bit&quot;, &quot;pd&quot;, &quot;cpu&quot;, &quot;pack&quot;, &quot;adc&quot;, &quot;term&quot;, &quot;pio&quot;, &quot;uart&quot;, &quot;spi&quot;, &quot;tmr&quot;, &quot;pwm&quot;, &quot;net&quot; },
+  refman_ps_lm3s = { &quot;disp&quot; }
+}
+
+-------------------------------------------------------------------------------
+-- Local variables
+
+-- Paragraph indentation flag
+local p_indent = false
+
+-------------------------------------------------------------------------------
+-- Generic helpers and doc text formatting functions
+
+-- Return a proper &lt;p&gt; tag based on the p_indent flag
+local function get_p()
+  return p_indent and '&lt;p class=&quot;doc&quot;&gt;' or '&lt;p&gt;'
+end
+
+-- Format a name to a link by changing all the spaces to &quot;_&quot; and
+-- making all letters lowercase
+local function name2link( str )
+  str = str:gsub( &quot; &quot;, &quot;_&quot; )
+  return str:lower()
+end
+
+-- Returns the part of the string enclosed between two '#' chars
+-- Used for parsing function sig. 
+local function namefromsig( str )
+  local _, _, name = str:find( &quot;#(.*)#&quot; )
+  return name
+end
+
+-- Adds a &quot;.&quot; to the end of the string if it's not already present
+local function dot( str )
+  -- return str:sub( -1 ) == &quot;.&quot; and str or str .. &quot;.&quot;
+  return str
+end
+
+--[[ Process the given string as follows:
+- $string$ becomes &lt;b&gt;string&lt;/b&gt;
+- %string% becomes &lt;i&gt;string&lt;/i&gt;
+- @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ref at text</A>@ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
+- ^ref^text^ also becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
+- $$, %%, @@, ^^ become $, %, @, ^ respectively
+- the string &quot;eLua&quot; becomes &lt;b&gt;eLua&lt;/b&gt;
+- strings between two tildas (~~) get special code-like formatting
+- newlines are changed to ' ' if 'keepnl' isn't true
+- '&amp;' is translated to its corresponding HTML code.
+- '&lt;&lt;' and '&gt;&gt;&quot; are also translated to the corresponding HTML codes (note the repetition).
+--]]
+local function format_string( str, keepnl )
+  -- replace double &quot;special chars&quot; with &quot;temps&quot; for later use
+  str = str:gsub( &quot;%$%$&quot;, &quot;\001&quot; )
+  str = str:gsub( &quot;%%%%&quot;, &quot;\002&quot; )
+  str = str:gsub( &quot;@@&quot;, &quot;\003&quot; )
+  str = str:gsub( &quot;%^%^&quot;, &quot;\004&quot; )
+  str = str:gsub( &quot;~~&quot;, &quot;\005&quot; )
+
+   -- Translate 'special' HTML chars to their equivalents
+  local tr_table = 
+  {
+    [ &quot;%&amp;&quot; ] = &quot;&amp;&quot;,
+  }
+  for char, rep in pairs( tr_table ) do
+    str = str:gsub( char, rep )
+  end
+
+  -- some double chars are replaced directly with their HTML codes
+  str = str:gsub( &quot;&lt;&lt;&quot;, &quot;&lt;&quot; )
+  str = str:gsub( &quot;&gt;&gt;&quot;, &quot;&gt;&quot; )
+
+  -- replace eLua with &lt;b&gt;eLua&lt;/b&gt;
+  str = str:gsub( &quot;eLua&quot;, &quot;&lt;b&gt;eLua&lt;/b&gt;&quot; )
+
+  -- $string$ becomes &lt;b&gt;string&gt;&lt;/b&gt;
+  str = str:gsub( &quot;%$(.-)%$&quot;, &quot;&lt;b&gt;%1&lt;/b&gt;&quot; )
+
+  -- %string% becomes &lt;i&gt;string&lt;/i&gt;
+  str = str:gsub( &quot;%%(.-)%%&quot;, &quot;&lt;i&gt;%1&lt;/i&gt;&quot; )
+
+  -- @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ref at text</A>@ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
+  str = str:gsub( &quot;@(.-)@(.-)@&quot;, '&lt;a href=&quot;%1&quot;&gt;%2&lt;/a&gt;' )
+
+  -- ^ref^text^ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
+  str = str:gsub( &quot;%^(.-)%^(.-*)%^&quot;, '&lt;a href=&quot;%1&quot;&gt;%2&lt;/a&gt;' )
+
+  -- strings between two tildas (~~) get special code-like formatting
+  str = str:gsub( &quot;~(.-)~&quot;, function( x )
+    x = x:gsub( &quot;\n&quot;, &quot;&lt;br /&gt;&quot; )
+    x = x:gsub( &quot;%s%s+&quot;, function( x ) return ( &quot;&nbsp;&quot; ):rep( #x ) end )
+    return &quot;&lt;p&gt;&lt;code&gt;&quot; .. x .. &quot;&lt;/code&gt;&lt;/p&gt;&quot;
+  end )
+  str = str:gsub( &quot;~~&quot;, &quot;~&quot; )
+
+  if p_indent then
+    str = str:gsub( &quot;&lt;p&gt;&quot;, '&lt;p class=&quot;doc&quot;&gt;' )
+  end
+
+  -- other &quot;\n&quot; chars should dissapear now
+  if not keepnl then  str = str:gsub( &quot;\n&quot;, &quot; &quot; ) end
+
+  -- put back the &quot;temps&quot;
+  str = str:gsub( &quot;\001&quot;, &quot;%$&quot; )
+  str = str:gsub( &quot;\002&quot;, &quot;%%&quot; )
+  str = str:gsub( &quot;\003&quot;, &quot;@&quot; )
+  str = str:gsub( &quot;\004&quot;, &quot;%^&quot; )
+  str = str:gsub( &quot;\005&quot;, &quot;~&quot; )
+
+  -- all done
+  return str
+end
+
+-------------------------------------------------------------------------------
+-- Content generation
+
+-- Build the documentation starting from the given file
+local function build_file( fname )
+  dofile( fname )
+  local res = {}
+
+  for _, lang in pairs( languages ) do
+    res[ lang ] = {}
+    res[ lang ].menu = {}
+    local menu = res[ lang ].menu
+    
+    -- we need english always
+    -- the other languages will be substituted with english if not found
+    local resname = string.format( &quot;data_%s&quot;, lang )
+    local r = _G[ resname ]
+    if not r then
+      if lang == &quot;en&quot; then
+        return false, &quot;data_en must exist in the description&quot;
+      else
+        print( string.format( &quot;'%s': data for language '%s' not found, defaulting to english&quot;, fname, lang ) )
+        r = _G.data_en
+      end
+    end
+
+    -- process names
+    if not r.menu_name then
+      return false, &quot;menu_names not found&quot;
+    end
+    menu.name = r.menu_name
+
+    -- process title
+    if not r.title then
+      return false, &quot;title not found&quot;
+    end
+    local page = &quot;$$HEADER$$\n&quot;
+    menu.title = r.title
+
+    -- process overview
+    if not r.overview then
+      return false, &quot;overview not found&quot;
+    end
+    page = page .. '&lt;a name=&quot;overview&quot;&gt;&lt;h3&gt;Overview&lt;/h3&gt;&lt;/a&gt;\n&lt;p&gt;' .. format_string( r.overview ) .. &quot;&lt;/p&gt;\n\n&quot;
+
+    -- process structures if needed
+    if r.structures then
+      local structures = r.structures
+      menu.structs = {}
+      page = page .. '&lt;a name=&quot;structures&quot;&gt;&lt;h3&gt;Data structures, constants and types&lt;/h3&gt;&lt;/a&gt;\n'
+      for i = 1, #structures do
+        local s = structures[ i ]
+        menu.structs[ #menu.structs + 1 ] = s.name
+        if not s.text or not s.desc or not s.name then
+          return false, &quot;structure without text, desc or name fields&quot;
+        end
+        -- text/name. The link name is ALWAYS the one in ENGLISH.
+        page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', name2link( res.en.menu.structs[ i ] ) )
+        page = page .. &quot;&lt;pre&gt;&lt;code&gt;&quot; .. format_string( s.text, true ) .. &quot;&lt;/code&gt;&lt;/pre&gt;&quot;
+        page = page .. &quot;&lt;/a&gt;&quot;
+        -- description
+        p_indent = true
+        page = page .. &quot;\n&lt;p class=\&quot;doc\&quot;&gt;&quot; .. format_string( s.desc ) .. &quot;&lt;/p&gt;\n\n&quot;
+        p_indent = false
+      end 
+    end
+
+    -- process functions now
+    if not r.funcs then
+      return false, &quot;funcs not found&quot;
+    end
+    local funcs = r.funcs
+    page = page .. '&lt;a name=&quot;funcs&quot;&gt;&lt;h3&gt;Functions&lt;/h3&gt;&lt;/a&gt;\n'
+    menu.funcs = {}
+    for i = 1, #funcs do
+      local f = funcs[ i ]
+      if not f.sig or not f.desc then
+        return false, &quot;function without sig or desc fields&quot;
+      end
+      local funcname = namefromsig( f.sig )
+      if not funcname then
+        return false, string.format( &quot;'%s' should contain the function name between '*' chars&quot;, f.sig )
+      end
+      menu.funcs[ #menu.funcs + 1 ] = funcname
+      -- signature
+      page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', funcname )
+      page = page .. &quot;&lt;pre&gt;&lt;code&gt;&quot; .. f.sig:gsub( '#', '' ) .. &quot;&lt;/code&gt;&lt;/pre&gt;&quot;
+      page = page .. &quot;&lt;/a&gt;&quot;
+      -- description
+      p_indent = true
+      page = page .. &quot;\n&lt;p class=\&quot;doc\&quot;&gt;&quot; .. dot( format_string( f.desc ) ) .. &quot;&lt;/p&gt;\n&quot;
+      -- arguments
+      page = page .. &quot;&lt;p class=\&quot;doc\&quot;&gt;&lt;b&gt;Arguments&lt;/b&gt;: &quot;
+      if f.args then
+        local a = f.args
+        if type( a ) == &quot;string&quot; or ( type( a ) == &quot;table&quot; and #a == 1 ) then
+          local text = type( a ) == &quot;string&quot; and a or a[ 1 ]
+          page = page .. dot( format_string( text ) )
+        else
+          page = page .. &quot;\n&lt;ul&gt;\n&quot;
+          for i = 1, #a do page = page .. &quot;  &lt;li&gt;&quot; .. dot( format_string( a[ i ] ) ) .. &quot;&lt;/li&gt;\n&quot; end
+          page = page .. &quot;&lt;/ul&gt;&quot;
+        end
+      else
+        page = page .. &quot;none.&quot;
+      end
+      page = page .. &quot;&lt;/p&gt;\n&quot;
+      -- return value
+      page = page .. &quot;&lt;p class=\&quot;doc\&quot;&gt;&lt;b&gt;Returns&lt;/b&gt;: &quot;
+      if f.ret then
+        local r = f.ret
+        if type( r ) == &quot;string&quot; or ( type( r ) == &quot;table&quot; and #r == 1 ) then
+          local text = type( r ) == &quot;string&quot; and r or r[ 1 ]
+          page = page .. dot( format_string( text ) )
+        else
+          page = page .. &quot;\n&lt;ul&gt;\n&quot;
+          for i = 1, #r do page = page .. &quot;  &lt;li&gt;&quot; .. dot( format_string( r[ i ] ) ) .. &quot;&lt;/li&gt;\n&quot; end
+          page = page .. &quot;&lt;/ul&gt;&quot;
+        end
+      else
+        page = page .. &quot;nothing.&quot;
+      end
+      page = page .. &quot;&lt;/p&gt;\n\n&quot;
+      p_indent = false
+    end
+
+    -- aux data (if any)
+    if r.auxdata then
+      local auxdata = r.auxdata
+      menu.auxdata = {}
+      for i = 1, #auxdata do
+        local a = auxdata[ i ]
+        menu.auxdata[ #menu.auxdata + 1 ] = a.title
+        if not a.title or not a.desc then
+          return false, &quot;auxdata without title or desc&quot;
+        end
+        -- the link name is ALWAYS the one in ENGLISH
+        page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', name2link( res.en.menu.auxdata[ i ] ) )
+        page = page .. &quot;&lt;h3&gt;&quot; .. a.title .. &quot;&lt;/h3&gt;&quot;
+        page = page .. &quot;&lt;/a&gt;&quot;
+        page = page .. &quot;\n&lt;p&gt;&quot; .. format_string( a.desc ) .. &quot;&lt;/p&gt;\n\n&quot;
+      end
+    end
+
+    -- footer
+    page = page .. &quot;$$FOOTER$$\n&quot;
+    res[ lang ].page = page
+  end
+  return res
+end
+
+-------------------------------------------------------------------------------
+-- Menu generation
+
+-- Helper function to get strings in all languages when needed
+local function all_langs( getstr )
+  local langs =  {}
+  for _, lang in pairs( languages ) do
+    langs[ #langs + 1 ] = getstr( lang )
+  end
+  return langs
+end
+
+-- Transform the data from the menu dictionary (in 'fulldata') for component 'component' and section 'sect' to a menu structure
+local function gen_menu( fulldata, component, sect )
+  local relfname = sect .. &quot;_&quot; .. component .. &quot;.html&quot;
+  local res = fulldata[ component ]
+  local themenu = { all_langs( function( x ) return res[ x ].menu.name end ), relfname, {}, all_langs( function( x ) return res[ x ].menu.title end ) }
+  local sub = themenu[ submenu_idx ] 
+  
+  -- Overview
+  sub[ #sub + 1 ] = { all_langs( function( x ) return getstr( &quot;Overview&quot;, x ) end ), sf( &quot;%s#overview&quot;, relfname ) }
+
+  -- Data structures (if needed)
+  if res.en.menu.structs then
+    sub[ #sub + 1 ] = { all_langs( function( x ) return getstr( &quot;Data structures&quot;, x ) end ), sf( &quot;%s#structures&quot;, relfname ), {} }
+    local s_sub = sub[ #sub ][ submenu_idx ]
+    for i = 1, #res.en.menu.structs do
+      local v = res.en.menu.structs[ i ]
+      s_sub[ #s_sub + 1 ] = { all_langs( function( x ) return res[ x ].menu.structs[ i ] end ), sf( &quot;%s#%s&quot;, relfname, name2link( v ) ) }
+    end
+  end
+
+  -- Functions
+  sub[ #sub + 1 ] = { all_langs( function( x ) return getstr( &quot;Functions&quot;, x ) end ), sf( &quot;%s#funcs&quot;, relfname ), {} }
+  local f_sub = sub[ #sub ][ submenu_idx ]
+  for _, v in pairs( res.en.menu.funcs ) do
+    f_sub[ #f_sub + 1 ] = { all_langs( function( x ) return v end ), sf( &quot;%s#%s&quot;, relfname, name2link( v ) ) }
+  end
+
+  -- Aux data (if needed)
+  if res.en.menu.auxdata then
+    for i = 1, #res.en.menu.auxdata do
+      local v = res.en.menu.auxdata[ i ]
+      sub[ #sub + 1 ] = { all_langs( function( x ) return res[ x ].menu.auxdata[ i ] end ), sf( &quot;%s#%s&quot;, relfname, name2link( v ) ) }
+    end
+  end
+
+  return themenu
+end
+
+-------------------------------------------------------------------------------
+-- Generate documentation from eluadoc for all languages
+
+function gen_html_doc()
+  local menu, genfiles = {}, {}
+
+  for _, section in pairs( doc_sections ) do 
+    -- Generate documentation for each module in turn
+    local fulldata = {}
+    menu[ section ] = {}
+    local ms = menu[ section ]
+    -- First generate HTML documentation
+    for _, modname in pairs( components[ section ] ) do
+      local descfname = string.format( &quot;eluadoc/%s_%s.lua&quot;, section, modname )
+      local res, err = build_file( descfname )
+      if res then
+        fulldata[ modname ] = res
+        -- Write doc for each language
+        for _, lang in pairs( languages ) do
+          local fname = string.format( &quot;%s/%s_%s.html&quot;, lang, section, modname )
+          local f = io.open( fname, &quot;wb&quot; )
+          if not f then
+            print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
+            return
+          else
+            f:write( res[ lang ].page )
+            f:close()
+            print( ( &quot;Wrote %s&quot; ):format( fname ) )
+            genfiles[ #genfiles + 1 ] = fname
+          end
+        end
+      else
+        print( string.format( &quot;Error processing module '%s': %s&quot;, modname, err ) )
+        return
+      end
+    end 
+
+    -- Then generate menu data
+    for _, modname in pairs( components[ section ] ) do
+      local submenu= gen_menu( fulldata, modname, section )
+      ms[ #ms + 1 ] = submenu
+    end
+  end
+  return menu, genfiles
+end
+


Property changes on: tags/pre0.6/doc/eluadoc.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: tags/pre0.6/doc/luadoc.lua
===================================================================
--- tags/pre0.6/doc/luadoc.lua	2009-08-24 14:46:01 UTC (rev 408)
+++ tags/pre0.6/doc/luadoc.lua	2009-08-25 11:42:25 UTC (rev 409)
@@ -1,376 +0,0 @@
--------------------------------------------------------------------------------
--- eLua doc builder module (for the luadoc/ directory)
-
-module( ..., package.seeall )
-
-local sf = string.format
-
--------------------------------------------------------------------------------
--- Data structure declarations
-
--- List here all the sections for which we're generating the documentation
-local doc_sections = { &quot;arch_platform&quot;, &quot;refman_gen&quot;, &quot;refman_ps_lm3s&quot; }
-
--- List here all the components of each section
-local components = 
-{ 
-  arch_platform = { &quot;ll&quot;, &quot;pio&quot;, &quot;spi&quot;, &quot;uart&quot;, &quot;timers&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;eth&quot;, &quot;adc&quot; },
-  refman_gen = { &quot;bit&quot;, &quot;pd&quot;, &quot;cpu&quot;, &quot;pack&quot;, &quot;adc&quot;, &quot;term&quot;, &quot;pio&quot;, &quot;uart&quot;, &quot;spi&quot;, &quot;tmr&quot;, &quot;pwm&quot;, &quot;net&quot; },
-  refman_ps_lm3s = { &quot;disp&quot; }
-}
-
--------------------------------------------------------------------------------
--- Local variables
-
--- Paragraph indentation flag
-local p_indent = false
-
--------------------------------------------------------------------------------
--- Generic helpers and doc text formatting functions
-
--- Return a proper &lt;p&gt; tag based on the p_indent flag
-local function get_p()
-  return p_indent and '&lt;p class=&quot;doc&quot;&gt;' or '&lt;p&gt;'
-end
-
--- Format a name to a link by changing all the spaces to &quot;_&quot; and
--- making all letters lowercase
-local function name2link( str )
-  str = str:gsub( &quot; &quot;, &quot;_&quot; )
-  return str:lower()
-end
-
--- Returns the part of the string enclosed between two '#' chars
--- Used for parsing function sig. 
-local function namefromsig( str )
-  local _, _, name = str:find( &quot;#(.*)#&quot; )
-  return name
-end
-
--- Adds a &quot;.&quot; to the end of the string if it's not already present
-local function dot( str )
-  -- return str:sub( -1 ) == &quot;.&quot; and str or str .. &quot;.&quot;
-  return str
-end
-
---[[ Process the given string as follows:
-- $string$ becomes &lt;b&gt;string&lt;/b&gt;
-- %string% becomes &lt;i&gt;string&lt;/i&gt;
-- @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ref at text</A>@ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
-- ^ref^text^ also becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
-- $$, %%, @@, ^^ become $, %, @, ^ respectively
-- the string &quot;eLua&quot; becomes &lt;b&gt;eLua&lt;/b&gt;
-- strings between two tildas (~~) get special code-like formatting
-- newlines are changed to ' ' if 'keepnl' isn't true
-- '&amp;' is translated to its corresponding HTML code.
-- '&lt;&lt;' and '&gt;&gt;&quot; are also translated to the corresponding HTML codes (note the repetition).
---]]
-local function format_string( str, keepnl )
-  -- replace double &quot;special chars&quot; with &quot;temps&quot; for later use
-  str = str:gsub( &quot;%$%$&quot;, &quot;\001&quot; )
-  str = str:gsub( &quot;%%%%&quot;, &quot;\002&quot; )
-  str = str:gsub( &quot;@@&quot;, &quot;\003&quot; )
-  str = str:gsub( &quot;%^%^&quot;, &quot;\004&quot; )
-  str = str:gsub( &quot;~~&quot;, &quot;\005&quot; )
-
-   -- Translate 'special' HTML chars to their equivalents
-  local tr_table = 
-  {
-    [ &quot;%&amp;&quot; ] = &quot;&amp;&quot;,
-  }
-  for char, rep in pairs( tr_table ) do
-    str = str:gsub( char, rep )
-  end
-
-  -- some double chars are replaced directly with their HTML codes
-  str = str:gsub( &quot;&lt;&lt;&quot;, &quot;&lt;&quot; )
-  str = str:gsub( &quot;&gt;&gt;&quot;, &quot;&gt;&quot; )
-
-  -- replace eLua with &lt;b&gt;eLua&lt;/b&gt;
-  str = str:gsub( &quot;eLua&quot;, &quot;&lt;b&gt;eLua&lt;/b&gt;&quot; )
-
-  -- $string$ becomes &lt;b&gt;string&gt;&lt;/b&gt;
-  str = str:gsub( &quot;%$(.-)%$&quot;, &quot;&lt;b&gt;%1&lt;/b&gt;&quot; )
-
-  -- %string% becomes &lt;i&gt;string&lt;/i&gt;
-  str = str:gsub( &quot;%%(.-)%%&quot;, &quot;&lt;i&gt;%1&lt;/i&gt;&quot; )
-
-  -- @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ref at text</A>@ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
-  str = str:gsub( &quot;@(.-)@(.-)@&quot;, '&lt;a href=&quot;%1&quot;&gt;%2&lt;/a&gt;' )
-
-  -- ^ref^text^ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
-  str = str:gsub( &quot;%^(.-)%^(.-*)%^&quot;, '&lt;a href=&quot;%1&quot;&gt;%2&lt;/a&gt;' )
-
-  -- strings between two tildas (~~) get special code-like formatting
-  str = str:gsub( &quot;~(.-)~&quot;, function( x )
-    x = x:gsub( &quot;\n&quot;, &quot;&lt;br /&gt;&quot; )
-    x = x:gsub( &quot;%s%s+&quot;, function( x ) return ( &quot;&nbsp;&quot; ):rep( #x ) end )
-    return &quot;&lt;p&gt;&lt;code&gt;&quot; .. x .. &quot;&lt;/code&gt;&lt;/p&gt;&quot;
-  end )
-  str = str:gsub( &quot;~~&quot;, &quot;~&quot; )
-
-  if p_indent then
-    str = str:gsub( &quot;&lt;p&gt;&quot;, '&lt;p class=&quot;doc&quot;&gt;' )
-  end
-
-  -- other &quot;\n&quot; chars should dissapear now
-  if not keepnl then  str = str:gsub( &quot;\n&quot;, &quot; &quot; ) end
-
-  -- put back the &quot;temps&quot;
-  str = str:gsub( &quot;\001&quot;, &quot;%$&quot; )
-  str = str:gsub( &quot;\002&quot;, &quot;%%&quot; )
-  str = str:gsub( &quot;\003&quot;, &quot;@&quot; )
-  str = str:gsub( &quot;\004&quot;, &quot;%^&quot; )
-  str = str:gsub( &quot;\005&quot;, &quot;~&quot; )
-
-  -- all done
-  return str
-end
-
--------------------------------------------------------------------------------
--- Content generation
-
--- Build the documentation starting from the given file
-local function build_file( fname )
-  dofile( fname )
-  local res = {}
-
-  for _, lang in pairs( languages ) do
-    res[ lang ] = {}
-    res[ lang ].menu = {}
-    local menu = res[ lang ].menu
-    
-    -- we need english always
-    -- the other languages will be substituted with english if not found
-    local resname = string.format( &quot;data_%s&quot;, lang )
-    local r = _G[ resname ]
-    if not r then
-      if lang == &quot;en&quot; then
-        return false, &quot;data_en must exist in the description&quot;
-      else
-        print( string.format( &quot;'%s': data for language '%s' not found, defaulting to english&quot;, fname, lang ) )
-        r = _G.data_en
-      end
-    end
-
-    -- process names
-    if not r.menu_name then
-      return false, &quot;menu_names not found&quot;
-    end
-    menu.name = r.menu_name
-
-    -- process title
-    if not r.title then
-      return false, &quot;title not found&quot;
-    end
-    local page = &quot;$$HEADER$$\n&quot;
-    menu.title = r.title
-
-    -- process overview
-    if not r.overview then
-      return false, &quot;overview not found&quot;
-    end
-    page = page .. '&lt;a name=&quot;overview&quot;&gt;&lt;h3&gt;Overview&lt;/h3&gt;&lt;/a&gt;\n&lt;p&gt;' .. format_string( r.overview ) .. &quot;&lt;/p&gt;\n\n&quot;
-
-    -- process structures if needed
-    if r.structures then
-      local structures = r.structures
-      menu.structs = {}
-      page = page .. '&lt;a name=&quot;structures&quot;&gt;&lt;h3&gt;Data structures, constants and types&lt;/h3&gt;&lt;/a&gt;\n'
-      for i = 1, #structures do
-        local s = structures[ i ]
-        menu.structs[ #menu.structs + 1 ] = s.name
-        if not s.text or not s.desc or not s.name then
-          return false, &quot;structure without text, desc or name fields&quot;
-        end
-        -- text/name. The link name is ALWAYS the one in ENGLISH.
-        page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', name2link( res.en.menu.structs[ i ] ) )
-        page = page .. &quot;&lt;pre&gt;&lt;code&gt;&quot; .. format_string( s.text, true ) .. &quot;&lt;/code&gt;&lt;/pre&gt;&quot;
-        page = page .. &quot;&lt;/a&gt;&quot;
-        -- description
-        p_indent = true
-        page = page .. &quot;\n&lt;p class=\&quot;doc\&quot;&gt;&quot; .. format_string( s.desc ) .. &quot;&lt;/p&gt;\n\n&quot;
-        p_indent = false
-      end 
-    end
-
-    -- process functions now
-    if not r.funcs then
-      return false, &quot;funcs not found&quot;
-    end
-    local funcs = r.funcs
-    page = page .. '&lt;a name=&quot;funcs&quot;&gt;&lt;h3&gt;Functions&lt;/h3&gt;&lt;/a&gt;\n'
-    menu.funcs = {}
-    for i = 1, #funcs do
-      local f = funcs[ i ]
-      if not f.sig or not f.desc then
-        return false, &quot;function without sig or desc fields&quot;
-      end
-      local funcname = namefromsig( f.sig )
-      if not funcname then
-        return false, string.format( &quot;'%s' should contain the function name between '*' chars&quot;, f.sig )
-      end
-      menu.funcs[ #menu.funcs + 1 ] = funcname
-      -- signature
-      page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', funcname )
-      page = page .. &quot;&lt;pre&gt;&lt;code&gt;&quot; .. f.sig:gsub( '#', '' ) .. &quot;&lt;/code&gt;&lt;/pre&gt;&quot;
-      page = page .. &quot;&lt;/a&gt;&quot;
-      -- description
-      p_indent = true
-      page = page .. &quot;\n&lt;p class=\&quot;doc\&quot;&gt;&quot; .. dot( format_string( f.desc ) ) .. &quot;&lt;/p&gt;\n&quot;
-      -- arguments
-      page = page .. &quot;&lt;p class=\&quot;doc\&quot;&gt;&lt;b&gt;Arguments&lt;/b&gt;: &quot;
-      if f.args then
-        local a = f.args
-        if type( a ) == &quot;string&quot; or ( type( a ) == &quot;table&quot; and #a == 1 ) then
-          local text = type( a ) == &quot;string&quot; and a or a[ 1 ]
-          page = page .. dot( format_string( text ) )
-        else
-          page = page .. &quot;\n&lt;ul&gt;\n&quot;
-          for i = 1, #a do page = page .. &quot;  &lt;li&gt;&quot; .. dot( format_string( a[ i ] ) ) .. &quot;&lt;/li&gt;\n&quot; end
-          page = page .. &quot;&lt;/ul&gt;&quot;
-        end
-      else
-        page = page .. &quot;none.&quot;
-      end
-      page = page .. &quot;&lt;/p&gt;\n&quot;
-      -- return value
-      page = page .. &quot;&lt;p class=\&quot;doc\&quot;&gt;&lt;b&gt;Returns&lt;/b&gt;: &quot;
-      if f.ret then
-        local r = f.ret
-        if type( r ) == &quot;string&quot; or ( type( r ) == &quot;table&quot; and #r == 1 ) then
-          local text = type( r ) == &quot;string&quot; and r or r[ 1 ]
-          page = page .. dot( format_string( text ) )
-        else
-          page = page .. &quot;\n&lt;ul&gt;\n&quot;
-          for i = 1, #r do page = page .. &quot;  &lt;li&gt;&quot; .. dot( format_string( r[ i ] ) ) .. &quot;&lt;/li&gt;\n&quot; end
-          page = page .. &quot;&lt;/ul&gt;&quot;
-        end
-      else
-        page = page .. &quot;nothing.&quot;
-      end
-      page = page .. &quot;&lt;/p&gt;\n\n&quot;
-      p_indent = false
-    end
-
-    -- aux data (if any)
-    if r.auxdata then
-      local auxdata = r.auxdata
-      menu.auxdata = {}
-      for i = 1, #auxdata do
-        local a = auxdata[ i ]
-        menu.auxdata[ #menu.auxdata + 1 ] = a.title
-        if not a.title or not a.desc then
-          return false, &quot;auxdata without title or desc&quot;
-        end
-        -- the link name is ALWAYS the one in ENGLISH
-        page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', name2link( res.en.menu.auxdata[ i ] ) )
-        page = page .. &quot;&lt;h3&gt;&quot; .. a.title .. &quot;&lt;/h3&gt;&quot;
-        page = page .. &quot;&lt;/a&gt;&quot;
-        page = page .. &quot;\n&lt;p&gt;&quot; .. format_string( a.desc ) .. &quot;&lt;/p&gt;\n\n&quot;
-      end
-    end
-
-    -- footer
-    page = page .. &quot;$$FOOTER$$\n&quot;
-    res[ lang ].page = page
-  end
-  return res
-end
-
--------------------------------------------------------------------------------
--- Menu generation
-
--- Helper function to get strings in all languages when needed
-local function all_langs( getstr )
-  local langs =  {}
-  for _, lang in pairs( languages ) do
-    langs[ #langs + 1 ] = getstr( lang )
-  end
-  return langs
-end
-
--- Transform the data from the menu dictionary (in 'fulldata') for component 'component' and section 'sect' to a menu structure
-local function gen_menu( fulldata, component, sect )
-  local relfname = sect .. &quot;_&quot; .. component .. &quot;.html&quot;
-  local res = fulldata[ component ]
-  local themenu = { all_langs( function( x ) return res[ x ].menu.name end ), relfname, {}, all_langs( function( x ) return res[ x ].menu.title end ) }
-  local sub = themenu[ submenu_idx ] 
-  
-  -- Overview
-  sub[ #sub + 1 ] = { all_langs( function( x ) return getstr( &quot;Overview&quot;, x ) end ), sf( &quot;%s#overview&quot;, relfname ) }
-
-  -- Data structures (if needed)
-  if res.en.menu.structs then
-    sub[ #sub + 1 ] = { all_langs( function( x ) return getstr( &quot;Data structures&quot;, x ) end ), sf( &quot;%s#structures&quot;, relfname ), {} }
-    local s_sub = sub[ #sub ][ submenu_idx ]
-    for i = 1, #res.en.menu.structs do
-      local v = res.en.menu.structs[ i ]
-      s_sub[ #s_sub + 1 ] = { all_langs( function( x ) return res[ x ].menu.structs[ i ] end ), sf( &quot;%s#%s&quot;, relfname, name2link( v ) ) }
-    end
-  end
-
-  -- Functions
-  sub[ #sub + 1 ] = { all_langs( function( x ) return getstr( &quot;Functions&quot;, x ) end ), sf( &quot;%s#funcs&quot;, relfname ), {} }
-  local f_sub = sub[ #sub ][ submenu_idx ]
-  for _, v in pairs( res.en.menu.funcs ) do
-    f_sub[ #f_sub + 1 ] = { all_langs( function( x ) return v end ), sf( &quot;%s#%s&quot;, relfname, name2link( v ) ) }
-  end
-
-  -- Aux data (if needed)
-  if res.en.menu.auxdata then
-    for i = 1, #res.en.menu.auxdata do
-      local v = res.en.menu.auxdata[ i ]
-      sub[ #sub + 1 ] = { all_langs( function( x ) return res[ x ].menu.auxdata[ i ] end ), sf( &quot;%s#%s&quot;, relfname, name2link( v ) ) }
-    end
-  end
-
-  return themenu
-end
-
--------------------------------------------------------------------------------
--- Generate documentation from luadoc for all languages
-
-function gen_html_doc()
-  local menu, genfiles = {}, {}
-
-  for _, section in pairs( doc_sections ) do 
-    -- Generate documentation for each module in turn
-    local fulldata = {}
-    menu[ section ] = {}
-    local ms = menu[ section ]
-    -- First generate HTML documentation
-    for _, modname in pairs( components[ section ] ) do
-      local descfname = string.format( &quot;luadoc/%s_%s.lua&quot;, section, modname )
-      local res, err = build_file( descfname )
-      if res then
-        fulldata[ modname ] = res
-        -- Write doc for each language
-        for _, lang in pairs( languages ) do
-          local fname = string.format( &quot;%s/%s_%s.html&quot;, lang, section, modname )
-          local f = io.open( fname, &quot;wb&quot; )
-          if not f then
-            print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
-            return
-          else
-            f:write( res[ lang ].page )
-            f:close()
-            print( ( &quot;Wrote %s&quot; ):format( fname ) )
-            genfiles[ #genfiles + 1 ] = fname
-          end
-        end
-      else
-        print( string.format( &quot;Error processing module '%s': %s&quot;, modname, err ) )
-        return
-      end
-    end 
-
-    -- Then generate menu data
-    for _, modname in pairs( components[ section ] ) do
-      local submenu= gen_menu( fulldata, modname, section )
-      ms[ #ms + 1 ] = submenu
-    end
-  end
-  return menu, genfiles
-end
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000364.html">[Elua-svn] r408 - tags/pre0.6/doc
</A></li>
	<LI>Next message: <A HREF="000366.html">[Elua-svn] r410 - in tags/pre0.6/doc: . eluadoc en
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#365">[ date ]</a>
              <a href="thread.html#365">[ thread ]</a>
              <a href="subject.html#365">[ subject ]</a>
              <a href="author.html#365">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
