<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r413 - tags/pre0.6/doc/en
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r413%20-%20tags/pre0.6/doc/en&In-Reply-To=%3C200908271735.n7RHZXb9032380%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000368.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r413 - tags/pre0.6/doc/en</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r413%20-%20tags/pre0.6/doc/en&In-Reply-To=%3C200908271735.n7RHZXb9032380%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r413 - tags/pre0.6/doc/en">bogdanm at mail.berlios.de
       </A><BR>
    <I>Thu Aug 27 19:35:33 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000368.html">[Elua-svn] r412 - trunk/src/modules
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#369">[ date ]</a>
              <a href="thread.html#369">[ thread ]</a>
              <a href="subject.html#369">[ subject ]</a>
              <a href="author.html#369">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2009-08-27 19:35:32 +0200 (Thu, 27 Aug 2009)
New Revision: 413

Modified:
   tags/pre0.6/doc/en/arch_coding.html
   tags/pre0.6/doc/en/arch_con_term.html
   tags/pre0.6/doc/en/arch_ltr.html
   tags/pre0.6/doc/en/arch_newport.html
   tags/pre0.6/doc/en/arch_tcpip.html
Log:
now ALL our html pages should be XHTML 1.0 strict. I'll check this again and add the compliance icon upon confirmation.

Modified: tags/pre0.6/doc/en/arch_coding.html
===================================================================
--- tags/pre0.6/doc/en/arch_coding.html	2009-08-27 01:14:01 UTC (rev 412)
+++ tags/pre0.6/doc/en/arch_coding.html	2009-08-27 17:35:32 UTC (rev 413)
@@ -1,88 +1,88 @@
 $$HEADER$$
 &lt;h3&gt;The eLua coding style&lt;/h3&gt;
-&lt;p&gt;This section presents the &lt;b&gt;eLua&lt;/b&gt; coding style that should be followed by every developer working on &lt;b&gt;eLua&lt;/b&gt;. The following rules apply:
+&lt;p&gt;This section presents the &lt;b&gt;eLua&lt;/b&gt; coding style that should be followed by every developer working on &lt;b&gt;eLua&lt;/b&gt;. The following rules apply:&lt;/p&gt;
 &lt;ol&gt;
   &lt;li&gt;Everything should be spaced out properly. Examples (please note the spacing rules, which is basically &quot;space out everything for readability&quot;):
-  &lt;p&gt;&lt;pre&gt;&lt;code&gt;i = 3 (not i=3)
+  &lt;pre&gt;&lt;code&gt;i = 3 (not i=3)
 a = ( a + 5 ) / 3
 for( i = 0; i &lt; 10; i ++ ) ...
 if( ( i == 5 ) &amp;&amp; ( a == 10 ) ) ...
 unsigned i = ( unsigned )p;
-void func( int arg1, const char* arg2 ) ...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
-  &lt;li&gt;&lt;b&gt;Indentation&lt;/b&gt;: indent everything at 2 SPACES. Again, &lt;b&gt;SPACES&lt;/b&gt;. &lt;b&gt;DO NOT USE TABS&lt;/b&gt;; this is important (and fortunately pretty easy to remember :) ). 
+void func( int arg1, const char* arg2 ) ...&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;Indentation&lt;/b&gt;: indent everything at 2 SPACES. Again, &lt;b&gt;SPACES&lt;/b&gt;. &lt;span class=&quot;warning&quot;&gt;DO NOT USE TABS&lt;/span&gt;; this is important (and fortunately pretty easy to remember :) ). 
   There are too many examples where tabs completely destroyed the readability of source code. Most editors have an &quot;insert tabs instead of spaces&quot; option; 
   use it, and set your &quot;tab size&quot; to 2.&lt;br&gt;
   Also, indent &quot;{&quot; and &quot;}&quot; on their own lines:
-  &lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
+  &lt;pre&gt;&lt;code&gt;if( i == 2 )
 {
   // some code here
 }
 else
 {
   // some other code here
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+}&lt;/code&gt;&lt;/pre&gt;
 
       Or:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;void f( int i )
+&lt;pre&gt;&lt;code&gt;void f( int i )
 {
   // function code
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+}&lt;/code&gt;&lt;/pre&gt;
 
 Do not enclose single statements in {} when given a choice. For example, do this:
 
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
-  return;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;if( i == 2 )
+  return;&lt;/code&gt;&lt;/pre&gt;
           
           instead of this:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
+&lt;pre&gt;&lt;code&gt;if( i == 2 )
 {
   return;
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+}&lt;/code&gt;&lt;/pre&gt;
 
 Also, follow the &quot;one statement per line&quot; rule. In other words, don't do this:
 
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 ) return;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;if( i == 2 ) return;&lt;/code&gt;&lt;/pre&gt;
 
 Do this instead:
 
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
-  return;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;if( i == 2 )
+  return;&lt;/code&gt;&lt;/pre&gt;
 
 Note that &lt;b&gt;eLua&lt;/b&gt; code does not use a space between the function name and its parameter list when calling/defining it (like in the Lua code, for example). So do this:
 
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;void f( int i )
+&lt;pre&gt;&lt;code&gt;void f( int i )
 {
   // function code here
 }
 
-f( 2 ); // function call&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+f( 2 ); // function call&lt;/code&gt;&lt;/pre&gt;
 
 instead of this:
 
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;void f ( int i )
+&lt;pre&gt;&lt;code&gt;void f ( int i )
 {
   // function code here
 }
 
-f ( 2 ); // function call&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
-&lt;li&gt;&lt;b&gt;line terminators&lt;/b&gt;: &lt;b&gt;THIS IS IMPORTANT TOO!&lt;/b&gt; Use UNIX style (LF) line terminators, not DOS (CR/LF) or old Mac (CR) line terminators.&lt;/li&gt;
+f ( 2 ); // function call&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;line terminators&lt;/b&gt;: &lt;span class=&quot;warning&quot;&gt;THIS IS IMPORTANT!&lt;/span&gt; Use UNIX style (LF) line terminators, not DOS (CR/LF) or old Mac (CR) line terminators.&lt;/li&gt;
 &lt;li&gt;&lt;b&gt;identifier names&lt;/b&gt;: use a &quot;GNU-style&quot; here, with underlines and all lowercase:
 
- &lt;p&gt;&lt;pre&gt;&lt;code&gt;int simple;
+ &lt;pre&gt;&lt;code&gt;int simple;
 double another_identifier;
-char yes_this_is_OK_although_quite_stupid;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+char yes_this_is_OK_although_quite_stupid;&lt;/code&gt;&lt;/pre&gt;
 
 As opposed to:
 
- &lt;p&gt;&lt;pre&gt;&lt;code&gt;int Simple1;
+ &lt;pre&gt;&lt;code&gt;int Simple1;
 double AnotherIdentifier;
-char DontEvenThinkAboutWritingSomethingLikeThis;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+char DontEvenThinkAboutWritingSomethingLikeThis;&lt;/code&gt;&lt;/pre&gt;
 &lt;b&gt;DO NOT USE HUNGARIAN NOTATION&lt;/b&gt; (like iNumber, sString, fFloat ... if you don't know what that is, it's fine, as it means that we don't need to worry about it :) ). It has its advantages
 when used properly, it's just not for &lt;b&gt;eLua&lt;/b&gt;.
 &lt;/li&gt;
 &lt;li&gt;&lt;b&gt;constants in code&lt;/b&gt;: don't ever write something like this:
 
- &lt;p&gt;&lt;pre&gt;&lt;code&gt;if( key == 10 )
+ &lt;pre&gt;&lt;code&gt;if( key == 10 )
   sys_ok();
 else if( key == 5 )
   phone_dial( &quot;911&quot; );
@@ -94,11 +94,11 @@
 else if( key == 0 )
  sys_retry();
 else
- sys_error();&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+ sys_error();&lt;/code&gt;&lt;/pre&gt;
 
 Instead, define some constants with meaningful names (via enums or even #define) and write like this:
 
- &lt;p&gt;&lt;pre&gt;&lt;code&gt;if( key == KEY_CODE_OK )
+ &lt;pre&gt;&lt;code&gt;if( key == KEY_CODE_OK )
   sys_ok();
 else if( key == KEY_CODE_FATAL_ERROR )
   phone_dial( &quot;911&quot; );
@@ -110,7 +110,7 @@
 else if( key == KEY_CODE_NONE )
   sys_retry();
 else
-  sys_error();&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+  sys_error();&lt;/code&gt;&lt;/pre&gt;
 You can see in this example an accepted violation of the &quot;one statement per line&quot; rule: it's OK to write &quot;else if (newcondition)&quot; on the same line.&lt;/li&gt;
 
 &lt;li&gt;use specific data types as much as possible. In this context, &lt;b&gt;specific data types&lt;/b&gt; reffers to generic types that have the same size on all 
@@ -136,26 +136,26 @@
   they tend to make the programmer overdocument the code to the point where it becomes hard to read because of the documentation alone. Ideally, you'd neither overdocument, nor 
   underdocument your code; just document it as much as you think it's needed, without getting into too much details, but also without omitting important information. In particular, DON'T do this:
 
- &lt;p&gt;&lt;pre&gt;&lt;code&gt;// This function returns the sum of two numbers
+ &lt;pre&gt;&lt;code&gt;// This function returns the sum of two numbers
 // Input: n1 - first number
 // Input: n2 - the second number
 // Output: the sum of n1 and n2
 int sum( int n1, int n2 )
 {
   return n1 + n2;
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+}&lt;/code&gt;&lt;/pre&gt;
 
   When something is self-obvious from the context, documenting it more is pointless and decreases readability.&lt;/li&gt;
 &lt;li&gt;&lt;b&gt;pseudo name-spaces&lt;/b&gt;: since we don't have namespaces in C, I like to &quot;emulate&quot; them by prefixing anything (constants, variables, functions) in a file with something that identifies that 
   file uniquely (most likely its name, but this is not a definite rule). For example, a file called &quot;uart.c&quot; would look like this:
 
- &lt;p&gt;&lt;pre&gt;&lt;code&gt;int uart_tx_count, uart_rx_count;
+ &lt;pre&gt;&lt;code&gt;int uart_tx_count, uart_rx_count;
 
 int uart_receive( unsigned limit )...
-unsigned uart_send( const char *buf, unsigned size )...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+unsigned uart_send( const char *buf, unsigned size )...&lt;/code&gt;&lt;/pre&gt;
 &lt;/li&gt;
 
-&lt;/ol&gt;&lt;/p&gt;
+&lt;/ol&gt;
 &lt;p&gt;Also, if you're using 3rd party code (from a library/support package for example) making it follow the above rules is nice, but not mandatory. Focus on functionality and writing your own code properly, and come back to indent other people's code when you really don't have anything better to do with your time.&lt;/p&gt;
 $$FOOTER$$
 

Modified: tags/pre0.6/doc/en/arch_con_term.html
===================================================================
--- tags/pre0.6/doc/en/arch_con_term.html	2009-08-27 01:14:01 UTC (rev 412)
+++ tags/pre0.6/doc/en/arch_con_term.html	2009-08-27 17:35:32 UTC (rev 413)
@@ -1,23 +1,23 @@
 $$HEADER$$
 &lt;h3&gt;eLua consoles and terminals&lt;/h3&gt;
-&lt;p&gt;In &lt;b&gt;eLua&lt;/b&gt;, a &lt;b&gt;console&lt;/b&gt; and a &lt;b&gt;terminal&lt;/b&gt; serve two related, but different purposes:
+&lt;p&gt;In &lt;b&gt;eLua&lt;/b&gt;, a &lt;b&gt;console&lt;/b&gt; and a &lt;b&gt;terminal&lt;/b&gt; serve two related, but different purposes:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;the &lt;b&gt;console&lt;/b&gt; takes care of basic user input/output. They come in two flavours: serial consoles and TCP/IP consoles (note that the two can't coexist at the same time).&lt;/li&gt;
   &lt;li&gt;the &lt;b&gt;terminal&lt;/b&gt; enhances the console in order to take advantage of ANSI terminals and their advanced control functions, like explicit cursor positioning, clear screen and others. At this
   time, terminals work only over serial connections, not over TCP/IP (like consoles).&lt;/li&gt;
-&lt;/ul&gt;&lt;/p&gt;
+&lt;/ul&gt;
 &lt;p&gt;Both components can be enabled and disabled as needed (they don't rely on each other). See &lt;a href=&quot;building.html&quot;&gt;building eLua&lt;/a&gt; for details on how to enable and disable components.&lt;/p&gt;
 &lt;h2&gt;Serial consoles&lt;/h2&gt;
 &lt;p&gt;The serial console input/output is handled by a generic layer (&lt;i&gt;src/newlib/genstd.c&lt;/i&gt;) that can be used to easily adapt the console subsystem to a variety of input/output devices. 
   It needs just two functions, one for displaying characters and another one for receiving input with timeout:&lt;/p&gt;
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;// Send/receive function types
+&lt;pre&gt;&lt;code&gt;// Send/receive function types
 typedef void ( *p_std_send_char )( int fd, char c );
 typedef int ( *p_std_get_char )( s32 to );
-&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;(the &lt;b&gt;send&lt;/b&gt; faction gets an additional &lt;b&gt;fd&lt;/b&gt; parameter that you can use to  differentiate between the standard C stdout and stderr output streams).&lt;/p&gt;
 &lt;p&gt;To set them, use &lt;b&gt;std_set_send_func&lt;/b&gt; and &lt;b&gt;std_set_get_func&lt;/b&gt;, both defined in &lt;i&gt;inc/newlib/getstd.h&lt;/i&gt;. Usually they are called from &lt;i&gt;src/common.c&lt;/i&gt; and configured to work
   over UART by default:&lt;/p&gt;
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;// *****************************************************************************
+&lt;pre&gt;&lt;code&gt;// *****************************************************************************
 // std functions and platform initialization
 
 static void uart_send( int fd, char c )
@@ -37,7 +37,7 @@
   std_set_send_func( uart_send );
   std_set_get_func( uart_recv );  
 }
-&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;If you need another type of serial console device (for example a dedicated console running over a SPI connection) just call &lt;i&gt;std_set_send_func/std_set_get_func&lt;/i&gt; with the appropriate 
   function pointers.&lt;/p&gt;
 &lt;p&gt;To enable serial consoles, define the &lt;b&gt;BUILD_CON_GENERIC&lt;/b&gt; macro in your platform's &lt;b&gt;platform_conf.h&lt;/b&gt; file.&lt;/p&gt;
@@ -47,8 +47,8 @@
 &lt;h2&gt;Terminals&lt;/h2&gt;
 &lt;p&gt;Besides standard stdio/stdout/stderr support provided by consoles, &lt;b&gt;eLua&lt;/b&gt; uses the &quot;term&quot; module to access ANSI compatible terminal emulators.  It is designed to be as flexible as 
   possible, thus allowing a large number of terminal emulators to be used. To enable terminal support, add &lt;b&gt;BUILD_TERM&lt;/b&gt; in your platform's &lt;b&gt;platform_conf.h&lt;/b&gt; file. To use it, initialize
-  it with a call to &lt;b&gt;term_init&lt;/b&gt;:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;...........................
+  it with a call to &lt;b&gt;term_init&lt;/b&gt;:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;...........................
 // Terminal output function
 typedef void ( *p_term_out )( u8 );
 // Terminal input function
@@ -59,21 +59,21 @@
 // Terminal initialization
 void term_init( unsigned lines, unsigned cols, p_term_out term_out_func, 
                 p_term_in term_in_func, p_term_translate term_translate_func );
-&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
-&lt;p&gt;The initialization function takes the physical size of the terminal emulator window (usually 80 lines and 25 cols) and three function pointers:
+&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;The initialization function takes the physical size of the terminal emulator window (usually 80 lines and 25 cols) and three function pointers:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;&lt;b&gt;p_term_out&lt;/b&gt;: this function will be called to output characters to the terminal. It receives the character to output as its single parameter.&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;p_term_in&lt;/b&gt;: this function will be called to read a character from the terminal. It receives a parameter that can be either TERM_INPUT_DONT_WAIT (in which case the function returns 
   -1 immediately if no character is available) or TERM_INPUT_WAIT (in which case the function will wait for the character).&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;p_term_translate&lt;/b&gt;: this function translates terminal-specific codes to &quot;term&quot; codes. The &quot;term&quot; codes are defined in an enum from &lt;i&gt;inc/term.h&lt;/i&gt;:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;...........................
+&lt;pre&gt;&lt;code&gt;...........................
 _D( KC_UP ),\
 _D( KC_DOWN ),\
 _D( KC_LEFT ),\
 ...........................
 _D( KC_ESC ),\
 _D( KC_UNKNOWN )  
-...........................&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+...........................&lt;/code&gt;&lt;/pre&gt;
 By using this function, it is possible to adapt a very large number of &quot;term emulators&quot; to &lt;b&gt;eLua&lt;/b&gt;. For example, you might want to run eLua in a &quot;standalone
   mode&quot; that does not require a PC at all, just an external LCD display and maybe a keyboard for data input. Your &lt;b&gt;eLua&lt;/b&gt; board can connect to this standalone terminal using its 
   I/O pins or built in peripherals, for example via SPI. By writing the three functions described above, the effort of making &lt;b&gt;eLua&lt;/b&gt; work with this new type of device is minimal, 

Modified: tags/pre0.6/doc/en/arch_ltr.html
===================================================================
--- tags/pre0.6/doc/en/arch_ltr.html	2009-08-27 01:14:01 UTC (rev 412)
+++ tags/pre0.6/doc/en/arch_ltr.html	2009-08-27 17:35:32 UTC (rev 413)
@@ -19,7 +19,7 @@
 &lt;h2&gt;Details&lt;/h2&gt;
 &lt;p&gt;The patch adds two new data types to Lua. Both or them are based on the lightuserdata type already found in Lua, and they share the same basic 
   attributes: they don't need to be dynamically allocated (as they're just pointers on steroids) and they're compared in the same way lightuserdatas 
-  are compared (by value). And of course, they are not collectable, so the garbage collector won't have anything to do with them. The new types are:
+  are compared (by value). And of course, they are not collectable, so the garbage collector won't have anything to do with them. The new types are:&lt;/p&gt;
 &lt;ol&gt;
 &lt;li&gt;&lt;b&gt;lightfunctions&lt;/b&gt;: these are &quot;simple&quot; functions, in the sense that they can't have upvalues or environments. They are just pointers to regular 
   C functions. Other than that, you can use them from Lua just as you'd use any other function.&lt;/li&gt;
@@ -33,8 +33,8 @@
   &lt;li&gt;you can use rotables as metatables for both &quot;regular&quot; tables and for Lua types (via debug.setmetatable)&lt;/li&gt;
   &lt;li&gt;a rotable can have another rotable (or tself) as a metatable&lt;/li&gt;
   &lt;li&gt;you can iterate over rotables with pairs/ipairs/next just as you do with &quot;regular&quot; tables.&lt;/li&gt;
-&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;
-&lt;p&gt;Just as with lightuserdata, you can only create lightfunctions and rotables from C code, never from Lua itself.&lt;p&gt;
+&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
+&lt;p&gt;Just as with lightuserdata, you can only create lightfunctions and rotables from C code, never from Lua itself.&lt;/p&gt;
 &lt;h2&gt;Testing&lt;/h2&gt;
 &lt;p&gt;I tested my patch with the (&lt;a target=&quot;_blank&quot; href=&quot;<A HREF="http://lua-users.org/lists/lua-l/2006-03/msg00723.html">http://lua-users.org/lists/lua-l/2006-03/msg00723.html</A>&quot;&gt;Lua 5.1 test suite&lt;/a&gt;). The test suite 
   was an excellent testing tool. I thought I had the patch ready until I found the test suite and ran it. After another week of work, I had something 
@@ -92,7 +92,7 @@
 &lt;/tr&gt;
 &lt;/tbody&gt;
 &lt;/table&gt;
-&lt;/p&gt;
+
 &lt;p&gt;As you can see, the differences are significant, and (more important) it doesn't matter how many modules you load in &lt;b&gt;eLua&lt;/b&gt;, the RAM consumption
    doesn't modify.&lt;/p&gt;
 &lt;p&gt;Currently, there aren't any performane measurements related to LTR. It's clear from the implementation that the patch slows down the virtual machine, 
@@ -126,21 +126,21 @@
   luaL_register( L, &quot;mod&quot;, mod_map );
   return 1;
 }&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
-&lt;p&gt;For the rotables implementation, however, you'd need to define the same thing like this:&lt;p&gt;
+&lt;p&gt;For the rotables implementation, however, you'd need to define the same thing like this:&lt;/p&gt;
 
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;const luaR_entry mod_map[] = &lt;font color=&quot;red&quot;&gt;// note: no static this time&lt;/font&gt;
+&lt;pre&gt;&lt;code&gt;const luaR_entry mod_map[] = &lt;span class=&quot;warning&quot;&gt;// note: no static this time&lt;/span&gt;
 {
   { LRO_STRKEY( &quot;f&quot; ), LRO_FUNCVAL( f_implementation ) },
   { LRO_NILKEY, LRO_NILVAL }
 };
 
-&lt;font color=&quot;red&quot;&gt;// note: in this case the &quot;luaopen_mod&quot; function isn't really needed anymore&lt;/font&gt;
+&lt;span class=&quot;warning&quot;&gt;// note: in this case the &quot;luaopen_mod&quot; function isn't really needed anymore&lt;/span&gt;
 LUALIB_API int luaopen_mod( lua_State *L )
 {
   return 0;
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+}&lt;/code&gt;&lt;/pre&gt;
 
-&lt;p&gt;A few points about the rotables example above:
+&lt;p&gt;A few points about the rotables example above:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;a rotable needs a &quot;map&quot; (mod_map) array much like a regular module, but you need to define that array with special macros:
   &lt;ul&gt;
@@ -148,29 +148,29 @@
        (empty) key&lt;/li&gt;
     &lt;li&gt;&lt;b&gt;for values&lt;/b&gt;: &lt;b&gt;LRO_FUNCVAL(f)&lt;/b&gt; defines a lightfunction value, &lt;b&gt;LRO_NUMVAL(f)&lt;/b&gt; defines a number value, &lt;b&gt;LRO_RO(p)&lt;/b&gt; defines a 
        rotable value (p is the pointer to the rotable) and &lt;b&gt;LRO_NILVAL&lt;/b&gt; defines a NULL (empty) value.&lt;/li&gt;
-  &lt;/ul&gt;
+  &lt;/ul&gt;&lt;/li&gt;
   &lt;li&gt;all the &quot;global&quot; rotables in the system (the ones that must be visible from &lt;b&gt;_G&lt;/b&gt;, like the rotables of all the modules exported to Lua) must be 
   included in a special array, called &lt;b&gt;lua_rotable&lt;/b&gt; (defined in &lt;i&gt;linit.c&lt;/i&gt;). Simply including the rotable's definition array (mod_map in this case)
   in the lua_rotable array makes it visible globally, thus you don't need to call any kind of register function. This is why &lt;b&gt;luaopen_mod&lt;/b&gt; now returns
   0.&lt;/li&gt;
-&lt;/ul&gt;&lt;/p&gt;
+&lt;/ul&gt;
 &lt;p&gt;The two forms above (for regular tables and for rotables) are clearly different, but we want to keep them both to be able to work at both &lt;b&gt;optram=0&lt;/b&gt;
   and &lt;b&gt;optram=2&lt;/b&gt;. You can use #ifdefs to differentiate between the two cases in different optimization levels, but this becomes really annoying after 
   a (short) while. This is why I added another file called &lt;b&gt;lrodefs.h&lt;/b&gt; (&lt;i&gt;src/lua&lt;/i&gt;) that can be used to give an &quot;universal&quot; definition to our map 
   arrays. Here's how our example looks after rewriting it to take advantage of &lt;b&gt;lrodefs.h&lt;/b&gt;:&lt;/p&gt;
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;&lt;font color=&quot;red&quot;&gt;#define MIN_OPT_LEVEL  2 // the minimum optimization level at which we use rotables&lt;/font&gt;
+&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;warning&quot;&gt;#define MIN_OPT_LEVEL  2 // the minimum optimization level at which we use rotables&lt;/span&gt;
 #include &quot;lrodefs.h&quot;
-const &lt;font color=&quot;red&quot;&gt; LUA_REG_TYPE&lt;/font&gt; mod_map[] = &lt;font color=&quot;red&quot;&gt;// note: no more luaL_reg or luaR_entry&lt;/font&gt;
+const &lt;span class=&quot;warning&quot;&gt; LUA_REG_TYPE&lt;/span&gt; mod_map[] = &lt;span class=&quot;warning&quot;&gt;// note: no more luaL_reg or luaR_entry&lt;/span&gt;
 {
   { LSTRKEY( &quot;f&quot; ), LFUNCVAL( f_implementation ) },
   { LNILKEY, LNILVAL }
 };
-// &lt;font color=&quot;red&quot;&gt;note: no more LRO_something, just Lsomething (for example LRO_STRKEY becomes LSTRKEY)&lt;/font&gt;
+// &lt;span class=&quot;warning&quot;&gt;note: no more LRO_something, just Lsomething (for example LRO_STRKEY becomes LSTRKEY)&lt;/span&gt;
 
 LUALIB_API int luaopen_mod( lua_State *L )
 {
-  &lt;font color=&quot;red&quot;&gt;LREGISTER&lt;/font&gt;( L, &quot;mod&quot;, mod_map ); // &lt;font color=&quot;red&quot;&gt;note: no more luaL_register, no &quot;return 1&quot;&lt;/font&gt;
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+  &lt;span class=&quot;warning&quot;&gt;LREGISTER&lt;/span&gt;( L, &quot;mod&quot;, mod_map ); // &lt;span class=&quot;warning&quot;&gt;note: no more luaL_register, no &quot;return 1&quot;&lt;/span&gt;
+}&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;Now, if &lt;b&gt;LUA_OPTIMIZE_MEMORY&lt;/b&gt; (a macro defined by the system as 0 when &lt;b&gt;optram=0&lt;/b&gt; and as 2 when &lt;b&gt;optram=1&lt;/b&gt;) is less than 
   &lt;b&gt;MIN_OPT_LEVEL&lt;/b&gt;, the above definition will compile in its &quot;regular table&quot; format. If &lt;b&gt;LUA_OPTIMIZE_MEMORY&lt;/b&gt; is 2, it compiles to the 
   rotables format. Problem solved :) &lt;b&gt;LREGISTER&lt;/b&gt; will also take care of calling &lt;b&gt;luaL_register&lt;/b&gt; and return 1 when &lt;b&gt;optram=0&lt;/b&gt; and do 
@@ -180,7 +180,7 @@
   metatable, it needs a &quot;__metatable&quot; field to point to its metatable (which is also a rotable, not necessarily another rotable) and the usual 
   metatable functions. For example, let's make our &lt;b&gt;mod&lt;/b&gt; rotable its own metatable and declare an &lt;b&gt;__index&lt;/b&gt; function. Moreover, let's do 
   this for both &lt;b&gt;optram=0&lt;/b&gt; and &lt;b&gt;optram=1&lt;/b&gt;.&lt;/p&gt;
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;static int mod_mt_index( lua_State *L ) 
+&lt;pre&gt;&lt;code&gt;static int mod_mt_index( lua_State *L ) 
 {
   return 0;
 }
@@ -190,9 +190,9 @@
 const LUA_REG_TYPE mod_map[] =
 {
   { LSTRKEY( &quot;f&quot; ), LFUNCVAL( f_implementation ) },
-&lt;font color=&quot;red&quot;&gt;#if LUA_OPTIMIZE_MEMORY &gt; 0
+&lt;span class=&quot;warning&quot;&gt;#if LUA_OPTIMIZE_MEMORY &gt; 0
   { LSTRKEY( &quot;__metatable&quot; ), LROVAL( mod_map ) },
-#endif&lt;/font&gt;
+#endif&lt;/span&gt;
   { LSTRKEY( &quot;__index&quot; ), LFUNCVAL( mod_mt_index) },
   { LNILKEY, LNILVAL };
 };
@@ -204,16 +204,16 @@
 #else
   luaL_register( L, &quot;mod&quot;, mod_map );
 	      
-  &lt;font color=&quot;red&quot;&gt;// Set &quot;mod&quot; as its own metatable
+  &lt;span class=&quot;warning&quot;&gt;// Set &quot;mod&quot; as its own metatable
   lua_pushvalue( L, -1 );
-  lua_setmetatable( L, -2 );&lt;/font&gt;
+  lua_setmetatable( L, -2 );&lt;/span&gt;
 		    
  return 1;
  #endif
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+}&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;If you want to register a module using a regular Lua table, but use lightfunctions instead of regular functions, use &lt;i&gt;luaL_register_light&lt;/i&gt; instead
   of &lt;i&gt;luaL_register&lt;/i&gt; (same syntax). &lt;/p&gt;
-&lt;p&gt;More important things to keep in mind when working with LTR:
+&lt;p&gt;More important things to keep in mind when working with LTR:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;currently, &lt;b&gt;MIN_OPT_LEVEL&lt;/b&gt; should be always set to 2&lt;/li&gt;
   &lt;li&gt;you need a C99-compatible compiler to use LTR (because of the compile-time explicit union initialization that's needed to declare const rotables). 
@@ -222,13 +222,13 @@
   placement (generally you'd declare stext at the beginning of .text definition and etext and the end of .text definition, see for example 
   &lt;i&gt;src/lua/at91sam7x256/flash256.lds&lt;/i&gt;). These are needed by the patch to differentiate between a regular table and a rotable (although this is likely
   to change in a future version of the patch.&lt;/li&gt;
-  &lt;li&gt;&lt;b&gt;&lt;font color=&quot;red&quot;&gt;remember to declare all you rotable's definition array as 'const'!!&lt;/font&gt;&lt;/b&gt; Forgetting to do so will not only increase 
+  &lt;li&gt;&lt;span class=&quot;warning&quot;&gt;remember to declare all you rotable's definition array as 'const'!!&lt;/span&gt; Forgetting to do so will not only increase 
   memory usage, it will also make the patch not functional, because of the way it recognizes rotables (see above).&lt;/li&gt;
-&lt;/ul&gt;&lt;/p&gt;
-&lt;a name=&quot;config&quot;&gt;&lt;h2&gt;LTR and module configuration at build time&lt;/h2&gt;&lt;/a&gt;
+&lt;/ul&gt;
+&lt;a name=&quot;config&quot; /&gt;&lt;h2&gt;LTR and module configuration at build time&lt;/h2&gt;
 &lt;p&gt;With unpatched Lua, you can specify what modules to be part of the Lua image by modifying &lt;i&gt;src/lua/linit.c&lt;/i&gt;. In the particular case of &lt;b&gt;eLua&lt;/b&gt;
   one had to declare a list of the modules that must be compiled in &lt;i&gt;src/platform/&lt;name&gt;/platform_conf.h&lt;/i&gt; like this:&lt;/p&gt;
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;#define LUA_PLATFORM_LIBS\
+&lt;pre&gt;&lt;code&gt;#define LUA_PLATFORM_LIBS\
   { AUXLIB_PIO, luaopen_pio },\
   { AUXLIB_TMR, luaopen_tmr },\
   { AUXLIB_PD, luaopen_pd },\
@@ -238,10 +238,10 @@
   { AUXLIB_PACK, luaopen_pack },\
   { AUXLIB_BIT, luaopen_bit },\
   { LUA_MATHLIBNAME, luaopen_math }
-&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt; 
-  Things are a bit more complex with LTR, but not by much. The list of modules that must be compiled is declared via a preprocessor macro in 
+&lt;/code&gt;&lt;/pre&gt;
+  &lt;p&gt;Things are a bit more complex with LTR, but not by much. The list of modules that must be compiled is declared via a preprocessor macro in 
   &lt;i&gt;src/platform/&lt;name&gt;/platform_conf.h&lt;/i&gt; and it looks like this:&lt;/p&gt;
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;#define LUA_PLATFORM_LIBS_ROM\
+&lt;pre&gt;&lt;code&gt;#define LUA_PLATFORM_LIBS_ROM\
   _ROM( AUXLIB_PIO, luaopen_pio, pio_map )\
   _ROM( AUXLIB_TMR, luaopen_tmr, tmr_map )\
   _ROM( AUXLIB_PD, luaopen_pd, pd_map )\
@@ -250,7 +250,7 @@
   _ROM( AUXLIB_PWM, luaopen_pwm, pwm_map )\
   _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
-  _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+  _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;(&lt;b&gt;IMPORTANT NOTE&lt;/b&gt;: the fact that there are no commas between two different _ROM declarations (as seen above) is NOT an error; 
   on the contrary, this is very much intended. Try using commas and you'll get in trouble very soon :) ).&lt;/p&gt;
 &lt;p&gt;Note the 3rd parameter of the &lt;b&gt;_ROM&lt;/b&gt; macro, which is the name of the definition array for the (ro)table. That's it. The code in linit.c will take 

Modified: tags/pre0.6/doc/en/arch_newport.html
===================================================================
--- tags/pre0.6/doc/en/arch_newport.html	2009-08-27 01:14:01 UTC (rev 412)
+++ tags/pre0.6/doc/en/arch_newport.html	2009-08-27 17:35:32 UTC (rev 413)
@@ -6,7 +6,7 @@
   an exhaustive guide, but it should be enough to point you in the right direction. Before diving into this, it's highly recommended that you take a look
   at the &lt;a href=&quot;elua_arch.html&quot;&gt;eLua architecture page&lt;/a&gt;. &lt;/p&gt;
 &lt;h3&gt;Prerequisites&lt;/h3&gt;
-&lt;p&gt;Before starting to work on the port, make sure that:
+&lt;p&gt;Before starting to work on the port, make sure that:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;your CPU has enough resources to run &lt;b&gt;eLua&lt;/b&gt;. A very rough estimation (based on ARM Thumb code only) is that you'd need at least 256k
   of program memory and 32k of RAM for a complete &lt;b&gt;eLua&lt;/b&gt; image, and 128k of program memory for a basic image. It's possible to run &lt;b&gt;eLua&lt;/b&gt; in
@@ -19,13 +19,13 @@
   &lt;/li&gt;
   &lt;li&gt;you have a platform library (it usually comes from the CPU manufacturer) that you can use to implement (at least part of) the platform interface.
   It's also highly recommended to gain at least a basic understanding of your platform, it will help a lot while writing the port.&lt;/li&gt;
-&lt;/ul&gt;&lt;/p&gt;
+&lt;/ul&gt;
 &lt;p&gt;If all of the above are true, you should continue reading this document to bring your port to life. If not, we're sorry, but (at least at this point)
 &lt;b&gt;eLua&lt;/b&gt; can't be ported to your CPU. If, on the other hand, you're good to go, please take a bit of time and read 
   &lt;a href=&quot;arch_overview.html#platforms&quot;&gt;this section&lt;/a&gt; first, as it details the structure of a port and might simplify your work quite a bit.&lt;/p&gt;
-&lt;a name=&quot;newboard&quot;&gt;&lt;h3&gt;Adding a new board&lt;/h3&gt;&lt;/a&gt;
+&lt;a name=&quot;newboard&quot; /&gt;&lt;h3&gt;Adding a new board&lt;/h3&gt;
 &lt;p&gt;If all you need is to add a new board that uses a CPU already supported by &lt;b&gt;eLua&lt;/b&gt; (check &lt;a href=&quot;status.html&quot;&gt;here&lt;/a&gt; for a complete list), it's
-fairly easy to accomplish this:
+fairly easy to accomplish this:&lt;/p&gt;
 &lt;ol&gt;
   &lt;li&gt;choose a good name for your board :)&lt;/li&gt;
   &lt;li&gt;edit &lt;b&gt;SConstruct&lt;/b&gt; and add your board to the &lt;b&gt;board_list&lt;/b&gt; dictionary, specifying its CPU. A part of the definition of &lt;b&gt;board_list&lt;/b&gt; is given below:
@@ -38,15 +38,15 @@
   &lt;/li&gt;
   &lt;li&gt;also edit the &lt;b&gt;file_list&lt;/b&gt; dictionary in &lt;b&gt;SConstruct&lt;/b&gt; to specify the list of ROMFS files that will be compiled for your board (see the 
   &lt;a href=&quot;arch_romfs.html&quot;&gt;ROMFS section&lt;/a&gt; for details). A part of the definition of &lt;b&gt;file_list&lt;/b&gt; is given below:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;# List of board/romfs data combinations
+&lt;pre&gt;&lt;code&gt;# List of board/romfs data combinations
 file_list = { 'SAM7-EX256' : [ 'bisect', 'hangman' , 'led', 'piano', 'hello', 'info', 'morse' ],
               'EK-LM3S8962' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
               'EK-LM3S6965' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
               ...............................
-            }&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
+            }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;if your board has external memory, you'll probably want to use the &quot;multiple&quot; allocator by default to take advantage of that (see &lt;a href=&quot;building.html&quot;&gt;building&lt;/a&gt;)
   for details. If so, you need to modify the CPU/allocator mapping code from &lt;b&gt;SConstruct&lt;/b&gt;:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;# CPU/allocator mapping (if allocator not specified)
+&lt;pre&gt;&lt;code&gt;# CPU/allocator mapping (if allocator not specified)
 if allocator == '':
   if &lt;b&gt;boardname == 'LPC-H2888'&lt;/b&gt; or &lt;b&gt;boardname == 'ATEVK1100'&lt;/b&gt;:
     allocator = 'multiple'
@@ -56,12 +56,12 @@
   print &quot;Unknown allocator&quot;, allocator
   print &quot;Allocator can be either 'newlib', 'multiple' or 'simple'&quot;
   sys.exit( -1 )
-&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;/code&gt;&lt;/pre&gt;
   &lt;/li&gt;
   &lt;li&gt;customize the &lt;b&gt;eLua&lt;/b&gt; image for this new board. You can use the variable &lt;b&gt;boardname&lt;/b&gt; in &lt;b&gt;conf.py&lt;/b&gt; to define new preprocessor macros specifically for your board
   (that you can use later in &lt;b&gt;platform_conf.h&lt;/b&gt;, for example), or to include or exclude certain files from the build, or change the build flags and so on. An example taken from 
   the &lt;b&gt;lm3s&lt;/b&gt; port is given below (part of &lt;b&gt;conf.py&lt;/b&gt;):
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;if boardname == 'EK-LM3S6965' or boardname == 'EK-LM3S8962':
+&lt;pre&gt;&lt;code&gt;if boardname == 'EK-LM3S6965' or boardname == 'EK-LM3S8962':
   specific_files = specific_files + &quot; rit128x96x4.c disp.c&quot;
   cdefs = cdefs + &quot; -DENABLE_DISP&quot;
 
@@ -71,16 +71,16 @@
   linkopts = &quot;-Wl,-Ttext,0x2000&quot;
 else:
   linkopts = &quot;&quot;
-&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;/code&gt;&lt;/pre&gt;
 &lt;/li&gt;
-&lt;/ol&gt;&lt;/p&gt;
+&lt;/ol&gt;
 &lt;p&gt;After you edit all the relevant source files, all you have to do is to execute &lt;i&gt;scons board=&lt;boardname&gt;&lt;/i&gt; and you'll have &lt;b&gt;eLua&lt;/b&gt; compiled for your board.&lt;/p&gt;
-&lt;a name=&quot;newcpu&quot;&gt;&lt;h3&gt;Adding a new CPU&lt;/h3&gt;&lt;/a&gt;
+&lt;a name=&quot;newcpu&quot; /&gt;&lt;h3&gt;Adding a new CPU&lt;/h3&gt;
 &lt;p&gt;If you want to add a new CPU to &lt;b&gt;eLua&lt;/b&gt; and the new CPU happens to be supported by a platform on which &lt;b&gt;eLua&lt;/b&gt; already runs (see &lt;a href=&quot;status.html&quot;&gt;here&lt;/a&gt; for a full
-list), your task is still quite easy. Follow the steps below:
+list), your task is still quite easy. Follow the steps below:&lt;/p&gt;
 &lt;ol&gt;
   &lt;li&gt;edit &lt;b&gt;SConstruct&lt;/b&gt; and add your new CPU to the &lt;b&gt;platform_list&lt;/b&gt; dictionary. Use the &quot;official&quot; name of the CPU (as it appears in its datasheet). An example is given below:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;# List of platform/CPU/toolchains combinations
+&lt;pre&gt;&lt;code&gt;# List of platform/CPU/toolchains combinations
 # The first toolchain in the toolchains list is the default one
 # (the one that will be used if none is specified)
 platform_list = {
@@ -88,14 +88,14 @@
   'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'str9' : { 'cpus' : [ 'STR912FAW44' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   ..................
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
+}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;you also need to add a new board to &lt;b&gt;eLua&lt;/b&gt; (which makes sense, since you're most likely going to run &lt;b&gt;eLua&lt;/b&gt; on a board built around the CPU 
   of your choice, not only on the CPU itself). So follow the instruction from the &lt;a href=&quot;arch_newport.html#newboard&quot;&gt;previous paragraph&lt;/a&gt; to add
   your new board.&lt;/li&gt;
   &lt;li&gt;customize the &lt;b&gt;eLua&lt;/b&gt; image for this new CPU. You can use the variable &lt;b&gt;cputype&lt;/b&gt; in &lt;b&gt;conf.py&lt;/b&gt; to define new preprocessor macros specifically for your CPU
   (that you can use later in &lt;b&gt;platform_conf.h&lt;/b&gt;, for example), or to include or exclude certain files from the build, or change the build flags and so on. An example taken from 
   the &lt;b&gt;at91sam7x&lt;/b&gt; port is given below (part of &lt;b&gt;conf.py&lt;/b&gt;):
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;if cputype == 'AT91SAM7X256':
+&lt;pre&gt;&lt;code&gt;if cputype == 'AT91SAM7X256':
   ldscript = &quot;flash256.lds&quot;
   cdefs = cdefs + &quot; -Dat91sam7x256&quot;
 elif cputype == 'AT91SAM7X512':
@@ -103,25 +103,25 @@
   cdefs = cdefs + &quot; -Dat91sam7x512&quot;
 else:
   print &quot;Invalid AT91SAM7X CPU %s&quot; % cputype
-  sys.exit( -1 ) &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
-&lt;/ol&gt;&lt;/p&gt;
+  sys.exit( -1 ) &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+&lt;/ol&gt;
 &lt;p&gt;After you edit all the relevant source files, all you have to do is to execute &lt;i&gt;scons board=&lt;boardname&gt;&lt;/i&gt; and you'll have &lt;b&gt;eLua&lt;/b&gt; compiled for your board (and implicitly for
   your new CPU).&lt;/p&gt;
-&lt;a name=&quot;newplatform&quot;&gt;&lt;h3&gt;Adding a new platform&lt;/h3&gt;&lt;/a&gt;
+&lt;a name=&quot;newplatform&quot; /&gt;&lt;h3&gt;Adding a new platform&lt;/h3&gt;
 &lt;p&gt;If you want to add a new CPU to &lt;b&gt;eLua&lt;/b&gt; and the new CPU is not supported by a platform on which &lt;b&gt;eLua&lt;/b&gt; already runs (see &lt;a href=&quot;status.html&quot;&gt;here&lt;/a&gt; for a full list), you have to
 go the whole way and add a completely new platform to &lt;b&gt;eLua&lt;/b&gt;. This is certainly more difficult than the previous cases, but still not that hard. Remember to start small (implement only
 minimal support at first) and don't write everything from scratch, start from an already existing platform implementation and work your way up from there. The &lt;b&gt;i386&lt;/b&gt; port is the simplest, 
 but also a bit different from the embedded ports. Another port that is quite simple at this point is the &lt;b&gt;lpc2888&lt;/b&gt; port, you might take a look at that too. After you &quot;get a feeling&quot; of
-how a port should look like, and after you read about the architecture of &lt;b&gt;eLua&lt;/b&gt; and the structure of a port &lt;a href=&quot;arch_overview.html&quot;&gt;here&lt;/a&gt;, follow the steps below:
+how a port should look like, and after you read about the architecture of &lt;b&gt;eLua&lt;/b&gt; and the structure of a port &lt;a href=&quot;arch_overview.html&quot;&gt;here&lt;/a&gt;, follow the steps below:&lt;/p&gt;
 &lt;ol&gt;
   &lt;li&gt;choose the name of your new platform. It should be an easy, descriptive name. For example, all the CPUs from the LM3S series are grouped inside a platform called &lt;b&gt;lm3s&lt;/b&gt;.&lt;/li&gt;
   &lt;li&gt;create the &lt;i&gt;src/platform/&lt;name&gt;&lt;/i&gt; directory, and add all your platform-specific files here. Check &lt;a href=&quot;arch_overview.html#platforms&quot;&gt;here&lt;/a&gt; for specific details.&lt;/li&gt;
-  &lt;li&gt;use the instructions from the &lt;a href=&quot;arch_newport.html#newcpu&quot;&gt;previous paragraph&lt;/a&gt; to add your new CPU and board to &lt;b&gt;eLua&lt;/b&gt;.&lt;/b&gt;
+  &lt;li&gt;use the instructions from the &lt;a href=&quot;arch_newport.html#newcpu&quot;&gt;previous paragraph&lt;/a&gt; to add your new CPU and board to &lt;b&gt;eLua&lt;/b&gt;.&lt;/li&gt;
   &lt;li&gt;implement as much as you need from the &lt;a href=&quot;arch_platform.html&quot;&gt;platform interface&lt;/a&gt;.&lt;/li&gt;
   &lt;li&gt;if your new platform uses a toolchain that wasn't previously configured in &lt;b&gt;eLua&lt;/b&gt;, add it now (see &lt;a href=&quot;toolchains.html&quot;&gt;here&lt;/a&gt; for more details about toolchains).&lt;/li&gt;
   &lt;li&gt;let &lt;b&gt;SConstruct&lt;/b&gt; know about your new platform by modifying the &lt;b&gt;platform_list&lt;/b&gt; variable to add information about the CPU(s) available for your platform and about its toolchains. 
 An example is given below:
-&lt;p&gt;&lt;pre&gt;&lt;code&gt;# List of platform/CPU/toolchains combinations
+&lt;pre&gt;&lt;code&gt;# List of platform/CPU/toolchains combinations
 # The first toolchain in the toolchains list is the default one
 # (the one that will be used if none is specified)
 platform_list = {
@@ -129,9 +129,8 @@
   'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'str9' : { 'cpus' : [ 'STR912FAW44' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   ..................
-}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
-  &lt;/ul&gt;&lt;/li&gt;
-&lt;/ol&gt;&lt;/p&gt;
+}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+&lt;/ol&gt;
 &lt;p&gt;After you edit all the relevant source files, all you have to do is to execute &lt;i&gt;scons board=&lt;boardname&gt;&lt;/i&gt; and you'll have &lt;b&gt;eLua&lt;/b&gt; compiled for your board (and implicitly for
   your new CPU).&lt;/p&gt;
 $$FOOTER$$

Modified: tags/pre0.6/doc/en/arch_tcpip.html
===================================================================
--- tags/pre0.6/doc/en/arch_tcpip.html	2009-08-27 01:14:01 UTC (rev 412)
+++ tags/pre0.6/doc/en/arch_tcpip.html	2009-08-27 17:35:32 UTC (rev 413)
@@ -1,9 +1,9 @@
 $$HEADER$$
-&lt;h3&gt;TCP/IP in eLua &lt;font color=&quot;red&quot;&gt;(WIP)&lt;/font&gt;&lt;/h3&gt;
+&lt;h3&gt;TCP/IP in eLua &lt;span class=&quot;warning&quot;&gt;(WIP)&lt;/span&gt;&lt;/h3&gt;
 &lt;p&gt;&lt;b&gt;eLua&lt;/b&gt;'s TCP/IP support was designed with flexibility and ease of use in mind. It
 might not provide all the functions of a &quot;full-fledged&quot; TCP/IP stack, but it's 
 still fully functional and probably easier to use than a &quot;regular&quot; (POSIX) TCP/IP
-stack. These are the services provided by the TCP/IP stack:
+stack. These are the services provided by the TCP/IP stack:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;a set of functions for network access (defined in inc/elua_net.h)&lt;/li&gt;
   &lt;li&gt;a DHCP client&lt;/li&gt;
@@ -11,9 +11,9 @@
   &lt;li&gt;a module (&lt;a href=&quot;m_net.html&quot;&gt;net&lt;/a&gt;) which can be used from Lua to access the network functions&lt;/li&gt;
   &lt;li&gt;a Telnet miniclient, which is used to support the eLua shell via TCP/IP instead of serial connections.&lt;/li&gt;
 &lt;/ul&gt;
-&lt;/p&gt;
+
 &lt;h2&gt;TCP/IP configuration&lt;/h2&gt;
-&lt;p&gt;To configure the TCP/IP subsystem, &lt;i&gt;edit src/platform/&lt;name&gt;platform_conf.h&lt;/i&gt; and:
+&lt;p&gt;To configure the TCP/IP subsystem, &lt;i&gt;edit src/platform/&lt;name&gt;platform_conf.h&lt;/i&gt; and:&lt;/p&gt;
 &lt;ol&gt;
 &lt;li&gt;&lt;b&gt;#define BUILD_UIP&lt;/b&gt; to enable TCP/IP support&lt;/li&gt;
 &lt;li&gt;if you'll be using the DHCP client, just &lt;b&gt;#define BUILD_DHCPC&lt;/b&gt; to build the 
@@ -24,19 +24,19 @@
   &lt;b&gt;#define ELUA_CONF_DEFGW0 ... ELUA_CONF_DEFGW3&lt;/b&gt; : the default gateway&lt;br&gt;
   &lt;b&gt;#define ELUA_CONF_DNS0 ... ELUA_CONF_DNS3&lt;/b&gt; : the DNS server &lt;/p&gt;
 
-  Note that you must define both &lt;b&gt;BUILD_DHCPC&lt;/b&gt; and the &lt;b&gt;ELUA_CONF_*&lt;/b&gt; macros. If the
+  &lt;p&gt;Note that you must define both &lt;b&gt;BUILD_DHCPC&lt;/b&gt; and the &lt;b&gt;ELUA_CONF_*&lt;/b&gt; macros. If the
   DHCP client fails to obtain a valid IP address, the static configuration will 
   be used instead. To use only the static configuration (and make the eLua image
-  size a bit smaller) don't define the BUILD_DHCPC client.&lt;/li&gt;
+  size a bit smaller) don't define the BUILD_DHCPC client.&lt;/p&gt;&lt;/li&gt;
 
 &lt;li&gt;&lt;b&gt;#define BUILD_DNSM&lt;/b&gt; if you want support for the DNS server.&lt;/li&gt;
 &lt;li&gt;&lt;b&gt;#define BUILD_CON_TCP&lt;/b&gt; if you want support for shell over telnet instead of
    serial. Note that you must NOT define &lt;b&gt;BUILD_CON_GENERIC&lt;/b&gt; in this case (see
    &lt;a href=&quot;arch_con_term.html&quot;&gt;here&lt;/a&gt; for details).&lt;/li&gt;
-&lt;/ol&gt;&lt;/p&gt;
+&lt;/ol&gt;
 &lt;p&gt;You'll also need an uIP configuration file (&lt;i&gt;src/platform/&lt;name&gt;/uip-conf.h&lt;/i&gt;) to configure the TCP/IP
 stack. For an example, look at &lt;i&gt;src/platform/&lt;lm3s&gt;/uip-conf.h&lt;/i&gt;. The header if quite self-explanatory, below
-you have a list of parameters that you might want to change:
+you have a list of parameters that you might want to change:&lt;/p&gt;
 &lt;ul&gt;
   &lt;li&gt;&lt;b&gt;u8_t, u16_t&lt;/b&gt;: define these types to match your platform.&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;UIP_CONF_MAX_CONNECTIONS&lt;/b&gt;: the maximum number of TCP connections that can be active at a given time.&lt;/li&gt;
@@ -48,7 +48,8 @@
     be used (for example by DNS/DHCP), so be careful if you disable this.&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;ELUA_DHCP_TIMER_ID&lt;/b&gt;: the timer ID used for the TCP/IP subsystem. Note that this should be a dedicated timer, not available to the rest 
     of the system (or available in &quot;read-only&quot; mode).&lt;/li&gt;
-&lt;/ul&gt;&lt;/p&gt;
+&lt;/ul&gt;
+
 &lt;h2&gt;TCP/IP implementation internals&lt;/h2&gt;
 &lt;p&gt;The TCP/IP support was designed in such a way that it doesn't require a specific
 TCP/IP stack implementation. To work with &lt;b&gt;eLua&lt;/b&gt;, a TCP/IP stack must simply 
@@ -60,7 +61,8 @@
 everything in a platform-independent manner, except for some functions (as few as
 possible and as simple as possible) that must be implemented by each platform.
 To illustrate the above, a short overview of the uIP integration is given below.&lt;/p&gt;
-&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;<A HREF="http://www.sics.se/~adam/uip/index.php/Main_Page">http://www.sics.se/~adam/uip/index.php/Main_Page</A>&quot;&gt;uIP&lt;/a&gt; is a minimalistic TCP/IP
+
+&lt;p&gt;&lt;a  href=&quot;<A HREF="http://www.sics.se/~adam/uip/index.php/Main_Page">http://www.sics.se/~adam/uip/index.php/Main_Page</A>&quot;&gt;uIP&lt;/a&gt; is a minimalistic TCP/IP
 stack designed specifically for resource constrained embedded systems. While the
 design and implementation of uIP are an excellent example of what can be done
 with a few kilobytes of memory, it has a number of quirks that make it hard to
@@ -69,10 +71,11 @@
 library that can be used to write uIP applications in a more &quot;traditional&quot; way,
 but it's quite restrictive. So, to use it with &lt;b&gt;eLua&lt;/b&gt;, a translation layer was
 needed. It is implemented in &lt;i&gt;src/elua_uip.c&lt;/i&gt;, and its sole purpose is to &quot;adapt&quot;
-the uIP stack to the &lt;B&gt;eLua model&lt;/b&gt;: implement the functions in &lt;i&gt;inc/elua_net.h&lt;/i&gt; and
+the uIP stack to the &lt;b&gt;eLua model&lt;/b&gt;: implement the functions in &lt;i&gt;inc/elua_net.h&lt;/i&gt; and
 you're ready to use the stack. In this case the &quot;adaption layer&quot; is quite large
-because of uIP's callback-based design.&lt;br&gt;
-To make the uIP implementation as platform-independent as possible, a special
+because of uIP's callback-based design.&lt;/p&gt;
+
+&lt;p&gt;To make the uIP implementation as platform-independent as possible, a special
 &lt;a href=&quot;&quot;&gt;##networking layer&lt;/a&gt; is added to the &lt;a href=&quot;arch.platform.html&quot;&gt;platform interface&lt;/a&gt;. 
 There are only 4 functions that must be implemented by a backend
 to use the networking layer. They might change as more TCP/IP stacks are added


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000368.html">[Elua-svn] r412 - trunk/src/modules
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#369">[ date ]</a>
              <a href="thread.html#369">[ thread ]</a>
              <a href="subject.html#369">[ subject ]</a>
              <a href="author.html#369">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
