<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r380 - in trunk: . src/platform/lm3s
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r380%20-%20in%20trunk%3A%20.%20src/platform/lm3s&In-Reply-To=%3C200908031838.n73IcdpT011166%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000336.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r380 - in trunk: . src/platform/lm3s</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r380%20-%20in%20trunk%3A%20.%20src/platform/lm3s&In-Reply-To=%3C200908031838.n73IcdpT011166%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r380 - in trunk: . src/platform/lm3s">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Mon Aug  3 20:38:39 CEST 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000336.html">[Elua-svn] r381 - trunk/src/platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#342">[ date ]</a>
              <a href="thread.html#342">[ thread ]</a>
              <a href="subject.html#342">[ subject ]</a>
              <a href="author.html#342">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-08-03 20:37:38 +0200 (Mon, 03 Aug 2009)
New Revision: 380

Added:
   trunk/src/platform/lm3s/can.c
   trunk/src/platform/lm3s/can.h
   trunk/src/platform/lm3s/hw_can.h
   trunk/src/platform/lm3s/hw_comp.h
   trunk/src/platform/lm3s/hw_epi.h
   trunk/src/platform/lm3s/hw_hibernate.h
   trunk/src/platform/lm3s/hw_i2c.h
   trunk/src/platform/lm3s/hw_i2s.h
   trunk/src/platform/lm3s/hw_qei.h
   trunk/src/platform/lm3s/hw_udma.h
   trunk/src/platform/lm3s/hw_usb.h
   trunk/src/platform/lm3s/hw_watchdog.h
   trunk/src/platform/lm3s/lm3s6918.h
   trunk/src/platform/lm3s/lm3s6965.h
   trunk/src/platform/lm3s/lm3s8962.h
   trunk/src/platform/lm3s/lm3s9b92.h
   trunk/src/platform/lm3s/rom.h
   trunk/src/platform/lm3s/rom_map.h
   trunk/src/platform/lm3s/uart.c
   trunk/src/platform/lm3s/uart.h
Modified:
   trunk/SConstruct
   trunk/src/platform/lm3s/adc.c
   trunk/src/platform/lm3s/adc.h
   trunk/src/platform/lm3s/cpu.c
   trunk/src/platform/lm3s/cpu.h
   trunk/src/platform/lm3s/debug.h
   trunk/src/platform/lm3s/ethernet.c
   trunk/src/platform/lm3s/ethernet.h
   trunk/src/platform/lm3s/flash.c
   trunk/src/platform/lm3s/flash.h
   trunk/src/platform/lm3s/gpio.c
   trunk/src/platform/lm3s/gpio.h
   trunk/src/platform/lm3s/hw_adc.h
   trunk/src/platform/lm3s/hw_ethernet.h
   trunk/src/platform/lm3s/hw_flash.h
   trunk/src/platform/lm3s/hw_gpio.h
   trunk/src/platform/lm3s/hw_ints.h
   trunk/src/platform/lm3s/hw_memmap.h
   trunk/src/platform/lm3s/hw_nvic.h
   trunk/src/platform/lm3s/hw_pwm.h
   trunk/src/platform/lm3s/hw_ssi.h
   trunk/src/platform/lm3s/hw_sysctl.h
   trunk/src/platform/lm3s/hw_timer.h
   trunk/src/platform/lm3s/hw_types.h
   trunk/src/platform/lm3s/hw_uart.h
   trunk/src/platform/lm3s/interrupt.c
   trunk/src/platform/lm3s/interrupt.h
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/platform_conf.h
   trunk/src/platform/lm3s/pwm.c
   trunk/src/platform/lm3s/pwm.h
   trunk/src/platform/lm3s/ssi.c
   trunk/src/platform/lm3s/ssi.h
   trunk/src/platform/lm3s/sysctl.c
   trunk/src/platform/lm3s/sysctl.h
   trunk/src/platform/lm3s/systick.c
   trunk/src/platform/lm3s/systick.h
   trunk/src/platform/lm3s/timer.c
   trunk/src/platform/lm3s/timer.h
Log:
Updated driver library (except for UART/USART).

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/SConstruct	2009-08-03 18:37:38 UTC (rev 380)
@@ -54,7 +54,7 @@
 # (the one that will be used if none is specified)
 platform_list = {  
   'at91sam7x' : { 'cpus' : [ 'AT91SAM7X256', 'AT91SAM7X512' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
-  'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
+  'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918', 'LM3S9B92' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'str9' : { 'cpus' : [ 'STR912FAW44' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'i386' : { 'cpus' : [ 'I386' ], 'toolchains' : [ 'i686-gcc' ] },
   'sim' : { 'cpus' : [ 'LINUX' ], 'toolchains' : [ 'i686-gcc' ] },
@@ -68,6 +68,7 @@
 board_list = { 'SAM7-EX256' : [ 'AT91SAM7X256', 'AT91SAM7X512' ],
                'EK-LM3S8962' : [ 'LM3S8962' ],
                'EK-LM3S6965' : [ 'LM3S6965' ],
+               'EK-LM3S9B92' : [ 'LM3S9B92' ],
                'STR9-COMSTICK' : [ 'STR912FAW44' ],
                'PC' : [ 'I386' ],
                'SIM' : [ 'LINUX' ],
@@ -104,6 +105,7 @@
 file_list = { 'SAM7-EX256' : [ 'bisect', 'hangman' , 'led', 'piano', 'hello', 'info', 'morse' ],
               'EK-LM3S8962' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope','adcpoll' ],
               'EK-LM3S6965' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope','adcpoll' ],
+              'EK-LM3S9B92' : [ 'bisect', 'hangman', 'lhttpd', 'led', 'hello', 'info', 'adcscope','adcpoll' ],
               'STR9-COMSTICK' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
               'PC' : [ 'bisect', 'hello', 'info', 'life', 'hangman' ],
               'SIM' : [ 'bisect', 'hello', 'info', 'life', 'hangman' ],

Modified: trunk/src/platform/lm3s/adc.c
===================================================================
--- trunk/src/platform/lm3s/adc.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/adc.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,979 +1,1317 @@
-//*****************************************************************************
-//
-// adc.c - Driver for the ADC.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup adc_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_adc.h&quot;
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;adc.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-
-//*****************************************************************************
-//
-// These defines are used by the ADC driver to simplify access to the ADC
-// sequencer's registers.
-//
-//*****************************************************************************
-#define ADC_SEQ                 (ADC_O_SSMUX0)
-#define ADC_SEQ_STEP            (ADC_O_SSMUX1 - ADC_O_SSMUX0)
-#define ADC_SSMUX               (ADC_O_SSMUX0 - ADC_O_SSMUX0)
-#define ADC_SSCTL               (ADC_O_SSCTL0 - ADC_O_SSMUX0)
-#define ADC_SSFIFO              (ADC_O_SSFIFO0 - ADC_O_SSMUX0)
-#define ADC_SSFSTAT             (ADC_O_SSFSTAT0 - ADC_O_SSMUX0)
-
-//*****************************************************************************
-//
-// The currently configured software oversampling factor for each of the ADC
-// sequencers.
-//
-//*****************************************************************************
-static unsigned char g_pucOversampleFactor[3];
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for an ADC interrupt.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param pfnHandler is a pointer to the function to be called when the
-//! ADC sample sequence interrupt occurs.
-//!
-//! This function sets the handler to be called when a sample sequence
-//! interrupt occurs.  This will enable the global interrupt in the interrupt
-//! controller; the sequence interrupt must be enabled with ADCIntEnable().  It
-//! is the interrupt handler's responsibility to clear the interrupt source via
-//! ADCIntClear().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCIntRegister(unsigned long ulBase, unsigned long ulSequenceNum,
-               void (*pfnHandler)(void))
-{
-    unsigned long ulInt;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Determine the interrupt to register based on the sequence number.
-    //
-    ulInt = INT_ADC0 + ulSequenceNum;
-
-    //
-    // Register the interrupt handler.
-    //
-    IntRegister(ulInt, pfnHandler);
-
-    //
-    // Enable the timer interrupt.
-    //
-    IntEnable(ulInt);
-}
-
-//*****************************************************************************
-//
-//! Unregisters the interrupt handler for an ADC interrupt.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This function unregisters the interrupt handler.  This will disable the
-//! global interrupt in the interrupt controller; the sequence interrupt must
-//! be disabled via ADCIntDisable().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCIntUnregister(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    unsigned long ulInt;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Determine the interrupt to unregister based on the sequence number.
-    //
-    ulInt = INT_ADC0 + ulSequenceNum;
-
-    //
-    // Disable the interrupt.
-    //
-    IntDisable(ulInt);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(ulInt);
-}
-
-//*****************************************************************************
-//
-//! Disables a sample sequence interrupt.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This function disables the requested sample sequence interrupt.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCIntDisable(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Disable this sample sequence interrupt.
-    //
-    HWREG(ulBase + ADC_O_IM) &amp;= ~(1 &lt;&lt; ulSequenceNum);
-}
-
-//*****************************************************************************
-//
-//! Enables a sample sequence interrupt.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This function enables the requested sample sequence interrupt.  Any
-//! outstanding interrupts are cleared before enabling the sample sequence
-//! interrupt.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCIntEnable(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Clear any outstanding interrupts on this sample sequence.
-    //
-    HWREG(ulBase + ADC_O_ISC) = 1 &lt;&lt; ulSequenceNum;
-
-    //
-    // Enable this sample sequence interrupt.
-    //
-    HWREG(ulBase + ADC_O_IM) |= 1 &lt;&lt; ulSequenceNum;
-}
-
-//*****************************************************************************
-//
-//! Gets the current interrupt status.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param bMasked is false if the raw interrupt status is required and true if
-//! the masked interrupt status is required.
-//!
-//! This returns the interrupt status for the specified sample sequence.
-//! Either the raw interrupt status or the status of interrupts that are
-//! allowed to reflect to the processor can be returned.
-//!
-//! \return The current raw or masked interrupt status.
-//
-//*****************************************************************************
-unsigned long
-ADCIntStatus(unsigned long ulBase, unsigned long ulSequenceNum,
-             tBoolean bMasked)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Return either the interrupt status or the raw interrupt status as
-    // requested.
-    //
-    if(bMasked)
-    {
-        return(HWREG(ulBase + ADC_O_ISC) &amp; (1 &lt;&lt; ulSequenceNum));
-    }
-    else
-    {
-        return(HWREG(ulBase + ADC_O_RIS) &amp; (1 &lt;&lt; ulSequenceNum));
-    }
-}
-
-//*****************************************************************************
-//
-//! Clears sample sequence interrupt source.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! The specified sample sequence interrupt is cleared, so that it no longer
-//! asserts.  This must be done in the interrupt handler to keep it from being
-//! called again immediately upon exit.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCIntClear(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arugments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Clear the interrupt.
-    //
-    HWREG(ulBase + ADC_O_ISC) = 1 &lt;&lt; ulSequenceNum;
-}
-
-//*****************************************************************************
-//
-//! Enables a sample sequence.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! Allows the specified sample sequence to be captured when its trigger is
-//! detected.  A sample sequence must be configured before it is enabled.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSequenceEnable(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arugments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Enable the specified sequence.
-    //
-    HWREG(ulBase + ADC_O_ACTSS) |= 1 &lt;&lt; ulSequenceNum;
-}
-
-//*****************************************************************************
-//
-//! Disables a sample sequence.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! Prevents the specified sample sequence from being captured when its trigger
-//! is detected.  A sample sequence should be disabled before it is configured.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSequenceDisable(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arugments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Disable the specified sequences.
-    //
-    HWREG(ulBase + ADC_O_ACTSS) &amp;= ~(1 &lt;&lt; ulSequenceNum);
-}
-
-//*****************************************************************************
-//
-//! Configures the trigger source and priority of a sample sequence.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param ulTrigger is the trigger source that initiates the sample sequence;
-//! must be one of the \b ADC_TRIGGER_* values.
-//! \param ulPriority is the relative priority of the sample sequence with
-//! respect to the other sample sequences.
-//!
-//! This function configures the initiation criteria for a sample sequence.
-//! Valid sample sequences range from zero to three; sequence zero will capture
-//! up to eight samples, sequences one and two will capture up to four samples,
-//! and sequence three will capture a single sample.  The trigger condition and
-//! priority (with respect to other sample sequence execution) is set.
-//!
-//! The \e ulTrigger parameter can take on the following values:
-//!
-//! - \b ADC_TRIGGER_PROCESSOR - A trigger generated by the processor, via the
-//!                              ADCProcessorTrigger() function.
-//! - \b ADC_TRIGGER_COMP0 - A trigger generated by the first analog
-//!                          comparator; configured with ComparatorConfigure().
-//! - \b ADC_TRIGGER_COMP1 - A trigger generated by the second analog
-//!                          comparator; configured with ComparatorConfigure().
-//! - \b ADC_TRIGGER_COMP2 - A trigger generated by the third analog
-//!                          comparator; configured with ComparatorConfigure().
-//! - \b ADC_TRIGGER_EXTERNAL - A trigger generated by an input from the Port
-//!                             B4 pin.
-//! - \b ADC_TRIGGER_TIMER - A trigger generated by a timer; configured with
-//!                          TimerControlTrigger().
-//! - \b ADC_TRIGGER_PWM0 - A trigger generated by the first PWM generator;
-//!                         configured with PWMGenIntTrigEnable().
-//! - \b ADC_TRIGGER_PWM1 - A trigger generated by the second PWM generator;
-//!                         configured with PWMGenIntTrigEnable().
-//! - \b ADC_TRIGGER_PWM2 - A trigger generated by the third PWM generator;
-//!                         configured with PWMGenIntTrigEnable().
-//! - \b ADC_TRIGGER_ALWAYS - A trigger that is always asserted, causing the
-//!                           sample sequence to capture repeatedly (so long as
-//!                           there is not a higher priority source active).
-//!
-//! Note that not all trigger sources are available on all Stellaris family
-//! members; consult the data sheet for the device in question to determine the
-//! availability of triggers.
-//!
-//! The \e ulPriority parameter is a value between 0 and 3, where 0 represents
-//! the highest priority and 3 the lowest.  Note that when programming the
-//! priority among a set of sample sequences, each must have unique priority;
-//! it is up to the caller to guarantee the uniqueness of the priorities.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSequenceConfigure(unsigned long ulBase, unsigned long ulSequenceNum,
-                     unsigned long ulTrigger, unsigned long ulPriority)
-{
-    //
-    // Check the arugments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-    ASSERT((ulTrigger == ADC_TRIGGER_PROCESSOR) ||
-           (ulTrigger == ADC_TRIGGER_COMP0) ||
-           (ulTrigger == ADC_TRIGGER_COMP1) ||
-           (ulTrigger == ADC_TRIGGER_COMP2) ||
-           (ulTrigger == ADC_TRIGGER_EXTERNAL) ||
-           (ulTrigger == ADC_TRIGGER_TIMER) ||
-           (ulTrigger == ADC_TRIGGER_PWM0) ||
-           (ulTrigger == ADC_TRIGGER_PWM1) ||
-           (ulTrigger == ADC_TRIGGER_PWM2) ||
-           (ulTrigger == ADC_TRIGGER_ALWAYS));
-    ASSERT(ulPriority &lt; 4);
-
-    //
-    // Compute the shift for the bits that control this sample sequence.
-    //
-    ulSequenceNum *= 4;
-
-    //
-    // Set the trigger event for this sample sequence.
-    //
-    HWREG(ulBase + ADC_O_EMUX) = ((HWREG(ulBase + ADC_O_EMUX) &amp;
-                                   ~(0xf &lt;&lt; ulSequenceNum)) |
-                                  ((ulTrigger &amp; 0xf) &lt;&lt; ulSequenceNum));
-
-    //
-    // Set the priority for this sample sequence.
-    //
-    HWREG(ulBase + ADC_O_SSPRI) = ((HWREG(ulBase + ADC_O_SSPRI) &amp;
-                                    ~(0xf &lt;&lt; ulSequenceNum)) |
-                                   ((ulPriority &amp; 0x3) &lt;&lt; ulSequenceNum));
-}
-
-//*****************************************************************************
-//
-//! Configure a step of the sample sequencer.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param ulStep is the step to be configured.
-//! \param ulConfig is the configuration of this step; must be a logical OR of
-//! \b ADC_CTL_TS, \b ADC_CTL_IE, \b ADC_CTL_END, \b ADC_CTL_D, and one of the
-//! input channel selects (\b ADC_CTL_CH0 through \b ADC_CTL_CH7).
-//!
-//! This function will set the configuration of the ADC for one step of a
-//! sample sequence.  The ADC can be configured for single-ended or
-//! differential operation (the \b ADC_CTL_D bit selects differential
-//! operation when set), the channel to be sampled can be chosen (the
-//! \b ADC_CTL_CH0 through \b ADC_CTL_CH7 values), and the internal temperature
-//! sensor can be selected (the \b ADC_CTL_TS bit).  Additionally, this step
-//! can be defined as the last in the sequence (the \b ADC_CTL_END bit) and it
-//! can be configured to cause an interrupt when the step is complete (the
-//! \b ADC_CTL_IE bit).  The configuration is used by the ADC at the
-//! appropriate time when the trigger for this sequence occurs.
-//!
-//! The \e ulStep parameter determines the order in which the samples are
-//! captured by the ADC when the trigger occurs.  It can range from zero to
-//! seven for the first sample sequence, from zero to three for the second and
-//! third sample sequence, and can only be zero for the fourth sample sequence.
-//!
-//! Differential mode only works with adjacent channel pairs (for example, 0
-//! and 1).  The channel select must be the number of the channel pair to
-//! sample (for example, \b ADC_CTL_CH0 for 0 and 1, or \b ADC_CTL_CH1 for 2
-//! and 3) or undefined results will be returned by the ADC.  Additionally, if
-//! differential mode is selected when the temperature sensor is being sampled,
-//! undefined results will be returned by the ADC.
-//!
-//! It is the responsibility of the caller to ensure that a valid configuration
-//! is specified; this function does not check the validity of the specified
-//! configuration.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSequenceStepConfigure(unsigned long ulBase, unsigned long ulSequenceNum,
-                         unsigned long ulStep, unsigned long ulConfig)
-{
-    //
-    // Check the arugments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-    ASSERT(((ulSequenceNum == 0) &amp;&amp; (ulStep &lt; 8)) ||
-           ((ulSequenceNum == 1) &amp;&amp; (ulStep &lt; 4)) ||
-           ((ulSequenceNum == 2) &amp;&amp; (ulStep &lt; 4)) ||
-           ((ulSequenceNum == 3) &amp;&amp; (ulStep &lt; 1)));
-
-    //
-    // Get the offset of the sequence to be configured.
-    //
-    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
-
-    //
-    // Compute the shift for the bits that control this step.
-    //
-    ulStep *= 4;
-
-    //
-    // Set the analog mux value for this step.
-    //
-    HWREG(ulBase + ADC_SSMUX) = ((HWREG(ulBase + ADC_SSMUX) &amp;
-                                  ~(0x0000000f &lt;&lt; ulStep)) |
-                                 ((ulConfig &amp; 0x0f) &lt;&lt; ulStep));
-
-    //
-    // Set the control value for this step.
-    //
-    HWREG(ulBase + ADC_SSCTL) = ((HWREG(ulBase + ADC_SSCTL) &amp;
-                                  ~(0x0000000f &lt;&lt; ulStep)) |
-                                 (((ulConfig &amp; 0xf0) &gt;&gt; 4) &lt;&lt; ulStep));
-}
-
-//*****************************************************************************
-//
-//! Determines if a sample sequence overflow occurred.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This determines if a sample sequence overflow has occurred.  This will
-//! happen if the captured samples are not read from the FIFO before the next
-//! trigger occurs.
-//!
-//! \return Returns zero if there was not an overflow, and non-zero if there
-//! was.
-//
-//*****************************************************************************
-long
-ADCSequenceOverflow(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Determine if there was an overflow on this sequence.
-    //
-    return(HWREG(ulBase + ADC_O_OSTAT) &amp; (1 &lt;&lt; ulSequenceNum));
-}
-
-//*****************************************************************************
-//
-//! Clears the overflow condition on a sample sequence.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This will clear an overflow condition on one of the sample sequences.  The
-//! overflow condition must be cleared in order to detect a subsequent overflow
-//! condition (it otherwise causes no harm).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSequenceOverflowClear(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Clear the overflow condition for this sequence.
-    //
-    HWREG(ulBase + ADC_O_OSTAT) = 1 &lt;&lt; ulSequenceNum;
-}
-
-//*****************************************************************************
-//
-//! Determines if a sample sequence underflow occurred.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This determines if a sample sequence underflow has occurred.  This will
-//! happen if too many samples are read from the FIFO.
-//!
-//! \return Returns zero if there was not an underflow, and non-zero if there
-//! was.
-//
-//*****************************************************************************
-long
-ADCSequenceUnderflow(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Determine if there was an underflow on this sequence.
-    //
-    return(HWREG(ulBase + ADC_O_USTAT) &amp; (1 &lt;&lt; ulSequenceNum));
-}
-
-//*****************************************************************************
-//
-//! Clears the underflow condition on a sample sequence.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This will clear an underflow condition on one of the sample sequences.  The
-//! underflow condition must be cleared in order to detect a subsequent
-//! underflow condition (it otherwise causes no harm).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSequenceUnderflowClear(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Clear the underflow condition for this sequence.
-    //
-    HWREG(ulBase + ADC_O_USTAT) = 1 &lt;&lt; ulSequenceNum;
-}
-
-//*****************************************************************************
-//
-//! Gets the captured data for a sample sequence.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param pulBuffer is the address where the data is stored.
-//!
-//! This function copies data from the specified sample sequence output FIFO to
-//! a memory resident buffer.  The number of samples available in the hardware
-//! FIFO are copied into the buffer, which is assumed to be large enough to
-//! hold that many samples.  This will only return the samples that are
-//! presently available, which may not be the entire sample sequence if it is
-//! in the process of being executed.
-//!
-//! \return Returns the number of samples copied to the buffer.
-//
-//*****************************************************************************
-long
-ADCSequenceDataGet(unsigned long ulBase, unsigned long ulSequenceNum,
-                   unsigned long *pulBuffer)
-{
-    unsigned long ulCount;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Get the offset of the sequence to be read.
-    //
-    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
-
-    //
-    // Read samples from the FIFO until it is empty.
-    //
-    ulCount = 0;
-    while(!(HWREG(ulBase + ADC_SSFSTAT) &amp; ADC_SSFSTAT0_EMPTY) &amp;&amp; (ulCount &lt; 8))
-    {
-        //
-        // Read the FIFO and copy it to the destination.
-        //
-        *pulBuffer++ = HWREG(ulBase + ADC_SSFIFO);
-
-        //
-        // Increment the count of samples read.
-        //
-        ulCount++;
-    }
-
-    //
-    // Return the number of samples read.
-    //
-    return(ulCount);
-}
-
-//*****************************************************************************
-//
-//! Causes a processor trigger for a sample sequence.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//!
-//! This function triggers a processor-initiated sample sequence if the sample
-//! sequence trigger is configured to \b ADC_TRIGGER_PROCESSOR.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCProcessorTrigger(unsigned long ulBase, unsigned long ulSequenceNum)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 4);
-
-    //
-    // Generate a processor trigger for this sample sequence.
-    //
-    HWREG(ulBase + ADC_O_PSSI) = 1 &lt;&lt; ulSequenceNum;
-}
-
-//*****************************************************************************
-//
-//! Configures the software oversampling factor of the ADC.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param ulFactor is the number of samples to be averaged.
-//!
-//! This function configures the software oversampling for the ADC, which can
-//! be used to provide better resolution on the sampled data.  Oversampling is
-//! accomplished by averaging multiple samples from the same analog input.
-//! Three different oversampling rates are supported; 2x, 4x, and 8x.
-//!
-//! Oversampling is only supported on the sample sequencers that are more than
-//! one sample in depth (that is, the fourth sample sequencer is not
-//! supported).  Oversampling by 2x (for example) divides the depth of the
-//! sample sequencer by two; so 2x oversampling on the first sample sequencer
-//! can only provide four samples per trigger.  This also means that 8x
-//! oversampling is only available on the first sample sequencer.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSoftwareOversampleConfigure(unsigned long ulBase,
-                               unsigned long ulSequenceNum,
-                               unsigned long ulFactor)
-{
-    unsigned long ulValue;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 3);
-    ASSERT(((ulFactor == 2) || (ulFactor == 4) || (ulFactor == 8)) &amp;&amp;
-           ((ulSequenceNum == 0) || (ulFactor != 8)));
-
-    //
-    // Convert the oversampling factor to a shift factor.
-    //
-    for(ulValue = 0, ulFactor &gt;&gt;= 1; ulFactor; ulValue++, ulFactor &gt;&gt;= 1)
-    {
-    }
-
-    //
-    // Save the sfiht factor.
-    //
-    g_pucOversampleFactor[ulSequenceNum] = ulValue;
-}
-
-//*****************************************************************************
-//
-//! Configures a step of the software oversampled sequencer.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param ulStep is the step to be configured.
-//! \param ulConfig is the configuration of this step.
-//!
-//! This function configures a step of the sample sequencer when using the
-//! software oversampling feature.  The number of steps available depends on
-//! the oversampling factor set by ADCSoftwareOversampleConfigure().  The value
-//! of \e ulConfig is the same as defined for ADCSequenceStepConfigure().
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSoftwareOversampleStepConfigure(unsigned long ulBase,
-                                   unsigned long ulSequenceNum,
-                                   unsigned long ulStep,
-                                   unsigned long ulConfig)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 3);
-    ASSERT(((ulSequenceNum == 0) &amp;&amp;
-            (ulStep &lt; (8 &gt;&gt; g_pucOversampleFactor[ulSequenceNum]))) ||
-           (ulStep &lt; (4 &gt;&gt; g_pucOversampleFactor[ulSequenceNum])));
-
-    //
-    // Get the offset of the sequence to be configured.
-    //
-    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
-
-    //
-    // Compute the shift for the bits that control this step.
-    //
-    ulStep *= 4 &lt;&lt; g_pucOversampleFactor[ulSequenceNum];
-
-    //
-    // Loop through the hardware steps that make up this step of the software
-    // oversampled sequence.
-    //
-    for(ulSequenceNum = 1 &lt;&lt; g_pucOversampleFactor[ulSequenceNum];
-        ulSequenceNum; ulSequenceNum--)
-    {
-        //
-        // Set the analog mux value for this step.
-        //
-        HWREG(ulBase + ADC_SSMUX) = ((HWREG(ulBase + ADC_SSMUX) &amp;
-                                      ~(0x0000000f &lt;&lt; ulStep)) |
-                                     ((ulConfig &amp; 0x0f) &lt;&lt; ulStep));
-
-        //
-        // Set the control value for this step.
-        //
-        HWREG(ulBase + ADC_SSCTL) = ((HWREG(ulBase + ADC_SSCTL) &amp;
-                                      ~(0x0000000f &lt;&lt; ulStep)) |
-                                     (((ulConfig &amp; 0xf0) &gt;&gt; 4) &lt;&lt; ulStep));
-        if(ulSequenceNum != 1)
-        {
-            HWREG(ulBase + ADC_SSCTL) &amp;= ~((ADC_SSCTL0_IE0 |
-                                            ADC_SSCTL0_END0) &lt;&lt; ulStep);
-        }
-
-        //
-        // Go to the next hardware step.
-        //
-        ulStep += 4;
-    }
-}
-
-//*****************************************************************************
-//
-//! Gets the captured data for a sample sequence using software oversampling.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulSequenceNum is the sample sequence number.
-//! \param pulBuffer is the address where the data is stored.
-//! \param ulCount is the number of samples to be read.
-//!
-//! This function copies data from the specified sample sequence output FIFO to
-//! a memory resident buffer with software oversampling applied.  The requested
-//! number of samples are copied into the data buffer; if there are not enough
-//! samples in the hardware FIFO to satisfy this many oversampled data items
-//! then incorrect results will be returned.  It is the caller's responsibility
-//! to read only the samples that are available and wait until enough data is
-//! available, for example as a result of receiving an interrupt.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCSoftwareOversampleDataGet(unsigned long ulBase, unsigned long ulSequenceNum,
-                             unsigned long *pulBuffer, unsigned long ulCount)
-{
-    unsigned long ulIdx, ulAccum;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(ulSequenceNum &lt; 3);
-    ASSERT(((ulSequenceNum == 0) &amp;&amp;
-            (ulCount &lt; (8 &gt;&gt; g_pucOversampleFactor[ulSequenceNum]))) ||
-           (ulCount &lt; (4 &gt;&gt; g_pucOversampleFactor[ulSequenceNum])));
-
-    //
-    // Get the offset of the sequence to be read.
-    //
-    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
-
-    //
-    // Read the samples from the FIFO until it is empty.
-    //
-    while(ulCount--)
-    {
-        //
-        // Compute the sum of the samples.
-        //
-        ulAccum = 0;
-        for(ulIdx = 1 &lt;&lt; g_pucOversampleFactor[ulSequenceNum]; ulIdx; ulIdx--)
-        {
-            //
-            // Read the FIFO and add it to the accumulator.
-            //
-            ulAccum += HWREG(ulBase + ADC_SSFIFO);
-        }
-
-        //
-        // Write the averaged sample to the output buffer.
-        //
-        *pulBuffer++ = ulAccum &gt;&gt; g_pucOversampleFactor[ulSequenceNum];
-    }
-}
-
-//*****************************************************************************
-//
-//! Configures the hardware oversampling factor of the ADC.
-//!
-//! \param ulBase is the base address of the ADC module.
-//! \param ulFactor is the number of samples to be averaged.
-//!
-//! This function configures the hardware oversampling for the ADC, which can
-//! be used to provide better resolution on the sampled data.  Oversampling is
-//! accomplished by averaging multiple samples from the same analog input.  Six
-//! different oversampling rates are supported; 2x, 4x, 8x, 16x, 32x, and 64x.
-//! Specifying an oversampling factor of zero will disable hardware
-//! oversampling.
-//!
-//! Hardware oversampling applies uniformly to all sample sequencers.  It does
-//! not reduce the depth of the sample sequencers like the software
-//! oversampling APIs; each sample written into the sample sequence FIFO is a
-//! fully oversampled analog input reading.
-//!
-//! Enabling hardware averaging increases the precision of the ADC at the cost
-//! of throughput.  For example, enabling 4x oversampling reduces the
-//! throughput of a 250 Ksps ADC to 62.5 Ksps.
-//!
-//! \note Hardware oversampling is available beginning with Rev C0 of the
-//! Stellaris microcontroller.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-ADCHardwareOversampleConfigure(unsigned long ulBase, unsigned long ulFactor)
-{
-    unsigned long ulValue;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ADC_BASE);
-    ASSERT(((ulFactor == 0) || (ulFactor == 2) || (ulFactor == 4) ||
-           (ulFactor == 8) || (ulFactor == 16) || (ulFactor == 32) ||
-           (ulFactor == 64)));
-
-    //
-    // Convert the oversampling factor to a shift factor.
-    //
-    for(ulValue = 0, ulFactor &gt;&gt;= 1; ulFactor; ulValue++, ulFactor &gt;&gt;= 1)
-    {
-    }
-
-    //
-    // Write the shift factor to the ADC to configure the hardware oversampler.
-    //
-    HWREG(ulBase + ADC_O_SAC) = ulValue;
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// adc.c - Driver for the ADC.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup adc_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_adc.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;adc.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// These defines are used by the ADC driver to simplify access to the ADC
+// sequencer's registers.
+//
+//*****************************************************************************
+#define ADC_SEQ                 (ADC_O_SSMUX0)
+#define ADC_SEQ_STEP            (ADC_O_SSMUX1 - ADC_O_SSMUX0)
+#define ADC_SSMUX               (ADC_O_SSMUX0 - ADC_O_SSMUX0)
+#define ADC_SSCTL               (ADC_O_SSCTL0 - ADC_O_SSMUX0)
+#define ADC_SSFIFO              (ADC_O_SSFIFO0 - ADC_O_SSMUX0)
+#define ADC_SSFSTAT             (ADC_O_SSFSTAT0 - ADC_O_SSMUX0)
+#define ADC_SSOP                (ADC_O_SSOP0 - ADC_O_SSMUX0)
+#define ADC_SSDC                (ADC_O_SSDC0 - ADC_O_SSMUX0)
+
+//*****************************************************************************
+//
+// The currently configured software oversampling factor for each of the ADC
+// sequencers.
+//
+//*****************************************************************************
+static unsigned char g_pucOversampleFactor[3];
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for an ADC interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param pfnHandler is a pointer to the function to be called when the
+//! ADC sample sequence interrupt occurs.
+//!
+//! This function sets the handler to be called when a sample sequence
+//! interrupt occurs.  This will enable the global interrupt in the interrupt
+//! controller; the sequence interrupt must be enabled with ADCIntEnable().  It
+//! is the interrupt handler's responsibility to clear the interrupt source via
+//! ADCIntClear().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntRegister(unsigned long ulBase, unsigned long ulSequenceNum,
+               void (*pfnHandler)(void))
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine the interrupt to register based on the sequence number.
+    //
+    ulInt = INT_ADC0 + ulSequenceNum;
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(ulInt, pfnHandler);
+
+    //
+    // Enable the timer interrupt.
+    //
+    IntEnable(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Unregisters the interrupt handler for an ADC interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function unregisters the interrupt handler.  This will disable the
+//! global interrupt in the interrupt controller; the sequence interrupt must
+//! be disabled via ADCIntDisable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntUnregister(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine the interrupt to unregister based on the sequence number.
+    //
+    ulInt = INT_ADC0 + ulSequenceNum;
+
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(ulInt);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Disables a sample sequence interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function disables the requested sample sequence interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntDisable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Disable this sample sequence interrupt.
+    //
+    HWREG(ulBase + ADC_O_IM) &amp;= ~(1 &lt;&lt; ulSequenceNum);
+}
+
+//*****************************************************************************
+//
+//! Enables a sample sequence interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function enables the requested sample sequence interrupt.  Any
+//! outstanding interrupts are cleared before enabling the sample sequence
+//! interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntEnable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear any outstanding interrupts on this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_ISC) = 1 &lt;&lt; ulSequenceNum;
+
+    //
+    // Enable this sample sequence interrupt.
+    //
+    HWREG(ulBase + ADC_O_IM) |= 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param bMasked is false if the raw interrupt status is required and true if
+//! the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the specified sample sequence.
+//! Either the raw interrupt status or the status of interrupts that are
+//! allowed to reflect to the processor can be returned.
+//!
+//! \return The current raw or masked interrupt status.
+//
+//*****************************************************************************
+unsigned long
+ADCIntStatus(unsigned long ulBase, unsigned long ulSequenceNum,
+             tBoolean bMasked)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    if(bMasked)
+    {
+        ulTemp = HWREG(ulBase + ADC_O_ISC) &amp; (0x10001 &lt;&lt; ulSequenceNum);
+    }
+    else
+    {
+        ulTemp = HWREG(ulBase + ADC_O_RIS) &amp; (0x10000 | (1 &lt;&lt; ulSequenceNum));
+
+        //
+        // If the Digital Comparator status bit is set, reflect it to the 
+        // appropriate sequence bit.
+        //
+        if(ulTemp &amp; 0x10000)
+        {
+            ulTemp |= 0xF0000;
+            ulTemp &amp;= ~(0x10000 &lt;&lt; ulSequenceNum);
+        }
+    }
+
+    //
+    // Return the interrupt status
+    //
+    return(ulTemp);
+}
+
+//*****************************************************************************
+//
+//! Clears sample sequence interrupt source.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! The specified sample sequence interrupt is cleared, so that it no longer
+//! asserts.  This must be done in the interrupt handler to keep it from being
+//! called again immediately upon exit.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntClear(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear the interrupt.
+    //
+    HWREG(ulBase + ADC_O_ISC) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Enables a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! Allows the specified sample sequence to be captured when its trigger is
+//! detected.  A sample sequence must be configured before it is enabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceEnable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Enable the specified sequence.
+    //
+    HWREG(ulBase + ADC_O_ACTSS) |= 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Disables a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! Prevents the specified sample sequence from being captured when its trigger
+//! is detected.  A sample sequence should be disabled before it is configured.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceDisable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Disable the specified sequences.
+    //
+    HWREG(ulBase + ADC_O_ACTSS) &amp;= ~(1 &lt;&lt; ulSequenceNum);
+}
+
+//*****************************************************************************
+//
+//! Configures the trigger source and priority of a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulTrigger is the trigger source that initiates the sample sequence;
+//! must be one of the \b ADC_TRIGGER_* values.
+//! \param ulPriority is the relative priority of the sample sequence with
+//! respect to the other sample sequences.
+//!
+//! This function configures the initiation criteria for a sample sequence.
+//! Valid sample sequences range from zero to three; sequence zero will capture
+//! up to eight samples, sequences one and two will capture up to four samples,
+//! and sequence three will capture a single sample.  The trigger condition and
+//! priority (with respect to other sample sequence execution) is set.
+//!
+//! The \e ulTrigger parameter can take on the following values:
+//!
+//! - \b ADC_TRIGGER_PROCESSOR - A trigger generated by the processor, via the
+//!                              ADCProcessorTrigger() function.
+//! - \b ADC_TRIGGER_COMP0 - A trigger generated by the first analog
+//!                          comparator; configured with ComparatorConfigure().
+//! - \b ADC_TRIGGER_COMP1 - A trigger generated by the second analog
+//!                          comparator; configured with ComparatorConfigure().
+//! - \b ADC_TRIGGER_COMP2 - A trigger generated by the third analog
+//!                          comparator; configured with ComparatorConfigure().
+//! - \b ADC_TRIGGER_EXTERNAL - A trigger generated by an input from the Port
+//!                             B4 pin.
+//! - \b ADC_TRIGGER_TIMER - A trigger generated by a timer; configured with
+//!                          TimerControlTrigger().
+//! - \b ADC_TRIGGER_PWM0 - A trigger generated by the first PWM generator;
+//!                         configured with PWMGenIntTrigEnable().
+//! - \b ADC_TRIGGER_PWM1 - A trigger generated by the second PWM generator;
+//!                         configured with PWMGenIntTrigEnable().
+//! - \b ADC_TRIGGER_PWM2 - A trigger generated by the third PWM generator;
+//!                         configured with PWMGenIntTrigEnable().
+//! - \b ADC_TRIGGER_ALWAYS - A trigger that is always asserted, causing the
+//!                           sample sequence to capture repeatedly (so long as
+//!                           there is not a higher priority source active).
+//!
+//! Note that not all trigger sources are available on all Stellaris family
+//! members; consult the data sheet for the device in question to determine the
+//! availability of triggers.
+//!
+//! The \e ulPriority parameter is a value between 0 and 3, where 0 represents
+//! the highest priority and 3 the lowest.  Note that when programming the
+//! priority among a set of sample sequences, each must have unique priority;
+//! it is up to the caller to guarantee the uniqueness of the priorities.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceConfigure(unsigned long ulBase, unsigned long ulSequenceNum,
+                     unsigned long ulTrigger, unsigned long ulPriority)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+    ASSERT((ulTrigger == ADC_TRIGGER_PROCESSOR) ||
+           (ulTrigger == ADC_TRIGGER_COMP0) ||
+           (ulTrigger == ADC_TRIGGER_COMP1) ||
+           (ulTrigger == ADC_TRIGGER_COMP2) ||
+           (ulTrigger == ADC_TRIGGER_EXTERNAL) ||
+           (ulTrigger == ADC_TRIGGER_TIMER) ||
+           (ulTrigger == ADC_TRIGGER_PWM0) ||
+           (ulTrigger == ADC_TRIGGER_PWM1) ||
+           (ulTrigger == ADC_TRIGGER_PWM2) ||
+           (ulTrigger == ADC_TRIGGER_ALWAYS));
+    ASSERT(ulPriority &lt; 4);
+
+    //
+    // Compute the shift for the bits that control this sample sequence.
+    //
+    ulSequenceNum *= 4;
+
+    //
+    // Set the trigger event for this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_EMUX) = ((HWREG(ulBase + ADC_O_EMUX) &amp;
+                                   ~(0xf &lt;&lt; ulSequenceNum)) |
+                                  ((ulTrigger &amp; 0xf) &lt;&lt; ulSequenceNum));
+
+    //
+    // Set the priority for this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_SSPRI) = ((HWREG(ulBase + ADC_O_SSPRI) &amp;
+                                    ~(0xf &lt;&lt; ulSequenceNum)) |
+                                   ((ulPriority &amp; 0x3) &lt;&lt; ulSequenceNum));
+}
+
+//*****************************************************************************
+//
+//! Configure a step of the sample sequencer.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulStep is the step to be configured.
+//! \param ulConfig is the configuration of this step; must be a logical OR of
+//! \b ADC_CTL_TS, \b ADC_CTL_IE, \b ADC_CTL_END, \b ADC_CTL_D, and one of the
+//! input channel selects (\b ADC_CTL_CH0 through \b ADC_CTL_CH15).  For parts
+//! with the Digital Comparator feature, the follow values may also be OR'd
+//! into the \e ulConfig value to enable the Digital Comparater feature:
+//! \b ADC_CTL_CE and one of the comparater selects (\b ADC_CTL_CMP0 through
+//! \b ADC_CTL_CMP7).
+//!
+//! This function will set the configuration of the ADC for one step of a
+//! sample sequence.  The ADC can be configured for single-ended or
+//! differential operation (the \b ADC_CTL_D bit selects differential
+//! operation when set), the channel to be sampled can be chosen (the
+//! \b ADC_CTL_CH0 through \b ADC_CTL_CH15 values), and the internal
+//! temperature sensor can be selected (the \b ADC_CTL_TS bit).  Additionally,
+//! this step can be defined as the last in the sequence (the \b ADC_CTL_END
+//! bit) and it can be configured to cause an interrupt when the step is
+//! complete (the \b ADC_CTL_IE bit).  If the Digital Comparators are present
+//! on the device, this step may also be configured send the ADC sample to
+//! the selected comparator (the \b ADC_CTL_CMP0 through \b ADC_CTL_CMP7
+//! values) by using the \b ADC_CTL_CE bit.  The configuration is used by the
+//! ADC at the appropriate time when the trigger for this sequence occurs.
+//!
+//! \note If the Digitial Comparator is present and enabled using the
+//! \b ADC_CTL_CE bit, the ADC sample will NOT be written into the ADC
+//! sequence data FIFO.
+//!
+//! The \e ulStep parameter determines the order in which the samples are
+//! captured by the ADC when the trigger occurs.  It can range from zero to
+//! seven for the first sample sequence, from zero to three for the second and
+//! third sample sequence, and can only be zero for the fourth sample sequence.
+//!
+//! Differential mode only works with adjacent channel pairs (for example, 0
+//! and 1).  The channel select must be the number of the channel pair to
+//! sample (for example, \b ADC_CTL_CH0 for 0 and 1, or \b ADC_CTL_CH1 for 2
+//! and 3) or undefined results will be returned by the ADC.  Additionally, if
+//! differential mode is selected when the temperature sensor is being sampled,
+//! undefined results will be returned by the ADC.
+//!
+//! It is the responsibility of the caller to ensure that a valid configuration
+//! is specified; this function does not check the validity of the specified
+//! configuration.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceStepConfigure(unsigned long ulBase, unsigned long ulSequenceNum,
+                         unsigned long ulStep, unsigned long ulConfig)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arugments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+    ASSERT(((ulSequenceNum == 0) &amp;&amp; (ulStep &lt; 8)) ||
+           ((ulSequenceNum == 1) &amp;&amp; (ulStep &lt; 4)) ||
+           ((ulSequenceNum == 2) &amp;&amp; (ulStep &lt; 4)) ||
+           ((ulSequenceNum == 3) &amp;&amp; (ulStep &lt; 1)));
+
+    //
+    // Get the offset of the sequence to be configured.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Compute the shift for the bits that control this step.
+    //
+    ulStep *= 4;
+
+    //
+    // Set the analog mux value for this step.
+    //
+    HWREG(ulBase + ADC_SSMUX) = ((HWREG(ulBase + ADC_SSMUX) &amp;
+                                  ~(0x0000000f &lt;&lt; ulStep)) |
+                                 ((ulConfig &amp; 0x0f) &lt;&lt; ulStep));
+
+    //
+    // Set the control value for this step.
+    //
+    HWREG(ulBase + ADC_SSCTL) = ((HWREG(ulBase + ADC_SSCTL) &amp;
+                                  ~(0x0000000f &lt;&lt; ulStep)) |
+                                 (((ulConfig &amp; 0xf0) &gt;&gt; 4) &lt;&lt; ulStep));
+
+    //
+    // Enable Digital Comparator if specified in the ulConfig bit-fields.
+    //
+    if(ulConfig &amp; 0x000F0000)
+    {
+        //
+        // Program the comparator for the specified step.
+        //
+        ulTemp = HWREG(ulBase + ADC_SSDC);
+        ulTemp &amp;= ~(0xF &lt;&lt; ulStep);
+        ulTemp |= (((ulConfig &amp; 0x00070000) &gt;&gt; 16) &lt;&lt; ulStep);
+        HWREG(ulBase + ADC_SSDC) = ulTemp;
+
+        //
+        // Enable the comparator.
+        //
+        ulTemp = HWREG(ulBase + ADC_SSOP);
+        ulTemp |= (1 &lt;&lt; ulStep);
+        HWREG(ulBase + ADC_SSOP) = ulTemp;
+    }
+
+    //
+    // Disable Digital Comparator if not specified.
+    //
+    else
+    {
+        ulTemp = HWREG(ulBase + ADC_SSOP);
+        ulTemp &amp;= ~(1 &lt;&lt; ulStep);
+        HWREG(ulBase + ADC_SSOP) = ulTemp;
+    }
+}
+
+//*****************************************************************************
+//
+//! Determines if a sample sequence overflow occurred.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This determines if a sample sequence overflow has occurred.  This will
+//! happen if the captured samples are not read from the FIFO before the next
+//! trigger occurs.
+//!
+//! \return Returns zero if there was not an overflow, and non-zero if there
+//! was.
+//
+//*****************************************************************************
+long
+ADCSequenceOverflow(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine if there was an overflow on this sequence.
+    //
+    return(HWREG(ulBase + ADC_O_OSTAT) &amp; (1 &lt;&lt; ulSequenceNum));
+}
+
+//*****************************************************************************
+//
+//! Clears the overflow condition on a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This will clear an overflow condition on one of the sample sequences.  The
+//! overflow condition must be cleared in order to detect a subsequent overflow
+//! condition (it otherwise causes no harm).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceOverflowClear(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear the overflow condition for this sequence.
+    //
+    HWREG(ulBase + ADC_O_OSTAT) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Determines if a sample sequence underflow occurred.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This determines if a sample sequence underflow has occurred.  This will
+//! happen if too many samples are read from the FIFO.
+//!
+//! \return Returns zero if there was not an underflow, and non-zero if there
+//! was.
+//
+//*****************************************************************************
+long
+ADCSequenceUnderflow(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine if there was an underflow on this sequence.
+    //
+    return(HWREG(ulBase + ADC_O_USTAT) &amp; (1 &lt;&lt; ulSequenceNum));
+}
+
+//*****************************************************************************
+//
+//! Clears the underflow condition on a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This will clear an underflow condition on one of the sample sequences.  The
+//! underflow condition must be cleared in order to detect a subsequent
+//! underflow condition (it otherwise causes no harm).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceUnderflowClear(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear the underflow condition for this sequence.
+    //
+    HWREG(ulBase + ADC_O_USTAT) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Gets the captured data for a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param pulBuffer is the address where the data is stored.
+//!
+//! This function copies data from the specified sample sequence output FIFO to
+//! a memory resident buffer.  The number of samples available in the hardware
+//! FIFO are copied into the buffer, which is assumed to be large enough to
+//! hold that many samples.  This will only return the samples that are
+//! presently available, which may not be the entire sample sequence if it is
+//! in the process of being executed.
+//!
+//! \return Returns the number of samples copied to the buffer.
+//
+//*****************************************************************************
+long
+ADCSequenceDataGet(unsigned long ulBase, unsigned long ulSequenceNum,
+                   unsigned long *pulBuffer)
+{
+    unsigned long ulCount;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Get the offset of the sequence to be read.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Read samples from the FIFO until it is empty.
+    //
+    ulCount = 0;
+    while(!(HWREG(ulBase + ADC_SSFSTAT) &amp; ADC_SSFSTAT0_EMPTY) &amp;&amp; (ulCount &lt; 8))
+    {
+        //
+        // Read the FIFO and copy it to the destination.
+        //
+        *pulBuffer++ = HWREG(ulBase + ADC_SSFIFO);
+
+        //
+        // Increment the count of samples read.
+        //
+        ulCount++;
+    }
+
+    //
+    // Return the number of samples read.
+    //
+    return(ulCount);
+}
+
+//*****************************************************************************
+//
+//! Causes a processor trigger for a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function triggers a processor-initiated sample sequence if the sample
+//! sequence trigger is configured to \b ADC_TRIGGER_PROCESSOR.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCProcessorTrigger(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Generate a processor trigger for this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_PSSI) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Configures the software oversampling factor of the ADC.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulFactor is the number of samples to be averaged.
+//!
+//! This function configures the software oversampling for the ADC, which can
+//! be used to provide better resolution on the sampled data.  Oversampling is
+//! accomplished by averaging multiple samples from the same analog input.
+//! Three different oversampling rates are supported; 2x, 4x, and 8x.
+//!
+//! Oversampling is only supported on the sample sequencers that are more than
+//! one sample in depth (that is, the fourth sample sequencer is not
+//! supported).  Oversampling by 2x (for example) divides the depth of the
+//! sample sequencer by two; so 2x oversampling on the first sample sequencer
+//! can only provide four samples per trigger.  This also means that 8x
+//! oversampling is only available on the first sample sequencer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSoftwareOversampleConfigure(unsigned long ulBase,
+                               unsigned long ulSequenceNum,
+                               unsigned long ulFactor)
+{
+    unsigned long ulValue;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 3);
+    ASSERT(((ulFactor == 2) || (ulFactor == 4) || (ulFactor == 8)) &amp;&amp;
+           ((ulSequenceNum == 0) || (ulFactor != 8)));
+
+    //
+    // Convert the oversampling factor to a shift factor.
+    //
+    for(ulValue = 0, ulFactor &gt;&gt;= 1; ulFactor; ulValue++, ulFactor &gt;&gt;= 1)
+    {
+    }
+
+    //
+    // Save the sfiht factor.
+    //
+    g_pucOversampleFactor[ulSequenceNum] = ulValue;
+}
+
+//*****************************************************************************
+//
+//! Configures a step of the software oversampled sequencer.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulStep is the step to be configured.
+//! \param ulConfig is the configuration of this step.
+//!
+//! This function configures a step of the sample sequencer when using the
+//! software oversampling feature.  The number of steps available depends on
+//! the oversampling factor set by ADCSoftwareOversampleConfigure().  The value
+//! of \e ulConfig is the same as defined for ADCSequenceStepConfigure().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSoftwareOversampleStepConfigure(unsigned long ulBase,
+                                   unsigned long ulSequenceNum,
+                                   unsigned long ulStep,
+                                   unsigned long ulConfig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 3);
+    ASSERT(((ulSequenceNum == 0) &amp;&amp;
+            (ulStep &lt; (8 &gt;&gt; g_pucOversampleFactor[ulSequenceNum]))) ||
+           (ulStep &lt; (4 &gt;&gt; g_pucOversampleFactor[ulSequenceNum])));
+
+    //
+    // Get the offset of the sequence to be configured.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Compute the shift for the bits that control this step.
+    //
+    ulStep *= 4 &lt;&lt; g_pucOversampleFactor[ulSequenceNum];
+
+    //
+    // Loop through the hardware steps that make up this step of the software
+    // oversampled sequence.
+    //
+    for(ulSequenceNum = 1 &lt;&lt; g_pucOversampleFactor[ulSequenceNum];
+        ulSequenceNum; ulSequenceNum--)
+    {
+        //
+        // Set the analog mux value for this step.
+        //
+        HWREG(ulBase + ADC_SSMUX) = ((HWREG(ulBase + ADC_SSMUX) &amp;
+                                      ~(0x0000000f &lt;&lt; ulStep)) |
+                                     ((ulConfig &amp; 0x0f) &lt;&lt; ulStep));
+
+        //
+        // Set the control value for this step.
+        //
+        HWREG(ulBase + ADC_SSCTL) = ((HWREG(ulBase + ADC_SSCTL) &amp;
+                                      ~(0x0000000f &lt;&lt; ulStep)) |
+                                     (((ulConfig &amp; 0xf0) &gt;&gt; 4) &lt;&lt; ulStep));
+        if(ulSequenceNum != 1)
+        {
+            HWREG(ulBase + ADC_SSCTL) &amp;= ~((ADC_SSCTL0_IE0 |
+                                            ADC_SSCTL0_END0) &lt;&lt; ulStep);
+        }
+
+        //
+        // Go to the next hardware step.
+        //
+        ulStep += 4;
+    }
+}
+
+//*****************************************************************************
+//
+//! Gets the captured data for a sample sequence using software oversampling.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param pulBuffer is the address where the data is stored.
+//! \param ulCount is the number of samples to be read.
+//!
+//! This function copies data from the specified sample sequence output FIFO to
+//! a memory resident buffer with software oversampling applied.  The requested
+//! number of samples are copied into the data buffer; if there are not enough
+//! samples in the hardware FIFO to satisfy this many oversampled data items
+//! then incorrect results will be returned.  It is the caller's responsibility
+//! to read only the samples that are available and wait until enough data is
+//! available, for example as a result of receiving an interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSoftwareOversampleDataGet(unsigned long ulBase, unsigned long ulSequenceNum,
+                             unsigned long *pulBuffer, unsigned long ulCount)
+{
+    unsigned long ulIdx, ulAccum;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 3);
+    ASSERT(((ulSequenceNum == 0) &amp;&amp;
+            (ulCount &lt; (8 &gt;&gt; g_pucOversampleFactor[ulSequenceNum]))) ||
+           (ulCount &lt; (4 &gt;&gt; g_pucOversampleFactor[ulSequenceNum])));
+
+    //
+    // Get the offset of the sequence to be read.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Read the samples from the FIFO until it is empty.
+    //
+    while(ulCount--)
+    {
+        //
+        // Compute the sum of the samples.
+        //
+        ulAccum = 0;
+        for(ulIdx = 1 &lt;&lt; g_pucOversampleFactor[ulSequenceNum]; ulIdx; ulIdx--)
+        {
+            //
+            // Read the FIFO and add it to the accumulator.
+            //
+            ulAccum += HWREG(ulBase + ADC_SSFIFO);
+        }
+
+        //
+        // Write the averaged sample to the output buffer.
+        //
+        *pulBuffer++ = ulAccum &gt;&gt; g_pucOversampleFactor[ulSequenceNum];
+    }
+}
+
+//*****************************************************************************
+//
+//! Configures the hardware oversampling factor of the ADC.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulFactor is the number of samples to be averaged.
+//!
+//! This function configures the hardware oversampling for the ADC, which can
+//! be used to provide better resolution on the sampled data.  Oversampling is
+//! accomplished by averaging multiple samples from the same analog input.  Six
+//! different oversampling rates are supported; 2x, 4x, 8x, 16x, 32x, and 64x.
+//! Specifying an oversampling factor of zero will disable hardware
+//! oversampling.
+//!
+//! Hardware oversampling applies uniformly to all sample sequencers.  It does
+//! not reduce the depth of the sample sequencers like the software
+//! oversampling APIs; each sample written into the sample sequence FIFO is a
+//! fully oversampled analog input reading.
+//!
+//! Enabling hardware averaging increases the precision of the ADC at the cost
+//! of throughput.  For example, enabling 4x oversampling reduces the
+//! throughput of a 250 Ksps ADC to 62.5 Ksps.
+//!
+//! \note Hardware oversampling is available beginning with Rev C0 of the
+//! Stellaris microcontroller.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCHardwareOversampleConfigure(unsigned long ulBase, unsigned long ulFactor)
+{
+    unsigned long ulValue;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(((ulFactor == 0) || (ulFactor == 2) || (ulFactor == 4) ||
+           (ulFactor == 8) || (ulFactor == 16) || (ulFactor == 32) ||
+           (ulFactor == 64)));
+
+    //
+    // Convert the oversampling factor to a shift factor.
+    //
+    for(ulValue = 0, ulFactor &gt;&gt;= 1; ulFactor; ulValue++, ulFactor &gt;&gt;= 1)
+    {
+    }
+
+    //
+    // Write the shift factor to the ADC to configure the hardware oversampler.
+    //
+    HWREG(ulBase + ADC_O_SAC) = ulValue;
+}
+
+//*****************************************************************************
+//
+//! Configures an ADC Digital Comparator.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulComp is the index of the comparator to configure.
+//! \param ulConfig is the configuration of the comparator.
+//!
+//! This function will configure a comparator.  The \e ulConfig parameter is
+//! the result of a logical OR operation between the \b ADC_COMP_TRIG_xxx, and
+//! \b ADC_COMP_INT_xxx values.
+//!
+//! The \b ADC_COMP_TRIG_xxx term can take on the following values:
+//!
+//! - \b ADC_COMP_TRIG_NONE to never trigger PWM fault condition.
+//! - \b ADC_COMP_TRIG_LOW_ALWAYS to always trigger PWM fault condition when
+//! ADC output is in the low-band.
+//! - \b ADC_COMP_TRIG_LOW_ONCE to trigger PWM fault condition once when ADC
+//! output transitions into the low-band.
+//! - \b ADC_COMP_TRIG_LOW_HALWAYS to always trigger PWM fault condition when
+//! ADC output is in the low-band only if ADC output has been in the high-band
+//! since the last trigger output.
+//! - \b ADC_COMP_TRIG_LOW_HONCE to trigger PWM fault condition once when ADC
+//! output transitions into low-band only if ADC output has been in the
+//! high-band since the last trigger output.
+//! - \b ADC_COMP_TRIG_MID_ALWAYS to always trigger PWM fault condition when
+//! ADC output is in the mid-band.
+//! - \b ADC_COMP_TRIG_MID_ONCE to trigger PWM fault condition once when ADC
+//! output transitions into the mid-band.
+//! - \b ADC_COMP_TRIG_HIGH_ALWAYS to always trigger PWM fault condition when
+//! ADC output is in the high-band.
+//! - \b ADC_COMP_TRIG_HIGH_ONCE to trigger PWM fault condition once when ADC
+//! output transitions into the high-band.
+//! - \b ADC_COMP_TRIG_HIGH_HALWAYS to always trigger PWM fault condition when
+//! ADC output is in the high-band only if ADC output has been in the low-band
+//! since the last trigger output.
+//! - \b ADC_COMP_TRIG_HIGH_HONCE to trigger PWM fault condition once when ADC
+//! output transitions into high-band only if ADC output has been in the
+//! low-band since the last trigger output.
+//!
+//! The \b ADC_COMP_INT_xxx term can take on the following values:
+//!
+//! - \b ADC_COMP_INT_NONE to never generate ADC interrupt.
+//! - \b ADC_COMP_INT_LOW_ALWAYS to always generate ADC interrupt when ADC
+//! output is in the low-band.
+//! - \b ADC_COMP_INT_LOW_ONCE to generate ADC interrupt once when ADC output
+//! transitions into the low-band.
+//! - \b ADC_COMP__INT_LOW_HALWAYS to always generate ADC interrupt when ADC
+//! output is in the low-band only if ADC output has been in the high-band
+//! since the last trigger output.
+//! - \b ADC_COMP_INT_LOW_HONCE to generate ADC interrupt once when ADC output
+//! transitions into low-band only if ADC output has been in the high-band
+//! since the last trigger output.
+//! - \b ADC_COMP_INT_MID_ALWAYS to always generate ADC interrupt when ADC
+//! output is in the mid-band.
+//! - \b ADC_COMP_INT_MID_ONCE to generate ADC interrupt once when ADC output
+//! transitions into the mid-band.
+//! - \b ADC_COMP_INT_HIGH_ALWAYS to always generate ADC interrupt when ADC
+//! output is in the high-band.
+//! - \b ADC_COMP_INT_HIGH_ONCE to generate ADC interrupt once when ADC output
+//! transitions into the high-band.
+//! - \b ADC_COMP_INT_HIGH_HALWAYS to always generate ADC interrupt when ADC
+//! output is in the high-band only if ADC output has been in the low-band
+//! since the last trigger output.
+//! - \b ADC_COMP_INT_HIGH_HONCE to generate ADC interrupt once when ADC output
+//! transitions into high-band only if ADC output has been in the low-band
+//! since the last trigger output.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCComparatorConfigure(unsigned long ulBase, unsigned long ulComp,
+                       unsigned long ulConfig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulComp &lt; 8);
+
+    //
+    // Save the new setting.
+    //
+    HWREG(ulBase + ADC_O_DCCTL0 + (ulComp * 4)) = ulConfig;
+}
+
+//*****************************************************************************
+//
+//! Define the ADC Digital Comparator Regions.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulComp is the index of the comparator to configure.
+//! \param ulLowRef is the reference point for the low/mid band threshold.
+//! \param ulHighRef is the reference point for the mid/high band threshold.
+//!
+//! The ADC Digital Comparator operation is based on three ADC value regions:
+//! - \b low-band is defined as any ADC value less than or equal to the
+//! \e ulLowRef value.
+//! - \b mid-band is defined as any ADC value greater than the \e ulLowRef
+//! value but less than or equal to the \e ulHighRef value.
+//! - \b high-band is defined as any ADC value greater than the \e ulHighRef
+//! value.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCComparatorRegionSet(unsigned long ulBase, unsigned long ulComp,
+                       unsigned long ulLowRef, unsigned long ulHighRef)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulComp &lt; 8);
+    ASSERT((ulLowRef &lt; 1024) &amp;&amp; (ulLowRef &lt;= ulHighRef));
+    ASSERT(ulHighRef &lt; 1024);
+
+    //
+    // Save the new region settings.
+    //
+    HWREG(ulBase + ADC_O_DCCMP0 + (ulComp * 4)) = (ulHighRef &lt;&lt; 16) | ulLowRef;
+}
+
+//*****************************************************************************
+//
+//! Resets the current ADC Digital Comparator conditions.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulComp is the index of the comparator.
+//! \param bTrigger is the flag to indicate reset of Trigger conditions.
+//! \param bInterrupt is the flag to indicate reset of Interrupt conditions.
+//!
+//! Because the Digital Comparator uses current and previous ADC values, this
+//! function is provide to allow the comparator to be reset to its initial
+//! value to prevent stale data from being used when a sequence is enabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCComparatorReset(unsigned long ulBase, unsigned long ulComp,
+                   tBoolean bTrigger, tBoolean bInterrupt)
+{
+    unsigned long ulTemp = 0;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulComp &lt; 8);
+
+    //
+    // Set the appropriate bits to reset the trigger and/or interrupt
+    // comparator conditions.
+    //
+    if(bTrigger)
+    {
+        ulTemp |= (1 &lt;&lt; (16 + ulComp));
+    }
+    if(bInterrupt)
+    {
+        ulTemp |= (1 &lt;&lt; ulComp);
+    }
+
+    HWREG(ulBase + ADC_O_DCRIC) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Disables a sample sequence comparator interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function disables the requested sample sequence comparator interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCComparatorIntDisable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Disable this sample sequence comparator interrupt.
+    //
+    HWREG(ulBase + ADC_O_IM) &amp;= ~(0x10000 &lt;&lt; ulSequenceNum);
+}
+
+//*****************************************************************************
+//
+//! Enables a sample sequence comparator interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function enables the requested sample sequence comparator interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCComparatorIntEnable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Enable this sample sequence interrupt.
+    //
+    HWREG(ulBase + ADC_O_IM) |= 0x10000 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Gets the current comparator interrupt status.
+//!
+//! \param ulBase is the base address of the ADC module.
+//!
+//! This returns the Digitial Comparator interrupt status bits.  This status
+//! is sequence agnostic.
+//!
+//! \return The current comparator interrupt status.
+//
+//*****************************************************************************
+unsigned long
+ADCComparatorIntStatus(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+
+    //
+    // Return the digitial comparator interrupt status.
+    //
+    return(HWREG(ulBase + ADC_O_DCISC));
+}
+
+//*****************************************************************************
+//
+//! Clears sample sequence comparator interrupt source.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulStatus is the bit-mapped interrupts status to clear.
+//!
+//! The specified interrupt status is cleared.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCComparatorIntClear(unsigned long ulBase, unsigned long ulStatus)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT((ulBase == ADC0_BASE) || (ulBase == ADC1_BASE));
+
+    //
+    // Clear the interrupt.
+    //
+    HWREG(ulBase + ADC_O_DCISC) = ulStatus;
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/adc.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/adc.h
===================================================================
--- trunk/src/platform/lm3s/adc.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/adc.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,141 +1,216 @@
-//*****************************************************************************
-//
-// adc.h - ADC headers for using the ADC driver functions.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __ADC_H__
-#define __ADC_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Values that can be passed to ADCSequenceConfigure as the ulTrigger
-// parameter.
-//
-//*****************************************************************************
-#define ADC_TRIGGER_PROCESSOR   0x00000000  // Processor event
-#define ADC_TRIGGER_COMP0       0x00000001  // Analog comparator 0 event
-#define ADC_TRIGGER_COMP1       0x00000002  // Analog comparator 1 event
-#define ADC_TRIGGER_COMP2       0x00000003  // Analog comparator 2 event
-#define ADC_TRIGGER_EXTERNAL    0x00000004  // External event
-#define ADC_TRIGGER_TIMER       0x00000005  // Timer event
-#define ADC_TRIGGER_PWM0        0x00000006  // PWM0 event
-#define ADC_TRIGGER_PWM1        0x00000007  // PWM1 event
-#define ADC_TRIGGER_PWM2        0x00000008  // PWM2 event
-#define ADC_TRIGGER_ALWAYS      0x0000000F  // Always event
-
-//*****************************************************************************
-//
-// Values that can be passed to ADCSequenceStepConfigure as the ulConfig
-// parameter.
-//
-//*****************************************************************************
-#define ADC_CTL_TS              0x00000080  // Temperature sensor select
-#define ADC_CTL_IE              0x00000040  // Interrupt enable
-#define ADC_CTL_END             0x00000020  // Sequence end select
-#define ADC_CTL_D               0x00000010  // Differential select
-#define ADC_CTL_CH0             0x00000000  // Input channel 0
-#define ADC_CTL_CH1             0x00000001  // Input channel 1
-#define ADC_CTL_CH2             0x00000002  // Input channel 2
-#define ADC_CTL_CH3             0x00000003  // Input channel 3
-#define ADC_CTL_CH4             0x00000004  // Input channel 4
-#define ADC_CTL_CH5             0x00000005  // Input channel 5
-#define ADC_CTL_CH6             0x00000006  // Input channel 6
-#define ADC_CTL_CH7             0x00000007  // Input channel 7
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern void ADCIntRegister(unsigned long ulBase, unsigned long ulSequenceNum,
-                           void (*pfnHandler)(void));
-extern void ADCIntUnregister(unsigned long ulBase,
-                             unsigned long ulSequenceNum);
-extern void ADCIntDisable(unsigned long ulBase, unsigned long ulSequenceNum);
-extern void ADCIntEnable(unsigned long ulBase, unsigned long ulSequenceNum);
-extern unsigned long ADCIntStatus(unsigned long ulBase,
-                                  unsigned long ulSequenceNum,
-                                  tBoolean bMasked);
-extern void ADCIntClear(unsigned long ulBase, unsigned long ulSequenceNum);
-extern void ADCSequenceEnable(unsigned long ulBase,
-                              unsigned long ulSequenceNum);
-extern void ADCSequenceDisable(unsigned long ulBase,
-                               unsigned long ulSequenceNum);
-extern void ADCSequenceConfigure(unsigned long ulBase,
-                                 unsigned long ulSequenceNum,
-                                 unsigned long ulTrigger,
-                                 unsigned long ulPriority);
-extern void ADCSequenceStepConfigure(unsigned long ulBase,
-                                     unsigned long ulSequenceNum,
-                                     unsigned long ulStep,
-                                     unsigned long ulConfig);
-extern long ADCSequenceOverflow(unsigned long ulBase,
-                                unsigned long ulSequenceNum);
-extern void ADCSequenceOverflowClear(unsigned long ulBase,
-                                     unsigned long ulSequenceNum);
-extern long ADCSequenceUnderflow(unsigned long ulBase,
-                                 unsigned long ulSequenceNum);
-extern void ADCSequenceUnderflowClear(unsigned long ulBase,
-                                      unsigned long ulSequenceNum);
-extern long ADCSequenceDataGet(unsigned long ulBase,
-                               unsigned long ulSequenceNum,
-                               unsigned long *pulBuffer);
-extern void ADCProcessorTrigger(unsigned long ulBase,
-                                unsigned long ulSequenceNum);
-extern void ADCSoftwareOversampleConfigure(unsigned long ulBase,
-                                           unsigned long ulSequenceNum,
-                                           unsigned long ulFactor);
-extern void ADCSoftwareOversampleStepConfigure(unsigned long ulBase,
-                                               unsigned long ulSequenceNum,
-                                               unsigned long ulStep,
-                                               unsigned long ulConfig);
-extern void ADCSoftwareOversampleDataGet(unsigned long ulBase,
-                                         unsigned long ulSequenceNum,
-                                         unsigned long *pulBuffer,
-                                         unsigned long ulCount);
-extern void ADCHardwareOversampleConfigure(unsigned long ulBase,
-                                           unsigned long ulFactor);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __ADC_H__
+//*****************************************************************************
+//
+// adc.h - ADC headers for using the ADC driver functions.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __ADC_H__
+#define __ADC_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to ADCSequenceConfigure as the ulTrigger
+// parameter.
+//
+//*****************************************************************************
+#define ADC_TRIGGER_PROCESSOR   0x00000000  // Processor event
+#define ADC_TRIGGER_COMP0       0x00000001  // Analog comparator 0 event
+#define ADC_TRIGGER_COMP1       0x00000002  // Analog comparator 1 event
+#define ADC_TRIGGER_COMP2       0x00000003  // Analog comparator 2 event
+#define ADC_TRIGGER_EXTERNAL    0x00000004  // External event
+#define ADC_TRIGGER_TIMER       0x00000005  // Timer event
+#define ADC_TRIGGER_PWM0        0x00000006  // PWM0 event
+#define ADC_TRIGGER_PWM1        0x00000007  // PWM1 event
+#define ADC_TRIGGER_PWM2        0x00000008  // PWM2 event
+#define ADC_TRIGGER_ALWAYS      0x0000000F  // Always event
+
+//*****************************************************************************
+//
+// Values that can be passed to ADCSequenceStepConfigure as the ulConfig
+// parameter.
+//
+//*****************************************************************************
+#define ADC_CTL_TS              0x00000080  // Temperature sensor select
+#define ADC_CTL_IE              0x00000040  // Interrupt enable
+#define ADC_CTL_END             0x00000020  // Sequence end select
+#define ADC_CTL_D               0x00000010  // Differential select
+#define ADC_CTL_CH0             0x00000000  // Input channel 0
+#define ADC_CTL_CH1             0x00000001  // Input channel 1
+#define ADC_CTL_CH2             0x00000002  // Input channel 2
+#define ADC_CTL_CH3             0x00000003  // Input channel 3
+#define ADC_CTL_CH4             0x00000004  // Input channel 4
+#define ADC_CTL_CH5             0x00000005  // Input channel 5
+#define ADC_CTL_CH6             0x00000006  // Input channel 6
+#define ADC_CTL_CH7             0x00000007  // Input channel 7
+#define ADC_CTL_CH8             0x00000008  // Input channel 8
+#define ADC_CTL_CH9             0x00000009  // Input channel 9
+#define ADC_CTL_CH10            0x0000000A  // Input channel 10
+#define ADC_CTL_CH11            0x0000000B  // Input channel 11
+#define ADC_CTL_CH12            0x0000000C  // Input channel 12
+#define ADC_CTL_CH13            0x0000000D  // Input channel 13
+#define ADC_CTL_CH14            0x0000000E  // Input channel 14
+#define ADC_CTL_CH15            0x0000000F  // Input channel 15
+#define ADC_CTL_CMP0            0x00080000  // Select Comparator 0
+#define ADC_CTL_CMP1            0x00090000  // Select Comparator 1
+#define ADC_CTL_CMP2            0x000A0000  // Select Comparator 2
+#define ADC_CTL_CMP3            0x000B0000  // Select Comparator 3
+#define ADC_CTL_CMP4            0x000C0000  // Select Comparator 4
+#define ADC_CTL_CMP5            0x000D0000  // Select Comparator 5
+#define ADC_CTL_CMP6            0x000E0000  // Select Comparator 6
+#define ADC_CTL_CMP7            0x000F0000  // Select Comparator 7
+
+//*****************************************************************************
+//
+// Values that can be passed to ADCComparatorConfigure as part of the
+// ulConfig parameter.
+//
+//*****************************************************************************
+#define ADC_COMP_TRIG_NONE      0x00000000  // Trigger Disabled
+#define ADC_COMP_TRIG_LOW_ALWAYS \
+                                0x00001000  // Trigger Low Always
+#define ADC_COMP_TRIG_LOW_ONCE  0x00001100  // Trigger Low Once
+#define ADC_COMP_TRIG_LOW_HALWAYS \
+                                0x00001200  // Trigger Low Always (Hysteresis)
+#define ADC_COMP_TRIG_LOW_HONCE 0x00001300  // Trigger Low Once (Hysteresis)
+#define ADC_COMP_TRIG_MID_ALWAYS \
+                                0x00001400  // Trigger Mid Always
+#define ADC_COMP_TRIG_MID_ONCE  0x00001500  // Trigger Mid Once
+#define ADC_COMP_TRIG_HIGH_ALWAYS \
+                                0x00001C00  // Trigger High Always
+#define ADC_COMP_TRIG_HIGH_ONCE 0x00001D00  // Trigger High Once
+#define ADC_COMP_TRIG_HIGH_HALWAYS \
+                                0x00001E00  // Trigger High Always (Hysteresis)
+#define ADC_COMP_TRIG_HIGH_HONCE \
+                                0x00001F00  // Trigger High Once (Hysteresis)
+
+#define ADC_COMP_INT_NONE       0x00000000  // Interrupt Disabled
+#define ADC_COMP_INT_LOW_ALWAYS \
+                                0x00000010  // Interrupt Low Always
+#define ADC_COMP_INT_LOW_ONCE   0x00000011  // Interrupt Low Once
+#define ADC_COMP_INT_LOW_HALWAYS \
+                                0x00000012  // Interrupt Low Always
+                                            // (Hysteresis)
+#define ADC_COMP_INT_LOW_HONCE  0x00000013  // Interrupt Low Once (Hysteresis)
+#define ADC_COMP_INT_MID_ALWAYS \
+                                0x00000014  // Interrupt Mid Always
+#define ADC_COMP_INT_MID_ONCE   0x00000015  // Interrupt Mid Once
+#define ADC_COMP_INT_HIGH_ALWAYS \
+                                0x0000001C  // Interrupt High Always
+#define ADC_COMP_INT_HIGH_ONCE  0x0000001D  // Interrupt High Once
+#define ADC_COMP_INT_HIGH_HALWAYS \
+                                0x0000001E  // Interrupt High Always
+                                            // (Hysteresis)
+#define ADC_COMP_INT_HIGH_HONCE \
+                                0x0000001F  // Interrupt High Once (Hysteresis)
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern void ADCIntRegister(unsigned long ulBase, unsigned long ulSequenceNum,
+                           void (*pfnHandler)(void));
+extern void ADCIntUnregister(unsigned long ulBase,
+                             unsigned long ulSequenceNum);
+extern void ADCIntDisable(unsigned long ulBase, unsigned long ulSequenceNum);
+extern void ADCIntEnable(unsigned long ulBase, unsigned long ulSequenceNum);
+extern unsigned long ADCIntStatus(unsigned long ulBase,
+                                  unsigned long ulSequenceNum,
+                                  tBoolean bMasked);
+extern void ADCIntClear(unsigned long ulBase, unsigned long ulSequenceNum);
+extern void ADCSequenceEnable(unsigned long ulBase,
+                              unsigned long ulSequenceNum);
+extern void ADCSequenceDisable(unsigned long ulBase,
+                               unsigned long ulSequenceNum);
+extern void ADCSequenceConfigure(unsigned long ulBase,
+                                 unsigned long ulSequenceNum,
+                                 unsigned long ulTrigger,
+                                 unsigned long ulPriority);
+extern void ADCSequenceStepConfigure(unsigned long ulBase,
+                                     unsigned long ulSequenceNum,
+                                     unsigned long ulStep,
+                                     unsigned long ulConfig);
+extern long ADCSequenceOverflow(unsigned long ulBase,
+                                unsigned long ulSequenceNum);
+extern void ADCSequenceOverflowClear(unsigned long ulBase,
+                                     unsigned long ulSequenceNum);
+extern long ADCSequenceUnderflow(unsigned long ulBase,
+                                 unsigned long ulSequenceNum);
+extern void ADCSequenceUnderflowClear(unsigned long ulBase,
+                                      unsigned long ulSequenceNum);
+extern long ADCSequenceDataGet(unsigned long ulBase,
+                               unsigned long ulSequenceNum,
+                               unsigned long *pulBuffer);
+extern void ADCProcessorTrigger(unsigned long ulBase,
+                                unsigned long ulSequenceNum);
+extern void ADCSoftwareOversampleConfigure(unsigned long ulBase,
+                                           unsigned long ulSequenceNum,
+                                           unsigned long ulFactor);
+extern void ADCSoftwareOversampleStepConfigure(unsigned long ulBase,
+                                               unsigned long ulSequenceNum,
+                                               unsigned long ulStep,
+                                               unsigned long ulConfig);
+extern void ADCSoftwareOversampleDataGet(unsigned long ulBase,
+                                         unsigned long ulSequenceNum,
+                                         unsigned long *pulBuffer,
+                                         unsigned long ulCount);
+extern void ADCHardwareOversampleConfigure(unsigned long ulBase,
+                                           unsigned long ulFactor);
+extern void ADCComparatorConfigure(unsigned long ulBase, unsigned long ulComp,
+                                   unsigned long ulConfig);
+extern void ADCComparatorRegionSet(unsigned long ulBase, unsigned long ulComp,
+                                   unsigned long ulLowRef,
+                                   unsigned long ulHighRef);
+extern void ADCComparatorReset(unsigned long ulBase, unsigned long ulComp,
+                               tBoolean bTrigger, tBoolean bInterrupt);
+extern void ADCComparatorIntDisable(unsigned long ulBase,
+                                    unsigned long ulSequenceNum);
+extern void ADCComparatorIntEnable(unsigned long ulBase,
+                                   unsigned long ulSequenceNum);
+extern unsigned long ADCComparatorIntStatus(unsigned long ulBase);
+extern void ADCComparatorIntClear(unsigned long ulBase,
+                                  unsigned long ulStatus);
+
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __ADC_H__


Property changes on: trunk/src/platform/lm3s/adc.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/can.c
===================================================================
--- trunk/src/platform/lm3s/can.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/can.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,2203 @@
+//*****************************************************************************
+//
+// can.c - Driver for the CAN module.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup can_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_can.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_nvic.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;can.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// This is the maximum number that can be stored as an 11bit Message
+// identifier.
+//
+//*****************************************************************************
+#define CAN_MAX_11BIT_MSG_ID    (0x7ff)
+
+//*****************************************************************************
+//
+// This is used as the loop delay for accessing the CAN controller registers.
+//
+//*****************************************************************************
+#define CAN_RW_DELAY            (5)
+
+//
+// The maximum CAN bit timing divisor is 13.
+//
+#define CAN_MAX_BIT_DIVISOR     (13)
+
+//
+// The minimum CAN bit timing divisor is 5.
+//
+#define CAN_MIN_BIT_DIVISOR     (5)
+
+//
+// The maximum CAN pre-divisor is 1024.
+//
+#define CAN_MAX_PRE_DIVISOR     (1024)
+
+//
+// The minimum CAN pre-divisor is 1024.
+//
+#define CAN_MIN_PRE_DIVISOR     (1024)
+
+//*****************************************************************************
+//
+// This table is used by the CANBitRateSet() API as the register defaults for
+// the bit timing values.
+//
+//*****************************************************************************
+static const unsigned short g_usCANBitValues[] =
+{
+    0x1100, // TSEG2 2, TSEG1 2, SJW 1, Divide 5
+    0x1200, // TSEG2 2, TSEG1 3, SJW 1, Divide 6
+    0x2240, // TSEG2 3, TSEG1 3, SJW 2, Divide 7
+    0x2340, // TSEG2 3, TSEG1 4, SJW 2, Divide 8
+    0x3340, // TSEG2 4, TSEG1 4, SJW 2, Divide 9
+    0x3440, // TSEG2 4, TSEG1 5, SJW 2, Divide 10
+    0x3540, // TSEG2 4, TSEG1 6, SJW 2, Divide 11
+    0x3640, // TSEG2 4, TSEG1 7, SJW 2, Divide 12
+    0x3740  // TSEG2 4, TSEG1 8, SJW 2, Divide 13
+};
+
+//*****************************************************************************
+//
+//! \internal
+//! Checks a CAN base address.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//!
+//! This function determines if a CAN controller base address is valid.
+//!
+//! \return Returns \b true if the base address is valid and \b false
+//! otherwise.
+//
+//*****************************************************************************
+#ifdef DEBUG
+static tBoolean
+CANBaseValid(unsigned long ulBase)
+{
+    return((ulBase == CAN0_BASE) || (ulBase == CAN1_BASE) ||
+           (ulBase == CAN2_BASE));
+}
+#endif
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Returns the CAN controller interrupt number.
+//!
+//! \param ulBase is the base address of the selected CAN controller
+//!
+//! Given a CAN controller base address, returns the corresponding interrupt
+//! number.
+//!
+//! This function replaces the original CANGetIntNumber() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;can.h&lt;/tt&gt; to map the original
+//! API to this API.
+//!
+//! \return Returns a CAN interrupt number, or -1 if \e ulPort is invalid.
+//
+//*****************************************************************************
+static long
+CANIntNumberGet(unsigned long ulBase)
+{
+    long lIntNumber;
+
+    //
+    // Return the interrupt number for the given CAN controller.
+    //
+    switch(ulBase)
+    {
+        //
+        // Return the interrupt number for CAN 0
+        //
+        case CAN0_BASE:
+        {
+            lIntNumber = INT_CAN0;
+            break;
+        }
+
+        //
+        // Return the interrupt number for CAN 1
+        //
+        case CAN1_BASE:
+        {
+            lIntNumber = INT_CAN1;
+            break;
+        }
+
+        //
+        // Return the interrupt number for CAN 2
+        //
+        case CAN2_BASE:
+        {
+            lIntNumber = INT_CAN2;
+            break;
+        }
+
+        //
+        // Return -1 to indicate a bad address was passed in.
+        //
+        default:
+        {
+            lIntNumber = -1;
+        }
+    }
+    return(lIntNumber);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Reads a CAN controller register.
+//!
+//! \param ulRegAddress is the full address of the CAN register to be read.
+//!
+//! This function performs the necessary synchronization to read from a CAN
+//! controller register.
+//!
+//! This function replaces the original CANReadReg() API and performs the same
+//! actions.  A macro is provided in &lt;tt&gt;can.h&lt;/tt&gt; to map the original API to
+//! this API.
+//!
+//! \note This function provides the delay required to access CAN registers.
+//! This delay is required when accessing CAN registers directly.
+//!
+//! \return Returns the value read from the register.
+//
+//*****************************************************************************
+static unsigned long
+CANRegRead(unsigned long ulRegAddress)
+{
+    volatile int iDelay;
+    unsigned long ulRetVal;
+    unsigned long ulIntNumber;
+    unsigned long ulReenableInts;
+
+    //
+    // Get the CAN interrupt number from the register base address.
+    //
+    ulIntNumber = CANIntNumberGet(ulRegAddress &amp; 0xfffff000);
+
+    //
+    // Make sure that the CAN base address was valid.
+    //
+    ASSERT(ulIntNumber != (unsigned long)-1);
+
+    //
+    // Remember current state so that CAN interrupts are only re-enabled if
+    // they were already enabled.
+    //
+    ulReenableInts = HWREG(NVIC_EN1) &amp; (1 &lt;&lt; (ulIntNumber - 48));
+
+    //
+    // If the CAN interrupt was enabled then disable it.
+    //
+    if(ulReenableInts)
+    {
+        IntDisable(ulIntNumber);
+    }
+
+    //
+    // Trigger the inital read to the CAN controller.  The value returned at
+    // this point is not valid.
+    //
+    HWREG(ulRegAddress);
+
+    //
+    // This delay is necessary for the CAN have the correct data on the bus.
+    //
+    for(iDelay = 0; iDelay &lt; CAN_RW_DELAY; iDelay++)
+    {
+    }
+
+    //
+    // Do the final read that has the valid value of the register.
+    //
+    ulRetVal = HWREG(ulRegAddress);
+
+    //
+    // Reenable CAN interrupts if they were enabled before this call.
+    //
+    if(ulReenableInts)
+    {
+        IntEnable(ulIntNumber);
+    }
+
+    return(ulRetVal);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Writes a CAN controller register.
+//!
+//! \param ulRegAddress is the full address of the CAN register to be written.
+//! \param ulRegValue is the value to write into the register specified by
+//! \e ulRegAddress.
+//!
+//! This function takes care of the synchronization necessary to write to a
+//! CAN controller register.
+//!
+//! This function replaces the original CANWriteReg() API and performs the same
+//! actions.  A macro is provided in &lt;tt&gt;can.h&lt;/tt&gt; to map the original API to
+//! this API.
+//!
+//! \note The delays in this function are required when accessing CAN registers
+//! directly.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+CANRegWrite(unsigned long ulRegAddress, unsigned long ulRegValue)
+{
+    volatile int iDelay;
+
+    //
+    // Trigger the inital write to the CAN controller.  The value will not make
+    // it out to the CAN controller for CAN_RW_DELAY cycles.
+    //
+    HWREG(ulRegAddress) = ulRegValue;
+
+    //
+    // Delay to allow the CAN controller to receive the new data.
+    //
+    for(iDelay = 0; iDelay &lt; CAN_RW_DELAY; iDelay++)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Copies data from a buffer to the CAN Data registers.
+//!
+//! \param pucData is a pointer to the data to be written out to the CAN
+//! controller's data registers.
+//! \param pulRegister is an unsigned long pointer to the first register of the
+//! CAN controller's data registers.  For example, in order to use the IF1
+//! register set on CAN controller 0, the value would be: \b CAN0_BASE \b +
+//! \b CAN_O_IF1DA1.
+//! \param iSize is the number of bytes to copy into the CAN controller.
+//!
+//! This function takes the steps necessary to copy data from a contiguous
+//! buffer in memory into the non-contiguous data registers used by the CAN
+//! controller.  This function is rarely used outside of the CANMessageSet()
+//! function.
+//!
+//! This function replaces the original CANWriteDataReg() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;can.h&lt;/tt&gt; to map the original
+//! API to this API.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+CANDataRegWrite(unsigned char *pucData, unsigned long *pulRegister, int iSize)
+{
+    int iIdx;
+    unsigned long ulValue;
+
+    //
+    // Loop always copies 1 or 2 bytes per iteration.
+    //
+    for(iIdx = 0; iIdx &lt; iSize; )
+    {
+
+        //
+        // Write out the data 16 bits at a time since this is how the registers
+        // are aligned in memory.
+        //
+        ulValue = pucData[iIdx++];
+
+        //
+        // Only write the second byte if needed otherwise it will be zero.
+        //
+        if(iIdx &lt; iSize)
+        {
+            ulValue |= (pucData[iIdx++] &lt;&lt; 8);
+        }
+        CANRegWrite((unsigned long)(pulRegister++), ulValue);
+    }
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Copies data from a buffer to the CAN Data registers.
+//!
+//! \param pucData is a pointer to the location to store the data read from the
+//! CAN controller's data registers.
+//! \param pulRegister is an unsigned long pointer to the first register of the
+//! CAN controller's data registers.  For example, in order to use the IF1
+//! register set on CAN controller 1, the value would be: \b CAN0_BASE \b +
+//! \b CAN_O_IF1DA1.
+//! \param iSize is the number of bytes to copy from the CAN controller.
+//!
+//! This function takes the steps necessary to copy data to a contiguous buffer
+//! in memory from the non-contiguous data registers used by the CAN
+//! controller.  This function is rarely used outside of the CANMessageGet()
+//! function.
+//!
+//! This function replaces the original CANReadDataReg() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;can.h&lt;/tt&gt; to map the original
+//! API to this API.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+CANDataRegRead(unsigned char *pucData, unsigned long *pulRegister, int iSize)
+{
+    int iIdx;
+    unsigned long ulValue;
+
+    //
+    // Loop always copies 1 or 2 bytes per iteration.
+    //
+    for(iIdx = 0; iIdx &lt; iSize; )
+    {
+        //
+        // Read out the data 16 bits at a time since this is how the registers
+        // are aligned in memory.
+        //
+        ulValue = CANRegRead((unsigned long)(pulRegister++));
+
+        //
+        // Store the first byte.
+        //
+        pucData[iIdx++] = (unsigned char)ulValue;
+
+        //
+        // Only read the second byte if needed.
+        //
+        if(iIdx &lt; iSize)
+        {
+            pucData[iIdx++] = (unsigned char)(ulValue &gt;&gt; 8);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Initializes the CAN controller after reset.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//!
+//! After reset, the CAN controller is left in the disabled state.  However,
+//! the memory used for message objects contains undefined values and must be
+//! cleared prior to enabling the CAN controller the first time.  This prevents
+//! unwanted transmission or reception of data before the message objects are
+//! configured.  This function must be called before enabling the controller
+//! the first time.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANInit(unsigned long ulBase)
+{
+    int iMsg;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // Place CAN controller in init state, regardless of previous state.  This
+    // will put controller in idle, and allow the message object RAM to be
+    // programmed.
+    //
+    CANRegWrite(ulBase + CAN_O_CTL, CAN_CTL_INIT);
+
+    //
+    // Wait for busy bit to clear
+    //
+    while(CANRegRead(ulBase + CAN_O_IF1CRQ) &amp; CAN_IF1CRQ_BUSY)
+    {
+    }
+
+    //
+    // Clear the message value bit in the arbitration register.  This indicates
+    // the message is not valid and is a &quot;safe&quot; condition to leave the message
+    // object.  The same arb reg is used to program all the message objects.
+    //
+    CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_ARB |
+                CAN_IF1CMSK_CONTROL);
+    CANRegWrite(ulBase + CAN_O_IF1ARB2, 0);
+    CANRegWrite(ulBase + CAN_O_IF1MCTL, 0);
+
+    //
+    // Loop through to program all 32 message objects
+    //
+    for(iMsg = 1; iMsg &lt;= 32; iMsg++)
+    {
+        //
+        // Wait for busy bit to clear
+        //
+        while(CANRegRead(ulBase + CAN_O_IF1CRQ) &amp; CAN_IF1CRQ_BUSY)
+        {
+        }
+
+        //
+        // Initiate programming the message object
+        //
+        CANRegWrite(ulBase + CAN_O_IF1CRQ, iMsg);
+    }
+
+    //
+    // Make sure that the interrupt and new data flags are updated for the
+    // message objects.
+    //
+    CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_NEWDAT |
+                CAN_IF1CMSK_CLRINTPND);
+
+    //
+    // Loop through to program all 32 message objects
+    //
+    for(iMsg = 1; iMsg &lt;= 32; iMsg++)
+    {
+        //
+        // Wait for busy bit to clear.
+        //
+        while(CANRegRead(ulBase + CAN_O_IF1CRQ) &amp; CAN_IF1CRQ_BUSY)
+        {
+        }
+
+        //
+        // Initiate programming the message object
+        //
+        CANRegWrite(ulBase + CAN_O_IF1CRQ, iMsg);
+    }
+
+    //
+    // Acknowledge any pending status interrupts.
+    //
+    CANRegRead(ulBase + CAN_O_STS);
+}
+
+//*****************************************************************************
+//
+//! Enables the CAN controller.
+//!
+//! \param ulBase is the base address of the CAN controller to enable.
+//!
+//! Enables the CAN controller for message processing.  Once enabled, the
+//! controller will automatically transmit any pending frames, and process any
+//! received frames.  The controller can be stopped by calling CANDisable().
+//! Prior to calling CANEnable(), CANInit() should have been called to
+//! initialize the controller and the CAN bus clock should be configured by
+//! calling CANBitTimingSet().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANEnable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // Clear the init bit in the control register.
+    //
+    CANRegWrite(ulBase + CAN_O_CTL,
+                CANRegRead(ulBase + CAN_O_CTL) &amp; ~CAN_CTL_INIT);
+}
+
+//*****************************************************************************
+//
+//! Disables the CAN controller.
+//!
+//! \param ulBase is the base address of the CAN controller to disable.
+//!
+//! Disables the CAN controller for message processing.  When disabled, the
+//! controller will no longer automatically process data on the CAN bus.  The
+//! controller can be restarted by calling CANEnable().  The state of the CAN
+//! controller and the message objects in the controller are left as they were
+//! before this call was made.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANDisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // Set the init bit in the control register.
+    //
+    CANRegWrite(ulBase + CAN_O_CTL,
+                CANRegRead(ulBase + CAN_O_CTL) | CAN_CTL_INIT);
+}
+
+//*****************************************************************************
+//
+//! Reads the current settings for the CAN controller bit timing.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param pClkParms is a pointer to a structure to hold the timing parameters.
+//!
+//! This function reads the current configuration of the CAN controller bit
+//! clock timing, and stores the resulting information in the structure
+//! supplied by the caller.  Refer to CANBitTimingSet() for the meaning of the
+//! values that are returned in the structure pointed to by \e pClkParms.
+//!
+//! This function replaces the original CANGetBitTiming() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;can.h&lt;/tt&gt; to map the original
+//! API to this API.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANBitTimingGet(unsigned long ulBase, tCANBitClkParms *pClkParms)
+{
+    unsigned int uBitReg;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT(pClkParms != 0);
+
+    //
+    // Read out all the bit timing values from the CAN controller registers.
+    //
+    uBitReg = CANRegRead(ulBase + CAN_O_BIT);
+
+    //
+    // Set the phase 2 segment.
+    //
+    pClkParms-&gt;uPhase2Seg = ((uBitReg &amp; CAN_BIT_TSEG2_M) &gt;&gt; 12) + 1;
+
+    //
+    // Set the phase 1 segment.
+    //
+    pClkParms-&gt;uSyncPropPhase1Seg = ((uBitReg &amp; CAN_BIT_TSEG1_M) &gt;&gt; 8) + 1;
+
+    //
+    // Set the sychronous jump width.
+    //
+    pClkParms-&gt;uSJW = ((uBitReg &amp; CAN_BIT_SJW_M) &gt;&gt; 6) + 1;
+
+    //
+    // Set the pre-divider for the CAN bus bit clock.
+    //
+    pClkParms-&gt;uQuantumPrescaler =
+        ((uBitReg &amp; CAN_BIT_BRP_M) |
+         ((CANRegRead(ulBase + CAN_O_BRPE) &amp; CAN_BRPE_BRPE_M) &lt;&lt; 6)) + 1;
+}
+
+//*****************************************************************************
+//
+//! This function is used to set the CAN bit timing values to a nominal setting
+//! based on a desired bit rate.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param ulSourceClock is the system clock for the device in Hz.
+//! \param ulBitRate is the desired bit rate.
+//!
+//! This function will set the CAN bit timing for the bit rate passed in the
+//! \e ulBitRate parameter based on the \e ulSourceClock parameter.  Since the
+//! CAN clock is based off of the system clock the calling function should pass
+//! in the source clock rate either by retrieving it from SysCtlClockGet() or
+//! using a specific value in Hz.  The CAN bit clock is calculated to be an
+//! average timing value that should work for most systems.  If tighter timing
+//! requirements are needed, then the CANBitTimingSet() function is available
+//! for full customization of all of the CAN bit timing values.  Since not all
+//! bit rates can be matched exactly, the bit rate is set to the value closest
+//! to the desired bit rate without being higher than the \e ulBitRate value.
+//!
+//! \note On some devices the source clock is fixed at 8MHz so the
+//! \e ulSourceClock should be set to 8000000.
+//!
+//! \return This function returns the bit rate that the CAN controller was
+//! configured to use or it returns 0 to indicate that the bit rate was not
+//! changed because the requested bit rate was not valid.
+//!
+//*****************************************************************************
+unsigned long
+CANBitRateSet(unsigned long ulBase, unsigned long ulSourceClock,
+              unsigned long ulBitRate)
+{
+    unsigned long ulDesiredRatio;
+    unsigned long ulCANBits;
+    unsigned long ulPreDivide;
+    unsigned long ulRegValue;
+    unsigned short usCANCTL;
+
+    ASSERT(ulBitRate != 0);
+
+    //
+    // Caclulate the desired clock rate.
+    //
+    ulDesiredRatio = ulSourceClock / ulBitRate;
+
+    //
+    // If the ratio of CAN bit rate to processor clock is too small or too
+    // large then return 0 indicating that no bit rate was set.
+    //
+    if((ulDesiredRatio &gt; (CAN_MIN_PRE_DIVISOR * CAN_MIN_BIT_DIVISOR)) ||
+       (ulDesiredRatio &lt; CAN_MIN_BIT_DIVISOR))
+    {
+        return(0);
+    }
+
+    //
+    // Make sure that the Desired Ratio is not too large.  This enforces the
+    // requirement that the bit rate is larger than requested.
+    //
+    if((ulSourceClock / ulDesiredRatio) &gt; ulBitRate)
+    {
+        ulDesiredRatio += 1;
+    }
+
+    //
+    // Check all possible values to find a matching value.
+    //
+    while(ulDesiredRatio &lt;= CAN_MAX_PRE_DIVISOR * CAN_MAX_BIT_DIVISOR)
+    {
+        //
+        // Loop through all possible CAN bit divisors.
+        //
+        for(ulCANBits = CAN_MAX_BIT_DIVISOR; ulCANBits &gt;= CAN_MIN_BIT_DIVISOR;
+            ulCANBits--)
+        {
+            //
+            // For a given CAN bit divisor save the pre divisor.
+            //
+            ulPreDivide = ulDesiredRatio / ulCANBits;
+
+            //
+            // If the caculated divisors match the desired clock ratio then
+            // return these bit rate and set the CAN bit timing.
+            //
+            if((ulPreDivide * ulCANBits) == ulDesiredRatio)
+            {
+                //
+                // Start building the bit timing value by adding the bit timing
+                // in time quanta.
+                //
+                ulRegValue = g_usCANBitValues[ulCANBits - CAN_MIN_BIT_DIVISOR];
+
+                //
+                // To set the bit timing register, the controller must be placed
+                // in init mode (if not already), and also configuration change
+                // bit enabled.  The stat of the register should be saved
+                // so it can be restored.
+                //
+                usCANCTL = CANRegRead(ulBase + CAN_O_CTL);
+                CANRegWrite(ulBase + CAN_O_CTL, usCANCTL | CAN_CTL_INIT |
+                                                CAN_CTL_CCE);
+
+                //
+                // Now add in the pre-scalar on the bit rate.
+                //
+                ulRegValue |= ((ulPreDivide - 1)&amp; CAN_BIT_BRP_M);
+
+                //
+                // Set the clock bits in the and the lower bits of the
+                // pre-scalar.
+                //
+                CANRegWrite(ulBase + CAN_O_BIT, ulRegValue);
+
+                //
+                // Set the divider upper bits in the extension register.
+                //
+                CANRegWrite(ulBase + CAN_O_BRPE,
+                            ((ulPreDivide - 1) &gt;&gt; 6) &amp; CAN_BRPE_BRPE_M);
+
+                //
+                // Restore the saved CAN Control register.
+                //
+                CANRegWrite(ulBase + CAN_O_CTL, usCANCTL);
+
+                //
+                // Return the computed bit rate.
+                //
+                return(ulSourceClock / ( ulPreDivide * ulCANBits));
+            }
+        }
+
+        //
+        // Move the divisor up one and look again.  Only in rare cases are
+        // more than 2 loops required to find the value.
+        //
+        ulDesiredRatio++;
+    }
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Configures the CAN controller bit timing.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param pClkParms points to the structure with the clock parameters.
+//!
+//! Configures the various timing parameters for the CAN bus bit timing:
+//! Propagation segment, Phase Buffer 1 segment, Phase Buffer 2 segment, and
+//! the Synchronization Jump Width.  The values for Propagation and Phase
+//! Buffer 1 segments are derived from the combination
+//! \e pClkParms-&gt;uSyncPropPhase1Seg parameter.  Phase Buffer 2 is determined
+//! from the \e pClkParms-&gt;uPhase2Seg parameter.  These two parameters, along
+//! with \e pClkParms-&gt;uSJW are based in units of bit time quanta.  The actual
+//! quantum time is determined by the \e pClkParms-&gt;uQuantumPrescaler value,
+//! which specifies the divisor for the CAN module clock.
+//!
+//! The total bit time, in quanta, will be the sum of the two Seg parameters,
+//! as follows:
+//!
+//! bit_time_q = uSyncPropPhase1Seg + uPhase2Seg + 1
+//!
+//! Note that the Sync_Seg is always one quantum in duration, and will be added
+//! to derive the correct duration of Prop_Seg and Phase1_Seg.
+//!
+//! The equation to determine the actual bit rate is as follows:
+//!
+//! CAN Clock /
+//! ((\e uSyncPropPhase1Seg + \e uPhase2Seg + 1) * (\e uQuantumPrescaler))
+//!
+//! This means that with \e uSyncPropPhase1Seg = 4, \e uPhase2Seg = 1,
+//! \e uQuantumPrescaler = 2 and an 8 MHz CAN clock, that the bit rate will be
+//! (8 MHz) / ((5 + 2 + 1) * 2) or 500 Kbit/sec.
+//!
+//! This function replaces the original CANSetBitTiming() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;can.h&lt;/tt&gt; to map the original
+//! API to this API.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANBitTimingSet(unsigned long ulBase, tCANBitClkParms *pClkParms)
+{
+    unsigned int uBitReg;
+    unsigned int uSavedInit;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT(pClkParms != 0);
+
+    //
+    // The phase 1 segment must be in the range from 2 to 16.
+    //
+    ASSERT((pClkParms-&gt;uSyncPropPhase1Seg &gt;= 2) &amp;&amp;
+           (pClkParms-&gt;uSyncPropPhase1Seg &lt;= 16));
+
+    //
+    // The phase 2 segment must be in the range from 1 to 8.
+    //
+    ASSERT((pClkParms-&gt;uPhase2Seg &gt;= 1) &amp;&amp; (pClkParms-&gt;uPhase2Seg &lt;= 8));
+
+    //
+    // The synchronous jump windows must be in the range from 1 to 4.
+    //
+    ASSERT((pClkParms-&gt;uSJW &gt;= 1) &amp;&amp; (pClkParms-&gt;uSJW &lt;= 4));
+
+    //
+    // The CAN clock pre-divider must be in the range from 1 to 1024.
+    //
+    ASSERT((pClkParms-&gt;uQuantumPrescaler &lt;= 1024) &amp;&amp;
+           (pClkParms-&gt;uQuantumPrescaler &gt;= 1));
+
+    //
+    // To set the bit timing register, the controller must be placed in init
+    // mode (if not already), and also configuration change bit enabled.  State
+    // of the init bit should be saved so it can be restored at the end.
+    //
+    uSavedInit = CANRegRead(ulBase + CAN_O_CTL);
+    CANRegWrite(ulBase + CAN_O_CTL, uSavedInit | CAN_CTL_INIT | CAN_CTL_CCE);
+
+    //
+    // Set the bit fields of the bit timing register according to the parms.
+    //
+    uBitReg = ((pClkParms-&gt;uPhase2Seg - 1) &lt;&lt; 12) &amp; CAN_BIT_TSEG2_M;
+    uBitReg |= ((pClkParms-&gt;uSyncPropPhase1Seg - 1) &lt;&lt; 8) &amp; CAN_BIT_TSEG1_M;
+    uBitReg |= ((pClkParms-&gt;uSJW - 1) &lt;&lt; 6) &amp; CAN_BIT_SJW_M;
+    uBitReg |= (pClkParms-&gt;uQuantumPrescaler - 1) &amp; CAN_BIT_BRP_M;
+    CANRegWrite(ulBase + CAN_O_BIT, uBitReg);
+
+    //
+    // Set the divider upper bits in the extension register.
+    //
+    CANRegWrite(ulBase + CAN_O_BRPE,
+                ((pClkParms-&gt;uQuantumPrescaler - 1) &gt;&gt; 6) &amp; CAN_BRPE_BRPE_M);
+    //
+    // Clear the config change bit, and restore the init bit.
+    //
+    uSavedInit &amp;= ~CAN_CTL_CCE;
+
+    //
+    // If Init was not set before, then clear it.
+    //
+    if(uSavedInit &amp; CAN_CTL_INIT)
+    {
+        uSavedInit &amp;= ~CAN_CTL_INIT;
+    }
+    CANRegWrite(ulBase + CAN_O_CTL, uSavedInit);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the CAN controller.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param pfnHandler is a pointer to the function to be called when the
+//! enabled CAN interrupts occur.
+//!
+//! This function registers the interrupt handler in the interrupt vector
+//! table, and enables CAN interrupts on the interrupt controller; specific CAN
+//! interrupt sources must be enabled using CANIntEnable().  The interrupt
+//! handler being registered must clear the source of the interrupt using
+//! CANIntClear().
+//!
+//! If the application is using a static interrupt vector table stored in
+//! flash, then it is not necessary to register the interrupt handler this way.
+//! Instead, IntEnable() should be used to enable CAN interrupts on the
+//! interrupt controller.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
+{
+    unsigned long ulIntNumber;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // Get the actual interrupt number for this CAN controller.
+    //
+    ulIntNumber = CANIntNumberGet(ulBase);
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(ulIntNumber, pfnHandler);
+
+    //
+    // Enable the Ethernet interrupt.
+    //
+    IntEnable(ulIntNumber);
+}
+
+//*****************************************************************************
+//
+//! Unregisters an interrupt handler for the CAN controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! This function unregisters the previously registered interrupt handler and
+//! disables the interrupt on the interrupt controller.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANIntUnregister(unsigned long ulBase)
+{
+    unsigned long ulIntNumber;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // Get the actual interrupt number for this CAN controller.
+    //
+    ulIntNumber = CANIntNumberGet(ulBase);
+
+    //
+    // Register the interrupt handler.
+    //
+    IntUnregister(ulIntNumber);
+
+    //
+    // Disable the CAN interrupt.
+    //
+    IntDisable(ulIntNumber);
+}
+
+//*****************************************************************************
+//
+//! Enables individual CAN controller interrupt sources.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
+//!
+//! Enables specific interrupt sources of the CAN controller.  Only enabled
+//! sources will cause a processor interrupt.
+//!
+//! The \e ulIntFlags parameter is the logical OR of any of the following:
+//!
+//! - \b CAN_INT_ERROR - a controller error condition has occurred
+//! - \b CAN_INT_STATUS - a message transfer has completed, or a bus error has
+//! been detected
+//! - \b CAN_INT_MASTER - allow CAN controller to generate interrupts
+//!
+//! In order to generate any interrupts, \b CAN_INT_MASTER must be enabled.
+//! Further, for any particular transaction from a message object to generate
+//! an interrupt, that message object must have interrupts enabled (see
+//! CANMessageSet()).  \b CAN_INT_ERROR will generate an interrupt if the
+//! controller enters the ``bus off'' condition, or if the error counters reach
+//! a limit.  \b CAN_INT_STATUS will generate an interrupt under quite a few
+//! status conditions and may provide more interrupts than the application
+//! needs to handle.  When an interrupt occurs, use CANIntStatus() to determine
+//! the cause.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT((ulIntFlags &amp; ~(CAN_CTL_EIE | CAN_CTL_SIE | CAN_CTL_IE)) == 0);
+
+    //
+    // Enable the specified interrupts.
+    //
+    CANRegWrite(ulBase + CAN_O_CTL,
+                CANRegRead(ulBase + CAN_O_CTL) | ulIntFlags);
+}
+
+//*****************************************************************************
+//
+//! Disables individual CAN controller interrupt sources.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
+//!
+//! Disables the specified CAN controller interrupt sources.  Only enabled
+//! interrupt sources can cause a processor interrupt.
+//!
+//! The \e ulIntFlags parameter has the same definition as in the
+//! CANIntEnable() function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT((ulIntFlags &amp; ~(CAN_CTL_EIE | CAN_CTL_SIE | CAN_CTL_IE)) == 0);
+
+    //
+    // Disable the specified interrupts.
+    //
+    CANRegWrite(ulBase + CAN_O_CTL,
+                CANRegRead(ulBase + CAN_O_CTL) &amp; ~(ulIntFlags));
+}
+
+//*****************************************************************************
+//
+//! Returns the current CAN controller interrupt status.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param eIntStsReg indicates which interrupt status register to read
+//!
+//! Returns the value of one of two interrupt status registers.  The interrupt
+//! status register read is determined by the \e eIntStsReg parameter, which
+//! can have one of the following values:
+//!
+//! - \b CAN_INT_STS_CAUSE - indicates the cause of the interrupt
+//! - \b CAN_INT_STS_OBJECT - indicates pending interrupts of all message
+//! objects
+//!
+//! \b CAN_INT_STS_CAUSE returns the value of the controller interrupt register
+//! and indicates the cause of the interrupt.  It will be a value of
+//! \b CAN_INT_INTID_STATUS if the cause is a status interrupt.  In this case,
+//! the status register should be read with the CANStatusGet() function.
+//! Calling this function to read the status will also clear the status
+//! interrupt.  If the value of the interrupt register is in the range 1-32,
+//! then this indicates the number of the highest priority message object that
+//! has an interrupt pending.  The message object interrupt can be cleared by
+//! using the CANIntClear() function, or by reading the message using
+//! CANMessageGet() in the case of a received message.  The interrupt handler
+//! can read the interrupt status again to make sure all pending interrupts are
+//! cleared before returning from the interrupt.
+//!
+//! \b CAN_INT_STS_OBJECT returns a bit mask indicating which message objects
+//! have pending interrupts.  This can be used to discover all of the pending
+//! interrupts at once, as opposed to repeatedly reading the interrupt register
+//! by using \b CAN_INT_STS_CAUSE.
+//!
+//! \return Returns the value of one of the interrupt status registers.
+//
+//*****************************************************************************
+unsigned long
+CANIntStatus(unsigned long ulBase, tCANIntStsReg eIntStsReg)
+{
+    unsigned long ulStatus;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // See which status the caller is looking for.
+    //
+    switch(eIntStsReg)
+    {
+        //
+        // The caller wants the global interrupt status for the CAN controller
+        // specified by ulBase.
+        //
+        case CAN_INT_STS_CAUSE:
+        {
+            ulStatus = CANRegRead(ulBase + CAN_O_INT);
+            break;
+        }
+
+        //
+        // The caller wants the current message status interrupt for all
+        // messages.
+        //
+        case CAN_INT_STS_OBJECT:
+        {
+            //
+            // Read and combine both 16 bit values into one 32bit status.
+            //
+            ulStatus = (CANRegRead(ulBase + CAN_O_MSG1INT) &amp;
+                        CAN_MSG1INT_INTPND_M);
+            ulStatus |= (CANRegRead(ulBase + CAN_O_MSG2INT) &lt;&lt; 16);
+            break;
+        }
+
+        //
+        // Request was for unknown status so just return 0.
+        //
+        default:
+        {
+            ulStatus = 0;
+            break;
+        }
+    }
+    //
+    // Return the interrupt status value
+    //
+    return(ulStatus);
+}
+
+//*****************************************************************************
+//
+//! Clears a CAN interrupt source.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param ulIntClr is a value indicating which interrupt source to clear.
+//!
+//! This function can be used to clear a specific interrupt source.  The
+//! \e ulIntClr parameter should be one of the following values:
+//!
+//! - \b CAN_INT_INTID_STATUS - Clears a status interrupt.
+//! - 1-32 - Clears the specified message object interrupt
+//!
+//! It is not necessary to use this function to clear an interrupt.  This
+//! should only be used if the application wants to clear an interrupt source
+//! without taking the normal interrupt action.
+//!
+//! Normally, the status interrupt is cleared by reading the controller status
+//! using CANStatusGet().  A specific message object interrupt is normally
+//! cleared by reading the message object using CANMessageGet().
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANIntClear(unsigned long ulBase, unsigned long ulIntClr)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT((ulIntClr == CAN_INT_INTID_STATUS) ||
+           ((ulIntClr&gt;=1) &amp;&amp; (ulIntClr &lt;=32)));
+
+    if(ulIntClr == CAN_INT_INTID_STATUS)
+    {
+        //
+        // Simply read and discard the status to clear the interrupt.
+        //
+        CANRegRead(ulBase + CAN_O_STS);
+    }
+    else
+    {
+        //
+        // Wait to be sure that this interface is not busy.
+        //
+        while(CANRegRead(ulBase + CAN_O_IF1CRQ) &amp; CAN_IF1CRQ_BUSY)
+        {
+        }
+
+        //
+        // Only change the interrupt pending state by setting only the
+        // CAN_IF1CMSK_CLRINTPND bit.
+        //
+        CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_CLRINTPND);
+
+        //
+        // Send the clear pending interrupt command to the CAN controller.
+        //
+        CANRegWrite(ulBase + CAN_O_IF1CRQ, ulIntClr &amp; CAN_IF1CRQ_MNUM_M);
+
+        //
+        // Wait to be sure that this interface is not busy.
+        //
+        while(CANRegRead(ulBase + CAN_O_IF1CRQ) &amp; CAN_IF1CRQ_BUSY)
+        {
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Sets the CAN controller automatic retransmission behavior.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param bAutoRetry enables automatic retransmission.
+//!
+//! Enables or disables automatic retransmission of messages with detected
+//! errors.  If \e bAutoRetry is \b true, then automatic retransmission is
+//! enabled, otherwise it is disabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANRetrySet(unsigned long ulBase, tBoolean bAutoRetry)
+{
+    unsigned long ulCtlReg;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    ulCtlReg = CANRegRead(ulBase + CAN_O_CTL);
+
+    //
+    // Conditionally set the DAR bit to enable/disable auto-retry.
+    //
+    if(bAutoRetry)
+    {
+        //
+        // Clearing the DAR bit tells the controller to not disable the
+        // auto-retry of messages which were not transmitted or received
+        // correctly.
+        //
+        ulCtlReg &amp;= ~CAN_CTL_DAR;
+    }
+    else
+    {
+        //
+        // Setting the DAR bit tells the controller to disable the auto-retry
+        // of messages which were not transmitted or received correctly.
+        //
+        ulCtlReg |= CAN_CTL_DAR;
+    }
+
+    CANRegWrite(ulBase + CAN_O_CTL, ulCtlReg);
+}
+
+//*****************************************************************************
+//
+//! Returns the current setting for automatic retransmission.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//!
+//! Reads the current setting for the automatic retransmission in the CAN
+//! controller and returns it to the caller.
+//!
+//! \return Returns \b true if automatic retransmission is enabled, \b false
+//! otherwise.
+//
+//*****************************************************************************
+tBoolean
+CANRetryGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // Read the disable automatic retry setting from the CAN controller.
+    //
+    if(CANRegRead(ulBase + CAN_O_CTL) &amp; CAN_CTL_DAR)
+    {
+        //
+        // Automatic data retransmission is not enabled.
+        //
+        return(false);
+    }
+
+    //
+    // Automatic data retransmission is enabled.
+    //
+    return(true);
+}
+
+//*****************************************************************************
+//
+//! Reads one of the controller status registers.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param eStatusReg is the status register to read.
+//!
+//! Reads a status register of the CAN controller and returns it to the caller.
+//! The different status registers are:
+//!
+//! - \b CAN_STS_CONTROL - the main controller status
+//! - \b CAN_STS_TXREQUEST - bit mask of objects pending transmission
+//! - \b CAN_STS_NEWDAT - bit mask of objects with new data
+//! - \b CAN_STS_MSGVAL - bit mask of objects with valid configuration
+//!
+//! When reading the main controller status register, a pending status
+//! interrupt will be cleared.  This should be used in the interrupt handler
+//! for the CAN controller if the cause is a status interrupt.  The controller
+//! status register fields are as follows:
+//!
+//! - \b CAN_STATUS_BUS_OFF - controller is in bus-off condition
+//! - \b CAN_STATUS_EWARN - an error counter has reached a limit of at least 96
+//! - \b CAN_STATUS_EPASS - CAN controller is in the error passive state
+//! - \b CAN_STATUS_RXOK - a message was received successfully (independent of
+//! any message filtering).
+//! - \b CAN_STATUS_TXOK - a message was successfully transmitted
+//! - \b CAN_STATUS_LEC_MSK - mask of last error code bits (3 bits)
+//! - \b CAN_STATUS_LEC_NONE - no error
+//! - \b CAN_STATUS_LEC_STUFF - stuffing error detected
+//! - \b CAN_STATUS_LEC_FORM - a format error occurred in the fixed format part
+//! of a message
+//! - \b CAN_STATUS_LEC_ACK - a transmitted message was not acknowledged
+//! - \b CAN_STATUS_LEC_BIT1 - dominant level detected when trying to send in
+//! recessive mode
+//! - \b CAN_STATUS_LEC_BIT0 - recessive level detected when trying to send in
+//! dominant mode
+//! - \b CAN_STATUS_LEC_CRC - CRC error in received message
+//!
+//! The remaining status registers are 32-bit bit maps to the message objects.
+//! They can be used to quickly obtain information about the status of all the
+//! message objects without needing to query each one.  They contain the
+//! following information:
+//!
+//! - \b CAN_STS_TXREQUEST - if a message object's TxRequest bit is set, that
+//! means that a transmission is pending on that object.  The application can
+//! use this to determine which objects are still waiting to send a message.
+//! - \b CAN_STS_NEWDAT - if a message object's NewDat bit is set, that means
+//! that a new message has been received in that object, and has not yet been
+//! picked up by the host application
+//! - \b CAN_STS_MSGVAL - if a message object's MsgVal bit is set, that means
+//! it has a valid configuration programmed.  The host application can use this
+//! to determine which message objects are empty/unused.
+//!
+//! \return Returns the value of the status register.
+//
+//*****************************************************************************
+unsigned long
+CANStatusGet(unsigned long ulBase, tCANStsReg eStatusReg)
+{
+    unsigned long ulStatus;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    switch(eStatusReg)
+    {
+        //
+        // Just return the global CAN status register since that is what was
+        // requested.
+        //
+        case CAN_STS_CONTROL:
+        {
+            ulStatus = CANRegRead(ulBase + CAN_O_STS);
+            CANRegWrite(ulBase + CAN_O_STS,
+                        ~(CAN_STS_RXOK | CAN_STS_TXOK | CAN_STS_LEC_M));
+            break;
+        }
+
+        //
+        // Combine the Transmit status bits into one 32bit value.
+        //
+        case CAN_STS_TXREQUEST:
+        {
+            ulStatus = CANRegRead(ulBase + CAN_O_TXRQ1);
+            ulStatus |= CANRegRead(ulBase + CAN_O_TXRQ2) &lt;&lt; 16;
+            break;
+        }
+
+        //
+        // Combine the New Data status bits into one 32bit value.
+        //
+        case CAN_STS_NEWDAT:
+        {
+            ulStatus = CANRegRead(ulBase + CAN_O_NWDA1);
+            ulStatus |= CANRegRead(ulBase + CAN_O_NWDA2) &lt;&lt; 16;
+            break;
+        }
+
+        //
+        // Combine the Message valid status bits into one 32bit value.
+        //
+        case CAN_STS_MSGVAL:
+        {
+            ulStatus = CANRegRead(ulBase + CAN_O_MSG1VAL);
+            ulStatus |= CANRegRead(ulBase + CAN_O_MSG2VAL) &lt;&lt; 16;
+            break;
+        }
+
+        //
+        // Unknown CAN status requested so return 0.
+        //
+        default:
+        {
+            ulStatus = 0;
+            break;
+        }
+    }
+    return(ulStatus);
+}
+
+//*****************************************************************************
+//
+//! Reads the CAN controller error counter register.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param pulRxCount is a pointer to storage for the receive error counter.
+//! \param pulTxCount is a pointer to storage for the transmit error counter.
+//!
+//! Reads the error counter register and returns the transmit and receive error
+//! counts to the caller along with a flag indicating if the controller receive
+//! counter has reached the error passive limit.  The values of the receive and
+//! transmit error counters are returned through the pointers provided as
+//! parameters.
+//!
+//! After this call, \e *pulRxCount will hold the current receive error count
+//! and \e *pulTxCount will hold the current transmit error count.
+//!
+//! \return Returns \b true if the receive error count has reached the error
+//! passive limit, and \b false if the error count is below the error passive
+//! limit.
+//
+//*****************************************************************************
+tBoolean
+CANErrCntrGet(unsigned long ulBase, unsigned long *pulRxCount,
+              unsigned long *pulTxCount)
+{
+    unsigned long ulCANError;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+
+    //
+    // Read the current count of transmit/receive errors.
+    //
+    ulCANError = CANRegRead(ulBase + CAN_O_ERR);
+
+    //
+    // Extract the error numbers from the register value.
+    //
+    *pulRxCount = (ulCANError &amp; CAN_ERR_REC_M) &gt;&gt; CAN_ERR_REC_S;
+    *pulTxCount = (ulCANError &amp; CAN_ERR_TEC_M) &gt;&gt; CAN_ERR_TEC_S;
+
+    if(ulCANError &amp; CAN_ERR_RP)
+    {
+        return(true);
+    }
+    return(false);
+}
+
+//*****************************************************************************
+//
+//! Configures a message object in the CAN controller.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param ulObjID is the object number to configure (1-32).
+//! \param pMsgObject is a pointer to a structure containing message object
+//! settings.
+//! \param eMsgType indicates the type of message for this object.
+//!
+//! This function is used to configure any one of the 32 message objects in the
+//! CAN controller.  A message object can be configured as any type of CAN
+//! message object as well as several options for automatic transmission and
+//! reception.  This call also allows the message object to be configured to
+//! generate interrupts on completion of message receipt or transmission.  The
+//! message object can also be configured with a filter/mask so that actions
+//! are only taken when a message that meets certain parameters is seen on the
+//! CAN bus.
+//!
+//! The \e eMsgType parameter must be one of the following values:
+//!
+//! - \b MSG_OBJ_TYPE_TX - CAN transmit message object.
+//! - \b MSG_OBJ_TYPE_TX_REMOTE - CAN transmit remote request message object.
+//! - \b MSG_OBJ_TYPE_RX - CAN receive message object.
+//! - \b MSG_OBJ_TYPE_RX_REMOTE - CAN receive remote request message object.
+//! - \b MSG_OBJ_TYPE_RXTX_REMOTE - CAN remote frame receive remote, then
+//! transmit message object.
+//!
+//! The message object pointed to by \e pMsgObject must be populated by the
+//! caller, as follows:
+//!
+//! - \e ulMsgID - contains the message ID, either 11 or 29 bits.
+//! - \e ulMsgIDMask - mask of bits from \e ulMsgID that must match if
+//! identifier filtering is enabled.
+//! - \e ulFlags
+//!   - Set \b MSG_OBJ_TX_INT_ENABLE flag to enable interrupt on transmission.
+//!   - Set \b MSG_OBJ_RX_INT_ENABLE flag to enable interrupt on receipt.
+//!   - Set \b MSG_OBJ_USE_ID_FILTER flag to enable filtering based on the
+//!   identifier mask specified by \e ulMsgIDMask.
+//! - \e ulMsgLen - the number of bytes in the message data.  This should be
+//! non-zero even for a remote frame; it should match the expected bytes of the
+//! data responding data frame.
+//! - \e pucMsgData - points to a buffer containing up to 8 bytes of data for a
+//! data frame.
+//!
+//! \b Example: To send a data frame or remote frame(in response to a remote
+//! request), take the following steps:
+//!
+//! -# Set \e eMsgType to \b MSG_OBJ_TYPE_TX.
+//! -# Set \e pMsgObject-&gt;ulMsgID to the message ID.
+//! -# Set \e pMsgObject-&gt;ulFlags. Make sure to set \b MSG_OBJ_TX_INT_ENABLE to
+//! allow an interrupt to be generated when the message is sent.
+//! -# Set \e pMsgObject-&gt;ulMsgLen to the number of bytes in the data frame.
+//! -# Set \e pMsgObject-&gt;pucMsgData to point to an array containing the bytes
+//! to send in the message.
+//! -# Call this function with \e ulObjID set to one of the 32 object buffers.
+//!
+//! \b Example: To receive a specific data frame, take the following steps:
+//!
+//! -# Set \e eMsgObjType to \b MSG_OBJ_TYPE_RX.
+//! -# Set \e pMsgObject-&gt;ulMsgID to the full message ID, or a partial mask to
+//! use partial ID matching.
+//! -# Set \e pMsgObject-&gt;ulMsgIDMask bits that should be used for masking
+//! during comparison.
+//! -# Set \e pMsgObject-&gt;ulFlags as follows:
+//!   - Set \b MSG_OBJ_TX_INT_ENABLE flag to be interrupted when the data frame
+//!   is received.
+//!   - Set \b MSG_OBJ_USE_ID_FILTER flag to enable identifier based filtering.
+//! -# Set \e pMsgObject-&gt;ulMsgLen to the number of bytes in the expected data
+//! frame.
+//! -# The buffer pointed to by \e pMsgObject-&gt;pucMsgData  and
+//! \e pMsgObject-&gt;ulMsgLen are not used by this call as no data is present at
+//! the time of the call.
+//! -# Call this function with \e ulObjID set to one of the 32 object buffers.
+//!
+//! If you specify a message object buffer that already contains a message
+//! definition, it will be overwritten.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANMessageSet(unsigned long ulBase, unsigned long ulObjID,
+              tCANMsgObject *pMsgObject, tMsgObjType eMsgType)
+{
+    unsigned short usCmdMaskReg;
+    unsigned short usMaskReg[2];
+    unsigned short usArbReg[2];
+    unsigned short usMsgCtrl;
+    tBoolean bTransferData;
+    tBoolean bUseExtendedID;
+
+    bTransferData = 0;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT((ulObjID &lt;= 32) &amp;&amp; (ulObjID != 0));
+    ASSERT((eMsgType == MSG_OBJ_TYPE_TX) ||
+           (eMsgType == MSG_OBJ_TYPE_TX_REMOTE) ||
+           (eMsgType == MSG_OBJ_TYPE_RX) ||
+           (eMsgType == MSG_OBJ_TYPE_RX_REMOTE) ||
+           (eMsgType == MSG_OBJ_TYPE_TX_REMOTE) ||
+           (eMsgType == MSG_OBJ_TYPE_RXTX_REMOTE));
+
+    //
+    // Wait for busy bit to clear
+    //
+    while(CANRegRead(ulBase + CAN_O_IF1CRQ) &amp; CAN_IF1CRQ_BUSY)
+    {
+    }
+
+    //
+    // See if we need to use an extended identifier or not.
+    //
+    if((pMsgObject-&gt;ulMsgID &gt; CAN_MAX_11BIT_MSG_ID) ||
+       (pMsgObject-&gt;ulFlags &amp; MSG_OBJ_EXTENDED_ID))
+    {
+        bUseExtendedID = 1;
+    }
+    else
+    {
+        bUseExtendedID = 0;
+    }
+
+    //
+    // This is always a write to the Message object as this call is setting a
+    // message object.  This call will also always set all size bits so it sets
+    // both data bits.  The call will use the CONTROL register to set control
+    // bits so this bit needs to be set as well.
+    //
+    usCmdMaskReg = (CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_DATAA | CAN_IF1CMSK_DATAB |
+                    CAN_IF1CMSK_CONTROL);
+
+    //
+    // Initialize the values to a known state before filling them in based on
+    // the type of message object that is being configured.
+    //
+    usArbReg[0] = 0;
+    usMsgCtrl = 0;
+    usMaskReg[0] = 0;
+    usMaskReg[1] = 0;
+
+    switch(eMsgType)
+    {
+        //
+        // Transmit message object.
+        //
+        case MSG_OBJ_TYPE_TX:
+        {
+            //
+            // Set the TXRQST bit and the reset the rest of the register.
+            //
+            usMsgCtrl |= CAN_IF1MCTL_TXRQST;
+            usArbReg[1] = CAN_IF1ARB2_DIR;
+            bTransferData = 1;
+            break;
+        }
+
+        //
+        // Transmit remote request message object
+        //
+        case MSG_OBJ_TYPE_TX_REMOTE:
+        {
+            //
+            // Set the TXRQST bit and the reset the rest of the register.
+            //
+            usMsgCtrl |= CAN_IF1MCTL_TXRQST;
+            usArbReg[1] = 0;
+            break;
+        }
+
+        //
+        // Receive message object.
+        //
+        case MSG_OBJ_TYPE_RX:
+        {
+            //
+            // This clears the DIR bit along with everthing else.  The TXRQST
+            // bit was cleard by defaulting usMsgCtrl to 0.
+            //
+            usArbReg[1] = 0;
+            break;
+        }
+
+        //
+        // Receive remote request message object.
+        //
+        case MSG_OBJ_TYPE_RX_REMOTE:
+        {
+            //
+            // The DIR bit is set to one for remote receivers.  The TXRQST bit
+            // was cleard by defaulting usMsgCtrl to 0.
+            //
+            usArbReg[1] = CAN_IF1ARB2_DIR;
+
+            //
+            // Set this object so that it only indicates that a remote frame
+            // was received and allow for software to handle it by sending back
+            // a data frame.
+            //
+            usMsgCtrl = CAN_IF1MCTL_UMASK;
+
+            //
+            // Use the full Identifier by default.
+            //
+            usMaskReg[0] = 0xffff;
+            usMaskReg[1] = 0x1fff;
+
+            //
+            // Make sure to send the mask to the message object.
+            //
+            usCmdMaskReg |= CAN_IF1CMSK_MASK;
+            break;
+        }
+
+        //
+        // Remote frame receive remote, with auto-transmit message object.
+        //
+        case MSG_OBJ_TYPE_RXTX_REMOTE:
+        {
+            //
+            // Oddly the DIR bit is set to one for remote receivers.
+            //
+            usArbReg[1] = CAN_IF1ARB2_DIR;
+
+            //
+            // Set this object to auto answer if a matching identifier is seen.
+            //
+            usMsgCtrl = CAN_IF1MCTL_RMTEN | CAN_IF1MCTL_UMASK;
+
+            //
+            // The data to be returned needs to be filled in.
+            //
+            bTransferData = 1;
+            break;
+        }
+
+        //
+        // This case should never happen due to the ASSERT statement at the
+        // beginning of this function.
+        //
+        default:
+        {
+            return;
+        }
+    }
+
+    //
+    // Configure the Mask Registers.
+    //
+    if(pMsgObject-&gt;ulFlags &amp; MSG_OBJ_USE_ID_FILTER)
+    {
+        if(bUseExtendedID)
+        {
+            //
+            // Set the 29 bits of Identifier mask that were requested.
+            //
+            usMaskReg[0] = pMsgObject-&gt;ulMsgIDMask &amp; CAN_IF1MSK1_IDMSK_M;
+            usMaskReg[1] = ((pMsgObject-&gt;ulMsgIDMask &gt;&gt; 16) &amp;
+                            CAN_IF1MSK2_IDMSK_M);
+        }
+        else
+        {
+            //
+            // Lower 16 bit are unused so set them to zero.
+            //
+            usMaskReg[0] = 0;
+
+            //
+            // Put the 11 bit Mask Identifier into the upper bits of the field
+            // in the register.
+            //
+            usMaskReg[1] = ((pMsgObject-&gt;ulMsgIDMask &lt;&lt; 2) &amp;
+                            CAN_IF1MSK2_IDMSK_M);
+        }
+    }
+
+    //
+    // If the caller wants to filter on the extended ID bit then set it.
+    //
+    if((pMsgObject-&gt;ulFlags &amp; MSG_OBJ_USE_EXT_FILTER) ==
+       MSG_OBJ_USE_EXT_FILTER)
+    {
+        usMaskReg[1] |= CAN_IF1MSK2_MXTD;
+    }
+
+    //
+    // The caller wants to filter on the message direction field.
+    //
+    if((pMsgObject-&gt;ulFlags &amp; MSG_OBJ_USE_DIR_FILTER) ==
+       MSG_OBJ_USE_DIR_FILTER)
+    {
+        usMaskReg[1] |= CAN_IF1MSK2_MDIR;
+    }
+
+    if(pMsgObject-&gt;ulFlags &amp; (MSG_OBJ_USE_ID_FILTER | MSG_OBJ_USE_DIR_FILTER |
+                              MSG_OBJ_USE_EXT_FILTER))
+    {
+        //
+        // Set the UMASK bit to enable using the mask register.
+        //
+        usMsgCtrl |= CAN_IF1MCTL_UMASK;
+
+        //
+        // Set the MASK bit so that this gets trasferred to the Message Object.
+        //
+        usCmdMaskReg |= CAN_IF1CMSK_MASK;
+    }
+
+    //
+    // Set the Arb bit so that this gets transferred to the Message object.
+    //
+    usCmdMaskReg |= CAN_IF1CMSK_ARB;
+
+    //
+    // Configure the Arbitration registers.
+    //
+    if(bUseExtendedID)
+    {
+        //
+        // Set the 29 bit version of the Identifier for this message object.
+        //
+        usArbReg[0] |= pMsgObject-&gt;ulMsgID &amp; CAN_IF1ARB1_ID_M;
+        usArbReg[1] |= (pMsgObject-&gt;ulMsgID &gt;&gt; 16) &amp; CAN_IF1ARB2_ID_M;
+
+        //
+        // Mark the message as valid and set the extended ID bit.
+        //
+        usArbReg[1] |= CAN_IF1ARB2_MSGVAL | CAN_IF1ARB2_XTD;
+    }
+    else
+    {
+        //
+        // Set the 11 bit version of the Identifier for this message object.
+        // The lower 18 bits are set to zero.
+        //
+        usArbReg[1] |= (pMsgObject-&gt;ulMsgID &lt;&lt; 2) &amp; CAN_IF1ARB2_ID_M;
+
+        //
+        // Mark the message as valid.
+        //
+        usArbReg[1] |= CAN_IF1ARB2_MSGVAL;
+    }
+
+    //
+    // Set the data length since this is set for all transfers.  This is also a
+    // single transfer and not a FIFO transfer so set EOB bit.
+    //
+    usMsgCtrl |= (pMsgObject-&gt;ulMsgLen &amp; CAN_IF1MCTL_DLC_M) | CAN_IF1MCTL_EOB;
+
+    //
+    // Enable transmit interrupts if they should be enabled.
+    //
+    if(pMsgObject-&gt;ulFlags &amp; MSG_OBJ_TX_INT_ENABLE)
+    {
+        usMsgCtrl |= CAN_IF1MCTL_TXIE;
+    }
+
+    //
+    // Enable receive interrupts if they should be enabled.
+    //
+    if(pMsgObject-&gt;ulFlags &amp; MSG_OBJ_RX_INT_ENABLE)
+    {
+        usMsgCtrl |= CAN_IF1MCTL_RXIE;
+    }
+
+    //
+    // Write the data out to the CAN Data registers if needed.
+    //
+    if(bTransferData)
+    {
+        CANDataRegWrite(pMsgObject-&gt;pucMsgData,
+                        (unsigned long *)(ulBase + CAN_O_IF1DA1),
+                        pMsgObject-&gt;ulMsgLen);
+    }
+
+    //
+    // Write out the registers to program the message object.
+    //
+    CANRegWrite(ulBase + CAN_O_IF1CMSK, usCmdMaskReg);
+    CANRegWrite(ulBase + CAN_O_IF1MSK1, usMaskReg[0]);
+    CANRegWrite(ulBase + CAN_O_IF1MSK2, usMaskReg[1]);
+    CANRegWrite(ulBase + CAN_O_IF1ARB1, usArbReg[0]);
+    CANRegWrite(ulBase + CAN_O_IF1ARB2, usArbReg[1]);
+    CANRegWrite(ulBase + CAN_O_IF1MCTL, usMsgCtrl);
+
+    //
+    // Transfer the message object to the message object specifiec by ulObjID.
+    //
+    CANRegWrite(ulBase + CAN_O_IF1CRQ, ulObjID &amp; CAN_IF1CRQ_MNUM_M);
+
+    return;
+}
+
+//*****************************************************************************
+//
+//! Reads a CAN message from one of the message object buffers.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param ulObjID is the object number to read (1-32).
+//! \param pMsgObject points to a structure containing message object fields.
+//! \param bClrPendingInt indicates whether an associated interrupt should be
+//! cleared.
+//!
+//! This function is used to read the contents of one of the 32 message objects
+//! in the CAN controller, and return it to the caller.  The data returned is
+//! stored in the fields of the caller-supplied structure pointed to by
+//! \e pMsgObject.  The data consists of all of the parts of a CAN message,
+//! plus some control and status information.
+//!
+//! Normally this is used to read a message object that has received and stored
+//! a CAN message with a certain identifier.  However, this could also be used
+//! to read the contents of a message object in order to load the fields of the
+//! structure in case only part of the structure needs to be changed from a
+//! previous setting.
+//!
+//! When using CANMessageGet, all of the same fields of the structure are
+//! populated in the same way as when the CANMessageSet() function is used,
+//! with the following exceptions:
+//!
+//! \e pMsgObject-&gt;ulFlags:
+//!
+//! - \b MSG_OBJ_NEW_DATA indicates if this is new data since the last time it
+//! was read
+//! - \b MSG_OBJ_DATA_LOST indicates that at least one message was received on
+//! this message object, and not read by the host before being overwritten.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANMessageGet(unsigned long ulBase, unsigned long ulObjID,
+              tCANMsgObject *pMsgObject, tBoolean bClrPendingInt)
+{
+    unsigned short usCmdMaskReg;
+    unsigned short usMaskReg[2];
+    unsigned short usArbReg[2];
+    unsigned short usMsgCtrl;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT((ulObjID &lt;= 32) &amp;&amp; (ulObjID != 0));
+
+    //
+    // This is always a read to the Message object as this call is setting a
+    // message object.
+    //
+    usCmdMaskReg = (CAN_IF1CMSK_DATAA | CAN_IF1CMSK_DATAB |
+                    CAN_IF1CMSK_CONTROL | CAN_IF1CMSK_MASK | CAN_IF1CMSK_ARB);
+
+    //
+    // Clear a pending interrupt and new data in a message object.
+    //
+    if(bClrPendingInt)
+    {
+        usCmdMaskReg |= CAN_IF1CMSK_CLRINTPND;
+    }
+
+    //
+    // Set up the request for data from the message object.
+    //
+    CANRegWrite(ulBase + CAN_O_IF2CMSK, usCmdMaskReg);
+
+    //
+    // Transfer the message object to the message object specifiec by ulObjID.
+    //
+    CANRegWrite(ulBase + CAN_O_IF2CRQ, ulObjID &amp; CAN_IF1CRQ_MNUM_M);
+
+    //
+    // Wait for busy bit to clear
+    //
+    while(CANRegRead(ulBase + CAN_O_IF2CRQ) &amp; CAN_IF1CRQ_BUSY)
+    {
+    }
+
+    //
+    // Read out the IF Registers.
+    //
+    usMaskReg[0] = CANRegRead(ulBase + CAN_O_IF2MSK1);
+    usMaskReg[1] = CANRegRead(ulBase + CAN_O_IF2MSK2);
+    usArbReg[0] = CANRegRead(ulBase + CAN_O_IF2ARB1);
+    usArbReg[1] = CANRegRead(ulBase + CAN_O_IF2ARB2);
+    usMsgCtrl = CANRegRead(ulBase + CAN_O_IF2MCTL);
+
+    pMsgObject-&gt;ulFlags = MSG_OBJ_NO_FLAGS;
+
+    //
+    // Determine if this is a remote frame by checking the TXRQST and DIR bits.
+    //
+    if((!(usMsgCtrl &amp; CAN_IF1MCTL_TXRQST) &amp;&amp;
+        (usArbReg[1] &amp; CAN_IF1ARB2_DIR)) ||
+       ((usMsgCtrl &amp; CAN_IF1MCTL_TXRQST) &amp;&amp;
+        (!(usArbReg[1] &amp; CAN_IF1ARB2_DIR))))
+    {
+        pMsgObject-&gt;ulFlags |= MSG_OBJ_REMOTE_FRAME;
+    }
+
+    //
+    // Get the identifier out of the register, the format depends on size of
+    // the mask.
+    //
+    if(usArbReg[1] &amp; CAN_IF1ARB2_XTD)
+    {
+        //
+        // Set the 29 bit version of the Identifier for this message object.
+        //
+        pMsgObject-&gt;ulMsgID = ((usArbReg[1] &amp; CAN_IF1ARB2_ID_M) &lt;&lt; 16) |
+            usArbReg[0];
+
+        pMsgObject-&gt;ulFlags |= MSG_OBJ_EXTENDED_ID;
+    }
+    else
+    {
+        //
+        // The Identifier is an 11 bit value.
+        //
+        pMsgObject-&gt;ulMsgID = (usArbReg[1] &amp; CAN_IF1ARB2_ID_M) &gt;&gt; 2;
+    }
+
+    //
+    // Indicate that we lost some data.
+    //
+    if(usMsgCtrl &amp; CAN_IF1MCTL_MSGLST)
+    {
+        pMsgObject-&gt;ulFlags |= MSG_OBJ_DATA_LOST;
+    }
+
+    //
+    // Set the flag to indicate if ID masking was used.
+    //
+    if(usMsgCtrl &amp; CAN_IF1MCTL_UMASK)
+    {
+        if(usArbReg[1] &amp; CAN_IF1ARB2_XTD)
+        {
+            //
+            // The Identifier Mask is assumed to also be a 29 bit value.
+            //
+            pMsgObject-&gt;ulMsgIDMask =
+                ((usMaskReg[1] &amp; CAN_IF1MSK2_IDMSK_M) &lt;&lt; 16) | usMaskReg[0];
+            //
+            // If this is a fully specified Mask and a remote frame then don't
+            // set the MSG_OBJ_USE_ID_FILTER because the ID was not really
+            // filtered.
+            //
+            if((pMsgObject-&gt;ulMsgIDMask != 0x1fffffff) ||
+               ((pMsgObject-&gt;ulFlags &amp; MSG_OBJ_REMOTE_FRAME) == 0))
+            {
+                pMsgObject-&gt;ulFlags |= MSG_OBJ_USE_ID_FILTER;
+            }
+        }
+        else
+        {
+            //
+            // The Identifier Mask is assumed to also be an 11 bit value.
+            //
+            pMsgObject-&gt;ulMsgIDMask = ((usMaskReg[1] &amp; CAN_IF1MSK2_IDMSK_M) &gt;&gt;
+                                       2);
+
+            //
+            // If this is a fully specified Mask and a remote frame then don't
+            // set the MSG_OBJ_USE_ID_FILTER because the ID was not really
+            // filtered.
+            //
+            if((pMsgObject-&gt;ulMsgIDMask != 0x7ff) ||
+               ((pMsgObject-&gt;ulFlags &amp; MSG_OBJ_REMOTE_FRAME) == 0))
+            {
+                pMsgObject-&gt;ulFlags |= MSG_OBJ_USE_ID_FILTER;
+            }
+        }
+
+        //
+        // Indicate if the extended bit was used in filtering.
+        //
+        if(usMaskReg[1] &amp; CAN_IF1MSK2_MXTD)
+        {
+            pMsgObject-&gt;ulFlags |= MSG_OBJ_USE_EXT_FILTER;
+        }
+
+        //
+        // Indicate if direction filtering was enabled.
+        //
+        if(usMaskReg[1] &amp; CAN_IF1MSK2_MDIR)
+        {
+            pMsgObject-&gt;ulFlags |= MSG_OBJ_USE_DIR_FILTER;
+        }
+    }
+
+    //
+    // Set the interupt flags.
+    //
+    if(usMsgCtrl &amp; CAN_IF1MCTL_TXIE)
+    {
+        pMsgObject-&gt;ulFlags |= MSG_OBJ_TX_INT_ENABLE;
+    }
+    if(usMsgCtrl &amp; CAN_IF1MCTL_RXIE)
+    {
+        pMsgObject-&gt;ulFlags |= MSG_OBJ_RX_INT_ENABLE;
+    }
+
+    //
+    // See if there is new data available.
+    //
+    if(usMsgCtrl &amp; CAN_IF1MCTL_NEWDAT)
+    {
+        //
+        // Get the amount of data needed to be read.
+        //
+        pMsgObject-&gt;ulMsgLen = (usMsgCtrl &amp; CAN_IF1MCTL_DLC_M);
+
+        //
+        // Don't read any data for a remote frame, there is nothing valid in
+        // that buffer anyway.
+        //
+        if((pMsgObject-&gt;ulFlags &amp; MSG_OBJ_REMOTE_FRAME) == 0)
+        {
+            //
+            // Read out the data from the CAN registers.
+            //
+            CANDataRegRead(pMsgObject-&gt;pucMsgData,
+                           (unsigned long *)(ulBase + CAN_O_IF2DA1),
+                           pMsgObject-&gt;ulMsgLen);
+        }
+
+        //
+        // Now clear out the new data flag.
+        //
+        CANRegWrite(ulBase + CAN_O_IF2CMSK, CAN_IF1CMSK_NEWDAT);
+
+        //
+        // Transfer the message object to the message object specifiec by
+        // ulObjID.
+        //
+        CANRegWrite(ulBase + CAN_O_IF2CRQ, ulObjID &amp; CAN_IF1CRQ_MNUM_M);
+
+        //
+        // Wait for busy bit to clear
+        //
+        while(CANRegRead(ulBase + CAN_O_IF2CRQ) &amp; CAN_IF1CRQ_BUSY)
+        {
+        }
+
+        //
+        // Indicate that there is new data in this message.
+        //
+        pMsgObject-&gt;ulFlags |= MSG_OBJ_NEW_DATA;
+    }
+    else
+    {
+        //
+        // Along with the MSG_OBJ_NEW_DATA not being set the amount of data
+        // needs to be set to zero if none was available.
+        //
+        pMsgObject-&gt;ulMsgLen = 0;
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears a message object so that it is no longer used.
+//!
+//! \param ulBase is the base address of the CAN controller.
+//! \param ulObjID is the message object number to disable (1-32).
+//!
+//! This function frees the specified message object from use.  Once a message
+//! object has been ``cleared,'' it will no longer automatically send or
+//! receive messages, or generate interrupts.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+CANMessageClear(unsigned long ulBase, unsigned long ulObjID)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(CANBaseValid(ulBase));
+    ASSERT((ulObjID &gt;= 1) &amp;&amp; (ulObjID &lt;= 32));
+
+    //
+    // Wait for busy bit to clear
+    //
+    while(CANRegRead(ulBase + CAN_O_IF1CRQ) &amp; CAN_IF1CRQ_BUSY)
+    {
+    }
+
+    //
+    // Clear the message value bit in the arbitration register.  This indicates
+    // the message is not valid.
+    //
+    CANRegWrite(ulBase + CAN_O_IF1CMSK, CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_ARB);
+    CANRegWrite(ulBase + CAN_O_IF1ARB1, 0);
+    CANRegWrite(ulBase + CAN_O_IF1ARB2, 0);
+
+    //
+    // Initiate programming the message object
+    //
+    CANRegWrite(ulBase + CAN_O_IF1CRQ, ulObjID &amp; CAN_IF1CRQ_MNUM_M);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/can.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/can.h
===================================================================
--- trunk/src/platform/lm3s/can.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/can.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,458 @@
+//*****************************************************************************
+//
+// can.h - Defines and Macros for the CAN controller.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __CAN_H__
+#define __CAN_H__
+
+//*****************************************************************************
+//
+//! \addtogroup can_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Miscellaneous defines for Message ID Types
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! These are the flags used by the tCANMsgObject variable when calling the
+//! CANMessageSet() and CANMessageGet() functions.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! This indicates that transmit interrupts should be enabled, or are
+    //! enabled.
+    //
+    MSG_OBJ_TX_INT_ENABLE =     0x00000001,
+
+    //
+    //! This indicates that receive interrupts should be enabled, or are
+    //! enabled.
+    //
+    MSG_OBJ_RX_INT_ENABLE =     0x00000002,
+
+    //
+    //! This indicates that a message object will use or is using an extended
+    //! identifier.
+    //
+    MSG_OBJ_EXTENDED_ID =       0x00000004,
+
+    //
+    //! This indicates that a message object will use or is using filtering
+    //! based on the object's message identifier.
+    //
+    MSG_OBJ_USE_ID_FILTER =     0x00000008,
+
+    //
+    //! This indicates that new data was available in the message object.
+    //
+    MSG_OBJ_NEW_DATA =          0x00000080,
+
+    //
+    //! This indicates that data was lost since this message object was last
+    //! read.
+    //
+    MSG_OBJ_DATA_LOST =         0x00000100,
+
+    //
+    //! This indicates that a message object will use or is using filtering
+    //! based on the direction of the transfer.  If the direction filtering is
+    //! used, then ID filtering must also be enabled.
+    //
+    MSG_OBJ_USE_DIR_FILTER =    (0x00000010 | MSG_OBJ_USE_ID_FILTER),
+
+    //
+    //! This indicates that a message object will use or is using message
+    //! identifier filtering based on the extended identifier.  If the extended
+    //! identifier filtering is used, then ID filtering must also be enabled.
+    //
+    MSG_OBJ_USE_EXT_FILTER =    (0x00000020 | MSG_OBJ_USE_ID_FILTER),
+
+    //
+    //! This indicates that a message object is a remote frame.
+    //
+    MSG_OBJ_REMOTE_FRAME =      0x00000040,
+
+    //
+    //! This indicates that a message object has no flags set.
+    //
+    MSG_OBJ_NO_FLAGS =          0x00000000
+}
+tCANObjFlags;
+
+//*****************************************************************************
+//
+//! This define is used with the #tCANObjFlags enumerated values to allow
+//! checking only status flags and not configuration flags.
+//
+//*****************************************************************************
+#define MSG_OBJ_STATUS_MASK     (MSG_OBJ_NEW_DATA | MSG_OBJ_DATA_LOST)
+
+//*****************************************************************************
+//
+//! The structure used for encapsulating all the items associated with a CAN
+//! message object in the CAN controller.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! The CAN message identifier used for 11 or 29 bit identifiers.
+    //
+    unsigned long ulMsgID;
+
+    //
+    //! The message identifier mask used when identifier filtering is enabled.
+    //
+    unsigned long ulMsgIDMask;
+
+    //
+    //! This value holds various status flags and settings specified by
+    //! tCANObjFlags.
+    //
+    unsigned long ulFlags;
+
+    //
+    //! This value is the number of bytes of data in the message object.
+    //
+    unsigned long ulMsgLen;
+
+    //
+    //! This is a pointer to the message object's data.
+    //
+    unsigned char *pucMsgData;
+}
+tCANMsgObject;
+
+//*****************************************************************************
+//
+//! This structure is used for encapsulating the values associated with setting
+//! up the bit timing for a CAN controller.  The structure is used when calling
+//! the CANGetBitTiming and CANSetBitTiming functions.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    //! This value holds the sum of the Synchronization, Propagation, and Phase
+    //! Buffer 1 segments, measured in time quanta.  The valid values for this
+    //! setting range from 2 to 16.
+    //
+    unsigned int uSyncPropPhase1Seg;
+
+    //
+    //! This value holds the Phase Buffer 2 segment in time quanta.  The valid
+    //! values for this setting range from 1 to 8.
+    //
+    unsigned int uPhase2Seg;
+
+    //
+    //! This value holds the Resynchronization Jump Width in time quanta.  The
+    //! valid values for this setting range from 1 to 4.
+    //
+    unsigned int uSJW;
+
+    //
+    //! This value holds the CAN_CLK divider used to determine time quanta.
+    //! The valid values for this setting range from 1 to 1023.
+    //
+    unsigned int uQuantumPrescaler;
+}
+tCANBitClkParms;
+
+//*****************************************************************************
+//
+//! This data type is used to identify the interrupt status register.  This is
+//! used when calling the CANIntStatus() function.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! Read the CAN interrupt status information.
+    //
+    CAN_INT_STS_CAUSE,
+
+    //
+    //! Read a message object's interrupt status.
+    //
+    CAN_INT_STS_OBJECT
+}
+tCANIntStsReg;
+
+//*****************************************************************************
+//
+//! This data type is used to identify which of several status registers to
+//! read when calling the CANStatusGet() function.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! Read the full CAN controller status.
+    //
+    CAN_STS_CONTROL,
+
+    //
+    //! Read the full 32-bit mask of message objects with a transmit request
+    //! set.
+    //
+    CAN_STS_TXREQUEST,
+
+    //
+    //! Read the full 32-bit mask of message objects with new data available.
+    //
+    CAN_STS_NEWDAT,
+
+    //
+    //! Read the full 32-bit mask of message objects that are enabled.
+    //
+    CAN_STS_MSGVAL
+}
+tCANStsReg;
+
+//*****************************************************************************
+//
+//! These definitions are used to specify interrupt sources to CANIntEnable()
+//! and CANIntDisable().
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! This flag is used to allow a CAN controller to generate error
+    //! interrupts.
+    //
+    CAN_INT_ERROR =             0x00000008,
+
+    //
+    //! This flag is used to allow a CAN controller to generate status
+    //! interrupts.
+    //
+    CAN_INT_STATUS =            0x00000004,
+
+    //
+    //! This flag is used to allow a CAN controller to generate any CAN
+    //! interrupts.  If this is not set, then no interrupts will be generated
+    //! by the CAN controller.
+    //
+    CAN_INT_MASTER =            0x00000002
+}
+tCANIntFlags;
+
+//*****************************************************************************
+//
+//! This definition is used to determine the type of message object that will
+//! be set up via a call to the CANMessageSet() API.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! Transmit message object.
+    //
+    MSG_OBJ_TYPE_TX,
+
+    //
+    //! Transmit remote request message object
+    //
+    MSG_OBJ_TYPE_TX_REMOTE,
+
+    //
+    //! Receive message object.
+    //
+    MSG_OBJ_TYPE_RX,
+
+    //
+    //! Receive remote request message object.
+    //
+    MSG_OBJ_TYPE_RX_REMOTE,
+
+    //
+    //! Remote frame receive remote, with auto-transmit message object.
+    //
+    MSG_OBJ_TYPE_RXTX_REMOTE
+}
+tMsgObjType;
+
+//*****************************************************************************
+//
+//! The following enumeration contains all error or status indicators that can
+//! be returned when calling the CANStatusGet() function.
+//
+//*****************************************************************************
+typedef enum
+{
+    //
+    //! CAN controller has entered a Bus Off state.
+    //
+    CAN_STATUS_BUS_OFF =        0x00000080,
+
+    //
+    //! CAN controller error level has reached warning level.
+    //
+    CAN_STATUS_EWARN =          0x00000040,
+
+    //
+    //! CAN controller error level has reached error passive level.
+    //
+    CAN_STATUS_EPASS =          0x00000020,
+
+    //
+    //! A message was received successfully since the last read of this status.
+    //
+    CAN_STATUS_RXOK =           0x00000010,
+
+    //
+    //! A message was transmitted successfully since the last read of this
+    //! status.
+    //
+    CAN_STATUS_TXOK =           0x00000008,
+
+    //
+    //! This is the mask for the last error code field.
+    //
+    CAN_STATUS_LEC_MSK =        0x00000007,
+
+    //
+    //! There was no error.
+    //
+    CAN_STATUS_LEC_NONE =       0x00000000,
+
+    //
+    //! A bit stuffing error has occurred.
+    //
+    CAN_STATUS_LEC_STUFF =      0x00000001,
+
+    //
+    //! A formatting error has occurred.
+    //
+    CAN_STATUS_LEC_FORM =       0x00000002,
+
+    //
+    //! An acknowledge error has occurred.
+    //
+    CAN_STATUS_LEC_ACK =        0x00000003,
+
+    //
+    //! The bus remained a bit level of 1 for longer than is allowed.
+    //
+    CAN_STATUS_LEC_BIT1 =       0x00000004,
+
+    //
+    //! The bus remained a bit level of 0 for longer than is allowed.
+    //
+    CAN_STATUS_LEC_BIT0 =       0x00000005,
+
+    //
+    //! A CRC error has occurred.
+    //
+    CAN_STATUS_LEC_CRC =        0x00000006,
+
+    //
+    //! This is the mask for the CAN Last Error Code (LEC).
+    //
+    CAN_STATUS_LEC_MASK =       0x00000007
+}
+tCANStatusCtrl;
+
+//*****************************************************************************
+//
+// API Function prototypes
+//
+//*****************************************************************************
+extern void CANBitTimingGet(unsigned long ulBase, tCANBitClkParms *pClkParms);
+extern void CANBitTimingSet(unsigned long ulBase, tCANBitClkParms *pClkParms);
+extern unsigned long CANBitRateSet(unsigned long ulBase,
+                                   unsigned long ulSourceClock,
+                                   unsigned long ulBitRate);
+extern void CANDisable(unsigned long ulBase);
+extern void CANEnable(unsigned long ulBase);
+extern tBoolean CANErrCntrGet(unsigned long ulBase, unsigned long *pulRxCount,
+                              unsigned long *pulTxCount);
+extern void CANInit(unsigned long ulBase);
+extern void CANIntClear(unsigned long ulBase, unsigned long ulIntClr);
+extern void CANIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void CANIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void CANIntRegister(unsigned long ulBase, void (*pfnHandler)(void));
+extern unsigned long CANIntStatus(unsigned long ulBase,
+                                  tCANIntStsReg eIntStsReg);
+extern void CANIntUnregister(unsigned long ulBase);
+extern void CANMessageClear(unsigned long ulBase, unsigned long ulObjID);
+extern void CANMessageGet(unsigned long ulBase, unsigned long ulObjID,
+                          tCANMsgObject *pMsgObject, tBoolean bClrPendingInt);
+extern void CANMessageSet(unsigned long ulBase, unsigned long ulObjID,
+                          tCANMsgObject *pMsgObject, tMsgObjType eMsgType);
+extern tBoolean CANRetryGet(unsigned long ulBase);
+extern void CANRetrySet(unsigned long ulBase, tBoolean bAutoRetry);
+extern unsigned long CANStatusGet(unsigned long ulBase, tCANStsReg eStatusReg);
+
+//*****************************************************************************
+//
+// Several CAN APIs have been renamed, with the original function name being
+// deprecated.  These defines provide backward compatibility.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#define CANSetBitTiming(a, b)   CANBitTimingSet(a, b)
+#define CANGetBitTiming(a, b)   CANBitTimingGet(a, b)
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
+#endif //  __CAN_H__


Property changes on: trunk/src/platform/lm3s/can.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/cpu.c
===================================================================
--- trunk/src/platform/lm3s/cpu.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/cpu.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,189 +1,189 @@
-//*****************************************************************************
-//
-// cpu.c - Instruction wrappers for special CPU instructions needed by the
-//         drivers.
-//
-// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#include &quot;cpu.h&quot;
-
-//*****************************************************************************
-//
-// Wrapper function for the CPSID instruction.  Returns the state of PRIMASK
-// on entry.
-//
-//*****************************************************************************
-#if defined(codered) || defined(gcc) || defined(sourcerygxx)
-unsigned long __attribute__((naked))
-CPUcpsid(void)
-{
-    unsigned long ulRet;
-
-    //
-    // Read PRIMASK and disable interrupts.
-    //
-    __asm(&quot;    mrs     %0, PRIMASK\n&quot;
-          &quot;    cpsid   i\n&quot;
-          &quot;    bx      lr\n&quot;
-          : &quot;=r&quot; (ulRet));
-
-    //
-    // The return is handled in the inline assembly, but the compiler will
-    // still complain if there is not an explicit return here (despite the fact
-    // that this does not result in any code being produced because of the
-    // naked attribute).
-    //
-    return(ulRet);
-}
-#endif
-#if defined(ewarm)
-unsigned long
-CPUcpsid(void)
-{
-    //
-    // Read PRIMASK and disable interrupts.
-    //
-    __asm(&quot;    mrs     r0, PRIMASK\n&quot;
-          &quot;    cpsid   i\n&quot;);
-
-    //
-    // &quot;Warning[Pe940]: missing return statement at end of non-void function&quot;
-    // is suppressed here to avoid putting a &quot;bx lr&quot; in the inline assembly
-    // above and a superfluous return statement here.
-    //
-#pragma diag_suppress=Pe940
-}
-#pragma diag_default=Pe940
-#endif
-#if defined(rvmdk) || defined(__ARMCC_VERSION)
-__asm unsigned long
-CPUcpsid(void)
-{
-    //
-    // Read PRIMASK and disable interrupts.
-    //
-    mrs     r0, PRIMASK;
-    cpsid   i;
-    bx      lr
-}
-#endif
-
-//*****************************************************************************
-//
-// Wrapper function for the CPSIE instruction.  Returns the state of PRIMASK
-// on entry.
-//
-//*****************************************************************************
-#if defined(codered) || defined(gcc) || defined(sourcerygxx)
-unsigned long __attribute__((naked))
-CPUcpsie(void)
-{
-    unsigned long ulRet;
-
-    //
-    // Read PRIMASK and enable interrupts.
-    //
-    __asm(&quot;    mrs     %0, PRIMASK\n&quot;
-          &quot;    cpsie   i\n&quot;
-          &quot;    bx      lr\n&quot;
-          : &quot;=r&quot; (ulRet));
-
-    //
-    // The return is handled in the inline assembly, but the compiler will
-    // still complain if there is not an explicit return here (despite the fact
-    // that this does not result in any code being produced because of the
-    // naked attribute).
-    //
-    return(ulRet);
-}
-#endif
-#if defined(ewarm)
-unsigned long
-CPUcpsie(void)
-{
-    //
-    // Read PRIMASK and enable interrupts.
-    //
-    __asm(&quot;    mrs     r0, PRIMASK\n&quot;
-          &quot;    cpsie   i\n&quot;);
-
-    //
-    // &quot;Warning[Pe940]: missing return statement at end of non-void function&quot;
-    // is suppressed here to avoid putting a &quot;bx lr&quot; in the inline assembly
-    // above and a superfluous return statement here.
-    //
-#pragma diag_suppress=Pe940
-}
-#pragma diag_default=Pe940
-#endif
-#if defined(rvmdk) || defined(__ARMCC_VERSION)
-__asm unsigned long
-CPUcpsie(void)
-{
-    //
-    // Read PRIMASK and enable interrupts.
-    //
-    mrs     r0, PRIMASK;
-    cpsie   i;
-    bx      lr
-}
-#endif
-
-//*****************************************************************************
-//
-// Wrapper function for the WFI instruction.
-//
-//*****************************************************************************
-#if defined(codered) || defined(gcc) || defined(sourcerygxx)
-void __attribute__((naked))
-CPUwfi(void)
-{
-    //
-    // Wait for the next interrupt.
-    //
-    __asm(&quot;    wfi\n&quot;
-          &quot;    bx      lr\n&quot;);
-}
-#endif
-#if defined(ewarm)
-void
-CPUwfi(void)
-{
-    //
-    // Wait for the next interrupt.
-    //
-    __asm(&quot;    wfi\n&quot;);
-}
-#endif
-#if defined(rvmdk) || defined(__ARMCC_VERSION)
-__asm void
-CPUwfi(void)
-{
-    //
-    // Wait for the next interrupt.
-    //
-    wfi;
-    bx      lr
-}
-#endif
+//*****************************************************************************
+//
+// cpu.c - Instruction wrappers for special CPU instructions needed by the
+//         drivers.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#include &quot;cpu.h&quot;
+
+//*****************************************************************************
+//
+// Wrapper function for the CPSID instruction.  Returns the state of PRIMASK
+// on entry.
+//
+//*****************************************************************************
+#if defined(codered) || defined(gcc) || defined(sourcerygxx)
+unsigned long __attribute__((naked))
+CPUcpsid(void)
+{
+    unsigned long ulRet;
+
+    //
+    // Read PRIMASK and disable interrupts.
+    //
+    __asm(&quot;    mrs     %0, PRIMASK\n&quot;
+          &quot;    cpsid   i\n&quot;
+          &quot;    bx      lr\n&quot;
+          : &quot;=r&quot; (ulRet));
+
+    //
+    // The return is handled in the inline assembly, but the compiler will
+    // still complain if there is not an explicit return here (despite the fact
+    // that this does not result in any code being produced because of the
+    // naked attribute).
+    //
+    return(ulRet);
+}
+#endif
+#if defined(ewarm)
+unsigned long
+CPUcpsid(void)
+{
+    //
+    // Read PRIMASK and disable interrupts.
+    //
+    __asm(&quot;    mrs     r0, PRIMASK\n&quot;
+          &quot;    cpsid   i\n&quot;);
+
+    //
+    // &quot;Warning[Pe940]: missing return statement at end of non-void function&quot;
+    // is suppressed here to avoid putting a &quot;bx lr&quot; in the inline assembly
+    // above and a superfluous return statement here.
+    //
+#pragma diag_suppress=Pe940
+}
+#pragma diag_default=Pe940
+#endif
+#if defined(rvmdk) || defined(__ARMCC_VERSION)
+__asm unsigned long
+CPUcpsid(void)
+{
+    //
+    // Read PRIMASK and disable interrupts.
+    //
+    mrs     r0, PRIMASK;
+    cpsid   i;
+    bx      lr
+}
+#endif
+
+//*****************************************************************************
+//
+// Wrapper function for the CPSIE instruction.  Returns the state of PRIMASK
+// on entry.
+//
+//*****************************************************************************
+#if defined(codered) || defined(gcc) || defined(sourcerygxx)
+unsigned long __attribute__((naked))
+CPUcpsie(void)
+{
+    unsigned long ulRet;
+
+    //
+    // Read PRIMASK and enable interrupts.
+    //
+    __asm(&quot;    mrs     %0, PRIMASK\n&quot;
+          &quot;    cpsie   i\n&quot;
+          &quot;    bx      lr\n&quot;
+          : &quot;=r&quot; (ulRet));
+
+    //
+    // The return is handled in the inline assembly, but the compiler will
+    // still complain if there is not an explicit return here (despite the fact
+    // that this does not result in any code being produced because of the
+    // naked attribute).
+    //
+    return(ulRet);
+}
+#endif
+#if defined(ewarm)
+unsigned long
+CPUcpsie(void)
+{
+    //
+    // Read PRIMASK and enable interrupts.
+    //
+    __asm(&quot;    mrs     r0, PRIMASK\n&quot;
+          &quot;    cpsie   i\n&quot;);
+
+    //
+    // &quot;Warning[Pe940]: missing return statement at end of non-void function&quot;
+    // is suppressed here to avoid putting a &quot;bx lr&quot; in the inline assembly
+    // above and a superfluous return statement here.
+    //
+#pragma diag_suppress=Pe940
+}
+#pragma diag_default=Pe940
+#endif
+#if defined(rvmdk) || defined(__ARMCC_VERSION)
+__asm unsigned long
+CPUcpsie(void)
+{
+    //
+    // Read PRIMASK and enable interrupts.
+    //
+    mrs     r0, PRIMASK;
+    cpsie   i;
+    bx      lr
+}
+#endif
+
+//*****************************************************************************
+//
+// Wrapper function for the WFI instruction.
+//
+//*****************************************************************************
+#if defined(codered) || defined(gcc) || defined(sourcerygxx)
+void __attribute__((naked))
+CPUwfi(void)
+{
+    //
+    // Wait for the next interrupt.
+    //
+    __asm(&quot;    wfi\n&quot;
+          &quot;    bx      lr\n&quot;);
+}
+#endif
+#if defined(ewarm)
+void
+CPUwfi(void)
+{
+    //
+    // Wait for the next interrupt.
+    //
+    __asm(&quot;    wfi\n&quot;);
+}
+#endif
+#if defined(rvmdk) || defined(__ARMCC_VERSION)
+__asm void
+CPUwfi(void)
+{
+    //
+    // Wait for the next interrupt.
+    //
+    wfi;
+    bx      lr
+}
+#endif


Property changes on: trunk/src/platform/lm3s/cpu.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/cpu.h
===================================================================
--- trunk/src/platform/lm3s/cpu.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/cpu.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,60 +1,60 @@
-//*****************************************************************************
-//
-// cpu.h - Prototypes for the CPU instruction wrapper functions.
-//
-// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __CPU_H__
-#define __CPU_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Prototypes.
-//
-//*****************************************************************************
-extern unsigned long CPUcpsid(void);
-extern unsigned long CPUcpsie(void);
-extern void CPUwfi(void);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __CPU_H__
+//*****************************************************************************
+//
+// cpu.h - Prototypes for the CPU instruction wrapper functions.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __CPU_H__
+#define __CPU_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Prototypes.
+//
+//*****************************************************************************
+extern unsigned long CPUcpsid(void);
+extern unsigned long CPUcpsie(void);
+extern void CPUwfi(void);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __CPU_H__


Property changes on: trunk/src/platform/lm3s/cpu.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/debug.h
===================================================================
--- trunk/src/platform/lm3s/debug.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/debug.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,56 +1,56 @@
-//*****************************************************************************
-//
-// debug.h - Macros for assisting debug of the driver library.
-//
-// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __DEBUG_H__
-#define __DEBUG_H__
-
-//*****************************************************************************
-//
-// Prototype for the function that is called when an invalid argument is passed
-// to an API.  This is only used when doing a DEBUG build.
-//
-//*****************************************************************************
-extern void __error__(char *pcFilename, unsigned long ulLine);
-
-//*****************************************************************************
-//
-// The ASSERT macro, which does the actual assertion checking.  Typically, this
-// will be for procedure arguments.
-//
-//*****************************************************************************
-#ifdef DEBUG
-#define ASSERT(expr) {                                      \
-                         if(!(expr))                        \
-                         {                                  \
-                             __error__(__FILE__, __LINE__); \
-                         }                                  \
-                     }
-#else
-#define ASSERT(expr)
-#endif
-
-#endif // __DEBUG_H__
+//*****************************************************************************
+//
+// debug.h - Macros for assisting debug of the driver library.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+//*****************************************************************************
+//
+// Prototype for the function that is called when an invalid argument is passed
+// to an API.  This is only used when doing a DEBUG build.
+//
+//*****************************************************************************
+extern void __error__(char *pcFilename, unsigned long ulLine);
+
+//*****************************************************************************
+//
+// The ASSERT macro, which does the actual assertion checking.  Typically, this
+// will be for procedure arguments.
+//
+//*****************************************************************************
+#ifdef DEBUG
+#define ASSERT(expr) {                                      \
+                         if(!(expr))                        \
+                         {                                  \
+                             __error__(__FILE__, __LINE__); \
+                         }                                  \
+                     }
+#else
+#define ASSERT(expr)
+#endif
+
+#endif // __DEBUG_H__


Property changes on: trunk/src/platform/lm3s/debug.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/ethernet.c
===================================================================
--- trunk/src/platform/lm3s/ethernet.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/ethernet.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,1281 +1,1280 @@
-//*****************************************************************************
-//
-// ethernet.c - Driver for the Integrated Ethernet Controller
-//
-// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup ethernet_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;hw_ethernet.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-#include &quot;sysctl.h&quot;
-#include &quot;ethernet.h&quot;
-
-//*****************************************************************************
-//
-//! Initializes the Ethernet controller for operation.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param ulEthClk is the rate of the clock supplied to the Ethernet module.
-//!
-//! This function will prepare the Ethernet controller for first time use in
-//! a given hardware/software configuration.  This function should be called
-//! before any other Ethernet API functions are called.
-//!
-//! The peripheral clock will be the same as the processor clock.  This will be
-//! the value returned by SysCtlClockGet(), or it can be explicitly hard-coded
-//! if it is constant and known (to save the code/execution overhead of a call
-//! to SysCtlClockGet()).
-//!
-//! This function replaces the original EthernetInit() API and performs the
-//! same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to map the
-//! original API to this API.
-//!
-//! \note If the device configuration is changed (for example, the system clock
-//! is reprogrammed to a different speed), then the Ethernet controller must be
-//! disabled by calling the EthernetDisable() function and the controller must
-//! be reinitialized by calling the EthernetInitExpClk() function again.  After
-//! the controller has been reinitialized, the controller should be
-//! reconfigured using the appropriate Ethernet API calls.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetInitExpClk(unsigned long ulBase, unsigned long ulEthClk)
-{
-    unsigned long ulDiv;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Set the Management Clock Divider register for access to the PHY
-    // register set (via EthernetPHYRead/Write).
-    //
-    // The MDC clock divided down from the system clock using the following
-    // formula.  A maximum of 2.5MHz is allowed for F(mdc).
-    //
-    //      F(mdc) = F(sys) / (2 * (div + 1))
-    //      div = (F(sys) / (2 * F(mdc))) - 1
-    //      div = (F(sys) / 2 / F(mdc)) - 1
-    //
-    // Note: Because we should round up, to ensure we don't violate the
-    // maximum clock speed, we can simplify this as follows:
-    //
-    //      div = F(sys) / 2 / F(mdc)
-    //
-    // For example, given a system clock of 6.0MHz, and a div value of 1,
-    // the mdc clock would be programmed as 1.5 MHz.
-    //
-    ulDiv = (ulEthClk / 2) / 2500000;
-    HWREG(ulBase + MAC_O_MDV) = (ulDiv &amp; MAC_MDV_DIV_M);
-}
-
-//*****************************************************************************
-//
-//! Sets the configuration of the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param ulConfig is the configuration for the controller.
-//!
-//! After the EthernetInitExpClk() function has been called, this API function
-//! can be used to configure the various features of the Ethernet controller.
-//!
-//! The Ethernet controller provides three control registers that are used
-//! to configure the controller's operation.  The transmit control register
-//! provides settings to enable full duplex operation, to auto-generate the
-//! frame check sequence, and to pad the transmit packets to the minimum
-//! length as required by the IEEE standard.  The receive control register
-//! provides settings to enable reception of packets with bad frame check
-//! sequence values and to enable multi-cast or promiscuous modes.  The
-//! timestamp control register provides settings that enable support logic in
-//! the controller that allow the use of the General Purpose Timer 3 to capture
-//! timestamps for the transmitted and received packets.
-//!
-//! The \e ulConfig parameter is the logical OR of the following values:
-//!
-//! - \b ETH_CFG_TS_TSEN - Enable TX and RX interrupt status as CCP timer
-//! inputs
-//! - \b ETH_CFG_RX_BADCRCDIS - Disable reception of packets with a bad CRC
-//! - \b ETH_CFG_RX_PRMSEN - Enable promiscuous mode reception (all packets)
-//! - \b ETH_CFG_RX_AMULEN - Enable reception of multicast packets
-//! - \b ETH_CFG_TX_DPLXEN - Enable full duplex transmit mode
-//! - \b ETH_CFG_TX_CRCEN - Enable transmit with auto CRC generation
-//! - \b ETH_CFG_TX_PADEN - Enable padding of transmit data to minimum size
-//!
-//! These bit-mapped values are programmed into the transmit, receive, and/or
-//! timestamp control register.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetConfigSet(unsigned long ulBase, unsigned long ulConfig)
-{
-    unsigned long ulTemp;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT((ulConfig &amp; ~(ETH_CFG_TX_DPLXEN | ETH_CFG_TX_CRCEN |
-                         ETH_CFG_TX_PADEN | ETH_CFG_RX_BADCRCDIS |
-                         ETH_CFG_RX_PRMSEN | ETH_CFG_RX_AMULEN |
-                         ETH_CFG_TS_TSEN)) == 0);
-
-    //
-    // Setup the Transmit Control Register.
-    //
-    ulTemp  = HWREG(ulBase + MAC_O_TCTL);
-    ulTemp &amp;= ~(MAC_TCTL_DUPLEX | MAC_TCTL_CRC | MAC_TCTL_PADEN);
-    ulTemp |= ulConfig &amp; 0x0FF;
-    HWREG(ulBase + MAC_O_TCTL) = ulTemp;
-
-    //
-    // Setup the Receive Control Register.
-    //
-    ulTemp  = HWREG(ulBase + MAC_O_RCTL);
-    ulTemp &amp;= ~(MAC_RCTL_BADCRC | MAC_RCTL_PRMS | MAC_RCTL_AMUL);
-    ulTemp |= (ulConfig &gt;&gt; 8) &amp; 0x0FF;
-    HWREG(ulBase + MAC_O_RCTL) = ulTemp;
-
-    //
-    // Setup the Time Stamp Configuration register.
-    //
-    ulTemp = HWREG(ulBase + MAC_O_TS);
-    ulTemp &amp;= ~(MAC_TS_TSEN);
-    ulTemp |= (ulConfig &gt;&gt; 16) &amp; 0x0FF;
-    HWREG(ulBase + MAC_O_TS) = ulTemp;
-}
-
-//*****************************************************************************
-//
-//! Gets the current configuration of the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//!
-//! This function will query the control registers of the Ethernet controller
-//! and return a bit-mapped configuration value.
-//!
-//! \sa The description of the EthernetConfigSet() function provides detailed
-//! information for the bit-mapped configuration values that will be returned.
-//!
-//! \return Returns the bit-mapped Ethernet controller configuration value.
-//
-//*****************************************************************************
-unsigned long
-EthernetConfigGet(unsigned long ulBase)
-{
-    unsigned long ulConfig;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Read and return the Ethernet controller configuration parameters,
-    // properly shifted into the appropriate bit field positions.
-    //
-    ulConfig = HWREG(ulBase + MAC_O_TS) &lt;&lt; 16;
-    ulConfig |= (HWREG(ulBase + MAC_O_RCTL) &amp; ~(MAC_RCTL_RXEN)) &lt;&lt; 8;
-    ulConfig |= HWREG(ulBase + MAC_O_TCTL) &amp; ~(MAC_TCTL_TXEN);
-    return(ulConfig);
-}
-
-//*****************************************************************************
-//
-//! Sets the MAC address of the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucMACAddr is the pointer to the array of MAC-48 address octets.
-//!
-//! This function will program the IEEE-defined MAC-48 address specified in
-//! \e pucMACAddr into the Ethernet controller.  This address is used by the
-//! Ethernet controller for hardware-level filtering of incoming Ethernet
-//! packets (when promiscuous mode is not enabled).
-//!
-//! The MAC-48 address is defined as 6 octets, illustrated by the following
-//! example address.  The numbers are shown in hexadecimal format.
-//!
-//!         AC-DE-48-00-00-80
-//!
-//! In this representation, the first three octets (AC-DE-48) are the
-//! Organizationally Unique Identifier (OUI).  This is a number assigned by
-//! the IEEE to an organization that requests a block of MAC addresses.  The
-//! last three octets (00-00-80) are a 24-bit number managed by the OUI owner
-//! to uniquely identify a piece of hardware within that organization that is
-//! to be connected to the Ethernet.
-//!
-//! In this representation, the octets are transmitted from left to right,
-//! with the ``AC'' octet being transmitted first and the ``80'' octet being
-//! transmitted last.  Within an octet, the bits are transmitted LSB to MSB.
-//! For this address, the first bit to be transmitted would be ``0'', the LSB
-//! of ``AC'', and the last bit to be transmitted would be ``1'', the MSB of
-//! ``80''.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetMACAddrSet(unsigned long ulBase, unsigned char *pucMACAddr)
-{
-    unsigned long ulTemp;
-    unsigned char *pucTemp = (unsigned char *)&ulTemp;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(pucMACAddr != 0);
-
-    //
-    // Program the MAC Address into the device.  The first four bytes of the
-    // MAC Address are placed into the IA0 register.  The remaining two bytes
-    // of the MAC address are placed into the IA1 register.
-    //
-    pucTemp[0] = pucMACAddr[0];
-    pucTemp[1] = pucMACAddr[1];
-    pucTemp[2] = pucMACAddr[2];
-    pucTemp[3] = pucMACAddr[3];
-    HWREG(ulBase + MAC_O_IA0) = ulTemp;
-    ulTemp = 0;
-    pucTemp[0] = pucMACAddr[4];
-    pucTemp[1] = pucMACAddr[5];
-    HWREG(ulBase + MAC_O_IA1) = ulTemp;
-}
-
-//*****************************************************************************
-//
-//! Gets the MAC address of the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucMACAddr is the pointer to the location in which to store the
-//! array of MAC-48 address octets.
-//!
-//! This function will read the currently programmed MAC address into the
-//! \e pucMACAddr buffer.
-//!
-//! \sa Refer to EthernetMACAddrSet() API description for more details about
-//! the MAC address format.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetMACAddrGet(unsigned long ulBase, unsigned char *pucMACAddr)
-{
-    unsigned long ulTemp;
-    unsigned char *pucTemp = (unsigned char *)&ulTemp;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(pucMACAddr != 0);
-
-    //
-    // Read the MAC address from the device.  The first four bytes of the
-    // MAC address are read from the IA0 register.  The remaining two bytes
-    // of the MAC addres
-    //
-    ulTemp = HWREG(ulBase + MAC_O_IA0);
-    pucMACAddr[0] = pucTemp[0];
-    pucMACAddr[1] = pucTemp[1];
-    pucMACAddr[2] = pucTemp[2];
-    pucMACAddr[3] = pucTemp[3];
-    ulTemp = HWREG(ulBase + MAC_O_IA1);
-    pucMACAddr[4] = pucTemp[0];
-    pucMACAddr[5] = pucTemp[1];
-}
-
-//*****************************************************************************
-//
-//! Enables the Ethernet controller for normal operation.
-//!
-//! \param ulBase is the base address of the controller.
-//!
-//! Once the Ethernet controller has been configured using the
-//! EthernetConfigSet() function and the MAC address has been programmed using
-//! the EthernetMACAddrSet() function, this API function can be called to
-//! enable the controller for normal operation.
-//!
-//! This function will enable the controller's transmitter and receiver, and
-//! will reset the receive FIFO.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetEnable(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Reset the receive FIFO.
-    //
-    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
-
-    //
-    // Enable the Ethernet receiver.
-    //
-    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RXEN;
-
-    //
-    // Enable Ethernet transmitter.
-    //
-    HWREG(ulBase + MAC_O_TCTL) |= MAC_TCTL_TXEN;
-
-    //
-    // Reset the receive FIFO again, after the receiver has been enabled.
-    //
-    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
-}
-
-//*****************************************************************************
-//
-//! Disables the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//!
-//! When terminating operations on the Ethernet interface, this function should
-//! be called.  This function will disable the transmitter and receiver, and
-//! will clear out the receive FIFO.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetDisable(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Reset the receive FIFO.
-    //
-    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
-
-    //
-    // Disable the Ethernet transmitter.
-    //
-    HWREG(ulBase + MAC_O_TCTL) &amp;= ~(MAC_TCTL_TXEN);
-
-    //
-    // Disable the Ethernet receiver.
-    //
-    HWREG(ulBase + MAC_O_RCTL) &amp;= ~(MAC_RCTL_RXEN);
-
-    //
-    // Reset the receive FIFO again, after the receiver has been disabled.
-    //
-    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
-}
-
-//*****************************************************************************
-//
-//! Check for packet available from the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//!
-//! The Ethernet controller provides a register that contains the number of
-//! packets available in the receive FIFO.  When the last bytes of a packet are
-//! successfully received (that is, the frame check sequence bytes), the packet
-//! count is incremented.  Once the packet has been fully read (including the
-//! frame check sequence bytes) from the FIFO, the packet count will be
-//! decremented.
-//!
-//! \return Returns \b true if there are one or more packets available in the
-//! receive FIFO, including the current packet being read, and \b false
-//! otherwise.
-//
-//*****************************************************************************
-tBoolean
-EthernetPacketAvail(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Return the availability of packets.
-    //
-    return((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) ? true : false);
-}
-
-//*****************************************************************************
-//
-//! Checks for packet space available in the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//!
-//! The Ethernet controller's transmit FIFO is designed to support a single
-//! packet at a time.  After the packet has been written into the FIFO, the
-//! transmit request bit must be set to enable the transmission of the packet.
-//! Only after the packet has been transmitted can a new packet be written
-//! into the FIFO.  This function will simply check to see if a packet is
-//! in progress.  If so, there is no space available in the transmit FIFO.
-//!
-//! \return Returns \b true if a space is available in the transmit FIFO, and
-//! \b false otherwise.
-//
-//*****************************************************************************
-tBoolean
-EthernetSpaceAvail(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Return the availability of space.
-    //
-    return((HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX) ? false : true);
-}
-
-//*****************************************************************************
-//
-//! \internal
-//!
-//! Internal function for reading a packet from the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucBuf is the pointer to the packet buffer.
-//! \param lBufLen is the maximum number of bytes to be read into the buffer.
-//!
-//! Based on the following table of how the receive frame is stored in the
-//! receive FIFO, this function will extract a packet from the FIFO and store
-//! it in the packet buffer that was passed in.
-//!
-//! Format of the data in the RX FIFO is as follows:
-//!
-//! \verbatim
-//! +---------+----------+----------+----------+----------+
-//! |         | 31:24    | 23:16    | 15:8     | 7:0      |
-//! +---------+----------+----------+----------+----------+
-//! | Word 0  | DA 2     | DA 1     | FL MSB   | FL LSB   |
-//! +---------+----------+----------+----------+----------+
-//! | Word 1  | DA 6     | DA 5     | DA 4     | DA 3     |
-//! +---------+----------+----------+----------+----------+
-//! | Word 2  | SA 4     | SA 3     | SA 2     | SA 1     |
-//! +---------+----------+----------+----------+----------+
-//! | Word 3  | FT LSB   | FT MSB   | SA 6     | SA 5     |
-//! +---------+----------+----------+----------+----------+
-//! | Word 4  | DATA 4   | DATA 3   | DATA 2   | DATA 1   |
-//! +---------+----------+----------+----------+----------+
-//! | Word 5  | DATA 8   | DATA 7   | DATA 6   | DATA 5   |
-//! +---------+----------+----------+----------+----------+
-//! | Word 6  | DATA 12  | DATA 11  | DATA 10  | DATA 9   |
-//! +---------+----------+----------+----------+----------+
-//! | ...     |          |          |          |          |
-//! +---------+----------+----------+----------+----------+
-//! | Word X  | DATA n   | DATA n-1 | DATA n-2 | DATA n-3 |
-//! +---------+----------+----------+----------+----------+
-//! | Word Y  | FCS 4    | FCS 3    | FCS 2    | FCS 1    |
-//! +---------+----------+----------+----------+----------+
-//! \endverbatim
-//!
-//! Where FL is Frame Length, (FL + DA + SA + FT + DATA + FCS) Bytes.
-//! Where DA is Destination (MAC) Address.
-//! Where SA is Source (MAC) Address.
-//! Where FT is Frame Type (or Frame Length for Ethernet).
-//! Where DATA is Payload Data for the Ethernet Frame.
-//! Where FCS is the Frame Check Sequence.
-//!
-//! \return Returns the negated packet length \b -n if the packet is too large
-//! for \e pucBuf, and returns the packet length \b n otherwise.
-//
-//*****************************************************************************
-static long
-EthernetPacketGetInternal(unsigned long ulBase, unsigned char *pucBuf,
-                          long lBufLen)
-{
-    unsigned long ulTemp;
-    long lFrameLen, lTempLen;
-    long i = 0;
-
-    //
-    // Read WORD 0 (see format above) from the FIFO, set the receive
-    // Frame Length and store the first two bytes of the destination
-    // address in the receive buffer.
-    //
-    ulTemp = HWREG(ulBase + MAC_O_DATA);
-    lFrameLen = (long)(ulTemp &amp; 0xFFFF);
-    pucBuf[i++] = (unsigned char) ((ulTemp &gt;&gt; 16) &amp; 0xff);
-    pucBuf[i++] = (unsigned char) ((ulTemp &gt;&gt; 24) &amp; 0xff);
-
-    //
-    // Read all but the last WORD into the receive buffer.
-    //
-    lTempLen = (lBufLen &lt; (lFrameLen - 6)) ? lBufLen : (lFrameLen - 6);
-    while(i &lt;= (lTempLen - 4))
-    {
-        *(unsigned long *)&amp;pucBuf[i] = HWREG(ulBase + MAC_O_DATA);
-        i += 4;
-    }
-
-    //
-    // Read the last 1, 2, or 3 BYTES into the buffer
-    //
-    if(i &lt; lTempLen)
-    {
-        ulTemp = HWREG(ulBase + MAC_O_DATA);
-        if(i == lTempLen - 3)
-        {
-            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
-            pucBuf[i++] = ((ulTemp &gt;&gt;  8) &amp; 0xff);
-            pucBuf[i++] = ((ulTemp &gt;&gt; 16) &amp; 0xff);
-            i += 1;
-        }
-        else if(i == lTempLen - 2)
-        {
-            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
-            pucBuf[i++] = ((ulTemp &gt;&gt;  8) &amp; 0xff);
-            i += 2;
-        }
-        else if(i == lTempLen - 1)
-        {
-            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
-            i += 3;
-        }
-    }
-
-    //
-    // Read any remaining WORDS (that did not fit into the buffer).
-    //
-    while(i &lt; (lFrameLen - 2))
-    {
-        ulTemp = HWREG(ulBase + MAC_O_DATA);
-        i += 4;
-    }
-
-    //
-    // If frame was larger than the buffer, return the &quot;negative&quot; frame length
-    //
-    lFrameLen -= 6;
-    if(lFrameLen &gt; lBufLen)
-    {
-        return(-lFrameLen);
-    }
-
-    //
-    // Return the Frame Length
-    //
-    return(lFrameLen);
-}
-
-//*****************************************************************************
-//
-//! Receives a packet from the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucBuf is the pointer to the packet buffer.
-//! \param lBufLen is the maximum number of bytes to be read into the buffer.
-//!
-//! This function reads a packet from the receive FIFO of the controller and
-//! places it into \e pucBuf.  If no packet is available the function will
-//! return immediately.  Otherwise, the function will read the entire packet
-//! from the receive FIFO.  If there are more bytes in the packet than will fit
-//! into \e pucBuf (as specified by \e lBufLen), the function will return the
-//! negated length of the packet and the buffer will contain \e lBufLen bytes
-//! of the packet.  Otherwise, the function will return the length of the
-//! packet that was read and \e pucBuf will contain the entire packet
-//! (excluding the frame check sequence bytes).
-//!
-//! This function replaces the original EthernetPacketNonBlockingGet() API and
-//! performs the same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to
-//! map the original API to this API.
-//!
-//! \note This function will return immediately if no packet is available.
-//!
-//! \return Returns \b 0 if no packet is available, the negated packet length
-//! \b -n if the packet is too large for \e pucBuf, and the packet length \b n
-//! otherwise.
-//
-//*****************************************************************************
-long
-EthernetPacketGetNonBlocking(unsigned long ulBase, unsigned char *pucBuf,
-                             long lBufLen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(pucBuf != 0);
-    ASSERT(lBufLen &gt; 0);
-
-    //
-    // Check to see if any packets are available.
-    //
-    if((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) == 0)
-    {
-        return(0);
-    }
-
-    //
-    // Read the packet, and return.
-    //
-    return(EthernetPacketGetInternal(ulBase, pucBuf, lBufLen));
-}
-
-//*****************************************************************************
-//
-//! Waits for a packet from the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucBuf is the pointer to the packet buffer.
-//! \param lBufLen is the maximum number of bytes to be read into the buffer.
-//!
-//! This function reads a packet from the receive FIFO of the controller and
-//! places it into \e pucBuf.  The function will wait until a packet is
-//! available in the FIFO.  Then the function will read the entire packet
-//! from the receive FIFO.  If there are more bytes in the packet than will
-//! fit into \e pucBuf (as specified by \e lBufLen), the function will return
-//! the negated length of the packet and the buffer will contain \e lBufLen
-//! bytes of the packet.  Otherwise, the function will return the length of
-//! the packet that was read and \e pucBuf will contain the entire packet
-//! (excluding the frame check sequence bytes).
-//!
-//! \note This function is blocking and will not return until a packet arrives.
-//!
-//! \return Returns the negated packet length \b -n if the packet is too large
-//! for \e pucBuf, and returns the packet length \b n otherwise.
-//
-//*****************************************************************************
-long
-EthernetPacketGet(unsigned long ulBase, unsigned char *pucBuf,
-                  long lBufLen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(pucBuf != 0);
-    ASSERT(lBufLen &gt; 0);
-
-    //
-    // Wait for a packet to become available
-    //
-    while((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) == 0)
-    {
-    }
-
-    //
-    // Read the packet
-    //
-    return(EthernetPacketGetInternal(ulBase, pucBuf, lBufLen));
-}
-
-//*****************************************************************************
-//
-//! \internal
-//!
-//! Internal function for sending a packet to the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucBuf is the pointer to the packet buffer.
-//! \param lBufLen is number of bytes in the packet to be transmitted.
-//!
-//! Puts a packet into the transmit FIFO of the controller.
-//!
-//! Format of the data in the TX FIFO is as follows:
-//!
-//! \verbatim
-//! +---------+----------+----------+----------+----------+
-//! |         | 31:24    | 23:16    | 15:8     | 7:0      |
-//! +---------+----------+----------+----------+----------+
-//! | Word 0  | DA 2     | DA 1     | PL MSB   | PL LSB   |
-//! +---------+----------+----------+----------+----------+
-//! | Word 1  | DA 6     | DA 5     | DA 4     | DA 3     |
-//! +---------+----------+----------+----------+----------+
-//! | Word 2  | SA 4     | SA 3     | SA 2     | SA 1     |
-//! +---------+----------+----------+----------+----------+
-//! | Word 3  | FT LSB   | FT MSB   | SA 6     | SA 5     |
-//! +---------+----------+----------+----------+----------+
-//! | Word 4  | DATA 4   | DATA 3   | DATA 2   | DATA 1   |
-//! +---------+----------+----------+----------+----------+
-//! | Word 5  | DATA 8   | DATA 7   | DATA 6   | DATA 5   |
-//! +---------+----------+----------+----------+----------+
-//! | Word 6  | DATA 12  | DATA 11  | DATA 10  | DATA 9   |
-//! +---------+----------+----------+----------+----------+
-//! | ...     |          |          |          |          |
-//! +---------+----------+----------+----------+----------+
-//! | Word X  | DATA n   | DATA n-1 | DATA n-2 | DATA n-3 |
-//! +---------+----------+----------+----------+----------+
-//! \endverbatim
-//!
-//! Where PL is Payload Length, (DATA) only
-//! Where DA is Destination (MAC) Address
-//! Where SA is Source (MAC) Address
-//! Where FT is Frame Type (or Frame Length for Ethernet)
-//! Where DATA is Payload Data for the Ethernet Frame
-//!
-//! \return Returns the negated packet length \b -lBufLen if the packet is too
-//! large for FIFO, and the packet length \b lBufLen otherwise.
-//
-//*****************************************************************************
-static long
-EthernetPacketPutInternal(unsigned long ulBase, unsigned char *pucBuf,
-                          long lBufLen)
-{
-    unsigned long ulTemp;
-    long i = 0;
-
-    //
-    // If the packet is too large, return the negative packet length as
-    // an error code.
-    //
-    if(lBufLen &gt; (2048 - 2))
-    {
-        return(-lBufLen);
-    }
-
-    //
-    // Build and write WORD 0 (see format above) to the transmit FIFO.
-    //
-    ulTemp = (unsigned long)(lBufLen - 14);
-    ulTemp |= (pucBuf[i++] &lt;&lt; 16);
-    ulTemp |= (pucBuf[i++] &lt;&lt; 24);
-    HWREG(ulBase + MAC_O_DATA) = ulTemp;
-
-    //
-    // Write each subsequent WORD n to the transmit FIFO, except for the last
-    // WORD (if the word does not contain 4 bytes).
-    //
-    while(i &lt;= (lBufLen - 4))
-    {
-        HWREG(ulBase + MAC_O_DATA) = *(unsigned long *)&amp;pucBuf[i];
-        i += 4;
-    }
-
-    //
-    // Build the last word of the remaining 1, 2, or 3 bytes, and store
-    // the WORD into the transmit FIFO.
-    //
-    if(i != lBufLen)
-    {
-        if(i == (lBufLen - 3))
-        {
-            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
-            ulTemp |= (pucBuf[i++] &lt;&lt;  8);
-            ulTemp |= (pucBuf[i++] &lt;&lt; 16);
-            HWREG(ulBase + MAC_O_DATA) = ulTemp;
-        }
-        else if(i == (lBufLen - 2))
-        {
-            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
-            ulTemp |= (pucBuf[i++] &lt;&lt;  8);
-            HWREG(ulBase + MAC_O_DATA) = ulTemp;
-        }
-        else if(i == (lBufLen - 1))
-        {
-            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
-            HWREG(ulBase + MAC_O_DATA) = ulTemp;
-        }
-    }
-
-    //
-    // Activate the transmitter
-    //
-    HWREG(ulBase + MAC_O_TR) = MAC_TR_NEWTX;
-
-    //
-    // Return the Buffer Length transmitted.
-    //
-    return(lBufLen);
-}
-
-//*****************************************************************************
-//
-//! Sends a packet to the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucBuf is the pointer to the packet buffer.
-//! \param lBufLen is number of bytes in the packet to be transmitted.
-//!
-//! This function writes \e lBufLen bytes of the packet contained in \e pucBuf
-//! into the transmit FIFO of the controller and then activates the
-//! transmitter for this packet.  If no space is available in the FIFO, the
-//! function will return immediately.  If space is available, the
-//! function will return once \e lBufLen bytes of the packet have been placed
-//! into the FIFO and the transmitter has been started.  The function will not
-//! wait for the transmission to complete.  The function will return the
-//! negated \e lBufLen if the length is larger than the space available in
-//! the transmit FIFO.
-//!
-//! This function replaces the original EthernetPacketNonBlockingPut() API and
-//! performs the same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to
-//! map the original API to this API.
-//!
-//! \note This function does not block and will return immediately if no space
-//! is available for the transmit packet.
-//!
-//! \return Returns \b 0 if no space is available in the transmit FIFO, the
-//! negated packet length \b -lBufLen if the packet is too large for FIFO, and
-//! the packet length \b lBufLen otherwise.
-//
-//*****************************************************************************
-long
-EthernetPacketPutNonBlocking(unsigned long ulBase, unsigned char *pucBuf,
-                             long lBufLen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(pucBuf != 0);
-    ASSERT(lBufLen &gt; 0);
-
-    //
-    // Check if the transmit FIFO is in use and return the appropriate code.
-    //
-    if(HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX)
-    {
-        return(0);
-    }
-
-    //
-    // Send the packet and return.
-    //
-    return(EthernetPacketPutInternal(ulBase, pucBuf, lBufLen));
-}
-
-//*****************************************************************************
-//
-//! Waits to send a packet from the Ethernet controller.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pucBuf is the pointer to the packet buffer.
-//! \param lBufLen is number of bytes in the packet to be transmitted.
-//!
-//! This function writes \e lBufLen bytes of the packet contained in \e pucBuf
-//! into the transmit FIFO of the controller and then activates the transmitter
-//! for this packet.  This function will wait until the transmit FIFO is empty.
-//! Once space is available, the function will return once \e lBufLen bytes of
-//! the packet have been placed into the FIFO and the transmitter has been
-//! started.  The function will not wait for the transmission to complete.  The
-//! function will return the negated \e lBufLen if the length is larger than
-//! the space available in the transmit FIFO.
-//!
-//! \note This function blocks and will wait until space is available for the
-//! transmit packet before returning.
-//!
-//! \return Returns the negated packet length \b -lBufLen if the packet is too
-//! large for FIFO, and the packet length \b lBufLen otherwise.
-//
-//*****************************************************************************
-long
-EthernetPacketPut(unsigned long ulBase, unsigned char *pucBuf,
-                  long lBufLen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(pucBuf != 0);
-    ASSERT(lBufLen &gt; 0);
-
-    //
-    // Wait for current packet (if any) to complete.
-    //
-    while(HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX)
-    {
-    }
-
-    //
-    // Send the packet and return.
-    //
-    return(EthernetPacketPutInternal(ulBase, pucBuf, lBufLen));
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for an Ethernet interrupt.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param pfnHandler is a pointer to the function to be called when the
-//! enabled Ethernet interrupts occur.
-//!
-//! This function sets the handler to be called when the Ethernet interrupt
-//! occurs.  This will enable the global interrupt in the interrupt controller;
-//! specific Ethernet interrupts must be enabled via EthernetIntEnable().  It
-//! is the interrupt handler's responsibility to clear the interrupt source.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(pfnHandler != 0);
-
-    //
-    // Register the interrupt handler.
-    //
-    IntRegister(INT_ETH, pfnHandler);
-
-    //
-    // Enable the Ethernet interrupt.
-    //
-    IntEnable(INT_ETH);
-}
-
-//*****************************************************************************
-//
-//! Unregisters an interrupt handler for an Ethernet interrupt.
-//!
-//! \param ulBase is the base address of the controller.
-//!
-//! This function unregisters the interrupt handler.  This will disable the
-//! global interrupt in the interrupt controller so that the interrupt handler
-//! no longer is called.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetIntUnregister(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Disable the interrupt.
-    //
-    IntDisable(INT_ETH);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(INT_ETH);
-}
-
-//*****************************************************************************
-//
-//! Enables individual Ethernet interrupt sources.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
-//!
-//! Enables the indicated Ethernet interrupt sources.  Only the sources that
-//! are enabled can be reflected to the processor interrupt; disabled sources
-//! have no effect on the processor.
-//!
-//! The \e ulIntFlags parameter is the logical OR of any of the following:
-//!
-//! - \b ETH_INT_PHY - An interrupt from the PHY has occurred.  The integrated
-//! PHY supports a number of interrupt conditions.  The PHY register, PHY_MR17,
-//! must be read to determine which PHY interrupt has occurred.  This register
-//! can be read using the EthernetPHYRead() API function.
-//! - \b ETH_INT_MDIO - This interrupt indicates that a transaction on the
-//! management interface has completed successfully.
-//! - \b ETH_INT_RXER - This interrupt indicates that an error has occurred
-//! during reception of a frame.  This error can indicate a length mismatch, a
-//! CRC failure, or an error indication from the PHY.
-//! - \b ETH_INT_RXOF - This interrupt indicates that a frame has been received
-//! that exceeds the available space in the RX FIFO.
-//! - \b ETH_INT_TX - This interrupt indicates that the packet stored in the TX
-//! FIFO has been successfully transmitted.
-//! - \b ETH_INT_TXER - This interrupt indicates that an error has occurred
-//! during the transmission of a packet.  This error can be either a retry
-//! failure during the back-off process, or an invalid length stored in the TX
-//! FIFO.
-//! - \b ETH_INT_RX - This interrupt indicates that one (or more) packets are
-//! available in the RX FIFO for processing.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
-                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
-                            ETH_INT_RX)));
-
-    //
-    // Enable the specified interrupts.
-    //
-    HWREG(ulBase + MAC_O_IM) |= ulIntFlags;
-}
-
-//*****************************************************************************
-//
-//! Disables individual Ethernet interrupt sources.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
-//!
-//! Disables the indicated Ethernet interrupt sources.  Only the sources that
-//! are enabled can be reflected to the processor interrupt; disabled sources
-//! have no effect on the processor.
-//!
-//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
-//! parameter to EthernetIntEnable().
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
-                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
-                            ETH_INT_RX)));
-
-    //
-    // Disable the specified interrupts.
-    //
-    HWREG(ulBase + MAC_O_IM) &amp;= ~ulIntFlags;
-}
-
-//*****************************************************************************
-//
-//! Gets the current Ethernet interrupt status.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param bMasked is false if the raw interrupt status is required and true
-//! if the masked interrupt status is required.
-//!
-//! This returns the interrupt status for the Ethernet controller.  Either the
-//! raw interrupt status or the status of interrupts that are allowed to
-//! reflect to the processor can be returned.
-//!
-//! \return Returns the current interrupt status, enumerated as a bit field of
-//! values described in EthernetIntEnable().
-//
-//*****************************************************************************
-unsigned long
-EthernetIntStatus(unsigned long ulBase, tBoolean bMasked)
-{
-    unsigned long ulStatus;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Read the unmasked status.
-    //
-    ulStatus = HWREG(ulBase + MAC_O_RIS);
-
-    //
-    // If masked status is requested, mask it off.
-    //
-    if(bMasked)
-    {
-        ulStatus &amp;= HWREG(ulBase + MAC_O_IM);
-    }
-
-    //
-    // Return the interrupt status value.
-    //
-    return(ulStatus);
-}
-
-//*****************************************************************************
-//
-//! Clears Ethernet interrupt sources.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
-//!
-//! The specified Ethernet interrupt sources are cleared so that they no longer
-//! assert.  This must be done in the interrupt handler to keep it from being
-//! called again immediately upon exit.
-//!
-//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
-//! parameter to EthernetIntEnable().
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetIntClear(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
-                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
-                            ETH_INT_RX)));
-
-    //
-    // Clear the requested interrupt sources.
-    //
-    HWREG(ulBase + MAC_O_IACK) = ulIntFlags;
-}
-
-//*****************************************************************************
-//
-//! Writes to the PHY register.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param ucRegAddr is the address of the PHY register to be accessed.
-//! \param ulData is the data to be written to the PHY register.
-//!
-//! This function will write the \e ulData to the PHY register specified by
-//! \e ucRegAddr.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-EthernetPHYWrite(unsigned long ulBase, unsigned char ucRegAddr,
-                 unsigned long ulData)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Wait for any pending transaction to complete.
-    //
-    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
-    {
-    }
-
-    //
-    // Program the DATA to be written.
-    //
-    HWREG(ulBase + MAC_O_MTXD) = ulData &amp; MAC_MTXD_MDTX_M;
-
-    //
-    // Program the PHY register address and initiate the transaction.
-    //
-    HWREG(ulBase + MAC_O_MCTL) = (((ucRegAddr &lt;&lt; 3) &amp; MAC_MCTL_REGADR_M) |
-                                  MAC_MCTL_WRITE | MAC_MCTL_START);
-
-    //
-    // Wait for the write transaction to complete.
-    //
-    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
-    {
-    }
-}
-
-//*****************************************************************************
-//
-//! Reads from a PHY register.
-//!
-//! \param ulBase is the base address of the controller.
-//! \param ucRegAddr is the address of the PHY register to be accessed.
-//!
-//! This function will return the contents of the PHY register specified by
-//! \e ucRegAddr.
-//!
-//! \return Returns the 16-bit value read from the PHY.
-//
-//*****************************************************************************
-unsigned long
-EthernetPHYRead(unsigned long ulBase, unsigned char ucRegAddr)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == ETH_BASE);
-
-    //
-    // Wait for any pending transaction to complete.
-    //
-    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
-    {
-    }
-
-    //
-    // Program the PHY register address and initiate the transaction.
-    //
-    HWREG(ulBase + MAC_O_MCTL) = (((ucRegAddr &lt;&lt; 3) &amp; MAC_MCTL_REGADR_M) |
-                                  MAC_MCTL_START);
-
-    //
-    // Wait for the transaction to complete.
-    //
-    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
-    {
-    }
-
-    //
-    // Return the PHY data that was read.
-    //
-    return(HWREG(ulBase + MAC_O_MRXD) &amp; MAC_MRXD_MDRX_M);
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// ethernet.c - Driver for the Integrated Ethernet Controller
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup ethernet_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ethernet.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;ethernet.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+//! Initializes the Ethernet controller for operation.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulEthClk is the rate of the clock supplied to the Ethernet module.
+//!
+//! This function will prepare the Ethernet controller for first time use in
+//! a given hardware/software configuration.  This function should be called
+//! before any other Ethernet API functions are called.
+//!
+//! The peripheral clock will be the same as the processor clock.  This will be
+//! the value returned by SysCtlClockGet(), or it can be explicitly hard-coded
+//! if it is constant and known (to save the code/execution overhead of a call
+//! to SysCtlClockGet()).
+//!
+//! This function replaces the original EthernetInit() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to map the
+//! original API to this API.
+//!
+//! \note If the device configuration is changed (for example, the system clock
+//! is reprogrammed to a different speed), then the Ethernet controller must be
+//! disabled by calling the EthernetDisable() function and the controller must
+//! be reinitialized by calling the EthernetInitExpClk() function again.  After
+//! the controller has been reinitialized, the controller should be
+//! reconfigured using the appropriate Ethernet API calls.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetInitExpClk(unsigned long ulBase, unsigned long ulEthClk)
+{
+    unsigned long ulDiv;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Set the Management Clock Divider register for access to the PHY
+    // register set (via EthernetPHYRead/Write).
+    //
+    // The MDC clock divided down from the system clock using the following
+    // formula.  A maximum of 2.5MHz is allowed for F(mdc).
+    //
+    //      F(mdc) = F(sys) / (2 * (div + 1))
+    //      div = (F(sys) / (2 * F(mdc))) - 1
+    //      div = (F(sys) / 2 / F(mdc)) - 1
+    //
+    // Note: Because we should round up, to ensure we don't violate the
+    // maximum clock speed, we can simplify this as follows:
+    //
+    //      div = F(sys) / 2 / F(mdc)
+    //
+    // For example, given a system clock of 6.0MHz, and a div value of 1,
+    // the mdc clock would be programmed as 1.5 MHz.
+    //
+    ulDiv = (ulEthClk / 2) / 2500000;
+    HWREG(ulBase + MAC_O_MDV) = (ulDiv &amp; MAC_MDV_DIV_M);
+}
+
+//*****************************************************************************
+//
+//! Sets the configuration of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulConfig is the configuration for the controller.
+//!
+//! After the EthernetInitExpClk() function has been called, this API function
+//! can be used to configure the various features of the Ethernet controller.
+//!
+//! The Ethernet controller provides three control registers that are used
+//! to configure the controller's operation.  The transmit control register
+//! provides settings to enable full duplex operation, to auto-generate the
+//! frame check sequence, and to pad the transmit packets to the minimum
+//! length as required by the IEEE standard.  The receive control register
+//! provides settings to enable reception of packets with bad frame check
+//! sequence values and to enable multi-cast or promiscuous modes.  The
+//! timestamp control register provides settings that enable support logic in
+//! the controller that allow the use of the General Purpose Timer 3 to capture
+//! timestamps for the transmitted and received packets.
+//!
+//! The \e ulConfig parameter is the logical OR of the following values:
+//!
+//! - \b ETH_CFG_TS_TSEN - Enable TX and RX interrupt status as CCP timer
+//! inputs
+//! - \b ETH_CFG_RX_BADCRCDIS - Disable reception of packets with a bad CRC
+//! - \b ETH_CFG_RX_PRMSEN - Enable promiscuous mode reception (all packets)
+//! - \b ETH_CFG_RX_AMULEN - Enable reception of multicast packets
+//! - \b ETH_CFG_TX_DPLXEN - Enable full duplex transmit mode
+//! - \b ETH_CFG_TX_CRCEN - Enable transmit with auto CRC generation
+//! - \b ETH_CFG_TX_PADEN - Enable padding of transmit data to minimum size
+//!
+//! These bit-mapped values are programmed into the transmit, receive, and/or
+//! timestamp control register.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetConfigSet(unsigned long ulBase, unsigned long ulConfig)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT((ulConfig &amp; ~(ETH_CFG_TX_DPLXEN | ETH_CFG_TX_CRCEN |
+                         ETH_CFG_TX_PADEN | ETH_CFG_RX_BADCRCDIS |
+                         ETH_CFG_RX_PRMSEN | ETH_CFG_RX_AMULEN |
+                         ETH_CFG_TS_TSEN)) == 0);
+
+    //
+    // Setup the Transmit Control Register.
+    //
+    ulTemp  = HWREG(ulBase + MAC_O_TCTL);
+    ulTemp &amp;= ~(MAC_TCTL_DUPLEX | MAC_TCTL_CRC | MAC_TCTL_PADEN);
+    ulTemp |= ulConfig &amp; 0x0FF;
+    HWREG(ulBase + MAC_O_TCTL) = ulTemp;
+
+    //
+    // Setup the Receive Control Register.
+    //
+    ulTemp  = HWREG(ulBase + MAC_O_RCTL);
+    ulTemp &amp;= ~(MAC_RCTL_BADCRC | MAC_RCTL_PRMS | MAC_RCTL_AMUL);
+    ulTemp |= (ulConfig &gt;&gt; 8) &amp; 0x0FF;
+    HWREG(ulBase + MAC_O_RCTL) = ulTemp;
+
+    //
+    // Setup the Time Stamp Configuration register.
+    //
+    ulTemp = HWREG(ulBase + MAC_O_TS);
+    ulTemp &amp;= ~(MAC_TS_TSEN);
+    ulTemp |= (ulConfig &gt;&gt; 16) &amp; 0x0FF;
+    HWREG(ulBase + MAC_O_TS) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Gets the current configuration of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! This function will query the control registers of the Ethernet controller
+//! and return a bit-mapped configuration value.
+//!
+//! \sa The description of the EthernetConfigSet() function provides detailed
+//! information for the bit-mapped configuration values that will be returned.
+//!
+//! \return Returns the bit-mapped Ethernet controller configuration value.
+//
+//*****************************************************************************
+unsigned long
+EthernetConfigGet(unsigned long ulBase)
+{
+    unsigned long ulConfig;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Read and return the Ethernet controller configuration parameters,
+    // properly shifted into the appropriate bit field positions.
+    //
+    ulConfig = HWREG(ulBase + MAC_O_TS) &lt;&lt; 16;
+    ulConfig |= (HWREG(ulBase + MAC_O_RCTL) &amp; ~(MAC_RCTL_RXEN)) &lt;&lt; 8;
+    ulConfig |= HWREG(ulBase + MAC_O_TCTL) &amp; ~(MAC_TCTL_TXEN);
+    return(ulConfig);
+}
+
+//*****************************************************************************
+//
+//! Sets the MAC address of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucMACAddr is the pointer to the array of MAC-48 address octets.
+//!
+//! This function will program the IEEE-defined MAC-48 address specified in
+//! \e pucMACAddr into the Ethernet controller.  This address is used by the
+//! Ethernet controller for hardware-level filtering of incoming Ethernet
+//! packets (when promiscuous mode is not enabled).
+//!
+//! The MAC-48 address is defined as 6 octets, illustrated by the following
+//! example address.  The numbers are shown in hexadecimal format.
+//!
+//!         AC-DE-48-00-00-80
+//!
+//! In this representation, the first three octets (AC-DE-48) are the
+//! Organizationally Unique Identifier (OUI).  This is a number assigned by
+//! the IEEE to an organization that requests a block of MAC addresses.  The
+//! last three octets (00-00-80) are a 24-bit number managed by the OUI owner
+//! to uniquely identify a piece of hardware within that organization that is
+//! to be connected to the Ethernet.
+//!
+//! In this representation, the octets are transmitted from left to right,
+//! with the ``AC'' octet being transmitted first and the ``80'' octet being
+//! transmitted last.  Within an octet, the bits are transmitted LSB to MSB.
+//! For this address, the first bit to be transmitted would be ``0'', the LSB
+//! of ``AC'', and the last bit to be transmitted would be ``1'', the MSB of
+//! ``80''.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetMACAddrSet(unsigned long ulBase, unsigned char *pucMACAddr)
+{
+    unsigned long ulTemp;
+    unsigned char *pucTemp = (unsigned char *)&ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucMACAddr != 0);
+
+    //
+    // Program the MAC Address into the device.  The first four bytes of the
+    // MAC Address are placed into the IA0 register.  The remaining two bytes
+    // of the MAC address are placed into the IA1 register.
+    //
+    pucTemp[0] = pucMACAddr[0];
+    pucTemp[1] = pucMACAddr[1];
+    pucTemp[2] = pucMACAddr[2];
+    pucTemp[3] = pucMACAddr[3];
+    HWREG(ulBase + MAC_O_IA0) = ulTemp;
+    ulTemp = 0;
+    pucTemp[0] = pucMACAddr[4];
+    pucTemp[1] = pucMACAddr[5];
+    HWREG(ulBase + MAC_O_IA1) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Gets the MAC address of the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucMACAddr is the pointer to the location in which to store the
+//! array of MAC-48 address octets.
+//!
+//! This function will read the currently programmed MAC address into the
+//! \e pucMACAddr buffer.
+//!
+//! \sa Refer to EthernetMACAddrSet() API description for more details about
+//! the MAC address format.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetMACAddrGet(unsigned long ulBase, unsigned char *pucMACAddr)
+{
+    unsigned long ulTemp;
+    unsigned char *pucTemp = (unsigned char *)&ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucMACAddr != 0);
+
+    //
+    // Read the MAC address from the device.  The first four bytes of the
+    // MAC address are read from the IA0 register.  The remaining two bytes
+    // of the MAC addres
+    //
+    ulTemp = HWREG(ulBase + MAC_O_IA0);
+    pucMACAddr[0] = pucTemp[0];
+    pucMACAddr[1] = pucTemp[1];
+    pucMACAddr[2] = pucTemp[2];
+    pucMACAddr[3] = pucTemp[3];
+    ulTemp = HWREG(ulBase + MAC_O_IA1);
+    pucMACAddr[4] = pucTemp[0];
+    pucMACAddr[5] = pucTemp[1];
+}
+
+//*****************************************************************************
+//
+//! Enables the Ethernet controller for normal operation.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! Once the Ethernet controller has been configured using the
+//! EthernetConfigSet() function and the MAC address has been programmed using
+//! the EthernetMACAddrSet() function, this API function can be called to
+//! enable the controller for normal operation.
+//!
+//! This function will enable the controller's transmitter and receiver, and
+//! will reset the receive FIFO.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetEnable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Reset the receive FIFO.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+
+    //
+    // Enable the Ethernet receiver.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RXEN;
+
+    //
+    // Enable Ethernet transmitter.
+    //
+    HWREG(ulBase + MAC_O_TCTL) |= MAC_TCTL_TXEN;
+
+    //
+    // Reset the receive FIFO again, after the receiver has been enabled.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+}
+
+//*****************************************************************************
+//
+//! Disables the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! When terminating operations on the Ethernet interface, this function should
+//! be called.  This function will disable the transmitter and receiver, and
+//! will clear out the receive FIFO.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetDisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Reset the receive FIFO.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+
+    //
+    // Disable the Ethernet transmitter.
+    //
+    HWREG(ulBase + MAC_O_TCTL) &amp;= ~(MAC_TCTL_TXEN);
+
+    //
+    // Disable the Ethernet receiver.
+    //
+    HWREG(ulBase + MAC_O_RCTL) &amp;= ~(MAC_RCTL_RXEN);
+
+    //
+    // Reset the receive FIFO again, after the receiver has been disabled.
+    //
+    HWREG(ulBase + MAC_O_RCTL) |= MAC_RCTL_RSTFIFO;
+}
+
+//*****************************************************************************
+//
+//! Check for packet available from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! The Ethernet controller provides a register that contains the number of
+//! packets available in the receive FIFO.  When the last bytes of a packet are
+//! successfully received (that is, the frame check sequence bytes), the packet
+//! count is incremented.  Once the packet has been fully read (including the
+//! frame check sequence bytes) from the FIFO, the packet count will be
+//! decremented.
+//!
+//! \return Returns \b true if there are one or more packets available in the
+//! receive FIFO, including the current packet being read, and \b false
+//! otherwise.
+//
+//*****************************************************************************
+tBoolean
+EthernetPacketAvail(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Return the availability of packets.
+    //
+    return((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) ? true : false);
+}
+
+//*****************************************************************************
+//
+//! Checks for packet space available in the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! The Ethernet controller's transmit FIFO is designed to support a single
+//! packet at a time.  After the packet has been written into the FIFO, the
+//! transmit request bit must be set to enable the transmission of the packet.
+//! Only after the packet has been transmitted can a new packet be written
+//! into the FIFO.  This function will simply check to see if a packet is
+//! in progress.  If so, there is no space available in the transmit FIFO.
+//!
+//! \return Returns \b true if a space is available in the transmit FIFO, and
+//! \b false otherwise.
+//
+//*****************************************************************************
+tBoolean
+EthernetSpaceAvail(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Return the availability of space.
+    //
+    return((HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX) ? false : true);
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Internal function for reading a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is the maximum number of bytes to be read into the buffer.
+//!
+//! Based on the following table of how the receive frame is stored in the
+//! receive FIFO, this function will extract a packet from the FIFO and store
+//! it in the packet buffer that was passed in.
+//!
+//! Format of the data in the RX FIFO is as follows:
+//!
+//! \verbatim
+//! +---------+----------+----------+----------+----------+
+//! |         | 31:24    | 23:16    | 15:8     | 7:0      |
+//! +---------+----------+----------+----------+----------+
+//! | Word 0  | DA 2     | DA 1     | FL MSB   | FL LSB   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 1  | DA 6     | DA 5     | DA 4     | DA 3     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 2  | SA 4     | SA 3     | SA 2     | SA 1     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 3  | FT LSB   | FT MSB   | SA 6     | SA 5     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 4  | DATA 4   | DATA 3   | DATA 2   | DATA 1   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 5  | DATA 8   | DATA 7   | DATA 6   | DATA 5   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 6  | DATA 12  | DATA 11  | DATA 10  | DATA 9   |
+//! +---------+----------+----------+----------+----------+
+//! | ...     |          |          |          |          |
+//! +---------+----------+----------+----------+----------+
+//! | Word X  | DATA n   | DATA n-1 | DATA n-2 | DATA n-3 |
+//! +---------+----------+----------+----------+----------+
+//! | Word Y  | FCS 4    | FCS 3    | FCS 2    | FCS 1    |
+//! +---------+----------+----------+----------+----------+
+//! \endverbatim
+//!
+//! Where FL is Frame Length, (FL + DA + SA + FT + DATA + FCS) Bytes.
+//! Where DA is Destination (MAC) Address.
+//! Where SA is Source (MAC) Address.
+//! Where FT is Frame Type (or Frame Length for Ethernet).
+//! Where DATA is Payload Data for the Ethernet Frame.
+//! Where FCS is the Frame Check Sequence.
+//!
+//! \return Returns the negated packet length \b -n if the packet is too large
+//! for \e pucBuf, and returns the packet length \b n otherwise.
+//
+//*****************************************************************************
+static long
+EthernetPacketGetInternal(unsigned long ulBase, unsigned char *pucBuf,
+                          long lBufLen)
+{
+    unsigned long ulTemp;
+    long lFrameLen, lTempLen;
+    long i = 0;
+
+    //
+    // Read WORD 0 (see format above) from the FIFO, set the receive
+    // Frame Length and store the first two bytes of the destination
+    // address in the receive buffer.
+    //
+    ulTemp = HWREG(ulBase + MAC_O_DATA);
+    lFrameLen = (long)(ulTemp &amp; 0xFFFF);
+    pucBuf[i++] = (unsigned char) ((ulTemp &gt;&gt; 16) &amp; 0xff);
+    pucBuf[i++] = (unsigned char) ((ulTemp &gt;&gt; 24) &amp; 0xff);
+
+    //
+    // Read all but the last WORD into the receive buffer.
+    //
+    lTempLen = (lBufLen &lt; (lFrameLen - 6)) ? lBufLen : (lFrameLen - 6);
+    while(i &lt;= (lTempLen - 4))
+    {
+        *(unsigned long *)&amp;pucBuf[i] = HWREG(ulBase + MAC_O_DATA);
+        i += 4;
+    }
+
+    //
+    // Read the last 1, 2, or 3 BYTES into the buffer
+    //
+    if(i &lt; lTempLen)
+    {
+        ulTemp = HWREG(ulBase + MAC_O_DATA);
+        if(i == lTempLen - 3)
+        {
+            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
+            pucBuf[i++] = ((ulTemp &gt;&gt;  8) &amp; 0xff);
+            pucBuf[i++] = ((ulTemp &gt;&gt; 16) &amp; 0xff);
+            i += 1;
+        }
+        else if(i == lTempLen - 2)
+        {
+            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
+            pucBuf[i++] = ((ulTemp &gt;&gt;  8) &amp; 0xff);
+            i += 2;
+        }
+        else if(i == lTempLen - 1)
+        {
+            pucBuf[i++] = ((ulTemp &gt;&gt;  0) &amp; 0xff);
+            i += 3;
+        }
+    }
+
+    //
+    // Read any remaining WORDS (that did not fit into the buffer).
+    //
+    while(i &lt; (lFrameLen - 2))
+    {
+        ulTemp = HWREG(ulBase + MAC_O_DATA);
+        i += 4;
+    }
+
+    //
+    // If frame was larger than the buffer, return the &quot;negative&quot; frame length
+    //
+    lFrameLen -= 6;
+    if(lFrameLen &gt; lBufLen)
+    {
+        return(-lFrameLen);
+    }
+
+    //
+    // Return the Frame Length
+    //
+    return(lFrameLen);
+}
+
+//*****************************************************************************
+//
+//! Receives a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is the maximum number of bytes to be read into the buffer.
+//!
+//! This function reads a packet from the receive FIFO of the controller and
+//! places it into \e pucBuf.  If no packet is available the function will
+//! return immediately.  Otherwise, the function will read the entire packet
+//! from the receive FIFO.  If there are more bytes in the packet than will fit
+//! into \e pucBuf (as specified by \e lBufLen), the function will return the
+//! negated length of the packet and the buffer will contain \e lBufLen bytes
+//! of the packet.  Otherwise, the function will return the length of the
+//! packet that was read and \e pucBuf will contain the entire packet
+//! (excluding the frame check sequence bytes).
+//!
+//! This function replaces the original EthernetPacketNonBlockingGet() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to
+//! map the original API to this API.
+//!
+//! \note This function will return immediately if no packet is available.
+//!
+//! \return Returns \b 0 if no packet is available, the negated packet length
+//! \b -n if the packet is too large for \e pucBuf, and the packet length \b n
+//! otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketGetNonBlocking(unsigned long ulBase, unsigned char *pucBuf,
+                             long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Check to see if any packets are available.
+    //
+    if((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) == 0)
+    {
+        return(0);
+    }
+
+    //
+    // Read the packet, and return.
+    //
+    return(EthernetPacketGetInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! Waits for a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is the maximum number of bytes to be read into the buffer.
+//!
+//! This function reads a packet from the receive FIFO of the controller and
+//! places it into \e pucBuf.  The function will wait until a packet is
+//! available in the FIFO.  Then the function will read the entire packet
+//! from the receive FIFO.  If there are more bytes in the packet than will
+//! fit into \e pucBuf (as specified by \e lBufLen), the function will return
+//! the negated length of the packet and the buffer will contain \e lBufLen
+//! bytes of the packet.  Otherwise, the function will return the length of
+//! the packet that was read and \e pucBuf will contain the entire packet
+//! (excluding the frame check sequence bytes).
+//!
+//! \note This function is blocking and will not return until a packet arrives.
+//!
+//! \return Returns the negated packet length \b -n if the packet is too large
+//! for \e pucBuf, and returns the packet length \b n otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketGet(unsigned long ulBase, unsigned char *pucBuf,
+                  long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Wait for a packet to become available
+    //
+    while((HWREG(ulBase + MAC_O_NP) &amp; MAC_NP_NPR_M) == 0)
+    {
+    }
+
+    //
+    // Read the packet
+    //
+    return(EthernetPacketGetInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Internal function for sending a packet to the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is number of bytes in the packet to be transmitted.
+//!
+//! Puts a packet into the transmit FIFO of the controller.
+//!
+//! Format of the data in the TX FIFO is as follows:
+//!
+//! \verbatim
+//! +---------+----------+----------+----------+----------+
+//! |         | 31:24    | 23:16    | 15:8     | 7:0      |
+//! +---------+----------+----------+----------+----------+
+//! | Word 0  | DA 2     | DA 1     | PL MSB   | PL LSB   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 1  | DA 6     | DA 5     | DA 4     | DA 3     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 2  | SA 4     | SA 3     | SA 2     | SA 1     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 3  | FT LSB   | FT MSB   | SA 6     | SA 5     |
+//! +---------+----------+----------+----------+----------+
+//! | Word 4  | DATA 4   | DATA 3   | DATA 2   | DATA 1   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 5  | DATA 8   | DATA 7   | DATA 6   | DATA 5   |
+//! +---------+----------+----------+----------+----------+
+//! | Word 6  | DATA 12  | DATA 11  | DATA 10  | DATA 9   |
+//! +---------+----------+----------+----------+----------+
+//! | ...     |          |          |          |          |
+//! +---------+----------+----------+----------+----------+
+//! | Word X  | DATA n   | DATA n-1 | DATA n-2 | DATA n-3 |
+//! +---------+----------+----------+----------+----------+
+//! \endverbatim
+//!
+//! Where PL is Payload Length, (DATA) only
+//! Where DA is Destination (MAC) Address
+//! Where SA is Source (MAC) Address
+//! Where FT is Frame Type (or Frame Length for Ethernet)
+//! Where DATA is Payload Data for the Ethernet Frame
+//!
+//! \return Returns the negated packet length \b -lBufLen if the packet is too
+//! large for FIFO, and the packet length \b lBufLen otherwise.
+//
+//*****************************************************************************
+static long
+EthernetPacketPutInternal(unsigned long ulBase, unsigned char *pucBuf,
+                          long lBufLen)
+{
+    unsigned long ulTemp;
+    long i = 0;
+
+    //
+    // If the packet is too large, return the negative packet length as
+    // an error code.
+    //
+    if(lBufLen &gt; (2048 - 2))
+    {
+        return(-lBufLen);
+    }
+
+    //
+    // Build and write WORD 0 (see format above) to the transmit FIFO.
+    //
+    ulTemp = (unsigned long)(lBufLen - 14);
+    ulTemp |= (pucBuf[i++] &lt;&lt; 16);
+    ulTemp |= (pucBuf[i++] &lt;&lt; 24);
+    HWREG(ulBase + MAC_O_DATA) = ulTemp;
+
+    //
+    // Write each subsequent WORD n to the transmit FIFO, except for the last
+    // WORD (if the word does not contain 4 bytes).
+    //
+    while(i &lt;= (lBufLen - 4))
+    {
+        HWREG(ulBase + MAC_O_DATA) = *(unsigned long *)&amp;pucBuf[i];
+        i += 4;
+    }
+
+    //
+    // Build the last word of the remaining 1, 2, or 3 bytes, and store
+    // the WORD into the transmit FIFO.
+    //
+    if(i != lBufLen)
+    {
+        if(i == (lBufLen - 3))
+        {
+            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
+            ulTemp |= (pucBuf[i++] &lt;&lt;  8);
+            ulTemp |= (pucBuf[i++] &lt;&lt; 16);
+            HWREG(ulBase + MAC_O_DATA) = ulTemp;
+        }
+        else if(i == (lBufLen - 2))
+        {
+            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
+            ulTemp |= (pucBuf[i++] &lt;&lt;  8);
+            HWREG(ulBase + MAC_O_DATA) = ulTemp;
+        }
+        else if(i == (lBufLen - 1))
+        {
+            ulTemp  = (pucBuf[i++] &lt;&lt;  0);
+            HWREG(ulBase + MAC_O_DATA) = ulTemp;
+        }
+    }
+
+    //
+    // Activate the transmitter
+    //
+    HWREG(ulBase + MAC_O_TR) = MAC_TR_NEWTX;
+
+    //
+    // Return the Buffer Length transmitted.
+    //
+    return(lBufLen);
+}
+
+//*****************************************************************************
+//
+//! Sends a packet to the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is number of bytes in the packet to be transmitted.
+//!
+//! This function writes \e lBufLen bytes of the packet contained in \e pucBuf
+//! into the transmit FIFO of the controller and then activates the
+//! transmitter for this packet.  If no space is available in the FIFO, the
+//! function will return immediately.  If space is available, the
+//! function will return once \e lBufLen bytes of the packet have been placed
+//! into the FIFO and the transmitter has been started.  The function will not
+//! wait for the transmission to complete.  The function will return the
+//! negated \e lBufLen if the length is larger than the space available in
+//! the transmit FIFO.
+//!
+//! This function replaces the original EthernetPacketNonBlockingPut() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;ethernet.h&lt;/tt&gt; to
+//! map the original API to this API.
+//!
+//! \note This function does not block and will return immediately if no space
+//! is available for the transmit packet.
+//!
+//! \return Returns \b 0 if no space is available in the transmit FIFO, the
+//! negated packet length \b -lBufLen if the packet is too large for FIFO, and
+//! the packet length \b lBufLen otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketPutNonBlocking(unsigned long ulBase, unsigned char *pucBuf,
+                             long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Check if the transmit FIFO is in use and return the appropriate code.
+    //
+    if(HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX)
+    {
+        return(0);
+    }
+
+    //
+    // Send the packet and return.
+    //
+    return(EthernetPacketPutInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! Waits to send a packet from the Ethernet controller.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pucBuf is the pointer to the packet buffer.
+//! \param lBufLen is number of bytes in the packet to be transmitted.
+//!
+//! This function writes \e lBufLen bytes of the packet contained in \e pucBuf
+//! into the transmit FIFO of the controller and then activates the transmitter
+//! for this packet.  This function will wait until the transmit FIFO is empty.
+//! Once space is available, the function will return once \e lBufLen bytes of
+//! the packet have been placed into the FIFO and the transmitter has been
+//! started.  The function will not wait for the transmission to complete.  The
+//! function will return the negated \e lBufLen if the length is larger than
+//! the space available in the transmit FIFO.
+//!
+//! \note This function blocks and will wait until space is available for the
+//! transmit packet before returning.
+//!
+//! \return Returns the negated packet length \b -lBufLen if the packet is too
+//! large for FIFO, and the packet length \b lBufLen otherwise.
+//
+//*****************************************************************************
+long
+EthernetPacketPut(unsigned long ulBase, unsigned char *pucBuf,
+                  long lBufLen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pucBuf != 0);
+    ASSERT(lBufLen &gt; 0);
+
+    //
+    // Wait for current packet (if any) to complete.
+    //
+    while(HWREG(ulBase + MAC_O_TR) &amp; MAC_TR_NEWTX)
+    {
+    }
+
+    //
+    // Send the packet and return.
+    //
+    return(EthernetPacketPutInternal(ulBase, pucBuf, lBufLen));
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for an Ethernet interrupt.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param pfnHandler is a pointer to the function to be called when the
+//! enabled Ethernet interrupts occur.
+//!
+//! This function sets the handler to be called when the Ethernet interrupt
+//! occurs.  This will enable the global interrupt in the interrupt controller;
+//! specific Ethernet interrupts must be enabled via EthernetIntEnable().  It
+//! is the interrupt handler's responsibility to clear the interrupt source.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(pfnHandler != 0);
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(INT_ETH, pfnHandler);
+
+    //
+    // Enable the Ethernet interrupt.
+    //
+    IntEnable(INT_ETH);
+}
+
+//*****************************************************************************
+//
+//! Unregisters an interrupt handler for an Ethernet interrupt.
+//!
+//! \param ulBase is the base address of the controller.
+//!
+//! This function unregisters the interrupt handler.  This will disable the
+//! global interrupt in the interrupt controller so that the interrupt handler
+//! no longer is called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntUnregister(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(INT_ETH);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(INT_ETH);
+}
+
+//*****************************************************************************
+//
+//! Enables individual Ethernet interrupt sources.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
+//!
+//! Enables the indicated Ethernet interrupt sources.  Only the sources that
+//! are enabled can be reflected to the processor interrupt; disabled sources
+//! have no effect on the processor.
+//!
+//! The \e ulIntFlags parameter is the logical OR of any of the following:
+//!
+//! - \b ETH_INT_PHY - An interrupt from the PHY has occurred.  The integrated
+//! PHY supports a number of interrupt conditions.  The PHY register, PHY_MR17,
+//! must be read to determine which PHY interrupt has occurred.  This register
+//! can be read using the EthernetPHYRead() API function.
+//! - \b ETH_INT_MDIO - This interrupt indicates that a transaction on the
+//! management interface has completed successfully.
+//! - \b ETH_INT_RXER - This interrupt indicates that an error has occurred
+//! during reception of a frame.  This error can indicate a length mismatch, a
+//! CRC failure, or an error indication from the PHY.
+//! - \b ETH_INT_RXOF - This interrupt indicates that a frame has been received
+//! that exceeds the available space in the RX FIFO.
+//! - \b ETH_INT_TX - This interrupt indicates that the packet stored in the TX
+//! FIFO has been successfully transmitted.
+//! - \b ETH_INT_TXER - This interrupt indicates that an error has occurred
+//! during the transmission of a packet.  This error can be either a retry
+//! failure during the back-off process, or an invalid length stored in the TX
+//! FIFO.
+//! - \b ETH_INT_RX - This interrupt indicates that one (or more) packets are
+//! available in the RX FIFO for processing.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
+                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
+                            ETH_INT_RX)));
+
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(ulBase + MAC_O_IM) |= ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Disables individual Ethernet interrupt sources.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
+//!
+//! Disables the indicated Ethernet interrupt sources.  Only the sources that
+//! are enabled can be reflected to the processor interrupt; disabled sources
+//! have no effect on the processor.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to EthernetIntEnable().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
+                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
+                            ETH_INT_RX)));
+
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(ulBase + MAC_O_IM) &amp;= ~ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Gets the current Ethernet interrupt status.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param bMasked is false if the raw interrupt status is required and true
+//! if the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the Ethernet controller.  Either the
+//! raw interrupt status or the status of interrupts that are allowed to
+//! reflect to the processor can be returned.
+//!
+//! \return Returns the current interrupt status, enumerated as a bit field of
+//! values described in EthernetIntEnable().
+//
+//*****************************************************************************
+unsigned long
+EthernetIntStatus(unsigned long ulBase, tBoolean bMasked)
+{
+    unsigned long ulStatus;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Read the unmasked status.
+    //
+    ulStatus = HWREG(ulBase + MAC_O_RIS);
+
+    //
+    // If masked status is requested, mask it off.
+    //
+    if(bMasked)
+    {
+        ulStatus &amp;= HWREG(ulBase + MAC_O_IM);
+    }
+
+    //
+    // Return the interrupt status value.
+    //
+    return(ulStatus);
+}
+
+//*****************************************************************************
+//
+//! Clears Ethernet interrupt sources.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
+//!
+//! The specified Ethernet interrupt sources are cleared so that they no longer
+//! assert.  This must be done in the interrupt handler to keep it from being
+//! called again immediately upon exit.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to EthernetIntEnable().
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetIntClear(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+    ASSERT(!(ulIntFlags &amp; ~(ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
+                            ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER |
+                            ETH_INT_RX)));
+
+    //
+    // Clear the requested interrupt sources.
+    //
+    HWREG(ulBase + MAC_O_IACK) = ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Writes to the PHY register.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ucRegAddr is the address of the PHY register to be accessed.
+//! \param ulData is the data to be written to the PHY register.
+//!
+//! This function will write the \e ulData to the PHY register specified by
+//! \e ucRegAddr.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EthernetPHYWrite(unsigned long ulBase, unsigned char ucRegAddr,
+                 unsigned long ulData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Wait for any pending transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+
+    //
+    // Program the DATA to be written.
+    //
+    HWREG(ulBase + MAC_O_MTXD) = ulData &amp; MAC_MTXD_MDTX_M;
+
+    //
+    // Program the PHY register address and initiate the transaction.
+    //
+    HWREG(ulBase + MAC_O_MCTL) = (((ucRegAddr &lt;&lt; 3) &amp; MAC_MCTL_REGADR_M) |
+                                  MAC_MCTL_WRITE | MAC_MCTL_START);
+
+    //
+    // Wait for the write transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+//! Reads from a PHY register.
+//!
+//! \param ulBase is the base address of the controller.
+//! \param ucRegAddr is the address of the PHY register to be accessed.
+//!
+//! This function will return the contents of the PHY register specified by
+//! \e ucRegAddr.
+//!
+//! \return Returns the 16-bit value read from the PHY.
+//
+//*****************************************************************************
+unsigned long
+EthernetPHYRead(unsigned long ulBase, unsigned char ucRegAddr)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ETH_BASE);
+
+    //
+    // Wait for any pending transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+
+    //
+    // Program the PHY register address and initiate the transaction.
+    //
+    HWREG(ulBase + MAC_O_MCTL) = (((ucRegAddr &lt;&lt; 3) &amp; MAC_MCTL_REGADR_M) |
+                                  MAC_MCTL_START);
+
+    //
+    // Wait for the transaction to complete.
+    //
+    while(HWREG(ulBase + MAC_O_MCTL) &amp; MAC_MCTL_START)
+    {
+    }
+
+    //
+    // Return the PHY data that was read.
+    //
+    return(HWREG(ulBase + MAC_O_MRXD) &amp; MAC_MRXD_MDRX_M);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/ethernet.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/ethernet.h
===================================================================
--- trunk/src/platform/lm3s/ethernet.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/ethernet.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,172 +1,172 @@
-//*****************************************************************************
-//
-// ethernet.h - Defines and Macros for the ethernet module.
-//
-// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __ETHERNET_H__
-#define __ETHERNET_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Values that can be passed to EthernetConfigSet as the ulConfig value, and
-// returned from EthernetConfigGet.
-//
-//*****************************************************************************
-#define ETH_CFG_TS_TSEN         0x010000    // Enable Timestamp (CCP)
-#define ETH_CFG_RX_BADCRCDIS    0x000800    // Disable RX BAD CRC Packets
-#define ETH_CFG_RX_PRMSEN       0x000400    // Enable RX Promiscuous
-#define ETH_CFG_RX_AMULEN       0x000200    // Enable RX Multicast
-#define ETH_CFG_TX_DPLXEN       0x000010    // Enable TX Duplex Mode
-#define ETH_CFG_TX_CRCEN        0x000004    // Enable TX CRC Generation
-#define ETH_CFG_TX_PADEN        0x000002    // Enable TX Padding
-
-//*****************************************************************************
-//
-// Values that can be passed to EthernetIntEnable, EthernetIntDisable, and
-// EthernetIntClear as the ulIntFlags parameter, and returned from
-// EthernetIntStatus.
-//
-//*****************************************************************************
-#define ETH_INT_PHY             0x040       // PHY Event/Interrupt
-#define ETH_INT_MDIO            0x020       // Management Transaction
-#define ETH_INT_RXER            0x010       // RX Error
-#define ETH_INT_RXOF            0x008       // RX FIFO Overrun
-#define ETH_INT_TX              0x004       // TX Complete
-#define ETH_INT_TXER            0x002       // TX Error
-#define ETH_INT_RX              0x001       // RX Complete
-
-//*****************************************************************************
-//
-// Helper Macros for Ethernet Processing
-//
-//*****************************************************************************
-//
-// htonl/ntohl - big endian/little endian byte swapping macros for
-// 32-bit (long) values
-//
-//*****************************************************************************
-#ifndef htonl
-    #define htonl(a)                    \
-        ((((a) &gt;&gt; 24) &amp; 0x000000ff) |   \
-         (((a) &gt;&gt;  8) &amp; 0x0000ff00) |   \
-         (((a) &lt;&lt;  8) &amp; 0x00ff0000) |   \
-         (((a) &lt;&lt; 24) &amp; 0xff000000))
-#endif
-
-#ifndef ntohl
-    #define ntohl(a)    htonl((a))
-#endif
-
-//*****************************************************************************
-//
-// htons/ntohs - big endian/little endian byte swapping macros for
-// 16-bit (short) values
-//
-//*****************************************************************************
-#ifndef htons
-    #define htons(a)                \
-        ((((a) &gt;&gt; 8) &amp; 0x00ff) |    \
-         (((a) &lt;&lt; 8) &amp; 0xff00))
-#endif
-
-#ifndef ntohs
-    #define ntohs(a)    htons((a))
-#endif
-
-//*****************************************************************************
-//
-// API Function prototypes
-//
-//*****************************************************************************
-extern void EthernetInitExpClk(unsigned long ulBase, unsigned long ulEthClk);
-extern void EthernetConfigSet(unsigned long ulBase, unsigned long ulConfig);
-extern unsigned long EthernetConfigGet(unsigned long ulBase);
-extern void EthernetMACAddrSet(unsigned long ulBase,
-                               unsigned char *pucMACAddr);
-extern void EthernetMACAddrGet(unsigned long ulBase,
-                               unsigned char *pucMACAddr);
-extern void EthernetEnable(unsigned long ulBase);
-extern void EthernetDisable(unsigned long ulBase);
-extern tBoolean EthernetPacketAvail(unsigned long ulBase);
-extern tBoolean EthernetSpaceAvail(unsigned long ulBase);
-extern long EthernetPacketGetNonBlocking(unsigned long ulBase,
-                                         unsigned char *pucBuf,
-                                         long lBufLen);
-extern long EthernetPacketGet(unsigned long ulBase, unsigned char *pucBuf,
-                              long lBufLen);
-extern long EthernetPacketPutNonBlocking(unsigned long ulBase,
-                                         unsigned char *pucBuf,
-                                         long lBufLen);
-extern long EthernetPacketPut(unsigned long ulBase, unsigned char *pucBuf,
-                              long lBufLen);
-extern void EthernetIntRegister(unsigned long ulBase,
-                                void (*pfnHandler)(void));
-extern void EthernetIntUnregister(unsigned long ulBase);
-extern void EthernetIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
-extern void EthernetIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
-extern unsigned long EthernetIntStatus(unsigned long ulBase, tBoolean bMasked);
-extern void EthernetIntClear(unsigned long ulBase, unsigned long ulIntFlags);
-extern void EthernetPHYWrite(unsigned long ulBase, unsigned char ucRegAddr,
-                             unsigned long ulData);
-extern unsigned long EthernetPHYRead(unsigned long ulBase,
-                                     unsigned char ucRegAddr);
-
-//*****************************************************************************
-//
-// Several Ethernet APIs have been renamed, with the original function name
-// being deprecated.  These defines provide backward compatibility.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-#include &quot;sysctl.h&quot;
-#define EthernetInit(a)                         \
-        EthernetInitExpClk(a, SysCtlClockGet())
-#define EthernetPacketNonBlockingGet(a, b, c) \
-        EthernetPacketGetNonBlocking(a, b, c)
-#define EthernetPacketNonBlockingPut(a, b, c) \
-        EthernetPacketPutNonBlocking(a, b, c)
-#endif
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif //  __ETHERNET_H__
+//*****************************************************************************
+//
+// ethernet.h - Defines and Macros for the ethernet module.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __ETHERNET_H__
+#define __ETHERNET_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to EthernetConfigSet as the ulConfig value, and
+// returned from EthernetConfigGet.
+//
+//*****************************************************************************
+#define ETH_CFG_TS_TSEN         0x010000    // Enable Timestamp (CCP)
+#define ETH_CFG_RX_BADCRCDIS    0x000800    // Disable RX BAD CRC Packets
+#define ETH_CFG_RX_PRMSEN       0x000400    // Enable RX Promiscuous
+#define ETH_CFG_RX_AMULEN       0x000200    // Enable RX Multicast
+#define ETH_CFG_TX_DPLXEN       0x000010    // Enable TX Duplex Mode
+#define ETH_CFG_TX_CRCEN        0x000004    // Enable TX CRC Generation
+#define ETH_CFG_TX_PADEN        0x000002    // Enable TX Padding
+
+//*****************************************************************************
+//
+// Values that can be passed to EthernetIntEnable, EthernetIntDisable, and
+// EthernetIntClear as the ulIntFlags parameter, and returned from
+// EthernetIntStatus.
+//
+//*****************************************************************************
+#define ETH_INT_PHY             0x040       // PHY Event/Interrupt
+#define ETH_INT_MDIO            0x020       // Management Transaction
+#define ETH_INT_RXER            0x010       // RX Error
+#define ETH_INT_RXOF            0x008       // RX FIFO Overrun
+#define ETH_INT_TX              0x004       // TX Complete
+#define ETH_INT_TXER            0x002       // TX Error
+#define ETH_INT_RX              0x001       // RX Complete
+
+//*****************************************************************************
+//
+// Helper Macros for Ethernet Processing
+//
+//*****************************************************************************
+//
+// htonl/ntohl - big endian/little endian byte swapping macros for
+// 32-bit (long) values
+//
+//*****************************************************************************
+#ifndef htonl
+    #define htonl(a)                    \
+        ((((a) &gt;&gt; 24) &amp; 0x000000ff) |   \
+         (((a) &gt;&gt;  8) &amp; 0x0000ff00) |   \
+         (((a) &lt;&lt;  8) &amp; 0x00ff0000) |   \
+         (((a) &lt;&lt; 24) &amp; 0xff000000))
+#endif
+
+#ifndef ntohl
+    #define ntohl(a)    htonl((a))
+#endif
+
+//*****************************************************************************
+//
+// htons/ntohs - big endian/little endian byte swapping macros for
+// 16-bit (short) values
+//
+//*****************************************************************************
+#ifndef htons
+    #define htons(a)                \
+        ((((a) &gt;&gt; 8) &amp; 0x00ff) |    \
+         (((a) &lt;&lt; 8) &amp; 0xff00))
+#endif
+
+#ifndef ntohs
+    #define ntohs(a)    htons((a))
+#endif
+
+//*****************************************************************************
+//
+// API Function prototypes
+//
+//*****************************************************************************
+extern void EthernetInitExpClk(unsigned long ulBase, unsigned long ulEthClk);
+extern void EthernetConfigSet(unsigned long ulBase, unsigned long ulConfig);
+extern unsigned long EthernetConfigGet(unsigned long ulBase);
+extern void EthernetMACAddrSet(unsigned long ulBase,
+                               unsigned char *pucMACAddr);
+extern void EthernetMACAddrGet(unsigned long ulBase,
+                               unsigned char *pucMACAddr);
+extern void EthernetEnable(unsigned long ulBase);
+extern void EthernetDisable(unsigned long ulBase);
+extern tBoolean EthernetPacketAvail(unsigned long ulBase);
+extern tBoolean EthernetSpaceAvail(unsigned long ulBase);
+extern long EthernetPacketGetNonBlocking(unsigned long ulBase,
+                                         unsigned char *pucBuf,
+                                         long lBufLen);
+extern long EthernetPacketGet(unsigned long ulBase, unsigned char *pucBuf,
+                              long lBufLen);
+extern long EthernetPacketPutNonBlocking(unsigned long ulBase,
+                                         unsigned char *pucBuf,
+                                         long lBufLen);
+extern long EthernetPacketPut(unsigned long ulBase, unsigned char *pucBuf,
+                              long lBufLen);
+extern void EthernetIntRegister(unsigned long ulBase,
+                                void (*pfnHandler)(void));
+extern void EthernetIntUnregister(unsigned long ulBase);
+extern void EthernetIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void EthernetIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
+extern unsigned long EthernetIntStatus(unsigned long ulBase, tBoolean bMasked);
+extern void EthernetIntClear(unsigned long ulBase, unsigned long ulIntFlags);
+extern void EthernetPHYWrite(unsigned long ulBase, unsigned char ucRegAddr,
+                             unsigned long ulData);
+extern unsigned long EthernetPHYRead(unsigned long ulBase,
+                                     unsigned char ucRegAddr);
+
+//*****************************************************************************
+//
+// Several Ethernet APIs have been renamed, with the original function name
+// being deprecated.  These defines provide backward compatibility.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#include &quot;sysctl.h&quot;
+#define EthernetInit(a)                         \
+        EthernetInitExpClk(a, SysCtlClockGet())
+#define EthernetPacketNonBlockingGet(a, b, c) \
+        EthernetPacketGetNonBlocking(a, b, c)
+#define EthernetPacketNonBlockingPut(a, b, c) \
+        EthernetPacketPutNonBlocking(a, b, c)
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif //  __ETHERNET_H__


Property changes on: trunk/src/platform/lm3s/ethernet.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/flash.c
===================================================================
--- trunk/src/platform/lm3s/flash.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/flash.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,871 +1,915 @@
-//*****************************************************************************
-//
-// flash.c - Driver for programming the on-chip flash.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup flash_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_flash.h&quot;
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_sysctl.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;flash.h&quot;
-#include &quot;interrupt.h&quot;
-
-//*****************************************************************************
-//
-// An array that maps the specified memory bank to the appropriate Flash
-// Memory Protection Program Enable (FMPPE) register.
-//
-//*****************************************************************************
-static const unsigned long g_pulFMPPERegs[] =
-{
-    FLASH_FMPPE,
-    FLASH_FMPPE1,
-    FLASH_FMPPE2,
-    FLASH_FMPPE3
-};
-
-//*****************************************************************************
-//
-// An array that maps the specified memory bank to the appropriate Flash
-// Memory Protection Read Enable (FMPRE) register.
-//
-//*****************************************************************************
-static const unsigned long g_pulFMPRERegs[] =
-{
-    FLASH_FMPRE,
-    FLASH_FMPRE1,
-    FLASH_FMPRE2,
-    FLASH_FMPRE3
-};
-
-//*****************************************************************************
-//
-//! Gets the number of processor clocks per micro-second.
-//!
-//! This function returns the number of clocks per micro-second, as presently
-//! known by the flash controller.
-//!
-//! \return Returns the number of processor clocks per micro-second.
-//
-//*****************************************************************************
-unsigned long
-FlashUsecGet(void)
-{
-    //
-    // Return the number of clocks per micro-second.
-    //
-    return(HWREG(FLASH_USECRL) + 1);
-}
-
-//*****************************************************************************
-//
-//! Sets the number of processor clocks per micro-second.
-//!
-//! \param ulClocks is the number of processor clocks per micro-second.
-//!
-//! This function is used to tell the flash controller the number of processor
-//! clocks per micro-second.  This value must be programmed correctly or the
-//! flash most likely will not program correctly; it has no affect on reading
-//! flash.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-FlashUsecSet(unsigned long ulClocks)
-{
-    //
-    // Set the number of clocks per micro-second.
-    //
-    HWREG(FLASH_USECRL) = ulClocks - 1;
-}
-
-//*****************************************************************************
-//
-//! Erases a block of flash.
-//!
-//! \param ulAddress is the start address of the flash block to be erased.
-//!
-//! This function will erase a 1 kB block of the on-chip flash.  After erasing,
-//! the block will be filled with 0xFF bytes.  Read-only and execute-only
-//! blocks cannot be erased.
-//!
-//! This function will not return until the block has been erased.
-//!
-//! \return Returns 0 on success, or -1 if an invalid block address was
-//! specified or the block is write-protected.
-//
-//*****************************************************************************
-long
-FlashErase(unsigned long ulAddress)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(!(ulAddress &amp; (FLASH_ERASE_SIZE - 1)));
-
-    //
-    // Clear the flash access interrupt.
-    //
-    HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC;
-
-    //
-    // Erase the block.
-    //
-    HWREG(FLASH_FMA) = ulAddress;
-    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_ERASE;
-
-    //
-    // Wait until the block has been erased.
-    //
-    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_ERASE)
-    {
-    }
-
-    //
-    // Return an error if an access violation occurred.
-    //
-    if(HWREG(FLASH_FCRIS) &amp; FLASH_FCRIS_ARIS)
-    {
-        return(-1);
-    }
-
-    //
-    // Success.
-    //
-    return(0);
-}
-
-//*****************************************************************************
-//
-//! Programs flash.
-//!
-//! \param pulData is a pointer to the data to be programmed.
-//! \param ulAddress is the starting address in flash to be programmed.  Must
-//! be a multiple of four.
-//! \param ulCount is the number of bytes to be programmed.  Must be a multiple
-//! of four.
-//!
-//! This function will program a sequence of words into the on-chip flash.
-//! Programming each location consists of the result of an AND operation
-//! of the new data and the existing data; in other words bits that contain
-//! 1 can remain 1 or be changed to 0, but bits that are 0 cannot be changed
-//! to 1.  Therefore, a word can be programmed multiple times as long as these
-//! rules are followed; if a program operation attempts to change a 0 bit to
-//! a 1 bit, that bit will not have its value changed.
-//!
-//! Since the flash is programmed one word at a time, the starting address and
-//! byte count must both be multiples of four.  It is up to the caller to
-//! verify the programmed contents, if such verification is required.
-//!
-//! This function will not return until the data has been programmed.
-//!
-//! \return Returns 0 on success, or -1 if a programming error is encountered.
-//
-//*****************************************************************************
-long
-FlashProgram(unsigned long *pulData, unsigned long ulAddress,
-             unsigned long ulCount)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(!(ulAddress &amp; 3));
-    ASSERT(!(ulCount &amp; 3));
-
-    //
-    // Clear the flash access interrupt.
-    //
-    HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC;
-
-    //
-    // Loop over the words to be programmed.
-    //
-    while(ulCount)
-    {
-        //
-        // Program the next word.
-        //
-        HWREG(FLASH_FMA) = ulAddress;
-        HWREG(FLASH_FMD) = *pulData;
-        HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_WRITE;
-
-        //
-        // Wait until the word has been programmed.
-        //
-        while(HWREG(FLASH_FMC) &amp; FLASH_FMC_WRITE)
-        {
-        }
-
-        //
-        // Increment to the next word.
-        //
-        pulData++;
-        ulAddress += 4;
-        ulCount -= 4;
-    }
-
-    //
-    // Return an error if an access violation occurred.
-    //
-    if(HWREG(FLASH_FCRIS) &amp; FLASH_FCRIS_ARIS)
-    {
-        return(-1);
-    }
-
-    //
-    // Success.
-    //
-    return(0);
-}
-
-//*****************************************************************************
-//
-//! Gets the protection setting for a block of flash.
-//!
-//! \param ulAddress is the start address of the flash block to be queried.
-//!
-//! This function will get the current protection for the specified 2 kB block
-//! of flash.  Each block can be read/write, read-only, or execute-only.
-//! Read/write blocks can be read, executed, erased, and programmed.  Read-only
-//! blocks can be read and executed.  Execute-only blocks can only be executed;
-//! processor and debugger data reads are not allowed.
-//!
-//! \return Returns the protection setting for this block.  See
-//! FlashProtectSet() for possible values.
-//
-//*****************************************************************************
-tFlashProtection
-FlashProtectGet(unsigned long ulAddress)
-{
-    unsigned long ulFMPRE, ulFMPPE;
-    unsigned long ulBank;
-
-    //
-    // Check the argument.
-    //
-    ASSERT(!(ulAddress &amp; (FLASH_PROTECT_SIZE - 1)));
-
-    //
-    // Calculate the Flash Bank from Base Address, and mask off the Bank
-    // from ulAddress for subsequent reference.
-    //
-    ulBank = (((ulAddress / FLASH_PROTECT_SIZE) / 32) % 4);
-    ulAddress &amp;= ((FLASH_PROTECT_SIZE * 32) - 1);
-
-    //
-    // Read the appropriate flash protection registers for the specified
-    // flash bank.
-    //
-    ulFMPRE = HWREG(g_pulFMPRERegs[ulBank]);
-    ulFMPPE = HWREG(g_pulFMPPERegs[ulBank]);
-
-    //
-    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
-    // bits of the FMPPE register are used for JTAG protect options, and are
-    // not available for the FLASH protection scheme.  When Querying Block
-    // Protection, assume these bits are 1.
-    //
-    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
-    {
-        ulFMPRE |= (FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30);
-    }
-
-    //
-    // Check the appropriate protection bits for the block of memory that
-    // is specified by the address.
-    //
-    switch((((ulFMPRE &gt;&gt; (ulAddress / FLASH_PROTECT_SIZE)) &amp;
-             FLASH_FMP_BLOCK_0) &lt;&lt; 1) |
-           ((ulFMPPE &gt;&gt; (ulAddress / FLASH_PROTECT_SIZE)) &amp; FLASH_FMP_BLOCK_0))
-    {
-        //
-        // This block is marked as execute only (that is, it can not be erased
-        // or programmed, and the only reads allowed are via the instruction
-        // fecth interface).
-        //
-        case 0:
-        case 1:
-        {
-            return(FlashExecuteOnly);
-        }
-
-        //
-        // This block is marked as read only (that is, it can not be erased or
-        // programmed).
-        //
-        case 2:
-        {
-            return(FlashReadOnly);
-        }
-
-        //
-        // This block is read/write; it can be read, erased, and programmed.
-        //
-        case 3:
-        default:
-        {
-            return(FlashReadWrite);
-        }
-    }
-}
-
-//*****************************************************************************
-//
-//! Sets the protection setting for a block of flash.
-//!
-//! \param ulAddress is the start address of the flash block to be protected.
-//! \param eProtect is the protection to be applied to the block.  Can be one
-//! of \b FlashReadWrite, \b FlashReadOnly, or \b FlashExecuteOnly.
-//!
-//! This function will set the protection for the specified 2 kB block of
-//! flash.  Blocks which are read/write can be made read-only or execute-only.
-//! Blocks which are read-only can be made execute-only.  Blocks which are
-//! execute-only cannot have their protection modified.  Attempts to make the
-//! block protection less stringent (that is, read-only to read/write) will
-//! result in a failure (and be prevented by the hardware).
-//!
-//! Changes to the flash protection are maintained only until the next reset.
-//! This allows the application to be executed in the desired flash protection
-//! environment to check for inappropriate flash access (via the flash
-//! interrupt).  To make the flash protection permanent, use the
-//! FlashProtectSave() function.
-//!
-//! \return Returns 0 on success, or -1 if an invalid address or an invalid
-//! protection was specified.
-//
-//*****************************************************************************
-long
-FlashProtectSet(unsigned long ulAddress, tFlashProtection eProtect)
-{
-    unsigned long ulProtectRE, ulProtectPE;
-    unsigned long ulBank;
-
-    //
-    // Check the argument.
-    //
-    ASSERT(!(ulAddress &amp; (FLASH_PROTECT_SIZE - 1)));
-    ASSERT((eProtect == FlashReadWrite) || (eProtect == FlashReadOnly) ||
-           (eProtect == FlashExecuteOnly));
-
-    //
-    // Convert the address into a block number.
-    //
-    ulAddress /= FLASH_PROTECT_SIZE;
-
-    //
-    // ulAddress contains a &quot;raw&quot; block number.  Derive the Flash Bank from
-    // the &quot;raw&quot; block number, and convert ulAddress to a &quot;relative&quot;
-    // block number.
-    //
-    ulBank = ((ulAddress / 32) % 4);
-    ulAddress %= 32;
-
-    //
-    // Get the current protection for the specified flash bank.
-    //
-    ulProtectRE = HWREG(g_pulFMPRERegs[ulBank]);
-    ulProtectPE = HWREG(g_pulFMPPERegs[ulBank]);
-
-    //
-    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
-    // bits of the FMPPE register are used for JTAG protect options, and are
-    // not available for the FLASH protection scheme.  When setting protection,
-    // check to see if block 30 or 31 and protection is FlashExecuteOnly.  If
-    // so, return an error condition.
-    //
-    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
-    {
-        if((ulAddress &gt;= 30) &amp;&amp; (eProtect == FlashExecuteOnly))
-        {
-            return(-1);
-        }
-    }
-
-    //
-    // Set the protection based on the requested proection.
-    //
-    switch(eProtect)
-    {
-        //
-        // Make this block execute only.
-        //
-        case FlashExecuteOnly:
-        {
-            //
-            // Turn off the read and program bits for this block.
-            //
-            ulProtectRE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
-            ulProtectPE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
-
-            //
-            // We're done handling this protection.
-            //
-            break;
-        }
-
-        //
-        // Make this block read only.
-        //
-        case FlashReadOnly:
-        {
-            //
-            // The block can not be made read only if it is execute only.
-            //
-            if(((ulProtectRE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
-               FLASH_FMP_BLOCK_0)
-            {
-                return(-1);
-            }
-
-            //
-            // Make this block read only.
-            //
-            ulProtectPE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
-
-            //
-            // We're done handling this protection.
-            //
-            break;
-        }
-
-        //
-        // Make this block read/write.
-        //
-        case FlashReadWrite:
-        default:
-        {
-            //
-            // The block can not be made read/write if it is not already
-            // read/write.
-            //
-            if((((ulProtectRE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
-                FLASH_FMP_BLOCK_0) ||
-               (((ulProtectPE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
-                FLASH_FMP_BLOCK_0))
-            {
-                return(-1);
-            }
-
-            //
-            // The block is already read/write, so there is nothing to do.
-            //
-            return(0);
-        }
-    }
-
-    //
-    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
-    // bits of the FMPPE register are used for JTAG options, and are not
-    // available for the FLASH protection scheme.  When setting block
-    // protection, ensure that these bits are not altered.
-    //
-    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
-    {
-        ulProtectRE &amp;= ~(FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30);
-        ulProtectRE |= (HWREG(g_pulFMPRERegs[ulBank]) &amp;
-                (FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30));
-    }
-
-    //
-    // Set the new protection for the specified flash bank.
-    //
-    HWREG(g_pulFMPRERegs[ulBank]) = ulProtectRE;
-    HWREG(g_pulFMPPERegs[ulBank]) = ulProtectPE;
-
-    //
-    // Success.
-    //
-    return(0);
-}
-
-//*****************************************************************************
-//
-//! Saves the flash protection settings.
-//!
-//! This function will make the currently programmed flash protection settings
-//! permanent.  This is a non-reversible operation; a chip reset or power cycle
-//! will not change the flash protection.
-//!
-//! This function will not return until the protection has been saved.
-//!
-//! \return Returns 0 on success, or -1 if a hardware error is encountered.
-//
-//*****************************************************************************
-long
-FlashProtectSave(void)
-{
-    int ulTemp, ulLimit;
-
-    //
-    // If running on a Sandstorm-class device, only trigger a save of the first
-    // two protection registers (FMPRE and FMPPE).  Otherwise, save the
-    // entire bank of flash protection registers.
-    //
-    ulLimit = CLASS_IS_SANDSTORM ? 2 : 8;
-    for(ulTemp = 0; ulTemp &lt; ulLimit; ulTemp++)
-    {
-        //
-        // Tell the flash controller to write the flash protection register.
-        //
-        HWREG(FLASH_FMA) = ulTemp;
-        HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
-
-        //
-        // Wait until the write has completed.
-        //
-        while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
-        {
-        }
-    }
-
-    //
-    // Success.
-    //
-    return(0);
-}
-
-//*****************************************************************************
-//
-//! Gets the user registers.
-//!
-//! \param pulUser0 is a pointer to the location to store USER Register 0.
-//! \param pulUser1 is a pointer to the location to store USER Register 1.
-//!
-//! This function will read the contents of user registers (0 and 1), and
-//! store them in the specified locations.
-//!
-//! \return Returns 0 on success, or -1 if a hardware error is encountered.
-//
-//*****************************************************************************
-long
-FlashUserGet(unsigned long *pulUser0, unsigned long *pulUser1)
-{
-    //
-    // Verify that the pointers are valid.
-    //
-    ASSERT(pulUser0 != 0);
-    ASSERT(pulUser1 != 0);
-
-    //
-    // Verify that hardware supports user registers.
-    //
-    if(CLASS_IS_SANDSTORM)
-    {
-        return(-1);
-    }
-
-    //
-    // Get and store the current value of the user registers.
-    //
-    *pulUser0 = HWREG(FLASH_USERREG0);
-    *pulUser1 = HWREG(FLASH_USERREG1);
-
-    //
-    // Success.
-    //
-    return(0);
-}
-
-//*****************************************************************************
-//
-//! Sets the user registers.
-//!
-//! \param ulUser0 is the value to store in USER Register 0.
-//! \param ulUser1 is the value to store in USER Register 1.
-//!
-//! This function will set the contents of the user registers (0 and 1) to
-//! the specified values.
-//!
-//! \return Returns 0 on success, or -1 if a hardware error is encountered.
-//
-//*****************************************************************************
-long
-FlashUserSet(unsigned long ulUser0, unsigned long ulUser1)
-{
-    //
-    // Verify that hardware supports user registers.
-    //
-    if(CLASS_IS_SANDSTORM)
-    {
-        return(-1);
-    }
-
-    //
-    // Save the new values into the user registers.
-    //
-    HWREG(FLASH_USERREG0) = ulUser0;
-    HWREG(FLASH_USERREG1) = ulUser1;
-
-    //
-    // Success.
-    //
-    return(0);
-}
-
-//*****************************************************************************
-//
-//! Saves the user registers.
-//!
-//! This function will make the currently programmed user register settings
-//! permanent.  This is a non-reversible operation; a chip reset or power cycle
-//! will not change this setting.
-//!
-//! This function will not return until the protection has been saved.
-//!
-//! \return Returns 0 on success, or -1 if a hardware error is encountered.
-//
-//*****************************************************************************
-long
-FlashUserSave(void)
-{
-    //
-    // Verify that hardware supports user registers.
-    //
-    if(CLASS_IS_SANDSTORM)
-    {
-        return(-1);
-    }
-
-    //
-    // Setting the MSB of FMA will trigger a permanent save of a USER
-    // register.  Bit 0 will indicate User 0 (0) or User 1 (1).
-    //
-    HWREG(FLASH_FMA) = 0x80000000;
-    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
-
-    //
-    // Wait until the write has completed.
-    //
-    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
-    {
-    }
-
-    //
-    // Tell the flash controller to write the USER1 Register.
-    //
-    HWREG(FLASH_FMA) = 0x80000001;
-    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
-
-    //
-    // Wait until the write has completed.
-    //
-    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
-    {
-    }
-
-    //
-    // Success.
-    //
-    return(0);
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for the flash interrupt.
-//!
-//! \param pfnHandler is a pointer to the function to be called when the flash
-//! interrupt occurs.
-//!
-//! This sets the handler to be called when the flash interrupt occurs.  The
-//! flash controller can generate an interrupt when an invalid flash access
-//! occurs, such as trying to program or erase a read-only block, or trying to
-//! read from an execute-only block.  It can also generate an interrupt when a
-//! program or erase operation has completed.  The interrupt will be
-//! automatically enabled when the handler is registered.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-FlashIntRegister(void (*pfnHandler)(void))
-{
-    //
-    // Register the interrupt handler, returning an error if an error occurs.
-    //
-    IntRegister(INT_FLASH, pfnHandler);
-
-    //
-    // Enable the flash interrupt.
-    //
-    IntEnable(INT_FLASH);
-}
-
-//*****************************************************************************
-//
-//! Unregisters the interrupt handler for the flash interrupt.
-//!
-//! This function will clear the handler to be called when the flash interrupt
-//! occurs.  This will also mask off the interrupt in the interrupt controller
-//! so that the interrupt handler is no longer called.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-FlashIntUnregister(void)
-{
-    //
-    // Disable the interrupt.
-    //
-    IntDisable(INT_FLASH);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(INT_FLASH);
-}
-
-//*****************************************************************************
-//
-//! Enables individual flash controller interrupt sources.
-//!
-//! \param ulIntFlags is a bit mask of the interrupt sources to be enabled.
-//! Can be any of the \b FLASH_FCIM_PROGRAM or \b FLASH_FCIM_ACCESS values.
-//!
-//! Enables the indicated flash controller interrupt sources.  Only the sources
-//! that are enabled can be reflected to the processor interrupt; disabled
-//! sources have no effect on the processor.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-FlashIntEnable(unsigned long ulIntFlags)
-{
-    //
-    // Enable the specified interrupts.
-    //
-    HWREG(FLASH_FCIM) |= ulIntFlags;
-}
-
-//*****************************************************************************
-//
-//! Disables individual flash controller interrupt sources.
-//!
-//! \param ulIntFlags is a bit mask of the interrupt sources to be disabled.
-//! Can be any of the \b FLASH_FCIM_PROGRAM or \b FLASH_FCIM_ACCESS values.
-//!
-//! Disables the indicated flash controller interrupt sources.  Only the
-//! sources that are enabled can be reflected to the processor interrupt;
-//! disabled sources have no effect on the processor.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-FlashIntDisable(unsigned long ulIntFlags)
-{
-    //
-    // Disable the specified interrupts.
-    //
-    HWREG(FLASH_FCIM) &amp;= ~(ulIntFlags);
-}
-
-//*****************************************************************************
-//
-//! Gets the current interrupt status.
-//!
-//! \param bMasked is false if the raw interrupt status is required and true if
-//! the masked interrupt status is required.
-//!
-//! This returns the interrupt status for the flash controller.  Either the raw
-//! interrupt status or the status of interrupts that are allowed to reflect to
-//! the processor can be returned.
-//!
-//! \return The current interrupt status, enumerated as a bit field of
-//! \b FLASH_FCMISC_PROGRAM and \b FLASH_FCMISC_AMISC.
-//
-//*****************************************************************************
-unsigned long
-FlashIntGetStatus(tBoolean bMasked)
-{
-    //
-    // Return either the interrupt status or the raw interrupt status as
-    // requested.
-    //
-    if(bMasked)
-    {
-        return(HWREG(FLASH_FCMISC));
-    }
-    else
-    {
-        return(HWREG(FLASH_FCRIS));
-    }
-}
-
-//*****************************************************************************
-//
-//! Clears flash controller interrupt sources.
-//!
-//! \param ulIntFlags is the bit mask of the interrupt sources to be cleared.
-//! Can be any of the \b FLASH_FCMISC_PROGRAM or \b FLASH_FCMISC_AMISC values.
-//!
-//! The specified flash controller interrupt sources are cleared, so that they
-//! no longer assert.  This must be done in the interrupt handler to keep it
-//! from being called again immediately upon exit.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-FlashIntClear(unsigned long ulIntFlags)
-{
-    //
-    // Clear the flash interrupt.
-    //
-    HWREG(FLASH_FCMISC) = ulIntFlags;
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// flash.c - Driver for programming the on-chip flash.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup flash_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_flash.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_sysctl.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;flash.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// An array that maps the specified memory bank to the appropriate Flash
+// Memory Protection Program Enable (FMPPE) register.
+//
+//*****************************************************************************
+static const unsigned long g_pulFMPPERegs[] =
+{
+    FLASH_FMPPE,
+    FLASH_FMPPE1,
+    FLASH_FMPPE2,
+    FLASH_FMPPE3
+};
+
+//*****************************************************************************
+//
+// An array that maps the specified memory bank to the appropriate Flash
+// Memory Protection Read Enable (FMPRE) register.
+//
+//*****************************************************************************
+static const unsigned long g_pulFMPRERegs[] =
+{
+    FLASH_FMPRE,
+    FLASH_FMPRE1,
+    FLASH_FMPRE2,
+    FLASH_FMPRE3
+};
+
+//*****************************************************************************
+//
+//! Gets the number of processor clocks per micro-second.
+//!
+//! This function returns the number of clocks per micro-second, as presently
+//! known by the flash controller.
+//!
+//! \return Returns the number of processor clocks per micro-second.
+//
+//*****************************************************************************
+unsigned long
+FlashUsecGet(void)
+{
+    //
+    // Return the number of clocks per micro-second.
+    //
+    return(HWREG(FLASH_USECRL) + 1);
+}
+
+//*****************************************************************************
+//
+//! Sets the number of processor clocks per micro-second.
+//!
+//! \param ulClocks is the number of processor clocks per micro-second.
+//!
+//! This function is used to tell the flash controller the number of processor
+//! clocks per micro-second.  This value must be programmed correctly or the
+//! flash most likely will not program correctly; it has no affect on reading
+//! flash.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashUsecSet(unsigned long ulClocks)
+{
+    //
+    // Set the number of clocks per micro-second.
+    //
+    HWREG(FLASH_USECRL) = ulClocks - 1;
+}
+
+//*****************************************************************************
+//
+//! Erases a block of flash.
+//!
+//! \param ulAddress is the start address of the flash block to be erased.
+//!
+//! This function will erase a 1 kB block of the on-chip flash.  After erasing,
+//! the block will be filled with 0xFF bytes.  Read-only and execute-only
+//! blocks cannot be erased.
+//!
+//! This function will not return until the block has been erased.
+//!
+//! \return Returns 0 on success, or -1 if an invalid block address was
+//! specified or the block is write-protected.
+//
+//*****************************************************************************
+long
+FlashErase(unsigned long ulAddress)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!(ulAddress &amp; (FLASH_ERASE_SIZE - 1)));
+
+    //
+    // Clear the flash access interrupt.
+    //
+    HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC;
+
+    //
+    // Erase the block.
+    //
+    HWREG(FLASH_FMA) = ulAddress;
+    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_ERASE;
+
+    //
+    // Wait until the block has been erased.
+    //
+    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_ERASE)
+    {
+    }
+
+    //
+    // Return an error if an access violation occurred.
+    //
+    if(HWREG(FLASH_FCRIS) &amp; FLASH_FCRIS_ARIS)
+    {
+        return(-1);
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Programs flash.
+//!
+//! \param pulData is a pointer to the data to be programmed.
+//! \param ulAddress is the starting address in flash to be programmed.  Must
+//! be a multiple of four.
+//! \param ulCount is the number of bytes to be programmed.  Must be a multiple
+//! of four.
+//!
+//! This function will program a sequence of words into the on-chip flash.
+//! Programming each location consists of the result of an AND operation
+//! of the new data and the existing data; in other words bits that contain
+//! 1 can remain 1 or be changed to 0, but bits that are 0 cannot be changed
+//! to 1.  Therefore, a word can be programmed multiple times as long as these
+//! rules are followed; if a program operation attempts to change a 0 bit to
+//! a 1 bit, that bit will not have its value changed.
+//!
+//! Since the flash is programmed one word at a time, the starting address and
+//! byte count must both be multiples of four.  It is up to the caller to
+//! verify the programmed contents, if such verification is required.
+//!
+//! This function will not return until the data has been programmed.
+//!
+//! \return Returns 0 on success, or -1 if a programming error is encountered.
+//
+//*****************************************************************************
+long
+FlashProgram(unsigned long *pulData, unsigned long ulAddress,
+             unsigned long ulCount)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!(ulAddress &amp; 3));
+    ASSERT(!(ulCount &amp; 3));
+
+    //
+    // Clear the flash access interrupt.
+    //
+    HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC;
+
+    //
+    // See if this device has a write buffer.
+    //
+    if(HWREG(SYSCTL_NVMSTAT) &amp; SYSCTL_NVMSTAT_FWB)
+    {
+        //
+        // Loop over the words to be programmed.
+        //
+        while(ulCount)
+        {
+            //
+            // Set the address of this block of words.
+            //
+            HWREG(FLASH_FMA) = ulAddress &amp; ~(0x7f);
+
+            //
+            // Loop over the words in this 32-word block.
+            //
+            while(((ulAddress &amp; 0x7c) || (HWREG(FLASH_FWBVAL) == 0)) &amp;&amp;
+                  (ulCount != 0))
+            {
+                //
+                // Write this word into the write buffer.
+                //
+                HWREG(FLASH_FWBN + (ulAddress &amp; 0x7c)) = *pulData++;
+                ulAddress += 4;
+                ulCount -= 4;
+            }
+
+            //
+            // Program the contents of the write buffer into flash.
+            //
+            HWREG(FLASH_FMC2) = FLASH_FMC2_WRKEY | FLASH_FMC2_WRBUF;
+
+            //
+            // Wait until the write buffer has been programmed.
+            //
+            while(HWREG(FLASH_FMC2) &amp; FLASH_FMC2_WRBUF)
+            {
+            }
+        }
+    }
+    else
+    {
+        //
+        // Loop over the words to be programmed.
+        //
+        while(ulCount)
+        {
+            //
+            // Program the next word.
+            //
+            HWREG(FLASH_FMA) = ulAddress;
+            HWREG(FLASH_FMD) = *pulData;
+            HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_WRITE;
+
+            //
+            // Wait until the word has been programmed.
+            //
+            while(HWREG(FLASH_FMC) &amp; FLASH_FMC_WRITE)
+            {
+            }
+
+            //
+            // Increment to the next word.
+            //
+            pulData++;
+            ulAddress += 4;
+            ulCount -= 4;
+        }
+    }
+
+    //
+    // Return an error if an access violation occurred.
+    //
+    if(HWREG(FLASH_FCRIS) &amp; FLASH_FCRIS_ARIS)
+    {
+        return(-1);
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Gets the protection setting for a block of flash.
+//!
+//! \param ulAddress is the start address of the flash block to be queried.
+//!
+//! This function will get the current protection for the specified 2 kB block
+//! of flash.  Each block can be read/write, read-only, or execute-only.
+//! Read/write blocks can be read, executed, erased, and programmed.  Read-only
+//! blocks can be read and executed.  Execute-only blocks can only be executed;
+//! processor and debugger data reads are not allowed.
+//!
+//! \return Returns the protection setting for this block.  See
+//! FlashProtectSet() for possible values.
+//
+//*****************************************************************************
+tFlashProtection
+FlashProtectGet(unsigned long ulAddress)
+{
+    unsigned long ulFMPRE, ulFMPPE;
+    unsigned long ulBank;
+
+    //
+    // Check the argument.
+    //
+    ASSERT(!(ulAddress &amp; (FLASH_PROTECT_SIZE - 1)));
+
+    //
+    // Calculate the Flash Bank from Base Address, and mask off the Bank
+    // from ulAddress for subsequent reference.
+    //
+    ulBank = (((ulAddress / FLASH_PROTECT_SIZE) / 32) % 4);
+    ulAddress &amp;= ((FLASH_PROTECT_SIZE * 32) - 1);
+
+    //
+    // Read the appropriate flash protection registers for the specified
+    // flash bank.
+    //
+    ulFMPRE = HWREG(g_pulFMPRERegs[ulBank]);
+    ulFMPPE = HWREG(g_pulFMPPERegs[ulBank]);
+
+    //
+    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
+    // bits of the FMPPE register are used for JTAG protect options, and are
+    // not available for the FLASH protection scheme.  When Querying Block
+    // Protection, assume these bits are 1.
+    //
+    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
+    {
+        ulFMPRE |= (FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30);
+    }
+
+    //
+    // Check the appropriate protection bits for the block of memory that
+    // is specified by the address.
+    //
+    switch((((ulFMPRE &gt;&gt; (ulAddress / FLASH_PROTECT_SIZE)) &amp;
+             FLASH_FMP_BLOCK_0) &lt;&lt; 1) |
+           ((ulFMPPE &gt;&gt; (ulAddress / FLASH_PROTECT_SIZE)) &amp; FLASH_FMP_BLOCK_0))
+    {
+        //
+        // This block is marked as execute only (that is, it can not be erased
+        // or programmed, and the only reads allowed are via the instruction
+        // fetch interface).
+        //
+        case 0:
+        case 1:
+        {
+            return(FlashExecuteOnly);
+        }
+
+        //
+        // This block is marked as read only (that is, it can not be erased or
+        // programmed).
+        //
+        case 2:
+        {
+            return(FlashReadOnly);
+        }
+
+        //
+        // This block is read/write; it can be read, erased, and programmed.
+        //
+        case 3:
+        default:
+        {
+            return(FlashReadWrite);
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Sets the protection setting for a block of flash.
+//!
+//! \param ulAddress is the start address of the flash block to be protected.
+//! \param eProtect is the protection to be applied to the block.  Can be one
+//! of \b FlashReadWrite, \b FlashReadOnly, or \b FlashExecuteOnly.
+//!
+//! This function will set the protection for the specified 2 kB block of
+//! flash.  Blocks which are read/write can be made read-only or execute-only.
+//! Blocks which are read-only can be made execute-only.  Blocks which are
+//! execute-only cannot have their protection modified.  Attempts to make the
+//! block protection less stringent (that is, read-only to read/write) will
+//! result in a failure (and be prevented by the hardware).
+//!
+//! Changes to the flash protection are maintained only until the next reset.
+//! This allows the application to be executed in the desired flash protection
+//! environment to check for inappropriate flash access (via the flash
+//! interrupt).  To make the flash protection permanent, use the
+//! FlashProtectSave() function.
+//!
+//! \return Returns 0 on success, or -1 if an invalid address or an invalid
+//! protection was specified.
+//
+//*****************************************************************************
+long
+FlashProtectSet(unsigned long ulAddress, tFlashProtection eProtect)
+{
+    unsigned long ulProtectRE, ulProtectPE;
+    unsigned long ulBank;
+
+    //
+    // Check the argument.
+    //
+    ASSERT(!(ulAddress &amp; (FLASH_PROTECT_SIZE - 1)));
+    ASSERT((eProtect == FlashReadWrite) || (eProtect == FlashReadOnly) ||
+           (eProtect == FlashExecuteOnly));
+
+    //
+    // Convert the address into a block number.
+    //
+    ulAddress /= FLASH_PROTECT_SIZE;
+
+    //
+    // ulAddress contains a &quot;raw&quot; block number.  Derive the Flash Bank from
+    // the &quot;raw&quot; block number, and convert ulAddress to a &quot;relative&quot;
+    // block number.
+    //
+    ulBank = ((ulAddress / 32) % 4);
+    ulAddress %= 32;
+
+    //
+    // Get the current protection for the specified flash bank.
+    //
+    ulProtectRE = HWREG(g_pulFMPRERegs[ulBank]);
+    ulProtectPE = HWREG(g_pulFMPPERegs[ulBank]);
+
+    //
+    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
+    // bits of the FMPPE register are used for JTAG protect options, and are
+    // not available for the FLASH protection scheme.  When setting protection,
+    // check to see if block 30 or 31 and protection is FlashExecuteOnly.  If
+    // so, return an error condition.
+    //
+    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
+    {
+        if((ulAddress &gt;= 30) &amp;&amp; (eProtect == FlashExecuteOnly))
+        {
+            return(-1);
+        }
+    }
+
+    //
+    // Set the protection based on the requested proection.
+    //
+    switch(eProtect)
+    {
+        //
+        // Make this block execute only.
+        //
+        case FlashExecuteOnly:
+        {
+            //
+            // Turn off the read and program bits for this block.
+            //
+            ulProtectRE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
+            ulProtectPE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
+
+            //
+            // We're done handling this protection.
+            //
+            break;
+        }
+
+        //
+        // Make this block read only.
+        //
+        case FlashReadOnly:
+        {
+            //
+            // The block can not be made read only if it is execute only.
+            //
+            if(((ulProtectRE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
+               FLASH_FMP_BLOCK_0)
+            {
+                return(-1);
+            }
+
+            //
+            // Make this block read only.
+            //
+            ulProtectPE &amp;= ~(FLASH_FMP_BLOCK_0 &lt;&lt; ulAddress);
+
+            //
+            // We're done handling this protection.
+            //
+            break;
+        }
+
+        //
+        // Make this block read/write.
+        //
+        case FlashReadWrite:
+        default:
+        {
+            //
+            // The block can not be made read/write if it is not already
+            // read/write.
+            //
+            if((((ulProtectRE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
+                FLASH_FMP_BLOCK_0) ||
+               (((ulProtectPE &gt;&gt; ulAddress) &amp; FLASH_FMP_BLOCK_0) !=
+                FLASH_FMP_BLOCK_0))
+            {
+                return(-1);
+            }
+
+            //
+            // The block is already read/write, so there is nothing to do.
+            //
+            return(0);
+        }
+    }
+
+    //
+    // For Stellaris Sandstorm-class devices, revision C1 and C2, the upper
+    // bits of the FMPPE register are used for JTAG options, and are not
+    // available for the FLASH protection scheme.  When setting block
+    // protection, ensure that these bits are not altered.
+    //
+    if(CLASS_IS_SANDSTORM &amp;&amp; (REVISION_IS_C1 || REVISION_IS_C2))
+    {
+        ulProtectRE &amp;= ~(FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30);
+        ulProtectRE |= (HWREG(g_pulFMPRERegs[ulBank]) &amp;
+                (FLASH_FMP_BLOCK_31 | FLASH_FMP_BLOCK_30));
+    }
+
+    //
+    // Set the new protection for the specified flash bank.
+    //
+    HWREG(g_pulFMPRERegs[ulBank]) = ulProtectRE;
+    HWREG(g_pulFMPPERegs[ulBank]) = ulProtectPE;
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Saves the flash protection settings.
+//!
+//! This function will make the currently programmed flash protection settings
+//! permanent.  This is a non-reversible operation; a chip reset or power cycle
+//! will not change the flash protection.
+//!
+//! This function will not return until the protection has been saved.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashProtectSave(void)
+{
+    int ulTemp, ulLimit;
+
+    //
+    // If running on a Sandstorm-class device, only trigger a save of the first
+    // two protection registers (FMPRE and FMPPE).  Otherwise, save the
+    // entire bank of flash protection registers.
+    //
+    ulLimit = CLASS_IS_SANDSTORM ? 2 : 8;
+    for(ulTemp = 0; ulTemp &lt; ulLimit; ulTemp++)
+    {
+        //
+        // Tell the flash controller to write the flash protection register.
+        //
+        HWREG(FLASH_FMA) = ulTemp;
+        HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
+
+        //
+        // Wait until the write has completed.
+        //
+        while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
+        {
+        }
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Gets the user registers.
+//!
+//! \param pulUser0 is a pointer to the location to store USER Register 0.
+//! \param pulUser1 is a pointer to the location to store USER Register 1.
+//!
+//! This function will read the contents of user registers (0 and 1), and
+//! store them in the specified locations.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashUserGet(unsigned long *pulUser0, unsigned long *pulUser1)
+{
+    //
+    // Verify that the pointers are valid.
+    //
+    ASSERT(pulUser0 != 0);
+    ASSERT(pulUser1 != 0);
+
+    //
+    // Verify that hardware supports user registers.
+    //
+    if(CLASS_IS_SANDSTORM)
+    {
+        return(-1);
+    }
+
+    //
+    // Get and store the current value of the user registers.
+    //
+    *pulUser0 = HWREG(FLASH_USERREG0);
+    *pulUser1 = HWREG(FLASH_USERREG1);
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Sets the user registers.
+//!
+//! \param ulUser0 is the value to store in USER Register 0.
+//! \param ulUser1 is the value to store in USER Register 1.
+//!
+//! This function will set the contents of the user registers (0 and 1) to
+//! the specified values.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashUserSet(unsigned long ulUser0, unsigned long ulUser1)
+{
+    //
+    // Verify that hardware supports user registers.
+    //
+    if(CLASS_IS_SANDSTORM)
+    {
+        return(-1);
+    }
+
+    //
+    // Save the new values into the user registers.
+    //
+    HWREG(FLASH_USERREG0) = ulUser0;
+    HWREG(FLASH_USERREG1) = ulUser1;
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Saves the user registers.
+//!
+//! This function will make the currently programmed user register settings
+//! permanent.  This is a non-reversible operation; a chip reset or power cycle
+//! will not change this setting.
+//!
+//! This function will not return until the protection has been saved.
+//!
+//! \return Returns 0 on success, or -1 if a hardware error is encountered.
+//
+//*****************************************************************************
+long
+FlashUserSave(void)
+{
+    //
+    // Verify that hardware supports user registers.
+    //
+    if(CLASS_IS_SANDSTORM)
+    {
+        return(-1);
+    }
+
+    //
+    // Setting the MSB of FMA will trigger a permanent save of a USER
+    // register.  Bit 0 will indicate User 0 (0) or User 1 (1).
+    //
+    HWREG(FLASH_FMA) = 0x80000000;
+    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
+
+    //
+    // Wait until the write has completed.
+    //
+    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
+    {
+    }
+
+    //
+    // Tell the flash controller to write the USER1 Register.
+    //
+    HWREG(FLASH_FMA) = 0x80000001;
+    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_COMT;
+
+    //
+    // Wait until the write has completed.
+    //
+    while(HWREG(FLASH_FMC) &amp; FLASH_FMC_COMT)
+    {
+    }
+
+    //
+    // Success.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the flash interrupt.
+//!
+//! \param pfnHandler is a pointer to the function to be called when the flash
+//! interrupt occurs.
+//!
+//! This sets the handler to be called when the flash interrupt occurs.  The
+//! flash controller can generate an interrupt when an invalid flash access
+//! occurs, such as trying to program or erase a read-only block, or trying to
+//! read from an execute-only block.  It can also generate an interrupt when a
+//! program or erase operation has completed.  The interrupt will be
+//! automatically enabled when the handler is registered.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntRegister(void (*pfnHandler)(void))
+{
+    //
+    // Register the interrupt handler, returning an error if an error occurs.
+    //
+    IntRegister(INT_FLASH, pfnHandler);
+
+    //
+    // Enable the flash interrupt.
+    //
+    IntEnable(INT_FLASH);
+}
+
+//*****************************************************************************
+//
+//! Unregisters the interrupt handler for the flash interrupt.
+//!
+//! This function will clear the handler to be called when the flash interrupt
+//! occurs.  This will also mask off the interrupt in the interrupt controller
+//! so that the interrupt handler is no longer called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntUnregister(void)
+{
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(INT_FLASH);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(INT_FLASH);
+}
+
+//*****************************************************************************
+//
+//! Enables individual flash controller interrupt sources.
+//!
+//! \param ulIntFlags is a bit mask of the interrupt sources to be enabled.
+//! Can be any of the \b FLASH_FCIM_PROGRAM or \b FLASH_FCIM_ACCESS values.
+//!
+//! Enables the indicated flash controller interrupt sources.  Only the sources
+//! that are enabled can be reflected to the processor interrupt; disabled
+//! sources have no effect on the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntEnable(unsigned long ulIntFlags)
+{
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(FLASH_FCIM) |= ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Disables individual flash controller interrupt sources.
+//!
+//! \param ulIntFlags is a bit mask of the interrupt sources to be disabled.
+//! Can be any of the \b FLASH_FCIM_PROGRAM or \b FLASH_FCIM_ACCESS values.
+//!
+//! Disables the indicated flash controller interrupt sources.  Only the
+//! sources that are enabled can be reflected to the processor interrupt;
+//! disabled sources have no effect on the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntDisable(unsigned long ulIntFlags)
+{
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(FLASH_FCIM) &amp;= ~(ulIntFlags);
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param bMasked is false if the raw interrupt status is required and true if
+//! the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the flash controller.  Either the raw
+//! interrupt status or the status of interrupts that are allowed to reflect to
+//! the processor can be returned.
+//!
+//! \return The current interrupt status, enumerated as a bit field of
+//! \b FLASH_FCMISC_PROGRAM and \b FLASH_FCMISC_AMISC.
+//
+//*****************************************************************************
+unsigned long
+FlashIntGetStatus(tBoolean bMasked)
+{
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    if(bMasked)
+    {
+        return(HWREG(FLASH_FCMISC));
+    }
+    else
+    {
+        return(HWREG(FLASH_FCRIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears flash controller interrupt sources.
+//!
+//! \param ulIntFlags is the bit mask of the interrupt sources to be cleared.
+//! Can be any of the \b FLASH_FCMISC_PROGRAM or \b FLASH_FCMISC_AMISC values.
+//!
+//! The specified flash controller interrupt sources are cleared, so that they
+//! no longer assert.  This must be done in the interrupt handler to keep it
+//! from being called again immediately upon exit.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+FlashIntClear(unsigned long ulIntFlags)
+{
+    //
+    // Clear the flash interrupt.
+    //
+    HWREG(FLASH_FCMISC) = ulIntFlags;
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/flash.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/flash.h
===================================================================
--- trunk/src/platform/lm3s/flash.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/flash.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,89 +1,89 @@
-//*****************************************************************************
-//
-// flash.h - Prototypes for the flash driver.
-//
-// Copyright (c) 2005-2007 Luminary Micro, Inc.  All rights reserved
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __FLASH_H__
-#define __FLASH_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Values that can be passed to FlashProtectSet(), and returned by
-// FlashProtectGet().
-//
-//*****************************************************************************
-typedef enum
-{
-    FlashReadWrite,                         // Flash can be read and written
-    FlashReadOnly,                          // Flash can only be read
-    FlashExecuteOnly                        // Flash can only be executed
-}
-tFlashProtection;
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern unsigned long FlashUsecGet(void);
-extern void FlashUsecSet(unsigned long ulClocks);
-extern long FlashErase(unsigned long ulAddress);
-extern long FlashProgram(unsigned long *pulData, unsigned long ulAddress,
-                         unsigned long ulCount);
-extern tFlashProtection FlashProtectGet(unsigned long ulAddress);
-extern long FlashProtectSet(unsigned long ulAddress,
-                            tFlashProtection eProtect);
-extern long FlashProtectSave(void);
-extern long FlashUserGet(unsigned long *pulUser0, unsigned long *pulUser1);
-extern long FlashUserSet(unsigned long ulUser0, unsigned long ulUser1);
-extern long FlashUserSave(void);
-extern void FlashIntRegister(void (*pfnHandler)(void));
-extern void FlashIntUnregister(void);
-extern void FlashIntEnable(unsigned long ulIntFlags);
-extern void FlashIntDisable(unsigned long ulIntFlags);
-extern unsigned long FlashIntGetStatus(tBoolean bMasked);
-extern void FlashIntClear(unsigned long ulIntFlags);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __FLASH_H__
+//*****************************************************************************
+//
+// flash.h - Prototypes for the flash driver.
+//
+// Copyright (c) 2005-2007 Luminary Micro, Inc.  All rights reserved
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __FLASH_H__
+#define __FLASH_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to FlashProtectSet(), and returned by
+// FlashProtectGet().
+//
+//*****************************************************************************
+typedef enum
+{
+    FlashReadWrite,                         // Flash can be read and written
+    FlashReadOnly,                          // Flash can only be read
+    FlashExecuteOnly                        // Flash can only be executed
+}
+tFlashProtection;
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern unsigned long FlashUsecGet(void);
+extern void FlashUsecSet(unsigned long ulClocks);
+extern long FlashErase(unsigned long ulAddress);
+extern long FlashProgram(unsigned long *pulData, unsigned long ulAddress,
+                         unsigned long ulCount);
+extern tFlashProtection FlashProtectGet(unsigned long ulAddress);
+extern long FlashProtectSet(unsigned long ulAddress,
+                            tFlashProtection eProtect);
+extern long FlashProtectSave(void);
+extern long FlashUserGet(unsigned long *pulUser0, unsigned long *pulUser1);
+extern long FlashUserSet(unsigned long ulUser0, unsigned long ulUser1);
+extern long FlashUserSave(void);
+extern void FlashIntRegister(void (*pfnHandler)(void));
+extern void FlashIntUnregister(void);
+extern void FlashIntEnable(unsigned long ulIntFlags);
+extern void FlashIntDisable(unsigned long ulIntFlags);
+extern unsigned long FlashIntGetStatus(tBoolean bMasked);
+extern void FlashIntClear(unsigned long ulIntFlags);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __FLASH_H__


Property changes on: trunk/src/platform/lm3s/flash.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/gpio.c
===================================================================
--- trunk/src/platform/lm3s/gpio.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/gpio.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,1343 +1,1517 @@
-//*****************************************************************************
-//
-// gpio.c - API for GPIO ports
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup gpio_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_gpio.h&quot;
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;gpio.h&quot;
-#include &quot;interrupt.h&quot;
-
-//*****************************************************************************
-//
-//! \internal
-//! Checks a GPIO base address.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//!
-//! This function determines if a GPIO port base address is valid.
-//!
-//! \return Returns \b true if the base address is valid and \b false
-//! otherwise.
-//
-//*****************************************************************************
-#ifdef DEBUG
-static tBoolean
-GPIOBaseValid(unsigned long ulPort)
-{
-    return((ulPort == GPIO_PORTA_BASE) || (ulPort == GPIO_PORTA_AHB_BASE) ||
-           (ulPort == GPIO_PORTB_BASE) || (ulPort == GPIO_PORTB_AHB_BASE) ||
-           (ulPort == GPIO_PORTC_BASE) || (ulPort == GPIO_PORTC_AHB_BASE) ||
-           (ulPort == GPIO_PORTD_BASE) || (ulPort == GPIO_PORTD_AHB_BASE) ||
-           (ulPort == GPIO_PORTE_BASE) || (ulPort == GPIO_PORTE_AHB_BASE) ||
-           (ulPort == GPIO_PORTF_BASE) || (ulPort == GPIO_PORTF_AHB_BASE) ||
-           (ulPort == GPIO_PORTG_BASE) || (ulPort == GPIO_PORTG_AHB_BASE) ||
-           (ulPort == GPIO_PORTH_BASE) || (ulPort == GPIO_PORTH_AHB_BASE));
-}
-#endif
-
-//*****************************************************************************
-//
-//! \internal
-//! Gets the GPIO interrupt number.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//!
-//! Given a GPIO base address, returns the corresponding interrupt number.
-//!
-//! \return Returns a GPIO interrupt number, or -1 if \e ulPort is invalid.
-//
-//*****************************************************************************
-static long
-GPIOGetIntNumber(unsigned long ulPort)
-{
-    unsigned int ulInt;
-
-    //
-    // Determine the GPIO interrupt number for the given module.
-    //
-    switch(ulPort)
-    {
-        case GPIO_PORTA_BASE:
-        case GPIO_PORTA_AHB_BASE:
-        {
-            ulInt = INT_GPIOA;
-            break;
-        }
-
-        case GPIO_PORTB_BASE:
-        case GPIO_PORTB_AHB_BASE:
-        {
-            ulInt = INT_GPIOB;
-            break;
-        }
-
-        case GPIO_PORTC_BASE:
-        case GPIO_PORTC_AHB_BASE:
-        {
-            ulInt = INT_GPIOC;
-            break;
-        }
-
-        case GPIO_PORTD_BASE:
-        case GPIO_PORTD_AHB_BASE:
-        {
-            ulInt = INT_GPIOD;
-            break;
-        }
-
-        case GPIO_PORTE_BASE:
-        case GPIO_PORTE_AHB_BASE:
-        {
-            ulInt = INT_GPIOE;
-            break;
-        }
-
-        case GPIO_PORTF_BASE:
-        case GPIO_PORTF_AHB_BASE:
-        {
-            ulInt = INT_GPIOF;
-            break;
-        }
-
-        case GPIO_PORTG_BASE:
-        case GPIO_PORTG_AHB_BASE:
-        {
-            ulInt = INT_GPIOG;
-            break;
-        }
-
-        case GPIO_PORTH_BASE:
-        case GPIO_PORTH_AHB_BASE:
-        {
-            ulInt = INT_GPIOH;
-            break;
-        }
-
-        default:
-        {
-            return(-1);
-        }
-    }
-
-    //
-    // Return GPIO interrupt number.
-    //
-    return(ulInt);
-}
-
-//*****************************************************************************
-//
-//! Sets the direction and mode of the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port
-//! \param ucPins is the bit-packed representation of the pin(s).
-//! \param ulPinIO is the pin direction and/or mode.
-//!
-//! This function will set the specified pin(s) on the selected GPIO port
-//! as either an input or output under software control, or it will set the
-//! pin to be under hardware control.
-//!
-//! The parameter \e ulPinIO is an enumerated data type that can be one of
-//! the following values:
-//!
-//! - \b GPIO_DIR_MODE_IN
-//! - \b GPIO_DIR_MODE_OUT
-//! - \b GPIO_DIR_MODE_HW
-//!
-//! where \b GPIO_DIR_MODE_IN specifies that the pin will be programmed as
-//! a software controlled input, \b GPIO_DIR_MODE_OUT specifies that the pin
-//! will be programmed as a software controlled output, and
-//! \b GPIO_DIR_MODE_HW specifies that the pin will be placed under
-//! hardware control.
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIODirModeSet(unsigned long ulPort, unsigned char ucPins,
-               unsigned long ulPinIO)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-    ASSERT((ulPinIO == GPIO_DIR_MODE_IN) || (ulPinIO == GPIO_DIR_MODE_OUT) ||
-           (ulPinIO == GPIO_DIR_MODE_HW));
-
-    //
-    // Set the pin direction and mode.
-    //
-    HWREG(ulPort + GPIO_O_DIR) = ((ulPinIO &amp; 1) ?
-                                  (HWREG(ulPort + GPIO_O_DIR) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_DIR) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_AFSEL) = ((ulPinIO &amp; 2) ?
-                                    (HWREG(ulPort + GPIO_O_AFSEL) | ucPins) :
-                                    (HWREG(ulPort + GPIO_O_AFSEL) &amp;
-                                     ~(ucPins)));
-}
-
-//*****************************************************************************
-//
-//! Gets the direction and mode of a pin.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPin is the pin number.
-//!
-//! This function gets the direction and control mode for a specified pin on
-//! the selected GPIO port.  The pin can be configured as either an input or
-//! output under software control, or it can be under hardware control.  The
-//! type of control and direction are returned as an enumerated data type.
-//!
-//! \return Returns one of the enumerated data types described for
-//! GPIODirModeSet().
-//
-//*****************************************************************************
-unsigned long
-GPIODirModeGet(unsigned long ulPort, unsigned char ucPin)
-{
-    unsigned long ulDir, ulAFSEL;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-    ASSERT(ucPin &lt; 8);
-
-    //
-    // Convert from a pin number to a bit position.
-    //
-    ucPin = 1 &lt;&lt; ucPin;
-
-    //
-    // Return the pin direction and mode.
-    //
-    ulDir = HWREG(ulPort + GPIO_O_DIR);
-    ulAFSEL = HWREG(ulPort + GPIO_O_AFSEL);
-    return(((ulDir &amp; ucPin) ? 1 : 0) | ((ulAFSEL &amp; ucPin) ? 2 : 0));
-}
-
-//*****************************************************************************
-//
-//! Sets the interrupt type for the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//! \param ulIntType specifies the type of interrupt trigger mechanism.
-//!
-//! This function sets up the various interrupt trigger mechanisms for the
-//! specified pin(s) on the selected GPIO port.
-//!
-//! The parameter \e ulIntType is an enumerated data type that can be one of
-//! the following values:
-//!
-//! - \b GPIO_FALLING_EDGE
-//! - \b GPIO_RISING_EDGE
-//! - \b GPIO_BOTH_EDGES
-//! - \b GPIO_LOW_LEVEL
-//! - \b GPIO_HIGH_LEVEL
-//!
-//! where the different values describe the interrupt detection mechanism
-//! (edge or level) and the particular triggering event (falling, rising,
-//! or both edges for edge detect, low or high for level detect).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note In order to avoid any spurious interrupts, the user must
-//! ensure that the GPIO inputs remain stable for the duration of
-//! this function.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOIntTypeSet(unsigned long ulPort, unsigned char ucPins,
-               unsigned long ulIntType)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-    ASSERT((ulIntType == GPIO_FALLING_EDGE) ||
-           (ulIntType == GPIO_RISING_EDGE) || (ulIntType == GPIO_BOTH_EDGES) ||
-           (ulIntType == GPIO_LOW_LEVEL) || (ulIntType == GPIO_HIGH_LEVEL));
-
-    //
-    // Set the pin interrupt type.
-    //
-    HWREG(ulPort + GPIO_O_IBE) = ((ulIntType &amp; 1) ?
-                                  (HWREG(ulPort + GPIO_O_IBE) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_IBE) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_IS) = ((ulIntType &amp; 2) ?
-                                 (HWREG(ulPort + GPIO_O_IS) | ucPins) :
-                                 (HWREG(ulPort + GPIO_O_IS) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_IEV) = ((ulIntType &amp; 4) ?
-                                  (HWREG(ulPort + GPIO_O_IEV) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_IEV) &amp; ~(ucPins)));
-}
-
-//*****************************************************************************
-//
-//! Gets the interrupt type for a pin.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPin is the pin number.
-//!
-//! This function gets the interrupt type for a specified pin on the selected
-//! GPIO port.  The pin can be configured as a falling edge, rising edge, or
-//! both edge detected interrupt, or it can be configured as a low level or
-//! high level detected interrupt.  The type of interrupt detection mechanism
-//! is returned as an enumerated data type.
-//!
-//! \return Returns one of the enumerated data types described for
-//! GPIOIntTypeSet().
-//
-//*****************************************************************************
-unsigned long
-GPIOIntTypeGet(unsigned long ulPort, unsigned char ucPin)
-{
-    unsigned long ulIBE, ulIS, ulIEV;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-    ASSERT(ucPin &lt; 8);
-
-    //
-    // Convert from a pin number to a bit position.
-    //
-    ucPin = 1 &lt;&lt; ucPin;
-
-    //
-    // Return the pin interrupt type.
-    //
-    ulIBE = HWREG(ulPort + GPIO_O_IBE);
-    ulIS = HWREG(ulPort + GPIO_O_IS);
-    ulIEV = HWREG(ulPort + GPIO_O_IEV);
-    return(((ulIBE &amp; ucPin) ? 1 : 0) | ((ulIS &amp; ucPin) ? 2 : 0) |
-           ((ulIEV &amp; ucPin) ? 4 : 0));
-}
-
-//*****************************************************************************
-//
-//! Sets the pad configuration for the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//! \param ulStrength specifies the output drive strength.
-//! \param ulPinType specifies the pin type.
-//!
-//! This function sets the drive strength and type for the specified pin(s)
-//! on the selected GPIO port.  For pin(s) configured as input ports, the
-//! pad is configured as requested, but the only real effect on the input
-//! is the configuration of the pull-up or pull-down termination.
-//!
-//! The parameter \e ulStrength can be one of the following values:
-//!
-//! - \b GPIO_STRENGTH_2MA
-//! - \b GPIO_STRENGTH_4MA
-//! - \b GPIO_STRENGTH_8MA
-//! - \b GPIO_STRENGTH_8MA_SC
-//!
-//! where \b GPIO_STRENGTH_xMA specifies either 2, 4, or 8 mA output drive
-//! strength, and \b GPIO_OUT_STRENGTH_8MA_SC specifies 8 mA output drive with
-//! slew control.
-//!
-//! The parameter \e ulPinType can be one of the following values:
-//!
-//! - \b GPIO_PIN_TYPE_STD
-//! - \b GPIO_PIN_TYPE_STD_WPU
-//! - \b GPIO_PIN_TYPE_STD_WPD
-//! - \b GPIO_PIN_TYPE_OD
-//! - \b GPIO_PIN_TYPE_OD_WPU
-//! - \b GPIO_PIN_TYPE_OD_WPD
-//! - \b GPIO_PIN_TYPE_ANALOG
-//!
-//! where \b GPIO_PIN_TYPE_STD* specifies a push-pull pin, \b GPIO_PIN_TYPE_OD*
-//! specifies an open-drain pin, \b *_WPU specifies a weak pull-up, \b *_WPD
-//! specifies a weak pull-down, and \b GPIO_PIN_TYPE_ANALOG specifies an
-//! analog input (for the comparators).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPadConfigSet(unsigned long ulPort, unsigned char ucPins,
-                 unsigned long ulStrength, unsigned long ulPinType)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-    ASSERT((ulStrength == GPIO_STRENGTH_2MA) ||
-           (ulStrength == GPIO_STRENGTH_4MA) ||
-           (ulStrength == GPIO_STRENGTH_8MA) ||
-           (ulStrength == GPIO_STRENGTH_8MA_SC));
-    ASSERT((ulPinType == GPIO_PIN_TYPE_STD) ||
-           (ulPinType == GPIO_PIN_TYPE_STD_WPU) ||
-           (ulPinType == GPIO_PIN_TYPE_STD_WPD) ||
-           (ulPinType == GPIO_PIN_TYPE_OD) ||
-           (ulPinType == GPIO_PIN_TYPE_OD_WPU) ||
-           (ulPinType == GPIO_PIN_TYPE_OD_WPD) ||
-           (ulPinType == GPIO_PIN_TYPE_ANALOG))
-
-    //
-    // Set the output drive strength.
-    //
-    HWREG(ulPort + GPIO_O_DR2R) = ((ulStrength &amp; 1) ?
-                                   (HWREG(ulPort + GPIO_O_DR2R) | ucPins) :
-                                   (HWREG(ulPort + GPIO_O_DR2R) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_DR4R) = ((ulStrength &amp; 2) ?
-                                   (HWREG(ulPort + GPIO_O_DR4R) | ucPins) :
-                                   (HWREG(ulPort + GPIO_O_DR4R) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_DR8R) = ((ulStrength &amp; 4) ?
-                                   (HWREG(ulPort + GPIO_O_DR8R) | ucPins) :
-                                   (HWREG(ulPort + GPIO_O_DR8R) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_SLR) = ((ulStrength &amp; 8) ?
-                                  (HWREG(ulPort + GPIO_O_SLR) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_SLR) &amp; ~(ucPins)));
-
-    //
-    // Set the pin type.
-    //
-    HWREG(ulPort + GPIO_O_ODR) = ((ulPinType &amp; 1) ?
-                                  (HWREG(ulPort + GPIO_O_ODR) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_ODR) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_PUR) = ((ulPinType &amp; 2) ?
-                                  (HWREG(ulPort + GPIO_O_PUR) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_PUR) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_PDR) = ((ulPinType &amp; 4) ?
-                                  (HWREG(ulPort + GPIO_O_PDR) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_PDR) &amp; ~(ucPins)));
-    HWREG(ulPort + GPIO_O_DEN) = ((ulPinType &amp; 8) ?
-                                  (HWREG(ulPort + GPIO_O_DEN) | ucPins) :
-                                  (HWREG(ulPort + GPIO_O_DEN) &amp; ~(ucPins)));
-
-    //
-    // Set the analog mode select register.  This register only appears in
-    // DustDevil-class (and later) devices, but is a harmless write on
-    // Sandstorm- and Fury-class devices.
-    //
-    HWREG(ulPort + GPIO_O_AMSEL) =
-        ((ulPinType == GPIO_PIN_TYPE_ANALOG) ?
-         (HWREG(ulPort + GPIO_O_AMSEL) | ucPins) :
-         (HWREG(ulPort + GPIO_O_AMSEL) &amp; ~(ucPins)));
-}
-
-//*****************************************************************************
-//
-//! Gets the pad configuration for a pin.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPin is the pin number.
-//! \param pulStrength is a pointer to storage for the output drive strength.
-//! \param pulPinType is a pointer to storage for the output drive type.
-//!
-//! This function gets the pad configuration for a specified pin on the
-//! selected GPIO port.  The values returned in \e pulStrength and
-//! \e pulPinType correspond to the values used in GPIOPadConfigSet().  This
-//! function also works for pin(s) configured as input pin(s); however, the
-//! only meaningful data returned is whether the pin is terminated with a
-//! pull-up or down resistor.
-//!
-//! \return None
-//
-//*****************************************************************************
-void
-GPIOPadConfigGet(unsigned long ulPort, unsigned char ucPin,
-                 unsigned long *pulStrength, unsigned long *pulPinType)
-{
-    unsigned long ulTemp1, ulTemp2, ulTemp3, ulTemp4;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-    ASSERT(ucPin &lt; 8);
-
-    //
-    // Convert from a pin number to a bit position.
-    //
-    ucPin = (1 &lt;&lt; ucPin);
-
-    //
-    // Get the drive strength for this pin.
-    //
-    ulTemp1 = HWREG(ulPort + GPIO_O_DR2R);
-    ulTemp2 = HWREG(ulPort + GPIO_O_DR4R);
-    ulTemp3 = HWREG(ulPort + GPIO_O_DR8R);
-    ulTemp4 = HWREG(ulPort + GPIO_O_SLR);
-    *pulStrength = (((ulTemp1 &amp; ucPin) ? 1 : 0) | ((ulTemp2 &amp; ucPin) ? 2 : 0) |
-                    ((ulTemp3 &amp; ucPin) ? 4 : 0) | ((ulTemp4 &amp; ucPin) ? 8 : 0));
-
-    //
-    // Get the pin type.
-    //
-    ulTemp1 = HWREG(ulPort + GPIO_O_ODR);
-    ulTemp2 = HWREG(ulPort + GPIO_O_PUR);
-    ulTemp3 = HWREG(ulPort + GPIO_O_PDR);
-    ulTemp4 = HWREG(ulPort + GPIO_O_DEN);
-    *pulPinType = (((ulTemp1 &amp; ucPin) ? 1 : 0) | ((ulTemp2 &amp; ucPin) ? 2 : 0) |
-                   ((ulTemp3 &amp; ucPin) ? 4 : 0) | ((ulTemp4 &amp; ucPin) ? 8 : 0));
-}
-
-//*****************************************************************************
-//
-//! Enables interrupts for the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! Unmasks the interrupt for the specified pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinIntEnable(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Enable the interrupts.
-    //
-    HWREG(ulPort + GPIO_O_IM) |= ucPins;
-}
-
-//*****************************************************************************
-//
-//! Disables interrupts for the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! Masks the interrupt for the specified pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinIntDisable(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Disable the interrupts.
-    //
-    HWREG(ulPort + GPIO_O_IM) &amp;= ~(ucPins);
-}
-
-//*****************************************************************************
-//
-//! Gets interrupt status for the specified GPIO port.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param bMasked specifies whether masked or raw interrupt status is
-//! returned.
-//!
-//! If \e bMasked is set as \b true, then the masked interrupt status is
-//! returned; otherwise, the raw interrupt status will be returned.
-//!
-//! \return Returns a bit-packed byte, where each bit that is set identifies
-//! an active masked or raw interrupt, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//! Bits 31:8 should be ignored.
-//
-//*****************************************************************************
-long
-GPIOPinIntStatus(unsigned long ulPort, tBoolean bMasked)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Return the interrupt status.
-    //
-    if(bMasked)
-    {
-        return(HWREG(ulPort + GPIO_O_MIS));
-    }
-    else
-    {
-        return(HWREG(ulPort + GPIO_O_RIS));
-    }
-}
-
-//*****************************************************************************
-//
-//! Clears the interrupt for the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! Clears the interrupt for the specified pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinIntClear(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Clear the interrupts.
-    //
-    HWREG(ulPort + GPIO_O_ICR) = ucPins;
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for a GPIO port.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param pfnIntHandler is a pointer to the GPIO port interrupt handling
-//! function.
-//!
-//! This function will ensure that the interrupt handler specified by
-//! \e pfnIntHandler is called when an interrupt is detected from the selected
-//! GPIO port.  This function will also enable the corresponding GPIO interrupt
-//! in the interrupt controller; individual pin interrupts and interrupt
-//! sources must be enabled with GPIOPinIntEnable().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPortIntRegister(unsigned long ulPort, void (*pfnIntHandler)(void))
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Get the interrupt number associated with the specified GPIO.
-    //
-    ulPort = GPIOGetIntNumber(ulPort);
-
-    //
-    // Register the interrupt handler.
-    //
-    IntRegister(ulPort, pfnIntHandler);
-
-    //
-    // Enable the GPIO interrupt.
-    //
-    IntEnable(ulPort);
-}
-
-//*****************************************************************************
-//
-//! Removes an interrupt handler for a GPIO port.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//!
-//! This function will unregister the interrupt handler for the specified
-//! GPIO port.  This function will also disable the corresponding
-//! GPIO port interrupt in the interrupt controller; individual GPIO interrupts
-//! and interrupt sources must be disabled with GPIOPinIntDisable().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPortIntUnregister(unsigned long ulPort)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Get the interrupt number associated with the specified GPIO.
-    //
-    ulPort = GPIOGetIntNumber(ulPort);
-
-    //
-    // Disable the GPIO interrupt.
-    //
-    IntDisable(ulPort);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(ulPort);
-}
-
-//*****************************************************************************
-//
-//! Reads the values present of the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The values at the specified pin(s) are read, as specified by \e ucPins.
-//! Values are returned for both input and output pin(s), and the value
-//! for pin(s) that are not specified by \e ucPins are set to 0.
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return Returns a bit-packed byte providing the state of the specified
-//! pin, where bit 0 of the byte represents GPIO port pin 0, bit 1 represents
-//! GPIO port pin 1, and so on.  Any bit that is not specified by \e ucPins
-//! is returned as a 0.  Bits 31:8 should be ignored.
-//
-//*****************************************************************************
-long
-GPIOPinRead(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Return the pin value(s).
-    //
-    return(HWREG(ulPort + (GPIO_O_DATA + (ucPins &lt;&lt; 2))));
-}
-
-//*****************************************************************************
-//
-//! Writes a value to the specified pin(s).
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//! \param ucVal is the value to write to the pin(s).
-//!
-//! Writes the corresponding bit values to the output pin(s) specified by
-//! \e ucPins.  Writing to a pin configured as an input pin has no effect.
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinWrite(unsigned long ulPort, unsigned char ucPins, unsigned char ucVal)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Write the pins.
-    //
-    HWREG(ulPort + (GPIO_O_DATA + (ucPins &lt;&lt; 2))) = ucVal;
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use as analog-to-digital converter inputs.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The analog-to-digital converter input pins must be properly configured
-//! to function correctly on DustDevil-class devices.  This function provides
-//! the proper configuration for those pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into an ADC input; it only
-//! configures an ADC input pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeADC(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be inputs.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_IN);
-
-    //
-    // Set the pad(s) for analog operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_ANALOG);
-
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use as a CAN device.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The CAN pins must be properly configured for the CAN peripherals to
-//! function correctly.  This function provides a typical configuration for
-//! those pin(s); other configurations may work as well depending upon the
-//! board setup (for example, using the on-chip pull-ups).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into a CAN pin; it only
-//! configures a CAN pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeCAN(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be inputs.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use as an analog comparator input.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The analog comparator input pins must be properly configured for the analog
-//! comparator to function correctly.  This function provides the proper
-//! configuration for those pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into an analog comparator input;
-//! it only configures an analog comparator pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeComparator(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be inputs.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_IN);
-
-    //
-    // Set the pad(s) for analog operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_ANALOG);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use as GPIO inputs.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The GPIO pins must be properly configured in order to function correctly as
-//! GPIO inputs; this is especially true of Fury-class devices where the
-//! digital input enable is turned off by default.  This function provides the
-//! proper configuration for those pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeGPIOInput(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be inputs.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_IN);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use as GPIO outputs.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The GPIO pins must be properly configured in order to function correctly as
-//! GPIO outputs; this is especially true of Fury-class devices where the
-//! digital input enable is turned off by default.  This function provides the
-//! proper configuration for those pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeGPIOOutput(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be outputs.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_OUT);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use as GPIO open drain outputs.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The GPIO pins must be properly configured in order to function correctly as
-//! GPIO outputs; this is especially true of Fury-class devices where the
-//! digital input enable is turned off by default.  This function provides the
-//! proper configuration for those pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeGPIOOutputOD(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be outputs.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_OUT);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_OD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use by the I2C peripheral.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The I2C pins must be properly configured for the I2C peripheral to function
-//! correctly.  This function provides the proper configuration for those
-//! pin(s).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into an I2C pin; it only
-//! configures an I2C pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeI2C(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be peripheral controlled.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for open-drain operation with a weak pull-up.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_OD_WPU);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use by the PWM peripheral.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The PWM pins must be properly configured for the PWM peripheral to function
-//! correctly.  This function provides a typical configuration for those
-//! pin(s); other configurations may work as well depending upon the board
-//! setup (for example, using the on-chip pull-ups).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into a PWM pin; it only
-//! configures a PWM pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypePWM(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be peripheral controlled.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use by the QEI peripheral.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The QEI pins must be properly configured for the QEI peripheral to function
-//! correctly.  This function provides a typical configuration for those
-//! pin(s); other configurations may work as well depending upon the board
-//! setup (for example, not using the on-chip pull-ups).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into a QEI pin; it only
-//! configures a QEI pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeQEI(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be peripheral controlled.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for standard push-pull operation with a weak pull-up.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use by the SSI peripheral.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The SSI pins must be properly configured for the SSI peripheral to function
-//! correctly.  This function provides a typical configuration for those
-//! pin(s); other configurations may work as well depending upon the board
-//! setup (for example, using the on-chip pull-ups).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into a SSI pin; it only
-//! configures a SSI pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeSSI(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be peripheral controlled.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use by the Timer peripheral.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The CCP pins must be properly configured for the timer peripheral to
-//! function correctly.  This function provides a typical configuration for
-//! those pin(s); other configurations may work as well depending upon the
-//! board setup (for example, using the on-chip pull-ups).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into a timer pin; it only
-//! configures a timer pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeTimer(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be peripheral controlled.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use by the UART peripheral.
-//!
-//! \param ulPort is the base address of the GPIO port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! The UART pins must be properly configured for the UART peripheral to
-//! function correctly.  This function provides a typical configuration for
-//! those pin(s); other configurations may work as well depending upon the
-//! board setup (for example, using the on-chip pull-ups).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into a UART pin; it only
-//! configures a UART pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeUART(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be peripheral controlled.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-//! Configures pin(s) for use by the USB peripheral.
-//!
-//! \param ulPort is the base address of the USB port.
-//! \param ucPins is the bit-packed representation of the pin(s).
-//!
-//! Some USB pins must be properly configured for the USB peripheral to
-//! function correctly.  This function provides a typical configuration for
-//! the digital USB pin(s); other configurations may work as well depending
-//! upon the board setup (for example, using the on-chip pull-ups).
-//!
-//! The pin(s) are specified using a bit-packed byte, where each bit that is
-//! set identifies the pin to be accessed, and where bit 0 of the byte
-//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
-//!
-//! \note This cannot be used to turn any pin into a USB pin; it only
-//! configures a USB pin for proper operation.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-GPIOPinTypeUSBDigital(unsigned long ulPort, unsigned char ucPins)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(GPIOBaseValid(ulPort));
-
-    //
-    // Make the pin(s) be peripheral controlled.
-    //
-    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
-
-    //
-    // Set the pad(s) for standard push-pull operation.
-    //
-    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// gpio.c - API for GPIO ports
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup gpio_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_gpio.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_sysctl.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;gpio.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// The base addresses of all the GPIO modules.  Both the APB and AHB apertures
+// are provided.
+//
+//*****************************************************************************
+static const unsigned long g_pulGPIOBaseAddrs[] =
+{
+    GPIO_PORTA_BASE, GPIO_PORTA_AHB_BASE,
+    GPIO_PORTB_BASE, GPIO_PORTB_AHB_BASE,
+    GPIO_PORTC_BASE, GPIO_PORTC_AHB_BASE,
+    GPIO_PORTD_BASE, GPIO_PORTD_AHB_BASE,
+    GPIO_PORTE_BASE, GPIO_PORTE_AHB_BASE,
+    GPIO_PORTF_BASE, GPIO_PORTF_AHB_BASE,
+    GPIO_PORTG_BASE, GPIO_PORTG_AHB_BASE,
+    GPIO_PORTH_BASE, GPIO_PORTH_AHB_BASE,
+    GPIO_PORTJ_BASE, GPIO_PORTJ_AHB_BASE,
+};
+
+//*****************************************************************************
+//
+//! \internal
+//! Checks a GPIO base address.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//!
+//! This function determines if a GPIO port base address is valid.
+//!
+//! \return Returns \b true if the base address is valid and \b false
+//! otherwise.
+//
+//*****************************************************************************
+#ifdef DEBUG
+static tBoolean
+GPIOBaseValid(unsigned long ulPort)
+{
+    return((ulPort == GPIO_PORTA_BASE) || (ulPort == GPIO_PORTA_AHB_BASE) ||
+           (ulPort == GPIO_PORTB_BASE) || (ulPort == GPIO_PORTB_AHB_BASE) ||
+           (ulPort == GPIO_PORTC_BASE) || (ulPort == GPIO_PORTC_AHB_BASE) ||
+           (ulPort == GPIO_PORTD_BASE) || (ulPort == GPIO_PORTD_AHB_BASE) ||
+           (ulPort == GPIO_PORTE_BASE) || (ulPort == GPIO_PORTE_AHB_BASE) ||
+           (ulPort == GPIO_PORTF_BASE) || (ulPort == GPIO_PORTF_AHB_BASE) ||
+           (ulPort == GPIO_PORTG_BASE) || (ulPort == GPIO_PORTG_AHB_BASE) ||
+           (ulPort == GPIO_PORTH_BASE) || (ulPort == GPIO_PORTH_AHB_BASE) ||
+           (ulPort == GPIO_PORTJ_BASE) || (ulPort == GPIO_PORTJ_AHB_BASE));
+}
+#endif
+
+//*****************************************************************************
+//
+//! \internal
+//! Gets the GPIO interrupt number.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//!
+//! Given a GPIO base address, returns the corresponding interrupt number.
+//!
+//! \return Returns a GPIO interrupt number, or -1 if \e ulPort is invalid.
+//
+//*****************************************************************************
+static long
+GPIOGetIntNumber(unsigned long ulPort)
+{
+    unsigned int ulInt;
+
+    //
+    // Determine the GPIO interrupt number for the given module.
+    //
+    switch(ulPort)
+    {
+        case GPIO_PORTA_BASE:
+        case GPIO_PORTA_AHB_BASE:
+        {
+            ulInt = INT_GPIOA;
+            break;
+        }
+
+        case GPIO_PORTB_BASE:
+        case GPIO_PORTB_AHB_BASE:
+        {
+            ulInt = INT_GPIOB;
+            break;
+        }
+
+        case GPIO_PORTC_BASE:
+        case GPIO_PORTC_AHB_BASE:
+        {
+            ulInt = INT_GPIOC;
+            break;
+        }
+
+        case GPIO_PORTD_BASE:
+        case GPIO_PORTD_AHB_BASE:
+        {
+            ulInt = INT_GPIOD;
+            break;
+        }
+
+        case GPIO_PORTE_BASE:
+        case GPIO_PORTE_AHB_BASE:
+        {
+            ulInt = INT_GPIOE;
+            break;
+        }
+
+        case GPIO_PORTF_BASE:
+        case GPIO_PORTF_AHB_BASE:
+        {
+            ulInt = INT_GPIOF;
+            break;
+        }
+
+        case GPIO_PORTG_BASE:
+        case GPIO_PORTG_AHB_BASE:
+        {
+            ulInt = INT_GPIOG;
+            break;
+        }
+
+        case GPIO_PORTH_BASE:
+        case GPIO_PORTH_AHB_BASE:
+        {
+            ulInt = INT_GPIOH;
+            break;
+        }
+
+        case GPIO_PORTJ_BASE:
+        case GPIO_PORTJ_AHB_BASE:
+        {
+            ulInt = INT_GPIOJ;
+            break;
+        }
+
+        default:
+        {
+            return(-1);
+        }
+    }
+
+    //
+    // Return GPIO interrupt number.
+    //
+    return(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Sets the direction and mode of the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port
+//! \param ucPins is the bit-packed representation of the pin(s).
+//! \param ulPinIO is the pin direction and/or mode.
+//!
+//! This function will set the specified pin(s) on the selected GPIO port
+//! as either an input or output under software control, or it will set the
+//! pin to be under hardware control.
+//!
+//! The parameter \e ulPinIO is an enumerated data type that can be one of
+//! the following values:
+//!
+//! - \b GPIO_DIR_MODE_IN
+//! - \b GPIO_DIR_MODE_OUT
+//! - \b GPIO_DIR_MODE_HW
+//!
+//! where \b GPIO_DIR_MODE_IN specifies that the pin will be programmed as
+//! a software controlled input, \b GPIO_DIR_MODE_OUT specifies that the pin
+//! will be programmed as a software controlled output, and
+//! \b GPIO_DIR_MODE_HW specifies that the pin will be placed under
+//! hardware control.
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIODirModeSet(unsigned long ulPort, unsigned char ucPins,
+               unsigned long ulPinIO)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+    ASSERT((ulPinIO == GPIO_DIR_MODE_IN) || (ulPinIO == GPIO_DIR_MODE_OUT) ||
+           (ulPinIO == GPIO_DIR_MODE_HW));
+
+    //
+    // Set the pin direction and mode.
+    //
+    HWREG(ulPort + GPIO_O_DIR) = ((ulPinIO &amp; 1) ?
+                                  (HWREG(ulPort + GPIO_O_DIR) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_DIR) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_AFSEL) = ((ulPinIO &amp; 2) ?
+                                    (HWREG(ulPort + GPIO_O_AFSEL) | ucPins) :
+                                    (HWREG(ulPort + GPIO_O_AFSEL) &amp;
+                                     ~(ucPins)));
+}
+
+//*****************************************************************************
+//
+//! Gets the direction and mode of a pin.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPin is the pin number.
+//!
+//! This function gets the direction and control mode for a specified pin on
+//! the selected GPIO port.  The pin can be configured as either an input or
+//! output under software control, or it can be under hardware control.  The
+//! type of control and direction are returned as an enumerated data type.
+//!
+//! \return Returns one of the enumerated data types described for
+//! GPIODirModeSet().
+//
+//*****************************************************************************
+unsigned long
+GPIODirModeGet(unsigned long ulPort, unsigned char ucPin)
+{
+    unsigned long ulDir, ulAFSEL;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+    ASSERT(ucPin &lt; 8);
+
+    //
+    // Convert from a pin number to a bit position.
+    //
+    ucPin = 1 &lt;&lt; ucPin;
+
+    //
+    // Return the pin direction and mode.
+    //
+    ulDir = HWREG(ulPort + GPIO_O_DIR);
+    ulAFSEL = HWREG(ulPort + GPIO_O_AFSEL);
+    return(((ulDir &amp; ucPin) ? 1 : 0) | ((ulAFSEL &amp; ucPin) ? 2 : 0));
+}
+
+//*****************************************************************************
+//
+//! Sets the interrupt type for the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//! \param ulIntType specifies the type of interrupt trigger mechanism.
+//!
+//! This function sets up the various interrupt trigger mechanisms for the
+//! specified pin(s) on the selected GPIO port.
+//!
+//! The parameter \e ulIntType is an enumerated data type that can be one of
+//! the following values:
+//!
+//! - \b GPIO_FALLING_EDGE
+//! - \b GPIO_RISING_EDGE
+//! - \b GPIO_BOTH_EDGES
+//! - \b GPIO_LOW_LEVEL
+//! - \b GPIO_HIGH_LEVEL
+//!
+//! where the different values describe the interrupt detection mechanism
+//! (edge or level) and the particular triggering event (falling, rising,
+//! or both edges for edge detect, low or high for level detect).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note In order to avoid any spurious interrupts, the user must
+//! ensure that the GPIO inputs remain stable for the duration of
+//! this function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOIntTypeSet(unsigned long ulPort, unsigned char ucPins,
+               unsigned long ulIntType)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+    ASSERT((ulIntType == GPIO_FALLING_EDGE) ||
+           (ulIntType == GPIO_RISING_EDGE) || (ulIntType == GPIO_BOTH_EDGES) ||
+           (ulIntType == GPIO_LOW_LEVEL) || (ulIntType == GPIO_HIGH_LEVEL));
+
+    //
+    // Set the pin interrupt type.
+    //
+    HWREG(ulPort + GPIO_O_IBE) = ((ulIntType &amp; 1) ?
+                                  (HWREG(ulPort + GPIO_O_IBE) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_IBE) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_IS) = ((ulIntType &amp; 2) ?
+                                 (HWREG(ulPort + GPIO_O_IS) | ucPins) :
+                                 (HWREG(ulPort + GPIO_O_IS) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_IEV) = ((ulIntType &amp; 4) ?
+                                  (HWREG(ulPort + GPIO_O_IEV) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_IEV) &amp; ~(ucPins)));
+}
+
+//*****************************************************************************
+//
+//! Gets the interrupt type for a pin.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPin is the pin number.
+//!
+//! This function gets the interrupt type for a specified pin on the selected
+//! GPIO port.  The pin can be configured as a falling edge, rising edge, or
+//! both edge detected interrupt, or it can be configured as a low level or
+//! high level detected interrupt.  The type of interrupt detection mechanism
+//! is returned as an enumerated data type.
+//!
+//! \return Returns one of the enumerated data types described for
+//! GPIOIntTypeSet().
+//
+//*****************************************************************************
+unsigned long
+GPIOIntTypeGet(unsigned long ulPort, unsigned char ucPin)
+{
+    unsigned long ulIBE, ulIS, ulIEV;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+    ASSERT(ucPin &lt; 8);
+
+    //
+    // Convert from a pin number to a bit position.
+    //
+    ucPin = 1 &lt;&lt; ucPin;
+
+    //
+    // Return the pin interrupt type.
+    //
+    ulIBE = HWREG(ulPort + GPIO_O_IBE);
+    ulIS = HWREG(ulPort + GPIO_O_IS);
+    ulIEV = HWREG(ulPort + GPIO_O_IEV);
+    return(((ulIBE &amp; ucPin) ? 1 : 0) | ((ulIS &amp; ucPin) ? 2 : 0) |
+           ((ulIEV &amp; ucPin) ? 4 : 0));
+}
+
+//*****************************************************************************
+//
+//! Sets the pad configuration for the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//! \param ulStrength specifies the output drive strength.
+//! \param ulPinType specifies the pin type.
+//!
+//! This function sets the drive strength and type for the specified pin(s)
+//! on the selected GPIO port.  For pin(s) configured as input ports, the
+//! pad is configured as requested, but the only real effect on the input
+//! is the configuration of the pull-up or pull-down termination.
+//!
+//! The parameter \e ulStrength can be one of the following values:
+//!
+//! - \b GPIO_STRENGTH_2MA
+//! - \b GPIO_STRENGTH_4MA
+//! - \b GPIO_STRENGTH_8MA
+//! - \b GPIO_STRENGTH_8MA_SC
+//!
+//! where \b GPIO_STRENGTH_xMA specifies either 2, 4, or 8 mA output drive
+//! strength, and \b GPIO_OUT_STRENGTH_8MA_SC specifies 8 mA output drive with
+//! slew control.
+//!
+//! The parameter \e ulPinType can be one of the following values:
+//!
+//! - \b GPIO_PIN_TYPE_STD
+//! - \b GPIO_PIN_TYPE_STD_WPU
+//! - \b GPIO_PIN_TYPE_STD_WPD
+//! - \b GPIO_PIN_TYPE_OD
+//! - \b GPIO_PIN_TYPE_OD_WPU
+//! - \b GPIO_PIN_TYPE_OD_WPD
+//! - \b GPIO_PIN_TYPE_ANALOG
+//!
+//! where \b GPIO_PIN_TYPE_STD* specifies a push-pull pin, \b GPIO_PIN_TYPE_OD*
+//! specifies an open-drain pin, \b *_WPU specifies a weak pull-up, \b *_WPD
+//! specifies a weak pull-down, and \b GPIO_PIN_TYPE_ANALOG specifies an
+//! analog input (for the comparators).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPadConfigSet(unsigned long ulPort, unsigned char ucPins,
+                 unsigned long ulStrength, unsigned long ulPinType)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+    ASSERT((ulStrength == GPIO_STRENGTH_2MA) ||
+           (ulStrength == GPIO_STRENGTH_4MA) ||
+           (ulStrength == GPIO_STRENGTH_8MA) ||
+           (ulStrength == GPIO_STRENGTH_8MA_SC));
+    ASSERT((ulPinType == GPIO_PIN_TYPE_STD) ||
+           (ulPinType == GPIO_PIN_TYPE_STD_WPU) ||
+           (ulPinType == GPIO_PIN_TYPE_STD_WPD) ||
+           (ulPinType == GPIO_PIN_TYPE_OD) ||
+           (ulPinType == GPIO_PIN_TYPE_OD_WPU) ||
+           (ulPinType == GPIO_PIN_TYPE_OD_WPD) ||
+           (ulPinType == GPIO_PIN_TYPE_ANALOG))
+
+    //
+    // Set the output drive strength.
+    //
+    HWREG(ulPort + GPIO_O_DR2R) = ((ulStrength &amp; 1) ?
+                                   (HWREG(ulPort + GPIO_O_DR2R) | ucPins) :
+                                   (HWREG(ulPort + GPIO_O_DR2R) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_DR4R) = ((ulStrength &amp; 2) ?
+                                   (HWREG(ulPort + GPIO_O_DR4R) | ucPins) :
+                                   (HWREG(ulPort + GPIO_O_DR4R) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_DR8R) = ((ulStrength &amp; 4) ?
+                                   (HWREG(ulPort + GPIO_O_DR8R) | ucPins) :
+                                   (HWREG(ulPort + GPIO_O_DR8R) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_SLR) = ((ulStrength &amp; 8) ?
+                                  (HWREG(ulPort + GPIO_O_SLR) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_SLR) &amp; ~(ucPins)));
+
+    //
+    // Set the pin type.
+    //
+    HWREG(ulPort + GPIO_O_ODR) = ((ulPinType &amp; 1) ?
+                                  (HWREG(ulPort + GPIO_O_ODR) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_ODR) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_PUR) = ((ulPinType &amp; 2) ?
+                                  (HWREG(ulPort + GPIO_O_PUR) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_PUR) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_PDR) = ((ulPinType &amp; 4) ?
+                                  (HWREG(ulPort + GPIO_O_PDR) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_PDR) &amp; ~(ucPins)));
+    HWREG(ulPort + GPIO_O_DEN) = ((ulPinType &amp; 8) ?
+                                  (HWREG(ulPort + GPIO_O_DEN) | ucPins) :
+                                  (HWREG(ulPort + GPIO_O_DEN) &amp; ~(ucPins)));
+
+    //
+    // Set the analog mode select register.  This register only appears in
+    // DustDevil-class (and later) devices, but is a harmless write on
+    // Sandstorm- and Fury-class devices.
+    //
+    HWREG(ulPort + GPIO_O_AMSEL) =
+        ((ulPinType == GPIO_PIN_TYPE_ANALOG) ?
+         (HWREG(ulPort + GPIO_O_AMSEL) | ucPins) :
+         (HWREG(ulPort + GPIO_O_AMSEL) &amp; ~(ucPins)));
+}
+
+//*****************************************************************************
+//
+//! Gets the pad configuration for a pin.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPin is the pin number.
+//! \param pulStrength is a pointer to storage for the output drive strength.
+//! \param pulPinType is a pointer to storage for the output drive type.
+//!
+//! This function gets the pad configuration for a specified pin on the
+//! selected GPIO port.  The values returned in \e pulStrength and
+//! \e pulPinType correspond to the values used in GPIOPadConfigSet().  This
+//! function also works for pin(s) configured as input pin(s); however, the
+//! only meaningful data returned is whether the pin is terminated with a
+//! pull-up or down resistor.
+//!
+//! \return None
+//
+//*****************************************************************************
+void
+GPIOPadConfigGet(unsigned long ulPort, unsigned char ucPin,
+                 unsigned long *pulStrength, unsigned long *pulPinType)
+{
+    unsigned long ulTemp1, ulTemp2, ulTemp3, ulTemp4;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+    ASSERT(ucPin &lt; 8);
+
+    //
+    // Convert from a pin number to a bit position.
+    //
+    ucPin = (1 &lt;&lt; ucPin);
+
+    //
+    // Get the drive strength for this pin.
+    //
+    ulTemp1 = HWREG(ulPort + GPIO_O_DR2R);
+    ulTemp2 = HWREG(ulPort + GPIO_O_DR4R);
+    ulTemp3 = HWREG(ulPort + GPIO_O_DR8R);
+    ulTemp4 = HWREG(ulPort + GPIO_O_SLR);
+    *pulStrength = (((ulTemp1 &amp; ucPin) ? 1 : 0) | ((ulTemp2 &amp; ucPin) ? 2 : 0) |
+                    ((ulTemp3 &amp; ucPin) ? 4 : 0) | ((ulTemp4 &amp; ucPin) ? 8 : 0));
+
+    //
+    // Get the pin type.
+    //
+    ulTemp1 = HWREG(ulPort + GPIO_O_ODR);
+    ulTemp2 = HWREG(ulPort + GPIO_O_PUR);
+    ulTemp3 = HWREG(ulPort + GPIO_O_PDR);
+    ulTemp4 = HWREG(ulPort + GPIO_O_DEN);
+    *pulPinType = (((ulTemp1 &amp; ucPin) ? 1 : 0) | ((ulTemp2 &amp; ucPin) ? 2 : 0) |
+                   ((ulTemp3 &amp; ucPin) ? 4 : 0) | ((ulTemp4 &amp; ucPin) ? 8 : 0));
+}
+
+//*****************************************************************************
+//
+//! Enables interrupts for the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! Unmasks the interrupt for the specified pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinIntEnable(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Enable the interrupts.
+    //
+    HWREG(ulPort + GPIO_O_IM) |= ucPins;
+}
+
+//*****************************************************************************
+//
+//! Disables interrupts for the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! Masks the interrupt for the specified pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinIntDisable(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Disable the interrupts.
+    //
+    HWREG(ulPort + GPIO_O_IM) &amp;= ~(ucPins);
+}
+
+//*****************************************************************************
+//
+//! Gets interrupt status for the specified GPIO port.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param bMasked specifies whether masked or raw interrupt status is
+//! returned.
+//!
+//! If \e bMasked is set as \b true, then the masked interrupt status is
+//! returned; otherwise, the raw interrupt status will be returned.
+//!
+//! \return Returns a bit-packed byte, where each bit that is set identifies
+//! an active masked or raw interrupt, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//! Bits 31:8 should be ignored.
+//
+//*****************************************************************************
+long
+GPIOPinIntStatus(unsigned long ulPort, tBoolean bMasked)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Return the interrupt status.
+    //
+    if(bMasked)
+    {
+        return(HWREG(ulPort + GPIO_O_MIS));
+    }
+    else
+    {
+        return(HWREG(ulPort + GPIO_O_RIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears the interrupt for the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! Clears the interrupt for the specified pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinIntClear(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Clear the interrupts.
+    //
+    HWREG(ulPort + GPIO_O_ICR) = ucPins;
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for a GPIO port.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param pfnIntHandler is a pointer to the GPIO port interrupt handling
+//! function.
+//!
+//! This function will ensure that the interrupt handler specified by
+//! \e pfnIntHandler is called when an interrupt is detected from the selected
+//! GPIO port.  This function will also enable the corresponding GPIO interrupt
+//! in the interrupt controller; individual pin interrupts and interrupt
+//! sources must be enabled with GPIOPinIntEnable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPortIntRegister(unsigned long ulPort, void (*pfnIntHandler)(void))
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Get the interrupt number associated with the specified GPIO.
+    //
+    ulPort = GPIOGetIntNumber(ulPort);
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(ulPort, pfnIntHandler);
+
+    //
+    // Enable the GPIO interrupt.
+    //
+    IntEnable(ulPort);
+}
+
+//*****************************************************************************
+//
+//! Removes an interrupt handler for a GPIO port.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//!
+//! This function will unregister the interrupt handler for the specified
+//! GPIO port.  This function will also disable the corresponding
+//! GPIO port interrupt in the interrupt controller; individual GPIO interrupts
+//! and interrupt sources must be disabled with GPIOPinIntDisable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPortIntUnregister(unsigned long ulPort)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Get the interrupt number associated with the specified GPIO.
+    //
+    ulPort = GPIOGetIntNumber(ulPort);
+
+    //
+    // Disable the GPIO interrupt.
+    //
+    IntDisable(ulPort);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(ulPort);
+}
+
+//*****************************************************************************
+//
+//! Reads the values present of the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The values at the specified pin(s) are read, as specified by \e ucPins.
+//! Values are returned for both input and output pin(s), and the value
+//! for pin(s) that are not specified by \e ucPins are set to 0.
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return Returns a bit-packed byte providing the state of the specified
+//! pin, where bit 0 of the byte represents GPIO port pin 0, bit 1 represents
+//! GPIO port pin 1, and so on.  Any bit that is not specified by \e ucPins
+//! is returned as a 0.  Bits 31:8 should be ignored.
+//
+//*****************************************************************************
+long
+GPIOPinRead(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Return the pin value(s).
+    //
+    return(HWREG(ulPort + (GPIO_O_DATA + (ucPins &lt;&lt; 2))));
+}
+
+//*****************************************************************************
+//
+//! Writes a value to the specified pin(s).
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//! \param ucVal is the value to write to the pin(s).
+//!
+//! Writes the corresponding bit values to the output pin(s) specified by
+//! \e ucPins.  Writing to a pin configured as an input pin has no effect.
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinWrite(unsigned long ulPort, unsigned char ucPins, unsigned char ucVal)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Write the pins.
+    //
+    HWREG(ulPort + (GPIO_O_DATA + (ucPins &lt;&lt; 2))) = ucVal;
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use as analog-to-digital converter inputs.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The analog-to-digital converter input pins must be properly configured
+//! to function correctly on DustDevil-class devices.  This function provides
+//! the proper configuration for those pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into an ADC input; it only
+//! configures an ADC input pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeADC(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be inputs.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_IN);
+
+    //
+    // Set the pad(s) for analog operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_ANALOG);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use as a CAN device.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The CAN pins must be properly configured for the CAN peripherals to
+//! function correctly.  This function provides a typical configuration for
+//! those pin(s); other configurations may work as well depending upon the
+//! board setup (for example, using the on-chip pull-ups).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a CAN pin; it only
+//! configures a CAN pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeCAN(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be inputs.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use as an analog comparator input.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The analog comparator input pins must be properly configured for the analog
+//! comparator to function correctly.  This function provides the proper
+//! configuration for those pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into an analog comparator input;
+//! it only configures an analog comparator pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeComparator(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be inputs.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_IN);
+
+    //
+    // Set the pad(s) for analog operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_ANALOG);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use as GPIO inputs.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The GPIO pins must be properly configured in order to function correctly as
+//! GPIO inputs; this is especially true of Fury-class devices where the
+//! digital input enable is turned off by default.  This function provides the
+//! proper configuration for those pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeGPIOInput(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be inputs.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_IN);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use as GPIO outputs.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The GPIO pins must be properly configured in order to function correctly as
+//! GPIO outputs; this is especially true of Fury-class devices where the
+//! digital input enable is turned off by default.  This function provides the
+//! proper configuration for those pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeGPIOOutput(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be outputs.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_OUT);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use as GPIO open drain outputs.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The GPIO pins must be properly configured in order to function correctly as
+//! GPIO outputs; this is especially true of Fury-class devices where the
+//! digital input enable is turned off by default.  This function provides the
+//! proper configuration for those pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeGPIOOutputOD(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be outputs.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_OUT);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_OD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the I2C peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The I2C pins must be properly configured for the I2C peripheral to function
+//! correctly.  This function provides the proper configuration for those
+//! pin(s).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into an I2C pin; it only
+//! configures an I2C pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeI2C(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for open-drain operation with a weak pull-up.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_OD_WPU);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the PWM peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The PWM pins must be properly configured for the PWM peripheral to function
+//! correctly.  This function provides a typical configuration for those
+//! pin(s); other configurations may work as well depending upon the board
+//! setup (for example, using the on-chip pull-ups).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a PWM pin; it only
+//! configures a PWM pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypePWM(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the QEI peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The QEI pins must be properly configured for the QEI peripheral to function
+//! correctly.  This function provides a typical configuration for those
+//! pin(s); other configurations may work as well depending upon the board
+//! setup (for example, not using the on-chip pull-ups).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a QEI pin; it only
+//! configures a QEI pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeQEI(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation with a weak pull-up.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the SSI peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The SSI pins must be properly configured for the SSI peripheral to function
+//! correctly.  This function provides a typical configuration for those
+//! pin(s); other configurations may work as well depending upon the board
+//! setup (for example, using the on-chip pull-ups).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a SSI pin; it only
+//! configures a SSI pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeSSI(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the Timer peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The CCP pins must be properly configured for the timer peripheral to
+//! function correctly.  This function provides a typical configuration for
+//! those pin(s); other configurations may work as well depending upon the
+//! board setup (for example, using the on-chip pull-ups).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a timer pin; it only
+//! configures a timer pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeTimer(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the UART peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! The UART pins must be properly configured for the UART peripheral to
+//! function correctly.  This function provides a typical configuration for
+//! those pin(s); other configurations may work as well depending upon the
+//! board setup (for example, using the on-chip pull-ups).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a UART pin; it only
+//! configures a UART pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeUART(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the USB peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! Some USB digital pins must be properly configured for the USB peripheral to
+//! function correctly.  This function provides a typical configuration for
+//! the digital USB pin(s); other configurations may work as well depending
+//! upon the board setup (for example, using the on-chip pull-ups).
+//!
+//! This function should only be used with EPEN and PFAULT pins as all other
+//! USB pins are analog in nature or are not used in devices without OTG
+//! functionality.
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a USB pin; it only
+//! configures a USB pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeUSBDigital(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the USB peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! Some USB analog pins must be properly configured for the USB peripheral to
+//! function correctly.  This function provides the proper configuration for
+//! any USB pin(s).  This can also be used to configure the EPEN and PFAULT pins
+//! so that they are no longer used by the USB controller.
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a USB pin; it only
+//! configures a USB pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeUSBAnalog(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be inputs.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_IN);
+
+    //
+    // Set the pad(s) for analog operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_ANALOG);
+}
+
+//*****************************************************************************
+//
+//! Configures pin(s) for use by the I2S peripheral.
+//!
+//! \param ulPort is the base address of the GPIO port.
+//! \param ucPins is the bit-packed representation of the pin(s).
+//!
+//! Some I2S pins must be properly configured for the I2S peripheral to
+//! function correctly.  This function provides a typical configuration for
+//! the digital I2S pin(s); other configurations may work as well depending
+//! upon the board setup (for example, using the on-chip pull-ups).
+//!
+//! The pin(s) are specified using a bit-packed byte, where each bit that is
+//! set identifies the pin to be accessed, and where bit 0 of the byte
+//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.
+//!
+//! \note This cannot be used to turn any pin into a I2S pin; it only
+//! configures a I2S pin for proper operation.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinTypeI2S(unsigned long ulPort, unsigned char ucPins)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(GPIOBaseValid(ulPort));
+
+    //
+    // Make the pin(s) be peripheral controlled.
+    //
+    GPIODirModeSet(ulPort, ucPins, GPIO_DIR_MODE_HW);
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    GPIOPadConfigSet(ulPort, ucPins, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD);
+}
+
+//*****************************************************************************
+//
+//! Configures the alternate function of a GPIO pin.
+//!
+//! \param ulPinConfig is the pin configuration value, specified as one of the
+//! \b GPIO_P??_??? values.
+//!
+//! This function configures the pin mux that selects the peripheral function
+//! associated with a particular GPIO pin.  Only one peripheral function at a
+//! time can be associated with a GPIO pin, and each peripheral function should
+//! only be associated with a single GPIO pin at a time (despite the fact that
+//! many of them can be associated with more than one GPIO pin).
+//!
+//! \note This function is only valid on Tempest-class devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOPinConfigure(unsigned long ulPinConfig)
+{
+    unsigned long ulBase, ulShift;
+
+    //
+    // Check the argument.
+    //
+    ASSERT(((ulPinConfig &gt;&gt; 16) &amp; 0xff) &lt; 9);
+    ASSERT(((ulPinConfig &gt;&gt; 8) &amp; 0xe3) == 0);
+
+    //
+    // Extract the base address index from the input value.
+    //
+    ulBase = (ulPinConfig &gt;&gt; 16) &amp; 0xff;
+
+    //
+    // Get the base address of the GPIO module, selecting either the APB or the
+    // AHB aperture as appropriate.
+    //
+    if(HWREG(SYSCTL_GPIOHSCTL) &amp; (1 &lt;&lt; ulBase))
+    {
+        ulBase = g_pulGPIOBaseAddrs[(ulBase &lt;&lt; 1) + 1];
+    }
+    else
+    {
+        ulBase = g_pulGPIOBaseAddrs[ulBase &lt;&lt; 1];
+    }
+
+    //
+    // Extract the shift from the input value.
+    //
+    ulShift = (ulPinConfig &gt;&gt; 8) &amp; 0xff;
+
+    //
+    // Write the requested pin muxing value for this GPIO pin.
+    //
+    HWREG(ulBase + GPIO_O_PCTL) = ((HWREG(ulBase + GPIO_O_PCTL) &amp;
+                                    ~(0xf &lt;&lt; ulShift)) |
+                                   ((ulPinConfig &amp; 0xf) &lt;&lt; ulShift));
+
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/gpio.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/gpio.h
===================================================================
--- trunk/src/platform/lm3s/gpio.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/gpio.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,155 +1,768 @@
-//*****************************************************************************
-//
-// gpio.h - Defines and Macros for GPIO API.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __GPIO_H__
-#define __GPIO_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// The following values define the bit field for the ucPins argument to several
-// of the APIs.
-//
-//*****************************************************************************
-#define GPIO_PIN_0              0x00000001  // GPIO pin 0
-#define GPIO_PIN_1              0x00000002  // GPIO pin 1
-#define GPIO_PIN_2              0x00000004  // GPIO pin 2
-#define GPIO_PIN_3              0x00000008  // GPIO pin 3
-#define GPIO_PIN_4              0x00000010  // GPIO pin 4
-#define GPIO_PIN_5              0x00000020  // GPIO pin 5
-#define GPIO_PIN_6              0x00000040  // GPIO pin 6
-#define GPIO_PIN_7              0x00000080  // GPIO pin 7
-
-//*****************************************************************************
-//
-// Values that can be passed to GPIODirModeSet as the ulPinIO parameter, and
-// returned from GPIODirModeGet.
-//
-//*****************************************************************************
-#define GPIO_DIR_MODE_IN        0x00000000  // Pin is a GPIO input
-#define GPIO_DIR_MODE_OUT       0x00000001  // Pin is a GPIO output
-#define GPIO_DIR_MODE_HW        0x00000002  // Pin is a peripheral function
-
-//*****************************************************************************
-//
-// Values that can be passed to GPIOIntTypeSet as the ulIntType parameter, and
-// returned from GPIOIntTypeGet.
-//
-//*****************************************************************************
-#define GPIO_FALLING_EDGE       0x00000000  // Interrupt on falling edge
-#define GPIO_RISING_EDGE        0x00000004  // Interrupt on rising edge
-#define GPIO_BOTH_EDGES         0x00000001  // Interrupt on both edges
-#define GPIO_LOW_LEVEL          0x00000002  // Interrupt on low level
-#define GPIO_HIGH_LEVEL         0x00000007  // Interrupt on high level
-
-//*****************************************************************************
-//
-// Values that can be passed to GPIOPadConfigSet as the ulStrength parameter,
-// and returned by GPIOPadConfigGet in the *pulStrength parameter.
-//
-//*****************************************************************************
-#define GPIO_STRENGTH_2MA       0x00000001  // 2mA drive strength
-#define GPIO_STRENGTH_4MA       0x00000002  // 4mA drive strength
-#define GPIO_STRENGTH_8MA       0x00000004  // 8mA drive strength
-#define GPIO_STRENGTH_8MA_SC    0x0000000C  // 8mA drive with slew rate control
-
-//*****************************************************************************
-//
-// Values that can be passed to GPIOPadConfigSet as the ulPadType parameter,
-// and returned by GPIOPadConfigGet in the *pulPadType parameter.
-//
-//*****************************************************************************
-#define GPIO_PIN_TYPE_STD       0x00000008  // Push-pull
-#define GPIO_PIN_TYPE_STD_WPU   0x0000000A  // Push-pull with weak pull-up
-#define GPIO_PIN_TYPE_STD_WPD   0x0000000C  // Push-pull with weak pull-down
-#define GPIO_PIN_TYPE_OD        0x00000009  // Open-drain
-#define GPIO_PIN_TYPE_OD_WPU    0x0000000B  // Open-drain with weak pull-up
-#define GPIO_PIN_TYPE_OD_WPD    0x0000000D  // Open-drain with weak pull-down
-#define GPIO_PIN_TYPE_ANALOG    0x00000000  // Analog comparator
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern void GPIODirModeSet(unsigned long ulPort, unsigned char ucPins,
-                           unsigned long ulPinIO);
-extern unsigned long GPIODirModeGet(unsigned long ulPort, unsigned char ucPin);
-extern void GPIOIntTypeSet(unsigned long ulPort, unsigned char ucPins,
-                           unsigned long ulIntType);
-extern unsigned long GPIOIntTypeGet(unsigned long ulPort, unsigned char ucPin);
-extern void GPIOPadConfigSet(unsigned long ulPort, unsigned char ucPins,
-                             unsigned long ulStrength,
-                             unsigned long ulPadType);
-extern void GPIOPadConfigGet(unsigned long ulPort, unsigned char ucPin,
-                             unsigned long *pulStrength,
-                             unsigned long *pulPadType);
-extern void GPIOPinIntEnable(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinIntDisable(unsigned long ulPort, unsigned char ucPins);
-extern long GPIOPinIntStatus(unsigned long ulPort, tBoolean bMasked);
-extern void GPIOPinIntClear(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPortIntRegister(unsigned long ulPort,
-                                void (*pfnIntHandler)(void));
-extern void GPIOPortIntUnregister(unsigned long ulPort);
-extern long GPIOPinRead(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinWrite(unsigned long ulPort, unsigned char ucPins,
-                         unsigned char ucVal);
-extern void GPIOPinTypeADC(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeCAN(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeComparator(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeGPIOInput(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeGPIOOutput(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeGPIOOutputOD(unsigned long ulPort,
-                                    unsigned char ucPins);
-extern void GPIOPinTypeI2C(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypePWM(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeQEI(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeSSI(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeTimer(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeUART(unsigned long ulPort, unsigned char ucPins);
-extern void GPIOPinTypeUSBDigital(unsigned long ulPort, unsigned char ucPins);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif //  __GPIO_H__
+//*****************************************************************************
+//
+// gpio.h - Defines and Macros for GPIO API.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __GPIO_H__
+#define __GPIO_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// The following values define the bit field for the ucPins argument to several
+// of the APIs.
+//
+//*****************************************************************************
+#define GPIO_PIN_0              0x00000001  // GPIO pin 0
+#define GPIO_PIN_1              0x00000002  // GPIO pin 1
+#define GPIO_PIN_2              0x00000004  // GPIO pin 2
+#define GPIO_PIN_3              0x00000008  // GPIO pin 3
+#define GPIO_PIN_4              0x00000010  // GPIO pin 4
+#define GPIO_PIN_5              0x00000020  // GPIO pin 5
+#define GPIO_PIN_6              0x00000040  // GPIO pin 6
+#define GPIO_PIN_7              0x00000080  // GPIO pin 7
+
+//*****************************************************************************
+//
+// Values that can be passed to GPIODirModeSet as the ulPinIO parameter, and
+// returned from GPIODirModeGet.
+//
+//*****************************************************************************
+#define GPIO_DIR_MODE_IN        0x00000000  // Pin is a GPIO input
+#define GPIO_DIR_MODE_OUT       0x00000001  // Pin is a GPIO output
+#define GPIO_DIR_MODE_HW        0x00000002  // Pin is a peripheral function
+
+//*****************************************************************************
+//
+// Values that can be passed to GPIOIntTypeSet as the ulIntType parameter, and
+// returned from GPIOIntTypeGet.
+//
+//*****************************************************************************
+#define GPIO_FALLING_EDGE       0x00000000  // Interrupt on falling edge
+#define GPIO_RISING_EDGE        0x00000004  // Interrupt on rising edge
+#define GPIO_BOTH_EDGES         0x00000001  // Interrupt on both edges
+#define GPIO_LOW_LEVEL          0x00000002  // Interrupt on low level
+#define GPIO_HIGH_LEVEL         0x00000007  // Interrupt on high level
+
+//*****************************************************************************
+//
+// Values that can be passed to GPIOPadConfigSet as the ulStrength parameter,
+// and returned by GPIOPadConfigGet in the *pulStrength parameter.
+//
+//*****************************************************************************
+#define GPIO_STRENGTH_2MA       0x00000001  // 2mA drive strength
+#define GPIO_STRENGTH_4MA       0x00000002  // 4mA drive strength
+#define GPIO_STRENGTH_8MA       0x00000004  // 8mA drive strength
+#define GPIO_STRENGTH_8MA_SC    0x0000000C  // 8mA drive with slew rate control
+
+//*****************************************************************************
+//
+// Values that can be passed to GPIOPadConfigSet as the ulPadType parameter,
+// and returned by GPIOPadConfigGet in the *pulPadType parameter.
+//
+//*****************************************************************************
+#define GPIO_PIN_TYPE_STD       0x00000008  // Push-pull
+#define GPIO_PIN_TYPE_STD_WPU   0x0000000A  // Push-pull with weak pull-up
+#define GPIO_PIN_TYPE_STD_WPD   0x0000000C  // Push-pull with weak pull-down
+#define GPIO_PIN_TYPE_OD        0x00000009  // Open-drain
+#define GPIO_PIN_TYPE_OD_WPU    0x0000000B  // Open-drain with weak pull-up
+#define GPIO_PIN_TYPE_OD_WPD    0x0000000D  // Open-drain with weak pull-down
+#define GPIO_PIN_TYPE_ANALOG    0x00000000  // Analog comparator
+
+//*****************************************************************************
+//
+// Values that can be passed to GPIOPinConfigure as the ulPinConfig parameter.
+//
+//*****************************************************************************
+//
+// GPIO pin A0
+//
+#define GPIO_PA0_U0RX           0x00000001
+#define GPIO_PA0_I2C1SCL        0x00000008
+#define GPIO_PA0_U1RX           0x00000009
+
+//
+// GPIO pin A1
+//
+#define GPIO_PA1_U0TX           0x00000401
+#define GPIO_PA1_I2C1SDA        0x00000408
+#define GPIO_PA1_U1TX           0x00000409
+
+//
+// GPIO pin A2
+//
+#define GPIO_PA2_SSI0CLK        0x00000801
+#define GPIO_PA2_PWM4           0x00000804
+#define GPIO_PA2_I2S0RXSD       0x00000809
+
+//
+// GPIO pin A3
+//
+#define GPIO_PA3_SSI0FSS        0x00000c01
+#define GPIO_PA3_PWM5           0x00000c04
+#define GPIO_PA3_I2S0RXMCLK     0x00000c09
+
+//
+// GPIO pin A4
+//
+#define GPIO_PA4_SSI0RX         0x00001001
+#define GPIO_PA4_PWM6           0x00001004
+#define GPIO_PA4_CAN0RX         0x00001005
+#define GPIO_PA4_I2S0TXSCK      0x00001009
+
+//
+// GPIO pin A5
+//
+#define GPIO_PA5_SSI0TX         0x00001401
+#define GPIO_PA5_PWM7           0x00001404
+#define GPIO_PA5_CAN0TX         0x00001405
+#define GPIO_PA5_I2S0TXWS       0x00001409
+
+//
+// GPIO pin A6
+//
+#define GPIO_PA6_I2C1SCL        0x00001801
+#define GPIO_PA6_CCP1           0x00001802
+#define GPIO_PA6_PWM0           0x00001804
+#define GPIO_PA6_PWM4           0x00001805
+#define GPIO_PA6_CAN0RX         0x00001806
+#define GPIO_PA6_USB0EPEN       0x00001808
+#define GPIO_PA6_U1CTS          0x00001809
+
+//
+// GPIO pin A7
+//
+#define GPIO_PA7_I2C1SDA        0x00001c01
+#define GPIO_PA7_CCP4           0x00001c02
+#define GPIO_PA7_PWM1           0x00001c04
+#define GPIO_PA7_PWM5           0x00001c05
+#define GPIO_PA7_CAN0TX         0x00001c06
+#define GPIO_PA7_CCP3           0x00001c07
+#define GPIO_PA7_USB0PFLT       0x00001c08
+#define GPIO_PA7_U1DCD          0x00001c09
+
+//
+// GPIO pin B0
+//
+#define GPIO_PB0_CCP0           0x00010001
+#define GPIO_PB0_PWM2           0x00010002
+#define GPIO_PB0_U1RX           0x00010005
+
+//
+// GPIO pin B1
+//
+#define GPIO_PB1_CCP2           0x00010401
+#define GPIO_PB1_PWM3           0x00010402
+#define GPIO_PB1_CCP1           0x00010404
+#define GPIO_PB1_U1TX           0x00010405
+
+//
+// GPIO pin B2
+//
+#define GPIO_PB2_I2C0SCL        0x00010801
+#define GPIO_PB2_IDX0           0x00010802
+#define GPIO_PB2_CCP3           0x00010804
+#define GPIO_PB2_CCP0           0x00010805
+#define GPIO_PB2_USB0EPEN       0x00010808
+
+//
+// GPIO pin B3
+//
+#define GPIO_PB3_I2C0SDA        0x00010c01
+#define GPIO_PB3_FAULT0         0x00010c02
+#define GPIO_PB3_FAULT3         0x00010c04
+#define GPIO_PB3_USB0PFLT       0x00010c08
+
+//
+// GPIO pin B4
+//
+#define GPIO_PB4_U2RX           0x00011004
+#define GPIO_PB4_CAN0RX         0x00011005
+#define GPIO_PB4_IDX0           0x00011006
+#define GPIO_PB4_U1RX           0x00011007
+#define GPIO_PB4_EPI0S23        0x00011008
+
+//
+// GPIO pin B5
+//
+#define GPIO_PB5_C0O            0x00011401
+#define GPIO_PB5_CCP5           0x00011402
+#define GPIO_PB5_CCP6           0x00011403
+#define GPIO_PB5_CCP0           0x00011404
+#define GPIO_PB5_CAN0TX         0x00011405
+#define GPIO_PB5_CCP2           0x00011406
+#define GPIO_PB5_U1TX           0x00011407
+#define GPIO_PB5_EPI0S22        0x00011408
+
+//
+// GPIO pin B6
+//
+#define GPIO_PB6_CCP1           0x00011801
+#define GPIO_PB6_CCP7           0x00011802
+#define GPIO_PB6_C0O            0x00011803
+#define GPIO_PB6_FAULT1         0x00011804
+#define GPIO_PB6_IDX0           0x00011805
+#define GPIO_PB6_CCP5           0x00011806
+#define GPIO_PB6_I2S0TXSCK      0x00011809
+
+//
+// GPIO pin B7
+//
+#define GPIO_PB7_NMI            0x00011c04
+
+//
+// GPIO pin C0
+//
+#define GPIO_PC0_TCK            0x00020003
+
+//
+// GPIO pin C1
+//
+#define GPIO_PC1_TMS            0x00020403
+
+//
+// GPIO pin C2
+//
+#define GPIO_PC2_TDI            0x00020803
+
+//
+// GPIO pin C3
+//
+#define GPIO_PC3_TDO            0x00020c03
+
+//
+// GPIO pin C4
+//
+#define GPIO_PC4_CCP5           0x00021001
+#define GPIO_PC4_PHA0           0x00021002
+#define GPIO_PC4_PWM6           0x00021004
+#define GPIO_PC4_CCP2           0x00021005
+#define GPIO_PC4_CCP4           0x00021006
+#define GPIO_PC4_EPI0S2         0x00021008
+#define GPIO_PC4_CCP1           0x00021009
+
+//
+// GPIO pin C5
+//
+#define GPIO_PC5_CCP1           0x00021401
+#define GPIO_PC5_C1O            0x00021402
+#define GPIO_PC5_C0O            0x00021403
+#define GPIO_PC5_FAULT2         0x00021404
+#define GPIO_PC5_CCP3           0x00021405
+#define GPIO_PC5_USB0EPEN       0x00021406
+#define GPIO_PC5_EPI0S3         0x00021408
+
+//
+// GPIO pin C6
+//
+#define GPIO_PC6_CCP3           0x00021801
+#define GPIO_PC6_PHB0           0x00021802
+#define GPIO_PC6_C2O            0x00021803
+#define GPIO_PC6_PWM7           0x00021804
+#define GPIO_PC6_U1RX           0x00021805
+#define GPIO_PC6_CCP0           0x00021806
+#define GPIO_PC6_USB0PFLT       0x00021807
+#define GPIO_PC6_EPI0S4         0x00021808
+
+//
+// GPIO pin C7
+//
+#define GPIO_PC7_CCP4           0x00021c01
+#define GPIO_PC7_PHB0           0x00021c02
+#define GPIO_PC7_CCP0           0x00021c04
+#define GPIO_PC7_U1TX           0x00021c05
+#define GPIO_PC7_USB0PFLT       0x00021c06
+#define GPIO_PC7_C1O            0x00021c07
+#define GPIO_PC7_EPI0S5         0x00021c08
+
+//
+// GPIO pin D0
+//
+#define GPIO_PD0_PWM0           0x00030001
+#define GPIO_PD0_CAN0RX         0x00030002
+#define GPIO_PD0_IDX0           0x00030003
+#define GPIO_PD0_U2RX           0x00030004
+#define GPIO_PD0_U1RX           0x00030005
+#define GPIO_PD0_CCP6           0x00030006
+#define GPIO_PD0_I2S0RXSCK      0x00030008
+#define GPIO_PD0_U1CTS          0x00030009
+
+//
+// GPIO pin D1
+//
+#define GPIO_PD1_PWM1           0x00030401
+#define GPIO_PD1_CAN0TX         0x00030402
+#define GPIO_PD1_PHA0           0x00030403
+#define GPIO_PD1_U2TX           0x00030404
+#define GPIO_PD1_U1TX           0x00030405
+#define GPIO_PD1_CCP7           0x00030406
+#define GPIO_PD1_I2S0RXWS       0x00030408
+#define GPIO_PD1_U1DCD          0x00030409
+#define GPIO_PD1_CCP2           0x0003040a
+#define GPIO_PD1_PHB1           0x0003040b
+
+//
+// GPIO pin D2
+//
+#define GPIO_PD2_U1RX           0x00030801
+#define GPIO_PD2_CCP6           0x00030802
+#define GPIO_PD2_PWM2           0x00030803
+#define GPIO_PD2_CCP5           0x00030804
+#define GPIO_PD2_EPI0S20        0x00030808
+
+//
+// GPIO pin D3
+//
+#define GPIO_PD3_U1TX           0x00030c01
+#define GPIO_PD3_CCP7           0x00030c02
+#define GPIO_PD3_PWM3           0x00030c03
+#define GPIO_PD3_CCP0           0x00030c04
+#define GPIO_PD3_EPI0S21        0x00030c08
+
+//
+// GPIO pin D4
+//
+#define GPIO_PD4_CCP0           0x00031001
+#define GPIO_PD4_CCP3           0x00031002
+#define GPIO_PD4_I2S0RXSD       0x00031008
+#define GPIO_PD4_U1RI           0x00031009
+#define GPIO_PD4_EPI0S19        0x0003100a
+
+//
+// GPIO pin D5
+//
+#define GPIO_PD5_CCP2           0x00031401
+#define GPIO_PD5_CCP4           0x00031402
+#define GPIO_PD5_I2S0RXMCLK     0x00031408
+#define GPIO_PD5_U2RX           0x00031409
+#define GPIO_PD5_EPI0S28        0x0003140a
+
+//
+// GPIO pin D6
+//
+#define GPIO_PD6_FAULT0         0x00031801
+#define GPIO_PD6_I2S0TXSCK      0x00031808
+#define GPIO_PD6_U2TX           0x00031809
+#define GPIO_PD6_EPI0S29        0x0003180a
+
+//
+// GPIO pin D7
+//
+#define GPIO_PD7_IDX0           0x00031c01
+#define GPIO_PD7_C0O            0x00031c02
+#define GPIO_PD7_CCP1           0x00031c03
+#define GPIO_PD7_I2S0TXWS       0x00031c08
+#define GPIO_PD7_U1DTR          0x00031c09
+#define GPIO_PD7_EPI0S30        0x00031c0a
+
+//
+// GPIO pin E0
+//
+#define GPIO_PE0_PWM4           0x00040001
+#define GPIO_PE0_SSI1CLK        0x00040002
+#define GPIO_PE0_CCP3           0x00040003
+#define GPIO_PE0_EPI0S8         0x00040008
+#define GPIO_PE0_USB0PFLT       0x00040009
+
+//
+// GPIO pin E1
+//
+#define GPIO_PE1_PWM5           0x00040401
+#define GPIO_PE1_SSI1FSS        0x00040402
+#define GPIO_PE1_FAULT0         0x00040403
+#define GPIO_PE1_CCP2           0x00040404
+#define GPIO_PE1_CCP6           0x00040405
+#define GPIO_PE1_EPI0S9         0x00040408
+
+//
+// GPIO pin E2
+//
+#define GPIO_PE2_CCP4           0x00040801
+#define GPIO_PE2_SSI1RX         0x00040802
+#define GPIO_PE2_PHB1           0x00040803
+#define GPIO_PE2_PHA0           0x00040804
+#define GPIO_PE2_CCP2           0x00040805
+#define GPIO_PE2_EPI0S24        0x00040808
+
+//
+// GPIO pin E3
+//
+#define GPIO_PE3_CCP1           0x00040c01
+#define GPIO_PE3_SSI1TX         0x00040c02
+#define GPIO_PE3_PHA1           0x00040c03
+#define GPIO_PE3_PHB0           0x00040c04
+#define GPIO_PE3_CCP7           0x00040c05
+#define GPIO_PE3_EPI0S25        0x00040c08
+
+//
+// GPIO pin E4
+//
+#define GPIO_PE4_CCP3           0x00041001
+#define GPIO_PE4_FAULT0         0x00041004
+#define GPIO_PE4_U2TX           0x00041005
+#define GPIO_PE4_CCP2           0x00041006
+#define GPIO_PE4_I2S0TXWS       0x00041009
+
+//
+// GPIO pin E5
+//
+#define GPIO_PE5_CCP5           0x00041401
+#define GPIO_PE5_I2S0TXSD       0x00041409
+
+//
+// GPIO pin E6
+//
+#define GPIO_PE6_PWM4           0x00041801
+#define GPIO_PE6_C1O            0x00041802
+#define GPIO_PE6_U1CTS          0x00041809
+
+//
+// GPIO pin E7
+//
+#define GPIO_PE7_PWM5           0x00041c01
+#define GPIO_PE7_C2O            0x00041c02
+#define GPIO_PE7_U1DCD          0x00041c09
+
+//
+// GPIO pin F0
+//
+#define GPIO_PF0_CAN1RX         0x00050001
+#define GPIO_PF0_PHB0           0x00050002
+#define GPIO_PF0_PWM0           0x00050003
+#define GPIO_PF0_I2S0TXSD       0x00050008
+#define GPIO_PF0_U1DSR          0x00050009
+
+//
+// GPIO pin F1
+//
+#define GPIO_PF1_CAN1TX         0x00050401
+#define GPIO_PF1_IDX1           0x00050402
+#define GPIO_PF1_PWM1           0x00050403
+#define GPIO_PF1_I2S0TXMCLK     0x00050408
+#define GPIO_PF1_U1RTS          0x00050409
+#define GPIO_PF1_CCP3           0x0005040a
+
+//
+// GPIO pin F2
+//
+#define GPIO_PF2_LED1           0x00050801
+#define GPIO_PF2_PWM4           0x00050802
+#define GPIO_PF2_PWM2           0x00050804
+#define GPIO_PF2_SSI1CLK        0x00050809
+
+//
+// GPIO pin F3
+//
+#define GPIO_PF3_LED0           0x00050c01
+#define GPIO_PF3_PWM5           0x00050c02
+#define GPIO_PF3_PWM3           0x00050c04
+#define GPIO_PF3_SSI1FSS        0x00050c09
+
+//
+// GPIO pin F4
+//
+#define GPIO_PF4_CCP0           0x00051001
+#define GPIO_PF4_C0O            0x00051002
+#define GPIO_PF4_FAULT0         0x00051004
+#define GPIO_PF4_EPI0S12        0x00051008
+#define GPIO_PF4_SSI1RX         0x00051009
+
+//
+// GPIO pin F5
+//
+#define GPIO_PF5_CCP2           0x00051401
+#define GPIO_PF5_C1O            0x00051402
+#define GPIO_PF5_EPI0S15        0x00051408
+#define GPIO_PF5_SSI1TX         0x00051409
+
+//
+// GPIO pin F6
+//
+#define GPIO_PF6_CCP1           0x00051801
+#define GPIO_PF6_C2O            0x00051802
+#define GPIO_PF6_PHA0           0x00051804
+#define GPIO_PF6_I2S0TXMCLK     0x00051809
+#define GPIO_PF6_U1RTS          0x0005180a
+
+//
+// GPIO pin F7
+//
+#define GPIO_PF7_CCP4           0x00051c01
+#define GPIO_PF7_PHB0           0x00051c04
+#define GPIO_PF7_EPI0S12        0x00051c08
+#define GPIO_PF7_FAULT1         0x00051c09
+
+//
+// GPIO pin G0
+//
+#define GPIO_PG0_U2RX           0x00060001
+#define GPIO_PG0_PWM0           0x00060002
+#define GPIO_PG0_I2C1SCL        0x00060003
+#define GPIO_PG0_PWM4           0x00060004
+#define GPIO_PG0_USB0EPEN       0x00060007
+#define GPIO_PG0_EPI0S13        0x00060008
+
+//
+// GPIO pin G1
+//
+#define GPIO_PG1_U2TX           0x00060401
+#define GPIO_PG1_PWM1           0x00060402
+#define GPIO_PG1_I2C1SDA        0x00060403
+#define GPIO_PG1_PWM5           0x00060404
+#define GPIO_PG1_EPI0S14        0x00060408
+
+//
+// GPIO pin G2
+//
+#define GPIO_PG2_PWM0           0x00060801
+#define GPIO_PG2_FAULT0         0x00060804
+#define GPIO_PG2_IDX1           0x00060808
+#define GPIO_PG2_I2S0RXSD       0x00060809
+
+//
+// GPIO pin G3
+//
+#define GPIO_PG3_PWM1           0x00060c01
+#define GPIO_PG3_FAULT2         0x00060c04
+#define GPIO_PG3_FAULT0         0x00060c08
+#define GPIO_PG3_I2S0RXMCLK     0x00060c09
+
+//
+// GPIO pin G4
+//
+#define GPIO_PG4_CCP3           0x00061001
+#define GPIO_PG4_FAULT1         0x00061004
+#define GPIO_PG4_EPI0S15        0x00061008
+#define GPIO_PG4_PWM6           0x00061009
+#define GPIO_PG4_U1RI           0x0006100a
+
+//
+// GPIO pin G5
+//
+#define GPIO_PG5_CCP5           0x00061401
+#define GPIO_PG5_IDX0           0x00061404
+#define GPIO_PG5_FAULT1         0x00061405
+#define GPIO_PG5_PWM7           0x00061408
+#define GPIO_PG5_I2S0RXSCK      0x00061409
+#define GPIO_PG5_U1DTR          0x0006140a
+
+//
+// GPIO pin G6
+//
+#define GPIO_PG6_PHA1           0x00061801
+#define GPIO_PG6_PWM6           0x00061804
+#define GPIO_PG6_FAULT1         0x00061808
+#define GPIO_PG6_I2S0RXWS       0x00061809
+#define GPIO_PG6_U1RI           0x0006180a
+
+//
+// GPIO pin G7
+//
+#define GPIO_PG7_PHB1           0x00061c01
+#define GPIO_PG7_PWM7           0x00061c04
+#define GPIO_PG7_CCP5           0x00061c08
+#define GPIO_PG7_EPI0S31        0x00061c09
+
+//
+// GPIO pin H0
+//
+#define GPIO_PH0_CCP6           0x00070001
+#define GPIO_PH0_PWM2           0x00070002
+#define GPIO_PH0_EPI0S6         0x00070008
+#define GPIO_PH0_PWM4           0x00070009
+
+//
+// GPIO pin H1
+//
+#define GPIO_PH1_CCP7           0x00070401
+#define GPIO_PH1_PWM3           0x00070402
+#define GPIO_PH1_EPI0S7         0x00070408
+#define GPIO_PH1_PWM5           0x00070409
+
+//
+// GPIO pin H2
+//
+#define GPIO_PH2_IDX1           0x00070801
+#define GPIO_PH2_C1O            0x00070802
+#define GPIO_PH2_FAULT3         0x00070804
+#define GPIO_PH2_EPI0S1         0x00070808
+
+//
+// GPIO pin H3
+//
+#define GPIO_PH3_PHB0           0x00070c01
+#define GPIO_PH3_FAULT0         0x00070c02
+#define GPIO_PH3_USB0EPEN       0x00070c04
+#define GPIO_PH3_EPI0S0         0x00070c08
+
+//
+// GPIO pin H4
+//
+#define GPIO_PH4_USB0PFLT       0x00071004
+#define GPIO_PH4_EPI0S10        0x00071008
+#define GPIO_PH4_SSI1CLK        0x0007100b
+
+//
+// GPIO pin H5
+//
+#define GPIO_PH5_EPI0S11        0x00071408
+#define GPIO_PH5_FAULT2         0x0007140a
+#define GPIO_PH5_SSI1FSS        0x0007140b
+
+//
+// GPIO pin H6
+//
+#define GPIO_PH6_EPI0S26        0x00071808
+#define GPIO_PH6_PWM4           0x0007180a
+#define GPIO_PH6_SSI1RX         0x0007180b
+
+//
+// GPIO pin H7
+//
+#define GPIO_PH7_EPI0S27        0x00071c08
+#define GPIO_PH7_PWM5           0x00071c0a
+#define GPIO_PH7_SSI1TX         0x00071c0b
+
+//
+// GPIO pin J0
+//
+#define GPIO_PJ0_EPI0S16        0x00080008
+#define GPIO_PJ0_PWM0           0x0008000a
+#define GPIO_PJ0_I2C1SCL        0x0008000b
+
+//
+// GPIO pin J1
+//
+#define GPIO_PJ1_EPI0S17        0x00080408
+#define GPIO_PJ1_USB0PFLT       0x00080409
+#define GPIO_PJ1_PWM1           0x0008040a
+#define GPIO_PJ1_I2C1SDA        0x0008040b
+
+//
+// GPIO pin J2
+//
+#define GPIO_PJ2_EPI0S18        0x00080808
+#define GPIO_PJ2_CCP0           0x00080809
+#define GPIO_PJ2_FAULT0         0x0008080a
+
+//
+// GPIO pin J3
+//
+#define GPIO_PJ3_EPI0S19        0x00080c08
+#define GPIO_PJ3_U1CTS          0x00080c09
+#define GPIO_PJ3_CCP6           0x00080c0a
+
+//
+// GPIO pin J4
+//
+#define GPIO_PJ4_EPI0S28        0x00081008
+#define GPIO_PJ4_U1DCD          0x00081009
+#define GPIO_PJ4_CCP4           0x0008100a
+
+//
+// GPIO pin J5
+//
+#define GPIO_PJ5_EPI0S29        0x00081408
+#define GPIO_PJ5_U1DSR          0x00081409
+#define GPIO_PJ5_CCP2           0x0008140a
+
+//
+// GPIO pin J6
+//
+#define GPIO_PJ6_EPI0S30        0x00081808
+#define GPIO_PJ6_U1RTS          0x00081809
+#define GPIO_PJ6_CCP1           0x0008180a
+
+//
+// GPIO pin J7
+//
+#define GPIO_PJ7_U1DTR          0x00081c09
+#define GPIO_PJ7_CCP0           0x00081c0a
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern void GPIODirModeSet(unsigned long ulPort, unsigned char ucPins,
+                           unsigned long ulPinIO);
+extern unsigned long GPIODirModeGet(unsigned long ulPort, unsigned char ucPin);
+extern void GPIOIntTypeSet(unsigned long ulPort, unsigned char ucPins,
+                           unsigned long ulIntType);
+extern unsigned long GPIOIntTypeGet(unsigned long ulPort, unsigned char ucPin);
+extern void GPIOPadConfigSet(unsigned long ulPort, unsigned char ucPins,
+                             unsigned long ulStrength,
+                             unsigned long ulPadType);
+extern void GPIOPadConfigGet(unsigned long ulPort, unsigned char ucPin,
+                             unsigned long *pulStrength,
+                             unsigned long *pulPadType);
+extern void GPIOPinIntEnable(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinIntDisable(unsigned long ulPort, unsigned char ucPins);
+extern long GPIOPinIntStatus(unsigned long ulPort, tBoolean bMasked);
+extern void GPIOPinIntClear(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPortIntRegister(unsigned long ulPort,
+                                void (*pfnIntHandler)(void));
+extern void GPIOPortIntUnregister(unsigned long ulPort);
+extern long GPIOPinRead(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinWrite(unsigned long ulPort, unsigned char ucPins,
+                         unsigned char ucVal);
+extern void GPIOPinConfigure(unsigned long ulPinConfig);
+extern void GPIOPinTypeADC(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeCAN(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeComparator(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeGPIOInput(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeGPIOOutput(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeGPIOOutputOD(unsigned long ulPort,
+                                    unsigned char ucPins);
+extern void GPIOPinTypeI2C(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeI2S(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypePWM(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeQEI(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeSSI(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeTimer(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeUART(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeUSBAnalog(unsigned long ulPort, unsigned char ucPins);
+extern void GPIOPinTypeUSBDigital(unsigned long ulPort, unsigned char ucPins);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif //  __GPIO_H__


Property changes on: trunk/src/platform/lm3s/gpio.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_adc.h
===================================================================
--- trunk/src/platform/lm3s/hw_adc.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_adc.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,634 +1,1159 @@
-//*****************************************************************************
-//
-// hw_adc.h - Macros used when accessing the ADC hardware.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_ADC_H__
-#define __HW_ADC_H__
-
-//*****************************************************************************
-//
-// The following are defines for the ADC register offsets.
-//
-//*****************************************************************************
-#define ADC_O_ACTSS             0x00000000  // Active sample register
-#define ADC_O_RIS               0x00000004  // Raw interrupt status register
-#define ADC_O_IM                0x00000008  // Interrupt mask register
-#define ADC_O_ISC               0x0000000C  // Interrupt status/clear register
-#define ADC_O_OSTAT             0x00000010  // Overflow status register
-#define ADC_O_EMUX              0x00000014  // Event multiplexer select reg.
-#define ADC_O_USTAT             0x00000018  // Underflow status register
-#define ADC_O_SSPRI             0x00000020  // Channel priority register
-#define ADC_O_PSSI              0x00000028  // Processor sample initiate reg.
-#define ADC_O_SAC               0x00000030  // Sample Averaging Control reg.
-#define ADC_O_SSMUX0            0x00000040  // Multiplexer select 0 register
-#define ADC_O_SSCTL0            0x00000044  // Sample sequence control 0 reg.
-#define ADC_O_SSFIFO0           0x00000048  // Result FIFO 0 register
-#define ADC_O_SSFSTAT0          0x0000004C  // FIFO 0 status register
-#define ADC_O_SSMUX1            0x00000060  // Multiplexer select 1 register
-#define ADC_O_SSCTL1            0x00000064  // Sample sequence control 1 reg.
-#define ADC_O_SSFIFO1           0x00000068  // Result FIFO 1 register
-#define ADC_O_SSFSTAT1          0x0000006C  // FIFO 1 status register
-#define ADC_O_SSMUX2            0x00000080  // Multiplexer select 2 register
-#define ADC_O_SSCTL2            0x00000084  // Sample sequence control 2 reg.
-#define ADC_O_SSFIFO2           0x00000088  // Result FIFO 2 register
-#define ADC_O_SSFSTAT2          0x0000008C  // FIFO 2 status register
-#define ADC_O_SSMUX3            0x000000A0  // Multiplexer select 3 register
-#define ADC_O_SSCTL3            0x000000A4  // Sample sequence control 3 reg.
-#define ADC_O_SSFIFO3           0x000000A8  // Result FIFO 3 register
-#define ADC_O_SSFSTAT3          0x000000AC  // FIFO 3 status register
-#define ADC_O_TMLB              0x00000100  // Test mode loopback register
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_ACTSS register.
-//
-//*****************************************************************************
-#define ADC_ACTSS_ASEN3         0x00000008  // Sample sequence 3 enable
-#define ADC_ACTSS_ASEN2         0x00000004  // Sample sequence 2 enable
-#define ADC_ACTSS_ASEN1         0x00000002  // Sample sequence 1 enable
-#define ADC_ACTSS_ASEN0         0x00000001  // Sample sequence 0 enable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_RIS register.
-//
-//*****************************************************************************
-#define ADC_RIS_INR3            0x00000008  // Sample sequence 3 interrupt
-#define ADC_RIS_INR2            0x00000004  // Sample sequence 2 interrupt
-#define ADC_RIS_INR1            0x00000002  // Sample sequence 1 interrupt
-#define ADC_RIS_INR0            0x00000001  // Sample sequence 0 interrupt
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_IM register.
-//
-//*****************************************************************************
-#define ADC_IM_MASK3            0x00000008  // Sample sequence 3 mask
-#define ADC_IM_MASK2            0x00000004  // Sample sequence 2 mask
-#define ADC_IM_MASK1            0x00000002  // Sample sequence 1 mask
-#define ADC_IM_MASK0            0x00000001  // Sample sequence 0 mask
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_ISC register.
-//
-//*****************************************************************************
-#define ADC_ISC_IN3             0x00000008  // Sample sequence 3 interrupt
-#define ADC_ISC_IN2             0x00000004  // Sample sequence 2 interrupt
-#define ADC_ISC_IN1             0x00000002  // Sample sequence 1 interrupt
-#define ADC_ISC_IN0             0x00000001  // Sample sequence 0 interrupt
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_OSTAT register.
-//
-//*****************************************************************************
-#define ADC_OSTAT_OV3           0x00000008  // Sample sequence 3 overflow
-#define ADC_OSTAT_OV2           0x00000004  // Sample sequence 2 overflow
-#define ADC_OSTAT_OV1           0x00000002  // Sample sequence 1 overflow
-#define ADC_OSTAT_OV0           0x00000001  // Sample sequence 0 overflow
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_EMUX register.
-//
-//*****************************************************************************
-#define ADC_EMUX_EM3_M          0x0000F000  // Event mux 3 mask
-#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Processor event
-#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog comparator 0 event
-#define ADC_EMUX_EM3_COMP1      0x00002000  // Analog comparator 1 event
-#define ADC_EMUX_EM3_COMP2      0x00003000  // Analog comparator 2 event
-#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External event
-#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer event
-#define ADC_EMUX_EM3_PWM0       0x00006000  // PWM0 event
-#define ADC_EMUX_EM3_PWM1       0x00007000  // PWM1 event
-#define ADC_EMUX_EM3_PWM2       0x00008000  // PWM2 event
-#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always event
-#define ADC_EMUX_EM2_M          0x00000F00  // Event mux 2 mask
-#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Processor event
-#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog comparator 0 event
-#define ADC_EMUX_EM2_COMP1      0x00000200  // Analog comparator 1 event
-#define ADC_EMUX_EM2_COMP2      0x00000300  // Analog comparator 2 event
-#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External event
-#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer event
-#define ADC_EMUX_EM2_PWM0       0x00000600  // PWM0 event
-#define ADC_EMUX_EM2_PWM1       0x00000700  // PWM1 event
-#define ADC_EMUX_EM2_PWM2       0x00000800  // PWM2 event
-#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always event
-#define ADC_EMUX_EM1_M          0x000000F0  // Event mux 1 mask
-#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Processor event
-#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog comparator 0 event
-#define ADC_EMUX_EM1_COMP1      0x00000020  // Analog comparator 1 event
-#define ADC_EMUX_EM1_COMP2      0x00000030  // Analog comparator 2 event
-#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External event
-#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer event
-#define ADC_EMUX_EM1_PWM0       0x00000060  // PWM0 event
-#define ADC_EMUX_EM1_PWM1       0x00000070  // PWM1 event
-#define ADC_EMUX_EM1_PWM2       0x00000080  // PWM2 event
-#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always event
-#define ADC_EMUX_EM0_M          0x0000000F  // Event mux 0 mask
-#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Processor event
-#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog comparator 0 event
-#define ADC_EMUX_EM0_COMP1      0x00000002  // Analog comparator 1 event
-#define ADC_EMUX_EM0_COMP2      0x00000003  // Analog comparator 2 event
-#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External event
-#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer event
-#define ADC_EMUX_EM0_PWM0       0x00000006  // PWM0 event
-#define ADC_EMUX_EM0_PWM1       0x00000007  // PWM1 event
-#define ADC_EMUX_EM0_PWM2       0x00000008  // PWM2 event
-#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always event
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_USTAT register.
-//
-//*****************************************************************************
-#define ADC_USTAT_UV3           0x00000008  // Sample sequence 3 underflow
-#define ADC_USTAT_UV2           0x00000004  // Sample sequence 2 underflow
-#define ADC_USTAT_UV1           0x00000002  // Sample sequence 1 underflow
-#define ADC_USTAT_UV0           0x00000001  // Sample sequence 0 underflow
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_SSPRI register.
-//
-//*****************************************************************************
-#define ADC_SSPRI_SS3_M         0x00003000  // Sequencer 3 priority mask
-#define ADC_SSPRI_SS3_1ST       0x00000000  // First priority
-#define ADC_SSPRI_SS3_2ND       0x00001000  // Second priority
-#define ADC_SSPRI_SS3_3RD       0x00002000  // Third priority
-#define ADC_SSPRI_SS3_4TH       0x00003000  // Fourth priority
-#define ADC_SSPRI_SS2_M         0x00000300  // Sequencer 2 priority mask
-#define ADC_SSPRI_SS2_1ST       0x00000000  // First priority
-#define ADC_SSPRI_SS2_2ND       0x00000100  // Second priority
-#define ADC_SSPRI_SS2_3RD       0x00000200  // Third priority
-#define ADC_SSPRI_SS2_4TH       0x00000300  // Fourth priority
-#define ADC_SSPRI_SS1_M         0x00000030  // Sequencer 1 priority mask
-#define ADC_SSPRI_SS1_1ST       0x00000000  // First priority
-#define ADC_SSPRI_SS1_2ND       0x00000010  // Second priority
-#define ADC_SSPRI_SS1_3RD       0x00000020  // Third priority
-#define ADC_SSPRI_SS1_4TH       0x00000030  // Fourth priority
-#define ADC_SSPRI_SS0_M         0x00000003  // Sequencer 0 priority mask
-#define ADC_SSPRI_SS0_1ST       0x00000000  // First priority
-#define ADC_SSPRI_SS0_2ND       0x00000001  // Second priority
-#define ADC_SSPRI_SS0_3RD       0x00000002  // Third priority
-#define ADC_SSPRI_SS0_4TH       0x00000003  // Fourth priority
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_PSSI register.
-//
-//*****************************************************************************
-#define ADC_PSSI_SS3            0x00000008  // Trigger sample sequencer 3
-#define ADC_PSSI_SS2            0x00000004  // Trigger sample sequencer 2
-#define ADC_PSSI_SS1            0x00000002  // Trigger sample sequencer 1
-#define ADC_PSSI_SS0            0x00000001  // Trigger sample sequencer 0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_SAC register.
-//
-//*****************************************************************************
-#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control.
-#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
-#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
-#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
-#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
-#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
-#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
-#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
-
-//*****************************************************************************
-//
-// The following are defines for the the interpretation of the data in the
-// SSFIFOx when the ADC TMLB is enabled.
-//
-//*****************************************************************************
-#define ADC_SSFIFO_TMLB_CNT_M   0x000003C0  // Continuous Sample Counter.
-#define ADC_SSFIFO_TMLB_CONT    0x00000020  // Continuation Sample Indicator.
-#define ADC_SSFIFO_TMLB_DIFF    0x00000010  // Differential Sample Indicator.
-#define ADC_SSFIFO_TMLB_TS      0x00000008  // Temp Sensor Sample Indicator.
-#define ADC_SSFIFO_TMLB_MUX_M   0x00000007  // Analog Input Indicator.
-#define ADC_SSFIFO_TMLB_CNT_S   6           // Sample counter shift
-#define ADC_SSFIFO_TMLB_MUX_S   0           // Input channel number shift
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_TMLB register.
-//
-//*****************************************************************************
-#define ADC_TMLB_LB             0x00000001  // Loopback control signals
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
-//
-//*****************************************************************************
-#define ADC_SSMUX0_MUX7_M       0x70000000  // 8th Sample Input Select.
-#define ADC_SSMUX0_MUX6_M       0x07000000  // 7th Sample Input Select.
-#define ADC_SSMUX0_MUX5_M       0x00700000  // 6th Sample Input Select.
-#define ADC_SSMUX0_MUX4_M       0x00070000  // 5th Sample Input Select.
-#define ADC_SSMUX0_MUX3_M       0x00007000  // 4th Sample Input Select.
-#define ADC_SSMUX0_MUX2_M       0x00000700  // 3rd Sample Input Select.
-#define ADC_SSMUX0_MUX1_M       0x00000070  // 2nd Sample Input Select.
-#define ADC_SSMUX0_MUX0_M       0x00000007  // 1st Sample Input Select.
-#define ADC_SSMUX0_MUX7_S       28
-#define ADC_SSMUX0_MUX6_S       24
-#define ADC_SSMUX0_MUX5_S       20
-#define ADC_SSMUX0_MUX4_S       16
-#define ADC_SSMUX0_MUX3_S       12
-#define ADC_SSMUX0_MUX2_S       8
-#define ADC_SSMUX0_MUX1_S       4
-#define ADC_SSMUX0_MUX0_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
-//
-//*****************************************************************************
-#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable.
-#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence.
-#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Diff Input Select.
-#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable.
-#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence.
-#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Diff Input Select.
-#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable.
-#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence.
-#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Diff Input Select.
-#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable.
-#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence.
-#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Diff Input Select.
-#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable.
-#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence.
-#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Diff Input Select.
-#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable.
-#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence.
-#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Diff Input Select.
-#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable.
-#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence.
-#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Diff Input Select.
-#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select.
-#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable.
-#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence.
-#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Diff Input Select.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
-//
-//*****************************************************************************
-#define ADC_SSFIFO0_DATA_M      0x000003FF  // Conversion Result Data.
-#define ADC_SSFIFO0_DATA_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
-//
-//*****************************************************************************
-#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full.
-#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty.
-#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer.
-#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer.
-#define ADC_SSFSTAT0_HPTR_S     4
-#define ADC_SSFSTAT0_TPTR_S     0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
-//
-//*****************************************************************************
-#define ADC_SSMUX1_MUX3_M       0x00007000  // 4th Sample Input Select.
-#define ADC_SSMUX1_MUX2_M       0x00000700  // 3rd Sample Input Select.
-#define ADC_SSMUX1_MUX1_M       0x00000070  // 2nd Sample Input Select.
-#define ADC_SSMUX1_MUX0_M       0x00000007  // 1st Sample Input Select.
-#define ADC_SSMUX1_MUX3_S       12
-#define ADC_SSMUX1_MUX2_S       8
-#define ADC_SSMUX1_MUX1_S       4
-#define ADC_SSMUX1_MUX0_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
-//
-//*****************************************************************************
-#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select.
-#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable.
-#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence.
-#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Diff Input Select.
-#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
-#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable.
-#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence.
-#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Diff Input Select.
-#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
-#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable.
-#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence.
-#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Diff Input Select.
-#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select.
-#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable.
-#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence.
-#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Diff Input Select.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
-//
-//*****************************************************************************
-#define ADC_SSFIFO1_DATA_M      0x000003FF  // Conversion Result Data.
-#define ADC_SSFIFO1_DATA_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
-//
-//*****************************************************************************
-#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full.
-#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty.
-#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer.
-#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer.
-#define ADC_SSFSTAT1_HPTR_S     4
-#define ADC_SSFSTAT1_TPTR_S     0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
-//
-//*****************************************************************************
-#define ADC_SSMUX2_MUX3_M       0x00007000  // 4th Sample Input Select.
-#define ADC_SSMUX2_MUX2_M       0x00000700  // 3rd Sample Input Select.
-#define ADC_SSMUX2_MUX1_M       0x00000070  // 2nd Sample Input Select.
-#define ADC_SSMUX2_MUX0_M       0x00000007  // 1st Sample Input Select.
-#define ADC_SSMUX2_MUX3_S       12
-#define ADC_SSMUX2_MUX2_S       8
-#define ADC_SSMUX2_MUX1_S       4
-#define ADC_SSMUX2_MUX0_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
-//
-//*****************************************************************************
-#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select.
-#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable.
-#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence.
-#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Diff Input Select.
-#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
-#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable.
-#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence.
-#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Diff Input Select.
-#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
-#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable.
-#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence.
-#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Diff Input Select.
-#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select.
-#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable.
-#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence.
-#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Diff Input Select.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
-//
-//*****************************************************************************
-#define ADC_SSFIFO2_DATA_M      0x000003FF  // Conversion Result Data.
-#define ADC_SSFIFO2_DATA_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
-//
-//*****************************************************************************
-#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full.
-#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty.
-#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer.
-#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer.
-#define ADC_SSFSTAT2_HPTR_S     4
-#define ADC_SSFSTAT2_TPTR_S     0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
-//
-//*****************************************************************************
-#define ADC_SSMUX3_MUX0_M       0x00000007  // 1st Sample Input Select.
-#define ADC_SSMUX3_MUX0_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
-//
-//*****************************************************************************
-#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select.
-#define ADC_SSCTL3_IE0          0x00000004  // 1st Sample Interrupt Enable.
-#define ADC_SSCTL3_END0         0x00000002  // 1st Sample is End of Sequence.
-#define ADC_SSCTL3_D0           0x00000001  // 1st Sample Diff Input Select.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
-//
-//*****************************************************************************
-#define ADC_SSFIFO3_DATA_M      0x000003FF  // Conversion Result Data.
-#define ADC_SSFIFO3_DATA_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
-//
-//*****************************************************************************
-#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full.
-#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty.
-#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer.
-#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer.
-#define ADC_SSFSTAT3_HPTR_S     4
-#define ADC_SSFSTAT3_TPTR_S     0
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the ADC sequence register offsets.
-//
-//*****************************************************************************
-#define ADC_O_SEQ               0x00000040  // Offset to the first sequence
-#define ADC_O_SEQ_STEP          0x00000020  // Increment to the next sequence
-#define ADC_O_X_SSFSTAT         0x0000000C  // FIFO status register
-#define ADC_O_X_SSFIFO          0x00000008  // Result FIFO register
-#define ADC_O_X_SSCTL           0x00000004  // Sample sequence control register
-#define ADC_O_X_SSMUX           0x00000000  // Multiplexer select register
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the ADC_EMUX
-// register.
-//
-//*****************************************************************************
-#define ADC_EMUX_EM3_MASK       0x0000F000  // Event mux 3 mask
-#define ADC_EMUX_EM2_MASK       0x00000F00  // Event mux 2 mask
-#define ADC_EMUX_EM1_MASK       0x000000F0  // Event mux 1 mask
-#define ADC_EMUX_EM0_MASK       0x0000000F  // Event mux 0 mask
-#define ADC_EMUX_EM3_SHIFT      12          // The shift for the fourth event
-#define ADC_EMUX_EM2_SHIFT      8           // The shift for the third event
-#define ADC_EMUX_EM1_SHIFT      4           // The shift for the second event
-#define ADC_EMUX_EM0_SHIFT      0           // The shift for the first event
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the ADC_SSPRI
-// register.
-//
-//*****************************************************************************
-#define ADC_SSPRI_SS3_MASK      0x00003000  // Sequencer 3 priority mask
-#define ADC_SSPRI_SS2_MASK      0x00000300  // Sequencer 2 priority mask
-#define ADC_SSPRI_SS1_MASK      0x00000030  // Sequencer 1 priority mask
-#define ADC_SSPRI_SS0_MASK      0x00000003  // Sequencer 0 priority mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the ADC_SSMUX0,
-// ADC_SSMUX1, ADC_SSMUX2, and ADC_SSMUX3 registers. Not all fields are present
-// in all registers.
-//
-//*****************************************************************************
-#define ADC_SSMUX_MUX7_MASK     0x70000000  // 8th mux select mask
-#define ADC_SSMUX_MUX6_MASK     0x07000000  // 7th mux select mask
-#define ADC_SSMUX_MUX5_MASK     0x00700000  // 6th mux select mask
-#define ADC_SSMUX_MUX4_MASK     0x00070000  // 5th mux select mask
-#define ADC_SSMUX_MUX3_MASK     0x00007000  // 4th mux select mask
-#define ADC_SSMUX_MUX2_MASK     0x00000700  // 3rd mux select mask
-#define ADC_SSMUX_MUX1_MASK     0x00000070  // 2nd mux select mask
-#define ADC_SSMUX_MUX0_MASK     0x00000007  // 1st mux select mask
-#define ADC_SSMUX_MUX7_SHIFT    28
-#define ADC_SSMUX_MUX6_SHIFT    24
-#define ADC_SSMUX_MUX5_SHIFT    20
-#define ADC_SSMUX_MUX4_SHIFT    16
-#define ADC_SSMUX_MUX3_SHIFT    12
-#define ADC_SSMUX_MUX2_SHIFT    8
-#define ADC_SSMUX_MUX1_SHIFT    4
-#define ADC_SSMUX_MUX0_SHIFT    0
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the ADC_SSCTL0,
-// ADC_SSCTL1, ADC_SSCTL2, and ADC_SSCTL3 registers. Not all fields are present
-// in all registers.
-//
-//*****************************************************************************
-#define ADC_SSCTL_TS7           0x80000000  // 8th temperature sensor select
-#define ADC_SSCTL_IE7           0x40000000  // 8th interrupt enable
-#define ADC_SSCTL_END7          0x20000000  // 8th sequence end select
-#define ADC_SSCTL_D7            0x10000000  // 8th differential select
-#define ADC_SSCTL_TS6           0x08000000  // 7th temperature sensor select
-#define ADC_SSCTL_IE6           0x04000000  // 7th interrupt enable
-#define ADC_SSCTL_END6          0x02000000  // 7th sequence end select
-#define ADC_SSCTL_D6            0x01000000  // 7th differential select
-#define ADC_SSCTL_TS5           0x00800000  // 6th temperature sensor select
-#define ADC_SSCTL_IE5           0x00400000  // 6th interrupt enable
-#define ADC_SSCTL_END5          0x00200000  // 6th sequence end select
-#define ADC_SSCTL_D5            0x00100000  // 6th differential select
-#define ADC_SSCTL_TS4           0x00080000  // 5th temperature sensor select
-#define ADC_SSCTL_IE4           0x00040000  // 5th interrupt enable
-#define ADC_SSCTL_END4          0x00020000  // 5th sequence end select
-#define ADC_SSCTL_D4            0x00010000  // 5th differential select
-#define ADC_SSCTL_TS3           0x00008000  // 4th temperature sensor select
-#define ADC_SSCTL_IE3           0x00004000  // 4th interrupt enable
-#define ADC_SSCTL_END3          0x00002000  // 4th sequence end select
-#define ADC_SSCTL_D3            0x00001000  // 4th differential select
-#define ADC_SSCTL_TS2           0x00000800  // 3rd temperature sensor select
-#define ADC_SSCTL_IE2           0x00000400  // 3rd interrupt enable
-#define ADC_SSCTL_END2          0x00000200  // 3rd sequence end select
-#define ADC_SSCTL_D2            0x00000100  // 3rd differential select
-#define ADC_SSCTL_TS1           0x00000080  // 2nd temperature sensor select
-#define ADC_SSCTL_IE1           0x00000040  // 2nd interrupt enable
-#define ADC_SSCTL_END1          0x00000020  // 2nd sequence end select
-#define ADC_SSCTL_D1            0x00000010  // 2nd differential select
-#define ADC_SSCTL_TS0           0x00000008  // 1st temperature sensor select
-#define ADC_SSCTL_IE0           0x00000004  // 1st interrupt enable
-#define ADC_SSCTL_END0          0x00000002  // 1st sequence end select
-#define ADC_SSCTL_D0            0x00000001  // 1st differential select
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the ADC_SSFIFO0,
-// ADC_SSFIFO1, ADC_SSFIFO2, and ADC_SSFIFO3 registers.
-//
-//*****************************************************************************
-#define ADC_SSFIFO_DATA_MASK    0x000003FF  // Sample data
-#define ADC_SSFIFO_DATA_SHIFT   0
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the ADC_SSFSTAT0,
-// ADC_SSFSTAT1, ADC_SSFSTAT2, and ADC_SSFSTAT3 registers.
-//
-//*****************************************************************************
-#define ADC_SSFSTAT_FULL        0x00001000  // FIFO is full
-#define ADC_SSFSTAT_EMPTY       0x00000100  // FIFO is empty
-#define ADC_SSFSTAT_HPTR        0x000000F0  // FIFO head pointer
-#define ADC_SSFSTAT_TPTR        0x0000000F  // FIFO tail pointer
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the the interpretation of the data
-// in the SSFIFOx when the ADC TMLB is enabled.
-//
-//*****************************************************************************
-#define ADC_TMLB_CNT_M          0x000003C0  // Continuous Sample Counter.
-#define ADC_TMLB_CONT           0x00000020  // Continuation Sample Indicator.
-#define ADC_TMLB_DIFF           0x00000010  // Differential Sample Indicator.
-#define ADC_TMLB_TS             0x00000008  // Temp Sensor Sample Indicator.
-#define ADC_TMLB_MUX_M          0x00000007  // Analog Input Indicator.
-#define ADC_TMLB_CNT_S          6           // Sample counter shift
-#define ADC_TMLB_MUX_S          0           // Input channel number shift
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the loopback ADC
-// data.
-//
-//*****************************************************************************
-#define ADC_LB_CNT_MASK         0x000003C0  // Sample counter mask
-#define ADC_LB_CONT             0x00000020  // Continuation sample
-#define ADC_LB_DIFF             0x00000010  // Differential sample
-#define ADC_LB_TS               0x00000008  // Temperature sensor sample
-#define ADC_LB_MUX_MASK         0x00000007  // Input channel number mask
-#define ADC_LB_CNT_SHIFT        6           // Sample counter shift
-#define ADC_LB_MUX_SHIFT        0           // Input channel number shift
-
-#endif
-
-#endif // __HW_ADC_H__
+//*****************************************************************************
+//
+// hw_adc.h - Macros used when accessing the ADC hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_ADC_H__
+#define __HW_ADC_H__
+
+//*****************************************************************************
+//
+// The following are defines for the ADC register offsets.
+//
+//*****************************************************************************
+#define ADC_O_ACTSS             0x00000000  // Active sample register
+#define ADC_O_RIS               0x00000004  // Raw interrupt status register
+#define ADC_O_IM                0x00000008  // Interrupt mask register
+#define ADC_O_ISC               0x0000000C  // Interrupt status/clear register
+#define ADC_O_OSTAT             0x00000010  // Overflow status register
+#define ADC_O_EMUX              0x00000014  // Event multiplexer select reg.
+#define ADC_O_USTAT             0x00000018  // Underflow status register
+#define ADC_O_SSPRI             0x00000020  // Channel priority register
+#define ADC_O_PSSI              0x00000028  // Processor sample initiate reg.
+#define ADC_O_SAC               0x00000030  // Sample Averaging Control reg.
+#define ADC_O_DCISC             0x00000034  // ADC Digital Comparator Interrupt
+                                            // Status and Clear
+#define ADC_O_CTL               0x00000038  // ADC Control
+#define ADC_O_SSMUX0            0x00000040  // Multiplexer select 0 register
+#define ADC_O_SSCTL0            0x00000044  // Sample sequence control 0 reg.
+#define ADC_O_SSFIFO0           0x00000048  // Result FIFO 0 register
+#define ADC_O_SSFSTAT0          0x0000004C  // FIFO 0 status register
+#define ADC_O_SSOP0             0x00000050  // ADC Sample Sequence 0 Operation
+#define ADC_O_SSDC0             0x00000054  // ADC Sample Sequence 0 Digital
+                                            // Comparator Select
+#define ADC_O_SSMUX1            0x00000060  // Multiplexer select 1 register
+#define ADC_O_SSCTL1            0x00000064  // Sample sequence control 1 reg.
+#define ADC_O_SSFIFO1           0x00000068  // Result FIFO 1 register
+#define ADC_O_SSFSTAT1          0x0000006C  // FIFO 1 status register
+#define ADC_O_SSOP1             0x00000070  // ADC Sample Sequence 1 Operation
+#define ADC_O_SSDC1             0x00000074  // ADC Sample Sequence 1 Digital
+                                            // Comparator Select
+#define ADC_O_SSMUX2            0x00000080  // Multiplexer select 2 register
+#define ADC_O_SSCTL2            0x00000084  // Sample sequence control 2 reg.
+#define ADC_O_SSFIFO2           0x00000088  // Result FIFO 2 register
+#define ADC_O_SSFSTAT2          0x0000008C  // FIFO 2 status register
+#define ADC_O_SSOP2             0x00000090  // ADC Sample Sequence 2 Operation
+#define ADC_O_SSDC2             0x00000094  // ADC Sample Sequence 2 Digital
+                                            // Comparator Select
+#define ADC_O_SSMUX3            0x000000A0  // Multiplexer select 3 register
+#define ADC_O_SSCTL3            0x000000A4  // Sample sequence control 3 reg.
+#define ADC_O_SSFIFO3           0x000000A8  // Result FIFO 3 register
+#define ADC_O_SSFSTAT3          0x000000AC  // FIFO 3 status register
+#define ADC_O_SSOP3             0x000000B0  // ADC Sample Sequence 3 Operation
+#define ADC_O_SSDC3             0x000000B4  // ADC Sample Sequence 3 Digital
+                                            // Comparator Select
+#define ADC_O_TMLB              0x00000100  // Test mode loopback register
+#define ADC_O_DCRIC             0x00000D00  // ADC Digital Comparator Reset
+                                            // Initial Conditions
+#define ADC_O_DCCTL0            0x00000E00  // ADC Digital Comparator Control 0
+#define ADC_O_DCCTL1            0x00000E04  // ADC Digital Comparator Control 1
+#define ADC_O_DCCTL2            0x00000E08  // ADC Digital Comparator Control 2
+#define ADC_O_DCCTL3            0x00000E0C  // ADC Digital Comparator Control 3
+#define ADC_O_DCCTL4            0x00000E10  // ADC Digital Comparator Control 4
+#define ADC_O_DCCTL5            0x00000E14  // ADC Digital Comparator Control 5
+#define ADC_O_DCCTL6            0x00000E18  // ADC Digital Comparator Control 6
+#define ADC_O_DCCTL7            0x00000E1C  // ADC Digital Comparator Control 7
+#define ADC_O_DCCMP0            0x00000E40  // ADC Digital Comparator Range 0
+#define ADC_O_DCCMP1            0x00000E44  // ADC Digital Comparator Range 1
+#define ADC_O_DCCMP2            0x00000E48  // ADC Digital Comparator Range 2
+#define ADC_O_DCCMP3            0x00000E4C  // ADC Digital Comparator Range 3
+#define ADC_O_DCCMP4            0x00000E50  // ADC Digital Comparator Range 4
+#define ADC_O_DCCMP5            0x00000E54  // ADC Digital Comparator Range 5
+#define ADC_O_DCCMP6            0x00000E58  // ADC Digital Comparator Range 6
+#define ADC_O_DCCMP7            0x00000E5C  // ADC Digital Comparator Range 7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_ACTSS register.
+//
+//*****************************************************************************
+#define ADC_ACTSS_ASEN3         0x00000008  // Sample sequence 3 enable
+#define ADC_ACTSS_ASEN2         0x00000004  // Sample sequence 2 enable
+#define ADC_ACTSS_ASEN1         0x00000002  // Sample sequence 1 enable
+#define ADC_ACTSS_ASEN0         0x00000001  // Sample sequence 0 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_RIS register.
+//
+//*****************************************************************************
+#define ADC_RIS_INRDC           0x00010000  // Digital Comparator Raw Interrupt
+                                            // Status.
+#define ADC_RIS_INR3            0x00000008  // Sample sequence 3 interrupt
+#define ADC_RIS_INR2            0x00000004  // Sample sequence 2 interrupt
+#define ADC_RIS_INR1            0x00000002  // Sample sequence 1 interrupt
+#define ADC_RIS_INR0            0x00000001  // Sample sequence 0 interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_IM register.
+//
+//*****************************************************************************
+#define ADC_IM_DCONSS3          0x00080000  // Digital Comparator Interrupt on
+                                            // SS3.
+#define ADC_IM_DCONSS2          0x00040000  // Digital Comparator Interrupt on
+                                            // SS2.
+#define ADC_IM_DCONSS1          0x00020000  // Digital Comparator Interrupt on
+                                            // SS1.
+#define ADC_IM_DCONSS0          0x00010000  // Digital Comparator Interrupt on
+                                            // SS0.
+#define ADC_IM_MASK3            0x00000008  // Sample sequence 3 mask
+#define ADC_IM_MASK2            0x00000004  // Sample sequence 2 mask
+#define ADC_IM_MASK1            0x00000002  // Sample sequence 1 mask
+#define ADC_IM_MASK0            0x00000001  // Sample sequence 0 mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_ISC register.
+//
+//*****************************************************************************
+#define ADC_ISC_DCINSS3         0x00080000  // Digital Comparator Interrupt
+                                            // Status on SS3.
+#define ADC_ISC_DCINSS2         0x00040000  // Digital Comparator Interrupt
+                                            // Status on SS2.
+#define ADC_ISC_DCINSS1         0x00020000  // Digital Comparator Interrupt
+                                            // Status on SS1.
+#define ADC_ISC_DCINSS0         0x00010000  // Digital Comparator Interrupt
+                                            // Status on SS0.
+#define ADC_ISC_IN3             0x00000008  // Sample sequence 3 interrupt
+#define ADC_ISC_IN2             0x00000004  // Sample sequence 2 interrupt
+#define ADC_ISC_IN1             0x00000002  // Sample sequence 1 interrupt
+#define ADC_ISC_IN0             0x00000001  // Sample sequence 0 interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_OSTAT register.
+//
+//*****************************************************************************
+#define ADC_OSTAT_OV3           0x00000008  // Sample sequence 3 overflow
+#define ADC_OSTAT_OV2           0x00000004  // Sample sequence 2 overflow
+#define ADC_OSTAT_OV1           0x00000002  // Sample sequence 1 overflow
+#define ADC_OSTAT_OV0           0x00000001  // Sample sequence 0 overflow
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_EMUX register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_M          0x0000F000  // Event mux 3 mask
+#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog comparator 0 event
+#define ADC_EMUX_EM3_COMP1      0x00002000  // Analog comparator 1 event
+#define ADC_EMUX_EM3_COMP2      0x00003000  // Analog comparator 2 event
+#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External event
+#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer event
+#define ADC_EMUX_EM3_PWM0       0x00006000  // PWM0 event
+#define ADC_EMUX_EM3_PWM1       0x00007000  // PWM1 event
+#define ADC_EMUX_EM3_PWM2       0x00008000  // PWM2 event
+#define ADC_EMUX_EM3_PWM3       0x00009000  // PWM3
+#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always event
+#define ADC_EMUX_EM2_M          0x00000F00  // Event mux 2 mask
+#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog comparator 0 event
+#define ADC_EMUX_EM2_COMP1      0x00000200  // Analog comparator 1 event
+#define ADC_EMUX_EM2_COMP2      0x00000300  // Analog comparator 2 event
+#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External event
+#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer event
+#define ADC_EMUX_EM2_PWM0       0x00000600  // PWM0 event
+#define ADC_EMUX_EM2_PWM1       0x00000700  // PWM1 event
+#define ADC_EMUX_EM2_PWM2       0x00000800  // PWM2 event
+#define ADC_EMUX_EM2_PWM3       0x00000900  // PWM3
+#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always event
+#define ADC_EMUX_EM1_M          0x000000F0  // Event mux 1 mask
+#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog comparator 0 event
+#define ADC_EMUX_EM1_COMP1      0x00000020  // Analog comparator 1 event
+#define ADC_EMUX_EM1_COMP2      0x00000030  // Analog comparator 2 event
+#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External event
+#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer event
+#define ADC_EMUX_EM1_PWM0       0x00000060  // PWM0 event
+#define ADC_EMUX_EM1_PWM1       0x00000070  // PWM1 event
+#define ADC_EMUX_EM1_PWM2       0x00000080  // PWM2 event
+#define ADC_EMUX_EM1_PWM3       0x00000090  // PWM3
+#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always event
+#define ADC_EMUX_EM0_M          0x0000000F  // Event mux 0 mask
+#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog comparator 0 event
+#define ADC_EMUX_EM0_COMP1      0x00000002  // Analog comparator 1 event
+#define ADC_EMUX_EM0_COMP2      0x00000003  // Analog comparator 2 event
+#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External event
+#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer event
+#define ADC_EMUX_EM0_PWM0       0x00000006  // PWM0 event
+#define ADC_EMUX_EM0_PWM1       0x00000007  // PWM1 event
+#define ADC_EMUX_EM0_PWM2       0x00000008  // PWM2 event
+#define ADC_EMUX_EM0_PWM3       0x00000009  // PWM3
+#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always event
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_USTAT register.
+//
+//*****************************************************************************
+#define ADC_USTAT_UV3           0x00000008  // Sample sequence 3 underflow
+#define ADC_USTAT_UV2           0x00000004  // Sample sequence 2 underflow
+#define ADC_USTAT_UV1           0x00000002  // Sample sequence 1 underflow
+#define ADC_USTAT_UV0           0x00000001  // Sample sequence 0 underflow
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_SSPRI register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_M         0x00003000  // Sequencer 3 priority mask
+#define ADC_SSPRI_SS3_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS3_2ND       0x00001000  // Second priority
+#define ADC_SSPRI_SS3_3RD       0x00002000  // Third priority
+#define ADC_SSPRI_SS3_4TH       0x00003000  // Fourth priority
+#define ADC_SSPRI_SS2_M         0x00000300  // Sequencer 2 priority mask
+#define ADC_SSPRI_SS2_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS2_2ND       0x00000100  // Second priority
+#define ADC_SSPRI_SS2_3RD       0x00000200  // Third priority
+#define ADC_SSPRI_SS2_4TH       0x00000300  // Fourth priority
+#define ADC_SSPRI_SS1_M         0x00000030  // Sequencer 1 priority mask
+#define ADC_SSPRI_SS1_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS1_2ND       0x00000010  // Second priority
+#define ADC_SSPRI_SS1_3RD       0x00000020  // Third priority
+#define ADC_SSPRI_SS1_4TH       0x00000030  // Fourth priority
+#define ADC_SSPRI_SS0_M         0x00000003  // Sequencer 0 priority mask
+#define ADC_SSPRI_SS0_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS0_2ND       0x00000001  // Second priority
+#define ADC_SSPRI_SS0_3RD       0x00000002  // Third priority
+#define ADC_SSPRI_SS0_4TH       0x00000003  // Fourth priority
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_PSSI register.
+//
+//*****************************************************************************
+#define ADC_PSSI_GSYNC          0x80000000  // Global Synchronize.
+#define ADC_PSSI_SYNCWAIT       0x08000000  // Synchronize Wait.
+#define ADC_PSSI_SS3            0x00000008  // Trigger sample sequencer 3
+#define ADC_PSSI_SS2            0x00000004  // Trigger sample sequencer 2
+#define ADC_PSSI_SS1            0x00000002  // Trigger sample sequencer 1
+#define ADC_PSSI_SS0            0x00000001  // Trigger sample sequencer 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_SAC register.
+//
+//*****************************************************************************
+#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control.
+#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
+#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
+#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
+#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
+#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
+#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
+#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_TMLB_CNT_M   0x000003C0  // Continuous Sample Counter.
+#define ADC_SSFIFO_TMLB_CONT    0x00000020  // Continuation Sample Indicator.
+#define ADC_SSFIFO_TMLB_DIFF    0x00000010  // Differential Sample Indicator.
+#define ADC_SSFIFO_TMLB_TS      0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_SSFIFO_TMLB_MUX_M   0x00000007  // Analog Input Indicator.
+#define ADC_SSFIFO_TMLB_CNT_S   6           // Sample counter shift
+#define ADC_SSFIFO_TMLB_MUX_S   0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_TMLB register.
+//
+//*****************************************************************************
+#define ADC_TMLB_LB             0x00000001  // Loopback control signals
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX0_MUX7_M       0xF0000000  // 8th Sample Input Select.
+#define ADC_SSMUX0_MUX6_M       0x0F000000  // 7th Sample Input Select.
+#define ADC_SSMUX0_MUX5_M       0x00F00000  // 6th Sample Input Select.
+#define ADC_SSMUX0_MUX4_M       0x000F0000  // 5th Sample Input Select.
+#define ADC_SSMUX0_MUX3_M       0x0000F000  // 4th Sample Input Select.
+#define ADC_SSMUX0_MUX2_M       0x00000F00  // 3rd Sample Input Select.
+#define ADC_SSMUX0_MUX1_M       0x000000F0  // 2nd Sample Input Select.
+#define ADC_SSMUX0_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX0_MUX7_S       28
+#define ADC_SSMUX0_MUX6_S       24
+#define ADC_SSMUX0_MUX5_S       20
+#define ADC_SSMUX0_MUX4_S       16
+#define ADC_SSMUX0_MUX3_S       12
+#define ADC_SSMUX0_MUX2_S       8
+#define ADC_SSMUX0_MUX1_S       4
+#define ADC_SSMUX0_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable.
+#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence.
+#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Diff Input Select.
+#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable.
+#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence.
+#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Diff Input Select.
+#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable.
+#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence.
+#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Diff Input Select.
+#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable.
+#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence.
+#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Diff Input Select.
+#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO0_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT0_HPTR_S     4
+#define ADC_SSFSTAT0_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX1_MUX3_M       0x0000F000  // 4th Sample Input Select.
+#define ADC_SSMUX1_MUX2_M       0x00000F00  // 3rd Sample Input Select.
+#define ADC_SSMUX1_MUX1_M       0x000000F0  // 2nd Sample Input Select.
+#define ADC_SSMUX1_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX1_MUX3_S       12
+#define ADC_SSMUX1_MUX2_S       8
+#define ADC_SSMUX1_MUX1_S       4
+#define ADC_SSMUX1_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO1_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT1_HPTR_S     4
+#define ADC_SSFSTAT1_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX2_MUX3_M       0x0000F000  // 4th Sample Input Select.
+#define ADC_SSMUX2_MUX2_M       0x00000F00  // 3rd Sample Input Select.
+#define ADC_SSMUX2_MUX1_M       0x000000F0  // 2nd Sample Input Select.
+#define ADC_SSMUX2_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX2_MUX3_S       12
+#define ADC_SSMUX2_MUX2_S       8
+#define ADC_SSMUX2_MUX1_S       4
+#define ADC_SSMUX2_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO2_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT2_HPTR_S     4
+#define ADC_SSFSTAT2_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX3_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX3_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL3_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL3_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL3_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO3_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT3_HPTR_S     4
+#define ADC_SSFSTAT3_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC0 register.
+//
+//*****************************************************************************
+#define ADC_SSDC0_S7DCSEL_M     0xF0000000  // Sample 7 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S6DCSEL_M     0x0F000000  // Sample 6 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S5DCSEL_M     0x00F00000  // Sample 5 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S4DCSEL_M     0x000F0000  // Sample 4 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S6DCSEL_S     24
+#define ADC_SSDC0_S5DCSEL_S     20
+#define ADC_SSDC0_S4DCSEL_S     16
+#define ADC_SSDC0_S3DCSEL_S     12
+#define ADC_SSDC0_S2DCSEL_S     8
+#define ADC_SSDC0_S1DCSEL_S     4
+#define ADC_SSDC0_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC1 register.
+//
+//*****************************************************************************
+#define ADC_SSDC1_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S2DCSEL_S     8
+#define ADC_SSDC1_S1DCSEL_S     4
+#define ADC_SSDC1_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC2 register.
+//
+//*****************************************************************************
+#define ADC_SSDC2_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S2DCSEL_S     8
+#define ADC_SSDC2_S1DCSEL_S     4
+#define ADC_SSDC2_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC3 register.
+//
+//*****************************************************************************
+#define ADC_SSDC3_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCISC register.
+//
+//*****************************************************************************
+#define ADC_DCISC_DCINT7        0x00000080  // Digital Comparator 7 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT6        0x00000040  // Digital Comparator 6 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT5        0x00000020  // Digital Comparator 5 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT4        0x00000010  // Digital Comparator 4 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT3        0x00000008  // Digital Comparator 3 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT2        0x00000004  // Digital Comparator 2 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT1        0x00000002  // Digital Comparator 1 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT0        0x00000001  // Digital Comparator 0 Interrupt
+                                            // Status and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP0 register.
+//
+//*****************************************************************************
+#define ADC_SSOP0_S7DCOP        0x10000000  // Sample 7 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S6DCOP        0x01000000  // Sample 6 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S5DCOP        0x00100000  // Sample 5 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S4DCOP        0x00010000  // Sample 4 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S3DCOP        0x00001000  // Sample 3 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP1 register.
+//
+//*****************************************************************************
+#define ADC_SSOP1_S3DCOP        0x00001000  // Sample 7 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP1_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP1_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP1_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP2 register.
+//
+//*****************************************************************************
+#define ADC_SSOP2_S3DCOP        0x00001000  // Sample 7 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP2_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP2_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP2_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP3 register.
+//
+//*****************************************************************************
+#define ADC_SSOP3_S0DCOP        0x00000001  // Sample 7 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCRIC register.
+//
+//*****************************************************************************
+#define ADC_DCRIC_DCTRIG7       0x00800000  // Digital Comparator Trigger 7.
+#define ADC_DCRIC_DCTRIG6       0x00400000  // Digital Comparator Trigger 6.
+#define ADC_DCRIC_DCTRIG5       0x00200000  // Digital Comparator Trigger 5.
+#define ADC_DCRIC_DCTRIG4       0x00100000  // Digital Comparator Trigger 4.
+#define ADC_DCRIC_DCTRIG3       0x00080000  // Digital Comparator Trigger 3.
+#define ADC_DCRIC_DCTRIG2       0x00040000  // Digital Comparator Trigger 2.
+#define ADC_DCRIC_DCTRIG1       0x00020000  // Digital Comparator Trigger 1.
+#define ADC_DCRIC_DCTRIG0       0x00010000  // Digital Comparator Trigger 0.
+#define ADC_DCRIC_DCINT7        0x00000080  // Digital Comparator Interrupt 7.
+#define ADC_DCRIC_DCINT6        0x00000040  // Digital Comparator Interrupt 6.
+#define ADC_DCRIC_DCINT5        0x00000020  // Digital Comparator Interrupt 5.
+#define ADC_DCRIC_DCINT4        0x00000010  // Digital Comparator Interrupt 4.
+#define ADC_DCRIC_DCINT3        0x00000008  // Digital Comparator Interrupt 3.
+#define ADC_DCRIC_DCINT2        0x00000004  // Digital Comparator Interrupt 2.
+#define ADC_DCRIC_DCINT1        0x00000002  // Digital Comparator Interrupt 1.
+#define ADC_DCRIC_DCINT0        0x00000001  // Digital Comparator Interrupt 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL0 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL0_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL0_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL0_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL0_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL0_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL0_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL0_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL0_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL0_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL0_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL0_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL0_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL0_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL0_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL0_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL0_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL0_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL0_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL0_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL0_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL1 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL1_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL1_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL1_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL1_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL1_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL1_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL1_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL1_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL1_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL1_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL1_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL1_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL1_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL1_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL1_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL1_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL1_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL1_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL1_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL1_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL2 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL2_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL2_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL2_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL2_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL2_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL2_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL2_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL2_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL2_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL2_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL2_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL2_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL2_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL2_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL2_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL2_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL2_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL2_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL2_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL2_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL3 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL3_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL3_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL3_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL3_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL3_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL3_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL3_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL3_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL3_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL3_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL3_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL3_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL3_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL3_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL3_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL3_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL3_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL3_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL3_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL3_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL4 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL4_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL4_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL4_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL4_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL4_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL4_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL4_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL4_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL4_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL4_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL4_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL4_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL4_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL4_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL4_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL4_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL4_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL4_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL4_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL4_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL5 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL5_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL5_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL5_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL5_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL5_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL5_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL5_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL5_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL5_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL5_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL5_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL5_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL5_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL5_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL5_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL5_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL5_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL5_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL5_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL5_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL6 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL6_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL6_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL6_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL6_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL6_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL6_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL6_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL6_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL6_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL6_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL6_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL6_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL6_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL6_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL6_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL6_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL6_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL6_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL6_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL6_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL7 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL7_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL7_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL7_CTC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL7_CTC_MID      0x00000400  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL7_CTC_HIGH     0x00000C00  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL7_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL7_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL7_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL7_CTM_HALWAYS  0x00000200  // Hysteresis always
+#define ADC_DCCTL7_CTM_HONCE    0x00000300  // Hysteresis once
+#define ADC_DCCTL7_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL7_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL7_CIC_LOW      0x00000000  // CV &lt; COMP0 and &lt; COMP1
+#define ADC_DCCTL7_CIC_MID      0x00000004  // COMP0 &gt;= CV &lt; COMP1
+#define ADC_DCCTL7_CIC_HIGH     0x0000000C  // CV &lt;= COMP0 and &lt;= COMP1
+#define ADC_DCCTL7_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL7_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL7_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL7_CIM_HALWAYS  0x00000002  // Hysteresis always
+#define ADC_DCCTL7_CIM_HONCE    0x00000003  // Hysteresis once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP0 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP0_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP0_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP0_COMP1_S      16
+#define ADC_DCCMP0_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP1 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP1_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP1_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP1_COMP1_S      16
+#define ADC_DCCMP1_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP2 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP2_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP2_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP2_COMP1_S      16
+#define ADC_DCCMP2_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP3 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP3_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP3_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP3_COMP1_S      16
+#define ADC_DCCMP3_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP4 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP4_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP4_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP4_COMP1_S      16
+#define ADC_DCCMP4_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP5 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP5_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP5_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP5_COMP1_S      16
+#define ADC_DCCMP5_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP6 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP6_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP6_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP6_COMP1_S      16
+#define ADC_DCCMP6_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP7 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP7_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP7_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP7_COMP1_S      16
+#define ADC_DCCMP7_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_CTL register.
+//
+//*****************************************************************************
+#define ADC_CTL_VREF            0x00000001  // Voltage Reference Select.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the ADC sequence register offsets.
+//
+//*****************************************************************************
+#define ADC_O_SEQ               0x00000040  // Offset to the first sequence
+#define ADC_O_SEQ_STEP          0x00000020  // Increment to the next sequence
+#define ADC_O_X_SSFSTAT         0x0000000C  // FIFO status register
+#define ADC_O_X_SSFIFO          0x00000008  // Result FIFO register
+#define ADC_O_X_SSCTL           0x00000004  // Sample sequence control register
+#define ADC_O_X_SSMUX           0x00000000  // Multiplexer select register
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_EMUX
+// register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_MASK       0x0000F000  // Event mux 3 mask
+#define ADC_EMUX_EM2_MASK       0x00000F00  // Event mux 2 mask
+#define ADC_EMUX_EM1_MASK       0x000000F0  // Event mux 1 mask
+#define ADC_EMUX_EM0_MASK       0x0000000F  // Event mux 0 mask
+#define ADC_EMUX_EM3_SHIFT      12          // The shift for the fourth event
+#define ADC_EMUX_EM2_SHIFT      8           // The shift for the third event
+#define ADC_EMUX_EM1_SHIFT      4           // The shift for the second event
+#define ADC_EMUX_EM0_SHIFT      0           // The shift for the first event
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSPRI
+// register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_MASK      0x00003000  // Sequencer 3 priority mask
+#define ADC_SSPRI_SS2_MASK      0x00000300  // Sequencer 2 priority mask
+#define ADC_SSPRI_SS1_MASK      0x00000030  // Sequencer 1 priority mask
+#define ADC_SSPRI_SS0_MASK      0x00000003  // Sequencer 0 priority mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSMUX0,
+// ADC_SSMUX1, ADC_SSMUX2, and ADC_SSMUX3 registers. Not all fields are present
+// in all registers.
+//
+//*****************************************************************************
+#define ADC_SSMUX_MUX7_MASK     0x70000000  // 8th mux select mask
+#define ADC_SSMUX_MUX6_MASK     0x07000000  // 7th mux select mask
+#define ADC_SSMUX_MUX5_MASK     0x00700000  // 6th mux select mask
+#define ADC_SSMUX_MUX4_MASK     0x00070000  // 5th mux select mask
+#define ADC_SSMUX_MUX3_MASK     0x00007000  // 4th mux select mask
+#define ADC_SSMUX_MUX2_MASK     0x00000700  // 3rd mux select mask
+#define ADC_SSMUX_MUX1_MASK     0x00000070  // 2nd mux select mask
+#define ADC_SSMUX_MUX0_MASK     0x00000007  // 1st mux select mask
+#define ADC_SSMUX_MUX7_SHIFT    28
+#define ADC_SSMUX_MUX6_SHIFT    24
+#define ADC_SSMUX_MUX5_SHIFT    20
+#define ADC_SSMUX_MUX4_SHIFT    16
+#define ADC_SSMUX_MUX3_SHIFT    12
+#define ADC_SSMUX_MUX2_SHIFT    8
+#define ADC_SSMUX_MUX1_SHIFT    4
+#define ADC_SSMUX_MUX0_SHIFT    0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSCTL0,
+// ADC_SSCTL1, ADC_SSCTL2, and ADC_SSCTL3 registers. Not all fields are present
+// in all registers.
+//
+//*****************************************************************************
+#define ADC_SSCTL_TS7           0x80000000  // 8th temperature sensor select
+#define ADC_SSCTL_IE7           0x40000000  // 8th interrupt enable
+#define ADC_SSCTL_END7          0x20000000  // 8th sequence end select
+#define ADC_SSCTL_D7            0x10000000  // 8th differential select
+#define ADC_SSCTL_TS6           0x08000000  // 7th temperature sensor select
+#define ADC_SSCTL_IE6           0x04000000  // 7th interrupt enable
+#define ADC_SSCTL_END6          0x02000000  // 7th sequence end select
+#define ADC_SSCTL_D6            0x01000000  // 7th differential select
+#define ADC_SSCTL_TS5           0x00800000  // 6th temperature sensor select
+#define ADC_SSCTL_IE5           0x00400000  // 6th interrupt enable
+#define ADC_SSCTL_END5          0x00200000  // 6th sequence end select
+#define ADC_SSCTL_D5            0x00100000  // 6th differential select
+#define ADC_SSCTL_TS4           0x00080000  // 5th temperature sensor select
+#define ADC_SSCTL_IE4           0x00040000  // 5th interrupt enable
+#define ADC_SSCTL_END4          0x00020000  // 5th sequence end select
+#define ADC_SSCTL_D4            0x00010000  // 5th differential select
+#define ADC_SSCTL_TS3           0x00008000  // 4th temperature sensor select
+#define ADC_SSCTL_IE3           0x00004000  // 4th interrupt enable
+#define ADC_SSCTL_END3          0x00002000  // 4th sequence end select
+#define ADC_SSCTL_D3            0x00001000  // 4th differential select
+#define ADC_SSCTL_TS2           0x00000800  // 3rd temperature sensor select
+#define ADC_SSCTL_IE2           0x00000400  // 3rd interrupt enable
+#define ADC_SSCTL_END2          0x00000200  // 3rd sequence end select
+#define ADC_SSCTL_D2            0x00000100  // 3rd differential select
+#define ADC_SSCTL_TS1           0x00000080  // 2nd temperature sensor select
+#define ADC_SSCTL_IE1           0x00000040  // 2nd interrupt enable
+#define ADC_SSCTL_END1          0x00000020  // 2nd sequence end select
+#define ADC_SSCTL_D1            0x00000010  // 2nd differential select
+#define ADC_SSCTL_TS0           0x00000008  // 1st temperature sensor select
+#define ADC_SSCTL_IE0           0x00000004  // 1st interrupt enable
+#define ADC_SSCTL_END0          0x00000002  // 1st sequence end select
+#define ADC_SSCTL_D0            0x00000001  // 1st differential select
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSFIFO0,
+// ADC_SSFIFO1, ADC_SSFIFO2, and ADC_SSFIFO3 registers.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_DATA_MASK    0x000003FF  // Sample data
+#define ADC_SSFIFO_DATA_SHIFT   0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSFSTAT0,
+// ADC_SSFSTAT1, ADC_SSFSTAT2, and ADC_SSFSTAT3 registers.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT_FULL        0x00001000  // FIFO is full
+#define ADC_SSFSTAT_EMPTY       0x00000100  // FIFO is empty
+#define ADC_SSFSTAT_HPTR        0x000000F0  // FIFO head pointer
+#define ADC_SSFSTAT_TPTR        0x0000000F  // FIFO tail pointer
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the the interpretation of the data
+// in the SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_TMLB_CNT_M          0x000003C0  // Continuous Sample Counter.
+#define ADC_TMLB_CONT           0x00000020  // Continuation Sample Indicator.
+#define ADC_TMLB_DIFF           0x00000010  // Differential Sample Indicator.
+#define ADC_TMLB_TS             0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_TMLB_MUX_M          0x00000007  // Analog Input Indicator.
+#define ADC_TMLB_CNT_S          6           // Sample counter shift
+#define ADC_TMLB_MUX_S          0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the loopback ADC
+// data.
+//
+//*****************************************************************************
+#define ADC_LB_CNT_MASK         0x000003C0  // Sample counter mask
+#define ADC_LB_CONT             0x00000020  // Continuation sample
+#define ADC_LB_DIFF             0x00000010  // Differential sample
+#define ADC_LB_TS               0x00000008  // Temperature sensor sample
+#define ADC_LB_MUX_MASK         0x00000007  // Input channel number mask
+#define ADC_LB_CNT_SHIFT        6           // Sample counter shift
+#define ADC_LB_MUX_SHIFT        0           // Input channel number shift
+
+#endif
+
+#endif // __HW_ADC_H__


Property changes on: trunk/src/platform/lm3s/hw_adc.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_can.h
===================================================================
--- trunk/src/platform/lm3s/hw_can.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_can.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,756 @@
+//*****************************************************************************
+//
+// hw_can.h - Defines and macros used when accessing the can.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_CAN_H__
+#define __HW_CAN_H__
+
+//*****************************************************************************
+//
+// The following are defines for the CAN register offsets.
+//
+//*****************************************************************************
+#define CAN_O_CTL               0x00000000  // Control register
+#define CAN_O_STS               0x00000004  // Status register
+#define CAN_O_ERR               0x00000008  // Error register
+#define CAN_O_BIT               0x0000000C  // Bit Timing register
+#define CAN_O_INT               0x00000010  // Interrupt register
+#define CAN_O_TST               0x00000014  // Test register
+#define CAN_O_BRPE              0x00000018  // Baud Rate Prescaler register
+#define CAN_O_IF1CRQ            0x00000020  // Interface 1 Command Request reg.
+#define CAN_O_IF1CMSK           0x00000024  // Interface 1 Command Mask reg.
+#define CAN_O_IF1MSK1           0x00000028  // Interface 1 Mask 1 register
+#define CAN_O_IF1MSK2           0x0000002C  // Interface 1 Mask 2 register
+#define CAN_O_IF1ARB1           0x00000030  // Interface 1 Arbitration 1 reg.
+#define CAN_O_IF1ARB2           0x00000034  // Interface 1 Arbitration 2 reg.
+#define CAN_O_IF1MCTL           0x00000038  // Interface 1 Message Control reg.
+#define CAN_O_IF1DA1            0x0000003C  // Interface 1 DataA 1 register
+#define CAN_O_IF1DA2            0x00000040  // Interface 1 DataA 2 register
+#define CAN_O_IF1DB1            0x00000044  // Interface 1 DataB 1 register
+#define CAN_O_IF1DB2            0x00000048  // Interface 1 DataB 2 register
+#define CAN_O_IF2CRQ            0x00000080  // Interface 2 Command Request reg.
+#define CAN_O_IF2CMSK           0x00000084  // Interface 2 Command Mask reg.
+#define CAN_O_IF2MSK1           0x00000088  // Interface 2 Mask 1 register
+#define CAN_O_IF2MSK2           0x0000008C  // Interface 2 Mask 2 register
+#define CAN_O_IF2ARB1           0x00000090  // Interface 2 Arbitration 1 reg.
+#define CAN_O_IF2ARB2           0x00000094  // Interface 2 Arbitration 2 reg.
+#define CAN_O_IF2MCTL           0x00000098  // Interface 2 Message Control reg.
+#define CAN_O_IF2DA1            0x0000009C  // Interface 2 DataA 1 register
+#define CAN_O_IF2DA2            0x000000A0  // Interface 2 DataA 2 register
+#define CAN_O_IF2DB1            0x000000A4  // Interface 2 DataB 1 register
+#define CAN_O_IF2DB2            0x000000A8  // Interface 2 DataB 2 register
+#define CAN_O_TXRQ1             0x00000100  // Transmission Request 1 register
+#define CAN_O_TXRQ2             0x00000104  // Transmission Request 2 register
+#define CAN_O_NWDA1             0x00000120  // New Data 1 register
+#define CAN_O_NWDA2             0x00000124  // New Data 2 register
+#define CAN_O_MSG1INT           0x00000140  // CAN Message 1 Interrupt Pending
+#define CAN_O_MSG2INT           0x00000144  // CAN Message 2 Interrupt Pending
+#define CAN_O_MSG1VAL           0x00000160  // CAN Message 1 Valid
+#define CAN_O_MSG2VAL           0x00000164  // CAN Message 2 Valid
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_CTL register.
+//
+//*****************************************************************************
+#define CAN_CTL_TEST            0x00000080  // Test mode enable
+#define CAN_CTL_CCE             0x00000040  // Configuration change enable
+#define CAN_CTL_DAR             0x00000020  // Disable automatic retransmission
+#define CAN_CTL_EIE             0x00000008  // Error interrupt enable
+#define CAN_CTL_SIE             0x00000004  // Status change interrupt enable
+#define CAN_CTL_IE              0x00000002  // Module interrupt enable
+#define CAN_CTL_INIT            0x00000001  // Initialization
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_STS register.
+//
+//*****************************************************************************
+#define CAN_STS_BOFF            0x00000080  // Bus Off status
+#define CAN_STS_EWARN           0x00000040  // Error Warning status
+#define CAN_STS_EPASS           0x00000020  // Error Passive status
+#define CAN_STS_RXOK            0x00000010  // Received Message Successful
+#define CAN_STS_TXOK            0x00000008  // Transmitted Message Successful
+#define CAN_STS_LEC_M           0x00000007  // Last Error Code
+#define CAN_STS_LEC_NONE        0x00000000  // No error
+#define CAN_STS_LEC_STUFF       0x00000001  // Stuff error
+#define CAN_STS_LEC_FORM        0x00000002  // Form(at) error
+#define CAN_STS_LEC_ACK         0x00000003  // Ack error
+#define CAN_STS_LEC_BIT1        0x00000004  // Bit 1 error
+#define CAN_STS_LEC_BIT0        0x00000005  // Bit 0 error
+#define CAN_STS_LEC_CRC         0x00000006  // CRC error
+#define CAN_STS_LEC_NOEVENT     0x00000007  // Unused
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_ERR register.
+//
+//*****************************************************************************
+#define CAN_ERR_RP              0x00008000  // Receive error passive status
+#define CAN_ERR_REC_M           0x00007F00  // Receive Error Counter.
+#define CAN_ERR_TEC_M           0x000000FF  // Transmit Error Counter.
+#define CAN_ERR_REC_S           8           // Receive error counter bit pos
+#define CAN_ERR_TEC_S           0           // Transmit error counter bit pos
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_BIT register.
+//
+//*****************************************************************************
+#define CAN_BIT_TSEG2_M         0x00007000  // Time Segment after Sample Point.
+#define CAN_BIT_TSEG1_M         0x00000F00  // Time Segment Before Sample
+                                            // Point.
+#define CAN_BIT_SJW_M           0x000000C0  // (Re)Synchronization Jump Width.
+#define CAN_BIT_BRP_M           0x0000003F  // Baud Rate Prescalar.
+#define CAN_BIT_TSEG2_S         12
+#define CAN_BIT_TSEG1_S         8
+#define CAN_BIT_SJW_S           6
+#define CAN_BIT_BRP_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_INT register.
+//
+//*****************************************************************************
+#define CAN_INT_INTID_M         0x0000FFFF  // Interrupt Identifier.
+#define CAN_INT_INTID_NONE      0x00000000  // No Interrupt Pending
+#define CAN_INT_INTID_STATUS    0x00008000  // Status Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_TST register.
+//
+//*****************************************************************************
+#define CAN_TST_RX              0x00000080  // CAN_RX pin status
+#define CAN_TST_TX_M            0x00000060  // Overide control of CAN_TX pin
+#define CAN_TST_TX_CANCTL       0x00000000  // CAN core controls CAN_TX
+#define CAN_TST_TX_SAMPLE       0x00000020  // Sample Point on CAN_TX
+#define CAN_TST_TX_DOMINANT     0x00000040  // Dominant value on CAN_TX
+#define CAN_TST_TX_RECESSIVE    0x00000060  // Recessive value on CAN_TX
+#define CAN_TST_LBACK           0x00000010  // Loop back mode
+#define CAN_TST_SILENT          0x00000008  // Silent mode
+#define CAN_TST_BASIC           0x00000004  // Basic mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_BRPE register.
+//
+//*****************************************************************************
+#define CAN_BRPE_BRPE_M         0x0000000F  // Baud Rate Prescalar Extension.
+#define CAN_BRPE_BRPE_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_TXRQ1 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ1_TXRQST_M      0x0000FFFF  // Transmission Request Bits.
+#define CAN_TXRQ1_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_TXRQ2 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ2_TXRQST_M      0x0000FFFF  // Transmission Request Bits.
+#define CAN_TXRQ2_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_NWDA1 register.
+//
+//*****************************************************************************
+#define CAN_NWDA1_NEWDAT_M      0x0000FFFF  // New Data Bits.
+#define CAN_NWDA1_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_NWDA2 register.
+//
+//*****************************************************************************
+#define CAN_NWDA2_NEWDAT_M      0x0000FFFF  // New Data Bits.
+#define CAN_NWDA2_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF1CRQ_BUSY         0x00008000  // Busy Flag.
+#define CAN_IF1CRQ_MNUM_M       0x0000003F  // Message Number.
+#define CAN_IF1CRQ_MNUM_RSVD    0x00000000  // 0 is not a valid message number;
+                                            // it is interpreted as 0x20, or
+                                            // object 32.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF1CMSK_WRNRD       0x00000080  // Write, Not Read.
+#define CAN_IF1CMSK_MASK        0x00000040  // Access Mask Bits.
+#define CAN_IF1CMSK_ARB         0x00000020  // Access Arbitration Bits.
+#define CAN_IF1CMSK_CONTROL     0x00000010  // Access Control Bits.
+#define CAN_IF1CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit.
+#define CAN_IF1CMSK_NEWDAT      0x00000004  // Access New Data.
+#define CAN_IF1CMSK_TXRQST      0x00000004  // Access Transmission Request.
+#define CAN_IF1CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3.
+#define CAN_IF1CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask.
+#define CAN_IF1MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK2_MXTD        0x00008000  // Mask Extended Identifier.
+#define CAN_IF1MSK2_MDIR        0x00004000  // Mask Message Direction.
+#define CAN_IF1MSK2_IDMSK_M     0x00001FFF  // Identifier Mask.
+#define CAN_IF1MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB1_ID_M        0x0000FFFF  // Message Identifier.
+#define CAN_IF1ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB2_MSGVAL      0x00008000  // Message Valid.
+#define CAN_IF1ARB2_XTD         0x00004000  // Extended Identifier.
+#define CAN_IF1ARB2_DIR         0x00002000  // Message Direction.
+#define CAN_IF1ARB2_ID_M        0x00001FFF  // Message Identifier.
+#define CAN_IF1ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF1MCTL_NEWDAT      0x00008000  // New Data.
+#define CAN_IF1MCTL_MSGLST      0x00004000  // Message Lost.
+#define CAN_IF1MCTL_INTPND      0x00002000  // Interrupt Pending.
+#define CAN_IF1MCTL_UMASK       0x00001000  // Use Acceptance Mask.
+#define CAN_IF1MCTL_TXIE        0x00000800  // Transmit Interrupt Enable.
+#define CAN_IF1MCTL_RXIE        0x00000400  // Receive Interrupt Enable.
+#define CAN_IF1MCTL_RMTEN       0x00000200  // Remote Enable.
+#define CAN_IF1MCTL_TXRQST      0x00000100  // Transmit Request.
+#define CAN_IF1MCTL_EOB         0x00000080  // End of Buffer.
+#define CAN_IF1MCTL_DLC_M       0x0000000F  // Data Length Code.
+#define CAN_IF1MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF2CRQ_BUSY         0x00008000  // Busy Flag.
+#define CAN_IF2CRQ_MNUM_M       0x0000003F  // Message Number.
+#define CAN_IF2CRQ_MNUM_RSVD    0x00000000  // 0 is not a valid message number;
+                                            // it is interpreted as 0x20, or
+                                            // object 32.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF2CMSK_WRNRD       0x00000080  // Write, Not Read.
+#define CAN_IF2CMSK_MASK        0x00000040  // Access Mask Bits.
+#define CAN_IF2CMSK_ARB         0x00000020  // Access Arbitration Bits.
+#define CAN_IF2CMSK_CONTROL     0x00000010  // Access Control Bits.
+#define CAN_IF2CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit.
+#define CAN_IF2CMSK_NEWDAT      0x00000004  // Access New Data.
+#define CAN_IF2CMSK_TXRQST      0x00000004  // Access Transmission Request.
+#define CAN_IF2CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3.
+#define CAN_IF2CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask.
+#define CAN_IF2MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK2_MXTD        0x00008000  // Mask Extended Identifier.
+#define CAN_IF2MSK2_MDIR        0x00004000  // Mask Message Direction.
+#define CAN_IF2MSK2_IDMSK_M     0x00001FFF  // Identifier Mask.
+#define CAN_IF2MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB1_ID_M        0x0000FFFF  // Message Identifier.
+#define CAN_IF2ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB2_MSGVAL      0x00008000  // Message Valid.
+#define CAN_IF2ARB2_XTD         0x00004000  // Extended Identifier.
+#define CAN_IF2ARB2_DIR         0x00002000  // Message Direction.
+#define CAN_IF2ARB2_ID_M        0x00001FFF  // Message Identifier.
+#define CAN_IF2ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF2MCTL_NEWDAT      0x00008000  // New Data.
+#define CAN_IF2MCTL_MSGLST      0x00004000  // Message Lost.
+#define CAN_IF2MCTL_INTPND      0x00002000  // Interrupt Pending.
+#define CAN_IF2MCTL_UMASK       0x00001000  // Use Acceptance Mask.
+#define CAN_IF2MCTL_TXIE        0x00000800  // Transmit Interrupt Enable.
+#define CAN_IF2MCTL_RXIE        0x00000400  // Receive Interrupt Enable.
+#define CAN_IF2MCTL_RMTEN       0x00000200  // Remote Enable.
+#define CAN_IF2MCTL_TXRQST      0x00000100  // Transmit Request.
+#define CAN_IF2MCTL_EOB         0x00000080  // End of Buffer.
+#define CAN_IF2MCTL_DLC_M       0x0000000F  // Data Length Code.
+#define CAN_IF2MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1INT register.
+//
+//*****************************************************************************
+#define CAN_MSG1INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits.
+#define CAN_MSG1INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2INT register.
+//
+//*****************************************************************************
+#define CAN_MSG2INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits.
+#define CAN_MSG2INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG1VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits.
+#define CAN_MSG1VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG2VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits.
+#define CAN_MSG2VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the CAN register offsets.
+//
+//*****************************************************************************
+#define CAN_O_MSGINT1           0x00000140  // Intr. Pending in Msg Obj 1 reg.
+#define CAN_O_MSGINT2           0x00000144  // Intr. Pending in Msg Obj 2 reg.
+#define CAN_O_MSGVAL1           0x00000160  // Message Valid in Msg Obj 1 reg.
+#define CAN_O_MSGVAL2           0x00000164  // Message Valid in Msg Obj 2 reg.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the reset values of the can
+// registers.
+//
+//*****************************************************************************
+#define CAN_RV_IF1MSK2          0x0000FFFF
+#define CAN_RV_IF1MSK1          0x0000FFFF
+#define CAN_RV_IF2MSK1          0x0000FFFF
+#define CAN_RV_IF2MSK2          0x0000FFFF
+#define CAN_RV_BIT              0x00002301
+#define CAN_RV_CTL              0x00000001
+#define CAN_RV_IF1CRQ           0x00000001
+#define CAN_RV_IF2CRQ           0x00000001
+#define CAN_RV_TXRQ2            0x00000000
+#define CAN_RV_IF2DB1           0x00000000
+#define CAN_RV_INT              0x00000000
+#define CAN_RV_IF1DB2           0x00000000
+#define CAN_RV_BRPE             0x00000000
+#define CAN_RV_IF2DA2           0x00000000
+#define CAN_RV_MSGVAL2          0x00000000
+#define CAN_RV_TXRQ1            0x00000000
+#define CAN_RV_IF1MCTL          0x00000000
+#define CAN_RV_IF1DB1           0x00000000
+#define CAN_RV_STS              0x00000000
+#define CAN_RV_MSGINT1          0x00000000
+#define CAN_RV_IF1DA2           0x00000000
+#define CAN_RV_TST              0x00000000
+#define CAN_RV_IF1ARB1          0x00000000
+#define CAN_RV_IF1ARB2          0x00000000
+#define CAN_RV_NWDA2            0x00000000
+#define CAN_RV_IF2CMSK          0x00000000
+#define CAN_RV_NWDA1            0x00000000
+#define CAN_RV_IF1DA1           0x00000000
+#define CAN_RV_IF2DA1           0x00000000
+#define CAN_RV_IF2MCTL          0x00000000
+#define CAN_RV_MSGVAL1          0x00000000
+#define CAN_RV_IF1CMSK          0x00000000
+#define CAN_RV_ERR              0x00000000
+#define CAN_RV_IF2ARB2          0x00000000
+#define CAN_RV_MSGINT2          0x00000000
+#define CAN_RV_IF2ARB1          0x00000000
+#define CAN_RV_IF2DB2           0x00000000
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_STS
+// register.
+//
+//*****************************************************************************
+#define CAN_STS_LEC_MSK         0x00000007  // Last Error Code
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_ERR
+// register.
+//
+//*****************************************************************************
+#define CAN_ERR_REC_MASK        0x00007F00  // Receive error counter status
+#define CAN_ERR_TEC_MASK        0x000000FF  // Transmit error counter status
+#define CAN_ERR_REC_SHIFT       8           // Receive error counter bit pos
+#define CAN_ERR_TEC_SHIFT       0           // Transmit error counter bit pos
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_BIT
+// register.
+//
+//*****************************************************************************
+#define CAN_BIT_TSEG2           0x00007000  // Time segment after sample point
+#define CAN_BIT_TSEG1           0x00000F00  // Time segment before sample point
+#define CAN_BIT_SJW             0x000000C0  // (Re)Synchronization jump width
+#define CAN_BIT_BRP             0x0000003F  // Baud rate prescaler
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_INT
+// register.
+//
+//*****************************************************************************
+#define CAN_INT_INTID_MSK       0x0000FFFF  // Interrupt Identifier
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_TST
+// register.
+//
+//*****************************************************************************
+#define CAN_TST_TX_MSK          0x00000060  // Overide control of CAN_TX pin
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_BRPE
+// register.
+//
+//*****************************************************************************
+#define CAN_BRPE_BRPE           0x0000000F  // Baud rate prescaler extension
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1CRQ
+// and CAN_IF1CRQ registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFCRQ_BUSY          0x00008000  // Busy flag status
+#define CAN_IFCRQ_MNUM_MSK      0x0000003F  // Message Number
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1CMSK
+// and CAN_IF2CMSK registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFCMSK_WRNRD        0x00000080  // Write, not Read
+#define CAN_IFCMSK_MASK         0x00000040  // Access Mask Bits
+#define CAN_IFCMSK_ARB          0x00000020  // Access Arbitration Bits
+#define CAN_IFCMSK_CONTROL      0x00000010  // Access Control Bits
+#define CAN_IFCMSK_CLRINTPND    0x00000008  // Clear interrupt pending Bit
+#define CAN_IFCMSK_TXRQST       0x00000004  // Access Tx request bit (WRNRD=1)
+#define CAN_IFCMSK_NEWDAT       0x00000004  // Access New Data bit (WRNRD=0)
+#define CAN_IFCMSK_DATAA        0x00000002  // DataA access - bytes 0 to 3
+#define CAN_IFCMSK_DATAB        0x00000001  // DataB access - bytes 4 to 7
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1MSK1
+// and CAN_IF2MSK1 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFMSK1_MSK          0x0000FFFF  // Identifier Mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1MSK2
+// and CAN_IF2MSK2 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFMSK2_MXTD         0x00008000  // Mask extended identifier
+#define CAN_IFMSK2_MDIR         0x00004000  // Mask message direction
+#define CAN_IFMSK2_MSK          0x00001FFF  // Mask identifier
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1ARB1
+// and CAN_IF2ARB1 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFARB1_ID           0x0000FFFF  // Identifier
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1ARB2
+// and CAN_IF2ARB2 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFARB2_MSGVAL       0x00008000  // Message valid
+#define CAN_IFARB2_XTD          0x00004000  // Extended identifier
+#define CAN_IFARB2_DIR          0x00002000  // Message direction
+#define CAN_IFARB2_ID           0x00001FFF  // Message identifier
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1MCTL
+// and CAN_IF2MCTL registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFMCTL_NEWDAT       0x00008000  // New Data
+#define CAN_IFMCTL_MSGLST       0x00004000  // Message lost
+#define CAN_IFMCTL_INTPND       0x00002000  // Interrupt pending
+#define CAN_IFMCTL_UMASK        0x00001000  // Use acceptance mask
+#define CAN_IFMCTL_TXIE         0x00000800  // Transmit interrupt enable
+#define CAN_IFMCTL_RXIE         0x00000400  // Receive interrupt enable
+#define CAN_IFMCTL_RMTEN        0x00000200  // Remote enable
+#define CAN_IFMCTL_TXRQST       0x00000100  // Transmit request
+#define CAN_IFMCTL_EOB          0x00000080  // End of buffer
+#define CAN_IFMCTL_DLC          0x0000000F  // Data length code
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1DA1
+// and CAN_IF2DA1 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFDA1_DATA          0x0000FFFF  // Data - bytes 1 and 0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1DA2
+// and CAN_IF2DA2 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFDA2_DATA          0x0000FFFF  // Data - bytes 3 and 2
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1DB1
+// and CAN_IF2DB1 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFDB1_DATA          0x0000FFFF  // Data - bytes 5 and 4
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_IF1DB2
+// and CAN_IF2DB2 registers.
+// Note: All bits may not be available in all registers
+//
+//*****************************************************************************
+#define CAN_IFDB2_DATA          0x0000FFFF  // Data - bytes 7 and 6
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_TXRQ1
+// register.
+//
+//*****************************************************************************
+#define CAN_TXRQ1_TXRQST        0x0000FFFF  // Transmission Request Bits
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_TXRQ2
+// register.
+//
+//*****************************************************************************
+#define CAN_TXRQ2_TXRQST        0x0000FFFF  // Transmission Request Bits
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_NWDA1
+// register.
+//
+//*****************************************************************************
+#define CAN_NWDA1_NEWDATA       0x0000FFFF  // New Data Bits
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_NWDA2
+// register.
+//
+//*****************************************************************************
+#define CAN_NWDA2_NEWDATA       0x0000FFFF  // New Data Bits
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_MSGINT1
+// register.
+//
+//*****************************************************************************
+#define CAN_MSGINT1_INTPND      0x0000FFFF  // Interrupt Pending Bits
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_MSGINT2
+// register.
+//
+//*****************************************************************************
+#define CAN_MSGINT2_INTPND      0x0000FFFF  // Interrupt Pending Bits
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_MSGVAL1
+// register.
+//
+//*****************************************************************************
+#define CAN_MSGVAL1_MSGVAL      0x0000FFFF  // Message Valid Bits
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the CAN_MSGVAL2
+// register.
+//
+//*****************************************************************************
+#define CAN_MSGVAL2_MSGVAL      0x0000FFFF  // Message Valid Bits
+
+#endif
+
+#endif // __HW_CAN_H__


Property changes on: trunk/src/platform/lm3s/hw_can.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_comp.h
===================================================================
--- trunk/src/platform/lm3s/hw_comp.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_comp.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,277 @@
+//*****************************************************************************
+//
+// hw_comp.h - Macros used when accessing the comparator hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_COMP_H__
+#define __HW_COMP_H__
+
+//*****************************************************************************
+//
+// The following are defines for the comparator register offsets.
+//
+//*****************************************************************************
+#define COMP_O_ACMIS            0x00000000  // Analog Comparator Masked
+                                            // Interrupt Status
+#define COMP_O_ACRIS            0x00000004  // Analog Comparator Raw Interrupt
+                                            // Status
+#define COMP_O_ACINTEN          0x00000008  // Analog Comparator Interrupt
+                                            // Enable
+#define COMP_O_ACREFCTL         0x00000010  // Analog Comparator Reference
+                                            // Voltage Control
+#define COMP_O_ACSTAT0          0x00000020  // Comp0 status register
+#define COMP_O_ACCTL0           0x00000024  // Comp0 control register
+#define COMP_O_ACSTAT1          0x00000040  // Comp1 status register
+#define COMP_O_ACCTL1           0x00000044  // Comp1 control register
+#define COMP_O_ACSTAT2          0x00000060  // Comp2 status register
+#define COMP_O_ACCTL2           0x00000064  // Comp2 control register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACMIS register.
+//
+//*****************************************************************************
+#define COMP_ACMIS_IN2          0x00000004  // Comparator 2 Masked Interrupt
+                                            // Status.
+#define COMP_ACMIS_IN1          0x00000002  // Comparator 1 Masked Interrupt
+                                            // Status.
+#define COMP_ACMIS_IN0          0x00000001  // Comparator 0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACRIS register.
+//
+//*****************************************************************************
+#define COMP_ACRIS_IN2          0x00000004  // Comparator 2 Interrupt Status.
+#define COMP_ACRIS_IN1          0x00000002  // Comparator 1 Interrupt Status.
+#define COMP_ACRIS_IN0          0x00000001  // Comparator 0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACINTEN register.
+//
+//*****************************************************************************
+#define COMP_ACINTEN_IN2        0x00000004  // Comparator 2 Interrupt Enable.
+#define COMP_ACINTEN_IN1        0x00000002  // Comparator 1 Interrupt Enable.
+#define COMP_ACINTEN_IN0        0x00000001  // Comparator 0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACREFCTL
+// register.
+//
+//*****************************************************************************
+#define COMP_ACREFCTL_EN        0x00000200  // Resistor Ladder Enable.
+#define COMP_ACREFCTL_RNG       0x00000100  // Resistor Ladder Range.
+#define COMP_ACREFCTL_VREF_M    0x0000000F  // Resistor Ladder Voltage Ref.
+#define COMP_ACREFCTL_VREF_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT0 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT0_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL0 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL0_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL0_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL0_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL0_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL0_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL0_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL0_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL0_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL0_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL0_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL0_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL0_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL0_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL0_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL0_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL0_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL0_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL0_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT1 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT1_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL1 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL1_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL1_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL1_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL1_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL1_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL1_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL1_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL1_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL1_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL1_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL1_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL1_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL1_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL1_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL1_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL1_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL1_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL1_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT2 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT2_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL2 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL2_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL2_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL2_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL2_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL2_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL2_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL2_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL2_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL2_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL2_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL2_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL2_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL2_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL2_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL2_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL2_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL2_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL2_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the comparator register offsets.
+//
+//*****************************************************************************
+#define COMP_O_MIS              0x00000000  // Interrupt status register
+#define COMP_O_RIS              0x00000004  // Raw interrupt status register
+#define COMP_O_INTEN            0x00000008  // Interrupt enable register
+#define COMP_O_REFCTL           0x00000010  // Reference voltage control reg.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the COMP_MIS,
+// COMP_RIS, and COMP_INTEN registers.
+//
+//*****************************************************************************
+#define COMP_INT_2              0x00000004  // Comp2 interrupt
+#define COMP_INT_1              0x00000002  // Comp1 interrupt
+#define COMP_INT_0              0x00000001  // Comp0 interrupt
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the COMP_REFCTL
+// register.
+//
+//*****************************************************************************
+#define COMP_REFCTL_EN          0x00000200  // Reference voltage enable
+#define COMP_REFCTL_RNG         0x00000100  // Reference voltage range
+#define COMP_REFCTL_VREF_MASK   0x0000000F  // Reference voltage select mask
+#define COMP_REFCTL_VREF_SHIFT  0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the COMP_ACSTAT0,
+// COMP_ACSTAT1, and COMP_ACSTAT2 registers.
+//
+//*****************************************************************************
+#define COMP_ACSTAT_OVAL        0x00000002  // Comparator output value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the COMP_ACCTL0,
+// COMP_ACCTL1, and COMP_ACCTL2 registers.
+//
+//*****************************************************************************
+#define COMP_ACCTL_TMASK        0x00000800  // Trigger enable
+#define COMP_ACCTL_ASRCP_MASK   0x00000600  // Vin+ source select mask
+#define COMP_ACCTL_ASRCP_PIN    0x00000000  // Dedicated Comp+ pin
+#define COMP_ACCTL_ASRCP_PIN0   0x00000200  // Comp0+ pin
+#define COMP_ACCTL_ASRCP_REF    0x00000400  // Internal voltage reference
+#define COMP_ACCTL_ASRCP_RES    0x00000600  // Reserved
+#define COMP_ACCTL_OEN          0x00000100  // Comparator output enable
+#define COMP_ACCTL_TSVAL        0x00000080  // Trigger polarity select
+#define COMP_ACCTL_TSEN_MASK    0x00000060  // Trigger sense mask
+#define COMP_ACCTL_TSEN_LEVEL   0x00000000  // Trigger is level sense
+#define COMP_ACCTL_TSEN_FALL    0x00000020  // Trigger is falling edge
+#define COMP_ACCTL_TSEN_RISE    0x00000040  // Trigger is rising edge
+#define COMP_ACCTL_TSEN_BOTH    0x00000060  // Trigger is both edges
+#define COMP_ACCTL_ISLVAL       0x00000010  // Interrupt polarity select
+#define COMP_ACCTL_ISEN_MASK    0x0000000C  // Interrupt sense mask
+#define COMP_ACCTL_ISEN_LEVEL   0x00000000  // Interrupt is level sense
+#define COMP_ACCTL_ISEN_FALL    0x00000004  // Interrupt is falling edge
+#define COMP_ACCTL_ISEN_RISE    0x00000008  // Interrupt is rising edge
+#define COMP_ACCTL_ISEN_BOTH    0x0000000C  // Interrupt is both edges
+#define COMP_ACCTL_CINV         0x00000002  // Comparator output invert
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the reset values for the comparator
+// registers.
+//
+//*****************************************************************************
+#define COMP_RV_ACCTL1          0x00000000  // Comp1 control register
+#define COMP_RV_ACSTAT2         0x00000000  // Comp2 status register
+#define COMP_RV_ACSTAT0         0x00000000  // Comp0 status register
+#define COMP_RV_RIS             0x00000000  // Raw interrupt status register
+#define COMP_RV_INTEN           0x00000000  // Interrupt enable register
+#define COMP_RV_ACCTL2          0x00000000  // Comp2 control register
+#define COMP_RV_MIS             0x00000000  // Interrupt status register
+#define COMP_RV_ACCTL0          0x00000000  // Comp0 control register
+#define COMP_RV_ACSTAT1         0x00000000  // Comp1 status register
+#define COMP_RV_REFCTL          0x00000000  // Reference voltage control reg.
+
+#endif
+
+#endif // __HW_COMP_H__


Property changes on: trunk/src/platform/lm3s/hw_comp.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_epi.h
===================================================================
--- trunk/src/platform/lm3s/hw_epi.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_epi.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,428 @@
+//*****************************************************************************
+//
+// hw_epi.h - Macros for use in accessing the EPI registers.
+//
+// Copyright (c) 2008-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_EPI_H__
+#define __HW_EPI_H__
+
+//*****************************************************************************
+//
+// The following are defines for the External Peripheral Interface (EPI)
+//
+//*****************************************************************************
+#define EPI_O_CFG               0x00000000  // EPI Configuration
+#define EPI_O_BAUD              0x00000004  // EPI Main Baud Rate
+#define EPI_O_GPCFG             0x00000010  // EPI General Purpose
+                                            // Configuration
+#define EPI_O_SDRAMCFG          0x00000010  // EPI SDRAM Mode Configuration
+#define EPI_O_HB8CFG            0x00000010  // EPI Host-Bus 8 Mode
+                                            // Configuration
+#define EPI_O_HB8CFG2           0x00000014  // EPI Host-Bus 8 Configuration 2
+#define EPI_O_SDRAMCFG2         0x00000014  // EPI SDRAM Configuration 2
+#define EPI_O_GPCFG2            0x00000014  // EPI General-Purpose
+                                            // Configuration 2
+#define EPI_O_ADDRMAP           0x0000001C  // EPI Address Map
+#define EPI_O_RSIZE0            0x00000020  // EPI Read Size 0
+#define EPI_O_RADDR0            0x00000024  // EPI Read Address 0
+#define EPI_O_RPSTD0            0x00000028  // EPI Non-Blocking Read Data 0
+#define EPI_O_RSIZE1            0x00000030  // EPI Read Size 1
+#define EPI_O_RADDR1            0x00000034  // EPI Read Address 1
+#define EPI_O_RPSTD1            0x00000038  // EPI Non-Blocking Read Data 1
+#define EPI_O_STAT              0x00000060  // EPI Status
+#define EPI_O_RFIFOCNT          0x0000006C  // EPI Read FIFO Count
+#define EPI_O_READFIFO          0x00000070  // EPI Read FIFO
+#define EPI_O_READFIFO1         0x00000074  // EPI Read FIFO Alias 1
+#define EPI_O_READFIFO2         0x00000078  // EPI Read FIFO Alias 2
+#define EPI_O_READFIFO3         0x0000007C  // EPI Read FIFO Alias 3
+#define EPI_O_READFIFO4         0x00000080  // EPI Read FIFO Alias 4
+#define EPI_O_READFIFO5         0x00000084  // EPI Read FIFO Alias 5
+#define EPI_O_READFIFO6         0x00000088  // EPI Read FIFO Alias 6
+#define EPI_O_READFIFO7         0x0000008C  // EPI Read FIFO Alias 7
+#define EPI_O_FIFOLVL           0x00000200  // EPI FIFO Level Selects
+#define EPI_O_WFIFOCNT          0x00000204  // EPI Write FIFO Count
+#define EPI_O_IM                0x00000210  // EPI Interrupt Mask
+#define EPI_O_RIS               0x00000214  // EPI Raw Interrupt Status
+#define EPI_O_MIS               0x00000218  // EPI Masked Interrupt Status
+#define EPI_O_EISC              0x0000021C  // EPI Error Interrupt Status and
+                                            // Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_CFG register.
+//
+//*****************************************************************************
+#define EPI_CFG_BLKEN           0x00000010  // Block Enable.
+#define EPI_CFG_MODE_M          0x0000000F  // Mode Select.
+#define EPI_CFG_MODE_NONE       0x00000000  // None
+#define EPI_CFG_MODE_SDRAM      0x00000001  // SDRAM
+#define EPI_CFG_MODE_HB8        0x00000002  // 8-Bit Host-Bus (HB8)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_BAUD register.
+//
+//*****************************************************************************
+#define EPI_BAUD_COUNT_M        0x0000FFFF  // Baud Rate Counter.
+#define EPI_BAUD_COUNT_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_SDRAMCFG register.
+//
+//*****************************************************************************
+#define EPI_SDRAMCFG_FREQ_M     0xC0000000  // Frequency Range.
+#define EPI_SDRAMCFG_FREQ_NONE  0x00000000  // 0
+#define EPI_SDRAMCFG_FREQ_15MHZ 0x40000000  // 15
+#define EPI_SDRAMCFG_FREQ_30MHZ 0x80000000  // 30
+#define EPI_SDRAMCFG_FREQ_50MHZ 0xC0000000  // 50
+#define EPI_SDRAMCFG_RFSH_M     0x07FF0000  // Refresh Counter.
+#define EPI_SDRAMCFG_SLEEP      0x00000200  // Sleep Mode.
+#define EPI_SDRAMCFG_SIZE_M     0x00000003  // Size of SDRAM.
+#define EPI_SDRAMCFG_SIZE_8MB   0x00000000  // 64Mb (8MB)
+#define EPI_SDRAMCFG_SIZE_16MB  0x00000001  // 128Mb (16MB)
+#define EPI_SDRAMCFG_SIZE_32MB  0x00000002  // 256Mb (32MB)
+#define EPI_SDRAMCFG_SIZE_64MB  0x00000003  // 512Mb (64MB)
+#define EPI_SDRAMCFG_RFSH_S     16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_GPCFG register.
+//
+//*****************************************************************************
+#define EPI_GPCFG_CLKPIN        0x80000000  // Clock Pin.
+#define EPI_GPCFG_CLKGATE       0x40000000  // Clock Gated.
+#define EPI_GPCFG_RDYEN         0x10000000  // Ready Enable.
+#define EPI_GPCFG_FRMPIN        0x08000000  // Framing Pin.
+#define EPI_GPCFG_FRM50         0x04000000  // 50/50 Frame.
+#define EPI_GPCFG_FRMCNT_M      0x03C00000  // Frame Count.
+#define EPI_GPCFG_RW            0x00200000  // Read and Write.
+#define EPI_GPCFG_WR2CYC        0x00080000  // 2-Cycle Writes.
+#define EPI_GPCFG_RD2CYC        0x00040000  // 2-Cycle Reads.
+#define EPI_GPCFG_MAXWAIT_M     0x0000FF00  // Maximum Wait.
+#define EPI_GPCFG_ASIZE_M       0x00000030  // Address Bus Size.
+#define EPI_GPCFG_ASIZE_NONE    0x00000000  // No address
+#define EPI_GPCFG_ASIZE_4BIT    0x00000010  // 4 Bits Wide (EPI24 to EPI27)
+#define EPI_GPCFG_ASIZE_12BIT   0x00000020  // 12 Bits Wide (EPI16 to EPI27).
+                                            // Cannot be used with 24-bit data
+#define EPI_GPCFG_ASIZE_20BIT   0x00000030  // 20 Bits Wide
+#define EPI_GPCFG_DSIZE_M       0x00000003  // Size of Data Bus.
+#define EPI_GPCFG_DSIZE_4BIT    0x00000000  // 4 Bits Wide (EPI0 to EPI7)
+#define EPI_GPCFG_DSIZE_16BIT   0x00000001  // 16 Bits Wide (EPI0 to EPI15)
+#define EPI_GPCFG_DSIZE_24BIT   0x00000002  // 24 Bits Wide (EPI0 to EPI23)
+#define EPI_GPCFG_DSIZE_32BIT   0x00000003  // 32 Bits Wide. May not be used
+                                            // with clock (EPI0 to EPI31). This
+                                            // value is normally used for
+                                            // acquisition input and actuator
+                                            // control as well as other general
+                                            // purpose uses.
+#define EPI_GPCFG_FRMCNT_S      22
+#define EPI_GPCFG_MAXWAIT_S     8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG_XFFEN        0x00800000  // External FIFO FULL Enable.
+#define EPI_HB8CFG_XFEEN        0x00400000  // External FIFO EMPTY Enable.
+#define EPI_HB8CFG_WRHIGH       0x00200000  // WRITE Strobe Polarity.
+#define EPI_HB8CFG_RDHIGH       0x00100000  // READ Strobe Polarity.
+#define EPI_HB8CFG_MAXWAIT_M    0x0000FF00  // Maximum Wait.
+#define EPI_HB8CFG_WRWS_M       0x000000C0  // Write Wait States.
+#define EPI_HB8CFG_WRWS_0       0x00000000  // No wait states
+#define EPI_HB8CFG_WRWS_1       0x00000040  // 1 wait state
+#define EPI_HB8CFG_WRWS_2       0x00000080  // 2 wait states
+#define EPI_HB8CFG_WRWS_3       0x000000C0  // 3 wait states
+#define EPI_HB8CFG_RDWS_M       0x00000030  // Read Wait States.
+#define EPI_HB8CFG_RDWS_0       0x00000000  // No wait states
+#define EPI_HB8CFG_RDWS_1       0x00000010  // 1 wait state
+#define EPI_HB8CFG_RDWS_2       0x00000020  // 2 wait states
+#define EPI_HB8CFG_RDWS_3       0x00000030  // 3 wait states
+#define EPI_HB8CFG_MODE_M       0x00000003  // Host Bus Sub-Mode.
+#define EPI_HB8CFG_MODE_MUX     0x00000000  // ADMUX - AD[7:0]
+#define EPI_HB8CFG_MODE_NMUX    0x00000001  // ADNONMUX - D[7:0]
+#define EPI_HB8CFG_MODE_SRAM    0x00000002  // SRAM
+#define EPI_HB8CFG_MODE_FIFO    0x00000003  // FIFO - D[7:0]
+#define EPI_HB8CFG_MAXWAIT_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_ADDRMAP register.
+//
+//*****************************************************************************
+#define EPI_ADDRMAP_EPSZ_M      0x000000C0  // External Peripheral Size.
+#define EPI_ADDRMAP_EPSZ_256B   0x00000000  // 0x100 (256)
+#define EPI_ADDRMAP_EPSZ_64KB   0x00000040  // 0x10000 (64 KB)
+#define EPI_ADDRMAP_EPSZ_16MB   0x00000080  // 0x1000000 (16 MB)
+#define EPI_ADDRMAP_EPSZ_512MB  0x000000C0  // 0x20000000 (512 MB)
+#define EPI_ADDRMAP_EPADR_M     0x00000030  // External Peripheral Address.
+#define EPI_ADDRMAP_EPADR_NONE  0x00000000  // Not mapped
+#define EPI_ADDRMAP_EPADR_A000  0x00000010  // At 0xA0000000
+#define EPI_ADDRMAP_EPADR_C000  0x00000020  // At 0xC0000000
+#define EPI_ADDRMAP_ERSZ_M      0x0000000C  // External RAM Size.
+#define EPI_ADDRMAP_ERSZ_256B   0x00000000  // 0x100 (256)
+#define EPI_ADDRMAP_ERSZ_64KB   0x00000004  // 0x10000 (64KB)
+#define EPI_ADDRMAP_ERSZ_16MB   0x00000008  // 0x1000000 (16MB)
+#define EPI_ADDRMAP_ERSZ_512MB  0x0000000C  // 0x20000000 (512MB)
+#define EPI_ADDRMAP_ERADR_M     0x00000003  // External RAM Address.
+#define EPI_ADDRMAP_ERADR_NONE  0x00000000  // Not mapped
+#define EPI_ADDRMAP_ERADR_6000  0x00000001  // At 0x60000000
+#define EPI_ADDRMAP_ERADR_8000  0x00000002  // At 0x80000000
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RSIZE0 register.
+//
+//*****************************************************************************
+#define EPI_RSIZE0_SIZE_M       0x00000003  // Current Size.
+#define EPI_RSIZE0_SIZE_8BIT    0x00000001  // Byte (8 bits)
+#define EPI_RSIZE0_SIZE_16BIT   0x00000002  // Half-word (16 bits)
+#define EPI_RSIZE0_SIZE_32BIT   0x00000003  // Word (32 bits)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RADDR0 register.
+//
+//*****************************************************************************
+#define EPI_RADDR0_ADDR_M       0x1FFFFFFF  // Current Address.
+#define EPI_RADDR0_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RPSTD0 register.
+//
+//*****************************************************************************
+#define EPI_RPSTD0_POSTCNT_M    0x00001FFF  // Post Count.
+#define EPI_RPSTD0_POSTCNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RSIZE1 register.
+//
+//*****************************************************************************
+#define EPI_RSIZE1_SIZE_M       0x00000003  // Current Size.
+#define EPI_RSIZE1_SIZE_8BIT    0x00000001  // Byte (8 bits)
+#define EPI_RSIZE1_SIZE_16BIT   0x00000002  // Half-word (16 bits)
+#define EPI_RSIZE1_SIZE_32BIT   0x00000003  // Word (32 bits)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RADDR1 register.
+//
+//*****************************************************************************
+#define EPI_RADDR1_ADDR_M       0x1FFFFFFF  // Current Address.
+#define EPI_RADDR1_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RPSTD1 register.
+//
+//*****************************************************************************
+#define EPI_RPSTD1_POSTCNT_M    0x00001FFF  // Post Count.
+#define EPI_RPSTD1_POSTCNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RFIFOCNT register.
+//
+//*****************************************************************************
+#define EPI_RFIFOCNT_COUNT_M    0x00000007  // FIFO Count.
+#define EPI_RFIFOCNT_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO register.
+//
+//*****************************************************************************
+#define EPI_READFIFO_DATA_M     0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO_DATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO1
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO1_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO1_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO2
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO2_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO2_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO3
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO3_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO3_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO4
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO4_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO4_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO5
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO5_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO5_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO6
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO6_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO6_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO7
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO7_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO7_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_FIFOLVL register.
+//
+//*****************************************************************************
+#define EPI_FIFOLVL_WFERR       0x00020000  // Write Full Error.
+#define EPI_FIFOLVL_RSERR       0x00010000  // Read Stall Error.
+#define EPI_FIFOLVL_WRFIFO_M    0x00000070  // Write FIFO.
+#define EPI_FIFOLVL_WRFIFO_EMPT 0x00000000  // Empty
+#define EPI_FIFOLVL_WRFIFO_1_4  0x00000020  // &gt;= 1/4 full
+#define EPI_FIFOLVL_WRFIFO_1_2  0x00000030  // &gt;= 1/2 full
+#define EPI_FIFOLVL_WRFIFO_3_4  0x00000040  // &gt;= 3/4 full
+#define EPI_FIFOLVL_RDFIFO_M    0x00000007  // Read FIFO.
+#define EPI_FIFOLVL_RDFIFO_EMPT 0x00000000  // Empty
+#define EPI_FIFOLVL_RDFIFO_1_8  0x00000001  // &lt;= 1/8 full
+#define EPI_FIFOLVL_RDFIFO_1_4  0x00000002  // &lt;= 1/4 full
+#define EPI_FIFOLVL_RDFIFO_1_2  0x00000003  // &lt;= 1/2 full
+#define EPI_FIFOLVL_RDFIFO_3_4  0x00000004  // &lt;= 3/4 full
+#define EPI_FIFOLVL_RDFIFO_7_8  0x00000005  // &lt;= 7/8 full
+#define EPI_FIFOLVL_RDFIFO_FULL 0x00000006  // Trigger when there are 8 entries
+                                            // in the NBRFIFO.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_IM register.
+//
+//*****************************************************************************
+#define EPI_IM_WRIM             0x00000004  // Write Interrupt Mask.
+#define EPI_IM_RDIM             0x00000002  // Read Interrupt Mask.
+#define EPI_IM_ERRIM            0x00000001  // Error Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RIS register.
+//
+//*****************************************************************************
+#define EPI_RIS_WRRIS           0x00000004  // Write Raw Interrupt Status.
+#define EPI_RIS_RDRIS           0x00000002  // Read Raw Interrupt Status.
+#define EPI_RIS_ERRRIS          0x00000001  // Error Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_MIS register.
+//
+//*****************************************************************************
+#define EPI_MIS_WRMIS           0x00000004  // Write Masked Interrupt Status.
+#define EPI_MIS_RDMIS           0x00000002  // Read Masked Interrupt Status.
+#define EPI_MIS_ERRMIS          0x00000001  // Error Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_SDRAMCFG2
+// register.
+//
+//*****************************************************************************
+#define EPI_SDRAMCFG2_RCM       0x80000000  // Read Capture Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG2 register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG2_WORD        0x80000000  // Word Access Mode.
+#define EPI_HB8CFG2_CSCFG       0x01000000  // Chip Select Configuration.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_GPCFG2 register.
+//
+//*****************************************************************************
+#define EPI_GPCFG2_WORD         0x80000000  // Word Access Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_STAT register.
+//
+//*****************************************************************************
+#define EPI_STAT_CELOW          0x00000200  // Clock Enable Low.
+#define EPI_STAT_XFFULL         0x00000100  // External FIFO Full.
+#define EPI_STAT_XFEMPTY        0x00000080  // External FIFO Empty.
+#define EPI_STAT_INITSEQ        0x00000040  // Initialization Sequence.
+#define EPI_STAT_WBUSY          0x00000020  // Write Busy.
+#define EPI_STAT_NBRBUSY        0x00000010  // Non-Blocking Read Busy.
+#define EPI_STAT_ACTIVE         0x00000001  // Register Active.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_WFIFOCNT register.
+//
+//*****************************************************************************
+#define EPI_WFIFOCNT_WTAV_M     0x00000007  // Available Write Transactions.
+#define EPI_WFIFOCNT_WTAV_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_EISC register.
+//
+//*****************************************************************************
+#define EPI_EISC_WTFULL         0x00000004  // Write FIFO Full Error.
+#define EPI_EISC_RSTALL         0x00000002  // Read Stalled Error.
+#define EPI_EISC_TOUT           0x00000001  // Timeout Error.
+
+#endif // __HW_EPI_H__


Property changes on: trunk/src/platform/lm3s/hw_epi.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_ethernet.h
===================================================================
--- trunk/src/platform/lm3s/hw_ethernet.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_ethernet.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,575 +1,683 @@
-//*****************************************************************************
-//
-// hw_ethernet.h - Macros used when accessing the Ethernet hardware.
-//
-// Copyright (c) 2006-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-//
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_ETHERNET_H__
-#define __HW_ETHERNET_H__
-
-//*****************************************************************************
-//
-// The following are defines for the MAC register offsets in the Ethernet
-// Controller.
-//
-//*****************************************************************************
-#define MAC_O_RIS               0x00000000  // Ethernet MAC Raw Interrupt
-                                            // Status
-#define MAC_O_IACK              0x00000000  // Interrupt Acknowledge Register
-#define MAC_O_IM                0x00000004  // Interrupt Mask Register
-#define MAC_O_RCTL              0x00000008  // Receive Control Register
-#define MAC_O_TCTL              0x0000000C  // Transmit Control Register
-#define MAC_O_DATA              0x00000010  // Data Register
-#define MAC_O_IA0               0x00000014  // Individual Address Register 0
-#define MAC_O_IA1               0x00000018  // Individual Address Register 1
-#define MAC_O_THR               0x0000001C  // Threshold Register
-#define MAC_O_MCTL              0x00000020  // Management Control Register
-#define MAC_O_MDV               0x00000024  // Management Divider Register
-#define MAC_O_MTXD              0x0000002C  // Management Transmit Data Reg
-#define MAC_O_MRXD              0x00000030  // Management Receive Data Reg
-#define MAC_O_NP                0x00000034  // Number of Packets Register
-#define MAC_O_TR                0x00000038  // Transmission Request Register
-#define MAC_O_TS                0x0000003C  // Timer Support Register
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_IACK register.
-//
-//*****************************************************************************
-#define MAC_IACK_PHYINT         0x00000040  // Clear PHY Interrupt
-#define MAC_IACK_MDINT          0x00000020  // Clear MDI Transaction Complete
-#define MAC_IACK_RXER           0x00000010  // Clear RX Error
-#define MAC_IACK_FOV            0x00000008  // Clear RX FIFO Overrun
-#define MAC_IACK_TXEMP          0x00000004  // Clear TX FIFO Empy
-#define MAC_IACK_TXER           0x00000002  // Clear TX Error
-#define MAC_IACK_RXINT          0x00000001  // Clear RX Packet Available
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_IM register.
-//
-//*****************************************************************************
-#define MAC_IM_PHYINTM          0x00000040  // Mask PHY Interrupt
-#define MAC_IM_MDINTM           0x00000020  // Mask MDI Transaction Complete
-#define MAC_IM_RXERM            0x00000010  // Mask RX Error
-#define MAC_IM_FOVM             0x00000008  // Mask RX FIFO Overrun
-#define MAC_IM_TXEMPM           0x00000004  // Mask TX FIFO Empy
-#define MAC_IM_TXERM            0x00000002  // Mask TX Error
-#define MAC_IM_RXINTM           0x00000001  // Mask RX Packet Available
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_RCTL register.
-//
-//*****************************************************************************
-#define MAC_RCTL_RSTFIFO        0x00000010  // Clear the Receive FIFO
-#define MAC_RCTL_BADCRC         0x00000008  // Reject Packets With Bad CRC
-#define MAC_RCTL_PRMS           0x00000004  // Enable Promiscuous Mode
-#define MAC_RCTL_AMUL           0x00000002  // Enable Multicast Packets
-#define MAC_RCTL_RXEN           0x00000001  // Enable Ethernet Receiver
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_TCTL register.
-//
-//*****************************************************************************
-#define MAC_TCTL_DUPLEX         0x00000010  // Enable Duplex mode
-#define MAC_TCTL_CRC            0x00000004  // Enable CRC Generation
-#define MAC_TCTL_PADEN          0x00000002  // Enable Automatic Padding
-#define MAC_TCTL_TXEN           0x00000001  // Enable Ethernet Transmitter
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_IA0 register.
-//
-//*****************************************************************************
-#define MAC_IA0_MACOCT4_M       0xFF000000  // MAC Address Octet 4.
-#define MAC_IA0_MACOCT3_M       0x00FF0000  // MAC Address Octet 3.
-#define MAC_IA0_MACOCT2_M       0x0000FF00  // MAC Address Octet 2.
-#define MAC_IA0_MACOCT1_M       0x000000FF  // MAC Address Octet 1.
-#define MAC_IA0_MACOCT4_S       24
-#define MAC_IA0_MACOCT3_S       16
-#define MAC_IA0_MACOCT2_S       8
-#define MAC_IA0_MACOCT1_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_IA1 register.
-//
-//*****************************************************************************
-#define MAC_IA1_MACOCT6_M       0x0000FF00  // MAC Address Octet 6.
-#define MAC_IA1_MACOCT5_M       0x000000FF  // MAC Address Octet 5.
-#define MAC_IA1_MACOCT6_S       8
-#define MAC_IA1_MACOCT5_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_TXTH register.
-//
-//*****************************************************************************
-#define MAC_THR_THRESH_M        0x0000003F  // Threshold Value.
-#define MAC_THR_THRESH_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_MCTL register.
-//
-//*****************************************************************************
-#define MAC_MCTL_REGADR_M       0x000000F8  // MII Register Address.
-#define MAC_MCTL_WRITE          0x00000002  // Next MII Transaction is Write
-#define MAC_MCTL_START          0x00000001  // Start MII Transaction
-#define MAC_MCTL_REGADR_S       3
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_MDV register.
-//
-//*****************************************************************************
-#define MAC_MDV_DIV_M           0x000000FF  // Clock Divider.
-#define MAC_MDV_DIV_S           0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_MTXD register.
-//
-//*****************************************************************************
-#define MAC_MTXD_MDTX_M         0x0000FFFF  // MII Register Transmit Data.
-#define MAC_MTXD_MDTX_S         0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_MRXD register.
-//
-//*****************************************************************************
-#define MAC_MRXD_MDRX_M         0x0000FFFF  // MII Register Receive Data.
-#define MAC_MRXD_MDRX_S         0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_NP register.
-//
-//*****************************************************************************
-#define MAC_NP_NPR_M            0x0000003F  // Number of Packets in Receive
-                                            // FIFO.
-#define MAC_NP_NPR_S            0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_TXRQ register.
-//
-//*****************************************************************************
-#define MAC_TR_NEWTX            0x00000001  // Start an Ethernet Transmission
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_TS register.
-//
-//*****************************************************************************
-#define MAC_TS_TSEN             0x00000001  // Enable Timestamp Logic
-
-//*****************************************************************************
-//
-// The following are defines for the Ethernet Controller PHY registers.
-//
-//*****************************************************************************
-#define PHY_MR0                 0x00000000  // Ethernet PHY Management Register
-                                            // 0 - Control
-#define PHY_MR1                 0x00000001  // Ethernet PHY Management Register
-                                            // 1 - Status
-#define PHY_MR2                 0x00000002  // Ethernet PHY Management Register
-                                            // 2 - PHY Identifier 1
-#define PHY_MR3                 0x00000003  // Ethernet PHY Management Register
-                                            // 3 - PHY Identifier 2
-#define PHY_MR4                 0x00000004  // Ethernet PHY Management Register
-                                            // 4 - Auto-Negotiation
-                                            // Advertisement
-#define PHY_MR5                 0x00000005  // Ethernet PHY Management Register
-                                            // 5 - Auto-Negotiation Link
-                                            // Partner Base Page Ability
-#define PHY_MR6                 0x00000006  // Ethernet PHY Management Register
-                                            // 6 - Auto-Negotiation Expansion
-#define PHY_MR16                0x00000010  // Ethernet PHY Management Register
-                                            // 16 - Vendor-Specific
-#define PHY_MR17                0x00000011  // Ethernet PHY Management Register
-                                            // 17 - Interrupt Control/Status
-#define PHY_MR18                0x00000012  // Ethernet PHY Management Register
-                                            // 18 - Diagnostic
-#define PHY_MR19                0x00000013  // Ethernet PHY Management Register
-                                            // 19 - Transceiver Control
-#define PHY_MR23                0x00000017  // Ethernet PHY Management Register
-                                            // 23 - LED Configuration
-#define PHY_MR24                0x00000018  // Ethernet PHY Management Register
-                                            // 24 -MDI/MDIX Control
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR0 register.
-//
-//*****************************************************************************
-#define PHY_MR0_RESET           0x00008000  // Reset Registers.
-#define PHY_MR0_LOOPBK          0x00004000  // Loopback Mode.
-#define PHY_MR0_SPEEDSL         0x00002000  // Speed Select.
-#define PHY_MR0_ANEGEN          0x00001000  // Auto-Negotiation Enable.
-#define PHY_MR0_PWRDN           0x00000800  // Power Down.
-#define PHY_MR0_ISO             0x00000400  // Isolate.
-#define PHY_MR0_RANEG           0x00000200  // Restart Auto-Negotiation.
-#define PHY_MR0_DUPLEX          0x00000100  // Set Duplex Mode.
-#define PHY_MR0_COLT            0x00000080  // Collision Test.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_O_RIS register.
-//
-//*****************************************************************************
-#define MAC_RIS_PHYINT          0x00000040  // PHY Interrupt.
-#define MAC_RIS_MDINT           0x00000020  // MII Transaction Complete.
-#define MAC_RIS_RXER            0x00000010  // Receive Error.
-#define MAC_RIS_FOV             0x00000008  // FIFO Overrrun.
-#define MAC_RIS_TXEMP           0x00000004  // Transmit FIFO Empty.
-#define MAC_RIS_TXER            0x00000002  // Transmit Error.
-#define MAC_RIS_RXINT           0x00000001  // Packet Received.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR1 register.
-//
-//*****************************************************************************
-#define PHY_MR1_100X_F          0x00004000  // 100BASE-TX Full-Duplex Mode.
-#define PHY_MR1_100X_H          0x00002000  // 100BASE-TX Half-Duplex Mode.
-#define PHY_MR1_10T_F           0x00001000  // 10BASE-T Full-Duplex Mode.
-#define PHY_MR1_10T_H           0x00000800  // 10BASE-T Half-Duplex Mode.
-#define PHY_MR1_MFPS            0x00000040  // Management Frames with Preamble
-                                            // Suppressed.
-#define PHY_MR1_ANEGC           0x00000020  // Auto-Negotiation Complete.
-#define PHY_MR1_RFAULT          0x00000010  // Remote Fault.
-#define PHY_MR1_ANEGA           0x00000008  // Auto-Negotiation.
-#define PHY_MR1_LINK            0x00000004  // Link Made.
-#define PHY_MR1_JAB             0x00000002  // Jabber Condition.
-#define PHY_MR1_EXTD            0x00000001  // Extended Capabilities.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR2 register.
-//
-//*****************************************************************************
-#define PHY_MR2_OUI_M           0x0000FFFF  // Organizationally Unique
-                                            // Identifier[21:6].
-#define PHY_MR2_OUI_S           0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR3 register.
-//
-//*****************************************************************************
-#define PHY_MR3_OUI_M           0x0000FC00  // Organizationally Unique
-                                            // Identifier[5:0].
-#define PHY_MR3_MN_M            0x000003F0  // Model Number.
-#define PHY_MR3_RN_M            0x0000000F  // Revision Number.
-#define PHY_MR3_OUI_S           10
-#define PHY_MR3_MN_S            4
-#define PHY_MR3_RN_S            0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR4 register.
-//
-//*****************************************************************************
-#define PHY_MR4_NP              0x00008000  // Next Page.
-#define PHY_MR4_RF              0x00002000  // Remote Fault.
-#define PHY_MR4_A3              0x00000100  // Technology Ability Field[3].
-#define PHY_MR4_A2              0x00000080  // Technology Ability Field[2].
-#define PHY_MR4_A1              0x00000040  // Technology Ability Field[1].
-#define PHY_MR4_A0              0x00000020  // Technology Ability Field[0].
-#define PHY_MR4_S_M             0x0000001F  // Selector Field.
-#define PHY_MR4_S_S             0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR5 register.
-//
-//*****************************************************************************
-#define PHY_MR5_NP              0x00008000  // Next Page.
-#define PHY_MR5_ACK             0x00004000  // Acknowledge.
-#define PHY_MR5_RF              0x00002000  // Remote Fault.
-#define PHY_MR5_A_M             0x00001FE0  // Technology Ability Field.
-#define PHY_MR5_S_M             0x0000001F  // Selector Field.
-#define PHY_MR5_S_8023          0x00000001  // IEEE Std 802.3
-#define PHY_MR5_S_8029          0x00000002  // IEEE Std 802.9 ISLAN-16T
-#define PHY_MR5_S_8025          0x00000003  // IEEE Std 802.5
-#define PHY_MR5_S_1394          0x00000004  // IEEE Std 1394
-#define PHY_MR5_A_S             5
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR6 register.
-//
-//*****************************************************************************
-#define PHY_MR6_PDF             0x00000010  // Parallel Detection Fault.
-#define PHY_MR6_LPNPA           0x00000008  // Link Partner is Next Page Able.
-#define PHY_MR6_PRX             0x00000002  // New Page Received.
-#define PHY_MR6_LPANEGA         0x00000001  // Link Partner is Auto-Negotiation
-                                            // Able.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the MAC_O_DATA register.
-//
-//*****************************************************************************
-#define MAC_DATA_TXDATA_M       0xFFFFFFFF  // Transmit FIFO Data.
-#define MAC_DATA_RXDATA_M       0xFFFFFFFF  // Receive FIFO Data.
-#define MAC_DATA_RXDATA_S       0
-#define MAC_DATA_TXDATA_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR16 register.
-//
-//*****************************************************************************
-#define PHY_MR16_RPTR           0x00008000  // Repeater Mode.
-#define PHY_MR16_INPOL          0x00004000  // Interrupt Polarity.
-#define PHY_MR16_TXHIM          0x00001000  // Transmit High Impedance Mode.
-#define PHY_MR16_SQEI           0x00000800  // SQE Inhibit Testing.
-#define PHY_MR16_NL10           0x00000400  // Natural Loopback Mode.
-#define PHY_MR16_APOL           0x00000020  // Auto-Polarity Disable.
-#define PHY_MR16_RVSPOL         0x00000010  // Receive Data Polarity.
-#define PHY_MR16_PCSBP          0x00000002  // PCS Bypass.
-#define PHY_MR16_RXCC           0x00000001  // Receive Clock Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR17 register.
-//
-//*****************************************************************************
-#define PHY_MR17_JABBER_IE      0x00008000  // Jabber Interrupt Enable.
-#define PHY_MR17_RXER_IE        0x00004000  // Receive Error Interrupt Enable.
-#define PHY_MR17_PRX_IE         0x00002000  // Page Received Interrupt Enable.
-#define PHY_MR17_PDF_IE         0x00001000  // Parallel Detection Fault
-                                            // Interrupt Enable.
-#define PHY_MR17_LPACK_IE       0x00000800  // LP Acknowledge Interrupt Enable.
-#define PHY_MR17_LSCHG_IE       0x00000400  // Link Status Change Interrupt
-                                            // Enable.
-#define PHY_MR17_RFAULT_IE      0x00000200  // Remote Fault Interrupt Enable.
-#define PHY_MR17_ANEGCOMP_IE    0x00000100  // Auto-Negotiation Complete
-                                            // Interrupt Enable.
-#define PHY_MR17_JABBER_INT     0x00000080  // Jabber Event Interrupt.
-#define PHY_MR17_RXER_INT       0x00000040  // Receive Error Interrupt.
-#define PHY_MR17_PRX_INT        0x00000020  // Page Receive Interrupt.
-#define PHY_MR17_PDF_INT        0x00000010  // Parallel Detection Fault
-                                            // Interrupt.
-#define PHY_MR17_LPACK_INT      0x00000008  // LP Acknowledge Interrupt.
-#define PHY_MR17_LSCHG_INT      0x00000004  // Link Status Change Interrupt.
-#define PHY_MR17_RFAULT_INT     0x00000002  // Remote Fault Interrupt.
-#define PHY_MR17_ANEGCOMP_INT   0x00000001  // Auto-Negotiation Complete
-                                            // Interrupt.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR18 register.
-//
-//*****************************************************************************
-#define PHY_MR18_ANEGF          0x00001000  // Auto-Negotiation Failure.
-#define PHY_MR18_DPLX           0x00000800  // Duplex Mode.
-#define PHY_MR18_RATE           0x00000400  // Rate.
-#define PHY_MR18_RXSD           0x00000200  // Receive Detection.
-#define PHY_MR18_RX_LOCK        0x00000100  // Receive PLL Lock.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR19 register.
-//
-//*****************************************************************************
-#define PHY_MR19_TXO_M          0x0000C000  // Transmit Amplitude Selection.
-#define PHY_MR19_TXO_00DB       0x00000000  // Gain set for 0.0dB of insertion
-                                            // loss
-#define PHY_MR19_TXO_04DB       0x00004000  // Gain set for 0.4dB of insertion
-                                            // loss
-#define PHY_MR19_TXO_08DB       0x00008000  // Gain set for 0.8dB of insertion
-                                            // loss
-#define PHY_MR19_TXO_12DB       0x0000C000  // Gain set for 1.2dB of insertion
-                                            // loss
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR23 register.
-//
-//*****************************************************************************
-#define PHY_MR23_LED1_M         0x000000F0  // LED1 Source.
-#define PHY_MR23_LED1_LINK      0x00000000  // Link OK
-#define PHY_MR23_LED1_RXTX      0x00000010  // RX or TX Activity (Default LED1)
-#define PHY_MR23_LED1_TX        0x00000020  // TX Activity
-#define PHY_MR23_LED1_RX        0x00000030  // RX Activity
-#define PHY_MR23_LED1_COL       0x00000040  // Collision
-#define PHY_MR23_LED1_100       0x00000050  // 100BASE-TX mode
-#define PHY_MR23_LED1_10        0x00000060  // 10BASE-T mode
-#define PHY_MR23_LED1_DUPLEX    0x00000070  // Full-Duplex
-#define PHY_MR23_LED1_LINKACT   0x00000080  // Link OK &amp; Blink=RX or TX
-                                            // Activity
-#define PHY_MR23_LED0_M         0x0000000F  // LED0 Source.
-#define PHY_MR23_LED0_LINK      0x00000000  // Link OK (Default LED0)
-#define PHY_MR23_LED0_RXTX      0x00000001  // RX or TX Activity
-#define PHY_MR23_LED0_TX        0x00000002  // TX Activity
-#define PHY_MR23_LED0_RX        0x00000003  // RX Activity
-#define PHY_MR23_LED0_COL       0x00000004  // Collision
-#define PHY_MR23_LED0_100       0x00000005  // 100BASE-TX mode
-#define PHY_MR23_LED0_10        0x00000006  // 10BASE-T mode
-#define PHY_MR23_LED0_DUPLEX    0x00000007  // Full-Duplex
-#define PHY_MR23_LED0_LINKACT   0x00000008  // Link OK &amp; Blink=RX or TX
-                                            // Activity
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PHY_MR24 register.
-//
-//*****************************************************************************
-#define PHY_MR24_PD_MODE        0x00000080  // Parallel Detection Mode.
-#define PHY_MR24_AUTO_SW        0x00000040  // Auto-Switching Enable.
-#define PHY_MR24_MDIX           0x00000020  // Auto-Switching Configuration.
-#define PHY_MR24_MDIX_CM        0x00000010  // Auto-Switching Complete.
-#define PHY_MR24_MDIX_SD_M      0x0000000F  // Auto-Switching Seed.
-#define PHY_MR24_MDIX_SD_S      0
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the MAC register offsets in the
-// Ethernet Controller.
-//
-//*****************************************************************************
-#define MAC_O_IS                0x00000000  // Interrupt Status Register
-#define MAC_O_MADD              0x00000028  // Management Address Register
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the reset values of the MAC
-// registers.
-//
-//*****************************************************************************
-#define MAC_RV_MDV              0x00000080
-#define MAC_RV_IM               0x0000007F
-#define MAC_RV_THR              0x0000003F
-#define MAC_RV_RCTL             0x00000008
-#define MAC_RV_IA0              0x00000000
-#define MAC_RV_TCTL             0x00000000
-#define MAC_RV_DATA             0x00000000
-#define MAC_RV_MRXD             0x00000000
-#define MAC_RV_TR               0x00000000
-#define MAC_RV_IS               0x00000000
-#define MAC_RV_NP               0x00000000
-#define MAC_RV_MCTL             0x00000000
-#define MAC_RV_MTXD             0x00000000
-#define MAC_RV_IA1              0x00000000
-#define MAC_RV_IACK             0x00000000
-#define MAC_RV_MADD             0x00000000
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_IS
-// register.
-//
-//*****************************************************************************
-#define MAC_IS_PHYINT           0x00000040  // PHY Interrupt
-#define MAC_IS_MDINT            0x00000020  // MDI Transaction Complete
-#define MAC_IS_RXER             0x00000010  // RX Error
-#define MAC_IS_FOV              0x00000008  // RX FIFO Overrun
-#define MAC_IS_TXEMP            0x00000004  // TX FIFO Empy
-#define MAC_IS_TXER             0x00000002  // TX Error
-#define MAC_IS_RXINT            0x00000001  // RX Packet Available
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_IA0
-// register.
-//
-//*****************************************************************************
-#define MAC_IA0_MACOCT4         0xFF000000  // 4th Octet of MAC address
-#define MAC_IA0_MACOCT3         0x00FF0000  // 3rd Octet of MAC address
-#define MAC_IA0_MACOCT2         0x0000FF00  // 2nd Octet of MAC address
-#define MAC_IA0_MACOCT1         0x000000FF  // 1st Octet of MAC address
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_IA1
-// register.
-//
-//*****************************************************************************
-#define MAC_IA1_MACOCT6         0x0000FF00  // 6th Octet of MAC address
-#define MAC_IA1_MACOCT5         0x000000FF  // 5th Octet of MAC address
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_TXTH
-// register.
-//
-//*****************************************************************************
-#define MAC_THR_THRESH          0x0000003F  // Transmit Threshold Value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_MCTL
-// register.
-//
-//*****************************************************************************
-#define MAC_MCTL_REGADR         0x000000F8  // Address for Next MII Transaction
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_MDV
-// register.
-//
-//*****************************************************************************
-#define MAC_MDV_DIV             0x000000FF  // Clock Divider for MDC for TX
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_MTXD
-// register.
-//
-//*****************************************************************************
-#define MAC_MTXD_MDTX           0x0000FFFF  // Data for Next MII Transaction
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_MRXD
-// register.
-//
-//*****************************************************************************
-#define MAC_MRXD_MDRX           0x0000FFFF  // Data Read from Last MII Trans.
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the MAC_NP
-// register.
-//
-//*****************************************************************************
-#define MAC_NP_NPR              0x0000003F  // Number of RX Frames in FIFO
-
-#endif
-
-#endif // __HW_ETHERNET_H__
+//*****************************************************************************
+//
+// hw_ethernet.h - Macros used when accessing the Ethernet hardware.
+//
+// Copyright (c) 2006-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_ETHERNET_H__
+#define __HW_ETHERNET_H__
+
+//*****************************************************************************
+//
+// The following are defines for the MAC register offsets in the Ethernet
+// Controller.
+//
+//*****************************************************************************
+#define MAC_O_RIS               0x00000000  // Ethernet MAC Raw Interrupt
+                                            // Status
+#define MAC_O_IACK              0x00000000  // Interrupt Acknowledge Register
+#define MAC_O_IM                0x00000004  // Interrupt Mask Register
+#define MAC_O_RCTL              0x00000008  // Receive Control Register
+#define MAC_O_TCTL              0x0000000C  // Transmit Control Register
+#define MAC_O_DATA              0x00000010  // Data Register
+#define MAC_O_IA0               0x00000014  // Individual Address Register 0
+#define MAC_O_IA1               0x00000018  // Individual Address Register 1
+#define MAC_O_THR               0x0000001C  // Threshold Register
+#define MAC_O_MCTL              0x00000020  // Management Control Register
+#define MAC_O_MDV               0x00000024  // Management Divider Register
+#define MAC_O_MTXD              0x0000002C  // Management Transmit Data Reg
+#define MAC_O_MRXD              0x00000030  // Management Receive Data Reg
+#define MAC_O_NP                0x00000034  // Number of Packets Register
+#define MAC_O_TR                0x00000038  // Transmission Request Register
+#define MAC_O_TS                0x0000003C  // Timer Support Register
+#define MAC_O_LED               0x00000040  // Ethernet MAC LED Encoding
+#define MAC_O_MDIX              0x00000044  // MDIX Register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IACK register.
+//
+//*****************************************************************************
+#define MAC_IACK_PHYINT         0x00000040  // Clear PHY Interrupt
+#define MAC_IACK_MDINT          0x00000020  // Clear MDI Transaction Complete
+#define MAC_IACK_RXER           0x00000010  // Clear RX Error
+#define MAC_IACK_FOV            0x00000008  // Clear RX FIFO Overrun
+#define MAC_IACK_TXEMP          0x00000004  // Clear TX FIFO Empy
+#define MAC_IACK_TXER           0x00000002  // Clear TX Error
+#define MAC_IACK_RXINT          0x00000001  // Clear RX Packet Available
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IM register.
+//
+//*****************************************************************************
+#define MAC_IM_PHYINTM          0x00000040  // Mask PHY Interrupt
+#define MAC_IM_MDINTM           0x00000020  // Mask MDI Transaction Complete
+#define MAC_IM_RXERM            0x00000010  // Mask RX Error
+#define MAC_IM_FOVM             0x00000008  // Mask RX FIFO Overrun
+#define MAC_IM_TXEMPM           0x00000004  // Mask TX FIFO Empy
+#define MAC_IM_TXERM            0x00000002  // Mask TX Error
+#define MAC_IM_RXINTM           0x00000001  // Mask RX Packet Available
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_RCTL register.
+//
+//*****************************************************************************
+#define MAC_RCTL_RSTFIFO        0x00000010  // Clear the Receive FIFO
+#define MAC_RCTL_BADCRC         0x00000008  // Reject Packets With Bad CRC
+#define MAC_RCTL_PRMS           0x00000004  // Enable Promiscuous Mode
+#define MAC_RCTL_AMUL           0x00000002  // Enable Multicast Packets
+#define MAC_RCTL_RXEN           0x00000001  // Enable Ethernet Receiver
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TCTL register.
+//
+//*****************************************************************************
+#define MAC_TCTL_DUPLEX         0x00000010  // Enable Duplex mode
+#define MAC_TCTL_CRC            0x00000004  // Enable CRC Generation
+#define MAC_TCTL_PADEN          0x00000002  // Enable Automatic Padding
+#define MAC_TCTL_TXEN           0x00000001  // Enable Ethernet Transmitter
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IA0 register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4_M       0xFF000000  // MAC Address Octet 4.
+#define MAC_IA0_MACOCT3_M       0x00FF0000  // MAC Address Octet 3.
+#define MAC_IA0_MACOCT2_M       0x0000FF00  // MAC Address Octet 2.
+#define MAC_IA0_MACOCT1_M       0x000000FF  // MAC Address Octet 1.
+#define MAC_IA0_MACOCT4_S       24
+#define MAC_IA0_MACOCT3_S       16
+#define MAC_IA0_MACOCT2_S       8
+#define MAC_IA0_MACOCT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_IA1 register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6_M       0x0000FF00  // MAC Address Octet 6.
+#define MAC_IA1_MACOCT5_M       0x000000FF  // MAC Address Octet 5.
+#define MAC_IA1_MACOCT6_S       8
+#define MAC_IA1_MACOCT5_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TXTH register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH_M        0x0000003F  // Threshold Value.
+#define MAC_THR_THRESH_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MCTL register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR_M       0x000000F8  // MII Register Address.
+#define MAC_MCTL_WRITE          0x00000002  // Next MII Transaction is Write
+#define MAC_MCTL_START          0x00000001  // Start MII Transaction
+#define MAC_MCTL_REGADR_S       3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MDV register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV_M           0x000000FF  // Clock Divider.
+#define MAC_MDV_DIV_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MTXD register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX_M         0x0000FFFF  // MII Register Transmit Data.
+#define MAC_MTXD_MDTX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MRXD register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX_M         0x0000FFFF  // MII Register Receive Data.
+#define MAC_MRXD_MDRX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_NP register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR_M            0x0000003F  // Number of Packets in Receive
+                                            // FIFO.
+#define MAC_NP_NPR_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TXRQ register.
+//
+//*****************************************************************************
+#define MAC_TR_NEWTX            0x00000001  // Start an Ethernet Transmission
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_TS register.
+//
+//*****************************************************************************
+#define MAC_TS_TSEN             0x00000001  // Enable Timestamp Logic
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_MDIX register.
+//
+//*****************************************************************************
+#define MAC_MDIX_EN             0x00000001  // MDI/MDI-X Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the Ethernet Controller PHY registers.
+//
+//*****************************************************************************
+#define PHY_MR0                 0x00000000  // Ethernet PHY Management Register
+                                            // 0 - Control
+#define PHY_MR1                 0x00000001  // Ethernet PHY Management Register
+                                            // 1 - Status
+#define PHY_MR2                 0x00000002  // Ethernet PHY Management Register
+                                            // 2 - PHY Identifier 1
+#define PHY_MR3                 0x00000003  // Ethernet PHY Management Register
+                                            // 3 - PHY Identifier 2
+#define PHY_MR4                 0x00000004  // Ethernet PHY Management Register
+                                            // 4 - Auto-Negotiation
+                                            // Advertisement
+#define PHY_MR5                 0x00000005  // Ethernet PHY Management Register
+                                            // 5 - Auto-Negotiation Link
+                                            // Partner Base Page Ability
+#define PHY_MR6                 0x00000006  // Ethernet PHY Management Register
+                                            // 6 - Auto-Negotiation Expansion
+#define PHY_MR16                0x00000010  // Ethernet PHY Management Register
+                                            // 16 - Vendor-Specific
+#define PHY_MR17                0x00000011  // Ethernet PHY Management Register
+                                            // 17 - Interrupt Control/Status
+#define PHY_MR18                0x00000012  // Ethernet PHY Management Register
+                                            // 18 - Diagnostic
+#define PHY_MR19                0x00000013  // Ethernet PHY Management Register
+                                            // 19 - Transceiver Control
+#define PHY_MR23                0x00000017  // Ethernet PHY Management Register
+                                            // 23 - LED Configuration
+#define PHY_MR24                0x00000018  // Ethernet PHY Management Register
+                                            // 24 -MDI/MDIX Control
+#define PHY_MR27                0x0000001B  // Ethernet PHY Management Register
+                                            // 27 -Special Control/Status
+#define PHY_MR29                0x0000001D  // Ethernet PHY Management Register
+                                            // 29 - Interrupt Status
+#define PHY_MR30                0x0000001E  // Ethernet PHY Management Register
+                                            // 30 - Interrupt Mask
+#define PHY_MR31                0x0000001F  // Ethernet PHY Management Register
+                                            // 31 - PHY Special Control/Status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR0 register.
+//
+//*****************************************************************************
+#define PHY_MR0_RESET           0x00008000  // Reset Registers.
+#define PHY_MR0_LOOPBK          0x00004000  // Loopback Mode.
+#define PHY_MR0_SPEEDSL         0x00002000  // Speed Select.
+#define PHY_MR0_ANEGEN          0x00001000  // Auto-Negotiation Enable.
+#define PHY_MR0_PWRDN           0x00000800  // Power Down.
+#define PHY_MR0_ISO             0x00000400  // Isolate.
+#define PHY_MR0_RANEG           0x00000200  // Restart Auto-Negotiation.
+#define PHY_MR0_DUPLEX          0x00000100  // Set Duplex Mode.
+#define PHY_MR0_COLT            0x00000080  // Collision Test.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RIS register.
+//
+//*****************************************************************************
+#define MAC_RIS_PHYINT          0x00000040  // PHY Interrupt.
+#define MAC_RIS_MDINT           0x00000020  // MII Transaction Complete.
+#define MAC_RIS_RXER            0x00000010  // Receive Error.
+#define MAC_RIS_FOV             0x00000008  // FIFO Overrrun.
+#define MAC_RIS_TXEMP           0x00000004  // Transmit FIFO Empty.
+#define MAC_RIS_TXER            0x00000002  // Transmit Error.
+#define MAC_RIS_RXINT           0x00000001  // Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR1 register.
+//
+//*****************************************************************************
+#define PHY_MR1_100X_F          0x00004000  // 100BASE-TX Full-Duplex Mode.
+#define PHY_MR1_100X_H          0x00002000  // 100BASE-TX Half-Duplex Mode.
+#define PHY_MR1_10T_F           0x00001000  // 10BASE-T Full-Duplex Mode.
+#define PHY_MR1_10T_H           0x00000800  // 10BASE-T Half-Duplex Mode.
+#define PHY_MR1_MFPS            0x00000040  // Management Frames with Preamble
+                                            // Suppressed.
+#define PHY_MR1_ANEGC           0x00000020  // Auto-Negotiation Complete.
+#define PHY_MR1_RFAULT          0x00000010  // Remote Fault.
+#define PHY_MR1_ANEGA           0x00000008  // Auto-Negotiation.
+#define PHY_MR1_LINK            0x00000004  // Link Made.
+#define PHY_MR1_JAB             0x00000002  // Jabber Condition.
+#define PHY_MR1_EXTD            0x00000001  // Extended Capabilities.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR2 register.
+//
+//*****************************************************************************
+#define PHY_MR2_OUI_M           0x0000FFFF  // Organizationally Unique
+                                            // Identifier[21:6].
+#define PHY_MR2_OUI_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR3 register.
+//
+//*****************************************************************************
+#define PHY_MR3_OUI_M           0x0000FC00  // Organizationally Unique
+                                            // Identifier[5:0].
+#define PHY_MR3_MN_M            0x000003F0  // Model Number.
+#define PHY_MR3_RN_M            0x0000000F  // Revision Number.
+#define PHY_MR3_OUI_S           10
+#define PHY_MR3_MN_S            4
+#define PHY_MR3_RN_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR4 register.
+//
+//*****************************************************************************
+#define PHY_MR4_NP              0x00008000  // Next Page.
+#define PHY_MR4_RF              0x00002000  // Remote Fault.
+#define PHY_MR4_A3              0x00000100  // Technology Ability Field[3].
+#define PHY_MR4_A2              0x00000080  // Technology Ability Field[2].
+#define PHY_MR4_A1              0x00000040  // Technology Ability Field[1].
+#define PHY_MR4_A0              0x00000020  // Technology Ability Field[0].
+#define PHY_MR4_S_M             0x0000001F  // Selector Field.
+#define PHY_MR4_S_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR5 register.
+//
+//*****************************************************************************
+#define PHY_MR5_NP              0x00008000  // Next Page.
+#define PHY_MR5_ACK             0x00004000  // Acknowledge.
+#define PHY_MR5_RF              0x00002000  // Remote Fault.
+#define PHY_MR5_A_M             0x00001FE0  // Technology Ability Field.
+#define PHY_MR5_S_M             0x0000001F  // Selector Field.
+#define PHY_MR5_S_8023          0x00000001  // IEEE Std 802.3
+#define PHY_MR5_S_8029          0x00000002  // IEEE Std 802.9 ISLAN-16T
+#define PHY_MR5_S_8025          0x00000003  // IEEE Std 802.5
+#define PHY_MR5_S_1394          0x00000004  // IEEE Std 1394
+#define PHY_MR5_A_S             5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR6 register.
+//
+//*****************************************************************************
+#define PHY_MR6_PDF             0x00000010  // Parallel Detection Fault.
+#define PHY_MR6_LPNPA           0x00000008  // Link Partner is Next Page Able.
+#define PHY_MR6_PRX             0x00000002  // New Page Received.
+#define PHY_MR6_LPANEGA         0x00000001  // Link Partner is Auto-Negotiation
+                                            // Able.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_DATA register.
+//
+//*****************************************************************************
+#define MAC_DATA_TXDATA_M       0xFFFFFFFF  // Transmit FIFO Data.
+#define MAC_DATA_RXDATA_M       0xFFFFFFFF  // Receive FIFO Data.
+#define MAC_DATA_RXDATA_S       0
+#define MAC_DATA_TXDATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR16 register.
+//
+//*****************************************************************************
+#define PHY_MR16_RPTR           0x00008000  // Repeater Mode.
+#define PHY_MR16_INPOL          0x00004000  // Interrupt Polarity.
+#define PHY_MR16_TXHIM          0x00001000  // Transmit High Impedance Mode.
+#define PHY_MR16_SQEI           0x00000800  // SQE Inhibit Testing.
+#define PHY_MR16_NL10           0x00000400  // Natural Loopback Mode.
+#define PHY_MR16_SR_M           0x000003C0  // Silicon Revision Identifier.
+#define PHY_MR16_APOL           0x00000020  // Auto-Polarity Disable.
+#define PHY_MR16_RVSPOL         0x00000010  // Receive Data Polarity.
+#define PHY_MR16_PCSBP          0x00000002  // PCS Bypass.
+#define PHY_MR16_RXCC           0x00000001  // Receive Clock Control.
+#define PHY_MR16_SR_S           6
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR17 register.
+//
+//*****************************************************************************
+#define PHY_MR17_JABBER_IE      0x00008000  // Jabber Interrupt Enable.
+#define PHY_MR17_FASTRIP        0x00004000  // 10-BASE-T Fast Mode Enable.
+#define PHY_MR17_RXER_IE        0x00004000  // Receive Error Interrupt Enable.
+#define PHY_MR17_EDPD           0x00002000  // Enable Energy Detect Power Down.
+#define PHY_MR17_PRX_IE         0x00002000  // Page Received Interrupt Enable.
+#define PHY_MR17_PDF_IE         0x00001000  // Parallel Detection Fault
+                                            // Interrupt Enable.
+#define PHY_MR17_LSQE           0x00000800  // Low Squelch Enable.
+#define PHY_MR17_LPACK_IE       0x00000800  // LP Acknowledge Interrupt Enable.
+#define PHY_MR17_LSCHG_IE       0x00000400  // Link Status Change Interrupt
+                                            // Enable.
+#define PHY_MR17_MDPB           0x00000400  // Management Data Preamble Bypass.
+#define PHY_MR17_RFAULT_IE      0x00000200  // Remote Fault Interrupt Enable.
+#define PHY_MR17_FLPBK          0x00000200  // Far Loopback Mode.
+#define PHY_MR17_ANEGCOMP_IE    0x00000100  // Auto-Negotiation Complete
+                                            // Interrupt Enable.
+#define PHY_MR17_FASTEST        0x00000100  // Auto-Negotiation Test Mode.
+#define PHY_MR17_JABBER_INT     0x00000080  // Jabber Event Interrupt.
+#define PHY_MR17_RXER_INT       0x00000040  // Receive Error Interrupt.
+#define PHY_MR17_PRX_INT        0x00000020  // Page Receive Interrupt.
+#define PHY_MR17_PDF_INT        0x00000010  // Parallel Detection Fault
+                                            // Interrupt.
+#define PHY_MR17_REFCE          0x00000010  // Reference Clock Enable.
+#define PHY_MR17_LPACK_INT      0x00000008  // LP Acknowledge Interrupt.
+#define PHY_MR17_PADBP          0x00000008  // PHY Address Bypass.
+#define PHY_MR17_LSCHG_INT      0x00000004  // Link Status Change Interrupt.
+#define PHY_MR17_FGLS           0x00000004  // Force Good Link Status.
+#define PHY_MR17_RFAULT_INT     0x00000002  // Remote Fault Interrupt.
+#define PHY_MR17_ENON           0x00000002  // Energy On.
+#define PHY_MR17_ANEGCOMP_INT   0x00000001  // Auto-Negotiation Complete
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR18 register.
+//
+//*****************************************************************************
+#define PHY_MR18_ANEGF          0x00001000  // Auto-Negotiation Failure.
+#define PHY_MR18_DPLX           0x00000800  // Duplex Mode.
+#define PHY_MR18_RATE           0x00000400  // Rate.
+#define PHY_MR18_RXSD           0x00000200  // Receive Detection.
+#define PHY_MR18_RX_LOCK        0x00000100  // Receive PLL Lock.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR19 register.
+//
+//*****************************************************************************
+#define PHY_MR19_TXO_M          0x0000C000  // Transmit Amplitude Selection.
+#define PHY_MR19_TXO_00DB       0x00000000  // Gain set for 0.0dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_04DB       0x00004000  // Gain set for 0.4dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_08DB       0x00008000  // Gain set for 0.8dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_12DB       0x0000C000  // Gain set for 1.2dB of insertion
+                                            // loss
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR23 register.
+//
+//*****************************************************************************
+#define PHY_MR23_LED1_M         0x000000F0  // LED1 Source.
+#define PHY_MR23_LED1_LINK      0x00000000  // Link OK
+#define PHY_MR23_LED1_RXTX      0x00000010  // RX or TX Activity (Default LED1)
+#define PHY_MR23_LED1_100       0x00000050  // 100BASE-TX mode
+#define PHY_MR23_LED1_10        0x00000060  // 10BASE-T mode
+#define PHY_MR23_LED1_DUPLEX    0x00000070  // Full-Duplex
+#define PHY_MR23_LED1_LINKACT   0x00000080  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+#define PHY_MR23_LED0_M         0x0000000F  // LED0 Source.
+#define PHY_MR23_LED0_LINK      0x00000000  // Link OK (Default LED0)
+#define PHY_MR23_LED0_RXTX      0x00000001  // RX or TX Activity
+#define PHY_MR23_LED0_100       0x00000005  // 100BASE-TX mode
+#define PHY_MR23_LED0_10        0x00000006  // 10BASE-T mode
+#define PHY_MR23_LED0_DUPLEX    0x00000007  // Full-Duplex
+#define PHY_MR23_LED0_LINKACT   0x00000008  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR24 register.
+//
+//*****************************************************************************
+#define PHY_MR24_PD_MODE        0x00000080  // Parallel Detection Mode.
+#define PHY_MR24_AUTO_SW        0x00000040  // Auto-Switching Enable.
+#define PHY_MR24_MDIX           0x00000020  // Auto-Switching Configuration.
+#define PHY_MR24_MDIX_CM        0x00000010  // Auto-Switching Complete.
+#define PHY_MR24_MDIX_SD_M      0x0000000F  // Auto-Switching Seed.
+#define PHY_MR24_MDIX_SD_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR27 register.
+//
+//*****************************************************************************
+#define PHY_MR27_XPOL           0x00000010  // Polarity State of 10 BASE-T.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR29 register.
+//
+//*****************************************************************************
+#define PHY_MR29_EONIS          0x00000080  // ENERGYON Interrupt.
+#define PHY_MR29_ANCOMPIS       0x00000040  // Auto-Negotiation Complete
+                                            // Interrupt.
+#define PHY_MR29_RFLTIS         0x00000020  // Remote Fault Interrupt.
+#define PHY_MR29_LDIS           0x00000010  // Link Down Interrupt.
+#define PHY_MR29_LPACKIS        0x00000008  // Auto-Negotiation LP Acknowledge.
+#define PHY_MR29_PDFIS          0x00000004  // Parallel Detection Fault.
+#define PHY_MR29_PRXIS          0x00000002  // Auto Negotiation Page Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR30 register.
+//
+//*****************************************************************************
+#define PHY_MR30_EONIM          0x00000080  // ENERGYON Interrupt Enabled.
+#define PHY_MR30_ANCOMPIM       0x00000040  // Auto-Negotiation Complete
+                                            // Interrupt Enabled.
+#define PHY_MR30_RFLTIM         0x00000020  // Remote Fault Interrupt Enabled.
+#define PHY_MR30_LDIM           0x00000010  // Link Down Interrupt Enabled.
+#define PHY_MR30_LPACKIM        0x00000008  // Auto-Negotiation LP Acknowledge
+                                            // Enabled.
+#define PHY_MR30_PDFIM          0x00000004  // Parallel Detection Fault
+                                            // Enabled.
+#define PHY_MR30_PRXIM          0x00000002  // Auto Negotiation Page Received
+                                            // Enabled.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PHY_MR31 register.
+//
+//*****************************************************************************
+#define PHY_MR31_BPRMG          0x00008000  // Bypass Remove Glitch.
+#define PHY_MR31_AUTODONE       0x00001000  // Auto Negotiation Done.
+#define PHY_MR31_EN4B5B         0x00000040  // Enable 4B5B Encoding/Decoding.
+#define PHY_MR31_SPEED_M        0x0000001C  // HCD Speed Value.
+#define PHY_MR31_SCRDIS         0x00000001  // Scramble Disable.
+#define PHY_MR31_SPEED_S        2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_LED register.
+//
+//*****************************************************************************
+#define MAC_LED_LED1_M          0x000000F0  // LED1 Source.
+#define MAC_LED_LED1_LINK       0x00000000  // Link OK
+#define MAC_LED_LED1_RXTX       0x00000010  // RX or TX Activity (Default LED1)
+#define MAC_LED_LED1_100        0x00000050  // 100BASE-TX mode
+#define MAC_LED_LED1_10         0x00000060  // 10BASE-T mode
+#define MAC_LED_LED1_DUPLEX     0x00000070  // Full-Duplex
+#define MAC_LED_LED1_LINKACT    0x00000080  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+#define MAC_LED_LED0_M          0x0000000F  // LED0 Source.
+#define MAC_LED_LED0_LINK       0x00000000  // Link OK (Default LED0)
+#define MAC_LED_LED0_RXTX       0x00000001  // RX or TX Activity
+#define MAC_LED_LED0_100        0x00000005  // 100BASE-TX mode
+#define MAC_LED_LED0_10         0x00000006  // 10BASE-T mode
+#define MAC_LED_LED0_DUPLEX     0x00000007  // Full-Duplex
+#define MAC_LED_LED0_LINKACT    0x00000008  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the MAC register offsets in the
+// Ethernet Controller.
+//
+//*****************************************************************************
+#define MAC_O_IS                0x00000000  // Interrupt Status Register
+#define MAC_O_MADD              0x00000028  // Management Address Register
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the reset values of the MAC
+// registers.
+//
+//*****************************************************************************
+#define MAC_RV_MDV              0x00000080
+#define MAC_RV_IM               0x0000007F
+#define MAC_RV_THR              0x0000003F
+#define MAC_RV_RCTL             0x00000008
+#define MAC_RV_IA0              0x00000000
+#define MAC_RV_TCTL             0x00000000
+#define MAC_RV_DATA             0x00000000
+#define MAC_RV_MRXD             0x00000000
+#define MAC_RV_TR               0x00000000
+#define MAC_RV_IS               0x00000000
+#define MAC_RV_NP               0x00000000
+#define MAC_RV_MCTL             0x00000000
+#define MAC_RV_MTXD             0x00000000
+#define MAC_RV_IA1              0x00000000
+#define MAC_RV_IACK             0x00000000
+#define MAC_RV_MADD             0x00000000
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_IS
+// register.
+//
+//*****************************************************************************
+#define MAC_IS_PHYINT           0x00000040  // PHY Interrupt
+#define MAC_IS_MDINT            0x00000020  // MDI Transaction Complete
+#define MAC_IS_RXER             0x00000010  // RX Error
+#define MAC_IS_FOV              0x00000008  // RX FIFO Overrun
+#define MAC_IS_TXEMP            0x00000004  // TX FIFO Empy
+#define MAC_IS_TXER             0x00000002  // TX Error
+#define MAC_IS_RXINT            0x00000001  // RX Packet Available
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_IA0
+// register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4         0xFF000000  // 4th Octet of MAC address
+#define MAC_IA0_MACOCT3         0x00FF0000  // 3rd Octet of MAC address
+#define MAC_IA0_MACOCT2         0x0000FF00  // 2nd Octet of MAC address
+#define MAC_IA0_MACOCT1         0x000000FF  // 1st Octet of MAC address
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_IA1
+// register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6         0x0000FF00  // 6th Octet of MAC address
+#define MAC_IA1_MACOCT5         0x000000FF  // 5th Octet of MAC address
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_TXTH
+// register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH          0x0000003F  // Transmit Threshold Value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MCTL
+// register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR         0x000000F8  // Address for Next MII Transaction
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MDV
+// register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV             0x000000FF  // Clock Divider for MDC for TX
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MTXD
+// register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX           0x0000FFFF  // Data for Next MII Transaction
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_MRXD
+// register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX           0x0000FFFF  // Data Read from Last MII Trans.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the MAC_NP
+// register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR              0x0000003F  // Number of RX Frames in FIFO
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the PHY_MR23
+// register.
+//
+//*****************************************************************************
+#define PHY_MR23_LED1_TX        0x00000020  // TX Activity
+#define PHY_MR23_LED1_RX        0x00000030  // RX Activity
+#define PHY_MR23_LED1_COL       0x00000040  // Collision
+#define PHY_MR23_LED0_TX        0x00000002  // TX Activity
+#define PHY_MR23_LED0_RX        0x00000003  // RX Activity
+#define PHY_MR23_LED0_COL       0x00000004  // Collision
+
+#endif
+
+#endif // __HW_ETHERNET_H__


Property changes on: trunk/src/platform/lm3s/hw_ethernet.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_flash.h
===================================================================
--- trunk/src/platform/lm3s/hw_flash.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_flash.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,295 +1,328 @@
-//*****************************************************************************
-//
-// hw_flash.h - Macros used when accessing the flash controller.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-//
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_FLASH_H__
-#define __HW_FLASH_H__
-
-//*****************************************************************************
-//
-// The following are defines for the FLASH register offsets.
-//
-//*****************************************************************************
-#define FLASH_FMA               0x400FD000  // Memory address register
-#define FLASH_FMD               0x400FD004  // Memory data register
-#define FLASH_FMC               0x400FD008  // Memory control register
-#define FLASH_FCRIS             0x400FD00C  // Raw interrupt status register
-#define FLASH_FCIM              0x400FD010  // Interrupt mask register
-#define FLASH_FCMISC            0x400FD014  // Interrupt status register
-#define FLASH_RMCTL             0x400FE0F0  // ROM Control
-#define FLASH_RMVER             0x400FE0F4  // ROM Version Register
-#define FLASH_FMPRE             0x400FE130  // FLASH read protect register
-#define FLASH_FMPPE             0x400FE134  // FLASH program protect register
-#define FLASH_USECRL            0x400FE140  // uSec reload register
-#define FLASH_USERDBG           0x400FE1D0  // User Debug
-#define FLASH_USERREG0          0x400FE1E0  // User Register 0
-#define FLASH_USERREG1          0x400FE1E4  // User Register 1
-#define FLASH_USERREG2          0x400FE1E8  // User Register 2
-#define FLASH_USERREG3          0x400FE1EC  // User Register 3
-#define FLASH_FMPRE0            0x400FE200  // FLASH read protect register 0
-#define FLASH_FMPRE1            0x400FE204  // FLASH read protect register 1
-#define FLASH_FMPRE2            0x400FE208  // FLASH read protect register 2
-#define FLASH_FMPRE3            0x400FE20C  // FLASH read protect register 3
-#define FLASH_FMPPE0            0x400FE400  // FLASH program protect register 0
-#define FLASH_FMPPE1            0x400FE404  // FLASH program protect register 1
-#define FLASH_FMPPE2            0x400FE408  // FLASH program protect register 2
-#define FLASH_FMPPE3            0x400FE40C  // FLASH program protect register 3
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_FMC register.
-//
-//*****************************************************************************
-#define FLASH_FMC_WRKEY_M       0xFFFF0000  // FLASH write key mask
-#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
-#define FLASH_FMC_COMT          0x00000008  // Commit user register
-#define FLASH_FMC_MERASE        0x00000004  // Mass erase FLASH
-#define FLASH_FMC_ERASE         0x00000002  // Erase FLASH page
-#define FLASH_FMC_WRITE         0x00000001  // Write FLASH word
-#define FLASH_FMC_WRKEY_S       16
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_FCRIS register.
-//
-//*****************************************************************************
-#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt
-                                            // Status.
-#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_FCIM register.
-//
-//*****************************************************************************
-#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask.
-#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_FMIS register.
-//
-//*****************************************************************************
-#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
-                                            // Status and Clear.
-#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
-                                            // and Clear.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_FMPRE and
-// FLASH_FMPPE registers.
-//
-//*****************************************************************************
-#define FLASH_FMP_BLOCK_31      0x80000000  // Enable for block 31
-#define FLASH_FMP_BLOCK_30      0x40000000  // Enable for block 30
-#define FLASH_FMP_BLOCK_29      0x20000000  // Enable for block 29
-#define FLASH_FMP_BLOCK_28      0x10000000  // Enable for block 28
-#define FLASH_FMP_BLOCK_27      0x08000000  // Enable for block 27
-#define FLASH_FMP_BLOCK_26      0x04000000  // Enable for block 26
-#define FLASH_FMP_BLOCK_25      0x02000000  // Enable for block 25
-#define FLASH_FMP_BLOCK_24      0x01000000  // Enable for block 24
-#define FLASH_FMP_BLOCK_23      0x00800000  // Enable for block 23
-#define FLASH_FMP_BLOCK_22      0x00400000  // Enable for block 22
-#define FLASH_FMP_BLOCK_21      0x00200000  // Enable for block 21
-#define FLASH_FMP_BLOCK_20      0x00100000  // Enable for block 20
-#define FLASH_FMP_BLOCK_19      0x00080000  // Enable for block 19
-#define FLASH_FMP_BLOCK_18      0x00040000  // Enable for block 18
-#define FLASH_FMP_BLOCK_17      0x00020000  // Enable for block 17
-#define FLASH_FMP_BLOCK_16      0x00010000  // Enable for block 16
-#define FLASH_FMP_BLOCK_15      0x00008000  // Enable for block 15
-#define FLASH_FMP_BLOCK_14      0x00004000  // Enable for block 14
-#define FLASH_FMP_BLOCK_13      0x00002000  // Enable for block 13
-#define FLASH_FMP_BLOCK_12      0x00001000  // Enable for block 12
-#define FLASH_FMP_BLOCK_11      0x00000800  // Enable for block 11
-#define FLASH_FMP_BLOCK_10      0x00000400  // Enable for block 10
-#define FLASH_FMP_BLOCK_9       0x00000200  // Enable for block 9
-#define FLASH_FMP_BLOCK_8       0x00000100  // Enable for block 8
-#define FLASH_FMP_BLOCK_7       0x00000080  // Enable for block 7
-#define FLASH_FMP_BLOCK_6       0x00000040  // Enable for block 6
-#define FLASH_FMP_BLOCK_5       0x00000020  // Enable for block 5
-#define FLASH_FMP_BLOCK_4       0x00000010  // Enable for block 4
-#define FLASH_FMP_BLOCK_3       0x00000008  // Enable for block 3
-#define FLASH_FMP_BLOCK_2       0x00000004  // Enable for block 2
-#define FLASH_FMP_BLOCK_1       0x00000002  // Enable for block 1
-#define FLASH_FMP_BLOCK_0       0x00000001  // Enable for block 0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_USECRL register.
-//
-//*****************************************************************************
-#define FLASH_USECRL_M          0x000000FF  // Microsecond Reload Value.
-#define FLASH_USECRL_S          0
-
-//*****************************************************************************
-//
-// The following are defines for the erase size of the FLASH block that is
-// erased by an erase operation, and the protect size is the size of the FLASH
-// block that is protected by each protection register.
-//
-//*****************************************************************************
-#define FLASH_PROTECT_SIZE      0x00000800
-#define FLASH_ERASE_SIZE        0x00000400
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_FMA register.
-//
-//*****************************************************************************
-#define FLASH_FMA_OFFSET_M      0x0003FFFF  // Address Offset.
-#define FLASH_FMA_OFFSET_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_FMD register.
-//
-//*****************************************************************************
-#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value.
-#define FLASH_FMD_DATA_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_USERDBG register.
-//
-//*****************************************************************************
-#define FLASH_USERDBG_NW        0x80000000  // User Debug Not Written.
-#define FLASH_USERDBG_DATA_M    0x7FFFFFFC  // User Data.
-#define FLASH_USERDBG_DBG1      0x00000002  // Debug Control 1.
-#define FLASH_USERDBG_DBG0      0x00000001  // Debug Control 0.
-#define FLASH_USERDBG_DATA_S    2
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_USERREG0 register.
-//
-//*****************************************************************************
-#define FLASH_USERREG0_NW       0x80000000  // Not Written.
-#define FLASH_USERREG0_DATA_M   0x7FFFFFFF  // User Data.
-#define FLASH_USERREG0_DATA_S   0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_USERREG1 register.
-//
-//*****************************************************************************
-#define FLASH_USERREG1_NW       0x80000000  // Not Written.
-#define FLASH_USERREG1_DATA_M   0x7FFFFFFF  // User Data.
-#define FLASH_USERREG1_DATA_S   0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_RMCTL register.
-//
-//*****************************************************************************
-#define FLASH_RMCTL_BA          0x00000001  // Boot Alias.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_RMVER register.
-//
-//*****************************************************************************
-#define FLASH_RMVER_CONT_M      0xFF000000  // ROM Contents.
-#define FLASH_RMVER_CONT_LM     0x00000000  // Boot Loader &amp; DriverLib
-#define FLASH_RMVER_SIZE_M      0x00FF0000  // ROM Size.
-#define FLASH_RMVER_SIZE_11K    0x00000000  // 11KB Size
-#define FLASH_RMVER_VER_M       0x0000FF00  // ROM Version.
-#define FLASH_RMVER_REV_M       0x000000FF  // ROM Revision.
-#define FLASH_RMVER_VER_S       8
-#define FLASH_RMVER_REV_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_USERREG2 register.
-//
-//*****************************************************************************
-#define FLASH_USERREG2_NW       0x80000000  // Not Written.
-#define FLASH_USERREG2_DATA_M   0x7FFFFFFF  // User Data.
-#define FLASH_USERREG2_DATA_S   0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the FLASH_USERREG3 register.
-//
-//*****************************************************************************
-#define FLASH_USERREG3_NW       0x80000000  // Not Written.
-#define FLASH_USERREG3_DATA_M   0x7FFFFFFF  // User Data.
-#define FLASH_USERREG3_DATA_S   0
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the FLASH_FMC
-// register.
-//
-//*****************************************************************************
-#define FLASH_FMC_WRKEY_MASK    0xFFFF0000  // FLASH write key mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the FLASH_FCRIS
-// register.
-//
-//*****************************************************************************
-#define FLASH_FCRIS_PROGRAM     0x00000002  // Programming status
-#define FLASH_FCRIS_ACCESS      0x00000001  // Invalid access status
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the FLASH_FCIM
-// register.
-//
-//*****************************************************************************
-#define FLASH_FCIM_PROGRAM      0x00000002  // Programming mask
-#define FLASH_FCIM_ACCESS       0x00000001  // Invalid access mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the FLASH_FMIS
-// register.
-//
-//*****************************************************************************
-#define FLASH_FCMISC_PROGRAM    0x00000002  // Programming status
-#define FLASH_FCMISC_ACCESS     0x00000001  // Invalid access status
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the FLASH_USECRL
-// register.
-//
-//*****************************************************************************
-#define FLASH_USECRL_MASK       0x000000FF  // Clock per uSec
-#define FLASH_USECRL_SHIFT      0
-
-#endif
-
-#endif // __HW_FLASH_H__
+//*****************************************************************************
+//
+// hw_flash.h - Macros used when accessing the flash controller.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_FLASH_H__
+#define __HW_FLASH_H__
+
+//*****************************************************************************
+//
+// The following are defines for the FLASH register offsets.
+//
+//*****************************************************************************
+#define FLASH_FMA               0x400FD000  // Memory address register
+#define FLASH_FMD               0x400FD004  // Memory data register
+#define FLASH_FMC               0x400FD008  // Memory control register
+#define FLASH_FCRIS             0x400FD00C  // Raw interrupt status register
+#define FLASH_FCIM              0x400FD010  // Interrupt mask register
+#define FLASH_FCMISC            0x400FD014  // Interrupt status register
+#define FLASH_FMC2              0x400FD020  // Flash Memory Control 2
+#define FLASH_FWBVAL            0x400FD030  // Flash Write Buffer Valid
+#define FLASH_FWBN              0x400FD100  // Flash Write Buffer Register n
+#define FLASH_RMCTL             0x400FE0F0  // ROM Control
+#define FLASH_RMVER             0x400FE0F4  // ROM Version Register
+#define FLASH_FMPRE             0x400FE130  // FLASH read protect register
+#define FLASH_FMPPE             0x400FE134  // FLASH program protect register
+#define FLASH_USECRL            0x400FE140  // uSec reload register
+#define FLASH_USERDBG           0x400FE1D0  // User Debug
+#define FLASH_USERREG0          0x400FE1E0  // User Register 0
+#define FLASH_USERREG1          0x400FE1E4  // User Register 1
+#define FLASH_USERREG2          0x400FE1E8  // User Register 2
+#define FLASH_USERREG3          0x400FE1EC  // User Register 3
+#define FLASH_FMPRE0            0x400FE200  // FLASH read protect register 0
+#define FLASH_FMPRE1            0x400FE204  // FLASH read protect register 1
+#define FLASH_FMPRE2            0x400FE208  // FLASH read protect register 2
+#define FLASH_FMPRE3            0x400FE20C  // FLASH read protect register 3
+#define FLASH_FMPPE0            0x400FE400  // FLASH program protect register 0
+#define FLASH_FMPPE1            0x400FE404  // FLASH program protect register 1
+#define FLASH_FMPPE2            0x400FE408  // FLASH program protect register 2
+#define FLASH_FMPPE3            0x400FE40C  // FLASH program protect register 3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_M       0xFFFF0000  // FLASH write key mask
+#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
+#define FLASH_FMC_COMT          0x00000008  // Commit user register
+#define FLASH_FMC_MERASE        0x00000004  // Mass erase FLASH
+#define FLASH_FMC_ERASE         0x00000002  // Erase FLASH page
+#define FLASH_FMC_WRITE         0x00000001  // Write FLASH word
+#define FLASH_FMC_WRKEY_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC2 register.
+//
+//*****************************************************************************
+#define FLASH_FMC2_WRKEY        0xA4420000  // FLASH write key
+#define FLASH_FMC2_WRBUF        0x00000001  // Buffered Flash Write.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCRIS register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt
+                                            // Status.
+#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCIM register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask.
+#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMIS register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
+                                            // Status and Clear.
+#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMPRE and
+// FLASH_FMPPE registers.
+//
+//*****************************************************************************
+#define FLASH_FMP_BLOCK_31      0x80000000  // Enable for block 31
+#define FLASH_FMP_BLOCK_30      0x40000000  // Enable for block 30
+#define FLASH_FMP_BLOCK_29      0x20000000  // Enable for block 29
+#define FLASH_FMP_BLOCK_28      0x10000000  // Enable for block 28
+#define FLASH_FMP_BLOCK_27      0x08000000  // Enable for block 27
+#define FLASH_FMP_BLOCK_26      0x04000000  // Enable for block 26
+#define FLASH_FMP_BLOCK_25      0x02000000  // Enable for block 25
+#define FLASH_FMP_BLOCK_24      0x01000000  // Enable for block 24
+#define FLASH_FMP_BLOCK_23      0x00800000  // Enable for block 23
+#define FLASH_FMP_BLOCK_22      0x00400000  // Enable for block 22
+#define FLASH_FMP_BLOCK_21      0x00200000  // Enable for block 21
+#define FLASH_FMP_BLOCK_20      0x00100000  // Enable for block 20
+#define FLASH_FMP_BLOCK_19      0x00080000  // Enable for block 19
+#define FLASH_FMP_BLOCK_18      0x00040000  // Enable for block 18
+#define FLASH_FMP_BLOCK_17      0x00020000  // Enable for block 17
+#define FLASH_FMP_BLOCK_16      0x00010000  // Enable for block 16
+#define FLASH_FMP_BLOCK_15      0x00008000  // Enable for block 15
+#define FLASH_FMP_BLOCK_14      0x00004000  // Enable for block 14
+#define FLASH_FMP_BLOCK_13      0x00002000  // Enable for block 13
+#define FLASH_FMP_BLOCK_12      0x00001000  // Enable for block 12
+#define FLASH_FMP_BLOCK_11      0x00000800  // Enable for block 11
+#define FLASH_FMP_BLOCK_10      0x00000400  // Enable for block 10
+#define FLASH_FMP_BLOCK_9       0x00000200  // Enable for block 9
+#define FLASH_FMP_BLOCK_8       0x00000100  // Enable for block 8
+#define FLASH_FMP_BLOCK_7       0x00000080  // Enable for block 7
+#define FLASH_FMP_BLOCK_6       0x00000040  // Enable for block 6
+#define FLASH_FMP_BLOCK_5       0x00000020  // Enable for block 5
+#define FLASH_FMP_BLOCK_4       0x00000010  // Enable for block 4
+#define FLASH_FMP_BLOCK_3       0x00000008  // Enable for block 3
+#define FLASH_FMP_BLOCK_2       0x00000004  // Enable for block 2
+#define FLASH_FMP_BLOCK_1       0x00000002  // Enable for block 1
+#define FLASH_FMP_BLOCK_0       0x00000001  // Enable for block 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USECRL register.
+//
+//*****************************************************************************
+#define FLASH_USECRL_M          0x000000FF  // Microsecond Reload Value.
+#define FLASH_USECRL_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the erase size of the FLASH block that is
+// erased by an erase operation, and the protect size is the size of the FLASH
+// block that is protected by each protection register.
+//
+//*****************************************************************************
+#define FLASH_PROTECT_SIZE      0x00000800
+#define FLASH_ERASE_SIZE        0x00000400
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMA register.
+//
+//*****************************************************************************
+#define FLASH_FMA_OFFSET_M      0x0003FFFF  // Address Offset.
+#define FLASH_FMA_OFFSET_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMD register.
+//
+//*****************************************************************************
+#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value.
+#define FLASH_FMD_DATA_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERDBG register.
+//
+//*****************************************************************************
+#define FLASH_USERDBG_NW        0x80000000  // User Debug Not Written.
+#define FLASH_USERDBG_DATA_M    0x7FFFFFFC  // User Data.
+#define FLASH_USERDBG_DBG1      0x00000002  // Debug Control 1.
+#define FLASH_USERDBG_DBG0      0x00000001  // Debug Control 0.
+#define FLASH_USERDBG_DATA_S    2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG0 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG0_NW       0x80000000  // Not Written.
+#define FLASH_USERREG0_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG0_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG1 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG1_NW       0x80000000  // Not Written.
+#define FLASH_USERREG1_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG1_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_RMCTL register.
+//
+//*****************************************************************************
+#define FLASH_RMCTL_BA          0x00000001  // Boot Alias.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_RMVER register.
+//
+//*****************************************************************************
+#define FLASH_RMVER_CONT_M      0xFF000000  // ROM Contents.
+#define FLASH_RMVER_CONT_LM     0x00000000  // Stellaris Boot Loader &amp;
+                                            // DriverLib
+#define FLASH_RMVER_CONT_LM_AES 0x02000000  // Stellaris Boot Loader &amp;
+                                            // DriverLib with AES
+#define FLASH_RMVER_CONT_LM_AES_SAFERTOS \
+                                0x03000000  // Stellaris Boot Loader &amp;
+                                            // DriverLib with AES and SAFERTOS
+#define FLASH_RMVER_SIZE_M      0x00FF0000  // ROM Size.
+#define FLASH_RMVER_SIZE_11K    0x00000000  // 11KB Size
+#define FLASH_RMVER_SIZE_23_75K 0x00020000  // 23.75KB Size
+#define FLASH_RMVER_SIZE_28_25K 0x00030000  // 28.25KB Size
+#define FLASH_RMVER_VER_M       0x0000FF00  // ROM Version.
+#define FLASH_RMVER_REV_M       0x000000FF  // ROM Revision.
+#define FLASH_RMVER_VER_S       8
+#define FLASH_RMVER_REV_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG2 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG2_NW       0x80000000  // Not Written.
+#define FLASH_USERREG2_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG2_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG3 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG3_NW       0x80000000  // Not Written.
+#define FLASH_USERREG3_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG3_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FWBVAL register.
+//
+//*****************************************************************************
+#define FLASH_FWBVAL_FWB_M      0xFFFFFFFF  // Flash Write Buffer.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FWBN register.
+//
+//*****************************************************************************
+#define FLASH_FWBN_DATA_M       0xFFFFFFFF  // Data.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FMC
+// register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_MASK    0xFFFF0000  // FLASH write key mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FCRIS
+// register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PROGRAM     0x00000002  // Programming status
+#define FLASH_FCRIS_ACCESS      0x00000001  // Invalid access status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FCIM
+// register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PROGRAM      0x00000002  // Programming mask
+#define FLASH_FCIM_ACCESS       0x00000001  // Invalid access mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_FMIS
+// register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PROGRAM    0x00000002  // Programming status
+#define FLASH_FCMISC_ACCESS     0x00000001  // Invalid access status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the FLASH_USECRL
+// register.
+//
+//*****************************************************************************
+#define FLASH_USECRL_MASK       0x000000FF  // Clock per uSec
+#define FLASH_USECRL_SHIFT      0
+
+#endif
+
+#endif // __HW_FLASH_H__


Property changes on: trunk/src/platform/lm3s/hw_flash.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_gpio.h
===================================================================
--- trunk/src/platform/lm3s/hw_gpio.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_gpio.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,135 +1,593 @@
-//*****************************************************************************
-//
-// hw_gpio.h - Defines and Macros for GPIO hardware.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_GPIO_H__
-#define __HW_GPIO_H__
-
-//*****************************************************************************
-//
-// The following are defines for the GPIO Register offsets.
-//
-//*****************************************************************************
-#define GPIO_O_DATA             0x00000000  // Data register.
-#define GPIO_O_DIR              0x00000400  // Data direction register.
-#define GPIO_O_IS               0x00000404  // Interrupt sense register.
-#define GPIO_O_IBE              0x00000408  // Interrupt both edges register.
-#define GPIO_O_IEV              0x0000040C  // Interrupt event register.
-#define GPIO_O_IM               0x00000410  // Interrupt mask register.
-#define GPIO_O_RIS              0x00000414  // Raw interrupt status register.
-#define GPIO_O_MIS              0x00000418  // Masked interrupt status reg.
-#define GPIO_O_ICR              0x0000041C  // Interrupt clear register.
-#define GPIO_O_AFSEL            0x00000420  // Mode control select register.
-#define GPIO_O_DR2R             0x00000500  // 2ma drive select register.
-#define GPIO_O_DR4R             0x00000504  // 4ma drive select register.
-#define GPIO_O_DR8R             0x00000508  // 8ma drive select register.
-#define GPIO_O_ODR              0x0000050C  // Open drain select register.
-#define GPIO_O_PUR              0x00000510  // Pull up select register.
-#define GPIO_O_PDR              0x00000514  // Pull down select register.
-#define GPIO_O_SLR              0x00000518  // Slew rate control enable reg.
-#define GPIO_O_DEN              0x0000051C  // Digital input enable register.
-#define GPIO_O_LOCK             0x00000520  // Lock register.
-#define GPIO_O_CR               0x00000524  // Commit register.
-#define GPIO_O_AMSEL            0x00000528  // GPIO Analog Mode Select
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the GPIO_LOCK register.
-//
-//*****************************************************************************
-#define GPIO_LOCK_M             0xFFFFFFFF  // GPIO Lock.
-#define GPIO_LOCK_UNLOCKED      0x00000000  // GPIO_CR register is unlocked
-#define GPIO_LOCK_LOCKED        0x00000001  // GPIO_CR register is locked
-#define GPIO_LOCK_KEY           0x1ACCE551  // Unlocks the GPIO_CR register
-#define GPIO_LOCK_KEY_DD        0x4C4F434B  // Unlocks the GPIO_CR register on
-                                            // DustDevil-class devices and
-                                            // later.
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the GPIO Register offsets.
-//
-//*****************************************************************************
-#define GPIO_O_PeriphID4        0x00000FD0
-#define GPIO_O_PeriphID5        0x00000FD4
-#define GPIO_O_PeriphID6        0x00000FD8
-#define GPIO_O_PeriphID7        0x00000FDC
-#define GPIO_O_PeriphID0        0x00000FE0
-#define GPIO_O_PeriphID1        0x00000FE4
-#define GPIO_O_PeriphID2        0x00000FE8
-#define GPIO_O_PeriphID3        0x00000FEC
-#define GPIO_O_PCellID0         0x00000FF0
-#define GPIO_O_PCellID1         0x00000FF4
-#define GPIO_O_PCellID2         0x00000FF8
-#define GPIO_O_PCellID3         0x00000FFC
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the GPIO Register reset values.
-//
-//*****************************************************************************
-#define GPIO_RV_DEN             0x000000FF  // Digital input enable reg RV.
-#define GPIO_RV_PUR             0x000000FF  // Pull up select reg RV.
-#define GPIO_RV_DR2R            0x000000FF  // 2ma drive select reg RV.
-#define GPIO_RV_PCellID1        0x000000F0
-#define GPIO_RV_PCellID3        0x000000B1
-#define GPIO_RV_PeriphID0       0x00000061
-#define GPIO_RV_PeriphID1       0x00000010
-#define GPIO_RV_PCellID0        0x0000000D
-#define GPIO_RV_PCellID2        0x00000005
-#define GPIO_RV_PeriphID2       0x00000004
-#define GPIO_RV_LOCK            0x00000001  // Lock register RV.
-#define GPIO_RV_PeriphID7       0x00000000
-#define GPIO_RV_PDR             0x00000000  // Pull down select reg RV.
-#define GPIO_RV_IC              0x00000000  // Interrupt clear reg RV.
-#define GPIO_RV_SLR             0x00000000  // Slew rate control enable reg RV.
-#define GPIO_RV_ODR             0x00000000  // Open drain select reg RV.
-#define GPIO_RV_IBE             0x00000000  // Interrupt both edges reg RV.
-#define GPIO_RV_AFSEL           0x00000000  // Mode control select reg RV.
-#define GPIO_RV_IS              0x00000000  // Interrupt sense reg RV.
-#define GPIO_RV_IM              0x00000000  // Interrupt mask reg RV.
-#define GPIO_RV_PeriphID4       0x00000000
-#define GPIO_RV_PeriphID5       0x00000000
-#define GPIO_RV_DR8R            0x00000000  // 8ma drive select reg RV.
-#define GPIO_RV_RIS             0x00000000  // Raw interrupt status reg RV.
-#define GPIO_RV_DR4R            0x00000000  // 4ma drive select reg RV.
-#define GPIO_RV_IEV             0x00000000  // Intterupt event reg RV.
-#define GPIO_RV_DIR             0x00000000  // Data direction reg RV.
-#define GPIO_RV_PeriphID6       0x00000000
-#define GPIO_RV_PeriphID3       0x00000000
-#define GPIO_RV_DATA            0x00000000  // Data register reset value.
-#define GPIO_RV_MIS             0x00000000  // Masked interrupt status reg RV.
-
-#endif
-
-#endif // __HW_GPIO_H__
+//*****************************************************************************
+//
+// hw_gpio.h - Defines and Macros for GPIO hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_GPIO_H__
+#define __HW_GPIO_H__
+
+//*****************************************************************************
+//
+// The following are defines for the GPIO Register offsets.
+//
+//*****************************************************************************
+#define GPIO_O_DATA             0x00000000  // Data register.
+#define GPIO_O_DIR              0x00000400  // Data direction register.
+#define GPIO_O_IS               0x00000404  // Interrupt sense register.
+#define GPIO_O_IBE              0x00000408  // Interrupt both edges register.
+#define GPIO_O_IEV              0x0000040C  // Interrupt event register.
+#define GPIO_O_IM               0x00000410  // Interrupt mask register.
+#define GPIO_O_RIS              0x00000414  // Raw interrupt status register.
+#define GPIO_O_MIS              0x00000418  // Masked interrupt status reg.
+#define GPIO_O_ICR              0x0000041C  // Interrupt clear register.
+#define GPIO_O_AFSEL            0x00000420  // Mode control select register.
+#define GPIO_O_DR2R             0x00000500  // 2ma drive select register.
+#define GPIO_O_DR4R             0x00000504  // 4ma drive select register.
+#define GPIO_O_DR8R             0x00000508  // 8ma drive select register.
+#define GPIO_O_ODR              0x0000050C  // Open drain select register.
+#define GPIO_O_PUR              0x00000510  // Pull up select register.
+#define GPIO_O_PDR              0x00000514  // Pull down select register.
+#define GPIO_O_SLR              0x00000518  // Slew rate control enable reg.
+#define GPIO_O_DEN              0x0000051C  // Digital input enable register.
+#define GPIO_O_LOCK             0x00000520  // Lock register.
+#define GPIO_O_CR               0x00000524  // Commit register.
+#define GPIO_O_AMSEL            0x00000528  // GPIO Analog Mode Select
+#define GPIO_O_PCTL             0x0000052C  // GPIO Port Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_LOCK register.
+//
+//*****************************************************************************
+#define GPIO_LOCK_M             0xFFFFFFFF  // GPIO Lock.
+#define GPIO_LOCK_UNLOCKED      0x00000000  // GPIO_CR register is unlocked
+#define GPIO_LOCK_LOCKED        0x00000001  // GPIO_CR register is locked
+#define GPIO_LOCK_KEY           0x1ACCE551  // Unlocks the GPIO_CR register
+#define GPIO_LOCK_KEY_DD        0x4C4F434B  // Unlocks the GPIO_CR register on
+                                            // DustDevil-class devices and
+                                            // later.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port A.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PA0_M         0x0000000F  // PA0 mask
+#define GPIO_PCTL_PA0_U0RX      0x00000001  // U0RX on PA0
+#define GPIO_PCTL_PA0_I2C1SCL   0x00000008  // I2C1SCL on PA0
+#define GPIO_PCTL_PA0_U1RX      0x00000009  // U1RX on PA0
+#define GPIO_PCTL_PA1_M         0x000000F0  // PA1 mask
+#define GPIO_PCTL_PA1_U0TX      0x00000010  // U0TX on PA1
+#define GPIO_PCTL_PA1_I2C1SDA   0x00000080  // I2C1SDA on PA1
+#define GPIO_PCTL_PA1_U1TX      0x00000090  // U1TX on PA1
+#define GPIO_PCTL_PA2_M         0x00000F00  // PA2 mask
+#define GPIO_PCTL_PA2_SSI0CLK   0x00000100  // SSI0CLK on PA2
+#define GPIO_PCTL_PA2_PWM4      0x00000400  // PWM4 on PA2
+#define GPIO_PCTL_PA2_I2S0RXSD  0x00000900  // I2S0RXSD on PA2
+#define GPIO_PCTL_PA3_M         0x0000F000  // PA3 mask
+#define GPIO_PCTL_PA3_SSI0FSS   0x00001000  // SSI0FSS on PA3
+#define GPIO_PCTL_PA3_PWM5      0x00004000  // PWM5 on PA3
+#define GPIO_PCTL_PA3_I2S0RXMCLK \
+                                0x00009000  // I2S0RXMCLK on PA3
+#define GPIO_PCTL_PA4_M         0x000F0000  // PA4 mask
+#define GPIO_PCTL_PA4_SSI0RX    0x00010000  // SSI0RX on PA4
+#define GPIO_PCTL_PA4_PWM6      0x00040000  // PWM6 on PA4
+#define GPIO_PCTL_PA4_CAN0RX    0x00050000  // CAN0RX on PA4
+#define GPIO_PCTL_PA4_I2S0TXSCK 0x00090000  // I2S0TXSCK on PA4
+#define GPIO_PCTL_PA5_M         0x00F00000  // PA5 mask
+#define GPIO_PCTL_PA5_SSI0TX    0x00100000  // SSI0TX on PA5
+#define GPIO_PCTL_PA5_PWM7      0x00400000  // PWM7 on PA5
+#define GPIO_PCTL_PA5_CAN0TX    0x00500000  // CAN0TX on PA5
+#define GPIO_PCTL_PA5_I2S0TXWS  0x00900000  // I2S0TXWS on PA5
+#define GPIO_PCTL_PA6_M         0x0F000000  // PA6 mask
+#define GPIO_PCTL_PA6_I2C1SCL   0x01000000  // I2C1SCL on PA6
+#define GPIO_PCTL_PA6_CCP1      0x02000000  // CCP1 on PA6
+#define GPIO_PCTL_PA6_PWM0      0x04000000  // PWM0 on PA6
+#define GPIO_PCTL_PA6_PWM4      0x05000000  // PWM4 on PA6
+#define GPIO_PCTL_PA6_CAN0RX    0x06000000  // CAN0RX on PA6
+#define GPIO_PCTL_PA6_USB0EPEN  0x08000000  // USB0EPEN on PA6
+#define GPIO_PCTL_PA6_U1CTS     0x09000000  // U1CTS on PA6
+#define GPIO_PCTL_PA7_M         0xF0000000  // PA7 mask
+#define GPIO_PCTL_PA7_I2C1SDA   0x10000000  // I2C1SDA on PA7
+#define GPIO_PCTL_PA7_CCP4      0x20000000  // CCP4 on PA7
+#define GPIO_PCTL_PA7_PWM1      0x40000000  // PWM1 on PA7
+#define GPIO_PCTL_PA7_PWM5      0x50000000  // PWM5 on PA7
+#define GPIO_PCTL_PA7_CAN0TX    0x60000000  // CAN0TX on PA7
+#define GPIO_PCTL_PA7_CCP3      0x70000000  // CCP3 on PA7
+#define GPIO_PCTL_PA7_USB0PFLT  0x80000000  // USB0PFLT on PA7
+#define GPIO_PCTL_PA7_U1DCD     0x90000000  // U1DCD on PA7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port B.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PB0_M         0x0000000F  // PB0 mask
+#define GPIO_PCTL_PB0_CCP0      0x00000001  // CCP0 on PB0
+#define GPIO_PCTL_PB0_PWM2      0x00000002  // PWM2 on PB0
+#define GPIO_PCTL_PB0_U1RX      0x00000005  // U1RX on PB0
+#define GPIO_PCTL_PB1_M         0x000000F0  // PB1 mask
+#define GPIO_PCTL_PB1_CCP2      0x00000010  // CCP2 on PB1
+#define GPIO_PCTL_PB1_PWM3      0x00000020  // PWM3 on PB1
+#define GPIO_PCTL_PB1_CCP1      0x00000040  // CCP1 on PB1
+#define GPIO_PCTL_PB1_U1TX      0x00000050  // U1TX on PB1
+#define GPIO_PCTL_PB2_M         0x00000F00  // PB2 mask
+#define GPIO_PCTL_PB2_I2C0SCL   0x00000100  // I2C0SCL on PB2
+#define GPIO_PCTL_PB2_IDX0      0x00000200  // IDX0 on PB2
+#define GPIO_PCTL_PB2_CCP3      0x00000400  // CCP3 on PB2
+#define GPIO_PCTL_PB2_CCP0      0x00000500  // CCP0 on PB2
+#define GPIO_PCTL_PB2_USB0EPEN  0x00000800  // USB0EPEN on PB2
+#define GPIO_PCTL_PB3_M         0x0000F000  // PB3 mask
+#define GPIO_PCTL_PB3_I2C0SDA   0x00001000  // I2C0SDA on PB3
+#define GPIO_PCTL_PB3_FAULT0    0x00002000  // FAULT0 on PB3
+#define GPIO_PCTL_PB3_FAULT3    0x00004000  // FAULT3 on PB3
+#define GPIO_PCTL_PB3_USB0PFLT  0x00008000  // USB0PFLT on PB3
+#define GPIO_PCTL_PB4_M         0x000F0000  // PB4 mask
+#define GPIO_PCTL_PB4_U2RX      0x00040000  // U2RX on PB4
+#define GPIO_PCTL_PB4_CAN0RX    0x00050000  // CAN0RX on PB4
+#define GPIO_PCTL_PB4_IDX0      0x00060000  // IDX0 on PB4
+#define GPIO_PCTL_PB4_U1RX      0x00070000  // U1RX on PB4
+#define GPIO_PCTL_PB4_EPI0S23   0x00080000  // EPI0S23 on PB4
+#define GPIO_PCTL_PB5_M         0x00F00000  // PB5 mask
+#define GPIO_PCTL_PB5_C0O       0x00100000  // C0O on PB5
+#define GPIO_PCTL_PB5_CCP5      0x00200000  // CCP5 on PB5
+#define GPIO_PCTL_PB5_CCP6      0x00300000  // CCP6 on PB5
+#define GPIO_PCTL_PB5_CCP0      0x00400000  // CCP0 on PB5
+#define GPIO_PCTL_PB5_CAN0TX    0x00500000  // CAN0TX on PB5
+#define GPIO_PCTL_PB5_CCP2      0x00600000  // CCP2 on PB5
+#define GPIO_PCTL_PB5_U1TX      0x00700000  // U1TX on PB5
+#define GPIO_PCTL_PB5_EPI0S22   0x00800000  // EPI0S22 on PB5
+#define GPIO_PCTL_PB6_M         0x0F000000  // PB6 mask
+#define GPIO_PCTL_PB6_CCP1      0x01000000  // CCP1 on PB6
+#define GPIO_PCTL_PB6_CCP7      0x02000000  // CCP7 on PB6
+#define GPIO_PCTL_PB6_C0O       0x03000000  // C0O on PB6
+#define GPIO_PCTL_PB6_FAULT1    0x04000000  // FAULT1 on PB6
+#define GPIO_PCTL_PB6_IDX0      0x05000000  // IDX0 on PB6
+#define GPIO_PCTL_PB6_CCP5      0x06000000  // CCP5 on PB6
+#define GPIO_PCTL_PB6_I2S0TXSCK 0x09000000  // I2S0TXSCK on PB6
+#define GPIO_PCTL_PB7_M         0xF0000000  // PB7 mask
+#define GPIO_PCTL_PB7_NMI       0x40000000  // NMI on PB7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port C.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PC0_M         0x0000000F  // PC0 mask
+#define GPIO_PCTL_PC0_TCK       0x00000003  // TCK on PC0
+#define GPIO_PCTL_PC1_M         0x000000F0  // PC1 mask
+#define GPIO_PCTL_PC1_TMS       0x00000030  // TMS on PC1
+#define GPIO_PCTL_PC2_M         0x00000F00  // PC2 mask
+#define GPIO_PCTL_PC2_TDI       0x00000300  // TDI on PC2
+#define GPIO_PCTL_PC3_M         0x0000F000  // PC3 mask
+#define GPIO_PCTL_PC3_TDO       0x00003000  // TDO on PC3
+#define GPIO_PCTL_PC4_M         0x000F0000  // PC4 mask
+#define GPIO_PCTL_PC4_CCP5      0x00010000  // CCP5 on PC4
+#define GPIO_PCTL_PC4_PHA0      0x00020000  // PHA0 on PC4
+#define GPIO_PCTL_PC4_PWM6      0x00040000  // PWM6 on PC4
+#define GPIO_PCTL_PC4_CCP2      0x00050000  // CCP2 on PC4
+#define GPIO_PCTL_PC4_CCP4      0x00060000  // CCP4 on PC4
+#define GPIO_PCTL_PC4_EPI0S2    0x00080000  // EPI0S2 on PC4
+#define GPIO_PCTL_PC4_CCP1      0x00090000  // CCP1 on PC4
+#define GPIO_PCTL_PC5_M         0x00F00000  // PC5 mask
+#define GPIO_PCTL_PC5_CCP1      0x00100000  // CCP1 on PC5
+#define GPIO_PCTL_PC5_C1O       0x00200000  // C1O on PC5
+#define GPIO_PCTL_PC5_C0O       0x00300000  // C0O on PC5
+#define GPIO_PCTL_PC5_FAULT2    0x00400000  // FAULT2 on PC5
+#define GPIO_PCTL_PC5_CCP3      0x00500000  // CCP3 on PC5
+#define GPIO_PCTL_PC5_USB0EPEN  0x00600000  // USB0EPEN on PC5
+#define GPIO_PCTL_PC5_EPI0S3    0x00800000  // EPI0S3 on PC5
+#define GPIO_PCTL_PC6_M         0x0F000000  // PC6 mask
+#define GPIO_PCTL_PC6_CCP3      0x01000000  // CCP3 on PC6
+#define GPIO_PCTL_PC6_PHB0      0x02000000  // PHB0 on PC6
+#define GPIO_PCTL_PC6_C2O       0x03000000  // C2O on PC6
+#define GPIO_PCTL_PC6_PWM7      0x04000000  // PWM7 on PC6
+#define GPIO_PCTL_PC6_U1RX      0x05000000  // U1RX on PC6
+#define GPIO_PCTL_PC6_CCP0      0x06000000  // CCP0 on PC6
+#define GPIO_PCTL_PC6_USB0PFLT  0x07000000  // USB0PFLT on PC6
+#define GPIO_PCTL_PC6_EPI0S4    0x08000000  // EPI0S4 on PC6
+#define GPIO_PCTL_PC7_M         0xF0000000  // PC7 mask
+#define GPIO_PCTL_PC7_CCP4      0x10000000  // CCP4 on PC7
+#define GPIO_PCTL_PC7_PHB0      0x20000000  // PHB0 on PC7
+#define GPIO_PCTL_PC7_CCP0      0x40000000  // CCP0 on PC7
+#define GPIO_PCTL_PC7_U1TX      0x50000000  // U1TX on PC7
+#define GPIO_PCTL_PC7_USB0PFLT  0x60000000  // USB0PFLT on PC7
+#define GPIO_PCTL_PC7_C1O       0x70000000  // C1O on PC7
+#define GPIO_PCTL_PC7_EPI0S5    0x80000000  // EPI0S5 on PC7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port D.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PD0_M         0x0000000F  // PD0 mask
+#define GPIO_PCTL_PD0_PWM0      0x00000001  // PWM0 on PD0
+#define GPIO_PCTL_PD0_CAN0RX    0x00000002  // CAN0RX on PD0
+#define GPIO_PCTL_PD0_IDX0      0x00000003  // IDX0 on PD0
+#define GPIO_PCTL_PD0_U2RX      0x00000004  // U2RX on PD0
+#define GPIO_PCTL_PD0_U1RX      0x00000005  // U1RX on PD0
+#define GPIO_PCTL_PD0_CCP6      0x00000006  // CCP6 on PD0
+#define GPIO_PCTL_PD0_I2S0RXSCK 0x00000008  // I2S0RXSCK on PD0
+#define GPIO_PCTL_PD0_U1CTS     0x00000009  // U1CTS on PD0
+#define GPIO_PCTL_PD1_M         0x000000F0  // PD1 mask
+#define GPIO_PCTL_PD1_PWM1      0x00000010  // PWM1 on PD1
+#define GPIO_PCTL_PD1_CAN0TX    0x00000020  // CAN0TX on PD1
+#define GPIO_PCTL_PD1_PHA0      0x00000030  // PHA0 on PD1
+#define GPIO_PCTL_PD1_U2TX      0x00000040  // U2TX on PD1
+#define GPIO_PCTL_PD1_U1TX      0x00000050  // U1TX on PD1
+#define GPIO_PCTL_PD1_CCP7      0x00000060  // CCP7 on PD1
+#define GPIO_PCTL_PD1_I2S0RXWS  0x00000080  // I2S0RXWS on PD1
+#define GPIO_PCTL_PD1_U1DCD     0x00000090  // U1DCD on PD1
+#define GPIO_PCTL_PD1_CCP2      0x000000A0  // CCP2 on PD1
+#define GPIO_PCTL_PD1_PHB1      0x000000B0  // PHB1 on PD1
+#define GPIO_PCTL_PD2_M         0x00000F00  // PD2 mask
+#define GPIO_PCTL_PD2_U1RX      0x00000100  // U1RX on PD2
+#define GPIO_PCTL_PD2_CCP6      0x00000200  // CCP6 on PD2
+#define GPIO_PCTL_PD2_PWM2      0x00000300  // PWM2 on PD2
+#define GPIO_PCTL_PD2_CCP5      0x00000400  // CCP5 on PD2
+#define GPIO_PCTL_PD2_EPI0S20   0x00000800  // EPI0S20 on PD2
+#define GPIO_PCTL_PD3_M         0x0000F000  // PD3 mask
+#define GPIO_PCTL_PD3_U1TX      0x00001000  // U1TX on PD3
+#define GPIO_PCTL_PD3_CCP7      0x00002000  // CCP7 on PD3
+#define GPIO_PCTL_PD3_PWM3      0x00003000  // PWM3 on PD3
+#define GPIO_PCTL_PD3_CCP0      0x00004000  // CCP0 on PD3
+#define GPIO_PCTL_PD3_EPI0S21   0x00008000  // EPI0S21 on PD3
+#define GPIO_PCTL_PD4_M         0x000F0000  // PD4 mask
+#define GPIO_PCTL_PD4_CCP0      0x00010000  // CCP0 on PD4
+#define GPIO_PCTL_PD4_CCP3      0x00020000  // CCP3 on PD4
+#define GPIO_PCTL_PD4_I2S0RXSD  0x00080000  // I2S0RXSD on PD4
+#define GPIO_PCTL_PD4_U1RI      0x00090000  // U1RI on PD4
+#define GPIO_PCTL_PD4_EPI0S19   0x000A0000  // EPI0S19 on PD4
+#define GPIO_PCTL_PD5_M         0x00F00000  // PD5 mask
+#define GPIO_PCTL_PD5_CCP2      0x00100000  // CCP2 on PD5
+#define GPIO_PCTL_PD5_CCP4      0x00200000  // CCP4 on PD5
+#define GPIO_PCTL_PD5_I2S0RXMCLK \
+                                0x00800000  // I2S0RXMCLK on PD5
+#define GPIO_PCTL_PD5_U2RX      0x00900000  // U2RX on PD5
+#define GPIO_PCTL_PD5_EPI0S28   0x00A00000  // EPI0S28 on PD5
+#define GPIO_PCTL_PD6_M         0x0F000000  // PD6 mask
+#define GPIO_PCTL_PD6_FAULT0    0x01000000  // FAULT0 on PD6
+#define GPIO_PCTL_PD6_I2S0TXSCK 0x08000000  // I2S0TXSCK on PD6
+#define GPIO_PCTL_PD6_U2TX      0x09000000  // U2TX on PD6
+#define GPIO_PCTL_PD6_EPI0S29   0x0A000000  // EPI0S29 on PD6
+#define GPIO_PCTL_PD7_M         0xF0000000  // PD7 mask
+#define GPIO_PCTL_PD7_IDX0      0x10000000  // IDX0 on PD7
+#define GPIO_PCTL_PD7_C0O       0x20000000  // C0O on PD7
+#define GPIO_PCTL_PD7_CCP1      0x30000000  // CCP1 on PD7
+#define GPIO_PCTL_PD7_I2S0TXWS  0x80000000  // I2S0TXWS on PD7
+#define GPIO_PCTL_PD7_U1DTR     0x90000000  // U1DTR on PD7
+#define GPIO_PCTL_PD7_EPI0S30   0xA0000000  // EPI0S30 on PD7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port E.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PE0_M         0x0000000F  // PE0 mask
+#define GPIO_PCTL_PE0_PWM4      0x00000001  // PWM4 on PE0
+#define GPIO_PCTL_PE0_SSI1CLK   0x00000002  // SSI1CLK on PE0
+#define GPIO_PCTL_PE0_CCP3      0x00000003  // CCP3 on PE0
+#define GPIO_PCTL_PE0_EPI0S8    0x00000008  // EPI0S8 on PE0
+#define GPIO_PCTL_PE0_USB0PFLT  0x00000009  // USB0PFLT on PE0
+#define GPIO_PCTL_PE1_M         0x000000F0  // PE1 mask
+#define GPIO_PCTL_PE1_PWM5      0x00000010  // PWM5 on PE1
+#define GPIO_PCTL_PE1_SSI1FSS   0x00000020  // SSI1FSS on PE1
+#define GPIO_PCTL_PE1_FAULT0    0x00000030  // FAULT0 on PE1
+#define GPIO_PCTL_PE1_CCP2      0x00000040  // CCP2 on PE1
+#define GPIO_PCTL_PE1_CCP6      0x00000050  // CCP6 on PE1
+#define GPIO_PCTL_PE1_EPI0S9    0x00000080  // EPI0S9 on PE1
+#define GPIO_PCTL_PE2_M         0x00000F00  // PE2 mask
+#define GPIO_PCTL_PE2_CCP4      0x00000100  // CCP4 on PE2
+#define GPIO_PCTL_PE2_SSI1RX    0x00000200  // SSI1RX on PE2
+#define GPIO_PCTL_PE2_PHB1      0x00000300  // PHB1 on PE2
+#define GPIO_PCTL_PE2_PHA0      0x00000400  // PHA0 on PE2
+#define GPIO_PCTL_PE2_CCP2      0x00000500  // CCP2 on PE2
+#define GPIO_PCTL_PE2_EPI0S24   0x00000800  // EPI0S24 on PE2
+#define GPIO_PCTL_PE3_M         0x0000F000  // PE3 mask
+#define GPIO_PCTL_PE3_CCP1      0x00001000  // CCP1 on PE3
+#define GPIO_PCTL_PE3_SSI1TX    0x00002000  // SSI1TX on PE3
+#define GPIO_PCTL_PE3_PHA1      0x00003000  // PHA1 on PE3
+#define GPIO_PCTL_PE3_PHB0      0x00004000  // PHB0 on PE3
+#define GPIO_PCTL_PE3_CCP7      0x00005000  // CCP7 on PE3
+#define GPIO_PCTL_PE3_EPI0S25   0x00008000  // EPI0S25 on PE3
+#define GPIO_PCTL_PE4_M         0x000F0000  // PE4 mask
+#define GPIO_PCTL_PE4_CCP3      0x00010000  // CCP3 on PE4
+#define GPIO_PCTL_PE4_FAULT0    0x00040000  // FAULT0 on PE4
+#define GPIO_PCTL_PE4_U2TX      0x00050000  // U2TX on PE4
+#define GPIO_PCTL_PE4_CCP2      0x00060000  // CCP2 on PE4
+#define GPIO_PCTL_PE4_I2S0TXWS  0x00090000  // I2S0TXWS on PE4
+#define GPIO_PCTL_PE5_M         0x00F00000  // PE5 mask
+#define GPIO_PCTL_PE5_CCP5      0x00100000  // CCP5 on PE5
+#define GPIO_PCTL_PE5_I2S0TXSD  0x00900000  // I2S0TXSD on PE5
+#define GPIO_PCTL_PE6_M         0x0F000000  // PE6 mask
+#define GPIO_PCTL_PE6_PWM4      0x01000000  // PWM4 on PE6
+#define GPIO_PCTL_PE6_C1O       0x02000000  // C1O on PE6
+#define GPIO_PCTL_PE6_U1CTS     0x09000000  // U1CTS on PE6
+#define GPIO_PCTL_PE7_M         0xF0000000  // PE7 mask
+#define GPIO_PCTL_PE7_PWM5      0x10000000  // PWM5 on PE7
+#define GPIO_PCTL_PE7_C2O       0x20000000  // C2O on PE7
+#define GPIO_PCTL_PE7_U1DCD     0x90000000  // U1DCD on PE7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port F.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PF0_M         0x0000000F  // PF0 mask
+#define GPIO_PCTL_PF0_CAN1RX    0x00000001  // CAN1RX on PF0
+#define GPIO_PCTL_PF0_PHB0      0x00000002  // PHB0 on PF0
+#define GPIO_PCTL_PF0_PWM0      0x00000003  // PWM0 on PF0
+#define GPIO_PCTL_PF0_I2S0TXSD  0x00000008  // I2S0TXSD on PF0
+#define GPIO_PCTL_PF0_U1DSR     0x00000009  // U1DSR on PF0
+#define GPIO_PCTL_PF1_M         0x000000F0  // PF1 mask
+#define GPIO_PCTL_PF1_CAN1TX    0x00000010  // CAN1TX on PF1
+#define GPIO_PCTL_PF1_IDX1      0x00000020  // IDX1 on PF1
+#define GPIO_PCTL_PF1_PWM1      0x00000030  // PWM1 on PF1
+#define GPIO_PCTL_PF1_I2S0TXMCLK \
+                                0x00000080  // I2S0TXMCLK on PF1
+#define GPIO_PCTL_PF1_U1RTS     0x00000090  // U1RTS on PF1
+#define GPIO_PCTL_PF1_CCP3      0x000000A0  // CCP3 on PF1
+#define GPIO_PCTL_PF2_M         0x00000F00  // PF2 mask
+#define GPIO_PCTL_PF2_LED1      0x00000100  // LED1 on PF2
+#define GPIO_PCTL_PF2_PWM4      0x00000200  // PWM4 on PF2
+#define GPIO_PCTL_PF2_PWM2      0x00000400  // PWM2 on PF2
+#define GPIO_PCTL_PF2_SSI1CLK   0x00000900  // SSI1CLK on PF2
+#define GPIO_PCTL_PF3_M         0x0000F000  // PF3 mask
+#define GPIO_PCTL_PF3_LED0      0x00001000  // LED0 on PF3
+#define GPIO_PCTL_PF3_PWM5      0x00002000  // PWM5 on PF3
+#define GPIO_PCTL_PF3_PWM3      0x00004000  // PWM3 on PF3
+#define GPIO_PCTL_PF3_SSI1FSS   0x00009000  // SSI1FSS on PF3
+#define GPIO_PCTL_PF4_M         0x000F0000  // PF4 mask
+#define GPIO_PCTL_PF4_CCP0      0x00010000  // CCP0 on PF4
+#define GPIO_PCTL_PF4_C0O       0x00020000  // C0O on PF4
+#define GPIO_PCTL_PF4_FAULT0    0x00040000  // FAULT0 on PF4
+#define GPIO_PCTL_PF4_EPI0S12   0x00080000  // EPI0S12 on PF4
+#define GPIO_PCTL_PF4_SSI1RX    0x00090000  // SSI1RX on PF4
+#define GPIO_PCTL_PF5_M         0x00F00000  // PF5 mask
+#define GPIO_PCTL_PF5_CCP2      0x00100000  // CCP2 on PF5
+#define GPIO_PCTL_PF5_C1O       0x00200000  // C1O on PF5
+#define GPIO_PCTL_PF5_EPI0S15   0x00800000  // EPI0S15 on PF5
+#define GPIO_PCTL_PF5_SSI1TX    0x00900000  // SSI1TX on PF5
+#define GPIO_PCTL_PF6_M         0x0F000000  // PF6 mask
+#define GPIO_PCTL_PF6_CCP1      0x01000000  // CCP1 on PF6
+#define GPIO_PCTL_PF6_C2O       0x02000000  // C2O on PF6
+#define GPIO_PCTL_PF6_PHA0      0x04000000  // PHA0 on PF6
+#define GPIO_PCTL_PF6_I2S0TXMCLK \
+                                0x09000000  // I2S0TXMCLK on PF6
+#define GPIO_PCTL_PF6_U1RTS     0x0A000000  // U1RTS on PF6
+#define GPIO_PCTL_PF7_M         0xF0000000  // PF7 mask
+#define GPIO_PCTL_PF7_CCP4      0x10000000  // CCP4 on PF7
+#define GPIO_PCTL_PF7_PHB0      0x40000000  // PHB0 on PF7
+#define GPIO_PCTL_PF7_EPI0S12   0x80000000  // EPI0S12 on PF7
+#define GPIO_PCTL_PF7_FAULT1    0x90000000  // FAULT1 on PF7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port G.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PG0_M         0x0000000F  // PG0 mask
+#define GPIO_PCTL_PG0_U2RX      0x00000001  // U2RX on PG0
+#define GPIO_PCTL_PG0_PWM0      0x00000002  // PWM0 on PG0
+#define GPIO_PCTL_PG0_I2C1SCL   0x00000003  // I2C1SCL on PG0
+#define GPIO_PCTL_PG0_PWM4      0x00000004  // PWM4 on PG0
+#define GPIO_PCTL_PG0_USB0EPEN  0x00000007  // USB0EPEN on PG0
+#define GPIO_PCTL_PG0_EPI0S13   0x00000008  // EPI0S13 on PG0
+#define GPIO_PCTL_PG1_M         0x000000F0  // PG1 mask
+#define GPIO_PCTL_PG1_U2TX      0x00000010  // U2TX on PG1
+#define GPIO_PCTL_PG1_PWM1      0x00000020  // PWM1 on PG1
+#define GPIO_PCTL_PG1_I2C1SDA   0x00000030  // I2C1SDA on PG1
+#define GPIO_PCTL_PG1_PWM5      0x00000040  // PWM5 on PG1
+#define GPIO_PCTL_PG1_EPI0S14   0x00000080  // EPI0S14 on PG1
+#define GPIO_PCTL_PG2_M         0x00000F00  // PG2 mask
+#define GPIO_PCTL_PG2_PWM0      0x00000100  // PWM0 on PG2
+#define GPIO_PCTL_PG2_FAULT0    0x00000400  // FAULT0 on PG2
+#define GPIO_PCTL_PG2_IDX1      0x00000800  // IDX1 on PG2
+#define GPIO_PCTL_PG2_I2S0RXSD  0x00000900  // I2S0RXSD on PG2
+#define GPIO_PCTL_PG3_M         0x0000F000  // PG3 mask
+#define GPIO_PCTL_PG3_PWM1      0x00001000  // PWM1 on PG3
+#define GPIO_PCTL_PG3_FAULT2    0x00004000  // FAULT2 on PG3
+#define GPIO_PCTL_PG3_FAULT0    0x00008000  // FAULT0 on PG3
+#define GPIO_PCTL_PG3_I2S0RXMCLK \
+                                0x00009000  // I2S0RXMCLK on PG3
+#define GPIO_PCTL_PG4_M         0x000F0000  // PG4 mask
+#define GPIO_PCTL_PG4_CCP3      0x00010000  // CCP3 on PG4
+#define GPIO_PCTL_PG4_FAULT1    0x00040000  // FAULT1 on PG4
+#define GPIO_PCTL_PG4_EPI0S15   0x00080000  // EPI0S15 on PG4
+#define GPIO_PCTL_PG4_PWM6      0x00090000  // PWM6 on PG4
+#define GPIO_PCTL_PG4_U1RI      0x000A0000  // U1RI on PG4
+#define GPIO_PCTL_PG5_M         0x00F00000  // PG5 mask
+#define GPIO_PCTL_PG5_CCP5      0x00100000  // CCP5 on PG5
+#define GPIO_PCTL_PG5_IDX0      0x00400000  // IDX0 on PG5
+#define GPIO_PCTL_PG5_FAULT1    0x00500000  // FAULT1 on PG5
+#define GPIO_PCTL_PG5_PWM7      0x00800000  // PWM7 on PG5
+#define GPIO_PCTL_PG5_I2S0RXSCK 0x00900000  // I2S0RXSCK on PG5
+#define GPIO_PCTL_PG5_U1DTR     0x00A00000  // U1DTR on PG5
+#define GPIO_PCTL_PG6_M         0x0F000000  // PG6 mask
+#define GPIO_PCTL_PG6_PHA1      0x01000000  // PHA1 on PG6
+#define GPIO_PCTL_PG6_PWM6      0x04000000  // PWM6 on PG6
+#define GPIO_PCTL_PG6_FAULT1    0x08000000  // FAULT1 on PG6
+#define GPIO_PCTL_PG6_I2S0RXWS  0x09000000  // I2S0RXWS on PG6
+#define GPIO_PCTL_PG6_U1RI      0x0A000000  // U1RI on PG6
+#define GPIO_PCTL_PG7_M         0xF0000000  // PG7 mask
+#define GPIO_PCTL_PG7_PHB1      0x10000000  // PHB1 on PG7
+#define GPIO_PCTL_PG7_PWM7      0x40000000  // PWM7 on PG7
+#define GPIO_PCTL_PG7_CCP5      0x80000000  // CCP5 on PG7
+#define GPIO_PCTL_PG7_EPI0S31   0x90000000  // EPI0S31 on PG7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port H.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PH0_M         0x0000000F  // PH0 mask
+#define GPIO_PCTL_PH0_CCP6      0x00000001  // CCP6 on PH0
+#define GPIO_PCTL_PH0_PWM2      0x00000002  // PWM2 on PH0
+#define GPIO_PCTL_PH0_EPI0S6    0x00000008  // EPI0S6 on PH0
+#define GPIO_PCTL_PH0_PWM4      0x00000009  // PWM4 on PH0
+#define GPIO_PCTL_PH1_M         0x000000F0  // PH1 mask
+#define GPIO_PCTL_PH1_CCP7      0x00000010  // CCP7 on PH1
+#define GPIO_PCTL_PH1_PWM3      0x00000020  // PWM3 on PH1
+#define GPIO_PCTL_PH1_EPI0S7    0x00000080  // EPI0S7 on PH1
+#define GPIO_PCTL_PH1_PWM5      0x00000090  // PWM5 on PH1
+#define GPIO_PCTL_PH2_M         0x00000F00  // PH2 mask
+#define GPIO_PCTL_PH2_IDX1      0x00000100  // IDX1 on PH2
+#define GPIO_PCTL_PH2_C1O       0x00000200  // C1O on PH2
+#define GPIO_PCTL_PH2_FAULT3    0x00000400  // FAULT3 on PH2
+#define GPIO_PCTL_PH2_EPI0S1    0x00000800  // EPI0S1 on PH2
+#define GPIO_PCTL_PH3_M         0x0000F000  // PH3 mask
+#define GPIO_PCTL_PH3_PHB0      0x00001000  // PHB0 on PH3
+#define GPIO_PCTL_PH3_FAULT0    0x00002000  // FAULT0 on PH3
+#define GPIO_PCTL_PH3_USB0EPEN  0x00004000  // USB0EPEN on PH3
+#define GPIO_PCTL_PH3_EPI0S0    0x00008000  // EPI0S0 on PH3
+#define GPIO_PCTL_PH4_M         0x000F0000  // PH4 mask
+#define GPIO_PCTL_PH4_USB0PFLT  0x00040000  // USB0PFLT on PH4
+#define GPIO_PCTL_PH4_EPI0S10   0x00080000  // EPI0S10 on PH4
+#define GPIO_PCTL_PH4_SSI1CLK   0x000B0000  // SSI1CLK on PH4
+#define GPIO_PCTL_PH5_M         0x00F00000  // PH5 mask
+#define GPIO_PCTL_PH5_EPI0S11   0x00800000  // EPI0S11 on PH5
+#define GPIO_PCTL_PH5_FAULT2    0x00A00000  // FAULT2 on PH5
+#define GPIO_PCTL_PH5_SSI1FSS   0x00B00000  // SSI1FSS on PH5
+#define GPIO_PCTL_PH6_M         0x0F000000  // PH6 mask
+#define GPIO_PCTL_PH6_EPI0S26   0x08000000  // EPI0S26 on PH6
+#define GPIO_PCTL_PH6_PWM4      0x0A000000  // PWM4 on PH6
+#define GPIO_PCTL_PH6_SSI1RX    0x0B000000  // SSI1RX on PH6
+#define GPIO_PCTL_PH7_M         0xF0000000  // PH7 mask
+#define GPIO_PCTL_PH7_EPI0S27   0x80000000  // EPI0S27 on PH7
+#define GPIO_PCTL_PH7_PWM5      0xA0000000  // PWM5 on PH7
+#define GPIO_PCTL_PH7_SSI1TX    0xB0000000  // SSI1TX on PH7
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_PCTL register for
+// port J.
+//
+//*****************************************************************************
+#define GPIO_PCTL_PJ0_M         0x0000000F  // PJ0 mask
+#define GPIO_PCTL_PJ0_EPI0S16   0x00000008  // EPI0S16 on PJ0
+#define GPIO_PCTL_PJ0_PWM0      0x0000000A  // PWM0 on PJ0
+#define GPIO_PCTL_PJ0_I2C1SCL   0x0000000B  // I2C1SCL on PJ0
+#define GPIO_PCTL_PJ1_M         0x000000F0  // PJ1 mask
+#define GPIO_PCTL_PJ1_EPI0S17   0x00000080  // EPI0S17 on PJ1
+#define GPIO_PCTL_PJ1_USB0PFLT  0x00000090  // USB0PFLT on PJ1
+#define GPIO_PCTL_PJ1_PWM1      0x000000A0  // PWM1 on PJ1
+#define GPIO_PCTL_PJ1_I2C1SDA   0x000000B0  // I2C1SDA on PJ1
+#define GPIO_PCTL_PJ2_M         0x00000F00  // PJ2 mask
+#define GPIO_PCTL_PJ2_EPI0S18   0x00000800  // EPI0S18 on PJ2
+#define GPIO_PCTL_PJ2_CCP0      0x00000900  // CCP0 on PJ2
+#define GPIO_PCTL_PJ2_FAULT0    0x00000A00  // FAULT0 on PJ2
+#define GPIO_PCTL_PJ3_M         0x0000F000  // PJ3 mask
+#define GPIO_PCTL_PJ3_EPI0S19   0x00008000  // EPI0S19 on PJ3
+#define GPIO_PCTL_PJ3_U1CTS     0x00009000  // U1CTS on PJ3
+#define GPIO_PCTL_PJ3_CCP6      0x0000A000  // CCP6 on PJ3
+#define GPIO_PCTL_PJ4_M         0x000F0000  // PJ4 mask
+#define GPIO_PCTL_PJ4_EPI0S28   0x00080000  // EPI0S28 on PJ4
+#define GPIO_PCTL_PJ4_U1DCD     0x00090000  // U1DCD on PJ4
+#define GPIO_PCTL_PJ4_CCP4      0x000A0000  // CCP4 on PJ4
+#define GPIO_PCTL_PJ5_M         0x00F00000  // PJ5 mask
+#define GPIO_PCTL_PJ5_EPI0S29   0x00800000  // EPI0S29 on PJ5
+#define GPIO_PCTL_PJ5_U1DSR     0x00900000  // U1DSR on PJ5
+#define GPIO_PCTL_PJ5_CCP2      0x00A00000  // CCP2 on PJ5
+#define GPIO_PCTL_PJ6_M         0x0F000000  // PJ6 mask
+#define GPIO_PCTL_PJ6_EPI0S30   0x08000000  // EPI0S30 on PJ6
+#define GPIO_PCTL_PJ6_U1RTS     0x09000000  // U1RTS on PJ6
+#define GPIO_PCTL_PJ6_CCP1      0x0A000000  // CCP1 on PJ6
+#define GPIO_PCTL_PJ7_M         0xF0000000  // PJ7 mask
+#define GPIO_PCTL_PJ7_U1DTR     0x90000000  // U1DTR on PJ7
+#define GPIO_PCTL_PJ7_CCP0      0xA0000000  // CCP0 on PJ7
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the GPIO Register offsets.
+//
+//*****************************************************************************
+#define GPIO_O_PeriphID4        0x00000FD0
+#define GPIO_O_PeriphID5        0x00000FD4
+#define GPIO_O_PeriphID6        0x00000FD8
+#define GPIO_O_PeriphID7        0x00000FDC
+#define GPIO_O_PeriphID0        0x00000FE0
+#define GPIO_O_PeriphID1        0x00000FE4
+#define GPIO_O_PeriphID2        0x00000FE8
+#define GPIO_O_PeriphID3        0x00000FEC
+#define GPIO_O_PCellID0         0x00000FF0
+#define GPIO_O_PCellID1         0x00000FF4
+#define GPIO_O_PCellID2         0x00000FF8
+#define GPIO_O_PCellID3         0x00000FFC
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the GPIO Register reset values.
+//
+//*****************************************************************************
+#define GPIO_RV_DEN             0x000000FF  // Digital input enable reg RV.
+#define GPIO_RV_PUR             0x000000FF  // Pull up select reg RV.
+#define GPIO_RV_DR2R            0x000000FF  // 2ma drive select reg RV.
+#define GPIO_RV_PCellID1        0x000000F0
+#define GPIO_RV_PCellID3        0x000000B1
+#define GPIO_RV_PeriphID0       0x00000061
+#define GPIO_RV_PeriphID1       0x00000010
+#define GPIO_RV_PCellID0        0x0000000D
+#define GPIO_RV_PCellID2        0x00000005
+#define GPIO_RV_PeriphID2       0x00000004
+#define GPIO_RV_LOCK            0x00000001  // Lock register RV.
+#define GPIO_RV_PeriphID7       0x00000000
+#define GPIO_RV_PDR             0x00000000  // Pull down select reg RV.
+#define GPIO_RV_IC              0x00000000  // Interrupt clear reg RV.
+#define GPIO_RV_SLR             0x00000000  // Slew rate control enable reg RV.
+#define GPIO_RV_ODR             0x00000000  // Open drain select reg RV.
+#define GPIO_RV_IBE             0x00000000  // Interrupt both edges reg RV.
+#define GPIO_RV_AFSEL           0x00000000  // Mode control select reg RV.
+#define GPIO_RV_IS              0x00000000  // Interrupt sense reg RV.
+#define GPIO_RV_IM              0x00000000  // Interrupt mask reg RV.
+#define GPIO_RV_PeriphID4       0x00000000
+#define GPIO_RV_PeriphID5       0x00000000
+#define GPIO_RV_DR8R            0x00000000  // 8ma drive select reg RV.
+#define GPIO_RV_RIS             0x00000000  // Raw interrupt status reg RV.
+#define GPIO_RV_DR4R            0x00000000  // 4ma drive select reg RV.
+#define GPIO_RV_IEV             0x00000000  // Intterupt event reg RV.
+#define GPIO_RV_DIR             0x00000000  // Data direction reg RV.
+#define GPIO_RV_PeriphID6       0x00000000
+#define GPIO_RV_PeriphID3       0x00000000
+#define GPIO_RV_DATA            0x00000000  // Data register reset value.
+#define GPIO_RV_MIS             0x00000000  // Masked interrupt status reg RV.
+
+#endif
+
+#endif // __HW_GPIO_H__


Property changes on: trunk/src/platform/lm3s/hw_gpio.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_hibernate.h
===================================================================
--- trunk/src/platform/lm3s/hw_hibernate.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_hibernate.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,245 @@
+//*****************************************************************************
+//
+// hw_hibernate.h - Defines and Macros for the Hibernation module.
+//
+// Copyright (c) 2007-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_HIBERNATE_H__
+#define __HW_HIBERNATE_H__
+
+//*****************************************************************************
+//
+// The following are defines for the Hibernation module register addresses.
+//
+//*****************************************************************************
+#define HIB_RTCC                0x400FC000  // Hibernate RTC counter
+#define HIB_RTCM0               0x400FC004  // Hibernate RTC match 0
+#define HIB_RTCM1               0x400FC008  // Hibernate RTC match 1
+#define HIB_RTCLD               0x400FC00C  // Hibernate RTC load
+#define HIB_CTL                 0x400FC010  // Hibernate RTC control
+#define HIB_IM                  0x400FC014  // Hibernate interrupt mask
+#define HIB_RIS                 0x400FC018  // Hibernate raw interrupt status
+#define HIB_MIS                 0x400FC01C  // Hibernate masked interrupt stat
+#define HIB_IC                  0x400FC020  // Hibernate interrupt clear
+#define HIB_RTCT                0x400FC024  // Hibernate RTC trim
+#define HIB_DATA                0x400FC030  // Hibernate data area
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate RTC counter
+// register.
+//
+//*****************************************************************************
+#define HIB_RTCC_M              0xFFFFFFFF  // RTC Counter.
+#define HIB_RTCC_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate RTC match 0
+// register.
+//
+//*****************************************************************************
+#define HIB_RTCM0_M             0xFFFFFFFF  // RTC Match 0.
+#define HIB_RTCM0_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate RTC match 1
+// register.
+//
+//*****************************************************************************
+#define HIB_RTCM1_M             0xFFFFFFFF  // RTC Match 1.
+#define HIB_RTCM1_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate RTC load
+// register.
+//
+//*****************************************************************************
+#define HIB_RTCLD_M             0xFFFFFFFF  // RTC Load.
+#define HIB_RTCLD_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate control
+// register
+//
+//*****************************************************************************
+#define HIB_CTL_WRC             0x80000000  // Write Complete/Capable.
+#define HIB_CTL_VDD3ON          0x00000100  // VDD Powered.
+#define HIB_CTL_VABORT          0x00000080  // low bat abort
+#define HIB_CTL_CLK32EN         0x00000040  // enable clock/oscillator
+#define HIB_CTL_LOWBATEN        0x00000020  // enable low battery detect
+#define HIB_CTL_PINWEN          0x00000010  // enable wake on WAKE pin
+#define HIB_CTL_RTCWEN          0x00000008  // enable wake on RTC match
+#define HIB_CTL_CLKSEL          0x00000004  // clock input selection
+#define HIB_CTL_HIBREQ          0x00000002  // request hibernation
+#define HIB_CTL_RTCEN           0x00000001  // RTC enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate interrupt mask
+// reg.
+//
+//*****************************************************************************
+#define HIB_IM_EXTW             0x00000008  // wake from external pin interrupt
+#define HIB_IM_LOWBAT           0x00000004  // low battery interrupt
+#define HIB_IM_RTCALT1          0x00000002  // RTC match 1 interrupt
+#define HIB_IM_RTCALT0          0x00000001  // RTC match 0 interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate raw interrupt
+// status.
+//
+//*****************************************************************************
+#define HIB_RIS_EXTW            0x00000008  // wake from external pin interrupt
+#define HIB_RIS_LOWBAT          0x00000004  // low battery interrupt
+#define HIB_RIS_RTCALT1         0x00000002  // RTC match 1 interrupt
+#define HIB_RIS_RTCALT0         0x00000001  // RTC Alert0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate masked int
+// status.
+//
+//*****************************************************************************
+#define HIB_MIS_EXTW            0x00000008  // wake from external pin interrupt
+#define HIB_MIS_LOWBAT          0x00000004  // low battery interrupt
+#define HIB_MIS_RTCALT1         0x00000002  // RTC match 1 interrupt
+#define HIB_MIS_RTCALT0         0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate interrupt
+// clear reg.
+//
+//*****************************************************************************
+#define HIB_IC_EXTW             0x00000008  // wake from external pin interrupt
+#define HIB_IC_LOWBAT           0x00000004  // low battery interrupt
+#define HIB_IC_RTCALT1          0x00000002  // RTC match 1 interrupt
+#define HIB_IC_RTCALT0          0x00000001  // RTC match 0 interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate RTC trim
+// register.
+//
+//*****************************************************************************
+#define HIB_RTCT_TRIM_M         0x0000FFFF  // RTC Trim Value.
+#define HIB_RTCT_TRIM_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the Hibernate data register.
+//
+//*****************************************************************************
+#define HIB_DATA_RTD_M          0xFFFFFFFF  // Hibernation Module NV
+                                            // Registers[63:0].
+#define HIB_DATA_RTD_S          0
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Hibernation module register
+// addresses.
+//
+//*****************************************************************************
+#define HIB_DATA_END            0x400FC130  // end of data area, exclusive
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate RTC
+// counter register.
+//
+//*****************************************************************************
+#define HIB_RTCC_MASK           0xFFFFFFFF  // RTC counter mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate RTC
+// match 0 register.
+//
+//*****************************************************************************
+#define HIB_RTCM0_MASK          0xFFFFFFFF  // RTC match 0 mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate RTC
+// match 1 register.
+//
+//*****************************************************************************
+#define HIB_RTCM1_MASK          0xFFFFFFFF  // RTC match 1 mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate RTC
+// load register.
+//
+//*****************************************************************************
+#define HIB_RTCLD_MASK          0xFFFFFFFF  // RTC load mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate raw
+// interrupt status.
+//
+//*****************************************************************************
+#define HIB_RID_RTCALT0         0x00000001  // RTC match 0 interrupt
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate
+// masked int status.
+//
+//*****************************************************************************
+#define HIB_MID_RTCALT0         0x00000001  // RTC match 0 interrupt
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate RTC
+// trim register.
+//
+//*****************************************************************************
+#define HIB_RTCT_MASK           0x0000FFFF  // RTC trim mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the Hibernate
+// data register.
+//
+//*****************************************************************************
+#define HIB_DATA_MASK           0xFFFFFFFF  // NV memory data mask
+
+#endif
+
+#endif // __HW_HIBERNATE_H__


Property changes on: trunk/src/platform/lm3s/hw_hibernate.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_i2c.h
===================================================================
--- trunk/src/platform/lm3s/hw_i2c.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_i2c.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,412 @@
+//*****************************************************************************
+//
+// hw_i2c.h - Macros used when accessing the I2C master and slave hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_I2C_H__
+#define __HW_I2C_H__
+
+//*****************************************************************************
+//
+// The following are defines for the offsets between the I2C master and slave
+// registers.
+//
+//*****************************************************************************
+#define I2C_O_MSA               0x00000000  // I2C Master Slave Address
+#define I2C_O_SOAR              0x00000000  // I2C Slave Own Address
+#define I2C_O_SCSR              0x00000004  // I2C Slave Control/Status
+#define I2C_O_MCS               0x00000004  // I2C Master Control/Status
+#define I2C_O_SDR               0x00000008  // I2C Slave Data
+#define I2C_O_MDR               0x00000008  // I2C Master Data
+#define I2C_O_MTPR              0x0000000C  // I2C Master Timer Period
+#define I2C_O_SIMR              0x0000000C  // I2C Slave Interrupt Mask
+#define I2C_O_SRIS              0x00000010  // I2C Slave Raw Interrupt Status
+#define I2C_O_MIMR              0x00000010  // I2C Master Interrupt Mask
+#define I2C_O_MRIS              0x00000014  // I2C Master Raw Interrupt Status
+#define I2C_O_SMIS              0x00000014  // I2C Slave Masked Interrupt
+                                            // Status
+#define I2C_O_SICR              0x00000018  // I2C Slave Interrupt Clear
+#define I2C_O_MMIS              0x00000018  // I2C Master Masked Interrupt
+                                            // Status
+#define I2C_O_MICR              0x0000001C  // I2C Master Interrupt Clear
+#define I2C_O_MCR               0x00000020  // I2C Master Configuration
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MSA register.
+//
+//*****************************************************************************
+#define I2C_MSA_SA_M            0x000000FE  // I2C Slave Address.
+#define I2C_MSA_RS              0x00000001  // Receive not Send
+#define I2C_MSA_SA_S            1
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SOAR register.
+//
+//*****************************************************************************
+#define I2C_SOAR_OAR_M          0x0000007F  // I2C Slave Own Address.
+#define I2C_SOAR_OAR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SCSR register.
+//
+//*****************************************************************************
+#define I2C_SCSR_FBR            0x00000004  // First Byte Received.
+#define I2C_SCSR_TREQ           0x00000002  // Transmit Request.
+#define I2C_SCSR_DA             0x00000001  // Device Active.
+#define I2C_SCSR_RREQ           0x00000001  // Receive Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCS register.
+//
+//*****************************************************************************
+#define I2C_MCS_BUSBSY          0x00000040  // Bus Busy.
+#define I2C_MCS_IDLE            0x00000020  // I2C Idle.
+#define I2C_MCS_ARBLST          0x00000010  // Arbitration Lost.
+#define I2C_MCS_ACK             0x00000008  // Data Acknowledge Enable.
+#define I2C_MCS_DATACK          0x00000008  // Acknowledge Data.
+#define I2C_MCS_ADRACK          0x00000004  // Acknowledge Address.
+#define I2C_MCS_STOP            0x00000004  // Generate STOP.
+#define I2C_MCS_START           0x00000002  // Generate START.
+#define I2C_MCS_ERROR           0x00000002  // Error.
+#define I2C_MCS_RUN             0x00000001  // I2C Master Enable.
+#define I2C_MCS_BUSY            0x00000001  // I2C Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SDR register.
+//
+//*****************************************************************************
+#define I2C_SDR_DATA_M          0x000000FF  // Data for Transfer.
+#define I2C_SDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MDR register.
+//
+//*****************************************************************************
+#define I2C_MDR_DATA_M          0x000000FF  // Data Transferred.
+#define I2C_MDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MTPR register.
+//
+//*****************************************************************************
+#define I2C_MTPR_TPR_M          0x000000FF  // SCL Clock Period.
+#define I2C_MTPR_TPR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SIMR register.
+//
+//*****************************************************************************
+#define I2C_SIMR_STOPIM         0x00000004  // Stop Condition Interrupt Mask.
+#define I2C_SIMR_STARTIM        0x00000002  // Start Condition Interrupt Mask.
+#define I2C_SIMR_DATAIM         0x00000001  // Data Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SRIS register.
+//
+//*****************************************************************************
+#define I2C_SRIS_STOPRIS        0x00000004  // Stop Condition Raw Interrupt
+                                            // Status.
+#define I2C_SRIS_STARTRIS       0x00000002  // Start Condition Raw Interrupt
+                                            // Status.
+#define I2C_SRIS_DATARIS        0x00000001  // Data Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MIMR register.
+//
+//*****************************************************************************
+#define I2C_MIMR_IM             0x00000001  // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MRIS register.
+//
+//*****************************************************************************
+#define I2C_MRIS_RIS            0x00000001  // Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SMIS register.
+//
+//*****************************************************************************
+#define I2C_SMIS_STOPMIS        0x00000004  // Stop Condition Masked Interrupt
+                                            // Status.
+#define I2C_SMIS_STARTMIS       0x00000002  // Start Condition Masked Interrupt
+                                            // Status.
+#define I2C_SMIS_DATAMIS        0x00000001  // Data Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SICR register.
+//
+//*****************************************************************************
+#define I2C_SICR_STOPIC         0x00000004  // Stop Condition Interrupt Clear.
+#define I2C_SICR_STARTIC        0x00000002  // Start Condition Interrupt Clear.
+#define I2C_SICR_DATAIC         0x00000001  // Data Clear Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MMIS register.
+//
+//*****************************************************************************
+#define I2C_MMIS_MIS            0x00000001  // Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MICR register.
+//
+//*****************************************************************************
+#define I2C_MICR_IC             0x00000001  // Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCR register.
+//
+//*****************************************************************************
+#define I2C_MCR_SFE             0x00000020  // I2C Slave Function Enable.
+#define I2C_MCR_MFE             0x00000010  // I2C Master Function Enable.
+#define I2C_MCR_LPBK            0x00000001  // I2C Loopback.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the offsets between the I2C master
+// and slave registers.
+//
+//*****************************************************************************
+#define I2C_O_SLAVE             0x00000800  // Offset from master to slave
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the I2C master register offsets.
+//
+//*****************************************************************************
+#define I2C_MASTER_O_SA         0x00000000  // Slave address register
+#define I2C_MASTER_O_CS         0x00000004  // Control and Status register
+#define I2C_MASTER_O_DR         0x00000008  // Data register
+#define I2C_MASTER_O_TPR        0x0000000C  // Timer period register
+#define I2C_MASTER_O_IMR        0x00000010  // Interrupt mask register
+#define I2C_MASTER_O_RIS        0x00000014  // Raw interrupt status register
+#define I2C_MASTER_O_MIS        0x00000018  // Masked interrupt status reg
+#define I2C_MASTER_O_MICR       0x0000001C  // Interrupt clear register
+#define I2C_MASTER_O_CR         0x00000020  // Configuration register
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the I2C slave register offsets.
+//
+//*****************************************************************************
+#define I2C_SLAVE_O_SICR        0x00000018  // Interrupt clear register
+#define I2C_SLAVE_O_MIS         0x00000014  // Masked interrupt status reg
+#define I2C_SLAVE_O_RIS         0x00000010  // Raw interrupt status register
+#define I2C_SLAVE_O_IM          0x0000000C  // Interrupt mask register
+#define I2C_SLAVE_O_DR          0x00000008  // Data register
+#define I2C_SLAVE_O_CSR         0x00000004  // Control/Status register
+#define I2C_SLAVE_O_OAR         0x00000000  // Own address register
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C master
+// slave address register.
+//
+//*****************************************************************************
+#define I2C_MASTER_SA_SA_MASK   0x000000FE  // Slave address
+#define I2C_MASTER_SA_RS        0x00000001  // Receive/send
+#define I2C_MASTER_SA_SA_SHIFT  1
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Master
+// Control and Status register.
+//
+//*****************************************************************************
+#define I2C_MASTER_CS_BUS_BUSY  0x00000040  // Bus busy
+#define I2C_MASTER_CS_IDLE      0x00000020  // Idle
+#define I2C_MASTER_CS_ERR_MASK  0x0000001C
+#define I2C_MASTER_CS_BUSY      0x00000001  // Controller is TX/RX data
+#define I2C_MASTER_CS_ERROR     0x00000002  // Error occurred
+#define I2C_MASTER_CS_ADDR_ACK  0x00000004  // Address byte not acknowledged
+#define I2C_MASTER_CS_DATA_ACK  0x00000008  // Data byte not acknowledged
+#define I2C_MASTER_CS_ARB_LOST  0x00000010  // Lost arbitration
+#define I2C_MASTER_CS_ACK       0x00000008  // Acknowlegde
+#define I2C_MASTER_CS_STOP      0x00000004  // Stop
+#define I2C_MASTER_CS_START     0x00000002  // Start
+#define I2C_MASTER_CS_RUN       0x00000001  // Run
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the values used in determining the
+// contents of the I2C Master Timer Period register.
+//
+//*****************************************************************************
+#define I2C_SCL_FAST            400000      // SCL fast frequency
+#define I2C_SCL_STANDARD        100000      // SCL standard frequency
+#define I2C_MASTER_TPR_SCL_LP   0x00000006  // SCL low period
+#define I2C_MASTER_TPR_SCL_HP   0x00000004  // SCL high period
+#define I2C_MASTER_TPR_SCL      (I2C_MASTER_TPR_SCL_HP + I2C_MASTER_TPR_SCL_LP)
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Master
+// Interrupt Mask register.
+//
+//*****************************************************************************
+#define I2C_MASTER_IMR_IM       0x00000001  // Master interrupt mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Master
+// Raw Interrupt Status register.
+//
+//*****************************************************************************
+#define I2C_MASTER_RIS_RIS      0x00000001  // Master raw interrupt status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Master
+// Masked Interrupt Status register.
+//
+//*****************************************************************************
+#define I2C_MASTER_MIS_MIS      0x00000001  // Master masked interrupt status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Master
+// Interrupt Clear register.
+//
+//*****************************************************************************
+#define I2C_MASTER_MICR_IC      0x00000001  // Master interrupt clear
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Master
+// Configuration register.
+//
+//*****************************************************************************
+#define I2C_MASTER_CR_SFE       0x00000020  // Slave function enable
+#define I2C_MASTER_CR_MFE       0x00000010  // Master function enable
+#define I2C_MASTER_CR_LPBK      0x00000001  // Loopback enable
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Slave Own
+// Address register.
+//
+//*****************************************************************************
+#define I2C_SLAVE_SOAR_OAR_MASK 0x0000007F  // Slave address
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Slave
+// Control/Status register.
+//
+//*****************************************************************************
+#define I2C_SLAVE_CSR_FBR       0x00000004  // First byte received from master
+#define I2C_SLAVE_CSR_TREQ      0x00000002  // Transmit request received
+#define I2C_SLAVE_CSR_DA        0x00000001  // Enable the device
+#define I2C_SLAVE_CSR_RREQ      0x00000001  // Receive data from I2C master
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Slave
+// Interrupt Mask register.
+//
+//*****************************************************************************
+#define I2C_SLAVE_IMR_IM        0x00000001  // Slave interrupt mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Slave Raw
+// Interrupt Status register.
+//
+//*****************************************************************************
+#define I2C_SLAVE_RIS_RIS       0x00000001  // Slave raw interrupt status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Slave
+// Masked Interrupt Status register.
+//
+//*****************************************************************************
+#define I2C_SLAVE_MIS_MIS       0x00000001  // Slave masked interrupt status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C Slave
+// Interrupt Clear register.
+//
+//*****************************************************************************
+#define I2C_SLAVE_SICR_IC       0x00000001  // Slave interrupt clear
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C_O_SIMR
+// register.
+//
+//*****************************************************************************
+#define I2C_SIMR_IM             0x00000001  // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C_O_SRIS
+// register.
+//
+//*****************************************************************************
+#define I2C_SRIS_RIS            0x00000001  // Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C_O_SMIS
+// register.
+//
+//*****************************************************************************
+#define I2C_SMIS_MIS            0x00000001  // Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the I2C_O_SICR
+// register.
+//
+//*****************************************************************************
+#define I2C_SICR_IC             0x00000001  // Clear Interrupt.
+
+#endif
+
+#endif // __HW_I2C_H__


Property changes on: trunk/src/platform/lm3s/hw_i2c.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_i2s.h
===================================================================
--- trunk/src/platform/lm3s/hw_i2s.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_i2s.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,233 @@
+//*****************************************************************************
+//
+// hw_i2s.h - Macros for use in accessing the I2S registers.
+//
+// Copyright (c) 2008-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_I2S_H__
+#define __HW_I2S_H__
+
+//*****************************************************************************
+//
+// The following are defines for the Inter-Integrated Circuit Sound (I2S)
+// Interface
+//
+//*****************************************************************************
+#define I2S_O_TXFIFO            0x00000000  // I2S Transmit FIFO Data
+#define I2S_O_TXFIFOCFG         0x00000004  // I2S Transmit FIFO Configuration
+#define I2S_O_TXCFG             0x00000008  // I2S Transmit Module
+                                            // Configuration
+#define I2S_O_TXLIMIT           0x0000000C  // I2S Transmit FIFO Limit
+#define I2S_O_TXISM             0x00000010  // I2S Transmit Interrupt Status
+                                            // and Mask
+#define I2S_O_TXLEV             0x00000018  // I2S Transmit FIFO Level
+#define I2S_O_RXFIFO            0x00000800  // I2S Receive FIFO Data
+#define I2S_O_RXFIFOCFG         0x00000804  // I2S Receive FIFO Configuration
+#define I2S_O_RXCFG             0x00000808  // I2S Receive Module Configuration
+#define I2S_O_RXLIMIT           0x0000080C  // I2S Receive FIFO Limit
+#define I2S_O_RXISM             0x00000810  // I2S Receive Interrupt Status and
+                                            // Mask
+#define I2S_O_RXLEV             0x00000818  // I2S Receive FIFO Level
+#define I2S_O_CFG               0x00000C00  // I2S Module Configuration
+#define I2S_O_IM                0x00000C10  // I2S Interrupt Mask
+#define I2S_O_RIS               0x00000C14  // I2S Raw Interrupt Status
+#define I2S_O_MIS               0x00000C18  // I2S Masked Interrupt Status
+#define I2S_O_IC                0x00000C1C  // I2S Interrupt Clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXFIFO register.
+//
+//*****************************************************************************
+#define I2S_TXFIFO_M            0xFFFFFFFF  // TX Data.
+#define I2S_TXFIFO_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXFIFOCFG
+// register.
+//
+//*****************************************************************************
+#define I2S_TXFIFOCFG_CSS       0x00000002  // Compact Stereo Sample Size.
+#define I2S_TXFIFOCFG_LRS       0x00000001  // Left-Right Sample Indicator.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXCFG register.
+//
+//*****************************************************************************
+#define I2S_TXCFG_JST           0x20000000  // Justification of Output Data.
+#define I2S_TXCFG_DLY           0x10000000  // Data Delay.
+#define I2S_TXCFG_SCP           0x08000000  // SCLK Polarity.
+#define I2S_TXCFG_LRP           0x04000000  // Left/Right Clock Polarity.
+#define I2S_TXCFG_WM_M          0x03000000  // Write Mode.
+#define I2S_TXCFG_WM_DUAL       0x00000000  // Stereo mode
+#define I2S_TXCFG_WM_COMPACT    0x01000000  // Compact Stereo mode
+#define I2S_TXCFG_WM_MONO       0x02000000  // Mono mode
+#define I2S_TXCFG_FMT           0x00800000  // FIFO Empty.
+#define I2S_TXCFG_MSL           0x00400000  // SCLK Master/Slave.
+#define I2S_TXCFG_SSZ_M         0x0000FC00  // Sample Size.
+#define I2S_TXCFG_SDSZ_M        0x000003F0  // System Data Size.
+#define I2S_TXCFG_SSZ_S         10
+#define I2S_TXCFG_SDSZ_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXLIMIT register.
+//
+//*****************************************************************************
+#define I2S_TXLIMIT_LIMIT_M     0x0000001F  // FIFO Limit.
+#define I2S_TXLIMIT_LIMIT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXISM register.
+//
+//*****************************************************************************
+#define I2S_TXISM_FFI           0x00010000  // Transmit FIFO Service Request
+                                            // Interrupt.
+#define I2S_TXISM_FFM           0x00000001  // FIFO Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXLEV register.
+//
+//*****************************************************************************
+#define I2S_TXLEV_LEVEL_M       0x0000001F  // Number of Audio Samples.
+#define I2S_TXLEV_LEVEL_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXFIFO register.
+//
+//*****************************************************************************
+#define I2S_RXFIFO_M            0xFFFFFFFF  // RX Data.
+#define I2S_RXFIFO_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXFIFOCFG
+// register.
+//
+//*****************************************************************************
+#define I2S_RXFIFOCFG_FMM       0x00000004  // FIFO Mono Mode.
+#define I2S_RXFIFOCFG_CSS       0x00000002  // Compact Stereo Sample Size.
+#define I2S_RXFIFOCFG_LRS       0x00000001  // Left-Right Sample Indicator.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXCFG register.
+//
+//*****************************************************************************
+#define I2S_RXCFG_JST           0x20000000  // Justification of Input Data.
+#define I2S_RXCFG_DLY           0x10000000  // Data Delay.
+#define I2S_RXCFG_SCP           0x08000000  // SCLK Polarity.
+#define I2S_RXCFG_LRP           0x04000000  // Left/Right Clock Polarity.
+#define I2S_RXCFG_RM            0x01000000  // Read Mode.
+#define I2S_RXCFG_MSL           0x00400000  // SCLK Master/Slave.
+#define I2S_RXCFG_SSZ_M         0x0000FC00  // Sample Size.
+#define I2S_RXCFG_SDSZ_M        0x000003F0  // System Data Size.
+#define I2S_RXCFG_SSZ_S         10
+#define I2S_RXCFG_SDSZ_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXLIMIT register.
+//
+//*****************************************************************************
+#define I2S_RXLIMIT_LIMIT_M     0x0000001F  // FIFO Limit.
+#define I2S_RXLIMIT_LIMIT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXISM register.
+//
+//*****************************************************************************
+#define I2S_RXISM_FFI           0x00010000  // Receive FIFO Service Request
+                                            // Interrupt.
+#define I2S_RXISM_FFM           0x00000001  // FIFO Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXLEV register.
+//
+//*****************************************************************************
+#define I2S_RXLEV_LEVEL_M       0x0000001F  // Number of Audio Samples.
+#define I2S_RXLEV_LEVEL_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_CFG register.
+//
+//*****************************************************************************
+#define I2S_CFG_RXSLV           0x00000020  // When clear, this bit configures
+                                            // the receiver to use the
+                                            // externally driven I2S0RXMCLK
+                                            // signal.
+#define I2S_CFG_TXSLV           0x00000010  // When clear, this bit configures
+                                            // the transmitter to use the
+                                            // externally driven I2S0TXMCLK
+                                            // signal.
+#define I2S_CFG_RXEN            0x00000002  // Serial Receive Engine Enable.
+#define I2S_CFG_TXEN            0x00000001  // Serial Transmit Engine Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_IM register.
+//
+//*****************************************************************************
+#define I2S_IM_RXRE             0x00000020  // Receive FIFO Read Error.
+#define I2S_IM_RXFSR            0x00000010  // Receive FIFO Service Request.
+#define I2S_IM_TXWE             0x00000002  // Transmit FIFO Write Error.
+#define I2S_IM_TXFSR            0x00000001  // Transmit FIFO Service Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RIS register.
+//
+//*****************************************************************************
+#define I2S_RIS_RXRE            0x00000020  // Receive FIFO Read Error.
+#define I2S_RIS_RXFSR           0x00000010  // Receive FIFO Service Request.
+#define I2S_RIS_TXWE            0x00000002  // Transmit FIFO Write Error.
+#define I2S_RIS_TXFSR           0x00000001  // Transmit FIFO Service Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_MIS register.
+//
+//*****************************************************************************
+#define I2S_MIS_RXRE            0x00000020  // Receive FIFO Read Error.
+#define I2S_MIS_RXFSR           0x00000010  // Receive FIFO Service Request.
+#define I2S_MIS_TXWE            0x00000002  // Transmit FIFO Write Error.
+#define I2S_MIS_TXFSR           0x00000001  // Transmit FIFO Service Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_IC register.
+//
+//*****************************************************************************
+#define I2S_IC_RXRE             0x00000020  // Receive FIFO Read Error.
+#define I2S_IC_TXWE             0x00000002  // Transmit FIFO Write Error.
+
+#endif // __HW_I2S_H__


Property changes on: trunk/src/platform/lm3s/hw_i2s.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_ints.h
===================================================================
--- trunk/src/platform/lm3s/hw_ints.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_ints.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,133 +1,140 @@
-//*****************************************************************************
-//
-// hw_ints.h - Macros that define the interrupt assignment on Stellaris.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program. Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_INTS_H__
-#define __HW_INTS_H__
-
-//*****************************************************************************
-//
-// The following are defines for the fault assignments.
-//
-//*****************************************************************************
-#define FAULT_NMI               2           // NMI fault
-#define FAULT_HARD              3           // Hard fault
-#define FAULT_MPU               4           // MPU fault
-#define FAULT_BUS               5           // Bus fault
-#define FAULT_USAGE             6           // Usage fault
-#define FAULT_SVCALL            11          // SVCall
-#define FAULT_DEBUG             12          // Debug monitor
-#define FAULT_PENDSV            14          // PendSV
-#define FAULT_SYSTICK           15          // System Tick
-
-//*****************************************************************************
-//
-// The following are defines for the interrupt assignments.
-//
-//*****************************************************************************
-#define INT_GPIOA               16          // GPIO Port A
-#define INT_GPIOB               17          // GPIO Port B
-#define INT_GPIOC               18          // GPIO Port C
-#define INT_GPIOD               19          // GPIO Port D
-#define INT_GPIOE               20          // GPIO Port E
-#define INT_UART0               21          // UART0 Rx and Tx
-#define INT_UART1               22          // UART1 Rx and Tx
-#define INT_SSI0                23          // SSI0 Rx and Tx
-#define INT_I2C0                24          // I2C0 Master and Slave
-#define INT_PWM_FAULT           25          // PWM Fault
-#define INT_PWM0                26          // PWM Generator 0
-#define INT_PWM1                27          // PWM Generator 1
-#define INT_PWM2                28          // PWM Generator 2
-#define INT_QEI0                29          // Quadrature Encoder 0
-#define INT_ADC0                30          // ADC Sequence 0
-#define INT_ADC1                31          // ADC Sequence 1
-#define INT_ADC2                32          // ADC Sequence 2
-#define INT_ADC3                33          // ADC Sequence 3
-#define INT_WATCHDOG            34          // Watchdog timer
-#define INT_TIMER0A             35          // Timer 0 subtimer A
-#define INT_TIMER0B             36          // Timer 0 subtimer B
-#define INT_TIMER1A             37          // Timer 1 subtimer A
-#define INT_TIMER1B             38          // Timer 1 subtimer B
-#define INT_TIMER2A             39          // Timer 2 subtimer A
-#define INT_TIMER2B             40          // Timer 2 subtimer B
-#define INT_COMP0               41          // Analog Comparator 0
-#define INT_COMP1               42          // Analog Comparator 1
-#define INT_COMP2               43          // Analog Comparator 2
-#define INT_SYSCTL              44          // System Control (PLL, OSC, BO)
-#define INT_FLASH               45          // FLASH Control
-#define INT_GPIOF               46          // GPIO Port F
-#define INT_GPIOG               47          // GPIO Port G
-#define INT_GPIOH               48          // GPIO Port H
-#define INT_UART2               49          // UART2 Rx and Tx
-#define INT_SSI1                50          // SSI1 Rx and Tx
-#define INT_TIMER3A             51          // Timer 3 subtimer A
-#define INT_TIMER3B             52          // Timer 3 subtimer B
-#define INT_I2C1                53          // I2C1 Master and Slave
-#define INT_QEI1                54          // Quadrature Encoder 1
-#define INT_CAN0                55          // CAN0
-#define INT_CAN1                56          // CAN1
-#define INT_CAN2                57          // CAN2
-#define INT_ETH                 58          // Ethernet
-#define INT_HIBERNATE           59          // Hibernation module
-#define INT_USB0                60          // USB 0 Controller
-#define INT_PWM3                61          // PWM Generator 3
-#define INT_UDMA                62          // uDMA controller
-#define INT_UDMAERR             63          // uDMA Error
-
-//*****************************************************************************
-//
-// The following are defines for the total number of interrupts.
-//
-//*****************************************************************************
-#define NUM_INTERRUPTS          64
-
-//*****************************************************************************
-//
-// The following are defines for the total number of priority levels.
-//
-//*****************************************************************************
-#define NUM_PRIORITY            8
-#define NUM_PRIORITY_BITS       3
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the interrupt assignments.
-//
-//*****************************************************************************
-#define INT_SSI                 23          // SSI Rx and Tx
-#define INT_I2C                 24          // I2C Master and Slave
-#define INT_QEI                 29          // Quadrature Encoder
-
-#endif
-
-#endif // __HW_INTS_H__
+//*****************************************************************************
+//
+// hw_ints.h - Macros that define the interrupt assignment on Stellaris.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_INTS_H__
+#define __HW_INTS_H__
+
+//*****************************************************************************
+//
+// The following are defines for the fault assignments.
+//
+//*****************************************************************************
+#define FAULT_NMI               2           // NMI fault
+#define FAULT_HARD              3           // Hard fault
+#define FAULT_MPU               4           // MPU fault
+#define FAULT_BUS               5           // Bus fault
+#define FAULT_USAGE             6           // Usage fault
+#define FAULT_SVCALL            11          // SVCall
+#define FAULT_DEBUG             12          // Debug monitor
+#define FAULT_PENDSV            14          // PendSV
+#define FAULT_SYSTICK           15          // System Tick
+
+//*****************************************************************************
+//
+// The following are defines for the interrupt assignments.
+//
+//*****************************************************************************
+#define INT_GPIOA               16          // GPIO Port A
+#define INT_GPIOB               17          // GPIO Port B
+#define INT_GPIOC               18          // GPIO Port C
+#define INT_GPIOD               19          // GPIO Port D
+#define INT_GPIOE               20          // GPIO Port E
+#define INT_UART0               21          // UART0 Rx and Tx
+#define INT_UART1               22          // UART1 Rx and Tx
+#define INT_SSI0                23          // SSI0 Rx and Tx
+#define INT_I2C0                24          // I2C0 Master and Slave
+#define INT_PWM_FAULT           25          // PWM Fault
+#define INT_PWM0                26          // PWM Generator 0
+#define INT_PWM1                27          // PWM Generator 1
+#define INT_PWM2                28          // PWM Generator 2
+#define INT_QEI0                29          // Quadrature Encoder 0
+#define INT_ADC0                30          // ADC Sequence 0
+#define INT_ADC1                31          // ADC Sequence 1
+#define INT_ADC2                32          // ADC Sequence 2
+#define INT_ADC3                33          // ADC Sequence 3
+#define INT_WATCHDOG            34          // Watchdog timer
+#define INT_TIMER0A             35          // Timer 0 subtimer A
+#define INT_TIMER0B             36          // Timer 0 subtimer B
+#define INT_TIMER1A             37          // Timer 1 subtimer A
+#define INT_TIMER1B             38          // Timer 1 subtimer B
+#define INT_TIMER2A             39          // Timer 2 subtimer A
+#define INT_TIMER2B             40          // Timer 2 subtimer B
+#define INT_COMP0               41          // Analog Comparator 0
+#define INT_COMP1               42          // Analog Comparator 1
+#define INT_COMP2               43          // Analog Comparator 2
+#define INT_SYSCTL              44          // System Control (PLL, OSC, BO)
+#define INT_FLASH               45          // FLASH Control
+#define INT_GPIOF               46          // GPIO Port F
+#define INT_GPIOG               47          // GPIO Port G
+#define INT_GPIOH               48          // GPIO Port H
+#define INT_UART2               49          // UART2 Rx and Tx
+#define INT_SSI1                50          // SSI1 Rx and Tx
+#define INT_TIMER3A             51          // Timer 3 subtimer A
+#define INT_TIMER3B             52          // Timer 3 subtimer B
+#define INT_I2C1                53          // I2C1 Master and Slave
+#define INT_QEI1                54          // Quadrature Encoder 1
+#define INT_CAN0                55          // CAN0
+#define INT_CAN1                56          // CAN1
+#define INT_CAN2                57          // CAN2
+#define INT_ETH                 58          // Ethernet
+#define INT_HIBERNATE           59          // Hibernation module
+#define INT_USB0                60          // USB 0 Controller
+#define INT_PWM3                61          // PWM Generator 3
+#define INT_UDMA                62          // uDMA controller
+#define INT_UDMAERR             63          // uDMA Error
+#define INT_ADC1SS0             64          // ADC1 Sequence 0
+#define INT_ADC1SS1             65          // ADC1 Sequence 1
+#define INT_ADC1SS2             66          // ADC1 Sequence 2
+#define INT_ADC1SS3             67          // ADC1 Sequence 3
+#define INT_I2S0                68          // I2S0
+#define INT_EPI0                69          // EPI0
+#define INT_GPIOJ               70          // GPIO Port J
+
+//*****************************************************************************
+//
+// The following are defines for the total number of interrupts.
+//
+//*****************************************************************************
+#define NUM_INTERRUPTS          70
+
+//*****************************************************************************
+//
+// The following are defines for the total number of priority levels.
+//
+//*****************************************************************************
+#define NUM_PRIORITY            8
+#define NUM_PRIORITY_BITS       3
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the interrupt assignments.
+//
+//*****************************************************************************
+#define INT_SSI                 23          // SSI Rx and Tx
+#define INT_I2C                 24          // I2C Master and Slave
+#define INT_QEI                 29          // Quadrature Encoder
+
+#endif
+
+#endif // __HW_INTS_H__


Property changes on: trunk/src/platform/lm3s/hw_ints.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_memmap.h
===================================================================
--- trunk/src/platform/lm3s/hw_memmap.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_memmap.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,110 +1,118 @@
-//*****************************************************************************
-//
-// hw_memmap.h - Macros defining the memory map of Stellaris.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_MEMMAP_H__
-#define __HW_MEMMAP_H__
-
-//*****************************************************************************
-//
-// The following are defines for the base address of the memories and
-// peripherals.
-//
-//*****************************************************************************
-#define FLASH_BASE              0x00000000  // FLASH memory
-#define SRAM_BASE               0x20000000  // SRAM memory
-#define WATCHDOG_BASE           0x40000000  // Watchdog
-#define GPIO_PORTA_BASE         0x40004000  // GPIO Port A
-#define GPIO_PORTB_BASE         0x40005000  // GPIO Port B
-#define GPIO_PORTC_BASE         0x40006000  // GPIO Port C
-#define GPIO_PORTD_BASE         0x40007000  // GPIO Port D
-#define SSI0_BASE               0x40008000  // SSI0
-#define SSI1_BASE               0x40009000  // SSI1
-#define UART0_BASE              0x4000C000  // UART0
-#define UART1_BASE              0x4000D000  // UART1
-#define UART2_BASE              0x4000E000  // UART2
-#define I2C0_MASTER_BASE        0x40020000  // I2C0 Master
-#define I2C0_SLAVE_BASE         0x40020800  // I2C0 Slave
-#define I2C1_MASTER_BASE        0x40021000  // I2C1 Master
-#define I2C1_SLAVE_BASE         0x40021800  // I2C1 Slave
-#define GPIO_PORTE_BASE         0x40024000  // GPIO Port E
-#define GPIO_PORTF_BASE         0x40025000  // GPIO Port F
-#define GPIO_PORTG_BASE         0x40026000  // GPIO Port G
-#define GPIO_PORTH_BASE         0x40027000  // GPIO Port H
-#define PWM_BASE                0x40028000  // PWM
-#define QEI0_BASE               0x4002C000  // QEI0
-#define QEI1_BASE               0x4002D000  // QEI1
-#define TIMER0_BASE             0x40030000  // Timer0
-#define TIMER1_BASE             0x40031000  // Timer1
-#define TIMER2_BASE             0x40032000  // Timer2
-#define TIMER3_BASE             0x40033000  // Timer3
-#define ADC_BASE                0x40038000  // ADC
-#define COMP_BASE               0x4003C000  // Analog comparators
-#define CAN0_BASE               0x40040000  // CAN0
-#define CAN1_BASE               0x40041000  // CAN1
-#define CAN2_BASE               0x40042000  // CAN2
-#define ETH_BASE                0x40048000  // Ethernet
-#define MAC_BASE                0x40048000  // Ethernet
-#define USB0_BASE               0x40050000  // USB 0 Controller
-#define GPIO_PORTA_AHB_BASE     0x40058000  // GPIO Port A (high speed)
-#define GPIO_PORTB_AHB_BASE     0x40059000  // GPIO Port B (high speed)
-#define GPIO_PORTC_AHB_BASE     0x4005A000  // GPIO Port C (high speed)
-#define GPIO_PORTD_AHB_BASE     0x4005B000  // GPIO Port D (high speed)
-#define GPIO_PORTE_AHB_BASE     0x4005C000  // GPIO Port E (high speed)
-#define GPIO_PORTF_AHB_BASE     0x4005D000  // GPIO Port F (high speed)
-#define GPIO_PORTG_AHB_BASE     0x4005E000  // GPIO Port G (high speed)
-#define GPIO_PORTH_AHB_BASE     0x4005F000  // GPIO Port H (high speed)
-#define HIB_BASE                0x400FC000  // Hibernation Module
-#define FLASH_CTRL_BASE         0x400FD000  // FLASH Controller
-#define SYSCTL_BASE             0x400FE000  // System Control
-#define UDMA_BASE               0x400FF000  // uDMA Controller
-#define ITM_BASE                0xE0000000  // Instrumentation Trace Macrocell
-#define DWT_BASE                0xE0001000  // Data Watchpoint and Trace
-#define FPB_BASE                0xE0002000  // FLASH Patch and Breakpoint
-#define NVIC_BASE               0xE000E000  // Nested Vectored Interrupt Ctrl
-#define TPIU_BASE               0xE0040000  // Trace Port Interface Unit
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the base address of the memories
-// and peripherals.
-//
-//*****************************************************************************
-#define SSI_BASE                0x40008000  // SSI
-#define I2C_MASTER_BASE         0x40020000  // I2C Master
-#define I2C_SLAVE_BASE          0x40020800  // I2C Slave
-#define QEI_BASE                0x4002C000  // QEI
-
-#endif
-
-#endif // __HW_MEMMAP_H__
+//*****************************************************************************
+//
+// hw_memmap.h - Macros defining the memory map of Stellaris.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_MEMMAP_H__
+#define __HW_MEMMAP_H__
+
+//*****************************************************************************
+//
+// The following are defines for the base address of the memories and
+// peripherals.
+//
+//*****************************************************************************
+#define FLASH_BASE              0x00000000  // FLASH memory
+#define SRAM_BASE               0x20000000  // SRAM memory
+#define WATCHDOG0_BASE          0x40000000  // Watchdog0
+#define WATCHDOG1_BASE          0x40001000  // Watchdog1
+#define GPIO_PORTA_BASE         0x40004000  // GPIO Port A
+#define GPIO_PORTB_BASE         0x40005000  // GPIO Port B
+#define GPIO_PORTC_BASE         0x40006000  // GPIO Port C
+#define GPIO_PORTD_BASE         0x40007000  // GPIO Port D
+#define SSI0_BASE               0x40008000  // SSI0
+#define SSI1_BASE               0x40009000  // SSI1
+#define UART0_BASE              0x4000C000  // UART0
+#define UART1_BASE              0x4000D000  // UART1
+#define UART2_BASE              0x4000E000  // UART2
+#define I2C0_MASTER_BASE        0x40020000  // I2C0 Master
+#define I2C0_SLAVE_BASE         0x40020800  // I2C0 Slave
+#define I2C1_MASTER_BASE        0x40021000  // I2C1 Master
+#define I2C1_SLAVE_BASE         0x40021800  // I2C1 Slave
+#define GPIO_PORTE_BASE         0x40024000  // GPIO Port E
+#define GPIO_PORTF_BASE         0x40025000  // GPIO Port F
+#define GPIO_PORTG_BASE         0x40026000  // GPIO Port G
+#define GPIO_PORTH_BASE         0x40027000  // GPIO Port H
+#define PWM_BASE                0x40028000  // PWM
+#define QEI0_BASE               0x4002C000  // QEI0
+#define QEI1_BASE               0x4002D000  // QEI1
+#define TIMER0_BASE             0x40030000  // Timer0
+#define TIMER1_BASE             0x40031000  // Timer1
+#define TIMER2_BASE             0x40032000  // Timer2
+#define TIMER3_BASE             0x40033000  // Timer3
+#define ADC0_BASE               0x40038000  // ADC0
+#define ADC1_BASE               0x40039000  // ADC1
+#define COMP_BASE               0x4003C000  // Analog comparators
+#define GPIO_PORTJ_BASE         0x4003D000  // GPIO Port J
+#define CAN0_BASE               0x40040000  // CAN0
+#define CAN1_BASE               0x40041000  // CAN1
+#define CAN2_BASE               0x40042000  // CAN2
+#define ETH_BASE                0x40048000  // Ethernet
+#define MAC_BASE                0x40048000  // Ethernet
+#define USB0_BASE               0x40050000  // USB 0 Controller
+#define I2S0_BASE               0x40054000  // I2S0
+#define GPIO_PORTA_AHB_BASE     0x40058000  // GPIO Port A (high speed)
+#define GPIO_PORTB_AHB_BASE     0x40059000  // GPIO Port B (high speed)
+#define GPIO_PORTC_AHB_BASE     0x4005A000  // GPIO Port C (high speed)
+#define GPIO_PORTD_AHB_BASE     0x4005B000  // GPIO Port D (high speed)
+#define GPIO_PORTE_AHB_BASE     0x4005C000  // GPIO Port E (high speed)
+#define GPIO_PORTF_AHB_BASE     0x4005D000  // GPIO Port F (high speed)
+#define GPIO_PORTG_AHB_BASE     0x4005E000  // GPIO Port G (high speed)
+#define GPIO_PORTH_AHB_BASE     0x4005F000  // GPIO Port H (high speed)
+#define GPIO_PORTJ_AHB_BASE     0x40060000  // GPIO Port J (high speed)
+#define EPI0_BASE               0x400D0000  // EPI0
+#define HIB_BASE                0x400FC000  // Hibernation Module
+#define FLASH_CTRL_BASE         0x400FD000  // FLASH Controller
+#define SYSCTL_BASE             0x400FE000  // System Control
+#define UDMA_BASE               0x400FF000  // uDMA Controller
+#define ITM_BASE                0xE0000000  // Instrumentation Trace Macrocell
+#define DWT_BASE                0xE0001000  // Data Watchpoint and Trace
+#define FPB_BASE                0xE0002000  // FLASH Patch and Breakpoint
+#define NVIC_BASE               0xE000E000  // Nested Vectored Interrupt Ctrl
+#define TPIU_BASE               0xE0040000  // Trace Port Interface Unit
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the base address of the memories
+// and peripherals.
+//
+//*****************************************************************************
+#define WATCHDOG_BASE           0x40000000  // Watchdog
+#define SSI_BASE                0x40008000  // SSI
+#define I2C_MASTER_BASE         0x40020000  // I2C Master
+#define I2C_SLAVE_BASE          0x40020800  // I2C Slave
+#define QEI_BASE                0x4002C000  // QEI
+#define ADC_BASE                0x40038000  // ADC
+
+#endif
+
+#endif // __HW_MEMMAP_H__


Property changes on: trunk/src/platform/lm3s/hw_memmap.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_nvic.h
===================================================================
--- trunk/src/platform/lm3s/hw_nvic.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_nvic.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,1025 +1,1027 @@
-//*****************************************************************************
-//
-// hw_nvic.h - Macros used when accessing the NVIC hardware.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_NVIC_H__
-#define __HW_NVIC_H__
-
-//*****************************************************************************
-//
-// The following are defines for the NVIC register addresses.
-//
-//*****************************************************************************
-#define NVIC_INT_TYPE           0xE000E004  // Interrupt Controller Type Reg.
-#define NVIC_ST_CTRL            0xE000E010  // SysTick Control and Status Reg.
-#define NVIC_ST_RELOAD          0xE000E014  // SysTick Reload Value Register
-#define NVIC_ST_CURRENT         0xE000E018  // SysTick Current Value Register
-#define NVIC_ST_CAL             0xE000E01C  // SysTick Calibration Value Reg.
-#define NVIC_EN0                0xE000E100  // IRQ 0 to 31 Set Enable Register
-#define NVIC_EN1                0xE000E104  // IRQ 32 to 63 Set Enable Register
-#define NVIC_DIS0               0xE000E180  // IRQ 0 to 31 Clear Enable Reg.
-#define NVIC_DIS1               0xE000E184  // IRQ 32 to 63 Clear Enable Reg.
-#define NVIC_PEND0              0xE000E200  // IRQ 0 to 31 Set Pending Register
-#define NVIC_PEND1              0xE000E204  // IRQ 32 to 63 Set Pending Reg.
-#define NVIC_UNPEND0            0xE000E280  // IRQ 0 to 31 Clear Pending Reg.
-#define NVIC_UNPEND1            0xE000E284  // IRQ 32 to 63 Clear Pending Reg.
-#define NVIC_ACTIVE0            0xE000E300  // IRQ 0 to 31 Active Register
-#define NVIC_ACTIVE1            0xE000E304  // IRQ 32 to 63 Active Register
-#define NVIC_PRI0               0xE000E400  // IRQ 0 to 3 Priority Register
-#define NVIC_PRI1               0xE000E404  // IRQ 4 to 7 Priority Register
-#define NVIC_PRI2               0xE000E408  // IRQ 8 to 11 Priority Register
-#define NVIC_PRI3               0xE000E40C  // IRQ 12 to 15 Priority Register
-#define NVIC_PRI4               0xE000E410  // IRQ 16 to 19 Priority Register
-#define NVIC_PRI5               0xE000E414  // IRQ 20 to 23 Priority Register
-#define NVIC_PRI6               0xE000E418  // IRQ 24 to 27 Priority Register
-#define NVIC_PRI7               0xE000E41C  // IRQ 28 to 31 Priority Register
-#define NVIC_PRI8               0xE000E420  // IRQ 32 to 35 Priority Register
-#define NVIC_PRI9               0xE000E424  // IRQ 36 to 39 Priority Register
-#define NVIC_PRI10              0xE000E428  // IRQ 40 to 43 Priority Register
-#define NVIC_PRI11              0xE000E42C  // IRQ 44 to 47 Priority Register
-#define NVIC_CPUID              0xE000ED00  // CPUID Base Register
-#define NVIC_INT_CTRL           0xE000ED04  // Interrupt Control State Register
-#define NVIC_VTABLE             0xE000ED08  // Vector Table Offset Register
-#define NVIC_APINT              0xE000ED0C  // App. Int &amp; Reset Control Reg.
-#define NVIC_SYS_CTRL           0xE000ED10  // System Control Register
-#define NVIC_CFG_CTRL           0xE000ED14  // Configuration Control Register
-#define NVIC_SYS_PRI1           0xE000ED18  // Sys. Handlers 4 to 7 Priority
-#define NVIC_SYS_PRI2           0xE000ED1C  // Sys. Handlers 8 to 11 Priority
-#define NVIC_SYS_PRI3           0xE000ED20  // Sys. Handlers 12 to 15 Priority
-#define NVIC_SYS_HND_CTRL       0xE000ED24  // System Handler Control and State
-#define NVIC_FAULT_STAT         0xE000ED28  // Configurable Fault Status Reg.
-#define NVIC_HFAULT_STAT        0xE000ED2C  // Hard Fault Status Register
-#define NVIC_DEBUG_STAT         0xE000ED30  // Debug Status Register
-#define NVIC_MM_ADDR            0xE000ED34  // Mem Manage Address Register
-#define NVIC_FAULT_ADDR         0xE000ED38  // Bus Fault Address Register
-#define NVIC_MPU_TYPE           0xE000ED90  // MPU Type Register
-#define NVIC_MPU_CTRL           0xE000ED94  // MPU Control Register
-#define NVIC_MPU_NUMBER         0xE000ED98  // MPU Region Number Register
-#define NVIC_MPU_BASE           0xE000ED9C  // MPU Region Base Address Register
-#define NVIC_MPU_ATTR           0xE000EDA0  // MPU Region Attribute &amp; Size Reg.
-#define NVIC_DBG_CTRL           0xE000EDF0  // Debug Control and Status Reg.
-#define NVIC_DBG_XFER           0xE000EDF4  // Debug Core Reg. Transfer Select
-#define NVIC_DBG_DATA           0xE000EDF8  // Debug Core Register Data
-#define NVIC_DBG_INT            0xE000EDFC  // Debug Reset Interrupt Control
-#define NVIC_SW_TRIG            0xE000EF00  // Software Trigger Interrupt Reg.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_INT_TYPE register.
-//
-//*****************************************************************************
-#define NVIC_INT_TYPE_LINES_M   0x0000001F  // Number of interrupt lines (x32)
-#define NVIC_INT_TYPE_LINES_S   0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_ST_CTRL register.
-//
-//*****************************************************************************
-#define NVIC_ST_CTRL_COUNT      0x00010000  // Count flag
-#define NVIC_ST_CTRL_CLK_SRC    0x00000004  // Clock Source
-#define NVIC_ST_CTRL_INTEN      0x00000002  // Interrupt enable
-#define NVIC_ST_CTRL_ENABLE     0x00000001  // Counter mode
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_ST_RELOAD register.
-//
-//*****************************************************************************
-#define NVIC_ST_RELOAD_M        0x00FFFFFF  // Counter load value
-#define NVIC_ST_RELOAD_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_ST_CURRENT
-// register.
-//
-//*****************************************************************************
-#define NVIC_ST_CURRENT_M       0x00FFFFFF  // Counter current value
-#define NVIC_ST_CURRENT_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_ST_CAL register.
-//
-//*****************************************************************************
-#define NVIC_ST_CAL_NOREF       0x80000000  // No reference clock
-#define NVIC_ST_CAL_SKEW        0x40000000  // Clock skew
-#define NVIC_ST_CAL_ONEMS_M     0x00FFFFFF  // 1ms reference value
-#define NVIC_ST_CAL_ONEMS_S     0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_EN0 register.
-//
-//*****************************************************************************
-#define NVIC_EN0_INT31          0x80000000  // Interrupt 31 enable
-#define NVIC_EN0_INT30          0x40000000  // Interrupt 30 enable
-#define NVIC_EN0_INT29          0x20000000  // Interrupt 29 enable
-#define NVIC_EN0_INT28          0x10000000  // Interrupt 28 enable
-#define NVIC_EN0_INT27          0x08000000  // Interrupt 27 enable
-#define NVIC_EN0_INT26          0x04000000  // Interrupt 26 enable
-#define NVIC_EN0_INT25          0x02000000  // Interrupt 25 enable
-#define NVIC_EN0_INT24          0x01000000  // Interrupt 24 enable
-#define NVIC_EN0_INT23          0x00800000  // Interrupt 23 enable
-#define NVIC_EN0_INT22          0x00400000  // Interrupt 22 enable
-#define NVIC_EN0_INT21          0x00200000  // Interrupt 21 enable
-#define NVIC_EN0_INT20          0x00100000  // Interrupt 20 enable
-#define NVIC_EN0_INT19          0x00080000  // Interrupt 19 enable
-#define NVIC_EN0_INT18          0x00040000  // Interrupt 18 enable
-#define NVIC_EN0_INT17          0x00020000  // Interrupt 17 enable
-#define NVIC_EN0_INT16          0x00010000  // Interrupt 16 enable
-#define NVIC_EN0_INT15          0x00008000  // Interrupt 15 enable
-#define NVIC_EN0_INT14          0x00004000  // Interrupt 14 enable
-#define NVIC_EN0_INT13          0x00002000  // Interrupt 13 enable
-#define NVIC_EN0_INT12          0x00001000  // Interrupt 12 enable
-#define NVIC_EN0_INT11          0x00000800  // Interrupt 11 enable
-#define NVIC_EN0_INT10          0x00000400  // Interrupt 10 enable
-#define NVIC_EN0_INT9           0x00000200  // Interrupt 9 enable
-#define NVIC_EN0_INT8           0x00000100  // Interrupt 8 enable
-#define NVIC_EN0_INT7           0x00000080  // Interrupt 7 enable
-#define NVIC_EN0_INT6           0x00000040  // Interrupt 6 enable
-#define NVIC_EN0_INT5           0x00000020  // Interrupt 5 enable
-#define NVIC_EN0_INT4           0x00000010  // Interrupt 4 enable
-#define NVIC_EN0_INT3           0x00000008  // Interrupt 3 enable
-#define NVIC_EN0_INT2           0x00000004  // Interrupt 2 enable
-#define NVIC_EN0_INT1           0x00000002  // Interrupt 1 enable
-#define NVIC_EN0_INT0           0x00000001  // Interrupt 0 enable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_EN1 register.
-//
-//*****************************************************************************
-#define NVIC_EN1_INT59          0x08000000  // Interrupt 59 enable
-#define NVIC_EN1_INT58          0x04000000  // Interrupt 58 enable
-#define NVIC_EN1_INT57          0x02000000  // Interrupt 57 enable
-#define NVIC_EN1_INT56          0x01000000  // Interrupt 56 enable
-#define NVIC_EN1_INT55          0x00800000  // Interrupt 55 enable
-#define NVIC_EN1_INT54          0x00400000  // Interrupt 54 enable
-#define NVIC_EN1_INT53          0x00200000  // Interrupt 53 enable
-#define NVIC_EN1_INT52          0x00100000  // Interrupt 52 enable
-#define NVIC_EN1_INT51          0x00080000  // Interrupt 51 enable
-#define NVIC_EN1_INT50          0x00040000  // Interrupt 50 enable
-#define NVIC_EN1_INT49          0x00020000  // Interrupt 49 enable
-#define NVIC_EN1_INT48          0x00010000  // Interrupt 48 enable
-#define NVIC_EN1_INT47          0x00008000  // Interrupt 47 enable
-#define NVIC_EN1_INT46          0x00004000  // Interrupt 46 enable
-#define NVIC_EN1_INT45          0x00002000  // Interrupt 45 enable
-#define NVIC_EN1_INT44          0x00001000  // Interrupt 44 enable
-#define NVIC_EN1_INT43          0x00000800  // Interrupt 43 enable
-#define NVIC_EN1_INT42          0x00000400  // Interrupt 42 enable
-#define NVIC_EN1_INT41          0x00000200  // Interrupt 41 enable
-#define NVIC_EN1_INT40          0x00000100  // Interrupt 40 enable
-#define NVIC_EN1_INT39          0x00000080  // Interrupt 39 enable
-#define NVIC_EN1_INT38          0x00000040  // Interrupt 38 enable
-#define NVIC_EN1_INT37          0x00000020  // Interrupt 37 enable
-#define NVIC_EN1_INT36          0x00000010  // Interrupt 36 enable
-#define NVIC_EN1_INT35          0x00000008  // Interrupt 35 enable
-#define NVIC_EN1_INT34          0x00000004  // Interrupt 34 enable
-#define NVIC_EN1_INT33          0x00000002  // Interrupt 33 enable
-#define NVIC_EN1_INT32          0x00000001  // Interrupt 32 enable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_DIS0 register.
-//
-//*****************************************************************************
-#define NVIC_DIS0_INT31         0x80000000  // Interrupt 31 disable
-#define NVIC_DIS0_INT30         0x40000000  // Interrupt 30 disable
-#define NVIC_DIS0_INT29         0x20000000  // Interrupt 29 disable
-#define NVIC_DIS0_INT28         0x10000000  // Interrupt 28 disable
-#define NVIC_DIS0_INT27         0x08000000  // Interrupt 27 disable
-#define NVIC_DIS0_INT26         0x04000000  // Interrupt 26 disable
-#define NVIC_DIS0_INT25         0x02000000  // Interrupt 25 disable
-#define NVIC_DIS0_INT24         0x01000000  // Interrupt 24 disable
-#define NVIC_DIS0_INT23         0x00800000  // Interrupt 23 disable
-#define NVIC_DIS0_INT22         0x00400000  // Interrupt 22 disable
-#define NVIC_DIS0_INT21         0x00200000  // Interrupt 21 disable
-#define NVIC_DIS0_INT20         0x00100000  // Interrupt 20 disable
-#define NVIC_DIS0_INT19         0x00080000  // Interrupt 19 disable
-#define NVIC_DIS0_INT18         0x00040000  // Interrupt 18 disable
-#define NVIC_DIS0_INT17         0x00020000  // Interrupt 17 disable
-#define NVIC_DIS0_INT16         0x00010000  // Interrupt 16 disable
-#define NVIC_DIS0_INT15         0x00008000  // Interrupt 15 disable
-#define NVIC_DIS0_INT14         0x00004000  // Interrupt 14 disable
-#define NVIC_DIS0_INT13         0x00002000  // Interrupt 13 disable
-#define NVIC_DIS0_INT12         0x00001000  // Interrupt 12 disable
-#define NVIC_DIS0_INT11         0x00000800  // Interrupt 11 disable
-#define NVIC_DIS0_INT10         0x00000400  // Interrupt 10 disable
-#define NVIC_DIS0_INT9          0x00000200  // Interrupt 9 disable
-#define NVIC_DIS0_INT8          0x00000100  // Interrupt 8 disable
-#define NVIC_DIS0_INT7          0x00000080  // Interrupt 7 disable
-#define NVIC_DIS0_INT6          0x00000040  // Interrupt 6 disable
-#define NVIC_DIS0_INT5          0x00000020  // Interrupt 5 disable
-#define NVIC_DIS0_INT4          0x00000010  // Interrupt 4 disable
-#define NVIC_DIS0_INT3          0x00000008  // Interrupt 3 disable
-#define NVIC_DIS0_INT2          0x00000004  // Interrupt 2 disable
-#define NVIC_DIS0_INT1          0x00000002  // Interrupt 1 disable
-#define NVIC_DIS0_INT0          0x00000001  // Interrupt 0 disable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_DIS1 register.
-//
-//*****************************************************************************
-#define NVIC_DIS1_INT59         0x08000000  // Interrupt 59 disable
-#define NVIC_DIS1_INT58         0x04000000  // Interrupt 58 disable
-#define NVIC_DIS1_INT57         0x02000000  // Interrupt 57 disable
-#define NVIC_DIS1_INT56         0x01000000  // Interrupt 56 disable
-#define NVIC_DIS1_INT55         0x00800000  // Interrupt 55 disable
-#define NVIC_DIS1_INT54         0x00400000  // Interrupt 54 disable
-#define NVIC_DIS1_INT53         0x00200000  // Interrupt 53 disable
-#define NVIC_DIS1_INT52         0x00100000  // Interrupt 52 disable
-#define NVIC_DIS1_INT51         0x00080000  // Interrupt 51 disable
-#define NVIC_DIS1_INT50         0x00040000  // Interrupt 50 disable
-#define NVIC_DIS1_INT49         0x00020000  // Interrupt 49 disable
-#define NVIC_DIS1_INT48         0x00010000  // Interrupt 48 disable
-#define NVIC_DIS1_INT47         0x00008000  // Interrupt 47 disable
-#define NVIC_DIS1_INT46         0x00004000  // Interrupt 46 disable
-#define NVIC_DIS1_INT45         0x00002000  // Interrupt 45 disable
-#define NVIC_DIS1_INT44         0x00001000  // Interrupt 44 disable
-#define NVIC_DIS1_INT43         0x00000800  // Interrupt 43 disable
-#define NVIC_DIS1_INT42         0x00000400  // Interrupt 42 disable
-#define NVIC_DIS1_INT41         0x00000200  // Interrupt 41 disable
-#define NVIC_DIS1_INT40         0x00000100  // Interrupt 40 disable
-#define NVIC_DIS1_INT39         0x00000080  // Interrupt 39 disable
-#define NVIC_DIS1_INT38         0x00000040  // Interrupt 38 disable
-#define NVIC_DIS1_INT37         0x00000020  // Interrupt 37 disable
-#define NVIC_DIS1_INT36         0x00000010  // Interrupt 36 disable
-#define NVIC_DIS1_INT35         0x00000008  // Interrupt 35 disable
-#define NVIC_DIS1_INT34         0x00000004  // Interrupt 34 disable
-#define NVIC_DIS1_INT33         0x00000002  // Interrupt 33 disable
-#define NVIC_DIS1_INT32         0x00000001  // Interrupt 32 disable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PEND0 register.
-//
-//*****************************************************************************
-#define NVIC_PEND0_INT31        0x80000000  // Interrupt 31 pend
-#define NVIC_PEND0_INT30        0x40000000  // Interrupt 30 pend
-#define NVIC_PEND0_INT29        0x20000000  // Interrupt 29 pend
-#define NVIC_PEND0_INT28        0x10000000  // Interrupt 28 pend
-#define NVIC_PEND0_INT27        0x08000000  // Interrupt 27 pend
-#define NVIC_PEND0_INT26        0x04000000  // Interrupt 26 pend
-#define NVIC_PEND0_INT25        0x02000000  // Interrupt 25 pend
-#define NVIC_PEND0_INT24        0x01000000  // Interrupt 24 pend
-#define NVIC_PEND0_INT23        0x00800000  // Interrupt 23 pend
-#define NVIC_PEND0_INT22        0x00400000  // Interrupt 22 pend
-#define NVIC_PEND0_INT21        0x00200000  // Interrupt 21 pend
-#define NVIC_PEND0_INT20        0x00100000  // Interrupt 20 pend
-#define NVIC_PEND0_INT19        0x00080000  // Interrupt 19 pend
-#define NVIC_PEND0_INT18        0x00040000  // Interrupt 18 pend
-#define NVIC_PEND0_INT17        0x00020000  // Interrupt 17 pend
-#define NVIC_PEND0_INT16        0x00010000  // Interrupt 16 pend
-#define NVIC_PEND0_INT15        0x00008000  // Interrupt 15 pend
-#define NVIC_PEND0_INT14        0x00004000  // Interrupt 14 pend
-#define NVIC_PEND0_INT13        0x00002000  // Interrupt 13 pend
-#define NVIC_PEND0_INT12        0x00001000  // Interrupt 12 pend
-#define NVIC_PEND0_INT11        0x00000800  // Interrupt 11 pend
-#define NVIC_PEND0_INT10        0x00000400  // Interrupt 10 pend
-#define NVIC_PEND0_INT9         0x00000200  // Interrupt 9 pend
-#define NVIC_PEND0_INT8         0x00000100  // Interrupt 8 pend
-#define NVIC_PEND0_INT7         0x00000080  // Interrupt 7 pend
-#define NVIC_PEND0_INT6         0x00000040  // Interrupt 6 pend
-#define NVIC_PEND0_INT5         0x00000020  // Interrupt 5 pend
-#define NVIC_PEND0_INT4         0x00000010  // Interrupt 4 pend
-#define NVIC_PEND0_INT3         0x00000008  // Interrupt 3 pend
-#define NVIC_PEND0_INT2         0x00000004  // Interrupt 2 pend
-#define NVIC_PEND0_INT1         0x00000002  // Interrupt 1 pend
-#define NVIC_PEND0_INT0         0x00000001  // Interrupt 0 pend
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PEND1 register.
-//
-//*****************************************************************************
-#define NVIC_PEND1_INT59        0x08000000  // Interrupt 59 pend
-#define NVIC_PEND1_INT58        0x04000000  // Interrupt 58 pend
-#define NVIC_PEND1_INT57        0x02000000  // Interrupt 57 pend
-#define NVIC_PEND1_INT56        0x01000000  // Interrupt 56 pend
-#define NVIC_PEND1_INT55        0x00800000  // Interrupt 55 pend
-#define NVIC_PEND1_INT54        0x00400000  // Interrupt 54 pend
-#define NVIC_PEND1_INT53        0x00200000  // Interrupt 53 pend
-#define NVIC_PEND1_INT52        0x00100000  // Interrupt 52 pend
-#define NVIC_PEND1_INT51        0x00080000  // Interrupt 51 pend
-#define NVIC_PEND1_INT50        0x00040000  // Interrupt 50 pend
-#define NVIC_PEND1_INT49        0x00020000  // Interrupt 49 pend
-#define NVIC_PEND1_INT48        0x00010000  // Interrupt 48 pend
-#define NVIC_PEND1_INT47        0x00008000  // Interrupt 47 pend
-#define NVIC_PEND1_INT46        0x00004000  // Interrupt 46 pend
-#define NVIC_PEND1_INT45        0x00002000  // Interrupt 45 pend
-#define NVIC_PEND1_INT44        0x00001000  // Interrupt 44 pend
-#define NVIC_PEND1_INT43        0x00000800  // Interrupt 43 pend
-#define NVIC_PEND1_INT42        0x00000400  // Interrupt 42 pend
-#define NVIC_PEND1_INT41        0x00000200  // Interrupt 41 pend
-#define NVIC_PEND1_INT40        0x00000100  // Interrupt 40 pend
-#define NVIC_PEND1_INT39        0x00000080  // Interrupt 39 pend
-#define NVIC_PEND1_INT38        0x00000040  // Interrupt 38 pend
-#define NVIC_PEND1_INT37        0x00000020  // Interrupt 37 pend
-#define NVIC_PEND1_INT36        0x00000010  // Interrupt 36 pend
-#define NVIC_PEND1_INT35        0x00000008  // Interrupt 35 pend
-#define NVIC_PEND1_INT34        0x00000004  // Interrupt 34 pend
-#define NVIC_PEND1_INT33        0x00000002  // Interrupt 33 pend
-#define NVIC_PEND1_INT32        0x00000001  // Interrupt 32 pend
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_UNPEND0 register.
-//
-//*****************************************************************************
-#define NVIC_UNPEND0_INT31      0x80000000  // Interrupt 31 unpend
-#define NVIC_UNPEND0_INT30      0x40000000  // Interrupt 30 unpend
-#define NVIC_UNPEND0_INT29      0x20000000  // Interrupt 29 unpend
-#define NVIC_UNPEND0_INT28      0x10000000  // Interrupt 28 unpend
-#define NVIC_UNPEND0_INT27      0x08000000  // Interrupt 27 unpend
-#define NVIC_UNPEND0_INT26      0x04000000  // Interrupt 26 unpend
-#define NVIC_UNPEND0_INT25      0x02000000  // Interrupt 25 unpend
-#define NVIC_UNPEND0_INT24      0x01000000  // Interrupt 24 unpend
-#define NVIC_UNPEND0_INT23      0x00800000  // Interrupt 23 unpend
-#define NVIC_UNPEND0_INT22      0x00400000  // Interrupt 22 unpend
-#define NVIC_UNPEND0_INT21      0x00200000  // Interrupt 21 unpend
-#define NVIC_UNPEND0_INT20      0x00100000  // Interrupt 20 unpend
-#define NVIC_UNPEND0_INT19      0x00080000  // Interrupt 19 unpend
-#define NVIC_UNPEND0_INT18      0x00040000  // Interrupt 18 unpend
-#define NVIC_UNPEND0_INT17      0x00020000  // Interrupt 17 unpend
-#define NVIC_UNPEND0_INT16      0x00010000  // Interrupt 16 unpend
-#define NVIC_UNPEND0_INT15      0x00008000  // Interrupt 15 unpend
-#define NVIC_UNPEND0_INT14      0x00004000  // Interrupt 14 unpend
-#define NVIC_UNPEND0_INT13      0x00002000  // Interrupt 13 unpend
-#define NVIC_UNPEND0_INT12      0x00001000  // Interrupt 12 unpend
-#define NVIC_UNPEND0_INT11      0x00000800  // Interrupt 11 unpend
-#define NVIC_UNPEND0_INT10      0x00000400  // Interrupt 10 unpend
-#define NVIC_UNPEND0_INT9       0x00000200  // Interrupt 9 unpend
-#define NVIC_UNPEND0_INT8       0x00000100  // Interrupt 8 unpend
-#define NVIC_UNPEND0_INT7       0x00000080  // Interrupt 7 unpend
-#define NVIC_UNPEND0_INT6       0x00000040  // Interrupt 6 unpend
-#define NVIC_UNPEND0_INT5       0x00000020  // Interrupt 5 unpend
-#define NVIC_UNPEND0_INT4       0x00000010  // Interrupt 4 unpend
-#define NVIC_UNPEND0_INT3       0x00000008  // Interrupt 3 unpend
-#define NVIC_UNPEND0_INT2       0x00000004  // Interrupt 2 unpend
-#define NVIC_UNPEND0_INT1       0x00000002  // Interrupt 1 unpend
-#define NVIC_UNPEND0_INT0       0x00000001  // Interrupt 0 unpend
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_UNPEND1 register.
-//
-//*****************************************************************************
-#define NVIC_UNPEND1_INT59      0x08000000  // Interrupt 59 unpend
-#define NVIC_UNPEND1_INT58      0x04000000  // Interrupt 58 unpend
-#define NVIC_UNPEND1_INT57      0x02000000  // Interrupt 57 unpend
-#define NVIC_UNPEND1_INT56      0x01000000  // Interrupt 56 unpend
-#define NVIC_UNPEND1_INT55      0x00800000  // Interrupt 55 unpend
-#define NVIC_UNPEND1_INT54      0x00400000  // Interrupt 54 unpend
-#define NVIC_UNPEND1_INT53      0x00200000  // Interrupt 53 unpend
-#define NVIC_UNPEND1_INT52      0x00100000  // Interrupt 52 unpend
-#define NVIC_UNPEND1_INT51      0x00080000  // Interrupt 51 unpend
-#define NVIC_UNPEND1_INT50      0x00040000  // Interrupt 50 unpend
-#define NVIC_UNPEND1_INT49      0x00020000  // Interrupt 49 unpend
-#define NVIC_UNPEND1_INT48      0x00010000  // Interrupt 48 unpend
-#define NVIC_UNPEND1_INT47      0x00008000  // Interrupt 47 unpend
-#define NVIC_UNPEND1_INT46      0x00004000  // Interrupt 46 unpend
-#define NVIC_UNPEND1_INT45      0x00002000  // Interrupt 45 unpend
-#define NVIC_UNPEND1_INT44      0x00001000  // Interrupt 44 unpend
-#define NVIC_UNPEND1_INT43      0x00000800  // Interrupt 43 unpend
-#define NVIC_UNPEND1_INT42      0x00000400  // Interrupt 42 unpend
-#define NVIC_UNPEND1_INT41      0x00000200  // Interrupt 41 unpend
-#define NVIC_UNPEND1_INT40      0x00000100  // Interrupt 40 unpend
-#define NVIC_UNPEND1_INT39      0x00000080  // Interrupt 39 unpend
-#define NVIC_UNPEND1_INT38      0x00000040  // Interrupt 38 unpend
-#define NVIC_UNPEND1_INT37      0x00000020  // Interrupt 37 unpend
-#define NVIC_UNPEND1_INT36      0x00000010  // Interrupt 36 unpend
-#define NVIC_UNPEND1_INT35      0x00000008  // Interrupt 35 unpend
-#define NVIC_UNPEND1_INT34      0x00000004  // Interrupt 34 unpend
-#define NVIC_UNPEND1_INT33      0x00000002  // Interrupt 33 unpend
-#define NVIC_UNPEND1_INT32      0x00000001  // Interrupt 32 unpend
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_ACTIVE0 register.
-//
-//*****************************************************************************
-#define NVIC_ACTIVE0_INT31      0x80000000  // Interrupt 31 active
-#define NVIC_ACTIVE0_INT30      0x40000000  // Interrupt 30 active
-#define NVIC_ACTIVE0_INT29      0x20000000  // Interrupt 29 active
-#define NVIC_ACTIVE0_INT28      0x10000000  // Interrupt 28 active
-#define NVIC_ACTIVE0_INT27      0x08000000  // Interrupt 27 active
-#define NVIC_ACTIVE0_INT26      0x04000000  // Interrupt 26 active
-#define NVIC_ACTIVE0_INT25      0x02000000  // Interrupt 25 active
-#define NVIC_ACTIVE0_INT24      0x01000000  // Interrupt 24 active
-#define NVIC_ACTIVE0_INT23      0x00800000  // Interrupt 23 active
-#define NVIC_ACTIVE0_INT22      0x00400000  // Interrupt 22 active
-#define NVIC_ACTIVE0_INT21      0x00200000  // Interrupt 21 active
-#define NVIC_ACTIVE0_INT20      0x00100000  // Interrupt 20 active
-#define NVIC_ACTIVE0_INT19      0x00080000  // Interrupt 19 active
-#define NVIC_ACTIVE0_INT18      0x00040000  // Interrupt 18 active
-#define NVIC_ACTIVE0_INT17      0x00020000  // Interrupt 17 active
-#define NVIC_ACTIVE0_INT16      0x00010000  // Interrupt 16 active
-#define NVIC_ACTIVE0_INT15      0x00008000  // Interrupt 15 active
-#define NVIC_ACTIVE0_INT14      0x00004000  // Interrupt 14 active
-#define NVIC_ACTIVE0_INT13      0x00002000  // Interrupt 13 active
-#define NVIC_ACTIVE0_INT12      0x00001000  // Interrupt 12 active
-#define NVIC_ACTIVE0_INT11      0x00000800  // Interrupt 11 active
-#define NVIC_ACTIVE0_INT10      0x00000400  // Interrupt 10 active
-#define NVIC_ACTIVE0_INT9       0x00000200  // Interrupt 9 active
-#define NVIC_ACTIVE0_INT8       0x00000100  // Interrupt 8 active
-#define NVIC_ACTIVE0_INT7       0x00000080  // Interrupt 7 active
-#define NVIC_ACTIVE0_INT6       0x00000040  // Interrupt 6 active
-#define NVIC_ACTIVE0_INT5       0x00000020  // Interrupt 5 active
-#define NVIC_ACTIVE0_INT4       0x00000010  // Interrupt 4 active
-#define NVIC_ACTIVE0_INT3       0x00000008  // Interrupt 3 active
-#define NVIC_ACTIVE0_INT2       0x00000004  // Interrupt 2 active
-#define NVIC_ACTIVE0_INT1       0x00000002  // Interrupt 1 active
-#define NVIC_ACTIVE0_INT0       0x00000001  // Interrupt 0 active
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_ACTIVE1 register.
-//
-//*****************************************************************************
-#define NVIC_ACTIVE1_INT59      0x08000000  // Interrupt 59 active
-#define NVIC_ACTIVE1_INT58      0x04000000  // Interrupt 58 active
-#define NVIC_ACTIVE1_INT57      0x02000000  // Interrupt 57 active
-#define NVIC_ACTIVE1_INT56      0x01000000  // Interrupt 56 active
-#define NVIC_ACTIVE1_INT55      0x00800000  // Interrupt 55 active
-#define NVIC_ACTIVE1_INT54      0x00400000  // Interrupt 54 active
-#define NVIC_ACTIVE1_INT53      0x00200000  // Interrupt 53 active
-#define NVIC_ACTIVE1_INT52      0x00100000  // Interrupt 52 active
-#define NVIC_ACTIVE1_INT51      0x00080000  // Interrupt 51 active
-#define NVIC_ACTIVE1_INT50      0x00040000  // Interrupt 50 active
-#define NVIC_ACTIVE1_INT49      0x00020000  // Interrupt 49 active
-#define NVIC_ACTIVE1_INT48      0x00010000  // Interrupt 48 active
-#define NVIC_ACTIVE1_INT47      0x00008000  // Interrupt 47 active
-#define NVIC_ACTIVE1_INT46      0x00004000  // Interrupt 46 active
-#define NVIC_ACTIVE1_INT45      0x00002000  // Interrupt 45 active
-#define NVIC_ACTIVE1_INT44      0x00001000  // Interrupt 44 active
-#define NVIC_ACTIVE1_INT43      0x00000800  // Interrupt 43 active
-#define NVIC_ACTIVE1_INT42      0x00000400  // Interrupt 42 active
-#define NVIC_ACTIVE1_INT41      0x00000200  // Interrupt 41 active
-#define NVIC_ACTIVE1_INT40      0x00000100  // Interrupt 40 active
-#define NVIC_ACTIVE1_INT39      0x00000080  // Interrupt 39 active
-#define NVIC_ACTIVE1_INT38      0x00000040  // Interrupt 38 active
-#define NVIC_ACTIVE1_INT37      0x00000020  // Interrupt 37 active
-#define NVIC_ACTIVE1_INT36      0x00000010  // Interrupt 36 active
-#define NVIC_ACTIVE1_INT35      0x00000008  // Interrupt 35 active
-#define NVIC_ACTIVE1_INT34      0x00000004  // Interrupt 34 active
-#define NVIC_ACTIVE1_INT33      0x00000002  // Interrupt 33 active
-#define NVIC_ACTIVE1_INT32      0x00000001  // Interrupt 32 active
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI0 register.
-//
-//*****************************************************************************
-#define NVIC_PRI0_INT3_M        0xFF000000  // Interrupt 3 priority mask
-#define NVIC_PRI0_INT2_M        0x00FF0000  // Interrupt 2 priority mask
-#define NVIC_PRI0_INT1_M        0x0000FF00  // Interrupt 1 priority mask
-#define NVIC_PRI0_INT0_M        0x000000FF  // Interrupt 0 priority mask
-#define NVIC_PRI0_INT3_S        24
-#define NVIC_PRI0_INT2_S        16
-#define NVIC_PRI0_INT1_S        8
-#define NVIC_PRI0_INT0_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI1 register.
-//
-//*****************************************************************************
-#define NVIC_PRI1_INT7_M        0xFF000000  // Interrupt 7 priority mask
-#define NVIC_PRI1_INT6_M        0x00FF0000  // Interrupt 6 priority mask
-#define NVIC_PRI1_INT5_M        0x0000FF00  // Interrupt 5 priority mask
-#define NVIC_PRI1_INT4_M        0x000000FF  // Interrupt 4 priority mask
-#define NVIC_PRI1_INT7_S        24
-#define NVIC_PRI1_INT6_S        16
-#define NVIC_PRI1_INT5_S        8
-#define NVIC_PRI1_INT4_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI2 register.
-//
-//*****************************************************************************
-#define NVIC_PRI2_INT11_M       0xFF000000  // Interrupt 11 priority mask
-#define NVIC_PRI2_INT10_M       0x00FF0000  // Interrupt 10 priority mask
-#define NVIC_PRI2_INT9_M        0x0000FF00  // Interrupt 9 priority mask
-#define NVIC_PRI2_INT8_M        0x000000FF  // Interrupt 8 priority mask
-#define NVIC_PRI2_INT11_S       24
-#define NVIC_PRI2_INT10_S       16
-#define NVIC_PRI2_INT9_S        8
-#define NVIC_PRI2_INT8_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI3 register.
-//
-//*****************************************************************************
-#define NVIC_PRI3_INT15_M       0xFF000000  // Interrupt 15 priority mask
-#define NVIC_PRI3_INT14_M       0x00FF0000  // Interrupt 14 priority mask
-#define NVIC_PRI3_INT13_M       0x0000FF00  // Interrupt 13 priority mask
-#define NVIC_PRI3_INT12_M       0x000000FF  // Interrupt 12 priority mask
-#define NVIC_PRI3_INT15_S       24
-#define NVIC_PRI3_INT14_S       16
-#define NVIC_PRI3_INT13_S       8
-#define NVIC_PRI3_INT12_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI4 register.
-//
-//*****************************************************************************
-#define NVIC_PRI4_INT19_M       0xFF000000  // Interrupt 19 priority mask
-#define NVIC_PRI4_INT18_M       0x00FF0000  // Interrupt 18 priority mask
-#define NVIC_PRI4_INT17_M       0x0000FF00  // Interrupt 17 priority mask
-#define NVIC_PRI4_INT16_M       0x000000FF  // Interrupt 16 priority mask
-#define NVIC_PRI4_INT19_S       24
-#define NVIC_PRI4_INT18_S       16
-#define NVIC_PRI4_INT17_S       8
-#define NVIC_PRI4_INT16_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI5 register.
-//
-//*****************************************************************************
-#define NVIC_PRI5_INT23_M       0xFF000000  // Interrupt 23 priority mask
-#define NVIC_PRI5_INT22_M       0x00FF0000  // Interrupt 22 priority mask
-#define NVIC_PRI5_INT21_M       0x0000FF00  // Interrupt 21 priority mask
-#define NVIC_PRI5_INT20_M       0x000000FF  // Interrupt 20 priority mask
-#define NVIC_PRI5_INT23_S       24
-#define NVIC_PRI5_INT22_S       16
-#define NVIC_PRI5_INT21_S       8
-#define NVIC_PRI5_INT20_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI6 register.
-//
-//*****************************************************************************
-#define NVIC_PRI6_INT27_M       0xFF000000  // Interrupt 27 priority mask
-#define NVIC_PRI6_INT26_M       0x00FF0000  // Interrupt 26 priority mask
-#define NVIC_PRI6_INT25_M       0x0000FF00  // Interrupt 25 priority mask
-#define NVIC_PRI6_INT24_M       0x000000FF  // Interrupt 24 priority mask
-#define NVIC_PRI6_INT27_S       24
-#define NVIC_PRI6_INT26_S       16
-#define NVIC_PRI6_INT25_S       8
-#define NVIC_PRI6_INT24_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI7 register.
-//
-//*****************************************************************************
-#define NVIC_PRI7_INT31_M       0xFF000000  // Interrupt 31 priority mask
-#define NVIC_PRI7_INT30_M       0x00FF0000  // Interrupt 30 priority mask
-#define NVIC_PRI7_INT29_M       0x0000FF00  // Interrupt 29 priority mask
-#define NVIC_PRI7_INT28_M       0x000000FF  // Interrupt 28 priority mask
-#define NVIC_PRI7_INT31_S       24
-#define NVIC_PRI7_INT30_S       16
-#define NVIC_PRI7_INT29_S       8
-#define NVIC_PRI7_INT28_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI8 register.
-//
-//*****************************************************************************
-#define NVIC_PRI8_INT35_M       0xFF000000  // Interrupt 35 priority mask
-#define NVIC_PRI8_INT34_M       0x00FF0000  // Interrupt 34 priority mask
-#define NVIC_PRI8_INT33_M       0x0000FF00  // Interrupt 33 priority mask
-#define NVIC_PRI8_INT32_M       0x000000FF  // Interrupt 32 priority mask
-#define NVIC_PRI8_INT35_S       24
-#define NVIC_PRI8_INT34_S       16
-#define NVIC_PRI8_INT33_S       8
-#define NVIC_PRI8_INT32_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI9 register.
-//
-//*****************************************************************************
-#define NVIC_PRI9_INT39_M       0xFF000000  // Interrupt 39 priority mask
-#define NVIC_PRI9_INT38_M       0x00FF0000  // Interrupt 38 priority mask
-#define NVIC_PRI9_INT37_M       0x0000FF00  // Interrupt 37 priority mask
-#define NVIC_PRI9_INT36_M       0x000000FF  // Interrupt 36 priority mask
-#define NVIC_PRI9_INT39_S       24
-#define NVIC_PRI9_INT38_S       16
-#define NVIC_PRI9_INT37_S       8
-#define NVIC_PRI9_INT36_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_PRI10 register.
-//
-//*****************************************************************************
-#define NVIC_PRI10_INT43_M      0xFF000000  // Interrupt 43 priority mask
-#define NVIC_PRI10_INT42_M      0x00FF0000  // Interrupt 42 priority mask
-#define NVIC_PRI10_INT41_M      0x0000FF00  // Interrupt 41 priority mask
-#define NVIC_PRI10_INT40_M      0x000000FF  // Interrupt 40 priority mask
-#define NVIC_PRI10_INT43_S      24
-#define NVIC_PRI10_INT42_S      16
-#define NVIC_PRI10_INT41_S      8
-#define NVIC_PRI10_INT40_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_CPUID register.
-//
-//*****************************************************************************
-#define NVIC_CPUID_IMP_M        0xFF000000  // Implementer
-#define NVIC_CPUID_VAR_M        0x00F00000  // Variant
-#define NVIC_CPUID_PARTNO_M     0x0000FFF0  // Processor part number
-#define NVIC_CPUID_REV_M        0x0000000F  // Revision
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_INT_CTRL register.
-//
-//*****************************************************************************
-#define NVIC_INT_CTRL_NMI_SET   0x80000000  // Pend a NMI
-#define NVIC_INT_CTRL_PEND_SV   0x10000000  // Pend a PendSV
-#define NVIC_INT_CTRL_UNPEND_SV 0x08000000  // Unpend a PendSV
-#define NVIC_INT_CTRL_ISR_PRE   0x00800000  // Debug interrupt handling
-#define NVIC_INT_CTRL_ISR_PEND  0x00400000  // Debug interrupt pending
-#define NVIC_INT_CTRL_VEC_PEN_M 0x003FF000  // Highest pending exception
-#define NVIC_INT_CTRL_RET_BASE  0x00000800  // Return to base
-#define NVIC_INT_CTRL_VEC_ACT_M 0x000003FF  // Current active exception
-#define NVIC_INT_CTRL_VEC_PEN_S 12
-#define NVIC_INT_CTRL_VEC_ACT_S 0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_VTABLE register.
-//
-//*****************************************************************************
-#define NVIC_VTABLE_BASE        0x20000000  // Vector table base
-#define NVIC_VTABLE_OFFSET_M    0x1FFFFF00  // Vector table offset
-#define NVIC_VTABLE_OFFSET_S    8
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_APINT register.
-//
-//*****************************************************************************
-#define NVIC_APINT_VECTKEY_M    0xFFFF0000  // Vector key mask
-#define NVIC_APINT_VECTKEY      0x05FA0000  // Vector key
-#define NVIC_APINT_ENDIANESS    0x00008000  // Data endianess
-#define NVIC_APINT_PRIGROUP_M   0x00000700  // Priority group
-#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
-#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
-#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
-#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
-#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
-#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
-#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
-#define NVIC_APINT_SYSRESETREQ  0x00000004  // System reset request
-#define NVIC_APINT_VECT_CLR_ACT 0x00000002  // Clear active NMI/fault info
-#define NVIC_APINT_VECT_RESET   0x00000001  // System reset
-#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_SYS_CTRL register.
-//
-//*****************************************************************************
-#define NVIC_SYS_CTRL_SEVONPEND 0x00000010  // Wakeup on pend
-#define NVIC_SYS_CTRL_SLEEPDEEP 0x00000004  // Deep sleep enable
-#define NVIC_SYS_CTRL_SLEEPEXIT 0x00000002  // Sleep on ISR exit
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_CFG_CTRL register.
-//
-//*****************************************************************************
-#define NVIC_CFG_CTRL_BFHFNMIGN 0x00000100  // Ignore bus fault in NMI/fault
-#define NVIC_CFG_CTRL_DIV0      0x00000010  // Trap on divide by 0
-#define NVIC_CFG_CTRL_UNALIGNED 0x00000008  // Trap on unaligned access
-#define NVIC_CFG_CTRL_DEEP_PEND 0x00000004  // Allow deep interrupt trigger
-#define NVIC_CFG_CTRL_MAIN_PEND 0x00000002  // Allow main interrupt trigger
-#define NVIC_CFG_CTRL_BASE_THR  0x00000001  // Thread state control
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_SYS_PRI1 register.
-//
-//*****************************************************************************
-#define NVIC_SYS_PRI1_RES_M     0xFF000000  // Priority of reserved handler
-#define NVIC_SYS_PRI1_USAGE_M   0x00FF0000  // Priority of usage fault handler
-#define NVIC_SYS_PRI1_BUS_M     0x0000FF00  // Priority of bus fault handler
-#define NVIC_SYS_PRI1_MEM_M     0x000000FF  // Priority of mem manage handler
-#define NVIC_SYS_PRI1_USAGE_S   16
-#define NVIC_SYS_PRI1_BUS_S     8
-#define NVIC_SYS_PRI1_MEM_S     0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_SYS_PRI2 register.
-//
-//*****************************************************************************
-#define NVIC_SYS_PRI2_SVC_M     0xFF000000  // Priority of SVCall handler
-#define NVIC_SYS_PRI2_RES_M     0x00FFFFFF  // Priority of reserved handlers
-#define NVIC_SYS_PRI2_SVC_S     24
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_SYS_PRI3 register.
-//
-//*****************************************************************************
-#define NVIC_SYS_PRI3_TICK_M    0xFF000000  // Priority of Sys Tick handler
-#define NVIC_SYS_PRI3_PENDSV_M  0x00FF0000  // Priority of PendSV handler
-#define NVIC_SYS_PRI3_RES_M     0x0000FF00  // Priority of reserved handler
-#define NVIC_SYS_PRI3_DEBUG_M   0x000000FF  // Priority of debug handler
-#define NVIC_SYS_PRI3_TICK_S    24
-#define NVIC_SYS_PRI3_PENDSV_S  16
-#define NVIC_SYS_PRI3_DEBUG_S   0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_SYS_HND_CTRL
-// register.
-//
-//*****************************************************************************
-#define NVIC_SYS_HND_CTRL_USAGE 0x00040000  // Usage fault enable
-#define NVIC_SYS_HND_CTRL_BUS   0x00020000  // Bus fault enable
-#define NVIC_SYS_HND_CTRL_MEM   0x00010000  // Mem manage fault enable
-#define NVIC_SYS_HND_CTRL_SVC   0x00008000  // SVCall is pended
-#define NVIC_SYS_HND_CTRL_BUSP  0x00004000  // Bus fault is pended
-#define NVIC_SYS_HND_CTRL_TICK  0x00000800  // Sys tick is active
-#define NVIC_SYS_HND_CTRL_PNDSV 0x00000400  // PendSV is active
-#define NVIC_SYS_HND_CTRL_MON   0x00000100  // Monitor is active
-#define NVIC_SYS_HND_CTRL_SVCA  0x00000080  // SVCall is active
-#define NVIC_SYS_HND_CTRL_USGA  0x00000008  // Usage fault is active
-#define NVIC_SYS_HND_CTRL_BUSA  0x00000002  // Bus fault is active
-#define NVIC_SYS_HND_CTRL_MEMA  0x00000001  // Mem manage is active
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_FAULT_STAT
-// register.
-//
-//*****************************************************************************
-#define NVIC_FAULT_STAT_DIV0    0x02000000  // Divide by zero fault
-#define NVIC_FAULT_STAT_UNALIGN 0x01000000  // Unaligned access fault
-#define NVIC_FAULT_STAT_NOCP    0x00080000  // No coprocessor fault
-#define NVIC_FAULT_STAT_INVPC   0x00040000  // Invalid PC fault
-#define NVIC_FAULT_STAT_INVSTAT 0x00020000  // Invalid state fault
-#define NVIC_FAULT_STAT_UNDEF   0x00010000  // Undefined instruction fault
-#define NVIC_FAULT_STAT_BFARV   0x00008000  // BFAR is valid
-#define NVIC_FAULT_STAT_BSTKE   0x00001000  // Stack bus fault
-#define NVIC_FAULT_STAT_BUSTKE  0x00000800  // Unstack bus fault
-#define NVIC_FAULT_STAT_IMPRE   0x00000400  // Imprecise data bus error
-#define NVIC_FAULT_STAT_PRECISE 0x00000200  // Precise data bus error
-#define NVIC_FAULT_STAT_IBUS    0x00000100  // Instruction bus fault
-#define NVIC_FAULT_STAT_MMARV   0x00000080  // MMAR is valid
-#define NVIC_FAULT_STAT_MSTKE   0x00000010  // Stack access violation
-#define NVIC_FAULT_STAT_MUSTKE  0x00000008  // Unstack access violation
-#define NVIC_FAULT_STAT_DERR    0x00000002  // Data access violation
-#define NVIC_FAULT_STAT_IERR    0x00000001  // Instruction access violation
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_HFAULT_STAT
-// register.
-//
-//*****************************************************************************
-#define NVIC_HFAULT_STAT_DBG    0x80000000  // Debug event
-#define NVIC_HFAULT_STAT_FORCED 0x40000000  // Cannot execute fault handler
-#define NVIC_HFAULT_STAT_VECT   0x00000002  // Vector table read fault
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_DEBUG_STAT
-// register.
-//
-//*****************************************************************************
-#define NVIC_DEBUG_STAT_EXTRNL  0x00000010  // EDBGRQ asserted
-#define NVIC_DEBUG_STAT_VCATCH  0x00000008  // Vector catch
-#define NVIC_DEBUG_STAT_DWTTRAP 0x00000004  // DWT match
-#define NVIC_DEBUG_STAT_BKPT    0x00000002  // Breakpoint instruction
-#define NVIC_DEBUG_STAT_HALTED  0x00000001  // Halt request
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_MM_ADDR register.
-//
-//*****************************************************************************
-#define NVIC_MM_ADDR_M          0xFFFFFFFF  // Data fault address
-#define NVIC_MM_ADDR_S          0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_FAULT_ADDR
-// register.
-//
-//*****************************************************************************
-#define NVIC_FAULT_ADDR_M       0xFFFFFFFF  // Data bus fault address
-#define NVIC_FAULT_ADDR_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_MPU_TYPE register.
-//
-//*****************************************************************************
-#define NVIC_MPU_TYPE_IREGION_M 0x00FF0000  // Number of I regions
-#define NVIC_MPU_TYPE_DREGION_M 0x0000FF00  // Number of D regions
-#define NVIC_MPU_TYPE_SEPARATE  0x00000001  // Separate or unified MPU
-#define NVIC_MPU_TYPE_IREGION_S 16
-#define NVIC_MPU_TYPE_DREGION_S 8
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_MPU_CTRL register.
-//
-//*****************************************************************************
-#define NVIC_MPU_CTRL_PRIVDEFEN 0x00000004  // MPU default region in priv mode
-#define NVIC_MPU_CTRL_HFNMIENA  0x00000002  // MPU enabled during faults
-#define NVIC_MPU_CTRL_ENABLE    0x00000001  // MPU enable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_MPU_NUMBER
-// register.
-//
-//*****************************************************************************
-#define NVIC_MPU_NUMBER_M       0x000000FF  // MPU region to access
-#define NVIC_MPU_NUMBER_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_MPU_BASE register.
-//
-//*****************************************************************************
-#define NVIC_MPU_BASE_ADDR_M    0xFFFFFFE0  // Base address mask
-#define NVIC_MPU_BASE_VALID     0x00000010  // Region number valid
-#define NVIC_MPU_BASE_REGION_M  0x0000000F  // Region number
-#define NVIC_MPU_BASE_ADDR_S    8
-#define NVIC_MPU_BASE_REGION_S  0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_MPU_ATTR register.
-//
-//*****************************************************************************
-#define NVIC_MPU_ATTR_M         0xFFFF0000  // Attributes
-#define NVIC_MPU_ATTR_AP_NO_NO  0x00000000  // prv: no access, usr: no access
-#define NVIC_MPU_ATTR_BUFFRABLE 0x00010000  // Bufferable
-#define NVIC_MPU_ATTR_CACHEABLE 0x00020000  // Cacheable
-#define NVIC_MPU_ATTR_SHAREABLE 0x00040000  // Shareable
-#define NVIC_MPU_ATTR_TEX_M     0x00380000  // Type extension mask
-#define NVIC_MPU_ATTR_AP_RW_NO  0x01000000  // prv: rw, usr: none
-#define NVIC_MPU_ATTR_AP_RW_RO  0x02000000  // prv: rw, usr: read-only
-#define NVIC_MPU_ATTR_AP_RW_RW  0x03000000  // prv: rw, usr: rw
-#define NVIC_MPU_ATTR_AP_RO_NO  0x05000000  // prv: ro, usr: none
-#define NVIC_MPU_ATTR_AP_RO_RO  0x06000000  // prv: ro, usr: ro
-#define NVIC_MPU_ATTR_AP_M      0x07000000  // Access permissions mask
-#define NVIC_MPU_ATTR_XN        0x10000000  // Execute disable
-#define NVIC_MPU_ATTR_SRD_M     0x0000FF00  // Sub-region disable mask
-#define NVIC_MPU_ATTR_SRD_0     0x00000100  // Sub-region 0 disable
-#define NVIC_MPU_ATTR_SRD_1     0x00000200  // Sub-region 1 disable
-#define NVIC_MPU_ATTR_SRD_2     0x00000400  // Sub-region 2 disable
-#define NVIC_MPU_ATTR_SRD_3     0x00000800  // Sub-region 3 disable
-#define NVIC_MPU_ATTR_SRD_4     0x00001000  // Sub-region 4 disable
-#define NVIC_MPU_ATTR_SRD_5     0x00002000  // Sub-region 5 disable
-#define NVIC_MPU_ATTR_SRD_6     0x00004000  // Sub-region 6 disable
-#define NVIC_MPU_ATTR_SRD_7     0x00008000  // Sub-region 7 disable
-#define NVIC_MPU_ATTR_SIZE_M    0x0000003E  // Region size mask
-#define NVIC_MPU_ATTR_SIZE_32B  0x00000008  // Region size 32 bytes
-#define NVIC_MPU_ATTR_SIZE_64B  0x0000000A  // Region size 64 bytes
-#define NVIC_MPU_ATTR_SIZE_128B 0x0000000C  // Region size 128 bytes
-#define NVIC_MPU_ATTR_SIZE_256B 0x0000000E  // Region size 256 bytes
-#define NVIC_MPU_ATTR_SIZE_512B 0x00000010  // Region size 512 bytes
-#define NVIC_MPU_ATTR_SIZE_1K   0x00000012  // Region size 1 Kbytes
-#define NVIC_MPU_ATTR_SIZE_2K   0x00000014  // Region size 2 Kbytes
-#define NVIC_MPU_ATTR_SIZE_4K   0x00000016  // Region size 4 Kbytes
-#define NVIC_MPU_ATTR_SIZE_8K   0x00000018  // Region size 8 Kbytes
-#define NVIC_MPU_ATTR_SIZE_16K  0x0000001A  // Region size 16 Kbytes
-#define NVIC_MPU_ATTR_SIZE_32K  0x0000001C  // Region size 32 Kbytes
-#define NVIC_MPU_ATTR_SIZE_64K  0x0000001E  // Region size 64 Kbytes
-#define NVIC_MPU_ATTR_SIZE_128K 0x00000020  // Region size 128 Kbytes
-#define NVIC_MPU_ATTR_SIZE_256K 0x00000022  // Region size 256 Kbytes
-#define NVIC_MPU_ATTR_SIZE_512K 0x00000024  // Region size 512 Kbytes
-#define NVIC_MPU_ATTR_SIZE_1M   0x00000026  // Region size 1 Mbytes
-#define NVIC_MPU_ATTR_SIZE_2M   0x00000028  // Region size 2 Mbytes
-#define NVIC_MPU_ATTR_SIZE_4M   0x0000002A  // Region size 4 Mbytes
-#define NVIC_MPU_ATTR_SIZE_8M   0x0000002C  // Region size 8 Mbytes
-#define NVIC_MPU_ATTR_SIZE_16M  0x0000002E  // Region size 16 Mbytes
-#define NVIC_MPU_ATTR_SIZE_32M  0x00000030  // Region size 32 Mbytes
-#define NVIC_MPU_ATTR_SIZE_64M  0x00000032  // Region size 64 Mbytes
-#define NVIC_MPU_ATTR_SIZE_128M 0x00000034  // Region size 128 Mbytes
-#define NVIC_MPU_ATTR_SIZE_256M 0x00000036  // Region size 256 Mbytes
-#define NVIC_MPU_ATTR_SIZE_512M 0x00000038  // Region size 512 Mbytes
-#define NVIC_MPU_ATTR_SIZE_1G   0x0000003A  // Region size 1 Gbytes
-#define NVIC_MPU_ATTR_SIZE_2G   0x0000003C  // Region size 2 Gbytes
-#define NVIC_MPU_ATTR_SIZE_4G   0x0000003E  // Region size 4 Gbytes
-#define NVIC_MPU_ATTR_ENABLE    0x00000001  // Region enable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_DBG_CTRL register.
-//
-//*****************************************************************************
-#define NVIC_DBG_CTRL_DBGKEY_M  0xFFFF0000  // Debug key mask
-#define NVIC_DBG_CTRL_DBGKEY    0xA05F0000  // Debug key
-#define NVIC_DBG_CTRL_S_RESET_ST \
-                                0x02000000  // Core has reset since last read
-#define NVIC_DBG_CTRL_S_RETIRE_ST \
-                                0x01000000  // Core has executed insruction
-                                            // since last read
-#define NVIC_DBG_CTRL_S_LOCKUP  0x00080000  // Core is locked up
-#define NVIC_DBG_CTRL_S_SLEEP   0x00040000  // Core is sleeping
-#define NVIC_DBG_CTRL_S_HALT    0x00020000  // Core status on halt
-#define NVIC_DBG_CTRL_S_REGRDY  0x00010000  // Register read/write available
-#define NVIC_DBG_CTRL_C_SNAPSTALL \
-                                0x00000020  // Breaks a stalled load/store
-#define NVIC_DBG_CTRL_C_MASKINT 0x00000008  // Mask interrupts when stepping
-#define NVIC_DBG_CTRL_C_STEP    0x00000004  // Step the core
-#define NVIC_DBG_CTRL_C_HALT    0x00000002  // Halt the core
-#define NVIC_DBG_CTRL_C_DEBUGEN 0x00000001  // Enable debug
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_DBG_XFER register.
-//
-//*****************************************************************************
-#define NVIC_DBG_XFER_REG_WNR   0x00010000  // Write or not read
-#define NVIC_DBG_XFER_REG_SEL_M 0x0000001F  // Register
-#define NVIC_DBG_XFER_REG_CFBP  0x00000014  // Control/Fault/BasePri/PriMask
-#define NVIC_DBG_XFER_REG_DSP   0x00000013  // Deep SP
-#define NVIC_DBG_XFER_REG_PSP   0x00000012  // Process SP
-#define NVIC_DBG_XFER_REG_MSP   0x00000011  // Main SP
-#define NVIC_DBG_XFER_REG_FLAGS 0x00000010  // xPSR/Flags register
-#define NVIC_DBG_XFER_REG_R15   0x0000000F  // Register R15
-#define NVIC_DBG_XFER_REG_R14   0x0000000E  // Register R14
-#define NVIC_DBG_XFER_REG_R13   0x0000000D  // Register R13
-#define NVIC_DBG_XFER_REG_R12   0x0000000C  // Register R12
-#define NVIC_DBG_XFER_REG_R11   0x0000000B  // Register R11
-#define NVIC_DBG_XFER_REG_R10   0x0000000A  // Register R10
-#define NVIC_DBG_XFER_REG_R9    0x00000009  // Register R9
-#define NVIC_DBG_XFER_REG_R8    0x00000008  // Register R8
-#define NVIC_DBG_XFER_REG_R7    0x00000007  // Register R7
-#define NVIC_DBG_XFER_REG_R6    0x00000006  // Register R6
-#define NVIC_DBG_XFER_REG_R5    0x00000005  // Register R5
-#define NVIC_DBG_XFER_REG_R4    0x00000004  // Register R4
-#define NVIC_DBG_XFER_REG_R3    0x00000003  // Register R3
-#define NVIC_DBG_XFER_REG_R2    0x00000002  // Register R2
-#define NVIC_DBG_XFER_REG_R1    0x00000001  // Register R1
-#define NVIC_DBG_XFER_REG_R0    0x00000000  // Register R0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_DBG_DATA register.
-//
-//*****************************************************************************
-#define NVIC_DBG_DATA_M         0xFFFFFFFF  // Data temporary cache
-#define NVIC_DBG_DATA_S         0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_DBG_INT register.
-//
-//*****************************************************************************
-#define NVIC_DBG_INT_HARDERR    0x00000400  // Debug trap on hard fault
-#define NVIC_DBG_INT_INTERR     0x00000200  // Debug trap on interrupt errors
-#define NVIC_DBG_INT_BUSERR     0x00000100  // Debug trap on bus error
-#define NVIC_DBG_INT_STATERR    0x00000080  // Debug trap on usage fault state
-#define NVIC_DBG_INT_CHKERR     0x00000040  // Debug trap on usage fault check
-#define NVIC_DBG_INT_NOCPERR    0x00000020  // Debug trap on coprocessor error
-#define NVIC_DBG_INT_MMERR      0x00000010  // Debug trap on mem manage fault
-#define NVIC_DBG_INT_RESET      0x00000008  // Core reset status
-#define NVIC_DBG_INT_RSTPENDCLR 0x00000004  // Clear pending core reset
-#define NVIC_DBG_INT_RSTPENDING 0x00000002  // Core reset is pending
-#define NVIC_DBG_INT_RSTVCATCH  0x00000001  // Reset vector catch
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the NVIC_SW_TRIG register.
-//
-//*****************************************************************************
-#define NVIC_SW_TRIG_INTID_M    0x000003FF  // Interrupt to trigger
-#define NVIC_SW_TRIG_INTID_S    0
-
-#endif // __HW_NVIC_H__
+//*****************************************************************************
+//
+// hw_nvic.h - Macros used when accessing the NVIC hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_NVIC_H__
+#define __HW_NVIC_H__
+
+//*****************************************************************************
+//
+// The following are defines for the NVIC register addresses.
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE           0xE000E004  // Interrupt Controller Type Reg.
+#define NVIC_ST_CTRL            0xE000E010  // SysTick Control and Status Reg.
+#define NVIC_ST_RELOAD          0xE000E014  // SysTick Reload Value Register
+#define NVIC_ST_CURRENT         0xE000E018  // SysTick Current Value Register
+#define NVIC_ST_CAL             0xE000E01C  // SysTick Calibration Value Reg.
+#define NVIC_EN0                0xE000E100  // IRQ 0 to 31 Set Enable Register
+#define NVIC_EN1                0xE000E104  // IRQ 32 to 63 Set Enable Register
+#define NVIC_DIS0               0xE000E180  // IRQ 0 to 31 Clear Enable Reg.
+#define NVIC_DIS1               0xE000E184  // IRQ 32 to 63 Clear Enable Reg.
+#define NVIC_PEND0              0xE000E200  // IRQ 0 to 31 Set Pending Register
+#define NVIC_PEND1              0xE000E204  // IRQ 32 to 63 Set Pending Reg.
+#define NVIC_UNPEND0            0xE000E280  // IRQ 0 to 31 Clear Pending Reg.
+#define NVIC_UNPEND1            0xE000E284  // IRQ 32 to 63 Clear Pending Reg.
+#define NVIC_ACTIVE0            0xE000E300  // IRQ 0 to 31 Active Register
+#define NVIC_ACTIVE1            0xE000E304  // IRQ 32 to 63 Active Register
+#define NVIC_PRI0               0xE000E400  // IRQ 0 to 3 Priority Register
+#define NVIC_PRI1               0xE000E404  // IRQ 4 to 7 Priority Register
+#define NVIC_PRI2               0xE000E408  // IRQ 8 to 11 Priority Register
+#define NVIC_PRI3               0xE000E40C  // IRQ 12 to 15 Priority Register
+#define NVIC_PRI4               0xE000E410  // IRQ 16 to 19 Priority Register
+#define NVIC_PRI5               0xE000E414  // IRQ 20 to 23 Priority Register
+#define NVIC_PRI6               0xE000E418  // IRQ 24 to 27 Priority Register
+#define NVIC_PRI7               0xE000E41C  // IRQ 28 to 31 Priority Register
+#define NVIC_PRI8               0xE000E420  // IRQ 32 to 35 Priority Register
+#define NVIC_PRI9               0xE000E424  // IRQ 36 to 39 Priority Register
+#define NVIC_PRI10              0xE000E428  // IRQ 40 to 43 Priority Register
+#define NVIC_PRI11              0xE000E42C  // IRQ 44 to 47 Priority Register
+#define NVIC_PRI12              0xE000E430  // IRQ 48 to 51 Priority Register
+#define NVIC_PRI13              0xE000E434  // IRQ 52 to 55 Priority Register
+#define NVIC_CPUID              0xE000ED00  // CPUID Base Register
+#define NVIC_INT_CTRL           0xE000ED04  // Interrupt Control State Register
+#define NVIC_VTABLE             0xE000ED08  // Vector Table Offset Register
+#define NVIC_APINT              0xE000ED0C  // App. Int &amp; Reset Control Reg.
+#define NVIC_SYS_CTRL           0xE000ED10  // System Control Register
+#define NVIC_CFG_CTRL           0xE000ED14  // Configuration Control Register
+#define NVIC_SYS_PRI1           0xE000ED18  // Sys. Handlers 4 to 7 Priority
+#define NVIC_SYS_PRI2           0xE000ED1C  // Sys. Handlers 8 to 11 Priority
+#define NVIC_SYS_PRI3           0xE000ED20  // Sys. Handlers 12 to 15 Priority
+#define NVIC_SYS_HND_CTRL       0xE000ED24  // System Handler Control and State
+#define NVIC_FAULT_STAT         0xE000ED28  // Configurable Fault Status Reg.
+#define NVIC_HFAULT_STAT        0xE000ED2C  // Hard Fault Status Register
+#define NVIC_DEBUG_STAT         0xE000ED30  // Debug Status Register
+#define NVIC_MM_ADDR            0xE000ED34  // Mem Manage Address Register
+#define NVIC_FAULT_ADDR         0xE000ED38  // Bus Fault Address Register
+#define NVIC_MPU_TYPE           0xE000ED90  // MPU Type Register
+#define NVIC_MPU_CTRL           0xE000ED94  // MPU Control Register
+#define NVIC_MPU_NUMBER         0xE000ED98  // MPU Region Number Register
+#define NVIC_MPU_BASE           0xE000ED9C  // MPU Region Base Address Register
+#define NVIC_MPU_ATTR           0xE000EDA0  // MPU Region Attribute &amp; Size Reg.
+#define NVIC_DBG_CTRL           0xE000EDF0  // Debug Control and Status Reg.
+#define NVIC_DBG_XFER           0xE000EDF4  // Debug Core Reg. Transfer Select
+#define NVIC_DBG_DATA           0xE000EDF8  // Debug Core Register Data
+#define NVIC_DBG_INT            0xE000EDFC  // Debug Reset Interrupt Control
+#define NVIC_SW_TRIG            0xE000EF00  // Software Trigger Interrupt Reg.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_LINES_M   0x0000001F  // Number of interrupt lines (x32)
+#define NVIC_INT_TYPE_LINES_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CTRL_COUNT      0x00010000  // Count flag
+#define NVIC_ST_CTRL_CLK_SRC    0x00000004  // Clock Source
+#define NVIC_ST_CTRL_INTEN      0x00000002  // Interrupt enable
+#define NVIC_ST_CTRL_ENABLE     0x00000001  // Counter mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_RELOAD register.
+//
+//*****************************************************************************
+#define NVIC_ST_RELOAD_M        0x00FFFFFF  // Counter load value
+#define NVIC_ST_RELOAD_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CURRENT
+// register.
+//
+//*****************************************************************************
+#define NVIC_ST_CURRENT_M       0x00FFFFFF  // Counter current value
+#define NVIC_ST_CURRENT_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CAL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CAL_NOREF       0x80000000  // No reference clock
+#define NVIC_ST_CAL_SKEW        0x40000000  // Clock skew
+#define NVIC_ST_CAL_ONEMS_M     0x00FFFFFF  // 1ms reference value
+#define NVIC_ST_CAL_ONEMS_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN0 register.
+//
+//*****************************************************************************
+#define NVIC_EN0_INT31          0x80000000  // Interrupt 31 enable
+#define NVIC_EN0_INT30          0x40000000  // Interrupt 30 enable
+#define NVIC_EN0_INT29          0x20000000  // Interrupt 29 enable
+#define NVIC_EN0_INT28          0x10000000  // Interrupt 28 enable
+#define NVIC_EN0_INT27          0x08000000  // Interrupt 27 enable
+#define NVIC_EN0_INT26          0x04000000  // Interrupt 26 enable
+#define NVIC_EN0_INT25          0x02000000  // Interrupt 25 enable
+#define NVIC_EN0_INT24          0x01000000  // Interrupt 24 enable
+#define NVIC_EN0_INT23          0x00800000  // Interrupt 23 enable
+#define NVIC_EN0_INT22          0x00400000  // Interrupt 22 enable
+#define NVIC_EN0_INT21          0x00200000  // Interrupt 21 enable
+#define NVIC_EN0_INT20          0x00100000  // Interrupt 20 enable
+#define NVIC_EN0_INT19          0x00080000  // Interrupt 19 enable
+#define NVIC_EN0_INT18          0x00040000  // Interrupt 18 enable
+#define NVIC_EN0_INT17          0x00020000  // Interrupt 17 enable
+#define NVIC_EN0_INT16          0x00010000  // Interrupt 16 enable
+#define NVIC_EN0_INT15          0x00008000  // Interrupt 15 enable
+#define NVIC_EN0_INT14          0x00004000  // Interrupt 14 enable
+#define NVIC_EN0_INT13          0x00002000  // Interrupt 13 enable
+#define NVIC_EN0_INT12          0x00001000  // Interrupt 12 enable
+#define NVIC_EN0_INT11          0x00000800  // Interrupt 11 enable
+#define NVIC_EN0_INT10          0x00000400  // Interrupt 10 enable
+#define NVIC_EN0_INT9           0x00000200  // Interrupt 9 enable
+#define NVIC_EN0_INT8           0x00000100  // Interrupt 8 enable
+#define NVIC_EN0_INT7           0x00000080  // Interrupt 7 enable
+#define NVIC_EN0_INT6           0x00000040  // Interrupt 6 enable
+#define NVIC_EN0_INT5           0x00000020  // Interrupt 5 enable
+#define NVIC_EN0_INT4           0x00000010  // Interrupt 4 enable
+#define NVIC_EN0_INT3           0x00000008  // Interrupt 3 enable
+#define NVIC_EN0_INT2           0x00000004  // Interrupt 2 enable
+#define NVIC_EN0_INT1           0x00000002  // Interrupt 1 enable
+#define NVIC_EN0_INT0           0x00000001  // Interrupt 0 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN1 register.
+//
+//*****************************************************************************
+#define NVIC_EN1_INT59          0x08000000  // Interrupt 59 enable
+#define NVIC_EN1_INT58          0x04000000  // Interrupt 58 enable
+#define NVIC_EN1_INT57          0x02000000  // Interrupt 57 enable
+#define NVIC_EN1_INT56          0x01000000  // Interrupt 56 enable
+#define NVIC_EN1_INT55          0x00800000  // Interrupt 55 enable
+#define NVIC_EN1_INT54          0x00400000  // Interrupt 54 enable
+#define NVIC_EN1_INT53          0x00200000  // Interrupt 53 enable
+#define NVIC_EN1_INT52          0x00100000  // Interrupt 52 enable
+#define NVIC_EN1_INT51          0x00080000  // Interrupt 51 enable
+#define NVIC_EN1_INT50          0x00040000  // Interrupt 50 enable
+#define NVIC_EN1_INT49          0x00020000  // Interrupt 49 enable
+#define NVIC_EN1_INT48          0x00010000  // Interrupt 48 enable
+#define NVIC_EN1_INT47          0x00008000  // Interrupt 47 enable
+#define NVIC_EN1_INT46          0x00004000  // Interrupt 46 enable
+#define NVIC_EN1_INT45          0x00002000  // Interrupt 45 enable
+#define NVIC_EN1_INT44          0x00001000  // Interrupt 44 enable
+#define NVIC_EN1_INT43          0x00000800  // Interrupt 43 enable
+#define NVIC_EN1_INT42          0x00000400  // Interrupt 42 enable
+#define NVIC_EN1_INT41          0x00000200  // Interrupt 41 enable
+#define NVIC_EN1_INT40          0x00000100  // Interrupt 40 enable
+#define NVIC_EN1_INT39          0x00000080  // Interrupt 39 enable
+#define NVIC_EN1_INT38          0x00000040  // Interrupt 38 enable
+#define NVIC_EN1_INT37          0x00000020  // Interrupt 37 enable
+#define NVIC_EN1_INT36          0x00000010  // Interrupt 36 enable
+#define NVIC_EN1_INT35          0x00000008  // Interrupt 35 enable
+#define NVIC_EN1_INT34          0x00000004  // Interrupt 34 enable
+#define NVIC_EN1_INT33          0x00000002  // Interrupt 33 enable
+#define NVIC_EN1_INT32          0x00000001  // Interrupt 32 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS0 register.
+//
+//*****************************************************************************
+#define NVIC_DIS0_INT31         0x80000000  // Interrupt 31 disable
+#define NVIC_DIS0_INT30         0x40000000  // Interrupt 30 disable
+#define NVIC_DIS0_INT29         0x20000000  // Interrupt 29 disable
+#define NVIC_DIS0_INT28         0x10000000  // Interrupt 28 disable
+#define NVIC_DIS0_INT27         0x08000000  // Interrupt 27 disable
+#define NVIC_DIS0_INT26         0x04000000  // Interrupt 26 disable
+#define NVIC_DIS0_INT25         0x02000000  // Interrupt 25 disable
+#define NVIC_DIS0_INT24         0x01000000  // Interrupt 24 disable
+#define NVIC_DIS0_INT23         0x00800000  // Interrupt 23 disable
+#define NVIC_DIS0_INT22         0x00400000  // Interrupt 22 disable
+#define NVIC_DIS0_INT21         0x00200000  // Interrupt 21 disable
+#define NVIC_DIS0_INT20         0x00100000  // Interrupt 20 disable
+#define NVIC_DIS0_INT19         0x00080000  // Interrupt 19 disable
+#define NVIC_DIS0_INT18         0x00040000  // Interrupt 18 disable
+#define NVIC_DIS0_INT17         0x00020000  // Interrupt 17 disable
+#define NVIC_DIS0_INT16         0x00010000  // Interrupt 16 disable
+#define NVIC_DIS0_INT15         0x00008000  // Interrupt 15 disable
+#define NVIC_DIS0_INT14         0x00004000  // Interrupt 14 disable
+#define NVIC_DIS0_INT13         0x00002000  // Interrupt 13 disable
+#define NVIC_DIS0_INT12         0x00001000  // Interrupt 12 disable
+#define NVIC_DIS0_INT11         0x00000800  // Interrupt 11 disable
+#define NVIC_DIS0_INT10         0x00000400  // Interrupt 10 disable
+#define NVIC_DIS0_INT9          0x00000200  // Interrupt 9 disable
+#define NVIC_DIS0_INT8          0x00000100  // Interrupt 8 disable
+#define NVIC_DIS0_INT7          0x00000080  // Interrupt 7 disable
+#define NVIC_DIS0_INT6          0x00000040  // Interrupt 6 disable
+#define NVIC_DIS0_INT5          0x00000020  // Interrupt 5 disable
+#define NVIC_DIS0_INT4          0x00000010  // Interrupt 4 disable
+#define NVIC_DIS0_INT3          0x00000008  // Interrupt 3 disable
+#define NVIC_DIS0_INT2          0x00000004  // Interrupt 2 disable
+#define NVIC_DIS0_INT1          0x00000002  // Interrupt 1 disable
+#define NVIC_DIS0_INT0          0x00000001  // Interrupt 0 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS1 register.
+//
+//*****************************************************************************
+#define NVIC_DIS1_INT59         0x08000000  // Interrupt 59 disable
+#define NVIC_DIS1_INT58         0x04000000  // Interrupt 58 disable
+#define NVIC_DIS1_INT57         0x02000000  // Interrupt 57 disable
+#define NVIC_DIS1_INT56         0x01000000  // Interrupt 56 disable
+#define NVIC_DIS1_INT55         0x00800000  // Interrupt 55 disable
+#define NVIC_DIS1_INT54         0x00400000  // Interrupt 54 disable
+#define NVIC_DIS1_INT53         0x00200000  // Interrupt 53 disable
+#define NVIC_DIS1_INT52         0x00100000  // Interrupt 52 disable
+#define NVIC_DIS1_INT51         0x00080000  // Interrupt 51 disable
+#define NVIC_DIS1_INT50         0x00040000  // Interrupt 50 disable
+#define NVIC_DIS1_INT49         0x00020000  // Interrupt 49 disable
+#define NVIC_DIS1_INT48         0x00010000  // Interrupt 48 disable
+#define NVIC_DIS1_INT47         0x00008000  // Interrupt 47 disable
+#define NVIC_DIS1_INT46         0x00004000  // Interrupt 46 disable
+#define NVIC_DIS1_INT45         0x00002000  // Interrupt 45 disable
+#define NVIC_DIS1_INT44         0x00001000  // Interrupt 44 disable
+#define NVIC_DIS1_INT43         0x00000800  // Interrupt 43 disable
+#define NVIC_DIS1_INT42         0x00000400  // Interrupt 42 disable
+#define NVIC_DIS1_INT41         0x00000200  // Interrupt 41 disable
+#define NVIC_DIS1_INT40         0x00000100  // Interrupt 40 disable
+#define NVIC_DIS1_INT39         0x00000080  // Interrupt 39 disable
+#define NVIC_DIS1_INT38         0x00000040  // Interrupt 38 disable
+#define NVIC_DIS1_INT37         0x00000020  // Interrupt 37 disable
+#define NVIC_DIS1_INT36         0x00000010  // Interrupt 36 disable
+#define NVIC_DIS1_INT35         0x00000008  // Interrupt 35 disable
+#define NVIC_DIS1_INT34         0x00000004  // Interrupt 34 disable
+#define NVIC_DIS1_INT33         0x00000002  // Interrupt 33 disable
+#define NVIC_DIS1_INT32         0x00000001  // Interrupt 32 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND0 register.
+//
+//*****************************************************************************
+#define NVIC_PEND0_INT31        0x80000000  // Interrupt 31 pend
+#define NVIC_PEND0_INT30        0x40000000  // Interrupt 30 pend
+#define NVIC_PEND0_INT29        0x20000000  // Interrupt 29 pend
+#define NVIC_PEND0_INT28        0x10000000  // Interrupt 28 pend
+#define NVIC_PEND0_INT27        0x08000000  // Interrupt 27 pend
+#define NVIC_PEND0_INT26        0x04000000  // Interrupt 26 pend
+#define NVIC_PEND0_INT25        0x02000000  // Interrupt 25 pend
+#define NVIC_PEND0_INT24        0x01000000  // Interrupt 24 pend
+#define NVIC_PEND0_INT23        0x00800000  // Interrupt 23 pend
+#define NVIC_PEND0_INT22        0x00400000  // Interrupt 22 pend
+#define NVIC_PEND0_INT21        0x00200000  // Interrupt 21 pend
+#define NVIC_PEND0_INT20        0x00100000  // Interrupt 20 pend
+#define NVIC_PEND0_INT19        0x00080000  // Interrupt 19 pend
+#define NVIC_PEND0_INT18        0x00040000  // Interrupt 18 pend
+#define NVIC_PEND0_INT17        0x00020000  // Interrupt 17 pend
+#define NVIC_PEND0_INT16        0x00010000  // Interrupt 16 pend
+#define NVIC_PEND0_INT15        0x00008000  // Interrupt 15 pend
+#define NVIC_PEND0_INT14        0x00004000  // Interrupt 14 pend
+#define NVIC_PEND0_INT13        0x00002000  // Interrupt 13 pend
+#define NVIC_PEND0_INT12        0x00001000  // Interrupt 12 pend
+#define NVIC_PEND0_INT11        0x00000800  // Interrupt 11 pend
+#define NVIC_PEND0_INT10        0x00000400  // Interrupt 10 pend
+#define NVIC_PEND0_INT9         0x00000200  // Interrupt 9 pend
+#define NVIC_PEND0_INT8         0x00000100  // Interrupt 8 pend
+#define NVIC_PEND0_INT7         0x00000080  // Interrupt 7 pend
+#define NVIC_PEND0_INT6         0x00000040  // Interrupt 6 pend
+#define NVIC_PEND0_INT5         0x00000020  // Interrupt 5 pend
+#define NVIC_PEND0_INT4         0x00000010  // Interrupt 4 pend
+#define NVIC_PEND0_INT3         0x00000008  // Interrupt 3 pend
+#define NVIC_PEND0_INT2         0x00000004  // Interrupt 2 pend
+#define NVIC_PEND0_INT1         0x00000002  // Interrupt 1 pend
+#define NVIC_PEND0_INT0         0x00000001  // Interrupt 0 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND1 register.
+//
+//*****************************************************************************
+#define NVIC_PEND1_INT59        0x08000000  // Interrupt 59 pend
+#define NVIC_PEND1_INT58        0x04000000  // Interrupt 58 pend
+#define NVIC_PEND1_INT57        0x02000000  // Interrupt 57 pend
+#define NVIC_PEND1_INT56        0x01000000  // Interrupt 56 pend
+#define NVIC_PEND1_INT55        0x00800000  // Interrupt 55 pend
+#define NVIC_PEND1_INT54        0x00400000  // Interrupt 54 pend
+#define NVIC_PEND1_INT53        0x00200000  // Interrupt 53 pend
+#define NVIC_PEND1_INT52        0x00100000  // Interrupt 52 pend
+#define NVIC_PEND1_INT51        0x00080000  // Interrupt 51 pend
+#define NVIC_PEND1_INT50        0x00040000  // Interrupt 50 pend
+#define NVIC_PEND1_INT49        0x00020000  // Interrupt 49 pend
+#define NVIC_PEND1_INT48        0x00010000  // Interrupt 48 pend
+#define NVIC_PEND1_INT47        0x00008000  // Interrupt 47 pend
+#define NVIC_PEND1_INT46        0x00004000  // Interrupt 46 pend
+#define NVIC_PEND1_INT45        0x00002000  // Interrupt 45 pend
+#define NVIC_PEND1_INT44        0x00001000  // Interrupt 44 pend
+#define NVIC_PEND1_INT43        0x00000800  // Interrupt 43 pend
+#define NVIC_PEND1_INT42        0x00000400  // Interrupt 42 pend
+#define NVIC_PEND1_INT41        0x00000200  // Interrupt 41 pend
+#define NVIC_PEND1_INT40        0x00000100  // Interrupt 40 pend
+#define NVIC_PEND1_INT39        0x00000080  // Interrupt 39 pend
+#define NVIC_PEND1_INT38        0x00000040  // Interrupt 38 pend
+#define NVIC_PEND1_INT37        0x00000020  // Interrupt 37 pend
+#define NVIC_PEND1_INT36        0x00000010  // Interrupt 36 pend
+#define NVIC_PEND1_INT35        0x00000008  // Interrupt 35 pend
+#define NVIC_PEND1_INT34        0x00000004  // Interrupt 34 pend
+#define NVIC_PEND1_INT33        0x00000002  // Interrupt 33 pend
+#define NVIC_PEND1_INT32        0x00000001  // Interrupt 32 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND0 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND0_INT31      0x80000000  // Interrupt 31 unpend
+#define NVIC_UNPEND0_INT30      0x40000000  // Interrupt 30 unpend
+#define NVIC_UNPEND0_INT29      0x20000000  // Interrupt 29 unpend
+#define NVIC_UNPEND0_INT28      0x10000000  // Interrupt 28 unpend
+#define NVIC_UNPEND0_INT27      0x08000000  // Interrupt 27 unpend
+#define NVIC_UNPEND0_INT26      0x04000000  // Interrupt 26 unpend
+#define NVIC_UNPEND0_INT25      0x02000000  // Interrupt 25 unpend
+#define NVIC_UNPEND0_INT24      0x01000000  // Interrupt 24 unpend
+#define NVIC_UNPEND0_INT23      0x00800000  // Interrupt 23 unpend
+#define NVIC_UNPEND0_INT22      0x00400000  // Interrupt 22 unpend
+#define NVIC_UNPEND0_INT21      0x00200000  // Interrupt 21 unpend
+#define NVIC_UNPEND0_INT20      0x00100000  // Interrupt 20 unpend
+#define NVIC_UNPEND0_INT19      0x00080000  // Interrupt 19 unpend
+#define NVIC_UNPEND0_INT18      0x00040000  // Interrupt 18 unpend
+#define NVIC_UNPEND0_INT17      0x00020000  // Interrupt 17 unpend
+#define NVIC_UNPEND0_INT16      0x00010000  // Interrupt 16 unpend
+#define NVIC_UNPEND0_INT15      0x00008000  // Interrupt 15 unpend
+#define NVIC_UNPEND0_INT14      0x00004000  // Interrupt 14 unpend
+#define NVIC_UNPEND0_INT13      0x00002000  // Interrupt 13 unpend
+#define NVIC_UNPEND0_INT12      0x00001000  // Interrupt 12 unpend
+#define NVIC_UNPEND0_INT11      0x00000800  // Interrupt 11 unpend
+#define NVIC_UNPEND0_INT10      0x00000400  // Interrupt 10 unpend
+#define NVIC_UNPEND0_INT9       0x00000200  // Interrupt 9 unpend
+#define NVIC_UNPEND0_INT8       0x00000100  // Interrupt 8 unpend
+#define NVIC_UNPEND0_INT7       0x00000080  // Interrupt 7 unpend
+#define NVIC_UNPEND0_INT6       0x00000040  // Interrupt 6 unpend
+#define NVIC_UNPEND0_INT5       0x00000020  // Interrupt 5 unpend
+#define NVIC_UNPEND0_INT4       0x00000010  // Interrupt 4 unpend
+#define NVIC_UNPEND0_INT3       0x00000008  // Interrupt 3 unpend
+#define NVIC_UNPEND0_INT2       0x00000004  // Interrupt 2 unpend
+#define NVIC_UNPEND0_INT1       0x00000002  // Interrupt 1 unpend
+#define NVIC_UNPEND0_INT0       0x00000001  // Interrupt 0 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND1 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND1_INT59      0x08000000  // Interrupt 59 unpend
+#define NVIC_UNPEND1_INT58      0x04000000  // Interrupt 58 unpend
+#define NVIC_UNPEND1_INT57      0x02000000  // Interrupt 57 unpend
+#define NVIC_UNPEND1_INT56      0x01000000  // Interrupt 56 unpend
+#define NVIC_UNPEND1_INT55      0x00800000  // Interrupt 55 unpend
+#define NVIC_UNPEND1_INT54      0x00400000  // Interrupt 54 unpend
+#define NVIC_UNPEND1_INT53      0x00200000  // Interrupt 53 unpend
+#define NVIC_UNPEND1_INT52      0x00100000  // Interrupt 52 unpend
+#define NVIC_UNPEND1_INT51      0x00080000  // Interrupt 51 unpend
+#define NVIC_UNPEND1_INT50      0x00040000  // Interrupt 50 unpend
+#define NVIC_UNPEND1_INT49      0x00020000  // Interrupt 49 unpend
+#define NVIC_UNPEND1_INT48      0x00010000  // Interrupt 48 unpend
+#define NVIC_UNPEND1_INT47      0x00008000  // Interrupt 47 unpend
+#define NVIC_UNPEND1_INT46      0x00004000  // Interrupt 46 unpend
+#define NVIC_UNPEND1_INT45      0x00002000  // Interrupt 45 unpend
+#define NVIC_UNPEND1_INT44      0x00001000  // Interrupt 44 unpend
+#define NVIC_UNPEND1_INT43      0x00000800  // Interrupt 43 unpend
+#define NVIC_UNPEND1_INT42      0x00000400  // Interrupt 42 unpend
+#define NVIC_UNPEND1_INT41      0x00000200  // Interrupt 41 unpend
+#define NVIC_UNPEND1_INT40      0x00000100  // Interrupt 40 unpend
+#define NVIC_UNPEND1_INT39      0x00000080  // Interrupt 39 unpend
+#define NVIC_UNPEND1_INT38      0x00000040  // Interrupt 38 unpend
+#define NVIC_UNPEND1_INT37      0x00000020  // Interrupt 37 unpend
+#define NVIC_UNPEND1_INT36      0x00000010  // Interrupt 36 unpend
+#define NVIC_UNPEND1_INT35      0x00000008  // Interrupt 35 unpend
+#define NVIC_UNPEND1_INT34      0x00000004  // Interrupt 34 unpend
+#define NVIC_UNPEND1_INT33      0x00000002  // Interrupt 33 unpend
+#define NVIC_UNPEND1_INT32      0x00000001  // Interrupt 32 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE0 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE0_INT31      0x80000000  // Interrupt 31 active
+#define NVIC_ACTIVE0_INT30      0x40000000  // Interrupt 30 active
+#define NVIC_ACTIVE0_INT29      0x20000000  // Interrupt 29 active
+#define NVIC_ACTIVE0_INT28      0x10000000  // Interrupt 28 active
+#define NVIC_ACTIVE0_INT27      0x08000000  // Interrupt 27 active
+#define NVIC_ACTIVE0_INT26      0x04000000  // Interrupt 26 active
+#define NVIC_ACTIVE0_INT25      0x02000000  // Interrupt 25 active
+#define NVIC_ACTIVE0_INT24      0x01000000  // Interrupt 24 active
+#define NVIC_ACTIVE0_INT23      0x00800000  // Interrupt 23 active
+#define NVIC_ACTIVE0_INT22      0x00400000  // Interrupt 22 active
+#define NVIC_ACTIVE0_INT21      0x00200000  // Interrupt 21 active
+#define NVIC_ACTIVE0_INT20      0x00100000  // Interrupt 20 active
+#define NVIC_ACTIVE0_INT19      0x00080000  // Interrupt 19 active
+#define NVIC_ACTIVE0_INT18      0x00040000  // Interrupt 18 active
+#define NVIC_ACTIVE0_INT17      0x00020000  // Interrupt 17 active
+#define NVIC_ACTIVE0_INT16      0x00010000  // Interrupt 16 active
+#define NVIC_ACTIVE0_INT15      0x00008000  // Interrupt 15 active
+#define NVIC_ACTIVE0_INT14      0x00004000  // Interrupt 14 active
+#define NVIC_ACTIVE0_INT13      0x00002000  // Interrupt 13 active
+#define NVIC_ACTIVE0_INT12      0x00001000  // Interrupt 12 active
+#define NVIC_ACTIVE0_INT11      0x00000800  // Interrupt 11 active
+#define NVIC_ACTIVE0_INT10      0x00000400  // Interrupt 10 active
+#define NVIC_ACTIVE0_INT9       0x00000200  // Interrupt 9 active
+#define NVIC_ACTIVE0_INT8       0x00000100  // Interrupt 8 active
+#define NVIC_ACTIVE0_INT7       0x00000080  // Interrupt 7 active
+#define NVIC_ACTIVE0_INT6       0x00000040  // Interrupt 6 active
+#define NVIC_ACTIVE0_INT5       0x00000020  // Interrupt 5 active
+#define NVIC_ACTIVE0_INT4       0x00000010  // Interrupt 4 active
+#define NVIC_ACTIVE0_INT3       0x00000008  // Interrupt 3 active
+#define NVIC_ACTIVE0_INT2       0x00000004  // Interrupt 2 active
+#define NVIC_ACTIVE0_INT1       0x00000002  // Interrupt 1 active
+#define NVIC_ACTIVE0_INT0       0x00000001  // Interrupt 0 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE1 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE1_INT59      0x08000000  // Interrupt 59 active
+#define NVIC_ACTIVE1_INT58      0x04000000  // Interrupt 58 active
+#define NVIC_ACTIVE1_INT57      0x02000000  // Interrupt 57 active
+#define NVIC_ACTIVE1_INT56      0x01000000  // Interrupt 56 active
+#define NVIC_ACTIVE1_INT55      0x00800000  // Interrupt 55 active
+#define NVIC_ACTIVE1_INT54      0x00400000  // Interrupt 54 active
+#define NVIC_ACTIVE1_INT53      0x00200000  // Interrupt 53 active
+#define NVIC_ACTIVE1_INT52      0x00100000  // Interrupt 52 active
+#define NVIC_ACTIVE1_INT51      0x00080000  // Interrupt 51 active
+#define NVIC_ACTIVE1_INT50      0x00040000  // Interrupt 50 active
+#define NVIC_ACTIVE1_INT49      0x00020000  // Interrupt 49 active
+#define NVIC_ACTIVE1_INT48      0x00010000  // Interrupt 48 active
+#define NVIC_ACTIVE1_INT47      0x00008000  // Interrupt 47 active
+#define NVIC_ACTIVE1_INT46      0x00004000  // Interrupt 46 active
+#define NVIC_ACTIVE1_INT45      0x00002000  // Interrupt 45 active
+#define NVIC_ACTIVE1_INT44      0x00001000  // Interrupt 44 active
+#define NVIC_ACTIVE1_INT43      0x00000800  // Interrupt 43 active
+#define NVIC_ACTIVE1_INT42      0x00000400  // Interrupt 42 active
+#define NVIC_ACTIVE1_INT41      0x00000200  // Interrupt 41 active
+#define NVIC_ACTIVE1_INT40      0x00000100  // Interrupt 40 active
+#define NVIC_ACTIVE1_INT39      0x00000080  // Interrupt 39 active
+#define NVIC_ACTIVE1_INT38      0x00000040  // Interrupt 38 active
+#define NVIC_ACTIVE1_INT37      0x00000020  // Interrupt 37 active
+#define NVIC_ACTIVE1_INT36      0x00000010  // Interrupt 36 active
+#define NVIC_ACTIVE1_INT35      0x00000008  // Interrupt 35 active
+#define NVIC_ACTIVE1_INT34      0x00000004  // Interrupt 34 active
+#define NVIC_ACTIVE1_INT33      0x00000002  // Interrupt 33 active
+#define NVIC_ACTIVE1_INT32      0x00000001  // Interrupt 32 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI0 register.
+//
+//*****************************************************************************
+#define NVIC_PRI0_INT3_M        0xFF000000  // Interrupt 3 priority mask
+#define NVIC_PRI0_INT2_M        0x00FF0000  // Interrupt 2 priority mask
+#define NVIC_PRI0_INT1_M        0x0000FF00  // Interrupt 1 priority mask
+#define NVIC_PRI0_INT0_M        0x000000FF  // Interrupt 0 priority mask
+#define NVIC_PRI0_INT3_S        24
+#define NVIC_PRI0_INT2_S        16
+#define NVIC_PRI0_INT1_S        8
+#define NVIC_PRI0_INT0_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_PRI1_INT7_M        0xFF000000  // Interrupt 7 priority mask
+#define NVIC_PRI1_INT6_M        0x00FF0000  // Interrupt 6 priority mask
+#define NVIC_PRI1_INT5_M        0x0000FF00  // Interrupt 5 priority mask
+#define NVIC_PRI1_INT4_M        0x000000FF  // Interrupt 4 priority mask
+#define NVIC_PRI1_INT7_S        24
+#define NVIC_PRI1_INT6_S        16
+#define NVIC_PRI1_INT5_S        8
+#define NVIC_PRI1_INT4_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_PRI2_INT11_M       0xFF000000  // Interrupt 11 priority mask
+#define NVIC_PRI2_INT10_M       0x00FF0000  // Interrupt 10 priority mask
+#define NVIC_PRI2_INT9_M        0x0000FF00  // Interrupt 9 priority mask
+#define NVIC_PRI2_INT8_M        0x000000FF  // Interrupt 8 priority mask
+#define NVIC_PRI2_INT11_S       24
+#define NVIC_PRI2_INT10_S       16
+#define NVIC_PRI2_INT9_S        8
+#define NVIC_PRI2_INT8_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_PRI3_INT15_M       0xFF000000  // Interrupt 15 priority mask
+#define NVIC_PRI3_INT14_M       0x00FF0000  // Interrupt 14 priority mask
+#define NVIC_PRI3_INT13_M       0x0000FF00  // Interrupt 13 priority mask
+#define NVIC_PRI3_INT12_M       0x000000FF  // Interrupt 12 priority mask
+#define NVIC_PRI3_INT15_S       24
+#define NVIC_PRI3_INT14_S       16
+#define NVIC_PRI3_INT13_S       8
+#define NVIC_PRI3_INT12_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI4 register.
+//
+//*****************************************************************************
+#define NVIC_PRI4_INT19_M       0xFF000000  // Interrupt 19 priority mask
+#define NVIC_PRI4_INT18_M       0x00FF0000  // Interrupt 18 priority mask
+#define NVIC_PRI4_INT17_M       0x0000FF00  // Interrupt 17 priority mask
+#define NVIC_PRI4_INT16_M       0x000000FF  // Interrupt 16 priority mask
+#define NVIC_PRI4_INT19_S       24
+#define NVIC_PRI4_INT18_S       16
+#define NVIC_PRI4_INT17_S       8
+#define NVIC_PRI4_INT16_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI5 register.
+//
+//*****************************************************************************
+#define NVIC_PRI5_INT23_M       0xFF000000  // Interrupt 23 priority mask
+#define NVIC_PRI5_INT22_M       0x00FF0000  // Interrupt 22 priority mask
+#define NVIC_PRI5_INT21_M       0x0000FF00  // Interrupt 21 priority mask
+#define NVIC_PRI5_INT20_M       0x000000FF  // Interrupt 20 priority mask
+#define NVIC_PRI5_INT23_S       24
+#define NVIC_PRI5_INT22_S       16
+#define NVIC_PRI5_INT21_S       8
+#define NVIC_PRI5_INT20_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI6 register.
+//
+//*****************************************************************************
+#define NVIC_PRI6_INT27_M       0xFF000000  // Interrupt 27 priority mask
+#define NVIC_PRI6_INT26_M       0x00FF0000  // Interrupt 26 priority mask
+#define NVIC_PRI6_INT25_M       0x0000FF00  // Interrupt 25 priority mask
+#define NVIC_PRI6_INT24_M       0x000000FF  // Interrupt 24 priority mask
+#define NVIC_PRI6_INT27_S       24
+#define NVIC_PRI6_INT26_S       16
+#define NVIC_PRI6_INT25_S       8
+#define NVIC_PRI6_INT24_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI7 register.
+//
+//*****************************************************************************
+#define NVIC_PRI7_INT31_M       0xFF000000  // Interrupt 31 priority mask
+#define NVIC_PRI7_INT30_M       0x00FF0000  // Interrupt 30 priority mask
+#define NVIC_PRI7_INT29_M       0x0000FF00  // Interrupt 29 priority mask
+#define NVIC_PRI7_INT28_M       0x000000FF  // Interrupt 28 priority mask
+#define NVIC_PRI7_INT31_S       24
+#define NVIC_PRI7_INT30_S       16
+#define NVIC_PRI7_INT29_S       8
+#define NVIC_PRI7_INT28_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI8 register.
+//
+//*****************************************************************************
+#define NVIC_PRI8_INT35_M       0xFF000000  // Interrupt 35 priority mask
+#define NVIC_PRI8_INT34_M       0x00FF0000  // Interrupt 34 priority mask
+#define NVIC_PRI8_INT33_M       0x0000FF00  // Interrupt 33 priority mask
+#define NVIC_PRI8_INT32_M       0x000000FF  // Interrupt 32 priority mask
+#define NVIC_PRI8_INT35_S       24
+#define NVIC_PRI8_INT34_S       16
+#define NVIC_PRI8_INT33_S       8
+#define NVIC_PRI8_INT32_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI9 register.
+//
+//*****************************************************************************
+#define NVIC_PRI9_INT39_M       0xFF000000  // Interrupt 39 priority mask
+#define NVIC_PRI9_INT38_M       0x00FF0000  // Interrupt 38 priority mask
+#define NVIC_PRI9_INT37_M       0x0000FF00  // Interrupt 37 priority mask
+#define NVIC_PRI9_INT36_M       0x000000FF  // Interrupt 36 priority mask
+#define NVIC_PRI9_INT39_S       24
+#define NVIC_PRI9_INT38_S       16
+#define NVIC_PRI9_INT37_S       8
+#define NVIC_PRI9_INT36_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI10 register.
+//
+//*****************************************************************************
+#define NVIC_PRI10_INT43_M      0xFF000000  // Interrupt 43 priority mask
+#define NVIC_PRI10_INT42_M      0x00FF0000  // Interrupt 42 priority mask
+#define NVIC_PRI10_INT41_M      0x0000FF00  // Interrupt 41 priority mask
+#define NVIC_PRI10_INT40_M      0x000000FF  // Interrupt 40 priority mask
+#define NVIC_PRI10_INT43_S      24
+#define NVIC_PRI10_INT42_S      16
+#define NVIC_PRI10_INT41_S      8
+#define NVIC_PRI10_INT40_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CPUID register.
+//
+//*****************************************************************************
+#define NVIC_CPUID_IMP_M        0xFF000000  // Implementer
+#define NVIC_CPUID_VAR_M        0x00F00000  // Variant
+#define NVIC_CPUID_PARTNO_M     0x0000FFF0  // Processor part number
+#define NVIC_CPUID_REV_M        0x0000000F  // Revision
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_INT_CTRL_NMI_SET   0x80000000  // Pend a NMI
+#define NVIC_INT_CTRL_PEND_SV   0x10000000  // Pend a PendSV
+#define NVIC_INT_CTRL_UNPEND_SV 0x08000000  // Unpend a PendSV
+#define NVIC_INT_CTRL_ISR_PRE   0x00800000  // Debug interrupt handling
+#define NVIC_INT_CTRL_ISR_PEND  0x00400000  // Debug interrupt pending
+#define NVIC_INT_CTRL_VEC_PEN_M 0x003FF000  // Highest pending exception
+#define NVIC_INT_CTRL_RET_BASE  0x00000800  // Return to base
+#define NVIC_INT_CTRL_VEC_ACT_M 0x000003FF  // Current active exception
+#define NVIC_INT_CTRL_VEC_PEN_S 12
+#define NVIC_INT_CTRL_VEC_ACT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_VTABLE register.
+//
+//*****************************************************************************
+#define NVIC_VTABLE_BASE        0x20000000  // Vector table base
+#define NVIC_VTABLE_OFFSET_M    0x1FFFFF00  // Vector table offset
+#define NVIC_VTABLE_OFFSET_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_APINT register.
+//
+//*****************************************************************************
+#define NVIC_APINT_VECTKEY_M    0xFFFF0000  // Vector key mask
+#define NVIC_APINT_VECTKEY      0x05FA0000  // Vector key
+#define NVIC_APINT_ENDIANESS    0x00008000  // Data endianess
+#define NVIC_APINT_PRIGROUP_M   0x00000700  // Priority group
+#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
+#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
+#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
+#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
+#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
+#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
+#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
+#define NVIC_APINT_SYSRESETREQ  0x00000004  // System reset request
+#define NVIC_APINT_VECT_CLR_ACT 0x00000002  // Clear active NMI/fault info
+#define NVIC_APINT_VECT_RESET   0x00000001  // System reset
+#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_SYS_CTRL_SEVONPEND 0x00000010  // Wakeup on pend
+#define NVIC_SYS_CTRL_SLEEPDEEP 0x00000004  // Deep sleep enable
+#define NVIC_SYS_CTRL_SLEEPEXIT 0x00000002  // Sleep on ISR exit
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CFG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_CFG_CTRL_BFHFNMIGN 0x00000100  // Ignore bus fault in NMI/fault
+#define NVIC_CFG_CTRL_DIV0      0x00000010  // Trap on divide by 0
+#define NVIC_CFG_CTRL_UNALIGNED 0x00000008  // Trap on unaligned access
+#define NVIC_CFG_CTRL_DEEP_PEND 0x00000004  // Allow deep interrupt trigger
+#define NVIC_CFG_CTRL_MAIN_PEND 0x00000002  // Allow main interrupt trigger
+#define NVIC_CFG_CTRL_BASE_THR  0x00000001  // Thread state control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI1_RES_M     0xFF000000  // Priority of reserved handler
+#define NVIC_SYS_PRI1_USAGE_M   0x00FF0000  // Priority of usage fault handler
+#define NVIC_SYS_PRI1_BUS_M     0x0000FF00  // Priority of bus fault handler
+#define NVIC_SYS_PRI1_MEM_M     0x000000FF  // Priority of mem manage handler
+#define NVIC_SYS_PRI1_USAGE_S   16
+#define NVIC_SYS_PRI1_BUS_S     8
+#define NVIC_SYS_PRI1_MEM_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI2_SVC_M     0xFF000000  // Priority of SVCall handler
+#define NVIC_SYS_PRI2_RES_M     0x00FFFFFF  // Priority of reserved handlers
+#define NVIC_SYS_PRI2_SVC_S     24
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI3_TICK_M    0xFF000000  // Priority of Sys Tick handler
+#define NVIC_SYS_PRI3_PENDSV_M  0x00FF0000  // Priority of PendSV handler
+#define NVIC_SYS_PRI3_RES_M     0x0000FF00  // Priority of reserved handler
+#define NVIC_SYS_PRI3_DEBUG_M   0x000000FF  // Priority of debug handler
+#define NVIC_SYS_PRI3_TICK_S    24
+#define NVIC_SYS_PRI3_PENDSV_S  16
+#define NVIC_SYS_PRI3_DEBUG_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_HND_CTRL
+// register.
+//
+//*****************************************************************************
+#define NVIC_SYS_HND_CTRL_USAGE 0x00040000  // Usage fault enable
+#define NVIC_SYS_HND_CTRL_BUS   0x00020000  // Bus fault enable
+#define NVIC_SYS_HND_CTRL_MEM   0x00010000  // Mem manage fault enable
+#define NVIC_SYS_HND_CTRL_SVC   0x00008000  // SVCall is pended
+#define NVIC_SYS_HND_CTRL_BUSP  0x00004000  // Bus fault is pended
+#define NVIC_SYS_HND_CTRL_TICK  0x00000800  // Sys tick is active
+#define NVIC_SYS_HND_CTRL_PNDSV 0x00000400  // PendSV is active
+#define NVIC_SYS_HND_CTRL_MON   0x00000100  // Monitor is active
+#define NVIC_SYS_HND_CTRL_SVCA  0x00000080  // SVCall is active
+#define NVIC_SYS_HND_CTRL_USGA  0x00000008  // Usage fault is active
+#define NVIC_SYS_HND_CTRL_BUSA  0x00000002  // Bus fault is active
+#define NVIC_SYS_HND_CTRL_MEMA  0x00000001  // Mem manage is active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_STAT_DIV0    0x02000000  // Divide by zero fault
+#define NVIC_FAULT_STAT_UNALIGN 0x01000000  // Unaligned access fault
+#define NVIC_FAULT_STAT_NOCP    0x00080000  // No coprocessor fault
+#define NVIC_FAULT_STAT_INVPC   0x00040000  // Invalid PC fault
+#define NVIC_FAULT_STAT_INVSTAT 0x00020000  // Invalid state fault
+#define NVIC_FAULT_STAT_UNDEF   0x00010000  // Undefined instruction fault
+#define NVIC_FAULT_STAT_BFARV   0x00008000  // BFAR is valid
+#define NVIC_FAULT_STAT_BSTKE   0x00001000  // Stack bus fault
+#define NVIC_FAULT_STAT_BUSTKE  0x00000800  // Unstack bus fault
+#define NVIC_FAULT_STAT_IMPRE   0x00000400  // Imprecise data bus error
+#define NVIC_FAULT_STAT_PRECISE 0x00000200  // Precise data bus error
+#define NVIC_FAULT_STAT_IBUS    0x00000100  // Instruction bus fault
+#define NVIC_FAULT_STAT_MMARV   0x00000080  // MMAR is valid
+#define NVIC_FAULT_STAT_MSTKE   0x00000010  // Stack access violation
+#define NVIC_FAULT_STAT_MUSTKE  0x00000008  // Unstack access violation
+#define NVIC_FAULT_STAT_DERR    0x00000002  // Data access violation
+#define NVIC_FAULT_STAT_IERR    0x00000001  // Instruction access violation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_HFAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_HFAULT_STAT_DBG    0x80000000  // Debug event
+#define NVIC_HFAULT_STAT_FORCED 0x40000000  // Cannot execute fault handler
+#define NVIC_HFAULT_STAT_VECT   0x00000002  // Vector table read fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DEBUG_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_DEBUG_STAT_EXTRNL  0x00000010  // EDBGRQ asserted
+#define NVIC_DEBUG_STAT_VCATCH  0x00000008  // Vector catch
+#define NVIC_DEBUG_STAT_DWTTRAP 0x00000004  // DWT match
+#define NVIC_DEBUG_STAT_BKPT    0x00000002  // Breakpoint instruction
+#define NVIC_DEBUG_STAT_HALTED  0x00000001  // Halt request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MM_ADDR register.
+//
+//*****************************************************************************
+#define NVIC_MM_ADDR_M          0xFFFFFFFF  // Data fault address
+#define NVIC_MM_ADDR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_ADDR
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_ADDR_M       0xFFFFFFFF  // Data bus fault address
+#define NVIC_FAULT_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_TYPE_IREGION_M 0x00FF0000  // Number of I regions
+#define NVIC_MPU_TYPE_DREGION_M 0x0000FF00  // Number of D regions
+#define NVIC_MPU_TYPE_SEPARATE  0x00000001  // Separate or unified MPU
+#define NVIC_MPU_TYPE_IREGION_S 16
+#define NVIC_MPU_TYPE_DREGION_S 8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_MPU_CTRL_PRIVDEFEN 0x00000004  // MPU default region in priv mode
+#define NVIC_MPU_CTRL_HFNMIENA  0x00000002  // MPU enabled during faults
+#define NVIC_MPU_CTRL_ENABLE    0x00000001  // MPU enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_NUMBER
+// register.
+//
+//*****************************************************************************
+#define NVIC_MPU_NUMBER_M       0x000000FF  // MPU region to access
+#define NVIC_MPU_NUMBER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE_ADDR_M    0xFFFFFFE0  // Base address mask
+#define NVIC_MPU_BASE_VALID     0x00000010  // Region number valid
+#define NVIC_MPU_BASE_REGION_M  0x0000000F  // Region number
+#define NVIC_MPU_BASE_ADDR_S    8
+#define NVIC_MPU_BASE_REGION_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR_M         0xFFFF0000  // Attributes
+#define NVIC_MPU_ATTR_AP_NO_NO  0x00000000  // prv: no access, usr: no access
+#define NVIC_MPU_ATTR_BUFFRABLE 0x00010000  // Bufferable
+#define NVIC_MPU_ATTR_CACHEABLE 0x00020000  // Cacheable
+#define NVIC_MPU_ATTR_SHAREABLE 0x00040000  // Shareable
+#define NVIC_MPU_ATTR_TEX_M     0x00380000  // Type extension mask
+#define NVIC_MPU_ATTR_AP_RW_NO  0x01000000  // prv: rw, usr: none
+#define NVIC_MPU_ATTR_AP_RW_RO  0x02000000  // prv: rw, usr: read-only
+#define NVIC_MPU_ATTR_AP_RW_RW  0x03000000  // prv: rw, usr: rw
+#define NVIC_MPU_ATTR_AP_RO_NO  0x05000000  // prv: ro, usr: none
+#define NVIC_MPU_ATTR_AP_RO_RO  0x06000000  // prv: ro, usr: ro
+#define NVIC_MPU_ATTR_AP_M      0x07000000  // Access permissions mask
+#define NVIC_MPU_ATTR_XN        0x10000000  // Execute disable
+#define NVIC_MPU_ATTR_SRD_M     0x0000FF00  // Sub-region disable mask
+#define NVIC_MPU_ATTR_SRD_0     0x00000100  // Sub-region 0 disable
+#define NVIC_MPU_ATTR_SRD_1     0x00000200  // Sub-region 1 disable
+#define NVIC_MPU_ATTR_SRD_2     0x00000400  // Sub-region 2 disable
+#define NVIC_MPU_ATTR_SRD_3     0x00000800  // Sub-region 3 disable
+#define NVIC_MPU_ATTR_SRD_4     0x00001000  // Sub-region 4 disable
+#define NVIC_MPU_ATTR_SRD_5     0x00002000  // Sub-region 5 disable
+#define NVIC_MPU_ATTR_SRD_6     0x00004000  // Sub-region 6 disable
+#define NVIC_MPU_ATTR_SRD_7     0x00008000  // Sub-region 7 disable
+#define NVIC_MPU_ATTR_SIZE_M    0x0000003E  // Region size mask
+#define NVIC_MPU_ATTR_SIZE_32B  0x00000008  // Region size 32 bytes
+#define NVIC_MPU_ATTR_SIZE_64B  0x0000000A  // Region size 64 bytes
+#define NVIC_MPU_ATTR_SIZE_128B 0x0000000C  // Region size 128 bytes
+#define NVIC_MPU_ATTR_SIZE_256B 0x0000000E  // Region size 256 bytes
+#define NVIC_MPU_ATTR_SIZE_512B 0x00000010  // Region size 512 bytes
+#define NVIC_MPU_ATTR_SIZE_1K   0x00000012  // Region size 1 Kbytes
+#define NVIC_MPU_ATTR_SIZE_2K   0x00000014  // Region size 2 Kbytes
+#define NVIC_MPU_ATTR_SIZE_4K   0x00000016  // Region size 4 Kbytes
+#define NVIC_MPU_ATTR_SIZE_8K   0x00000018  // Region size 8 Kbytes
+#define NVIC_MPU_ATTR_SIZE_16K  0x0000001A  // Region size 16 Kbytes
+#define NVIC_MPU_ATTR_SIZE_32K  0x0000001C  // Region size 32 Kbytes
+#define NVIC_MPU_ATTR_SIZE_64K  0x0000001E  // Region size 64 Kbytes
+#define NVIC_MPU_ATTR_SIZE_128K 0x00000020  // Region size 128 Kbytes
+#define NVIC_MPU_ATTR_SIZE_256K 0x00000022  // Region size 256 Kbytes
+#define NVIC_MPU_ATTR_SIZE_512K 0x00000024  // Region size 512 Kbytes
+#define NVIC_MPU_ATTR_SIZE_1M   0x00000026  // Region size 1 Mbytes
+#define NVIC_MPU_ATTR_SIZE_2M   0x00000028  // Region size 2 Mbytes
+#define NVIC_MPU_ATTR_SIZE_4M   0x0000002A  // Region size 4 Mbytes
+#define NVIC_MPU_ATTR_SIZE_8M   0x0000002C  // Region size 8 Mbytes
+#define NVIC_MPU_ATTR_SIZE_16M  0x0000002E  // Region size 16 Mbytes
+#define NVIC_MPU_ATTR_SIZE_32M  0x00000030  // Region size 32 Mbytes
+#define NVIC_MPU_ATTR_SIZE_64M  0x00000032  // Region size 64 Mbytes
+#define NVIC_MPU_ATTR_SIZE_128M 0x00000034  // Region size 128 Mbytes
+#define NVIC_MPU_ATTR_SIZE_256M 0x00000036  // Region size 256 Mbytes
+#define NVIC_MPU_ATTR_SIZE_512M 0x00000038  // Region size 512 Mbytes
+#define NVIC_MPU_ATTR_SIZE_1G   0x0000003A  // Region size 1 Gbytes
+#define NVIC_MPU_ATTR_SIZE_2G   0x0000003C  // Region size 2 Gbytes
+#define NVIC_MPU_ATTR_SIZE_4G   0x0000003E  // Region size 4 Gbytes
+#define NVIC_MPU_ATTR_ENABLE    0x00000001  // Region enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_DBG_CTRL_DBGKEY_M  0xFFFF0000  // Debug key mask
+#define NVIC_DBG_CTRL_DBGKEY    0xA05F0000  // Debug key
+#define NVIC_DBG_CTRL_S_RESET_ST \
+                                0x02000000  // Core has reset since last read
+#define NVIC_DBG_CTRL_S_RETIRE_ST \
+                                0x01000000  // Core has executed insruction
+                                            // since last read
+#define NVIC_DBG_CTRL_S_LOCKUP  0x00080000  // Core is locked up
+#define NVIC_DBG_CTRL_S_SLEEP   0x00040000  // Core is sleeping
+#define NVIC_DBG_CTRL_S_HALT    0x00020000  // Core status on halt
+#define NVIC_DBG_CTRL_S_REGRDY  0x00010000  // Register read/write available
+#define NVIC_DBG_CTRL_C_SNAPSTALL \
+                                0x00000020  // Breaks a stalled load/store
+#define NVIC_DBG_CTRL_C_MASKINT 0x00000008  // Mask interrupts when stepping
+#define NVIC_DBG_CTRL_C_STEP    0x00000004  // Step the core
+#define NVIC_DBG_CTRL_C_HALT    0x00000002  // Halt the core
+#define NVIC_DBG_CTRL_C_DEBUGEN 0x00000001  // Enable debug
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_XFER register.
+//
+//*****************************************************************************
+#define NVIC_DBG_XFER_REG_WNR   0x00010000  // Write or not read
+#define NVIC_DBG_XFER_REG_SEL_M 0x0000001F  // Register
+#define NVIC_DBG_XFER_REG_CFBP  0x00000014  // Control/Fault/BasePri/PriMask
+#define NVIC_DBG_XFER_REG_DSP   0x00000013  // Deep SP
+#define NVIC_DBG_XFER_REG_PSP   0x00000012  // Process SP
+#define NVIC_DBG_XFER_REG_MSP   0x00000011  // Main SP
+#define NVIC_DBG_XFER_REG_FLAGS 0x00000010  // xPSR/Flags register
+#define NVIC_DBG_XFER_REG_R15   0x0000000F  // Register R15
+#define NVIC_DBG_XFER_REG_R14   0x0000000E  // Register R14
+#define NVIC_DBG_XFER_REG_R13   0x0000000D  // Register R13
+#define NVIC_DBG_XFER_REG_R12   0x0000000C  // Register R12
+#define NVIC_DBG_XFER_REG_R11   0x0000000B  // Register R11
+#define NVIC_DBG_XFER_REG_R10   0x0000000A  // Register R10
+#define NVIC_DBG_XFER_REG_R9    0x00000009  // Register R9
+#define NVIC_DBG_XFER_REG_R8    0x00000008  // Register R8
+#define NVIC_DBG_XFER_REG_R7    0x00000007  // Register R7
+#define NVIC_DBG_XFER_REG_R6    0x00000006  // Register R6
+#define NVIC_DBG_XFER_REG_R5    0x00000005  // Register R5
+#define NVIC_DBG_XFER_REG_R4    0x00000004  // Register R4
+#define NVIC_DBG_XFER_REG_R3    0x00000003  // Register R3
+#define NVIC_DBG_XFER_REG_R2    0x00000002  // Register R2
+#define NVIC_DBG_XFER_REG_R1    0x00000001  // Register R1
+#define NVIC_DBG_XFER_REG_R0    0x00000000  // Register R0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_DATA register.
+//
+//*****************************************************************************
+#define NVIC_DBG_DATA_M         0xFFFFFFFF  // Data temporary cache
+#define NVIC_DBG_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_INT register.
+//
+//*****************************************************************************
+#define NVIC_DBG_INT_HARDERR    0x00000400  // Debug trap on hard fault
+#define NVIC_DBG_INT_INTERR     0x00000200  // Debug trap on interrupt errors
+#define NVIC_DBG_INT_BUSERR     0x00000100  // Debug trap on bus error
+#define NVIC_DBG_INT_STATERR    0x00000080  // Debug trap on usage fault state
+#define NVIC_DBG_INT_CHKERR     0x00000040  // Debug trap on usage fault check
+#define NVIC_DBG_INT_NOCPERR    0x00000020  // Debug trap on coprocessor error
+#define NVIC_DBG_INT_MMERR      0x00000010  // Debug trap on mem manage fault
+#define NVIC_DBG_INT_RESET      0x00000008  // Core reset status
+#define NVIC_DBG_INT_RSTPENDCLR 0x00000004  // Clear pending core reset
+#define NVIC_DBG_INT_RSTPENDING 0x00000002  // Core reset is pending
+#define NVIC_DBG_INT_RSTVCATCH  0x00000001  // Reset vector catch
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SW_TRIG register.
+//
+//*****************************************************************************
+#define NVIC_SW_TRIG_INTID_M    0x000003FF  // Interrupt to trigger
+#define NVIC_SW_TRIG_INTID_S    0
+
+#endif // __HW_NVIC_H__


Property changes on: trunk/src/platform/lm3s/hw_nvic.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_pwm.h
===================================================================
--- trunk/src/platform/lm3s/hw_pwm.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_pwm.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,676 +1,716 @@
-//*****************************************************************************
-//
-// hw_pwm.h - Defines and Macros for Pulse Width Modulation (PWM) ports
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_PWM_H__
-#define __HW_PWM_H__
-
-//*****************************************************************************
-//
-// The following are defines for the PWM Module Register offsets.
-//
-//*****************************************************************************
-#define PWM_O_CTL               0x00000000  // PWM Master Control register
-#define PWM_O_SYNC              0x00000004  // PWM Time Base Sync register
-#define PWM_O_ENABLE            0x00000008  // PWM Output Enable register
-#define PWM_O_INVERT            0x0000000C  // PWM Output Inversion register
-#define PWM_O_FAULT             0x00000010  // PWM Output Fault register
-#define PWM_O_INTEN             0x00000014  // PWM Interrupt Enable register
-#define PWM_O_RIS               0x00000018  // PWM Interrupt Raw Status reg.
-#define PWM_O_ISC               0x0000001C  // PWM Interrupt Status register
-#define PWM_O_STATUS            0x00000020  // PWM Status register
-#define PWM_O_FAULTVAL          0x00000024  // PWM Fault Condition Value
-#define PWM_O_0_CTL             0x00000040  // PWM0 Control
-#define PWM_O_0_INTEN           0x00000044  // PWM0 Interrupt and Trigger
-                                            // Enable
-#define PWM_O_0_RIS             0x00000048  // PWM0 Raw Interrupt Status
-#define PWM_O_0_ISC             0x0000004C  // PWM0 Interrupt Status and Clear
-#define PWM_O_0_LOAD            0x00000050  // PWM0 Load
-#define PWM_O_0_COUNT           0x00000054  // PWM0 Counter
-#define PWM_O_0_CMPA            0x00000058  // PWM0 Compare A
-#define PWM_O_0_CMPB            0x0000005C  // PWM0 Compare B
-#define PWM_O_0_GENA            0x00000060  // PWM0 Generator A Control
-#define PWM_O_0_GENB            0x00000064  // PWM0 Generator B Control
-#define PWM_O_0_DBCTL           0x00000068  // PWM0 Dead-Band Control
-#define PWM_O_0_DBRISE          0x0000006C  // PWM0 Dead-Band Rising-Edge Delay
-#define PWM_O_0_DBFALL          0x00000070  // PWM0 Dead-Band
-                                            // Falling-Edge-Delay
-#define PWM_O_0_FLTSRC0         0x00000074  // PWM0 Fault Source 0
-#define PWM_O_0_MINFLTPER       0x0000007C  // PWM0 Minimum Fault Period
-#define PWM_O_1_CTL             0x00000080  // PWM1 Control
-#define PWM_O_1_INTEN           0x00000084  // PWM1 Interrupt Enable
-#define PWM_O_1_RIS             0x00000088  // PWM1 Raw Interrupt Status
-#define PWM_O_1_ISC             0x0000008C  // PWM1 Interrupt Status and Clear
-#define PWM_O_1_LOAD            0x00000090  // PWM1 Load
-#define PWM_O_1_COUNT           0x00000094  // PWM1 Counter
-#define PWM_O_1_CMPA            0x00000098  // PWM1 Compare A
-#define PWM_O_1_CMPB            0x0000009C  // PWM1 Compare B
-#define PWM_O_1_GENA            0x000000A0  // PWM1 Generator A Control
-#define PWM_O_1_GENB            0x000000A4  // PWM1 Generator B Control
-#define PWM_O_1_DBCTL           0x000000A8  // PWM1 Dead-Band Control
-#define PWM_O_1_DBRISE          0x000000AC  // PWM1 Dead-Band Rising-Edge Delay
-#define PWM_O_1_DBFALL          0x000000B0  // PWM1 Dead-Band
-                                            // Falling-Edge-Delay
-#define PWM_O_1_FLTSRC0         0x000000B4  // PWM1 Fault Source 0
-#define PWM_O_1_MINFLTPER       0x000000BC  // PWM1 Minimum Fault Period
-#define PWM_O_2_CTL             0x000000C0  // PWM2 Control
-#define PWM_O_2_INTEN           0x000000C4  // PWM2 InterruptEnable
-#define PWM_O_2_RIS             0x000000C8  // PWM2 Raw Interrupt Status
-#define PWM_O_2_ISC             0x000000CC  // PWM2 Interrupt Status and Clear
-#define PWM_O_2_LOAD            0x000000D0  // PWM2 Load
-#define PWM_O_2_COUNT           0x000000D4  // PWM2 Counter
-#define PWM_O_2_CMPA            0x000000D8  // PWM2 Compare A
-#define PWM_O_2_CMPB            0x000000DC  // PWM2 Compare B
-#define PWM_O_2_GENA            0x000000E0  // PWM2 Generator A Control
-#define PWM_O_2_GENB            0x000000E4  // PWM2 Generator B Control
-#define PWM_O_2_DBCTL           0x000000E8  // PWM2 Dead-Band Control
-#define PWM_O_2_DBRISE          0x000000EC  // PWM2 Dead-Band Rising-Edge Delay
-#define PWM_O_2_DBFALL          0x000000F0  // PWM2 Dead-Band
-                                            // Falling-Edge-Delay
-#define PWM_O_2_FLTSRC0         0x000000F4  // PWM2 Fault Source 0
-#define PWM_O_2_MINFLTPER       0x000000FC  // PWM2 Minimum Fault Period
-#define PWM_O_3_CTL             0x00000100  // PWM3 Control
-#define PWM_O_3_INTEN           0x00000104  // PWM3 Interrupt and Trigger
-                                            // Enable
-#define PWM_O_3_RIS             0x00000108  // PWM3 Raw Interrupt Status
-#define PWM_O_3_ISC             0x0000010C  // PWM3 Interrupt Status and Clear
-#define PWM_O_3_LOAD            0x00000110  // PWM3 Load
-#define PWM_O_3_COUNT           0x00000114  // PWM3 Counter
-#define PWM_O_3_CMPA            0x00000118  // PWM3 Compare A
-#define PWM_O_3_CMPB            0x0000011C  // PWM3 Compare B
-#define PWM_O_3_GENA            0x00000120  // PWM3 Generator A Control
-#define PWM_O_3_GENB            0x00000124  // PWM3 Generator B Control
-#define PWM_O_3_DBCTL           0x00000128  // PWM3 Dead-Band Control
-#define PWM_O_3_DBRISE          0x0000012C  // PWM3 Dead-Band Rising-Edge Delay
-#define PWM_O_3_DBFALL          0x00000130  // PWM3 Dead-Band
-                                            // Falling-Edge-Delay
-#define PWM_O_3_FLTSRC0         0x00000134  // PWM3 Fault Source 0
-#define PWM_O_3_MINFLTPER       0x0000013C  // PWM3 Minimum Fault Period
-#define PWM_O_0_FLTSEN          0x00000800  // PWM0 Fault Pin Logic Sense
-#define PWM_O_0_FLTSTAT0        0x00000804  // PWM0 Fault Status 0
-#define PWM_O_1_FLTSEN          0x00000880  // PWM1 Fault Pin Logic Sense
-#define PWM_O_1_FLTSTAT0        0x00000884  // PWM1 Fault Status 0
-#define PWM_O_2_FLTSEN          0x00000900  // PWM2 Fault Pin Logic Sense
-#define PWM_O_2_FLTSTAT0        0x00000904  // PWM2 Fault Status 0
-#define PWM_O_3_FLTSEN          0x00000980  // PWM3 Fault Pin Logic Sense
-#define PWM_O_3_FLTSTAT0        0x00000984  // PWM3 Fault Status 0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM Master Control
-// register.
-//
-//*****************************************************************************
-#define PWM_CTL_GLOBALSYNC3     0x00000008  // Update PWM Generator 3.
-#define PWM_CTL_GLOBALSYNC2     0x00000004  // Update PWM Generator 2.
-#define PWM_CTL_GLOBALSYNC1     0x00000002  // Update PWM Generator 1.
-#define PWM_CTL_GLOBALSYNC0     0x00000001  // Update PWM Generator 0.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM Time Base Sync
-// register.
-//
-//*****************************************************************************
-#define PWM_SYNC_SYNC3          0x00000008  // Reset generator 3 counter
-#define PWM_SYNC_SYNC2          0x00000004  // Reset generator 2 counter
-#define PWM_SYNC_SYNC1          0x00000002  // Reset generator 1 counter
-#define PWM_SYNC_SYNC0          0x00000001  // Reset generator 0 counter
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM Output Enable
-// register.
-//
-//*****************************************************************************
-#define PWM_ENABLE_PWM7EN       0x00000080  // PWM7 pin enable
-#define PWM_ENABLE_PWM6EN       0x00000040  // PWM6 pin enable
-#define PWM_ENABLE_PWM5EN       0x00000020  // PWM5 pin enable
-#define PWM_ENABLE_PWM4EN       0x00000010  // PWM4 pin enable
-#define PWM_ENABLE_PWM3EN       0x00000008  // PWM3 pin enable
-#define PWM_ENABLE_PWM2EN       0x00000004  // PWM2 pin enable
-#define PWM_ENABLE_PWM1EN       0x00000002  // PWM1 pin enable
-#define PWM_ENABLE_PWM0EN       0x00000001  // PWM0 pin enable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM Inversion register.
-//
-//*****************************************************************************
-#define PWM_INVERT_PWM7INV      0x00000080  // PWM7 pin invert
-#define PWM_INVERT_PWM6INV      0x00000040  // PWM6 pin invert
-#define PWM_INVERT_PWM5INV      0x00000020  // PWM5 pin invert
-#define PWM_INVERT_PWM4INV      0x00000010  // PWM4 pin invert
-#define PWM_INVERT_PWM3INV      0x00000008  // PWM3 pin invert
-#define PWM_INVERT_PWM2INV      0x00000004  // PWM2 pin invert
-#define PWM_INVERT_PWM1INV      0x00000002  // PWM1 pin invert
-#define PWM_INVERT_PWM0INV      0x00000001  // PWM0 pin invert
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM Fault register.
-//
-//*****************************************************************************
-#define PWM_FAULT_FAULT7        0x00000080  // PWM7 pin fault
-#define PWM_FAULT_FAULT6        0x00000040  // PWM6 pin fault
-#define PWM_FAULT_FAULT5        0x00000020  // PWM5 pin fault
-#define PWM_FAULT_FAULT4        0x00000010  // PWM4 pin fault
-#define PWM_FAULT_FAULT3        0x00000008  // PWM3 pin fault
-#define PWM_FAULT_FAULT2        0x00000004  // PWM2 pin fault
-#define PWM_FAULT_FAULT1        0x00000002  // PWM1 pin fault
-#define PWM_FAULT_FAULT0        0x00000001  // PWM0 pin fault
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM Status register.
-//
-//*****************************************************************************
-#define PWM_STATUS_FAULT3       0x00000008  // Fault3 Interrupt Status.
-#define PWM_STATUS_FAULT2       0x00000004  // Fault2 Interrupt Status.
-#define PWM_STATUS_FAULT1       0x00000002  // Fault1 Interrupt Status.
-#define PWM_STATUS_FAULT0       0x00000001  // Fault0 Interrupt Status.
-
-//*****************************************************************************
-//
-// The following are defines for the PWM Generator standard offsets.
-//
-//*****************************************************************************
-#define PWM_O_X_CTL             0x00000000  // Gen Control Reg
-#define PWM_O_X_INTEN           0x00000004  // Gen Int/Trig Enable Reg
-#define PWM_O_X_RIS             0x00000008  // Gen Raw Int Status Reg
-#define PWM_O_X_ISC             0x0000000C  // Gen Int Status Reg
-#define PWM_O_X_LOAD            0x00000010  // Gen Load Reg
-#define PWM_O_X_COUNT           0x00000014  // Gen Counter Reg
-#define PWM_O_X_CMPA            0x00000018  // Gen Compare A Reg
-#define PWM_O_X_CMPB            0x0000001C  // Gen Compare B Reg
-#define PWM_O_X_GENA            0x00000020  // Gen Generator A Ctrl Reg
-#define PWM_O_X_GENB            0x00000024  // Gen Generator B Ctrl Reg
-#define PWM_O_X_DBCTL           0x00000028  // Gen Dead Band Ctrl Reg
-#define PWM_O_X_DBRISE          0x0000002C  // Gen DB Rising Edge Delay Reg
-#define PWM_O_X_DBFALL          0x00000030  // Gen DB Falling Edge Delay Reg
-#define PWM_O_X_FLTSRC0         0x00000034  // Fault pin, comparator condition
-#define PWM_O_X_MINFLTPER       0x0000003C  // Fault minimum period extension
-#define PWM_GEN_0_OFFSET        0x00000040  // PWM0 base
-#define PWM_GEN_1_OFFSET        0x00000080  // PWM1 base
-#define PWM_GEN_2_OFFSET        0x000000C0  // PWM2 base
-#define PWM_GEN_3_OFFSET        0x00000100  // PWM3 base
-
-//*****************************************************************************
-//
-// The following are defines for the PWM_X Control Register bit definitions.
-//
-//*****************************************************************************
-#define PWM_X_CTL_LATCH         0x00040000  // Latch Fault Input.
-#define PWM_X_CTL_MINFLTPER     0x00020000  // Minimum fault period enabled
-#define PWM_X_CTL_FLTSRC        0x00010000  // Fault Condition Source.
-#define PWM_X_CTL_DBFALLUPD_M   0x0000C000  // Specifies the update mode for
-                                            // the PWMnDBFALL register.
-#define PWM_X_CTL_DBFALLUPD_I   0x00000000  // Immediate
-#define PWM_X_CTL_DBFALLUPD_LS  0x00008000  // Locally Synchronized
-#define PWM_X_CTL_DBFALLUPD_GS  0x0000C000  // Globally Synchronized
-#define PWM_X_CTL_DBRISEUPD_M   0x00003000  // PWMnDBRISE Update Mode.
-#define PWM_X_CTL_DBRISEUPD_I   0x00000000  // Immediate
-#define PWM_X_CTL_DBRISEUPD_LS  0x00002000  // Locally Synchronized
-#define PWM_X_CTL_DBRISEUPD_GS  0x00003000  // Globally Synchronized
-#define PWM_X_CTL_DBCTLUPD_M    0x00000C00  // PWMnDBCTL Update Mode.
-#define PWM_X_CTL_DBCTLUPD_I    0x00000000  // Immediate
-#define PWM_X_CTL_DBCTLUPD_LS   0x00000800  // Locally Synchronized
-#define PWM_X_CTL_DBCTLUPD_GS   0x00000C00  // Globally Synchronized
-#define PWM_X_CTL_GENBUPD_M     0x00000300  // PWMnGENB Update Mode.
-#define PWM_X_CTL_GENBUPD_I     0x00000000  // Immediate
-#define PWM_X_CTL_GENBUPD_LS    0x00000200  // Locally Synchronized
-#define PWM_X_CTL_GENBUPD_GS    0x00000300  // Globally Synchronized
-#define PWM_X_CTL_GENAUPD_M     0x000000C0  // PWMnGENA Update Mode.
-#define PWM_X_CTL_GENAUPD_I     0x00000000  // Immediate
-#define PWM_X_CTL_GENAUPD_LS    0x00000080  // Locally Synchronized
-#define PWM_X_CTL_GENAUPD_GS    0x000000C0  // Globally Synchronized
-#define PWM_X_CTL_CMPBUPD       0x00000020  // Update mode for comp B reg
-#define PWM_X_CTL_CMPAUPD       0x00000010  // Update mode for comp A reg
-#define PWM_X_CTL_LOADUPD       0x00000008  // Update mode for the load reg
-#define PWM_X_CTL_DEBUG         0x00000004  // Debug mode
-#define PWM_X_CTL_MODE          0x00000002  // Counter mode, down or up/down
-#define PWM_X_CTL_ENABLE        0x00000001  // Master enable for gen block
-
-//*****************************************************************************
-//
-// The following are defines for the PWM Generator extended offsets.
-//
-//*****************************************************************************
-#define PWM_O_X_FLTSEN          0x00000000  // Fault logic sense
-#define PWM_O_X_FLTSTAT0        0x00000004  // Pin and comparator status
-#define PWM_EXT_0_OFFSET        0x00000800  // PWM0 extended base
-#define PWM_EXT_1_OFFSET        0x00000880  // PWM1 extended base
-#define PWM_EXT_2_OFFSET        0x00000900  // PWM2 extended base
-#define PWM_EXT_3_OFFSET        0x00000980  // PWM3 extended base
-
-//*****************************************************************************
-//
-// The following are defines for the PWM_X Interrupt/Trigger Enable Register
-// bit definitions.
-//
-//*****************************************************************************
-#define PWM_X_INTEN_TRCMPBD     0x00002000  // Trig if COUNT = CMPB D
-#define PWM_X_INTEN_TRCMPBU     0x00001000  // Trig if COUNT = CMPB U
-#define PWM_X_INTEN_TRCMPAD     0x00000800  // Trig if COUNT = CMPA D
-#define PWM_X_INTEN_TRCMPAU     0x00000400  // Trig if COUNT = CMPA U
-#define PWM_X_INTEN_TRCNTLOAD   0x00000200  // Trig if COUNT = LOAD
-#define PWM_X_INTEN_TRCNTZERO   0x00000100  // Trig if COUNT = 0
-#define PWM_X_INTEN_INTCMPBD    0x00000020  // Int if COUNT = CMPA D
-#define PWM_X_INTEN_INTCMPBU    0x00000010  // Int if COUNT = CMPA U
-#define PWM_X_INTEN_INTCMPAD    0x00000008  // Int if COUNT = CMPA D
-#define PWM_X_INTEN_INTCMPAU    0x00000004  // Int if COUNT = CMPA U
-#define PWM_X_INTEN_INTCNTLOAD  0x00000002  // Int if COUNT = LOAD
-#define PWM_X_INTEN_INTCNTZERO  0x00000001  // Int if COUNT = 0
-
-//*****************************************************************************
-//
-// The following are defines for the PWM_X Raw Interrupt Status Register bit
-// definitions.
-//
-//*****************************************************************************
-#define PWM_X_RIS_INTCMPBD      0x00000020  // PWM_X_COUNT = PWM_X_CMPB D int
-#define PWM_X_RIS_INTCMPBU      0x00000010  // PWM_X_COUNT = PWM_X_CMPB U int
-#define PWM_X_RIS_INTCMPAD      0x00000008  // PWM_X_COUNT = PWM_X_CMPA D int
-#define PWM_X_RIS_INTCMPAU      0x00000004  // PWM_X_COUNT = PWM_X_CMPA U int
-#define PWM_X_RIS_INTCNTLOAD    0x00000002  // PWM_X_COUNT = PWM_X_LOAD int
-#define PWM_X_RIS_INTCNTZERO    0x00000001  // PWM_X_COUNT = 0 int
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_INTEN register.
-//
-//*****************************************************************************
-#define PWM_INTEN_INTFAULT3     0x00080000  // Interrupt Fault 3.
-#define PWM_INTEN_INTFAULT2     0x00040000  // Interrupt Fault 2.
-#define PWM_INTEN_INTFAULT1     0x00020000  // Interrupt Fault 1.
-#define PWM_INTEN_INTFAULT      0x00010000  // Fault Interrupt Enable.
-#define PWM_INTEN_INTFAULT0     0x00010000  // Interrupt Fault 0.
-#define PWM_INTEN_INTPWM3       0x00000008  // PWM3 Interrupt Enable.
-#define PWM_INTEN_INTPWM2       0x00000004  // PWM2 Interrupt Enable.
-#define PWM_INTEN_INTPWM1       0x00000002  // PWM1 Interrupt Enable.
-#define PWM_INTEN_INTPWM0       0x00000001  // PWM0 Interrupt Enable.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_RIS register.
-//
-//*****************************************************************************
-#define PWM_RIS_INTFAULT3       0x00080000  // Interrupt Fault PWM 3.
-#define PWM_RIS_INTFAULT2       0x00040000  // Interrupt Fault PWM 2.
-#define PWM_RIS_INTFAULT1       0x00020000  // Interrupt Fault PWM 1.
-#define PWM_RIS_INTFAULT0       0x00010000  // Interrupt Fault PWM 0.
-#define PWM_RIS_INTFAULT        0x00010000  // Fault Interrupt Asserted.
-#define PWM_RIS_INTPWM3         0x00000008  // PWM3 Interrupt Asserted.
-#define PWM_RIS_INTPWM2         0x00000004  // PWM2 Interrupt Asserted.
-#define PWM_RIS_INTPWM1         0x00000002  // PWM1 Interrupt Asserted.
-#define PWM_RIS_INTPWM0         0x00000001  // PWM0 Interrupt Asserted.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_ISC register.
-//
-//*****************************************************************************
-#define PWM_ISC_INTFAULT3       0x00080000  // FAULT3 Interrupt Asserted.
-#define PWM_ISC_INTFAULT2       0x00040000  // FAULT2 Interrupt Asserted.
-#define PWM_ISC_INTFAULT1       0x00020000  // FAULT1 Interrupt Asserted.
-#define PWM_ISC_INTFAULT        0x00010000  // Fault Interrupt Asserted.
-#define PWM_ISC_INTFAULT0       0x00010000  // FAULT0 Interrupt Asserted.
-#define PWM_ISC_INTPWM3         0x00000008  // PWM3 Interrupt Status.
-#define PWM_ISC_INTPWM2         0x00000004  // PWM2 Interrupt Status.
-#define PWM_ISC_INTPWM1         0x00000002  // PWM1 Interrupt Status.
-#define PWM_ISC_INTPWM0         0x00000001  // PWM0 Interrupt Status.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_ISC register.
-//
-//*****************************************************************************
-#define PWM_X_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt.
-#define PWM_X_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt.
-#define PWM_X_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt.
-#define PWM_X_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt.
-#define PWM_X_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt.
-#define PWM_X_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_LOAD register.
-//
-//*****************************************************************************
-#define PWM_X_LOAD_M            0x0000FFFF  // Counter Load Value.
-#define PWM_X_LOAD_S            0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_COUNT register.
-//
-//*****************************************************************************
-#define PWM_X_COUNT_M           0x0000FFFF  // Counter Value.
-#define PWM_X_COUNT_S           0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_CMPA register.
-//
-//*****************************************************************************
-#define PWM_X_CMPA_M            0x0000FFFF  // Comparator A Value.
-#define PWM_X_CMPA_S            0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_CMPB register.
-//
-//*****************************************************************************
-#define PWM_X_CMPB_M            0x0000FFFF  // Comparator B Value.
-#define PWM_X_CMPB_S            0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_GENA register.
-//
-//*****************************************************************************
-#define PWM_X_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
-#define PWM_X_GENA_ACTCMPBD_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENA_ACTCMPBD_INV 0x00000400  // Invert the output signal.
-#define PWM_X_GENA_ACTCMPBD_ZERO \
-                                0x00000800  // Set the output signal to 0.
-#define PWM_X_GENA_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
-#define PWM_X_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
-#define PWM_X_GENA_ACTCMPBU_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENA_ACTCMPBU_INV 0x00000100  // Invert the output signal.
-#define PWM_X_GENA_ACTCMPBU_ZERO \
-                                0x00000200  // Set the output signal to 0.
-#define PWM_X_GENA_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
-#define PWM_X_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
-#define PWM_X_GENA_ACTCMPAD_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENA_ACTCMPAD_INV 0x00000040  // Invert the output signal.
-#define PWM_X_GENA_ACTCMPAD_ZERO \
-                                0x00000080  // Set the output signal to 0.
-#define PWM_X_GENA_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
-#define PWM_X_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
-#define PWM_X_GENA_ACTCMPAU_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENA_ACTCMPAU_INV 0x00000010  // Invert the output signal.
-#define PWM_X_GENA_ACTCMPAU_ZERO \
-                                0x00000020  // Set the output signal to 0.
-#define PWM_X_GENA_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
-#define PWM_X_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
-#define PWM_X_GENA_ACTLOAD_NONE 0x00000000  // Do nothing.
-#define PWM_X_GENA_ACTLOAD_INV  0x00000004  // Invert the output signal.
-#define PWM_X_GENA_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
-#define PWM_X_GENA_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
-#define PWM_X_GENA_ACTZERO_M    0x00000003  // Action for Counter=0.
-#define PWM_X_GENA_ACTZERO_NONE 0x00000000  // Do nothing.
-#define PWM_X_GENA_ACTZERO_INV  0x00000001  // Invert the output signal.
-#define PWM_X_GENA_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
-#define PWM_X_GENA_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_GENB register.
-//
-//*****************************************************************************
-#define PWM_X_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
-#define PWM_X_GENB_ACTCMPBD_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENB_ACTCMPBD_INV 0x00000400  // Invert the output signal.
-#define PWM_X_GENB_ACTCMPBD_ZERO \
-                                0x00000800  // Set the output signal to 0.
-#define PWM_X_GENB_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
-#define PWM_X_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
-#define PWM_X_GENB_ACTCMPBU_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENB_ACTCMPBU_INV 0x00000100  // Invert the output signal.
-#define PWM_X_GENB_ACTCMPBU_ZERO \
-                                0x00000200  // Set the output signal to 0.
-#define PWM_X_GENB_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
-#define PWM_X_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
-#define PWM_X_GENB_ACTCMPAD_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENB_ACTCMPAD_INV 0x00000040  // Invert the output signal.
-#define PWM_X_GENB_ACTCMPAD_ZERO \
-                                0x00000080  // Set the output signal to 0.
-#define PWM_X_GENB_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
-#define PWM_X_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
-#define PWM_X_GENB_ACTCMPAU_NONE \
-                                0x00000000  // Do nothing.
-#define PWM_X_GENB_ACTCMPAU_INV 0x00000010  // Invert the output signal.
-#define PWM_X_GENB_ACTCMPAU_ZERO \
-                                0x00000020  // Set the output signal to 0.
-#define PWM_X_GENB_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
-#define PWM_X_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
-#define PWM_X_GENB_ACTLOAD_NONE 0x00000000  // Do nothing.
-#define PWM_X_GENB_ACTLOAD_INV  0x00000004  // Invert the output signal.
-#define PWM_X_GENB_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
-#define PWM_X_GENB_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
-#define PWM_X_GENB_ACTZERO_M    0x00000003  // Action for Counter=0.
-#define PWM_X_GENB_ACTZERO_NONE 0x00000000  // Do nothing.
-#define PWM_X_GENB_ACTZERO_INV  0x00000001  // Invert the output signal.
-#define PWM_X_GENB_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
-#define PWM_X_GENB_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_DBCTL register.
-//
-//*****************************************************************************
-#define PWM_X_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_DBRISE register.
-//
-//*****************************************************************************
-#define PWM_X_DBRISE_DELAY_M    0x00000FFF  // Dead-Band Rise Delay.
-#define PWM_X_DBRISE_DELAY_S    0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_DBFALL register.
-//
-//*****************************************************************************
-#define PWM_X_DBFALL_DELAY_M    0x00000FFF  // Dead-Band Fall Delay.
-#define PWM_X_DBFALL_DELAY_S    0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_FAULTVAL register.
-//
-//*****************************************************************************
-#define PWM_FAULTVAL_PWM7       0x00000080  // PWM7 Fault Value.
-#define PWM_FAULTVAL_PWM6       0x00000040  // PWM6 Fault Value.
-#define PWM_FAULTVAL_PWM5       0x00000020  // PWM5 Fault Value.
-#define PWM_FAULTVAL_PWM4       0x00000010  // PWM4 Fault Value.
-#define PWM_FAULTVAL_PWM3       0x00000008  // PWM3 Fault Value.
-#define PWM_FAULTVAL_PWM2       0x00000004  // PWM2 Fault Value.
-#define PWM_FAULTVAL_PWM1       0x00000002  // PWM1 Fault Value.
-#define PWM_FAULTVAL_PWM0       0x00000001  // PWM0 Fault Value.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_MINFLTPER
-// register.
-//
-//*****************************************************************************
-#define PWM_X_MINFLTPER_M       0x0000FFFF  // Minimum Fault Period.
-#define PWM_X_MINFLTPER_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_FLTSEN register.
-//
-//*****************************************************************************
-#define PWM_X_FLTSEN_FAULT3     0x00000008  // Fault3 Sense.
-#define PWM_X_FLTSEN_FAULT2     0x00000004  // Fault2 Sense.
-#define PWM_X_FLTSEN_FAULT1     0x00000002  // Fault1 Sense.
-#define PWM_X_FLTSEN_FAULT0     0x00000001  // Fault0 Sense.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_FLTSRC0
-// register.
-//
-//*****************************************************************************
-#define PWM_X_FLTSRC0_FAULT3    0x00000008  // Fault3.
-#define PWM_X_FLTSRC0_FAULT2    0x00000004  // Fault2.
-#define PWM_X_FLTSRC0_FAULT1    0x00000002  // Fault1.
-#define PWM_X_FLTSRC0_FAULT0    0x00000001  // Fault0.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the PWM_O_X_FLTSTAT0
-// register.
-//
-//*****************************************************************************
-#define PWM_X_FLTSTAT0_FAULT3   0x00000008  // Fault Input 3.
-#define PWM_X_FLTSTAT0_FAULT2   0x00000004  // Fault Input 2.
-#define PWM_X_FLTSTAT0_FAULT1   0x00000002  // Fault Input 1.
-#define PWM_X_FLTSTAT0_FAULT0   0x00000001  // Fault Input 0.
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the PWM Master
-// Control register.
-//
-//*****************************************************************************
-#define PWM_CTL_GLOBAL_SYNC2    0x00000004  // Global sync generator 2
-#define PWM_CTL_GLOBAL_SYNC1    0x00000002  // Global sync generator 1
-#define PWM_CTL_GLOBAL_SYNC0    0x00000001  // Global sync generator 0
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the PWM Interrupt Register bit
-// definitions.
-//
-//*****************************************************************************
-#define PWM_INT_INTFAULT        0x00010000  // Fault interrupt pending
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the PWM Status
-// register.
-//
-//*****************************************************************************
-#define PWM_STATUS_FAULT        0x00000001  // Fault status
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the PWM_X Interrupt Status Register
-// bit definitions.
-//
-//*****************************************************************************
-#define PWM_X_INT_INTCMPBD      0x00000020  // PWM_X_COUNT = PWM_X_CMPB D rcvd
-#define PWM_X_INT_INTCMPBU      0x00000010  // PWM_X_COUNT = PWM_X_CMPB U rcvd
-#define PWM_X_INT_INTCMPAD      0x00000008  // PWM_X_COUNT = PWM_X_CMPA D rcvd
-#define PWM_X_INT_INTCMPAU      0x00000004  // PWM_X_COUNT = PWM_X_CMPA U rcvd
-#define PWM_X_INT_INTCNTLOAD    0x00000002  // PWM_X_COUNT = PWM_X_LOAD rcvd
-#define PWM_X_INT_INTCNTZERO    0x00000001  // PWM_X_COUNT = 0 received
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the PWM_X Generator A/B Control
-// Register bit definitions.
-//
-//*****************************************************************************
-#define PWM_X_GEN_Y_ACTCMPBD    0x00000C00  // Act PWM_X_COUNT = PWM_X_CMPB D
-#define PWM_X_GEN_Y_ACTCMPBU    0x00000300  // Act PWM_X_COUNT = PWM_X_CMPB U
-#define PWM_X_GEN_Y_ACTCMPAD    0x000000C0  // Act PWM_X_COUNT = PWM_X_CMPA D
-#define PWM_X_GEN_Y_ACTCMPAU    0x00000030  // Act PWM_X_COUNT = PWM_X_CMPA U
-#define PWM_X_GEN_Y_ACTLOAD     0x0000000C  // Act PWM_X_COUNT = PWM_X_LOAD
-#define PWM_X_GEN_Y_ACTZERO     0x00000003  // Act PWM_X_COUNT = 0
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the PWM_X Generator A/B Control
-// Register action definitions.
-//
-//*****************************************************************************
-#define PWM_GEN_ACT_ONE         0x00000003  // Set the output signal to one
-#define PWM_GEN_ACT_ZERO        0x00000002  // Set the output signal to zero
-#define PWM_GEN_ACT_INV         0x00000001  // Invert the output signal
-#define PWM_GEN_ACT_NONE        0x00000000  // Do nothing
-#define PWM_GEN_ACT_B_DN_SHIFT  10          // Shift amount for the B dn action
-#define PWM_GEN_ACT_B_UP_SHIFT  8           // Shift amount for the B up action
-#define PWM_GEN_ACT_A_DN_SHIFT  6           // Shift amount for the A dn action
-#define PWM_GEN_ACT_A_UP_SHIFT  4           // Shift amount for the A up action
-#define PWM_GEN_ACT_LOAD_SHIFT  2           // Shift amount for the load action
-#define PWM_GEN_ACT_ZERO_SHIFT  0           // Shift amount for the zero action
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the PWM_X Dead Band Control
-// Register bit definitions.
-//
-//*****************************************************************************
-#define PWM_DBCTL_ENABLE        0x00000001  // Enable dead band insertion
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the PWM Register reset values.
-//
-//*****************************************************************************
-#define PWM_RV_X_DBCTL          0x00000000  // Control the dead band generator
-#define PWM_RV_STATUS           0x00000000  // Status
-#define PWM_RV_X_ISC            0x00000000  // Interrupt status and clearing
-#define PWM_RV_X_RIS            0x00000000  // Raw interrupt status
-#define PWM_RV_X_CTL            0x00000000  // Master control of the PWM
-                                            // generator block
-#define PWM_RV_SYNC             0x00000000  // Counter synch for PWM generators
-#define PWM_RV_X_DBFALL         0x00000000  // The dead band falling edge delay
-                                            // count
-#define PWM_RV_X_INTEN          0x00000000  // Interrupt and trigger enable
-#define PWM_RV_X_LOAD           0x00000000  // The load value for the counter
-#define PWM_RV_X_GENA           0x00000000  // Controls PWM generator A
-#define PWM_RV_CTL              0x00000000  // Master control of the PWM module
-#define PWM_RV_FAULT            0x00000000  // Fault handling for the PWM
-                                            // output pins
-#define PWM_RV_RIS              0x00000000  // Raw interrupt status
-#define PWM_RV_X_CMPA           0x00000000  // The comparator A value
-#define PWM_RV_INVERT           0x00000000  // Inversion control for PWM output
-                                            // pins
-#define PWM_RV_X_DBRISE         0x00000000  // The dead band rising edge delay
-                                            // count
-#define PWM_RV_ENABLE           0x00000000  // Master enable for the PWM output
-                                            // pins
-#define PWM_RV_X_GENB           0x00000000  // Controls PWM generator B
-#define PWM_RV_X_CMPB           0x00000000  // The comparator B value
-#define PWM_RV_ISC              0x00000000  // Interrupt status and clearing
-#define PWM_RV_INTEN            0x00000000  // Interrupt enable
-#define PWM_RV_X_COUNT          0x00000000  // The current counter value
-
-#endif
-
-#endif // __HW_PWM_H__
+//*****************************************************************************
+//
+// hw_pwm.h - Defines and Macros for Pulse Width Modulation (PWM) ports
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_PWM_H__
+#define __HW_PWM_H__
+
+//*****************************************************************************
+//
+// The following are defines for the PWM Module Register offsets.
+//
+//*****************************************************************************
+#define PWM_O_CTL               0x00000000  // PWM Master Control register
+#define PWM_O_SYNC              0x00000004  // PWM Time Base Sync register
+#define PWM_O_ENABLE            0x00000008  // PWM Output Enable register
+#define PWM_O_INVERT            0x0000000C  // PWM Output Inversion register
+#define PWM_O_FAULT             0x00000010  // PWM Output Fault register
+#define PWM_O_INTEN             0x00000014  // PWM Interrupt Enable register
+#define PWM_O_RIS               0x00000018  // PWM Interrupt Raw Status reg.
+#define PWM_O_ISC               0x0000001C  // PWM Interrupt Status register
+#define PWM_O_STATUS            0x00000020  // PWM Status register
+#define PWM_O_FAULTVAL          0x00000024  // PWM Fault Condition Value
+#define PWM_O_0_CTL             0x00000040  // PWM0 Control
+#define PWM_O_0_INTEN           0x00000044  // PWM0 Interrupt and Trigger
+                                            // Enable
+#define PWM_O_0_RIS             0x00000048  // PWM0 Raw Interrupt Status
+#define PWM_O_0_ISC             0x0000004C  // PWM0 Interrupt Status and Clear
+#define PWM_O_0_LOAD            0x00000050  // PWM0 Load
+#define PWM_O_0_COUNT           0x00000054  // PWM0 Counter
+#define PWM_O_0_CMPA            0x00000058  // PWM0 Compare A
+#define PWM_O_0_CMPB            0x0000005C  // PWM0 Compare B
+#define PWM_O_0_GENA            0x00000060  // PWM0 Generator A Control
+#define PWM_O_0_GENB            0x00000064  // PWM0 Generator B Control
+#define PWM_O_0_DBCTL           0x00000068  // PWM0 Dead-Band Control
+#define PWM_O_0_DBRISE          0x0000006C  // PWM0 Dead-Band Rising-Edge Delay
+#define PWM_O_0_DBFALL          0x00000070  // PWM0 Dead-Band
+                                            // Falling-Edge-Delay
+#define PWM_O_0_FLTSRC0         0x00000074  // PWM0 Fault Source 0
+#define PWM_O_0_FLTSRC1         0x00000078  // PWM0 Fault Source 1
+#define PWM_O_0_MINFLTPER       0x0000007C  // PWM0 Minimum Fault Period
+#define PWM_O_1_CTL             0x00000080  // PWM1 Control
+#define PWM_O_1_INTEN           0x00000084  // PWM1 Interrupt Enable
+#define PWM_O_1_RIS             0x00000088  // PWM1 Raw Interrupt Status
+#define PWM_O_1_ISC             0x0000008C  // PWM1 Interrupt Status and Clear
+#define PWM_O_1_LOAD            0x00000090  // PWM1 Load
+#define PWM_O_1_COUNT           0x00000094  // PWM1 Counter
+#define PWM_O_1_CMPA            0x00000098  // PWM1 Compare A
+#define PWM_O_1_CMPB            0x0000009C  // PWM1 Compare B
+#define PWM_O_1_GENA            0x000000A0  // PWM1 Generator A Control
+#define PWM_O_1_GENB            0x000000A4  // PWM1 Generator B Control
+#define PWM_O_1_DBCTL           0x000000A8  // PWM1 Dead-Band Control
+#define PWM_O_1_DBRISE          0x000000AC  // PWM1 Dead-Band Rising-Edge Delay
+#define PWM_O_1_DBFALL          0x000000B0  // PWM1 Dead-Band
+                                            // Falling-Edge-Delay
+#define PWM_O_1_FLTSRC0         0x000000B4  // PWM1 Fault Source 0
+#define PWM_O_1_FLTSRC1         0x000000B8  // PWM1 Fault Source 1
+#define PWM_O_1_MINFLTPER       0x000000BC  // PWM1 Minimum Fault Period
+#define PWM_O_2_CTL             0x000000C0  // PWM2 Control
+#define PWM_O_2_INTEN           0x000000C4  // PWM2 InterruptEnable
+#define PWM_O_2_RIS             0x000000C8  // PWM2 Raw Interrupt Status
+#define PWM_O_2_ISC             0x000000CC  // PWM2 Interrupt Status and Clear
+#define PWM_O_2_LOAD            0x000000D0  // PWM2 Load
+#define PWM_O_2_COUNT           0x000000D4  // PWM2 Counter
+#define PWM_O_2_CMPA            0x000000D8  // PWM2 Compare A
+#define PWM_O_2_CMPB            0x000000DC  // PWM2 Compare B
+#define PWM_O_2_GENA            0x000000E0  // PWM2 Generator A Control
+#define PWM_O_2_GENB            0x000000E4  // PWM2 Generator B Control
+#define PWM_O_2_DBCTL           0x000000E8  // PWM2 Dead-Band Control
+#define PWM_O_2_DBRISE          0x000000EC  // PWM2 Dead-Band Rising-Edge Delay
+#define PWM_O_2_DBFALL          0x000000F0  // PWM2 Dead-Band
+                                            // Falling-Edge-Delay
+#define PWM_O_2_FLTSRC0         0x000000F4  // PWM2 Fault Source 0
+#define PWM_O_2_FLTSRC1         0x000000F8  // PWM2 Fault Source 1
+#define PWM_O_2_MINFLTPER       0x000000FC  // PWM2 Minimum Fault Period
+#define PWM_O_3_CTL             0x00000100  // PWM3 Control
+#define PWM_O_3_INTEN           0x00000104  // PWM3 Interrupt and Trigger
+                                            // Enable
+#define PWM_O_3_RIS             0x00000108  // PWM3 Raw Interrupt Status
+#define PWM_O_3_ISC             0x0000010C  // PWM3 Interrupt Status and Clear
+#define PWM_O_3_LOAD            0x00000110  // PWM3 Load
+#define PWM_O_3_COUNT           0x00000114  // PWM3 Counter
+#define PWM_O_3_CMPA            0x00000118  // PWM3 Compare A
+#define PWM_O_3_CMPB            0x0000011C  // PWM3 Compare B
+#define PWM_O_3_GENA            0x00000120  // PWM3 Generator A Control
+#define PWM_O_3_GENB            0x00000124  // PWM3 Generator B Control
+#define PWM_O_3_DBCTL           0x00000128  // PWM3 Dead-Band Control
+#define PWM_O_3_DBRISE          0x0000012C  // PWM3 Dead-Band Rising-Edge Delay
+#define PWM_O_3_DBFALL          0x00000130  // PWM3 Dead-Band
+                                            // Falling-Edge-Delay
+#define PWM_O_3_FLTSRC0         0x00000134  // PWM3 Fault Source 0
+#define PWM_O_3_FLTSRC1         0x00000138  // PWM3 Fault Source 1
+#define PWM_O_3_MINFLTPER       0x0000013C  // PWM3 Minimum Fault Period
+#define PWM_O_0_FLTSEN          0x00000800  // PWM0 Fault Pin Logic Sense
+#define PWM_O_0_FLTSTAT0        0x00000804  // PWM0 Fault Status 0
+#define PWM_O_0_FLTSTAT1        0x00000808  // PWM0 Fault Status 1
+#define PWM_O_1_FLTSEN          0x00000880  // PWM1 Fault Pin Logic Sense
+#define PWM_O_1_FLTSTAT0        0x00000884  // PWM1 Fault Status 0
+#define PWM_O_1_FLTSTAT1        0x00000888  // PWM1 Fault Status 1
+#define PWM_O_2_FLTSEN          0x00000900  // PWM2 Fault Pin Logic Sense
+#define PWM_O_2_FLTSTAT0        0x00000904  // PWM2 Fault Status 0
+#define PWM_O_2_FLTSTAT1        0x00000908  // PWM2 Fault Status 1
+#define PWM_O_3_FLTSEN          0x00000980  // PWM3 Fault Pin Logic Sense
+#define PWM_O_3_FLTSTAT0        0x00000984  // PWM3 Fault Status 0
+#define PWM_O_3_FLTSTAT1        0x00000988  // PWM3 Fault Status 1
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM Master Control
+// register.
+//
+//*****************************************************************************
+#define PWM_CTL_GLOBALSYNC3     0x00000008  // Update PWM Generator 3.
+#define PWM_CTL_GLOBALSYNC2     0x00000004  // Update PWM Generator 2.
+#define PWM_CTL_GLOBALSYNC1     0x00000002  // Update PWM Generator 1.
+#define PWM_CTL_GLOBALSYNC0     0x00000001  // Update PWM Generator 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM Time Base Sync
+// register.
+//
+//*****************************************************************************
+#define PWM_SYNC_SYNC3          0x00000008  // Reset generator 3 counter
+#define PWM_SYNC_SYNC2          0x00000004  // Reset generator 2 counter
+#define PWM_SYNC_SYNC1          0x00000002  // Reset generator 1 counter
+#define PWM_SYNC_SYNC0          0x00000001  // Reset generator 0 counter
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM Output Enable
+// register.
+//
+//*****************************************************************************
+#define PWM_ENABLE_PWM7EN       0x00000080  // PWM7 pin enable
+#define PWM_ENABLE_PWM6EN       0x00000040  // PWM6 pin enable
+#define PWM_ENABLE_PWM5EN       0x00000020  // PWM5 pin enable
+#define PWM_ENABLE_PWM4EN       0x00000010  // PWM4 pin enable
+#define PWM_ENABLE_PWM3EN       0x00000008  // PWM3 pin enable
+#define PWM_ENABLE_PWM2EN       0x00000004  // PWM2 pin enable
+#define PWM_ENABLE_PWM1EN       0x00000002  // PWM1 pin enable
+#define PWM_ENABLE_PWM0EN       0x00000001  // PWM0 pin enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM Inversion register.
+//
+//*****************************************************************************
+#define PWM_INVERT_PWM7INV      0x00000080  // PWM7 pin invert
+#define PWM_INVERT_PWM6INV      0x00000040  // PWM6 pin invert
+#define PWM_INVERT_PWM5INV      0x00000020  // PWM5 pin invert
+#define PWM_INVERT_PWM4INV      0x00000010  // PWM4 pin invert
+#define PWM_INVERT_PWM3INV      0x00000008  // PWM3 pin invert
+#define PWM_INVERT_PWM2INV      0x00000004  // PWM2 pin invert
+#define PWM_INVERT_PWM1INV      0x00000002  // PWM1 pin invert
+#define PWM_INVERT_PWM0INV      0x00000001  // PWM0 pin invert
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM Fault register.
+//
+//*****************************************************************************
+#define PWM_FAULT_FAULT7        0x00000080  // PWM7 pin fault
+#define PWM_FAULT_FAULT6        0x00000040  // PWM6 pin fault
+#define PWM_FAULT_FAULT5        0x00000020  // PWM5 pin fault
+#define PWM_FAULT_FAULT4        0x00000010  // PWM4 pin fault
+#define PWM_FAULT_FAULT3        0x00000008  // PWM3 pin fault
+#define PWM_FAULT_FAULT2        0x00000004  // PWM2 pin fault
+#define PWM_FAULT_FAULT1        0x00000002  // PWM1 pin fault
+#define PWM_FAULT_FAULT0        0x00000001  // PWM0 pin fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM Status register.
+//
+//*****************************************************************************
+#define PWM_STATUS_FAULT3       0x00000008  // Fault3 Interrupt Status.
+#define PWM_STATUS_FAULT2       0x00000004  // Fault2 Interrupt Status.
+#define PWM_STATUS_FAULT1       0x00000002  // Fault1 Interrupt Status.
+#define PWM_STATUS_FAULT0       0x00000001  // Fault0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the PWM Generator standard offsets.
+//
+//*****************************************************************************
+#define PWM_O_X_CTL             0x00000000  // Gen Control Reg
+#define PWM_O_X_INTEN           0x00000004  // Gen Int/Trig Enable Reg
+#define PWM_O_X_RIS             0x00000008  // Gen Raw Int Status Reg
+#define PWM_O_X_ISC             0x0000000C  // Gen Int Status Reg
+#define PWM_O_X_LOAD            0x00000010  // Gen Load Reg
+#define PWM_O_X_COUNT           0x00000014  // Gen Counter Reg
+#define PWM_O_X_CMPA            0x00000018  // Gen Compare A Reg
+#define PWM_O_X_CMPB            0x0000001C  // Gen Compare B Reg
+#define PWM_O_X_GENA            0x00000020  // Gen Generator A Ctrl Reg
+#define PWM_O_X_GENB            0x00000024  // Gen Generator B Ctrl Reg
+#define PWM_O_X_DBCTL           0x00000028  // Gen Dead Band Ctrl Reg
+#define PWM_O_X_DBRISE          0x0000002C  // Gen DB Rising Edge Delay Reg
+#define PWM_O_X_DBFALL          0x00000030  // Gen DB Falling Edge Delay Reg
+#define PWM_O_X_FLTSRC0         0x00000034  // Fault pin, comparator condition
+#define PWM_O_X_FLTSRC1         0x00000038  // Digital comparator condition
+#define PWM_O_X_MINFLTPER       0x0000003C  // Fault minimum period extension
+#define PWM_GEN_0_OFFSET        0x00000040  // PWM0 base
+#define PWM_GEN_1_OFFSET        0x00000080  // PWM1 base
+#define PWM_GEN_2_OFFSET        0x000000C0  // PWM2 base
+#define PWM_GEN_3_OFFSET        0x00000100  // PWM3 base
+
+//*****************************************************************************
+//
+// The following are defines for the PWM_X Control Register bit definitions.
+//
+//*****************************************************************************
+#define PWM_X_CTL_LATCH         0x00040000  // Latch Fault Input.
+#define PWM_X_CTL_MINFLTPER     0x00020000  // Minimum fault period enabled
+#define PWM_X_CTL_FLTSRC        0x00010000  // Fault Condition Source.
+#define PWM_X_CTL_DBFALLUPD_M   0x0000C000  // Specifies the update mode for
+                                            // the PWMnDBFALL register.
+#define PWM_X_CTL_DBFALLUPD_I   0x00000000  // Immediate
+#define PWM_X_CTL_DBFALLUPD_LS  0x00008000  // Locally Synchronized
+#define PWM_X_CTL_DBFALLUPD_GS  0x0000C000  // Globally Synchronized
+#define PWM_X_CTL_DBRISEUPD_M   0x00003000  // PWMnDBRISE Update Mode.
+#define PWM_X_CTL_DBRISEUPD_I   0x00000000  // Immediate
+#define PWM_X_CTL_DBRISEUPD_LS  0x00002000  // Locally Synchronized
+#define PWM_X_CTL_DBRISEUPD_GS  0x00003000  // Globally Synchronized
+#define PWM_X_CTL_DBCTLUPD_M    0x00000C00  // PWMnDBCTL Update Mode.
+#define PWM_X_CTL_DBCTLUPD_I    0x00000000  // Immediate
+#define PWM_X_CTL_DBCTLUPD_LS   0x00000800  // Locally Synchronized
+#define PWM_X_CTL_DBCTLUPD_GS   0x00000C00  // Globally Synchronized
+#define PWM_X_CTL_GENBUPD_M     0x00000300  // PWMnGENB Update Mode.
+#define PWM_X_CTL_GENBUPD_I     0x00000000  // Immediate
+#define PWM_X_CTL_GENBUPD_LS    0x00000200  // Locally Synchronized
+#define PWM_X_CTL_GENBUPD_GS    0x00000300  // Globally Synchronized
+#define PWM_X_CTL_GENAUPD_M     0x000000C0  // PWMnGENA Update Mode.
+#define PWM_X_CTL_GENAUPD_I     0x00000000  // Immediate
+#define PWM_X_CTL_GENAUPD_LS    0x00000080  // Locally Synchronized
+#define PWM_X_CTL_GENAUPD_GS    0x000000C0  // Globally Synchronized
+#define PWM_X_CTL_CMPBUPD       0x00000020  // Update mode for comp B reg
+#define PWM_X_CTL_CMPAUPD       0x00000010  // Update mode for comp A reg
+#define PWM_X_CTL_LOADUPD       0x00000008  // Update mode for the load reg
+#define PWM_X_CTL_DEBUG         0x00000004  // Debug mode
+#define PWM_X_CTL_MODE          0x00000002  // Counter mode, down or up/down
+#define PWM_X_CTL_ENABLE        0x00000001  // Master enable for gen block
+
+//*****************************************************************************
+//
+// The following are defines for the PWM Generator extended offsets.
+//
+//*****************************************************************************
+#define PWM_O_X_FLTSEN          0x00000000  // Fault logic sense
+#define PWM_O_X_FLTSTAT0        0x00000004  // Pin and comparator status
+#define PWM_O_X_FLTSTAT1        0x00000008  // Digital comparator status
+#define PWM_EXT_0_OFFSET        0x00000800  // PWM0 extended base
+#define PWM_EXT_1_OFFSET        0x00000880  // PWM1 extended base
+#define PWM_EXT_2_OFFSET        0x00000900  // PWM2 extended base
+#define PWM_EXT_3_OFFSET        0x00000980  // PWM3 extended base
+
+//*****************************************************************************
+//
+// The following are defines for the PWM_X Interrupt/Trigger Enable Register
+// bit definitions.
+//
+//*****************************************************************************
+#define PWM_X_INTEN_TRCMPBD     0x00002000  // Trig if COUNT = CMPB D
+#define PWM_X_INTEN_TRCMPBU     0x00001000  // Trig if COUNT = CMPB U
+#define PWM_X_INTEN_TRCMPAD     0x00000800  // Trig if COUNT = CMPA D
+#define PWM_X_INTEN_TRCMPAU     0x00000400  // Trig if COUNT = CMPA U
+#define PWM_X_INTEN_TRCNTLOAD   0x00000200  // Trig if COUNT = LOAD
+#define PWM_X_INTEN_TRCNTZERO   0x00000100  // Trig if COUNT = 0
+#define PWM_X_INTEN_INTCMPBD    0x00000020  // Int if COUNT = CMPA D
+#define PWM_X_INTEN_INTCMPBU    0x00000010  // Int if COUNT = CMPA U
+#define PWM_X_INTEN_INTCMPAD    0x00000008  // Int if COUNT = CMPA D
+#define PWM_X_INTEN_INTCMPAU    0x00000004  // Int if COUNT = CMPA U
+#define PWM_X_INTEN_INTCNTLOAD  0x00000002  // Int if COUNT = LOAD
+#define PWM_X_INTEN_INTCNTZERO  0x00000001  // Int if COUNT = 0
+
+//*****************************************************************************
+//
+// The following are defines for the PWM_X Raw Interrupt Status Register bit
+// definitions.
+//
+//*****************************************************************************
+#define PWM_X_RIS_INTCMPBD      0x00000020  // PWM_X_COUNT = PWM_X_CMPB D int
+#define PWM_X_RIS_INTCMPBU      0x00000010  // PWM_X_COUNT = PWM_X_CMPB U int
+#define PWM_X_RIS_INTCMPAD      0x00000008  // PWM_X_COUNT = PWM_X_CMPA D int
+#define PWM_X_RIS_INTCMPAU      0x00000004  // PWM_X_COUNT = PWM_X_CMPA U int
+#define PWM_X_RIS_INTCNTLOAD    0x00000002  // PWM_X_COUNT = PWM_X_LOAD int
+#define PWM_X_RIS_INTCNTZERO    0x00000001  // PWM_X_COUNT = 0 int
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INTEN register.
+//
+//*****************************************************************************
+#define PWM_INTEN_INTFAULT3     0x00080000  // Interrupt Fault 3.
+#define PWM_INTEN_INTFAULT2     0x00040000  // Interrupt Fault 2.
+#define PWM_INTEN_INTFAULT1     0x00020000  // Interrupt Fault 1.
+#define PWM_INTEN_INTFAULT      0x00010000  // Fault Interrupt Enable.
+#define PWM_INTEN_INTFAULT0     0x00010000  // Interrupt Fault 0.
+#define PWM_INTEN_INTPWM3       0x00000008  // PWM3 Interrupt Enable.
+#define PWM_INTEN_INTPWM2       0x00000004  // PWM2 Interrupt Enable.
+#define PWM_INTEN_INTPWM1       0x00000002  // PWM1 Interrupt Enable.
+#define PWM_INTEN_INTPWM0       0x00000001  // PWM0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_RIS register.
+//
+//*****************************************************************************
+#define PWM_RIS_INTFAULT3       0x00080000  // Interrupt Fault PWM 3.
+#define PWM_RIS_INTFAULT2       0x00040000  // Interrupt Fault PWM 2.
+#define PWM_RIS_INTFAULT1       0x00020000  // Interrupt Fault PWM 1.
+#define PWM_RIS_INTFAULT0       0x00010000  // Interrupt Fault PWM 0.
+#define PWM_RIS_INTFAULT        0x00010000  // Fault Interrupt Asserted.
+#define PWM_RIS_INTPWM3         0x00000008  // PWM3 Interrupt Asserted.
+#define PWM_RIS_INTPWM2         0x00000004  // PWM2 Interrupt Asserted.
+#define PWM_RIS_INTPWM1         0x00000002  // PWM1 Interrupt Asserted.
+#define PWM_RIS_INTPWM0         0x00000001  // PWM0 Interrupt Asserted.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ISC register.
+//
+//*****************************************************************************
+#define PWM_ISC_INTFAULT3       0x00080000  // FAULT3 Interrupt Asserted.
+#define PWM_ISC_INTFAULT2       0x00040000  // FAULT2 Interrupt Asserted.
+#define PWM_ISC_INTFAULT1       0x00020000  // FAULT1 Interrupt Asserted.
+#define PWM_ISC_INTFAULT        0x00010000  // Fault Interrupt Asserted.
+#define PWM_ISC_INTFAULT0       0x00010000  // FAULT0 Interrupt Asserted.
+#define PWM_ISC_INTPWM3         0x00000008  // PWM3 Interrupt Status.
+#define PWM_ISC_INTPWM2         0x00000004  // PWM2 Interrupt Status.
+#define PWM_ISC_INTPWM1         0x00000002  // PWM1 Interrupt Status.
+#define PWM_ISC_INTPWM0         0x00000001  // PWM0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_ISC register.
+//
+//*****************************************************************************
+#define PWM_X_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt.
+#define PWM_X_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt.
+#define PWM_X_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt.
+#define PWM_X_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt.
+#define PWM_X_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt.
+#define PWM_X_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_LOAD register.
+//
+//*****************************************************************************
+#define PWM_X_LOAD_M            0x0000FFFF  // Counter Load Value.
+#define PWM_X_LOAD_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_COUNT register.
+//
+//*****************************************************************************
+#define PWM_X_COUNT_M           0x0000FFFF  // Counter Value.
+#define PWM_X_COUNT_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_CMPA register.
+//
+//*****************************************************************************
+#define PWM_X_CMPA_M            0x0000FFFF  // Comparator A Value.
+#define PWM_X_CMPA_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_CMPB register.
+//
+//*****************************************************************************
+#define PWM_X_CMPB_M            0x0000FFFF  // Comparator B Value.
+#define PWM_X_CMPB_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_GENA register.
+//
+//*****************************************************************************
+#define PWM_X_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENA_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENA_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENA_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENA_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENA_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENA_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENA_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENA_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENA_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENA_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENA_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_GENB register.
+//
+//*****************************************************************************
+#define PWM_X_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENB_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENB_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENB_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENB_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENB_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENB_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENB_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENB_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENB_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENB_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENB_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_DBCTL register.
+//
+//*****************************************************************************
+#define PWM_X_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_DBRISE register.
+//
+//*****************************************************************************
+#define PWM_X_DBRISE_DELAY_M    0x00000FFF  // Dead-Band Rise Delay.
+#define PWM_X_DBRISE_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_DBFALL register.
+//
+//*****************************************************************************
+#define PWM_X_DBFALL_DELAY_M    0x00000FFF  // Dead-Band Fall Delay.
+#define PWM_X_DBFALL_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_FAULTVAL register.
+//
+//*****************************************************************************
+#define PWM_FAULTVAL_PWM7       0x00000080  // PWM7 Fault Value.
+#define PWM_FAULTVAL_PWM6       0x00000040  // PWM6 Fault Value.
+#define PWM_FAULTVAL_PWM5       0x00000020  // PWM5 Fault Value.
+#define PWM_FAULTVAL_PWM4       0x00000010  // PWM4 Fault Value.
+#define PWM_FAULTVAL_PWM3       0x00000008  // PWM3 Fault Value.
+#define PWM_FAULTVAL_PWM2       0x00000004  // PWM2 Fault Value.
+#define PWM_FAULTVAL_PWM1       0x00000002  // PWM1 Fault Value.
+#define PWM_FAULTVAL_PWM0       0x00000001  // PWM0 Fault Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_MINFLTPER
+// register.
+//
+//*****************************************************************************
+#define PWM_X_MINFLTPER_M       0x0000FFFF  // Minimum Fault Period.
+#define PWM_X_MINFLTPER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_FLTSEN register.
+//
+//*****************************************************************************
+#define PWM_X_FLTSEN_FAULT3     0x00000008  // Fault3 Sense.
+#define PWM_X_FLTSEN_FAULT2     0x00000004  // Fault2 Sense.
+#define PWM_X_FLTSEN_FAULT1     0x00000002  // Fault1 Sense.
+#define PWM_X_FLTSEN_FAULT0     0x00000001  // Fault0 Sense.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_FLTSRC0
+// register.
+//
+//*****************************************************************************
+#define PWM_X_FLTSRC0_FAULT3    0x00000008  // Fault3.
+#define PWM_X_FLTSRC0_FAULT2    0x00000004  // Fault2.
+#define PWM_X_FLTSRC0_FAULT1    0x00000002  // Fault1.
+#define PWM_X_FLTSRC0_FAULT0    0x00000001  // Fault0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_FLTSTAT0
+// register.
+//
+//*****************************************************************************
+#define PWM_X_FLTSTAT0_FAULT3   0x00000008  // Fault Input 3.
+#define PWM_X_FLTSTAT0_FAULT2   0x00000004  // Fault Input 2.
+#define PWM_X_FLTSTAT0_FAULT1   0x00000002  // Fault Input 1.
+#define PWM_X_FLTSTAT0_FAULT0   0x00000001  // Fault Input 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_FLTSRC1
+// register.
+//
+//*****************************************************************************
+#define PWM_X_FLTSRC1_DCMP7     0x00000080  // Digital Comparator 7.
+#define PWM_X_FLTSRC1_DCMP6     0x00000040  // Digital Comparator 6.
+#define PWM_X_FLTSRC1_DCMP5     0x00000020  // Digital Comparator 5.
+#define PWM_X_FLTSRC1_DCMP4     0x00000010  // Digital Comparator 4.
+#define PWM_X_FLTSRC1_DCMP3     0x00000008  // Digital Comparator 3.
+#define PWM_X_FLTSRC1_DCMP2     0x00000004  // Digital Comparator 2.
+#define PWM_X_FLTSRC1_DCMP1     0x00000002  // Digital Comparator 1.
+#define PWM_X_FLTSRC1_DCMP0     0x00000001  // Digital Comparator 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_X_FLTSTAT1
+// register.
+//
+//*****************************************************************************
+#define PWM_X_FLTSTAT1_DCMP7    0x00000080  // Digital Comparator 7 Trigger.
+#define PWM_X_FLTSTAT1_DCMP6    0x00000040  // Digital Comparator 6 Trigger.
+#define PWM_X_FLTSTAT1_DCMP5    0x00000020  // Digital Comparator 5 Trigger.
+#define PWM_X_FLTSTAT1_DCMP4    0x00000010  // Digital Comparator 4 Trigger.
+#define PWM_X_FLTSTAT1_DCMP3    0x00000008  // Digital Comparator 3 Trigger.
+#define PWM_X_FLTSTAT1_DCMP2    0x00000004  // Digital Comparator 2 Trigger.
+#define PWM_X_FLTSTAT1_DCMP1    0x00000002  // Digital Comparator 1 Trigger.
+#define PWM_X_FLTSTAT1_DCMP0    0x00000001  // Digital Comparator 0 Trigger.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the PWM Master
+// Control register.
+//
+//*****************************************************************************
+#define PWM_CTL_GLOBAL_SYNC2    0x00000004  // Global sync generator 2
+#define PWM_CTL_GLOBAL_SYNC1    0x00000002  // Global sync generator 1
+#define PWM_CTL_GLOBAL_SYNC0    0x00000001  // Global sync generator 0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the PWM Interrupt Register bit
+// definitions.
+//
+//*****************************************************************************
+#define PWM_INT_INTFAULT        0x00010000  // Fault interrupt pending
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the PWM Status
+// register.
+//
+//*****************************************************************************
+#define PWM_STATUS_FAULT        0x00000001  // Fault status
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the PWM_X Interrupt Status Register
+// bit definitions.
+//
+//*****************************************************************************
+#define PWM_X_INT_INTCMPBD      0x00000020  // PWM_X_COUNT = PWM_X_CMPB D rcvd
+#define PWM_X_INT_INTCMPBU      0x00000010  // PWM_X_COUNT = PWM_X_CMPB U rcvd
+#define PWM_X_INT_INTCMPAD      0x00000008  // PWM_X_COUNT = PWM_X_CMPA D rcvd
+#define PWM_X_INT_INTCMPAU      0x00000004  // PWM_X_COUNT = PWM_X_CMPA U rcvd
+#define PWM_X_INT_INTCNTLOAD    0x00000002  // PWM_X_COUNT = PWM_X_LOAD rcvd
+#define PWM_X_INT_INTCNTZERO    0x00000001  // PWM_X_COUNT = 0 received
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the PWM_X Generator A/B Control
+// Register bit definitions.
+//
+//*****************************************************************************
+#define PWM_X_GEN_Y_ACTCMPBD    0x00000C00  // Act PWM_X_COUNT = PWM_X_CMPB D
+#define PWM_X_GEN_Y_ACTCMPBU    0x00000300  // Act PWM_X_COUNT = PWM_X_CMPB U
+#define PWM_X_GEN_Y_ACTCMPAD    0x000000C0  // Act PWM_X_COUNT = PWM_X_CMPA D
+#define PWM_X_GEN_Y_ACTCMPAU    0x00000030  // Act PWM_X_COUNT = PWM_X_CMPA U
+#define PWM_X_GEN_Y_ACTLOAD     0x0000000C  // Act PWM_X_COUNT = PWM_X_LOAD
+#define PWM_X_GEN_Y_ACTZERO     0x00000003  // Act PWM_X_COUNT = 0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the PWM_X Generator A/B Control
+// Register action definitions.
+//
+//*****************************************************************************
+#define PWM_GEN_ACT_ONE         0x00000003  // Set the output signal to one
+#define PWM_GEN_ACT_ZERO        0x00000002  // Set the output signal to zero
+#define PWM_GEN_ACT_INV         0x00000001  // Invert the output signal
+#define PWM_GEN_ACT_NONE        0x00000000  // Do nothing
+#define PWM_GEN_ACT_B_DN_SHIFT  10          // Shift amount for the B dn action
+#define PWM_GEN_ACT_B_UP_SHIFT  8           // Shift amount for the B up action
+#define PWM_GEN_ACT_A_DN_SHIFT  6           // Shift amount for the A dn action
+#define PWM_GEN_ACT_A_UP_SHIFT  4           // Shift amount for the A up action
+#define PWM_GEN_ACT_LOAD_SHIFT  2           // Shift amount for the load action
+#define PWM_GEN_ACT_ZERO_SHIFT  0           // Shift amount for the zero action
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the PWM_X Dead Band Control
+// Register bit definitions.
+//
+//*****************************************************************************
+#define PWM_DBCTL_ENABLE        0x00000001  // Enable dead band insertion
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the PWM Register reset values.
+//
+//*****************************************************************************
+#define PWM_RV_X_DBCTL          0x00000000  // Control the dead band generator
+#define PWM_RV_STATUS           0x00000000  // Status
+#define PWM_RV_X_ISC            0x00000000  // Interrupt status and clearing
+#define PWM_RV_X_RIS            0x00000000  // Raw interrupt status
+#define PWM_RV_X_CTL            0x00000000  // Master control of the PWM
+                                            // generator block
+#define PWM_RV_SYNC             0x00000000  // Counter synch for PWM generators
+#define PWM_RV_X_DBFALL         0x00000000  // The dead band falling edge delay
+                                            // count
+#define PWM_RV_X_INTEN          0x00000000  // Interrupt and trigger enable
+#define PWM_RV_X_LOAD           0x00000000  // The load value for the counter
+#define PWM_RV_X_GENA           0x00000000  // Controls PWM generator A
+#define PWM_RV_CTL              0x00000000  // Master control of the PWM module
+#define PWM_RV_FAULT            0x00000000  // Fault handling for the PWM
+                                            // output pins
+#define PWM_RV_RIS              0x00000000  // Raw interrupt status
+#define PWM_RV_X_CMPA           0x00000000  // The comparator A value
+#define PWM_RV_INVERT           0x00000000  // Inversion control for PWM output
+                                            // pins
+#define PWM_RV_X_DBRISE         0x00000000  // The dead band rising edge delay
+                                            // count
+#define PWM_RV_ENABLE           0x00000000  // Master enable for the PWM output
+                                            // pins
+#define PWM_RV_X_GENB           0x00000000  // Controls PWM generator B
+#define PWM_RV_X_CMPB           0x00000000  // The comparator B value
+#define PWM_RV_ISC              0x00000000  // Interrupt status and clearing
+#define PWM_RV_INTEN            0x00000000  // Interrupt enable
+#define PWM_RV_X_COUNT          0x00000000  // The current counter value
+
+#endif
+
+#endif // __HW_PWM_H__


Property changes on: trunk/src/platform/lm3s/hw_pwm.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_qei.h
===================================================================
--- trunk/src/platform/lm3s/hw_qei.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_qei.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,201 @@
+//*****************************************************************************
+//
+// hw_qei.h - Macros used when accessing the QEI hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_QEI_H__
+#define __HW_QEI_H__
+
+//*****************************************************************************
+//
+// The following are defines for the QEI register offsets.
+//
+//*****************************************************************************
+#define QEI_O_CTL               0x00000000  // Configuration and control reg.
+#define QEI_O_STAT              0x00000004  // Status register
+#define QEI_O_POS               0x00000008  // Current position register
+#define QEI_O_MAXPOS            0x0000000C  // Maximum position register
+#define QEI_O_LOAD              0x00000010  // Velocity timer load register
+#define QEI_O_TIME              0x00000014  // Velocity timer register
+#define QEI_O_COUNT             0x00000018  // Velocity pulse count register
+#define QEI_O_SPEED             0x0000001C  // Velocity speed register
+#define QEI_O_INTEN             0x00000020  // Interrupt enable register
+#define QEI_O_RIS               0x00000024  // Raw interrupt status register
+#define QEI_O_ISC               0x00000028  // Interrupt status register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_CTL register.
+//
+//*****************************************************************************
+#define QEI_CTL_FILTCNT_M       0x000F0000  // Input Filter Pre-Scale Count.
+#define QEI_CTL_FILTEN          0x00002000  // Enable Input Filter.
+#define QEI_CTL_STALLEN         0x00001000  // Stall enable
+#define QEI_CTL_INVI            0x00000800  // Invert Index input
+#define QEI_CTL_INVB            0x00000400  // Invert PhB input
+#define QEI_CTL_INVA            0x00000200  // Invert PhA input
+#define QEI_CTL_VELDIV_M        0x000001C0  // Velocity predivider mask
+#define QEI_CTL_VELDIV_1        0x00000000  // Predivide by 1
+#define QEI_CTL_VELDIV_2        0x00000040  // Predivide by 2
+#define QEI_CTL_VELDIV_4        0x00000080  // Predivide by 4
+#define QEI_CTL_VELDIV_8        0x000000C0  // Predivide by 8
+#define QEI_CTL_VELDIV_16       0x00000100  // Predivide by 16
+#define QEI_CTL_VELDIV_32       0x00000140  // Predivide by 32
+#define QEI_CTL_VELDIV_64       0x00000180  // Predivide by 64
+#define QEI_CTL_VELDIV_128      0x000001C0  // Predivide by 128
+#define QEI_CTL_VELEN           0x00000020  // Velocity enable
+#define QEI_CTL_RESMODE         0x00000010  // Position counter reset mode
+#define QEI_CTL_CAPMODE         0x00000008  // Edge capture mode
+#define QEI_CTL_SIGMODE         0x00000004  // Encoder signaling mode
+#define QEI_CTL_SWAP            0x00000002  // Swap input signals
+#define QEI_CTL_ENABLE          0x00000001  // QEI enable
+#define QEI_CTL_FILTCNT_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_STAT register.
+//
+//*****************************************************************************
+#define QEI_STAT_DIRECTION      0x00000002  // Direction of rotation
+#define QEI_STAT_ERROR          0x00000001  // Signalling error detected
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_POS register.
+//
+//*****************************************************************************
+#define QEI_POS_M               0xFFFFFFFF  // Current encoder position
+#define QEI_POS_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_MAXPOS register.
+//
+//*****************************************************************************
+#define QEI_MAXPOS_M            0xFFFFFFFF  // Maximum encoder position
+#define QEI_MAXPOS_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_LOAD register.
+//
+//*****************************************************************************
+#define QEI_LOAD_M              0xFFFFFFFF  // Velocity timer load value
+#define QEI_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_TIME register.
+//
+//*****************************************************************************
+#define QEI_TIME_M              0xFFFFFFFF  // Velocity timer current value
+#define QEI_TIME_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_COUNT register.
+//
+//*****************************************************************************
+#define QEI_COUNT_M             0xFFFFFFFF  // Encoder running pulse count
+#define QEI_COUNT_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_SPEED register.
+//
+//*****************************************************************************
+#define QEI_SPEED_M             0xFFFFFFFF  // Encoder pulse count
+#define QEI_SPEED_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_INTEN register.
+//
+//*****************************************************************************
+#define QEI_INTEN_ERROR         0x00000008  // Phase error detected
+#define QEI_INTEN_DIR           0x00000004  // Direction change
+#define QEI_INTEN_TIMER         0x00000002  // Velocity timer expired
+#define QEI_INTEN_INDEX         0x00000001  // Index pulse detected
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_RIS register.
+//
+//*****************************************************************************
+#define QEI_RIS_ERROR           0x00000008  // Phase error detected
+#define QEI_RIS_DIR             0x00000004  // Direction change
+#define QEI_RIS_TIMER           0x00000002  // Velocity timer expired
+#define QEI_RIS_INDEX           0x00000001  // Index pulse detected
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_ISC register.
+//
+//*****************************************************************************
+#define QEI_ISC_ERROR           0x00000008  // Phase Error Interrupt.
+#define QEI_ISC_DIR             0x00000004  // Direction Change Interrupt.
+#define QEI_ISC_TIMER           0x00000002  // Velocity Timer Expired
+                                            // Interrupt.
+#define QEI_ISC_INDEX           0x00000001  // Index Pulse Interrupt.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the QEI_ISC
+// register.
+//
+//*****************************************************************************
+#define QEI_INT_ERROR           0x00000008  // Phase error detected
+#define QEI_INT_DIR             0x00000004  // Direction change
+#define QEI_INT_TIMER           0x00000002  // Velocity timer expired
+#define QEI_INT_INDEX           0x00000001  // Index pulse detected
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the reset values for the QEI
+// registers.
+//
+//*****************************************************************************
+#define QEI_RV_POS              0x00000000  // Current position register
+#define QEI_RV_LOAD             0x00000000  // Velocity timer load register
+#define QEI_RV_CTL              0x00000000  // Configuration and control reg.
+#define QEI_RV_RIS              0x00000000  // Raw interrupt status register
+#define QEI_RV_ISC              0x00000000  // Interrupt status register
+#define QEI_RV_SPEED            0x00000000  // Velocity speed register
+#define QEI_RV_INTEN            0x00000000  // Interrupt enable register
+#define QEI_RV_STAT             0x00000000  // Status register
+#define QEI_RV_COUNT            0x00000000  // Velocity pulse count register
+#define QEI_RV_MAXPOS           0x00000000  // Maximum position register
+#define QEI_RV_TIME             0x00000000  // Velocity timer register
+
+#endif
+
+#endif // __HW_QEI_H__


Property changes on: trunk/src/platform/lm3s/hw_qei.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_ssi.h
===================================================================
--- trunk/src/platform/lm3s/hw_ssi.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_ssi.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,219 +1,220 @@
-//*****************************************************************************
-//
-// hw_ssi.h - Macros used when accessing the SSI hardware.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_SSI_H__
-#define __HW_SSI_H__
-
-//*****************************************************************************
-//
-// The following are defines for the SSI register offsets.
-//
-//*****************************************************************************
-#define SSI_O_CR0               0x00000000  // Control register 0
-#define SSI_O_CR1               0x00000004  // Control register 1
-#define SSI_O_DR                0x00000008  // Data register
-#define SSI_O_SR                0x0000000C  // Status register
-#define SSI_O_CPSR              0x00000010  // Clock prescale register
-#define SSI_O_IM                0x00000014  // Int mask set and clear register
-#define SSI_O_RIS               0x00000018  // Raw interrupt register
-#define SSI_O_MIS               0x0000001C  // Masked interrupt register
-#define SSI_O_ICR               0x00000020  // Interrupt clear register
-#define SSI_O_DMACTL            0x00000024  // SSI DMA Control
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI Control register 0.
-//
-//*****************************************************************************
-#define SSI_CR0_SCR_M           0x0000FF00  // SSI Serial Clock Rate.
-#define SSI_CR0_SPH             0x00000080  // SSPCLKOUT phase
-#define SSI_CR0_SPO             0x00000040  // SSPCLKOUT polarity
-#define SSI_CR0_FRF_M           0x00000030  // Frame format mask
-#define SSI_CR0_FRF_MOTO        0x00000000  // Motorola SPI frame format
-#define SSI_CR0_FRF_TI          0x00000010  // TI sync serial frame format
-#define SSI_CR0_FRF_NMW         0x00000020  // National Microwire frame format
-#define SSI_CR0_DSS_M           0x0000000F  // SSI Data Size Select.
-#define SSI_CR0_DSS_4           0x00000003  // 4 bit data
-#define SSI_CR0_DSS_5           0x00000004  // 5 bit data
-#define SSI_CR0_DSS_6           0x00000005  // 6 bit data
-#define SSI_CR0_DSS_7           0x00000006  // 7 bit data
-#define SSI_CR0_DSS_8           0x00000007  // 8 bit data
-#define SSI_CR0_DSS_9           0x00000008  // 9 bit data
-#define SSI_CR0_DSS_10          0x00000009  // 10 bit data
-#define SSI_CR0_DSS_11          0x0000000A  // 11 bit data
-#define SSI_CR0_DSS_12          0x0000000B  // 12 bit data
-#define SSI_CR0_DSS_13          0x0000000C  // 13 bit data
-#define SSI_CR0_DSS_14          0x0000000D  // 14 bit data
-#define SSI_CR0_DSS_15          0x0000000E  // 15 bit data
-#define SSI_CR0_DSS_16          0x0000000F  // 16 bit data
-#define SSI_CR0_SCR_S           8
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI Control register 1.
-//
-//*****************************************************************************
-#define SSI_CR1_SOD             0x00000008  // Slave mode output disable
-#define SSI_CR1_MS              0x00000004  // Master or slave mode select
-#define SSI_CR1_SSE             0x00000002  // Sync serial port enable
-#define SSI_CR1_LBM             0x00000001  // Loopback mode
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI Status register.
-//
-//*****************************************************************************
-#define SSI_SR_BSY              0x00000010  // SSI busy
-#define SSI_SR_RFF              0x00000008  // RX FIFO full
-#define SSI_SR_RNE              0x00000004  // RX FIFO not empty
-#define SSI_SR_TNF              0x00000002  // TX FIFO not full
-#define SSI_SR_TFE              0x00000001  // TX FIFO empty
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI clock prescale
-// register.
-//
-//*****************************************************************************
-#define SSI_CPSR_CPSDVSR_M      0x000000FF  // SSI Clock Prescale Divisor.
-#define SSI_CPSR_CPSDVSR_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI_O_DR register.
-//
-//*****************************************************************************
-#define SSI_DR_DATA_M           0x0000FFFF  // SSI Receive/Transmit Data.
-#define SSI_DR_DATA_S           0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI_O_IM register.
-//
-//*****************************************************************************
-#define SSI_IM_TXIM             0x00000008  // SSI Transmit FIFO Interrupt
-                                            // Mask.
-#define SSI_IM_RXIM             0x00000004  // SSI Receive FIFO Interrupt Mask.
-#define SSI_IM_RTIM             0x00000002  // SSI Receive Time-Out Interrupt
-                                            // Mask.
-#define SSI_IM_RORIM            0x00000001  // SSI Receive Overrun Interrupt
-                                            // Mask.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI_O_RIS register.
-//
-//*****************************************************************************
-#define SSI_RIS_TXRIS           0x00000008  // SSI Transmit FIFO Raw Interrupt
-                                            // Status.
-#define SSI_RIS_RXRIS           0x00000004  // SSI Receive FIFO Raw Interrupt
-                                            // Status.
-#define SSI_RIS_RTRIS           0x00000002  // SSI Receive Time-Out Raw
-                                            // Interrupt Status.
-#define SSI_RIS_RORRIS          0x00000001  // SSI Receive Overrun Raw
-                                            // Interrupt Status.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI_O_MIS register.
-//
-//*****************************************************************************
-#define SSI_MIS_TXMIS           0x00000008  // SSI Transmit FIFO Masked
-                                            // Interrupt Status.
-#define SSI_MIS_RXMIS           0x00000004  // SSI Receive FIFO Masked
-                                            // Interrupt Status.
-#define SSI_MIS_RTMIS           0x00000002  // SSI Receive Time-Out Masked
-                                            // Interrupt Status.
-#define SSI_MIS_RORMIS          0x00000001  // SSI Receive Overrun Masked
-                                            // Interrupt Status.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI_O_ICR register.
-//
-//*****************************************************************************
-#define SSI_ICR_RTIC            0x00000002  // SSI Receive Time-Out Interrupt
-                                            // Clear.
-#define SSI_ICR_RORIC           0x00000001  // SSI Receive Overrun Interrupt
-                                            // Clear.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SSI_O_DMACTL register.
-//
-//*****************************************************************************
-#define SSI_DMACTL_TXDMAE       0x00000002  // Transmit DMA Enable.
-#define SSI_DMACTL_RXDMAE       0x00000001  // Receive DMA Enable.
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SSI Control
-// register 0.
-//
-//*****************************************************************************
-#define SSI_CR0_SCR             0x0000FF00  // Serial clock rate
-#define SSI_CR0_FRF_MASK        0x00000030  // Frame format mask
-#define SSI_CR0_DSS             0x0000000F  // Data size select
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SSI clock
-// prescale register.
-//
-//*****************************************************************************
-#define SSI_CPSR_CPSDVSR_MASK   0x000000FF  // Clock prescale
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the SSI controller's FIFO size.
-//
-//*****************************************************************************
-#define TX_FIFO_SIZE            (8)         // Number of entries in the TX FIFO
-#define RX_FIFO_SIZE            (8)         // Number of entries in the RX FIFO
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the interrupt
-// mask set and clear, raw interrupt, masked interrupt, and interrupt clear
-// registers.
-//
-//*****************************************************************************
-#define SSI_INT_TXFF            0x00000008  // TX FIFO interrupt
-#define SSI_INT_RXFF            0x00000004  // RX FIFO interrupt
-#define SSI_INT_RXTO            0x00000002  // RX timeout interrupt
-#define SSI_INT_RXOR            0x00000001  // RX overrun interrupt
-
-#endif
-
-#endif // __HW_SSI_H__
+//*****************************************************************************
+//
+// hw_ssi.h - Macros used when accessing the SSI hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_SSI_H__
+#define __HW_SSI_H__
+
+//*****************************************************************************
+//
+// The following are defines for the SSI register offsets.
+//
+//*****************************************************************************
+#define SSI_O_CR0               0x00000000  // Control register 0
+#define SSI_O_CR1               0x00000004  // Control register 1
+#define SSI_O_DR                0x00000008  // Data register
+#define SSI_O_SR                0x0000000C  // Status register
+#define SSI_O_CPSR              0x00000010  // Clock prescale register
+#define SSI_O_IM                0x00000014  // Int mask set and clear register
+#define SSI_O_RIS               0x00000018  // Raw interrupt register
+#define SSI_O_MIS               0x0000001C  // Masked interrupt register
+#define SSI_O_ICR               0x00000020  // Interrupt clear register
+#define SSI_O_DMACTL            0x00000024  // SSI DMA Control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI Control register 0.
+//
+//*****************************************************************************
+#define SSI_CR0_SCR_M           0x0000FF00  // SSI Serial Clock Rate.
+#define SSI_CR0_SPH             0x00000080  // SSPCLKOUT phase
+#define SSI_CR0_SPO             0x00000040  // SSPCLKOUT polarity
+#define SSI_CR0_FRF_M           0x00000030  // Frame format mask
+#define SSI_CR0_FRF_MOTO        0x00000000  // Motorola SPI frame format
+#define SSI_CR0_FRF_TI          0x00000010  // TI sync serial frame format
+#define SSI_CR0_FRF_NMW         0x00000020  // National Microwire frame format
+#define SSI_CR0_DSS_M           0x0000000F  // SSI Data Size Select.
+#define SSI_CR0_DSS_4           0x00000003  // 4 bit data
+#define SSI_CR0_DSS_5           0x00000004  // 5 bit data
+#define SSI_CR0_DSS_6           0x00000005  // 6 bit data
+#define SSI_CR0_DSS_7           0x00000006  // 7 bit data
+#define SSI_CR0_DSS_8           0x00000007  // 8 bit data
+#define SSI_CR0_DSS_9           0x00000008  // 9 bit data
+#define SSI_CR0_DSS_10          0x00000009  // 10 bit data
+#define SSI_CR0_DSS_11          0x0000000A  // 11 bit data
+#define SSI_CR0_DSS_12          0x0000000B  // 12 bit data
+#define SSI_CR0_DSS_13          0x0000000C  // 13 bit data
+#define SSI_CR0_DSS_14          0x0000000D  // 14 bit data
+#define SSI_CR0_DSS_15          0x0000000E  // 15 bit data
+#define SSI_CR0_DSS_16          0x0000000F  // 16 bit data
+#define SSI_CR0_SCR_S           8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI Control register 1.
+//
+//*****************************************************************************
+#define SSI_CR1_EOT             0x00000010  // End of Transmission.
+#define SSI_CR1_SOD             0x00000008  // Slave mode output disable
+#define SSI_CR1_MS              0x00000004  // Master or slave mode select
+#define SSI_CR1_SSE             0x00000002  // Sync serial port enable
+#define SSI_CR1_LBM             0x00000001  // Loopback mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI Status register.
+//
+//*****************************************************************************
+#define SSI_SR_BSY              0x00000010  // SSI busy
+#define SSI_SR_RFF              0x00000008  // RX FIFO full
+#define SSI_SR_RNE              0x00000004  // RX FIFO not empty
+#define SSI_SR_TNF              0x00000002  // TX FIFO not full
+#define SSI_SR_TFE              0x00000001  // TX FIFO empty
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI clock prescale
+// register.
+//
+//*****************************************************************************
+#define SSI_CPSR_CPSDVSR_M      0x000000FF  // SSI Clock Prescale Divisor.
+#define SSI_CPSR_CPSDVSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DR register.
+//
+//*****************************************************************************
+#define SSI_DR_DATA_M           0x0000FFFF  // SSI Receive/Transmit Data.
+#define SSI_DR_DATA_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_IM register.
+//
+//*****************************************************************************
+#define SSI_IM_TXIM             0x00000008  // SSI Transmit FIFO Interrupt
+                                            // Mask.
+#define SSI_IM_RXIM             0x00000004  // SSI Receive FIFO Interrupt Mask.
+#define SSI_IM_RTIM             0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Mask.
+#define SSI_IM_RORIM            0x00000001  // SSI Receive Overrun Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_RIS register.
+//
+//*****************************************************************************
+#define SSI_RIS_TXRIS           0x00000008  // SSI Transmit FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RXRIS           0x00000004  // SSI Receive FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RTRIS           0x00000002  // SSI Receive Time-Out Raw
+                                            // Interrupt Status.
+#define SSI_RIS_RORRIS          0x00000001  // SSI Receive Overrun Raw
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_MIS register.
+//
+//*****************************************************************************
+#define SSI_MIS_TXMIS           0x00000008  // SSI Transmit FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RXMIS           0x00000004  // SSI Receive FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RTMIS           0x00000002  // SSI Receive Time-Out Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RORMIS          0x00000001  // SSI Receive Overrun Masked
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_ICR register.
+//
+//*****************************************************************************
+#define SSI_ICR_RTIC            0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Clear.
+#define SSI_ICR_RORIC           0x00000001  // SSI Receive Overrun Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DMACTL register.
+//
+//*****************************************************************************
+#define SSI_DMACTL_TXDMAE       0x00000002  // Transmit DMA Enable.
+#define SSI_DMACTL_RXDMAE       0x00000001  // Receive DMA Enable.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SSI Control
+// register 0.
+//
+//*****************************************************************************
+#define SSI_CR0_SCR             0x0000FF00  // Serial clock rate
+#define SSI_CR0_FRF_MASK        0x00000030  // Frame format mask
+#define SSI_CR0_DSS             0x0000000F  // Data size select
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SSI clock
+// prescale register.
+//
+//*****************************************************************************
+#define SSI_CPSR_CPSDVSR_MASK   0x000000FF  // Clock prescale
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the SSI controller's FIFO size.
+//
+//*****************************************************************************
+#define TX_FIFO_SIZE            (8)         // Number of entries in the TX FIFO
+#define RX_FIFO_SIZE            (8)         // Number of entries in the RX FIFO
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the interrupt
+// mask set and clear, raw interrupt, masked interrupt, and interrupt clear
+// registers.
+//
+//*****************************************************************************
+#define SSI_INT_TXFF            0x00000008  // TX FIFO interrupt
+#define SSI_INT_RXFF            0x00000004  // RX FIFO interrupt
+#define SSI_INT_RXTO            0x00000002  // RX timeout interrupt
+#define SSI_INT_RXOR            0x00000001  // RX overrun interrupt
+
+#endif
+
+#endif // __HW_SSI_H__


Property changes on: trunk/src/platform/lm3s/hw_ssi.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_sysctl.h
===================================================================
--- trunk/src/platform/lm3s/hw_sysctl.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_sysctl.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,1333 +1,1625 @@
-//*****************************************************************************
-//
-// hw_sysctl.h - Macros used when accessing the system control hardware.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_SYSCTL_H__
-#define __HW_SYSCTL_H__
-
-//*****************************************************************************
-//
-// The following are defines for the system control register addresses.
-//
-//*****************************************************************************
-#define SYSCTL_DID0             0x400FE000  // Device identification register 0
-#define SYSCTL_DID1             0x400FE004  // Device identification register 1
-#define SYSCTL_DC0              0x400FE008  // Device capabilities register 0
-#define SYSCTL_DC1              0x400FE010  // Device capabilities register 1
-#define SYSCTL_DC2              0x400FE014  // Device capabilities register 2
-#define SYSCTL_DC3              0x400FE018  // Device capabilities register 3
-#define SYSCTL_DC4              0x400FE01C  // Device capabilities register 4
-#define SYSCTL_DC5              0x400FE020  // Device capabilities register 5
-#define SYSCTL_DC6              0x400FE024  // Device capabilities register 6
-#define SYSCTL_DC7              0x400FE028  // Device capabilities register 7
-#define SYSCTL_PBORCTL          0x400FE030  // POR/BOR reset control register
-#define SYSCTL_LDOPCTL          0x400FE034  // LDO power control register
-#define SYSCTL_SRCR0            0x400FE040  // Software reset control reg 0
-#define SYSCTL_SRCR1            0x400FE044  // Software reset control reg 1
-#define SYSCTL_SRCR2            0x400FE048  // Software reset control reg 2
-#define SYSCTL_RIS              0x400FE050  // Raw interrupt status register
-#define SYSCTL_IMC              0x400FE054  // Interrupt mask/control register
-#define SYSCTL_MISC             0x400FE058  // Interrupt status register
-#define SYSCTL_RESC             0x400FE05C  // Reset cause register
-#define SYSCTL_RCC              0x400FE060  // Run-mode clock config register
-#define SYSCTL_PLLCFG           0x400FE064  // PLL configuration register
-#define SYSCTL_GPIOHSCTL        0x400FE06C  // GPIO High Speed Control
-#define SYSCTL_RCC2             0x400FE070  // Run-mode clock config register 2
-#define SYSCTL_MOSCCTL          0x400FE07C  // Main Oscillator Control
-#define SYSCTL_RCGC0            0x400FE100  // Run-mode clock gating register 0
-#define SYSCTL_RCGC1            0x400FE104  // Run-mode clock gating register 1
-#define SYSCTL_RCGC2            0x400FE108  // Run-mode clock gating register 2
-#define SYSCTL_SCGC0            0x400FE110  // Sleep-mode clock gating reg 0
-#define SYSCTL_SCGC1            0x400FE114  // Sleep-mode clock gating reg 1
-#define SYSCTL_SCGC2            0x400FE118  // Sleep-mode clock gating reg 2
-#define SYSCTL_DCGC0            0x400FE120  // Deep Sleep-mode clock gate reg 0
-#define SYSCTL_DCGC1            0x400FE124  // Deep Sleep-mode clock gate reg 1
-#define SYSCTL_DCGC2            0x400FE128  // Deep Sleep-mode clock gate reg 2
-#define SYSCTL_DSLPCLKCFG       0x400FE144  // Deep Sleep-mode clock config reg
-#define SYSCTL_CLKVCLR          0x400FE150  // Clock verifcation clear register
-#define SYSCTL_LDOARST          0x400FE160  // LDO reset control register
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DID0 register.
-//
-//*****************************************************************************
-#define SYSCTL_DID0_VER_M       0x70000000  // DID0 version mask
-#define SYSCTL_DID0_VER_0       0x00000000  // DID0 version 0
-#define SYSCTL_DID0_VER_1       0x10000000  // DID0 version 1
-#define SYSCTL_DID0_CLASS_M     0x00FF0000  // Device Class
-#define SYSCTL_DID0_CLASS_SANDSTORM \
-                                0x00000000  // Sandstorm-class Device
-#define SYSCTL_DID0_CLASS_FURY  0x00010000  // Fury-class Device
-#define SYSCTL_DID0_CLASS_DUSTDEVIL \
-                                0x00030000  // DustDevil-class Device
-#define SYSCTL_DID0_MAJ_M       0x0000FF00  // Major revision mask
-#define SYSCTL_DID0_MAJ_REVA    0x00000000  // Revision A (initial device)
-#define SYSCTL_DID0_MAJ_REVB    0x00000100  // Revision B (first base layer
-                                            // revision)
-#define SYSCTL_DID0_MAJ_REVC    0x00000200  // Revision C (second base layer
-                                            // revision)
-#define SYSCTL_DID0_MIN_M       0x000000FF  // Minor revision mask
-#define SYSCTL_DID0_MIN_0       0x00000000  // Minor revision 0
-#define SYSCTL_DID0_MIN_1       0x00000001  // Minor revision 1
-#define SYSCTL_DID0_MIN_2       0x00000002  // Minor revision 2
-#define SYSCTL_DID0_MIN_3       0x00000003  // Minor revision 3
-#define SYSCTL_DID0_MIN_4       0x00000004  // Minor revision 4
-#define SYSCTL_DID0_MIN_5       0x00000005  // Minor revision 5
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DID1 register.
-//
-//*****************************************************************************
-#define SYSCTL_DID1_VER_M       0xF0000000  // DID1 Version.
-#define SYSCTL_DID1_VER_0       0x00000000  // Initial DID1 register format
-                                            // definition, indicating a
-                                            // Stellaris LM3Snnn device.
-#define SYSCTL_DID1_VER_1       0x10000000  // First revision of the DID1
-                                            // register format, indicating a
-                                            // Stellaris Fury-class device.
-#define SYSCTL_DID1_FAM_M       0x0F000000  // Family.
-#define SYSCTL_DID1_FAM_STELLARIS \
-                                0x00000000  // Stellaris family of
-                                            // microcontollers, that is, all
-                                            // devices with external part
-                                            // numbers starting with LM3S.
-#define SYSCTL_DID1_PRTNO_M     0x00FF0000  // Part number mask
-#define SYSCTL_DID1_PRTNO_101   0x00010000  // LM3S101
-#define SYSCTL_DID1_PRTNO_102   0x00020000  // LM3S102
-#define SYSCTL_DID1_PRTNO_300   0x00190000  // LM3S300
-#define SYSCTL_DID1_PRTNO_301   0x00110000  // LM3S301
-#define SYSCTL_DID1_PRTNO_308   0x001A0000  // LM3S308
-#define SYSCTL_DID1_PRTNO_310   0x00120000  // LM3S310
-#define SYSCTL_DID1_PRTNO_315   0x00130000  // LM3S315
-#define SYSCTL_DID1_PRTNO_316   0x00140000  // LM3S316
-#define SYSCTL_DID1_PRTNO_317   0x00170000  // LM3S317
-#define SYSCTL_DID1_PRTNO_328   0x00150000  // LM3S328
-#define SYSCTL_DID1_PRTNO_600   0x002A0000  // LM3S600
-#define SYSCTL_DID1_PRTNO_601   0x00210000  // LM3S601
-#define SYSCTL_DID1_PRTNO_608   0x002B0000  // LM3S608
-#define SYSCTL_DID1_PRTNO_610   0x00220000  // LM3S610
-#define SYSCTL_DID1_PRTNO_611   0x00230000  // LM3S611
-#define SYSCTL_DID1_PRTNO_612   0x00240000  // LM3S612
-#define SYSCTL_DID1_PRTNO_613   0x00250000  // LM3S613
-#define SYSCTL_DID1_PRTNO_615   0x00260000  // LM3S615
-#define SYSCTL_DID1_PRTNO_617   0x00280000  // LM3S617
-#define SYSCTL_DID1_PRTNO_618   0x00290000  // LM3S618
-#define SYSCTL_DID1_PRTNO_628   0x00270000  // LM3S628
-#define SYSCTL_DID1_PRTNO_800   0x00380000  // LM3S800
-#define SYSCTL_DID1_PRTNO_801   0x00310000  // LM3S801
-#define SYSCTL_DID1_PRTNO_808   0x00390000  // LM3S808
-#define SYSCTL_DID1_PRTNO_811   0x00320000  // LM3S811
-#define SYSCTL_DID1_PRTNO_812   0x00330000  // LM3S812
-#define SYSCTL_DID1_PRTNO_815   0x00340000  // LM3S815
-#define SYSCTL_DID1_PRTNO_817   0x00360000  // LM3S817
-#define SYSCTL_DID1_PRTNO_818   0x00370000  // LM3S818
-#define SYSCTL_DID1_PRTNO_828   0x00350000  // LM3S828
-#define SYSCTL_DID1_PRTNO_1110  0x00BF0000  // LM3S1110
-#define SYSCTL_DID1_PRTNO_1133  0x00C30000  // LM3S1133
-#define SYSCTL_DID1_PRTNO_1138  0x00C50000  // LM3S1138
-#define SYSCTL_DID1_PRTNO_1150  0x00C10000  // LM3S1150
-#define SYSCTL_DID1_PRTNO_1162  0x00C40000  // LM3S1162
-#define SYSCTL_DID1_PRTNO_1165  0x00C20000  // LM3S1165
-#define SYSCTL_DID1_PRTNO_1332  0x00C60000  // LM3S1332
-#define SYSCTL_DID1_PRTNO_1435  0x00BC0000  // LM3S1435
-#define SYSCTL_DID1_PRTNO_1439  0x00BA0000  // LM3S1439
-#define SYSCTL_DID1_PRTNO_1512  0x00BB0000  // LM3S1512
-#define SYSCTL_DID1_PRTNO_1538  0x00C70000  // LM3S1538
-#define SYSCTL_DID1_PRTNO_1601  0x00DB0000  // LM3S1601
-#define SYSCTL_DID1_PRTNO_1607  0x00060000  // LM3S1607
-#define SYSCTL_DID1_PRTNO_1608  0x00DA0000  // LM3S1608
-#define SYSCTL_DID1_PRTNO_1620  0x00C00000  // LM3S1620
-#define SYSCTL_DID1_PRTNO_1625  0x00030000  // LM3S1625
-#define SYSCTL_DID1_PRTNO_1626  0x00040000  // LM3S1626
-#define SYSCTL_DID1_PRTNO_1627  0x00050000  // LM3S1627
-#define SYSCTL_DID1_PRTNO_1635  0x00B30000  // LM3S1635
-#define SYSCTL_DID1_PRTNO_1637  0x00BD0000  // LM3S1637
-#define SYSCTL_DID1_PRTNO_1751  0x00B90000  // LM3S1751
-#define SYSCTL_DID1_PRTNO_1776  0x00100000  // LM3S1776
-#define SYSCTL_DID1_PRTNO_1850  0x00B40000  // LM3S1850
-#define SYSCTL_DID1_PRTNO_1911  0x00DD0000  // LM3S1911
-#define SYSCTL_DID1_PRTNO_1918  0x00DC0000  // LM3S1918
-#define SYSCTL_DID1_PRTNO_1937  0x00B70000  // LM3S1937
-#define SYSCTL_DID1_PRTNO_1958  0x00BE0000  // LM3S1958
-#define SYSCTL_DID1_PRTNO_1960  0x00B50000  // LM3S1960
-#define SYSCTL_DID1_PRTNO_1968  0x00B80000  // LM3S1968
-#define SYSCTL_DID1_PRTNO_2110  0x00510000  // LM3S2110
-#define SYSCTL_DID1_PRTNO_2139  0x00840000  // LM3S2139
-#define SYSCTL_DID1_PRTNO_2276  0x00390000  // LM3S2276
-#define SYSCTL_DID1_PRTNO_2410  0x00A20000  // LM3S2410
-#define SYSCTL_DID1_PRTNO_2412  0x00590000  // LM3S2412
-#define SYSCTL_DID1_PRTNO_2432  0x00560000  // LM3S2432
-#define SYSCTL_DID1_PRTNO_2533  0x005A0000  // LM3S2533
-#define SYSCTL_DID1_PRTNO_2601  0x00E10000  // LM3S2601
-#define SYSCTL_DID1_PRTNO_2608  0x00E00000  // LM3S2608
-#define SYSCTL_DID1_PRTNO_2616  0x00330000  // LM3S2616
-#define SYSCTL_DID1_PRTNO_2620  0x00570000  // LM3S2620
-#define SYSCTL_DID1_PRTNO_2637  0x00850000  // LM3S2637
-#define SYSCTL_DID1_PRTNO_2651  0x00530000  // LM3S2651
-#define SYSCTL_DID1_PRTNO_2671  0x00800000  // LM3S2671
-#define SYSCTL_DID1_PRTNO_2678  0x00500000  // LM3S2678
-#define SYSCTL_DID1_PRTNO_2730  0x00A40000  // LM3S2730
-#define SYSCTL_DID1_PRTNO_2739  0x00520000  // LM3S2739
-#define SYSCTL_DID1_PRTNO_2776  0x003A0000  // LM3S2776
-#define SYSCTL_DID1_PRTNO_2911  0x00E30000  // LM3S2911
-#define SYSCTL_DID1_PRTNO_2918  0x00E20000  // LM3S2918
-#define SYSCTL_DID1_PRTNO_2939  0x00540000  // LM3S2939
-#define SYSCTL_DID1_PRTNO_2948  0x008F0000  // LM3S2948
-#define SYSCTL_DID1_PRTNO_2950  0x00580000  // LM3S2950
-#define SYSCTL_DID1_PRTNO_2965  0x00550000  // LM3S2965
-#define SYSCTL_DID1_PRTNO_3651  0x00430000  // LM3S3651
-#define SYSCTL_DID1_PRTNO_3739  0x00440000  // LM3S3739
-#define SYSCTL_DID1_PRTNO_3748  0x00490000  // LM3S3748
-#define SYSCTL_DID1_PRTNO_3749  0x00450000  // LM3S3749
-#define SYSCTL_DID1_PRTNO_3759  0x00460000  // LM3S3759
-#define SYSCTL_DID1_PRTNO_3768  0x00480000  // LM3S3768
-#define SYSCTL_DID1_PRTNO_5632  0x00810000  // LM3S5632
-#define SYSCTL_DID1_PRTNO_5652  0x008A0000  // LM3S5652
-#define SYSCTL_DID1_PRTNO_5662  0x00910000  // LM3S5662
-#define SYSCTL_DID1_PRTNO_5732  0x00960000  // LM3S5732
-#define SYSCTL_DID1_PRTNO_5737  0x00970000  // LM3S5737
-#define SYSCTL_DID1_PRTNO_5739  0x00A00000  // LM3S5739
-#define SYSCTL_DID1_PRTNO_5747  0x00990000  // LM3S5747
-#define SYSCTL_DID1_PRTNO_5749  0x00A70000  // LM3S5749
-#define SYSCTL_DID1_PRTNO_5752  0x009A0000  // LM3S5752
-#define SYSCTL_DID1_PRTNO_5757  0x009B0000  // LM3S5757
-#define SYSCTL_DID1_PRTNO_5762  0x009C0000  // LM3S5762
-#define SYSCTL_DID1_PRTNO_5767  0x009D0000  // LM3S5767
-#define SYSCTL_DID1_PRTNO_5768  0x00A90000  // LM3S5768
-#define SYSCTL_DID1_PRTNO_5769  0x00A80000  // LM3S5769
-#define SYSCTL_DID1_PRTNO_6100  0x00A10000  // LM3S6100
-#define SYSCTL_DID1_PRTNO_6110  0x00740000  // LM3S6110
-#define SYSCTL_DID1_PRTNO_6420  0x00A50000  // LM3S6420
-#define SYSCTL_DID1_PRTNO_6422  0x00820000  // LM3S6422
-#define SYSCTL_DID1_PRTNO_6432  0x00750000  // LM3S6432
-#define SYSCTL_DID1_PRTNO_6537  0x00760000  // LM3S6537
-#define SYSCTL_DID1_PRTNO_6610  0x00710000  // LM3S6610
-#define SYSCTL_DID1_PRTNO_6611  0x00E70000  // LM3S6611
-#define SYSCTL_DID1_PRTNO_6618  0x00E60000  // LM3S6618
-#define SYSCTL_DID1_PRTNO_6633  0x00830000  // LM3S6633
-#define SYSCTL_DID1_PRTNO_6637  0x008B0000  // LM3S6637
-#define SYSCTL_DID1_PRTNO_6730  0x00A30000  // LM3S6730
-#define SYSCTL_DID1_PRTNO_6753  0x00770000  // LM3S6753
-#define SYSCTL_DID1_PRTNO_6911  0x00E90000  // LM3S6911
-#define SYSCTL_DID1_PRTNO_6918  0x00E80000  // LM3S6918
-#define SYSCTL_DID1_PRTNO_6938  0x00890000  // LM3S6938
-#define SYSCTL_DID1_PRTNO_6950  0x00720000  // LM3S6950
-#define SYSCTL_DID1_PRTNO_6952  0x00780000  // LM3S6952
-#define SYSCTL_DID1_PRTNO_6965  0x00730000  // LM3S6965
-#define SYSCTL_DID1_PRTNO_8530  0x00640000  // LM3S8530
-#define SYSCTL_DID1_PRTNO_8538  0x008E0000  // LM3S8538
-#define SYSCTL_DID1_PRTNO_8630  0x00610000  // LM3S8630
-#define SYSCTL_DID1_PRTNO_8730  0x00630000  // LM3S8730
-#define SYSCTL_DID1_PRTNO_8733  0x008D0000  // LM3S8733
-#define SYSCTL_DID1_PRTNO_8738  0x00860000  // LM3S8738
-#define SYSCTL_DID1_PRTNO_8930  0x00650000  // LM3S8930
-#define SYSCTL_DID1_PRTNO_8933  0x008C0000  // LM3S8933
-#define SYSCTL_DID1_PRTNO_8938  0x00880000  // LM3S8938
-#define SYSCTL_DID1_PRTNO_8962  0x00A60000  // LM3S8962
-#define SYSCTL_DID1_PRTNO_8970  0x00620000  // LM3S8970
-#define SYSCTL_DID1_PRTNO_8971  0x00D70000  // LM3S8971
-#define SYSCTL_DID1_PINCNT_M    0x0000E000  // Package Pin Count.
-#define SYSCTL_DID1_PINCNT_28   0x00000000  // 28 pin package
-#define SYSCTL_DID1_PINCNT_48   0x00002000  // 48 pin package
-#define SYSCTL_DID1_PINCNT_100  0x00004000  // 100 pin package
-#define SYSCTL_DID1_PINCNT_64   0x00006000  // 64 pin package
-#define SYSCTL_DID1_TEMP_M      0x000000E0  // Temperature range mask
-#define SYSCTL_DID1_TEMP_C      0x00000000  // Commercial temp range (0..70C)
-#define SYSCTL_DID1_TEMP_I      0x00000020  // Industrial temp range (-40..85C)
-#define SYSCTL_DID1_TEMP_E      0x00000040  // Extended temperature range (-40C
-                                            // to 105C)
-#define SYSCTL_DID1_PKG_M       0x00000018  // Package Type.
-#define SYSCTL_DID1_PKG_28SOIC  0x00000000  // 28-pin SOIC
-#define SYSCTL_DID1_PKG_48QFP   0x00000008  // 48-pin QFP
-#define SYSCTL_DID1_PKG_BGA     0x00000010  // BGA package
-#define SYSCTL_DID1_ROHS        0x00000004  // Part is RoHS compliant
-#define SYSCTL_DID1_QUAL_M      0x00000003  // Qualification status mask
-#define SYSCTL_DID1_QUAL_ES     0x00000000  // Engineering sample (unqualified)
-#define SYSCTL_DID1_QUAL_PP     0x00000001  // Pilot production (unqualified)
-#define SYSCTL_DID1_QUAL_FQ     0x00000002  // Fully qualified
-#define SYSCTL_DID1_PRTNO_S     16          // Part number shift
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC0 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC0_SRAMSZ_M     0xFFFF0000  // SRAM size mask
-#define SYSCTL_DC0_SRAMSZ_2KB   0x00070000  // 2 KB of SRAM
-#define SYSCTL_DC0_SRAMSZ_4KB   0x000F0000  // 4 KB of SRAM
-#define SYSCTL_DC0_SRAMSZ_8KB   0x001F0000  // 8 KB of SRAM
-#define SYSCTL_DC0_SRAMSZ_16KB  0x003F0000  // 16 KB of SRAM
-#define SYSCTL_DC0_SRAMSZ_32KB  0x007F0000  // 32 KB of SRAM
-#define SYSCTL_DC0_SRAMSZ_64KB  0x00FF0000  // 64 KB of SRAM
-#define SYSCTL_DC0_FLASHSZ_M    0x0000FFFF  // Flash size mask
-#define SYSCTL_DC0_FLASHSZ_8KB  0x00000003  // 8 KB of flash
-#define SYSCTL_DC0_FLASHSZ_16KB 0x00000007  // 16 KB of flash
-#define SYSCTL_DC0_FLASHSZ_32KB 0x0000000F  // 32 KB of flash
-#define SYSCTL_DC0_FLASHSZ_64KB 0x0000001F  // 64 KB of flash
-#define SYSCTL_DC0_FLASHSZ_96KB 0x0000002F  // 96 KB of flash
-#define SYSCTL_DC0_FLASHSZ_128K 0x0000003F  // 128 KB of flash
-#define SYSCTL_DC0_FLASHSZ_256K 0x0000007F  // 256 KB of flash
-#define SYSCTL_DC0_SRAMSZ_S     16          // SRAM size shift
-#define SYSCTL_DC0_FLASHSZ_S    0           // Flash size shift
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC1 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC1_CAN2         0x04000000  // CAN2 module present
-#define SYSCTL_DC1_CAN1         0x02000000  // CAN1 module present
-#define SYSCTL_DC1_CAN0         0x01000000  // CAN0 module present
-#define SYSCTL_DC1_PWM          0x00100000  // PWM module present
-#define SYSCTL_DC1_ADC          0x00010000  // ADC module present
-#define SYSCTL_DC1_MINSYSDIV_M  0x0000F000  // System Clock Divider.
-#define SYSCTL_DC1_MINSYSDIV_50 0x00003000  // Specifies a 50-MHz CPU clock
-                                            // with a PLL divider of 4.
-#define SYSCTL_DC1_MINSYSDIV_25 0x00007000  // Specifies a 25-MHz clock with a
-                                            // PLL divider of 8.
-#define SYSCTL_DC1_MINSYSDIV_20 0x00009000  // Specifies a 20-MHz clock with a
-                                            // PLL divider of 10.
-#define SYSCTL_DC1_ADCSPD_M     0x00000F00  // ADC speed mask
-#define SYSCTL_DC1_ADCSPD_125K  0x00000000  // 125Ksps ADC
-#define SYSCTL_DC1_ADCSPD_250K  0x00000100  // 250Ksps ADC
-#define SYSCTL_DC1_ADCSPD_500K  0x00000200  // 500Ksps ADC
-#define SYSCTL_DC1_ADCSPD_1M    0x00000300  // 1Msps ADC
-#define SYSCTL_DC1_MPU          0x00000080  // Cortex M3 MPU present
-#define SYSCTL_DC1_HIB          0x00000040  // Hibernation module present
-#define SYSCTL_DC1_TEMP         0x00000020  // Temperature sensor present
-#define SYSCTL_DC1_PLL          0x00000010  // PLL present
-#define SYSCTL_DC1_WDT          0x00000008  // Watchdog Timer Present.
-#define SYSCTL_DC1_SWO          0x00000004  // Serial wire output present
-#define SYSCTL_DC1_SWD          0x00000002  // Serial wire debug present
-#define SYSCTL_DC1_JTAG         0x00000001  // JTAG debug present
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC2 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC2_COMP2        0x04000000  // Analog comparator 2 present
-#define SYSCTL_DC2_COMP1        0x02000000  // Analog comparator 1 present
-#define SYSCTL_DC2_COMP0        0x01000000  // Analog comparator 0 present
-#define SYSCTL_DC2_TIMER3       0x00080000  // Timer 3 present
-#define SYSCTL_DC2_TIMER2       0x00040000  // Timer 2 present
-#define SYSCTL_DC2_TIMER1       0x00020000  // Timer 1 present
-#define SYSCTL_DC2_TIMER0       0x00010000  // Timer 0 present
-#define SYSCTL_DC2_I2C1         0x00004000  // I2C 1 present
-#define SYSCTL_DC2_I2C0         0x00001000  // I2C 0 present
-#define SYSCTL_DC2_QEI1         0x00000200  // QEI 1 present
-#define SYSCTL_DC2_QEI0         0x00000100  // QEI 0 present
-#define SYSCTL_DC2_SSI1         0x00000020  // SSI 1 present
-#define SYSCTL_DC2_SSI0         0x00000010  // SSI 0 present
-#define SYSCTL_DC2_UART2        0x00000004  // UART 2 present
-#define SYSCTL_DC2_UART1        0x00000002  // UART 1 present
-#define SYSCTL_DC2_UART0        0x00000001  // UART 0 present
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC3 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC3_32KHZ        0x80000000  // 32KHz Pin Present.
-#define SYSCTL_DC3_CCP5         0x20000000  // CCP5 pin present
-#define SYSCTL_DC3_CCP4         0x10000000  // CCP4 pin present
-#define SYSCTL_DC3_CCP3         0x08000000  // CCP3 pin present
-#define SYSCTL_DC3_CCP2         0x04000000  // CCP2 pin present
-#define SYSCTL_DC3_CCP1         0x02000000  // CCP1 pin present
-#define SYSCTL_DC3_CCP0         0x01000000  // CCP0 pin present
-#define SYSCTL_DC3_ADC7         0x00800000  // ADC7 pin present
-#define SYSCTL_DC3_ADC6         0x00400000  // ADC6 pin present
-#define SYSCTL_DC3_ADC5         0x00200000  // ADC5 pin present
-#define SYSCTL_DC3_ADC4         0x00100000  // ADC4 pin present
-#define SYSCTL_DC3_ADC3         0x00080000  // ADC3 pin present
-#define SYSCTL_DC3_ADC2         0x00040000  // ADC2 pin present
-#define SYSCTL_DC3_ADC1         0x00020000  // ADC1 pin present
-#define SYSCTL_DC3_ADC0         0x00010000  // ADC0 pin present
-#define SYSCTL_DC3_PWMFAULT     0x00008000  // PWM Fault Pin Present.
-#define SYSCTL_DC3_C2O          0x00004000  // C2o pin present
-#define SYSCTL_DC3_C2PLUS       0x00002000  // C2+ pin present
-#define SYSCTL_DC3_C2MINUS      0x00001000  // C2- pin present
-#define SYSCTL_DC3_C1O          0x00000800  // C1o pin present
-#define SYSCTL_DC3_C1PLUS       0x00000400  // C1+ pin present
-#define SYSCTL_DC3_C1MINUS      0x00000200  // C1- pin present
-#define SYSCTL_DC3_C0O          0x00000100  // C0o pin present
-#define SYSCTL_DC3_C0PLUS       0x00000080  // C0+ pin present
-#define SYSCTL_DC3_C0MINUS      0x00000040  // C0- pin present
-#define SYSCTL_DC3_PWM5         0x00000020  // PWM5 pin present
-#define SYSCTL_DC3_PWM4         0x00000010  // PWM4 pin present
-#define SYSCTL_DC3_PWM3         0x00000008  // PWM3 pin present
-#define SYSCTL_DC3_PWM2         0x00000004  // PWM2 pin present
-#define SYSCTL_DC3_PWM1         0x00000002  // PWM1 pin present
-#define SYSCTL_DC3_PWM0         0x00000001  // PWM0 pin present
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC4 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC4_ETH          0x50000000  // Ethernet present
-#define SYSCTL_DC4_EPHY0        0x40000000  // Ethernet PHY0 Present.
-#define SYSCTL_DC4_EMAC0        0x10000000  // Ethernet MAC0 Present.
-#define SYSCTL_DC4_E1588        0x01000000  // 1588 Capable.
-#define SYSCTL_DC4_CCP7         0x00008000  // CCP7 Pin Present.
-#define SYSCTL_DC4_CCP6         0x00004000  // CCP6 Pin Present.
-#define SYSCTL_DC4_UDMA         0x00002000  // Micro-DMA is present.
-#define SYSCTL_DC4_ROM          0x00001000  // Internal Code ROM is present.
-#define SYSCTL_DC4_GPIOH        0x00000080  // GPIO port H present
-#define SYSCTL_DC4_GPIOG        0x00000040  // GPIO port G present
-#define SYSCTL_DC4_GPIOF        0x00000020  // GPIO port F present
-#define SYSCTL_DC4_GPIOE        0x00000010  // GPIO port E present
-#define SYSCTL_DC4_GPIOD        0x00000008  // GPIO port D present
-#define SYSCTL_DC4_GPIOC        0x00000004  // GPIO port C present
-#define SYSCTL_DC4_GPIOB        0x00000002  // GPIO port B present
-#define SYSCTL_DC4_GPIOA        0x00000001  // GPIO port A present
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_PBORCTL register.
-//
-//*****************************************************************************
-#define SYSCTL_PBORCTL_BORTIM_M 0x0000FFFC  // BOR Time Delay.
-#define SYSCTL_PBORCTL_BORIOR   0x00000002  // BOR interrupt or reset
-#define SYSCTL_PBORCTL_BORWT    0x00000001  // BOR wait and check for noise
-#define SYSCTL_PBORCTL_BORTIM_S 2
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_LDOPCTL register.
-//
-//*****************************************************************************
-#define SYSCTL_LDOPCTL_M        0x0000003F  // LDO Output Voltage.
-#define SYSCTL_LDOPCTL_2_55V    0x0000001F  // LDO output of 2.55V
-#define SYSCTL_LDOPCTL_2_60V    0x0000001E  // LDO output of 2.60V
-#define SYSCTL_LDOPCTL_2_65V    0x0000001D  // LDO output of 2.65V
-#define SYSCTL_LDOPCTL_2_70V    0x0000001C  // LDO output of 2.70V
-#define SYSCTL_LDOPCTL_2_75V    0x0000001B  // LDO output of 2.75V
-#define SYSCTL_LDOPCTL_2_25V    0x00000005  // LDO output of 2.25V
-#define SYSCTL_LDOPCTL_2_30V    0x00000004  // LDO output of 2.30V
-#define SYSCTL_LDOPCTL_2_35V    0x00000003  // LDO output of 2.35V
-#define SYSCTL_LDOPCTL_2_40V    0x00000002  // LDO output of 2.40V
-#define SYSCTL_LDOPCTL_2_45V    0x00000001  // LDO output of 2.45V
-#define SYSCTL_LDOPCTL_2_50V    0x00000000  // LDO output of 2.50V
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_RESC register.
-//
-//*****************************************************************************
-#define SYSCTL_RESC_MOSCFAIL    0x00010000  // MOSC Failure Reset.
-#define SYSCTL_RESC_LDO         0x00000020  // LDO power OK lost reset
-#define SYSCTL_RESC_SW          0x00000010  // Software reset
-#define SYSCTL_RESC_WDT         0x00000008  // Watchdog Timer Reset.
-#define SYSCTL_RESC_BOR         0x00000004  // Brown-out reset
-#define SYSCTL_RESC_POR         0x00000002  // Power on reset
-#define SYSCTL_RESC_EXT         0x00000001  // External reset
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_RCC register.
-//
-//*****************************************************************************
-#define SYSCTL_RCC_ACG          0x08000000  // Automatic clock gating
-#define SYSCTL_RCC_SYSDIV_M     0x07800000  // System Clock Divisor.
-#define SYSCTL_RCC_SYSDIV_2     0x00800000  // System clock /2
-#define SYSCTL_RCC_SYSDIV_3     0x01000000  // System clock /3
-#define SYSCTL_RCC_SYSDIV_4     0x01800000  // System clock /4
-#define SYSCTL_RCC_SYSDIV_5     0x02000000  // System clock /5
-#define SYSCTL_RCC_SYSDIV_6     0x02800000  // System clock /6
-#define SYSCTL_RCC_SYSDIV_7     0x03000000  // System clock /7
-#define SYSCTL_RCC_SYSDIV_8     0x03800000  // System clock /8
-#define SYSCTL_RCC_SYSDIV_9     0x04000000  // System clock /9
-#define SYSCTL_RCC_SYSDIV_10    0x04800000  // System clock /10
-#define SYSCTL_RCC_SYSDIV_11    0x05000000  // System clock /11
-#define SYSCTL_RCC_SYSDIV_12    0x05800000  // System clock /12
-#define SYSCTL_RCC_SYSDIV_13    0x06000000  // System clock /13
-#define SYSCTL_RCC_SYSDIV_14    0x06800000  // System clock /14
-#define SYSCTL_RCC_SYSDIV_15    0x07000000  // System clock /15
-#define SYSCTL_RCC_SYSDIV_16    0x07800000  // System clock /16
-#define SYSCTL_RCC_USESYSDIV    0x00400000  // Enable System Clock Divider.
-#define SYSCTL_RCC_USEPWMDIV    0x00100000  // Enable PWM Clock Divisor.
-#define SYSCTL_RCC_PWMDIV_M     0x000E0000  // PWM clock divider
-#define SYSCTL_RCC_PWMDIV_2     0x00000000  // PWM clock /2
-#define SYSCTL_RCC_PWMDIV_4     0x00020000  // PWM clock /4
-#define SYSCTL_RCC_PWMDIV_8     0x00040000  // PWM clock /8
-#define SYSCTL_RCC_PWMDIV_16    0x00060000  // PWM clock /16
-#define SYSCTL_RCC_PWMDIV_32    0x00080000  // PWM clock /32
-#define SYSCTL_RCC_PWMDIV_64    0x000A0000  // PWM clock /64
-#define SYSCTL_RCC_PWRDN        0x00002000  // PLL power down
-#define SYSCTL_RCC_OEN          0x00001000  // PLL Output Enable.
-#define SYSCTL_RCC_BYPASS       0x00000800  // PLL bypass
-#define SYSCTL_RCC_XTAL_M       0x000007C0  // Crystal attached to main osc
-#define SYSCTL_RCC_XTAL_1MHZ    0x00000000  // Using a 1MHz crystal
-#define SYSCTL_RCC_XTAL_1_84MHZ 0x00000040  // Using a 1.8432MHz crystal
-#define SYSCTL_RCC_XTAL_2MHZ    0x00000080  // Using a 2MHz crystal
-#define SYSCTL_RCC_XTAL_2_45MHZ 0x000000C0  // Using a 2.4576MHz crystal
-#define SYSCTL_RCC_XTAL_3_57MHZ 0x00000100  // Using a 3.579545MHz crystal
-#define SYSCTL_RCC_XTAL_3_68MHZ 0x00000140  // Using a 3.6864MHz crystal
-#define SYSCTL_RCC_XTAL_4MHZ    0x00000180  // Using a 4MHz crystal
-#define SYSCTL_RCC_XTAL_4_09MHZ 0x000001C0  // Using a 4.096MHz crystal
-#define SYSCTL_RCC_XTAL_4_91MHZ 0x00000200  // Using a 4.9152MHz crystal
-#define SYSCTL_RCC_XTAL_5MHZ    0x00000240  // Using a 5MHz crystal
-#define SYSCTL_RCC_XTAL_5_12MHZ 0x00000280  // Using a 5.12MHz crystal
-#define SYSCTL_RCC_XTAL_6MHZ    0x000002C0  // Using a 6MHz crystal
-#define SYSCTL_RCC_XTAL_6_14MHZ 0x00000300  // Using a 6.144MHz crystal
-#define SYSCTL_RCC_XTAL_7_37MHZ 0x00000340  // Using a 7.3728MHz crystal
-#define SYSCTL_RCC_XTAL_8MHZ    0x00000380  // Using a 8MHz crystal
-#define SYSCTL_RCC_XTAL_8_19MHZ 0x000003C0  // Using a 8.192MHz crystal
-#define SYSCTL_RCC_XTAL_10MHZ   0x00000400  // 10.0 MHz (USB)
-#define SYSCTL_RCC_XTAL_12MHZ   0x00000440  // 12.0 MHz (USB)
-#define SYSCTL_RCC_XTAL_12_2MHZ 0x00000480  // 12.288 MHz
-#define SYSCTL_RCC_XTAL_13_5MHZ 0x000004C0  // 13.56 MHz
-#define SYSCTL_RCC_XTAL_14_3MHZ 0x00000500  // 14.31818 MHz
-#define SYSCTL_RCC_XTAL_16MHZ   0x00000540  // 16.0 MHz (USB)
-#define SYSCTL_RCC_XTAL_16_3MHZ 0x00000580  // 16.384 MHz
-#define SYSCTL_RCC_PLLVER       0x00000400  // PLL verification timer enable
-#define SYSCTL_RCC_OSCSRC_M     0x00000030  // Oscillator input select
-#define SYSCTL_RCC_OSCSRC_MAIN  0x00000000  // Use the main oscillator
-#define SYSCTL_RCC_OSCSRC_INT   0x00000010  // Use the internal oscillator
-#define SYSCTL_RCC_OSCSRC_INT4  0x00000020  // Use the internal oscillator / 4
-#define SYSCTL_RCC_OSCSRC_30    0x00000030  // 30 KHz internal oscillator
-#define SYSCTL_RCC_IOSCVER      0x00000008  // Int. osc. verification timer en
-#define SYSCTL_RCC_MOSCVER      0x00000004  // Main osc. verification timer en
-#define SYSCTL_RCC_IOSCDIS      0x00000002  // Internal oscillator disable
-#define SYSCTL_RCC_MOSCDIS      0x00000001  // Main oscillator disable
-#define SYSCTL_RCC_SYSDIV_S     23          // Shift to the SYSDIV field
-#define SYSCTL_RCC_PWMDIV_S     17          // Shift to the PWMDIV field
-#define SYSCTL_RCC_XTAL_S       6           // Shift to the XTAL field
-#define SYSCTL_RCC_OSCSRC_S     4           // Shift to the OSCSRC field
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_PLLCFG register.
-//
-//*****************************************************************************
-#define SYSCTL_PLLCFG_OD_M      0x0000C000  // Output divider
-#define SYSCTL_PLLCFG_OD_1      0x00000000  // Output divider is 1
-#define SYSCTL_PLLCFG_OD_2      0x00004000  // Output divider is 2
-#define SYSCTL_PLLCFG_OD_4      0x00008000  // Output divider is 4
-#define SYSCTL_PLLCFG_F_M       0x00003FE0  // PLL F Value.
-#define SYSCTL_PLLCFG_R_M       0x0000001F  // PLL R Value.
-#define SYSCTL_PLLCFG_F_S       5
-#define SYSCTL_PLLCFG_R_S       0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_RCC2 register.
-//
-//*****************************************************************************
-#define SYSCTL_RCC2_USERCC2     0x80000000  // Use RCC2
-#define SYSCTL_RCC2_SYSDIV2_M   0x1F800000  // System clock divider
-#define SYSCTL_RCC2_SYSDIV2_2   0x00800000  // System clock /2
-#define SYSCTL_RCC2_SYSDIV2_3   0x01000000  // System clock /3
-#define SYSCTL_RCC2_SYSDIV2_4   0x01800000  // System clock /4
-#define SYSCTL_RCC2_SYSDIV2_5   0x02000000  // System clock /5
-#define SYSCTL_RCC2_SYSDIV2_6   0x02800000  // System clock /6
-#define SYSCTL_RCC2_SYSDIV2_7   0x03000000  // System clock /7
-#define SYSCTL_RCC2_SYSDIV2_8   0x03800000  // System clock /8
-#define SYSCTL_RCC2_SYSDIV2_9   0x04000000  // System clock /9
-#define SYSCTL_RCC2_SYSDIV2_10  0x04800000  // System clock /10
-#define SYSCTL_RCC2_SYSDIV2_11  0x05000000  // System clock /11
-#define SYSCTL_RCC2_SYSDIV2_12  0x05800000  // System clock /12
-#define SYSCTL_RCC2_SYSDIV2_13  0x06000000  // System clock /13
-#define SYSCTL_RCC2_SYSDIV2_14  0x06800000  // System clock /14
-#define SYSCTL_RCC2_SYSDIV2_15  0x07000000  // System clock /15
-#define SYSCTL_RCC2_SYSDIV2_16  0x07800000  // System clock /16
-#define SYSCTL_RCC2_SYSDIV2_17  0x08000000  // System clock /17
-#define SYSCTL_RCC2_SYSDIV2_18  0x08800000  // System clock /18
-#define SYSCTL_RCC2_SYSDIV2_19  0x09000000  // System clock /19
-#define SYSCTL_RCC2_SYSDIV2_20  0x09800000  // System clock /20
-#define SYSCTL_RCC2_SYSDIV2_21  0x0A000000  // System clock /21
-#define SYSCTL_RCC2_SYSDIV2_22  0x0A800000  // System clock /22
-#define SYSCTL_RCC2_SYSDIV2_23  0x0B000000  // System clock /23
-#define SYSCTL_RCC2_SYSDIV2_24  0x0B800000  // System clock /24
-#define SYSCTL_RCC2_SYSDIV2_25  0x0C000000  // System clock /25
-#define SYSCTL_RCC2_SYSDIV2_26  0x0C800000  // System clock /26
-#define SYSCTL_RCC2_SYSDIV2_27  0x0D000000  // System clock /27
-#define SYSCTL_RCC2_SYSDIV2_28  0x0D800000  // System clock /28
-#define SYSCTL_RCC2_SYSDIV2_29  0x0E000000  // System clock /29
-#define SYSCTL_RCC2_SYSDIV2_30  0x0E800000  // System clock /30
-#define SYSCTL_RCC2_SYSDIV2_31  0x0F000000  // System clock /31
-#define SYSCTL_RCC2_SYSDIV2_32  0x0F800000  // System clock /32
-#define SYSCTL_RCC2_SYSDIV2_33  0x10000000  // System clock /33
-#define SYSCTL_RCC2_SYSDIV2_34  0x10800000  // System clock /34
-#define SYSCTL_RCC2_SYSDIV2_35  0x11000000  // System clock /35
-#define SYSCTL_RCC2_SYSDIV2_36  0x11800000  // System clock /36
-#define SYSCTL_RCC2_SYSDIV2_37  0x12000000  // System clock /37
-#define SYSCTL_RCC2_SYSDIV2_38  0x12800000  // System clock /38
-#define SYSCTL_RCC2_SYSDIV2_39  0x13000000  // System clock /39
-#define SYSCTL_RCC2_SYSDIV2_40  0x13800000  // System clock /40
-#define SYSCTL_RCC2_SYSDIV2_41  0x14000000  // System clock /41
-#define SYSCTL_RCC2_SYSDIV2_42  0x14800000  // System clock /42
-#define SYSCTL_RCC2_SYSDIV2_43  0x15000000  // System clock /43
-#define SYSCTL_RCC2_SYSDIV2_44  0x15800000  // System clock /44
-#define SYSCTL_RCC2_SYSDIV2_45  0x16000000  // System clock /45
-#define SYSCTL_RCC2_SYSDIV2_46  0x16800000  // System clock /46
-#define SYSCTL_RCC2_SYSDIV2_47  0x17000000  // System clock /47
-#define SYSCTL_RCC2_SYSDIV2_48  0x17800000  // System clock /48
-#define SYSCTL_RCC2_SYSDIV2_49  0x18000000  // System clock /49
-#define SYSCTL_RCC2_SYSDIV2_50  0x18800000  // System clock /50
-#define SYSCTL_RCC2_SYSDIV2_51  0x19000000  // System clock /51
-#define SYSCTL_RCC2_SYSDIV2_52  0x19800000  // System clock /52
-#define SYSCTL_RCC2_SYSDIV2_53  0x1A000000  // System clock /53
-#define SYSCTL_RCC2_SYSDIV2_54  0x1A800000  // System clock /54
-#define SYSCTL_RCC2_SYSDIV2_55  0x1B000000  // System clock /55
-#define SYSCTL_RCC2_SYSDIV2_56  0x1B800000  // System clock /56
-#define SYSCTL_RCC2_SYSDIV2_57  0x1C000000  // System clock /57
-#define SYSCTL_RCC2_SYSDIV2_58  0x1C800000  // System clock /58
-#define SYSCTL_RCC2_SYSDIV2_59  0x1D000000  // System clock /59
-#define SYSCTL_RCC2_SYSDIV2_60  0x1D800000  // System clock /60
-#define SYSCTL_RCC2_SYSDIV2_61  0x1E000000  // System clock /61
-#define SYSCTL_RCC2_SYSDIV2_62  0x1E800000  // System clock /62
-#define SYSCTL_RCC2_SYSDIV2_63  0x1F000000  // System clock /63
-#define SYSCTL_RCC2_SYSDIV2_64  0x1F800000  // System clock /64
-#define SYSCTL_RCC2_USBPWRDN    0x00004000  // Power-Down USB PLL.
-#define SYSCTL_RCC2_PWRDN2      0x00002000  // PLL power down
-#define SYSCTL_RCC2_BYPASS2     0x00000800  // PLL bypass
-#define SYSCTL_RCC2_OSCSRC2_M   0x00000070  // System Clock Source.
-#define SYSCTL_RCC2_OSCSRC2_MO  0x00000000  // Use the main oscillator
-#define SYSCTL_RCC2_OSCSRC2_IO  0x00000010  // Use the internal oscillator
-#define SYSCTL_RCC2_OSCSRC2_IO4 0x00000020  // Use the internal oscillator / 4
-#define SYSCTL_RCC2_OSCSRC2_30  0x00000030  // Use the 30 KHz internal osc.
-#define SYSCTL_RCC2_OSCSRC2_32  0x00000070  // Use the 32 KHz external osc.
-#define SYSCTL_RCC2_SYSDIV2_S   23          // Shift to the SYSDIV2 field
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DSLPCLKCFG
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_DSLPCLKCFG_D_M   0x1F800000  // Divider Field Override.
-#define SYSCTL_DSLPCLKCFG_D_2   0x00800000  // System clock /2
-#define SYSCTL_DSLPCLKCFG_D_3   0x01000000  // System clock /3
-#define SYSCTL_DSLPCLKCFG_D_4   0x01800000  // System clock /4
-#define SYSCTL_DSLPCLKCFG_D_5   0x02000000  // System clock /5
-#define SYSCTL_DSLPCLKCFG_D_6   0x02800000  // System clock /6
-#define SYSCTL_DSLPCLKCFG_D_7   0x03000000  // System clock /7
-#define SYSCTL_DSLPCLKCFG_D_8   0x03800000  // System clock /8
-#define SYSCTL_DSLPCLKCFG_D_9   0x04000000  // System clock /9
-#define SYSCTL_DSLPCLKCFG_D_10  0x04800000  // System clock /10
-#define SYSCTL_DSLPCLKCFG_D_11  0x05000000  // System clock /11
-#define SYSCTL_DSLPCLKCFG_D_12  0x05800000  // System clock /12
-#define SYSCTL_DSLPCLKCFG_D_13  0x06000000  // System clock /13
-#define SYSCTL_DSLPCLKCFG_D_14  0x06800000  // System clock /14
-#define SYSCTL_DSLPCLKCFG_D_15  0x07000000  // System clock /15
-#define SYSCTL_DSLPCLKCFG_D_16  0x07800000  // System clock /16
-#define SYSCTL_DSLPCLKCFG_D_17  0x08000000  // System clock /17
-#define SYSCTL_DSLPCLKCFG_D_18  0x08800000  // System clock /18
-#define SYSCTL_DSLPCLKCFG_D_19  0x09000000  // System clock /19
-#define SYSCTL_DSLPCLKCFG_D_20  0x09800000  // System clock /20
-#define SYSCTL_DSLPCLKCFG_D_21  0x0A000000  // System clock /21
-#define SYSCTL_DSLPCLKCFG_D_22  0x0A800000  // System clock /22
-#define SYSCTL_DSLPCLKCFG_D_23  0x0B000000  // System clock /23
-#define SYSCTL_DSLPCLKCFG_D_24  0x0B800000  // System clock /24
-#define SYSCTL_DSLPCLKCFG_D_25  0x0C000000  // System clock /25
-#define SYSCTL_DSLPCLKCFG_D_26  0x0C800000  // System clock /26
-#define SYSCTL_DSLPCLKCFG_D_27  0x0D000000  // System clock /27
-#define SYSCTL_DSLPCLKCFG_D_28  0x0D800000  // System clock /28
-#define SYSCTL_DSLPCLKCFG_D_29  0x0E000000  // System clock /29
-#define SYSCTL_DSLPCLKCFG_D_30  0x0E800000  // System clock /30
-#define SYSCTL_DSLPCLKCFG_D_31  0x0F000000  // System clock /31
-#define SYSCTL_DSLPCLKCFG_D_32  0x0F800000  // System clock /32
-#define SYSCTL_DSLPCLKCFG_D_33  0x10000000  // System clock /33
-#define SYSCTL_DSLPCLKCFG_D_34  0x10800000  // System clock /34
-#define SYSCTL_DSLPCLKCFG_D_35  0x11000000  // System clock /35
-#define SYSCTL_DSLPCLKCFG_D_36  0x11800000  // System clock /36
-#define SYSCTL_DSLPCLKCFG_D_37  0x12000000  // System clock /37
-#define SYSCTL_DSLPCLKCFG_D_38  0x12800000  // System clock /38
-#define SYSCTL_DSLPCLKCFG_D_39  0x13000000  // System clock /39
-#define SYSCTL_DSLPCLKCFG_D_40  0x13800000  // System clock /40
-#define SYSCTL_DSLPCLKCFG_D_41  0x14000000  // System clock /41
-#define SYSCTL_DSLPCLKCFG_D_42  0x14800000  // System clock /42
-#define SYSCTL_DSLPCLKCFG_D_43  0x15000000  // System clock /43
-#define SYSCTL_DSLPCLKCFG_D_44  0x15800000  // System clock /44
-#define SYSCTL_DSLPCLKCFG_D_45  0x16000000  // System clock /45
-#define SYSCTL_DSLPCLKCFG_D_46  0x16800000  // System clock /46
-#define SYSCTL_DSLPCLKCFG_D_47  0x17000000  // System clock /47
-#define SYSCTL_DSLPCLKCFG_D_48  0x17800000  // System clock /48
-#define SYSCTL_DSLPCLKCFG_D_49  0x18000000  // System clock /49
-#define SYSCTL_DSLPCLKCFG_D_50  0x18800000  // System clock /50
-#define SYSCTL_DSLPCLKCFG_D_51  0x19000000  // System clock /51
-#define SYSCTL_DSLPCLKCFG_D_52  0x19800000  // System clock /52
-#define SYSCTL_DSLPCLKCFG_D_53  0x1A000000  // System clock /53
-#define SYSCTL_DSLPCLKCFG_D_54  0x1A800000  // System clock /54
-#define SYSCTL_DSLPCLKCFG_D_55  0x1B000000  // System clock /55
-#define SYSCTL_DSLPCLKCFG_D_56  0x1B800000  // System clock /56
-#define SYSCTL_DSLPCLKCFG_D_57  0x1C000000  // System clock /57
-#define SYSCTL_DSLPCLKCFG_D_58  0x1C800000  // System clock /58
-#define SYSCTL_DSLPCLKCFG_D_59  0x1D000000  // System clock /59
-#define SYSCTL_DSLPCLKCFG_D_60  0x1D800000  // System clock /60
-#define SYSCTL_DSLPCLKCFG_D_61  0x1E000000  // System clock /61
-#define SYSCTL_DSLPCLKCFG_D_62  0x1E800000  // System clock /62
-#define SYSCTL_DSLPCLKCFG_D_63  0x1F000000  // System clock /63
-#define SYSCTL_DSLPCLKCFG_D_64  0x1F800000  // System clock /64
-#define SYSCTL_DSLPCLKCFG_O_M   0x00000070  // Clock Source.
-#define SYSCTL_DSLPCLKCFG_O_IGN 0x00000000  // Do not override
-#define SYSCTL_DSLPCLKCFG_O_IO  0x00000010  // Use the internal oscillator
-#define SYSCTL_DSLPCLKCFG_O_30  0x00000030  // Use the 30 KHz internal osc.
-#define SYSCTL_DSLPCLKCFG_O_32  0x00000070  // Use the 32 KHz external osc.
-#define SYSCTL_DSLPCLKCFG_IOSC  0x00000001  // IOSC Clock Source.
-#define SYSCTL_DSLPCLKCFG_D_S   23
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_CLKVCLR register.
-//
-//*****************************************************************************
-#define SYSCTL_CLKVCLR_VERCLR   0x00000001  // Clock Verification Clear.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_LDOARST register.
-//
-//*****************************************************************************
-#define SYSCTL_LDOARST_LDOARST  0x00000001  // LDO Reset.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_SRCR0 register.
-//
-//*****************************************************************************
-#define SYSCTL_SRCR0_CAN2       0x04000000  // CAN2 Reset Control.
-#define SYSCTL_SRCR0_CAN1       0x02000000  // CAN1 Reset Control.
-#define SYSCTL_SRCR0_CAN0       0x01000000  // CAN0 Reset Control.
-#define SYSCTL_SRCR0_PWM        0x00100000  // PWM Reset Control.
-#define SYSCTL_SRCR0_ADC        0x00010000  // ADC0 Reset Control.
-#define SYSCTL_SRCR0_HIB        0x00000040  // HIB Reset Control.
-#define SYSCTL_SRCR0_WDT        0x00000008  // WDT Reset Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_SRCR1 register.
-//
-//*****************************************************************************
-#define SYSCTL_SRCR1_COMP2      0x04000000  // Analog Comp 2 Reset Control.
-#define SYSCTL_SRCR1_COMP1      0x02000000  // Analog Comp 1 Reset Control.
-#define SYSCTL_SRCR1_COMP0      0x01000000  // Analog Comp 0 Reset Control.
-#define SYSCTL_SRCR1_TIMER3     0x00080000  // Timer 3 Reset Control.
-#define SYSCTL_SRCR1_TIMER2     0x00040000  // Timer 2 Reset Control.
-#define SYSCTL_SRCR1_TIMER1     0x00020000  // Timer 1 Reset Control.
-#define SYSCTL_SRCR1_TIMER0     0x00010000  // Timer 0 Reset Control.
-#define SYSCTL_SRCR1_I2C1       0x00004000  // I2C1 Reset Control.
-#define SYSCTL_SRCR1_I2C0       0x00001000  // I2C0 Reset Control.
-#define SYSCTL_SRCR1_QEI1       0x00000200  // QEI1 Reset Control.
-#define SYSCTL_SRCR1_QEI0       0x00000100  // QEI0 Reset Control.
-#define SYSCTL_SRCR1_SSI1       0x00000020  // SSI1 Reset Control.
-#define SYSCTL_SRCR1_SSI0       0x00000010  // SSI0 Reset Control.
-#define SYSCTL_SRCR1_UART2      0x00000004  // UART2 Reset Control.
-#define SYSCTL_SRCR1_UART1      0x00000002  // UART1 Reset Control.
-#define SYSCTL_SRCR1_UART0      0x00000001  // UART0 Reset Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_SRCR2 register.
-//
-//*****************************************************************************
-#define SYSCTL_SRCR2_EPHY0      0x40000000  // PHY0 Reset Control.
-#define SYSCTL_SRCR2_EMAC0      0x10000000  // MAC0 Reset Control.
-#define SYSCTL_SRCR2_USB0       0x00010000  // USB0 Reset Control.
-#define SYSCTL_SRCR2_UDMA       0x00002000  // UDMA Reset Control.
-#define SYSCTL_SRCR2_GPIOH      0x00000080  // Port H Reset Control.
-#define SYSCTL_SRCR2_GPIOG      0x00000040  // Port G Reset Control.
-#define SYSCTL_SRCR2_GPIOF      0x00000020  // Port F Reset Control.
-#define SYSCTL_SRCR2_GPIOE      0x00000010  // Port E Reset Control.
-#define SYSCTL_SRCR2_GPIOD      0x00000008  // Port D Reset Control.
-#define SYSCTL_SRCR2_GPIOC      0x00000004  // Port C Reset Control.
-#define SYSCTL_SRCR2_GPIOB      0x00000002  // Port B Reset Control.
-#define SYSCTL_SRCR2_GPIOA      0x00000001  // Port A Reset Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_RIS register.
-//
-//*****************************************************************************
-#define SYSCTL_RIS_MOSCPUPRIS   0x00000100  // MOSC Power Up Raw Interrupt
-                                            // Status.
-#define SYSCTL_RIS_USBPLLLRIS   0x00000080  // USB PLL Lock Raw Interrupt
-                                            // Status.
-#define SYSCTL_RIS_PLLLRIS      0x00000040  // PLL Lock Raw Interrupt Status.
-#define SYSCTL_RIS_CLRIS        0x00000020  // Current Limit Raw Interrupt
-                                            // Status.
-#define SYSCTL_RIS_IOFRIS       0x00000010  // Internal Oscillator Fault Raw
-                                            // Interrupt Status.
-#define SYSCTL_RIS_MOFRIS       0x00000008  // Main Oscillator Fault Raw
-                                            // Interrupt Status.
-#define SYSCTL_RIS_LDORIS       0x00000004  // LDO Power Unregulated Raw
-                                            // Interrupt Status.
-#define SYSCTL_RIS_BORRIS       0x00000002  // Brown-Out Reset Raw Interrupt
-                                            // Status.
-#define SYSCTL_RIS_PLLFRIS      0x00000001  // PLL Fault Raw Interrupt Status.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_IMC register.
-//
-//*****************************************************************************
-#define SYSCTL_IMC_MOSCPUPIM    0x00000100  // MOSC Power Up Interrupt Mask.
-#define SYSCTL_IMC_USBPLLLIM    0x00000080  // USB PLL Lock Interrupt Mask.
-#define SYSCTL_IMC_PLLLIM       0x00000040  // PLL Lock Interrupt Mask.
-#define SYSCTL_IMC_CLIM         0x00000020  // Current Limit Interrupt Mask.
-#define SYSCTL_IMC_IOFIM        0x00000010  // Internal Oscillator Fault
-                                            // Interrupt Mask.
-#define SYSCTL_IMC_MOFIM        0x00000008  // Main Oscillator Fault Interrupt
-                                            // Mask.
-#define SYSCTL_IMC_LDOIM        0x00000004  // LDO Power Unregulated Interrupt
-                                            // Mask.
-#define SYSCTL_IMC_BORIM        0x00000002  // Brown-Out Reset Interrupt Mask.
-#define SYSCTL_IMC_PLLFIM       0x00000001  // PLL Fault Interrupt Mask.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_MISC register.
-//
-//*****************************************************************************
-#define SYSCTL_MISC_MOSCPUPMIS  0x00000100  // MOSC Power Up Masked Interrupt
-                                            // Status.
-#define SYSCTL_MISC_USBPLLLMIS  0x00000080  // USB PLL Lock Masked Interrupt
-                                            // Status.
-#define SYSCTL_MISC_PLLLMIS     0x00000040  // PLL Lock Masked Interrupt
-                                            // Status.
-#define SYSCTL_MISC_CLMIS       0x00000020  // Current Limit Masked Interrupt
-                                            // Status.
-#define SYSCTL_MISC_IOFMIS      0x00000010  // Internal Oscillator Fault Masked
-                                            // Interrupt Status.
-#define SYSCTL_MISC_MOFMIS      0x00000008  // Main Oscillator Fault Masked
-                                            // Interrupt Status.
-#define SYSCTL_MISC_LDOMIS      0x00000004  // LDO Power Unregulated Masked
-                                            // Interrupt Status.
-#define SYSCTL_MISC_BORMIS      0x00000002  // BOR Masked Interrupt Status.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_RCGC0 register.
-//
-//*****************************************************************************
-#define SYSCTL_RCGC0_CAN2       0x04000000  // CAN2 Clock Gating Control.
-#define SYSCTL_RCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
-#define SYSCTL_RCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
-#define SYSCTL_RCGC0_PWM        0x00100000  // PWM Clock Gating Control.
-#define SYSCTL_RCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
-#define SYSCTL_RCGC0_ADCSPD_M   0x00000F00  // ADC Sample Speed.
-#define SYSCTL_RCGC0_ADCSPD125K 0x00000000  // 125K samples/second
-#define SYSCTL_RCGC0_ADCSPD250K 0x00000100  // 250K samples/second
-#define SYSCTL_RCGC0_ADCSPD500K 0x00000200  // 500K samples/second
-#define SYSCTL_RCGC0_ADCSPD1M   0x00000300  // 1M samples/second
-#define SYSCTL_RCGC0_HIB        0x00000040  // HIB Clock Gating Control.
-#define SYSCTL_RCGC0_WDT        0x00000008  // WDT Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_RCGC1 register.
-//
-//*****************************************************************************
-#define SYSCTL_RCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
-                                            // Gating.
-#define SYSCTL_RCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
-                                            // Gating.
-#define SYSCTL_RCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
-                                            // Gating.
-#define SYSCTL_RCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
-#define SYSCTL_RCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
-#define SYSCTL_RCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
-#define SYSCTL_RCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
-#define SYSCTL_RCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
-#define SYSCTL_RCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
-#define SYSCTL_RCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
-#define SYSCTL_RCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
-#define SYSCTL_RCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
-#define SYSCTL_RCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
-#define SYSCTL_RCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
-#define SYSCTL_RCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
-#define SYSCTL_RCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_RCGC2 register.
-//
-//*****************************************************************************
-#define SYSCTL_RCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
-#define SYSCTL_RCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
-#define SYSCTL_RCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
-#define SYSCTL_RCGC2_UDMA       0x00002000  // UDMA Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
-#define SYSCTL_RCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_SCGC0 register.
-//
-//*****************************************************************************
-#define SYSCTL_SCGC0_CAN2       0x04000000  // CAN2 Clock Gating Control.
-#define SYSCTL_SCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
-#define SYSCTL_SCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
-#define SYSCTL_SCGC0_PWM        0x00100000  // PWM Clock Gating Control.
-#define SYSCTL_SCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
-#define SYSCTL_SCGC0_ADCSPD_M   0x00000F00  // ADC Sample Speed.
-#define SYSCTL_SCGC0_ADCSPD125K 0x00000000  // 125K samples/second
-#define SYSCTL_SCGC0_ADCSPD250K 0x00000100  // 250K samples/second
-#define SYSCTL_SCGC0_ADCSPD500K 0x00000200  // 500K samples/second
-#define SYSCTL_SCGC0_ADCSPD1M   0x00000300  // 1M samples/second
-#define SYSCTL_SCGC0_HIB        0x00000040  // HIB Clock Gating Control.
-#define SYSCTL_SCGC0_WDT        0x00000008  // WDT Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_SCGC1 register.
-//
-//*****************************************************************************
-#define SYSCTL_SCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
-                                            // Gating.
-#define SYSCTL_SCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
-                                            // Gating.
-#define SYSCTL_SCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
-                                            // Gating.
-#define SYSCTL_SCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
-#define SYSCTL_SCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
-#define SYSCTL_SCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
-#define SYSCTL_SCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
-#define SYSCTL_SCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
-#define SYSCTL_SCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
-#define SYSCTL_SCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
-#define SYSCTL_SCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
-#define SYSCTL_SCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
-#define SYSCTL_SCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
-#define SYSCTL_SCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
-#define SYSCTL_SCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
-#define SYSCTL_SCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_SCGC2 register.
-//
-//*****************************************************************************
-#define SYSCTL_SCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
-#define SYSCTL_SCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
-#define SYSCTL_SCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
-#define SYSCTL_SCGC2_UDMA       0x00002000  // UDMA Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
-#define SYSCTL_SCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DCGC0 register.
-//
-//*****************************************************************************
-#define SYSCTL_DCGC0_CAN2       0x04000000  // CAN2 Clock Gating Control.
-#define SYSCTL_DCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
-#define SYSCTL_DCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
-#define SYSCTL_DCGC0_PWM        0x00100000  // PWM Clock Gating Control.
-#define SYSCTL_DCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
-#define SYSCTL_DCGC0_ADCSPD_M   0x00000F00  // ADC Sample Speed.
-#define SYSCTL_DCGC0_ADCSPD125K 0x00000000  // 125K samples/second
-#define SYSCTL_DCGC0_ADCSPD250K 0x00000100  // 250K samples/second
-#define SYSCTL_DCGC0_ADCSPD500K 0x00000200  // 500K samples/second
-#define SYSCTL_DCGC0_ADCSPD1M   0x00000300  // 1M samples/second
-#define SYSCTL_DCGC0_HIB        0x00000040  // HIB Clock Gating Control.
-#define SYSCTL_DCGC0_WDT        0x00000008  // WDT Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DCGC1 register.
-//
-//*****************************************************************************
-#define SYSCTL_DCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
-                                            // Gating.
-#define SYSCTL_DCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
-                                            // Gating.
-#define SYSCTL_DCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
-                                            // Gating.
-#define SYSCTL_DCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
-#define SYSCTL_DCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
-#define SYSCTL_DCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
-#define SYSCTL_DCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
-#define SYSCTL_DCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
-#define SYSCTL_DCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
-#define SYSCTL_DCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
-#define SYSCTL_DCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
-#define SYSCTL_DCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
-#define SYSCTL_DCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
-#define SYSCTL_DCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
-#define SYSCTL_DCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
-#define SYSCTL_DCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DCGC2 register.
-//
-//*****************************************************************************
-#define SYSCTL_DCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
-#define SYSCTL_DCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
-#define SYSCTL_DCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
-#define SYSCTL_DCGC2_UDMA       0x00002000  // UDMA Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
-#define SYSCTL_DCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC5 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC5_PWMFAULT3    0x08000000  // PWM Fault 3 Pin Present.
-#define SYSCTL_DC5_PWMFAULT2    0x04000000  // PWM Fault 2 Pin Present.
-#define SYSCTL_DC5_PWMFAULT1    0x02000000  // PWM Fault 1 Pin Present.
-#define SYSCTL_DC5_PWMFAULT0    0x01000000  // PWM Fault 0 Pin Present.
-#define SYSCTL_DC5_PWMEFLT      0x00200000  // PWM Extended Fault feature is
-                                            // active.
-#define SYSCTL_DC5_PWMESYNC     0x00100000  // PWM Extended SYNC feature is
-                                            // active.
-#define SYSCTL_DC5_PWM7         0x00000080  // PWM7 Pin Present.
-#define SYSCTL_DC5_PWM6         0x00000040  // PWM6 Pin Present.
-#define SYSCTL_DC5_PWM5         0x00000020  // PWM5 Pin Present.
-#define SYSCTL_DC5_PWM4         0x00000010  // PWM4 Pin Present.
-#define SYSCTL_DC5_PWM3         0x00000008  // PWM3 Pin Present.
-#define SYSCTL_DC5_PWM2         0x00000004  // PWM2 Pin Present.
-#define SYSCTL_DC5_PWM1         0x00000002  // PWM1 Pin Present.
-#define SYSCTL_DC5_PWM0         0x00000001  // PWM0 Pin Present.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC6 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC6_USB0_M       0x00000003  // This specifies that USB0 is
-                                            // present and its capability.
-#define SYSCTL_DC6_USB0_HOSTDEV 0x00000002  // USB is DEVICE or HOST
-#define SYSCTL_DC6_USB0_OTG     0x00000003  // USB is OTG
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_GPIOHSCTL
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_GPIOHSCTL_PORTH  0x00000080  // Port H High-Speed.
-#define SYSCTL_GPIOHSCTL_PORTG  0x00000040  // Port G High-Speed.
-#define SYSCTL_GPIOHSCTL_PORTF  0x00000020  // Port F High-Speed.
-#define SYSCTL_GPIOHSCTL_PORTE  0x00000010  // Port E High-Speed.
-#define SYSCTL_GPIOHSCTL_PORTD  0x00000008  // Port D High-Speed.
-#define SYSCTL_GPIOHSCTL_PORTC  0x00000004  // Port C High-Speed.
-#define SYSCTL_GPIOHSCTL_PORTB  0x00000002  // Port B High-Speed.
-#define SYSCTL_GPIOHSCTL_PORTA  0x00000001  // Port A High-Speed.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_MOSCCTL register.
-//
-//*****************************************************************************
-#define SYSCTL_MOSCCTL_CVAL     0x00000001  // Clock Validation for MOSC.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the SYSCTL_DC7 register.
-//
-//*****************************************************************************
-#define SYSCTL_DC7_SSI1_TX      0x02000000  // SSI1 TX on uDMA Ch25.
-#define SYSCTL_DC7_SSI1_RX      0x01000000  // SSI1 RX on uDMA Ch24.
-#define SYSCTL_DC7_UART1_TX     0x00800000  // UART1 TX on uDMA Ch23.
-#define SYSCTL_DC7_UART1_RX     0x00400000  // UART1 RX on uDMA Ch22.
-#define SYSCTL_DC7_SSI0_TX      0x00000800  // SSI0 TX on uDMA Ch11.
-#define SYSCTL_DC7_SSI0_RX      0x00000400  // SSI0 RX on uDMA Ch10.
-#define SYSCTL_DC7_UART0_TX     0x00000200  // UART0 TX on uDMA Ch9.
-#define SYSCTL_DC7_UART0_RX     0x00000100  // UART0 RX on uDMA Ch8.
-#define SYSCTL_DC7_USB_EP3_TX   0x00000020  // USB EP3 TX on uDMA Ch5.
-#define SYSCTL_DC7_USB_EP3_RX   0x00000010  // USB EP3 RX on uDMA Ch4.
-#define SYSCTL_DC7_USB_EP2_TX   0x00000008  // USB EP2 TX on uDMA Ch3.
-#define SYSCTL_DC7_USB_EP2_RX   0x00000004  // USB EP2 RX on uDMA Ch2.
-#define SYSCTL_DC7_USB_EP1_TX   0x00000002  // USB EP1 TX on uDMA Ch1.
-#define SYSCTL_DC7_USB_EP1_RX   0x00000001  // USB EP1 RX on uDMA Ch0.
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the system control register
-// addresses.
-//
-//*****************************************************************************
-#define SYSCTL_USER0            0x400FE1E0  // NV User Register 0
-#define SYSCTL_USER1            0x400FE1E4  // NV User Register 1
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_DID0
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_DID0_VER_MASK    0x70000000  // DID0 version mask
-#define SYSCTL_DID0_CLASS_MASK  0x00FF0000  // Device Class
-#define SYSCTL_DID0_MAJ_MASK    0x0000FF00  // Major revision mask
-#define SYSCTL_DID0_MAJ_A       0x00000000  // Major revision A
-#define SYSCTL_DID0_MAJ_B       0x00000100  // Major revision B
-#define SYSCTL_DID0_MAJ_C       0x00000200  // Major revision C
-#define SYSCTL_DID0_MIN_MASK    0x000000FF  // Minor revision mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_DID1
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_DID1_VER_MASK    0xF0000000  // Register version mask
-#define SYSCTL_DID1_FAM_MASK    0x0F000000  // Family mask
-#define SYSCTL_DID1_FAM_S       0x00000000  // Stellaris family
-#define SYSCTL_DID1_PRTNO_MASK  0x00FF0000  // Part number mask
-#define SYSCTL_DID1_PINCNT_MASK 0x0000E000  // Pin count
-#define SYSCTL_DID1_TEMP_MASK   0x000000E0  // Temperature range mask
-#define SYSCTL_DID1_PKG_MASK    0x00000018  // Package mask
-#define SYSCTL_DID1_QUAL_MASK   0x00000003  // Qualification status mask
-#define SYSCTL_DID1_PRTNO_SHIFT 16
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_DC0
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_DC0_SRAMSZ_MASK  0xFFFF0000  // SRAM size mask
-#define SYSCTL_DC0_FLASHSZ_MASK 0x0000FFFF  // Flash size mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_DC1
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_DC1_SYSDIV_MASK  0x0000F000  // Minimum system divider mask
-#define SYSCTL_DC1_ADCSPD_MASK  0x00000F00  // ADC speed mask
-#define SYSCTL_DC1_WDOG         0x00000008  // Watchdog present
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_DC2
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_DC2_I2C          0x00001000  // I2C present
-#define SYSCTL_DC2_QEI          0x00000100  // QEI present
-#define SYSCTL_DC2_SSI          0x00000010  // SSI present
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_DC3
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_DC3_MC_FAULT0    0x00008000  // MC0 fault pin present
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the
-// SYSCTL_PBORCTL register.
-//
-//*****************************************************************************
-#define SYSCTL_PBORCTL_BOR_MASK 0x0000FFFC  // BOR wait timer
-#define SYSCTL_PBORCTL_BOR_SH   2
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the
-// SYSCTL_LDOPCTL register.
-//
-//*****************************************************************************
-#define SYSCTL_LDOPCTL_MASK     0x0000003F  // Voltage adjust mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_SRCR0,
-// SYSCTL_RCGC0, SYSCTL_SCGC0, and SYSCTL_DCGC0 registers.
-//
-//*****************************************************************************
-#define SYSCTL_SET0_CAN2        0x04000000  // CAN 2 module
-#define SYSCTL_SET0_CAN1        0x02000000  // CAN 1 module
-#define SYSCTL_SET0_CAN0        0x01000000  // CAN 0 module
-#define SYSCTL_SET0_PWM         0x00100000  // PWM module
-#define SYSCTL_SET0_ADC         0x00010000  // ADC module
-#define SYSCTL_SET0_ADCSPD_MASK 0x00000F00  // ADC speed mask
-#define SYSCTL_SET0_ADCSPD_125K 0x00000000  // 125Ksps ADC
-#define SYSCTL_SET0_ADCSPD_250K 0x00000100  // 250Ksps ADC
-#define SYSCTL_SET0_ADCSPD_500K 0x00000200  // 500Ksps ADC
-#define SYSCTL_SET0_ADCSPD_1M   0x00000300  // 1Msps ADC
-#define SYSCTL_SET0_HIB         0x00000040  // Hibernation module
-#define SYSCTL_SET0_WDOG        0x00000008  // Watchdog module
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_SRCR1,
-// SYSCTL_RCGC1, SYSCTL_SCGC1, and SYSCTL_DCGC1 registers.
-//
-//*****************************************************************************
-#define SYSCTL_SET1_COMP2       0x04000000  // Analog comparator module 2
-#define SYSCTL_SET1_COMP1       0x02000000  // Analog comparator module 1
-#define SYSCTL_SET1_COMP0       0x01000000  // Analog comparator module 0
-#define SYSCTL_SET1_TIMER3      0x00080000  // Timer module 3
-#define SYSCTL_SET1_TIMER2      0x00040000  // Timer module 2
-#define SYSCTL_SET1_TIMER1      0x00020000  // Timer module 1
-#define SYSCTL_SET1_TIMER0      0x00010000  // Timer module 0
-#define SYSCTL_SET1_I2C1        0x00002000  // I2C module 1
-#define SYSCTL_SET1_I2C0        0x00001000  // I2C module 0
-#define SYSCTL_SET1_I2C         0x00001000  // I2C module
-#define SYSCTL_SET1_QEI1        0x00000200  // QEI module 1
-#define SYSCTL_SET1_QEI         0x00000100  // QEI module
-#define SYSCTL_SET1_QEI0        0x00000100  // QEI module 0
-#define SYSCTL_SET1_SSI1        0x00000020  // SSI module 1
-#define SYSCTL_SET1_SSI0        0x00000010  // SSI module 0
-#define SYSCTL_SET1_SSI         0x00000010  // SSI module
-#define SYSCTL_SET1_UART2       0x00000004  // UART module 2
-#define SYSCTL_SET1_UART1       0x00000002  // UART module 1
-#define SYSCTL_SET1_UART0       0x00000001  // UART module 0
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_SRCR2,
-// SYSCTL_RCGC2, SYSCTL_SCGC2, and SYSCTL_DCGC2 registers.
-//
-//*****************************************************************************
-#define SYSCTL_SET2_ETH         0x50000000  // ETH module
-#define SYSCTL_SET2_GPIOH       0x00000080  // GPIO H module
-#define SYSCTL_SET2_GPIOG       0x00000040  // GPIO G module
-#define SYSCTL_SET2_GPIOF       0x00000020  // GPIO F module
-#define SYSCTL_SET2_GPIOE       0x00000010  // GPIO E module
-#define SYSCTL_SET2_GPIOD       0x00000008  // GPIO D module
-#define SYSCTL_SET2_GPIOC       0x00000004  // GPIO C module
-#define SYSCTL_SET2_GPIOB       0x00000002  // GPIO B module
-#define SYSCTL_SET2_GPIOA       0x00000001  // GIPO A module
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_RIS,
-// SYSCTL_IMC, and SYSCTL_IMS registers.
-//
-//*****************************************************************************
-#define SYSCTL_INT_PLL_LOCK     0x00000040  // PLL lock interrupt
-#define SYSCTL_INT_CUR_LIMIT    0x00000020  // Current limit interrupt
-#define SYSCTL_INT_IOSC_FAIL    0x00000010  // Internal oscillator failure int
-#define SYSCTL_INT_MOSC_FAIL    0x00000008  // Main oscillator failure int
-#define SYSCTL_INT_POR          0x00000004  // Power on reset interrupt
-#define SYSCTL_INT_BOR          0x00000002  // Brown out interrupt
-#define SYSCTL_INT_PLL_FAIL     0x00000001  // PLL failure interrupt
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_RESC
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_RESC_WDOG        0x00000008  // Watchdog reset
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_RCC
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_RCC_SYSDIV_MASK  0x07800000  // System clock divider
-#define SYSCTL_RCC_USE_SYSDIV   0x00400000  // Use sytem clock divider
-#define SYSCTL_RCC_USE_PWMDIV   0x00100000  // Use PWM clock divider
-#define SYSCTL_RCC_PWMDIV_MASK  0x000E0000  // PWM clock divider
-#define SYSCTL_RCC_OE           0x00001000  // PLL output enable
-#define SYSCTL_RCC_XTAL_3_68MHz 0x00000140  // Using a 3.6864 MHz crystal
-#define SYSCTL_RCC_XTAL_4MHz    0x00000180  // Using a 4 MHz crystal
-#define SYSCTL_RCC_XTAL_MASK    0x000003C0  // Crystal attached to main osc
-#define SYSCTL_RCC_OSCSRC_MASK  0x00000030  // Oscillator input select
-#define SYSCTL_RCC_SYSDIV_SHIFT 23          // Shift to the SYSDIV field
-#define SYSCTL_RCC_PWMDIV_SHIFT 17          // Shift to the PWMDIV field
-#define SYSCTL_RCC_XTAL_SHIFT   6           // Shift to the XTAL field
-#define SYSCTL_RCC_OSCSRC_SHIFT 4           // Shift to the OSCSRC field
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_PLLCFG
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_PLLCFG_OD_MASK   0x0000C000  // Output divider
-#define SYSCTL_PLLCFG_F_MASK    0x00003FE0  // PLL multiplier
-#define SYSCTL_PLLCFG_R_MASK    0x0000001F  // Input predivider
-#define SYSCTL_PLLCFG_F_SHIFT   5
-#define SYSCTL_PLLCFG_R_SHIFT   0
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the SYSCTL_RCC2
-// register.
-//
-//*****************************************************************************
-#define SYSCTL_RCC2_SYSDIV2_MSK 0x1F800000  // System clock divider
-#define SYSCTL_RCC2_OSCSRC2_MSK 0x00000070  // Oscillator input select
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the
-// SYSCTL_DSLPCLKCFG register.
-//
-//*****************************************************************************
-#define SYSCTL_DSLPCLKCFG_D_MSK 0x1F800000  // Deep sleep system clock override
-#define SYSCTL_DSLPCLKCFG_O_MSK 0x00000070  // Deep sleep oscillator override
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the
-// SYSCTL_CLKVCLR register.
-//
-//*****************************************************************************
-#define SYSCTL_CLKVCLR_CLR      0x00000001  // Clear clock verification fault
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the
-// SYSCTL_LDOARST register.
-//
-//*****************************************************************************
-#define SYSCTL_LDOARST_ARST     0x00000001  // Allow LDO to reset device
-
-#endif
-
-#endif // __HW_SYSCTL_H__
+//*****************************************************************************
+//
+// hw_sysctl.h - Macros used when accessing the system control hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_SYSCTL_H__
+#define __HW_SYSCTL_H__
+
+//*****************************************************************************
+//
+// The following are defines for the system control register addresses.
+//
+//*****************************************************************************
+#define SYSCTL_DID0             0x400FE000  // Device identification register 0
+#define SYSCTL_DID1             0x400FE004  // Device identification register 1
+#define SYSCTL_DC0              0x400FE008  // Device capabilities register 0
+#define SYSCTL_DC1              0x400FE010  // Device capabilities register 1
+#define SYSCTL_DC2              0x400FE014  // Device capabilities register 2
+#define SYSCTL_DC3              0x400FE018  // Device capabilities register 3
+#define SYSCTL_DC4              0x400FE01C  // Device capabilities register 4
+#define SYSCTL_DC5              0x400FE020  // Device capabilities register 5
+#define SYSCTL_DC6              0x400FE024  // Device capabilities register 6
+#define SYSCTL_DC7              0x400FE028  // Device capabilities register 7
+#define SYSCTL_DC8              0x400FE02C  // Device capabilities register 8
+#define SYSCTL_PBORCTL          0x400FE030  // POR/BOR reset control register
+#define SYSCTL_LDOPCTL          0x400FE034  // LDO power control register
+#define SYSCTL_SRCR0            0x400FE040  // Software reset control reg 0
+#define SYSCTL_SRCR1            0x400FE044  // Software reset control reg 1
+#define SYSCTL_SRCR2            0x400FE048  // Software reset control reg 2
+#define SYSCTL_RIS              0x400FE050  // Raw interrupt status register
+#define SYSCTL_IMC              0x400FE054  // Interrupt mask/control register
+#define SYSCTL_MISC             0x400FE058  // Interrupt status register
+#define SYSCTL_RESC             0x400FE05C  // Reset cause register
+#define SYSCTL_RCC              0x400FE060  // Run-mode clock config register
+#define SYSCTL_PLLCFG           0x400FE064  // PLL configuration register
+#define SYSCTL_GPIOHSCTL        0x400FE06C  // GPIO High Speed Control
+#define SYSCTL_GPIOHBCTL        0x400FE06C  // GPIO Host-Bus Control
+#define SYSCTL_RCC2             0x400FE070  // Run-mode clock config register 2
+#define SYSCTL_MOSCCTL          0x400FE07C  // Main Oscillator Control
+#define SYSCTL_PIOSCCTL         0x400FE088  // Precision internal oscillator
+                                            // control register
+#define SYSCTL_RCGC0            0x400FE100  // Run-mode clock gating register 0
+#define SYSCTL_RCGC1            0x400FE104  // Run-mode clock gating register 1
+#define SYSCTL_RCGC2            0x400FE108  // Run-mode clock gating register 2
+#define SYSCTL_SCGC0            0x400FE110  // Sleep-mode clock gating reg 0
+#define SYSCTL_SCGC1            0x400FE114  // Sleep-mode clock gating reg 1
+#define SYSCTL_SCGC2            0x400FE118  // Sleep-mode clock gating reg 2
+#define SYSCTL_DCGC0            0x400FE120  // Deep Sleep-mode clock gate reg 0
+#define SYSCTL_DCGC1            0x400FE124  // Deep Sleep-mode clock gate reg 1
+#define SYSCTL_DCGC2            0x400FE128  // Deep Sleep-mode clock gate reg 2
+#define SYSCTL_DSLPCLKCFG       0x400FE144  // Deep Sleep-mode clock config reg
+#define SYSCTL_DSFLASHCFG       0x400FE14C  // Deep Sleep Flash Configuration
+#define SYSCTL_CLKVCLR          0x400FE150  // Clock verifcation clear register
+#define SYSCTL_PIOSCCAL         0x400FE150  // Precision Internal Oscillator
+                                            // Calibration
+#define SYSCTL_PIOSCSTAT        0x400FE154  // Precision Internal Oscillator
+                                            // Statistics
+#define SYSCTL_LDOARST          0x400FE160  // LDO reset control register
+#define SYSCTL_I2SMCLKCFG       0x400FE170  // I2S MCLK Configuration
+#define SYSCTL_DC9              0x400FE190  // Device capabilities register 9
+#define SYSCTL_NVMSTAT          0x400FE1A0  // Non-Volitile Memory Information
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID0_VER_M       0x70000000  // DID0 version mask
+#define SYSCTL_DID0_VER_0       0x00000000  // DID0 version 0
+#define SYSCTL_DID0_VER_1       0x10000000  // DID0 version 1
+#define SYSCTL_DID0_CLASS_M     0x00FF0000  // Device Class
+#define SYSCTL_DID0_CLASS_SANDSTORM \
+                                0x00000000  // Sandstorm-class Device
+#define SYSCTL_DID0_CLASS_FURY  0x00010000  // Fury-class Device
+#define SYSCTL_DID0_CLASS_DUSTDEVIL \
+                                0x00030000  // DustDevil-class Device
+#define SYSCTL_DID0_CLASS_TEMPEST \
+                                0x00040000  // Tempest-class Device
+#define SYSCTL_DID0_MAJ_M       0x0000FF00  // Major revision mask
+#define SYSCTL_DID0_MAJ_REVA    0x00000000  // Revision A (initial device)
+#define SYSCTL_DID0_MAJ_REVB    0x00000100  // Revision B (first base layer
+                                            // revision)
+#define SYSCTL_DID0_MAJ_REVC    0x00000200  // Revision C (second base layer
+                                            // revision)
+#define SYSCTL_DID0_MIN_M       0x000000FF  // Minor revision mask
+#define SYSCTL_DID0_MIN_0       0x00000000  // Minor revision 0
+#define SYSCTL_DID0_MIN_1       0x00000001  // Minor revision 1
+#define SYSCTL_DID0_MIN_2       0x00000002  // Minor revision 2
+#define SYSCTL_DID0_MIN_3       0x00000003  // Minor revision 3
+#define SYSCTL_DID0_MIN_4       0x00000004  // Minor revision 4
+#define SYSCTL_DID0_MIN_5       0x00000005  // Minor revision 5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID1_VER_M       0xF0000000  // DID1 Version.
+#define SYSCTL_DID1_VER_0       0x00000000  // Initial DID1 register format
+                                            // definition, indicating a
+                                            // Stellaris LM3Snnn device.
+#define SYSCTL_DID1_VER_1       0x10000000  // First revision of the DID1
+                                            // register format, indicating a
+                                            // Stellaris Fury-class device.
+#define SYSCTL_DID1_FAM_M       0x0F000000  // Family.
+#define SYSCTL_DID1_FAM_STELLARIS \
+                                0x00000000  // Stellaris family of
+                                            // microcontollers, that is, all
+                                            // devices with external part
+                                            // numbers starting with LM3S.
+#define SYSCTL_DID1_PRTNO_M     0x00FF0000  // Part number mask
+#define SYSCTL_DID1_PRTNO_2B93  0x006C0000  // LM3S2B93
+#define SYSCTL_DID1_PRTNO_5B91  0x00680000  // LM3S5B91
+#define SYSCTL_DID1_PRTNO_9B95  0x006E0000  // LM3S9B95
+#define SYSCTL_DID1_PRTNO_9B92  0x006A0000  // LM3S9B92
+#define SYSCTL_DID1_PRTNO_9B96  0x006F0000  // LM3S9B96
+#define SYSCTL_DID1_PRTNO_9B90  0x00660000  // LM3S9B90
+#define SYSCTL_DID1_PRTNO_101   0x00010000  // LM3S101
+#define SYSCTL_DID1_PRTNO_102   0x00020000  // LM3S102
+#define SYSCTL_DID1_PRTNO_300   0x00190000  // LM3S300
+#define SYSCTL_DID1_PRTNO_301   0x00110000  // LM3S301
+#define SYSCTL_DID1_PRTNO_308   0x001A0000  // LM3S308
+#define SYSCTL_DID1_PRTNO_310   0x00120000  // LM3S310
+#define SYSCTL_DID1_PRTNO_315   0x00130000  // LM3S315
+#define SYSCTL_DID1_PRTNO_316   0x00140000  // LM3S316
+#define SYSCTL_DID1_PRTNO_317   0x00170000  // LM3S317
+#define SYSCTL_DID1_PRTNO_328   0x00150000  // LM3S328
+#define SYSCTL_DID1_PRTNO_600   0x002A0000  // LM3S600
+#define SYSCTL_DID1_PRTNO_601   0x00210000  // LM3S601
+#define SYSCTL_DID1_PRTNO_608   0x002B0000  // LM3S608
+#define SYSCTL_DID1_PRTNO_610   0x00220000  // LM3S610
+#define SYSCTL_DID1_PRTNO_611   0x00230000  // LM3S611
+#define SYSCTL_DID1_PRTNO_612   0x00240000  // LM3S612
+#define SYSCTL_DID1_PRTNO_613   0x00250000  // LM3S613
+#define SYSCTL_DID1_PRTNO_615   0x00260000  // LM3S615
+#define SYSCTL_DID1_PRTNO_617   0x00280000  // LM3S617
+#define SYSCTL_DID1_PRTNO_618   0x00290000  // LM3S618
+#define SYSCTL_DID1_PRTNO_628   0x00270000  // LM3S628
+#define SYSCTL_DID1_PRTNO_800   0x00380000  // LM3S800
+#define SYSCTL_DID1_PRTNO_801   0x00310000  // LM3S801
+#define SYSCTL_DID1_PRTNO_808   0x00390000  // LM3S808
+#define SYSCTL_DID1_PRTNO_811   0x00320000  // LM3S811
+#define SYSCTL_DID1_PRTNO_812   0x00330000  // LM3S812
+#define SYSCTL_DID1_PRTNO_815   0x00340000  // LM3S815
+#define SYSCTL_DID1_PRTNO_817   0x00360000  // LM3S817
+#define SYSCTL_DID1_PRTNO_818   0x00370000  // LM3S818
+#define SYSCTL_DID1_PRTNO_828   0x00350000  // LM3S828
+#define SYSCTL_DID1_PRTNO_1110  0x00BF0000  // LM3S1110
+#define SYSCTL_DID1_PRTNO_1133  0x00C30000  // LM3S1133
+#define SYSCTL_DID1_PRTNO_1138  0x00C50000  // LM3S1138
+#define SYSCTL_DID1_PRTNO_1150  0x00C10000  // LM3S1150
+#define SYSCTL_DID1_PRTNO_1162  0x00C40000  // LM3S1162
+#define SYSCTL_DID1_PRTNO_1165  0x00C20000  // LM3S1165
+#define SYSCTL_DID1_PRTNO_1332  0x00C60000  // LM3S1332
+#define SYSCTL_DID1_PRTNO_1435  0x00BC0000  // LM3S1435
+#define SYSCTL_DID1_PRTNO_1439  0x00BA0000  // LM3S1439
+#define SYSCTL_DID1_PRTNO_1512  0x00BB0000  // LM3S1512
+#define SYSCTL_DID1_PRTNO_1538  0x00C70000  // LM3S1538
+#define SYSCTL_DID1_PRTNO_1601  0x00DB0000  // LM3S1601
+#define SYSCTL_DID1_PRTNO_1607  0x00060000  // LM3S1607
+#define SYSCTL_DID1_PRTNO_1608  0x00DA0000  // LM3S1608
+#define SYSCTL_DID1_PRTNO_1620  0x00C00000  // LM3S1620
+#define SYSCTL_DID1_PRTNO_1625  0x00030000  // LM3S1625
+#define SYSCTL_DID1_PRTNO_1626  0x00040000  // LM3S1626
+#define SYSCTL_DID1_PRTNO_1627  0x00050000  // LM3S1627
+#define SYSCTL_DID1_PRTNO_1635  0x00B30000  // LM3S1635
+#define SYSCTL_DID1_PRTNO_1637  0x00BD0000  // LM3S1637
+#define SYSCTL_DID1_PRTNO_1751  0x00B90000  // LM3S1751
+#define SYSCTL_DID1_PRTNO_1776  0x00100000  // LM3S1776
+#define SYSCTL_DID1_PRTNO_1850  0x00B40000  // LM3S1850
+#define SYSCTL_DID1_PRTNO_1911  0x00DD0000  // LM3S1911
+#define SYSCTL_DID1_PRTNO_1918  0x00DC0000  // LM3S1918
+#define SYSCTL_DID1_PRTNO_1937  0x00B70000  // LM3S1937
+#define SYSCTL_DID1_PRTNO_1958  0x00BE0000  // LM3S1958
+#define SYSCTL_DID1_PRTNO_1960  0x00B50000  // LM3S1960
+#define SYSCTL_DID1_PRTNO_1968  0x00B80000  // LM3S1968
+#define SYSCTL_DID1_PRTNO_2110  0x00510000  // LM3S2110
+#define SYSCTL_DID1_PRTNO_2139  0x00840000  // LM3S2139
+#define SYSCTL_DID1_PRTNO_2276  0x00390000  // LM3S2276
+#define SYSCTL_DID1_PRTNO_2410  0x00A20000  // LM3S2410
+#define SYSCTL_DID1_PRTNO_2412  0x00590000  // LM3S2412
+#define SYSCTL_DID1_PRTNO_2432  0x00560000  // LM3S2432
+#define SYSCTL_DID1_PRTNO_2533  0x005A0000  // LM3S2533
+#define SYSCTL_DID1_PRTNO_2601  0x00E10000  // LM3S2601
+#define SYSCTL_DID1_PRTNO_2608  0x00E00000  // LM3S2608
+#define SYSCTL_DID1_PRTNO_2616  0x00330000  // LM3S2616
+#define SYSCTL_DID1_PRTNO_2620  0x00570000  // LM3S2620
+#define SYSCTL_DID1_PRTNO_2637  0x00850000  // LM3S2637
+#define SYSCTL_DID1_PRTNO_2651  0x00530000  // LM3S2651
+#define SYSCTL_DID1_PRTNO_2671  0x00800000  // LM3S2671
+#define SYSCTL_DID1_PRTNO_2678  0x00500000  // LM3S2678
+#define SYSCTL_DID1_PRTNO_2730  0x00A40000  // LM3S2730
+#define SYSCTL_DID1_PRTNO_2739  0x00520000  // LM3S2739
+#define SYSCTL_DID1_PRTNO_2776  0x003A0000  // LM3S2776
+#define SYSCTL_DID1_PRTNO_2793  0x006D0000  // LM3S2793
+#define SYSCTL_DID1_PRTNO_2911  0x00E30000  // LM3S2911
+#define SYSCTL_DID1_PRTNO_2918  0x00E20000  // LM3S2918
+#define SYSCTL_DID1_PRTNO_2939  0x00540000  // LM3S2939
+#define SYSCTL_DID1_PRTNO_2948  0x008F0000  // LM3S2948
+#define SYSCTL_DID1_PRTNO_2950  0x00580000  // LM3S2950
+#define SYSCTL_DID1_PRTNO_2965  0x00550000  // LM3S2965
+#define SYSCTL_DID1_PRTNO_3651  0x00430000  // LM3S3651
+#define SYSCTL_DID1_PRTNO_3739  0x00440000  // LM3S3739
+#define SYSCTL_DID1_PRTNO_3748  0x00490000  // LM3S3748
+#define SYSCTL_DID1_PRTNO_3749  0x00450000  // LM3S3749
+#define SYSCTL_DID1_PRTNO_5632  0x00810000  // LM3S5632
+#define SYSCTL_DID1_PRTNO_5652  0x008A0000  // LM3S5652
+#define SYSCTL_DID1_PRTNO_5662  0x00910000  // LM3S5662
+#define SYSCTL_DID1_PRTNO_5732  0x00960000  // LM3S5732
+#define SYSCTL_DID1_PRTNO_5737  0x00970000  // LM3S5737
+#define SYSCTL_DID1_PRTNO_5739  0x00A00000  // LM3S5739
+#define SYSCTL_DID1_PRTNO_5747  0x00990000  // LM3S5747
+#define SYSCTL_DID1_PRTNO_5749  0x00A70000  // LM3S5749
+#define SYSCTL_DID1_PRTNO_5752  0x009A0000  // LM3S5752
+#define SYSCTL_DID1_PRTNO_5762  0x009C0000  // LM3S5762
+#define SYSCTL_DID1_PRTNO_5791  0x00690000  // LM3S5791
+#define SYSCTL_DID1_PRTNO_6100  0x00A10000  // LM3S6100
+#define SYSCTL_DID1_PRTNO_6110  0x00740000  // LM3S6110
+#define SYSCTL_DID1_PRTNO_6420  0x00A50000  // LM3S6420
+#define SYSCTL_DID1_PRTNO_6422  0x00820000  // LM3S6422
+#define SYSCTL_DID1_PRTNO_6432  0x00750000  // LM3S6432
+#define SYSCTL_DID1_PRTNO_6537  0x00760000  // LM3S6537
+#define SYSCTL_DID1_PRTNO_6610  0x00710000  // LM3S6610
+#define SYSCTL_DID1_PRTNO_6611  0x00E70000  // LM3S6611
+#define SYSCTL_DID1_PRTNO_6618  0x00E60000  // LM3S6618
+#define SYSCTL_DID1_PRTNO_6633  0x00830000  // LM3S6633
+#define SYSCTL_DID1_PRTNO_6637  0x008B0000  // LM3S6637
+#define SYSCTL_DID1_PRTNO_6730  0x00A30000  // LM3S6730
+#define SYSCTL_DID1_PRTNO_6753  0x00770000  // LM3S6753
+#define SYSCTL_DID1_PRTNO_6911  0x00E90000  // LM3S6911
+#define SYSCTL_DID1_PRTNO_6918  0x00E80000  // LM3S6918
+#define SYSCTL_DID1_PRTNO_6938  0x00890000  // LM3S6938
+#define SYSCTL_DID1_PRTNO_6950  0x00720000  // LM3S6950
+#define SYSCTL_DID1_PRTNO_6952  0x00780000  // LM3S6952
+#define SYSCTL_DID1_PRTNO_6965  0x00730000  // LM3S6965
+#define SYSCTL_DID1_PRTNO_8530  0x00640000  // LM3S8530
+#define SYSCTL_DID1_PRTNO_8538  0x008E0000  // LM3S8538
+#define SYSCTL_DID1_PRTNO_8630  0x00610000  // LM3S8630
+#define SYSCTL_DID1_PRTNO_8730  0x00630000  // LM3S8730
+#define SYSCTL_DID1_PRTNO_8733  0x008D0000  // LM3S8733
+#define SYSCTL_DID1_PRTNO_8738  0x00860000  // LM3S8738
+#define SYSCTL_DID1_PRTNO_8930  0x00650000  // LM3S8930
+#define SYSCTL_DID1_PRTNO_8933  0x008C0000  // LM3S8933
+#define SYSCTL_DID1_PRTNO_8938  0x00880000  // LM3S8938
+#define SYSCTL_DID1_PRTNO_8962  0x00A60000  // LM3S8962
+#define SYSCTL_DID1_PRTNO_8970  0x00620000  // LM3S8970
+#define SYSCTL_DID1_PRTNO_8971  0x00D70000  // LM3S8971
+#define SYSCTL_DID1_PRTNO_9790  0x00670000  // LM3S9790
+#define SYSCTL_DID1_PRTNO_9792  0x006B0000  // LM3S9792
+#define SYSCTL_DID1_PINCNT_M    0x0000E000  // Package Pin Count.
+#define SYSCTL_DID1_PINCNT_28   0x00000000  // 28 pin package
+#define SYSCTL_DID1_PINCNT_48   0x00002000  // 48 pin package
+#define SYSCTL_DID1_PINCNT_100  0x00004000  // 100 pin package
+#define SYSCTL_DID1_PINCNT_64   0x00006000  // 64 pin package
+#define SYSCTL_DID1_TEMP_M      0x000000E0  // Temperature range mask
+#define SYSCTL_DID1_TEMP_C      0x00000000  // Commercial temp range (0..70C)
+#define SYSCTL_DID1_TEMP_I      0x00000020  // Industrial temp range (-40..85C)
+#define SYSCTL_DID1_TEMP_E      0x00000040  // Extended temperature range (-40C
+                                            // to 105C)
+#define SYSCTL_DID1_PKG_M       0x00000018  // Package Type.
+#define SYSCTL_DID1_PKG_28SOIC  0x00000000  // 28-pin SOIC
+#define SYSCTL_DID1_PKG_48QFP   0x00000008  // 48-pin QFP
+#define SYSCTL_DID1_PKG_BGA     0x00000010  // BGA package
+#define SYSCTL_DID1_ROHS        0x00000004  // Part is RoHS compliant
+#define SYSCTL_DID1_QUAL_M      0x00000003  // Qualification status mask
+#define SYSCTL_DID1_QUAL_ES     0x00000000  // Engineering sample (unqualified)
+#define SYSCTL_DID1_QUAL_PP     0x00000001  // Pilot production (unqualified)
+#define SYSCTL_DID1_QUAL_FQ     0x00000002  // Fully qualified
+#define SYSCTL_DID1_PRTNO_S     16          // Part number shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC0_SRAMSZ_M     0xFFFF0000  // SRAM size mask
+#define SYSCTL_DC0_SRAMSZ_2KB   0x00070000  // 2 KB of SRAM
+#define SYSCTL_DC0_SRAMSZ_4KB   0x000F0000  // 4 KB of SRAM
+#define SYSCTL_DC0_SRAMSZ_8KB   0x001F0000  // 8 KB of SRAM
+#define SYSCTL_DC0_SRAMSZ_16KB  0x003F0000  // 16 KB of SRAM
+#define SYSCTL_DC0_SRAMSZ_32KB  0x007F0000  // 32 KB of SRAM
+#define SYSCTL_DC0_SRAMSZ_64KB  0x00FF0000  // 64 KB of SRAM
+#define SYSCTL_DC0_SRAMSZ_96KB  0x017F0000  // 96 KB of SRAM
+#define SYSCTL_DC0_FLASHSZ_M    0x0000FFFF  // Flash size mask
+#define SYSCTL_DC0_FLASHSZ_8KB  0x00000003  // 8 KB of flash
+#define SYSCTL_DC0_FLASHSZ_16KB 0x00000007  // 16 KB of flash
+#define SYSCTL_DC0_FLASHSZ_32KB 0x0000000F  // 32 KB of flash
+#define SYSCTL_DC0_FLASHSZ_64KB 0x0000001F  // 64 KB of flash
+#define SYSCTL_DC0_FLASHSZ_96KB 0x0000002F  // 96 KB of flash
+#define SYSCTL_DC0_FLASHSZ_128K 0x0000003F  // 128 KB of flash
+#define SYSCTL_DC0_FLASHSZ_256K 0x0000007F  // 256 KB of flash
+#define SYSCTL_DC0_SRAMSZ_S     16          // SRAM size shift
+#define SYSCTL_DC0_FLASHSZ_S    0           // Flash size shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC1_WDT1         0x10000000  // Watchdog Timer1 Present.
+#define SYSCTL_DC1_CAN2         0x04000000  // CAN2 module present
+#define SYSCTL_DC1_CAN1         0x02000000  // CAN1 module present
+#define SYSCTL_DC1_CAN0         0x01000000  // CAN0 module present
+#define SYSCTL_DC1_PWM          0x00100000  // PWM module present
+#define SYSCTL_DC1_ADC1         0x00020000  // ADC Module 1 Present.
+#define SYSCTL_DC1_ADC0         0x00010000  // ADC Module 0 Present.
+#define SYSCTL_DC1_MINSYSDIV_M  0x0000F000  // System Clock Divider.
+#define SYSCTL_DC1_MINSYSDIV_100 \
+                                0x00001000  // Specifies a 100-MHz clock with a
+                                            // PLL divider of 2.
+#define SYSCTL_DC1_MINSYSDIV_66 0x00002000  // Specifies a 66-MHz clock with a
+                                            // PLL divider of 3.
+#define SYSCTL_DC1_MINSYSDIV_50 0x00003000  // Specifies a 50-MHz clock with a
+                                            // PLL divider of 4.
+#define SYSCTL_DC1_MINSYSDIV_25 0x00007000  // Specifies a 25-MHz clock with a
+                                            // PLL divider of 8.
+#define SYSCTL_DC1_MINSYSDIV_20 0x00009000  // Specifies a 20-MHz clock with a
+                                            // PLL divider of 10.
+#define SYSCTL_DC1_ADCSPD_M     0x00000F00  // ADC speed mask
+#define SYSCTL_DC1_ADCSPD_125K  0x00000000  // 125Ksps ADC
+#define SYSCTL_DC1_ADCSPD_250K  0x00000100  // 250Ksps ADC
+#define SYSCTL_DC1_ADCSPD_500K  0x00000200  // 500Ksps ADC
+#define SYSCTL_DC1_ADCSPD_1M    0x00000300  // 1Msps ADC
+#define SYSCTL_DC1_ADC1SPD_M    0x00000C00  // Max ADC1 Speed.
+#define SYSCTL_DC1_ADC1SPD_1M   0x00000C00  // 1M samples/second
+#define SYSCTL_DC1_ADC0SPD_M    0x00000300  // Max ADC0 Speed.
+#define SYSCTL_DC1_ADC0SPD_1M   0x00000300  // 1M samples/second
+#define SYSCTL_DC1_MPU          0x00000080  // Cortex M3 MPU present
+#define SYSCTL_DC1_HIB          0x00000040  // Hibernation module present
+#define SYSCTL_DC1_TEMP         0x00000020  // Temperature sensor present
+#define SYSCTL_DC1_PLL          0x00000010  // PLL present
+#define SYSCTL_DC1_WDT0         0x00000008  // Watchdog Timer 0 Present.
+#define SYSCTL_DC1_SWO          0x00000004  // Serial wire output present
+#define SYSCTL_DC1_SWD          0x00000002  // Serial wire debug present
+#define SYSCTL_DC1_JTAG         0x00000001  // JTAG debug present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC2_EPI0         0x40000000  // EPI0 Present.
+#define SYSCTL_DC2_I2S0         0x10000000  // I2S 0 Present.
+#define SYSCTL_DC2_COMP2        0x04000000  // Analog comparator 2 present
+#define SYSCTL_DC2_COMP1        0x02000000  // Analog comparator 1 present
+#define SYSCTL_DC2_COMP0        0x01000000  // Analog comparator 0 present
+#define SYSCTL_DC2_TIMER3       0x00080000  // Timer 3 present
+#define SYSCTL_DC2_TIMER2       0x00040000  // Timer 2 present
+#define SYSCTL_DC2_TIMER1       0x00020000  // Timer 1 present
+#define SYSCTL_DC2_TIMER0       0x00010000  // Timer 0 present
+#define SYSCTL_DC2_I2C1         0x00004000  // I2C 1 present
+#define SYSCTL_DC2_I2C0         0x00001000  // I2C 0 present
+#define SYSCTL_DC2_QEI1         0x00000200  // QEI 1 present
+#define SYSCTL_DC2_QEI0         0x00000100  // QEI 0 present
+#define SYSCTL_DC2_SSI1         0x00000020  // SSI 1 present
+#define SYSCTL_DC2_SSI0         0x00000010  // SSI 0 present
+#define SYSCTL_DC2_UART2        0x00000004  // UART 2 present
+#define SYSCTL_DC2_UART1        0x00000002  // UART 1 present
+#define SYSCTL_DC2_UART0        0x00000001  // UART 0 present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC3 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC3_32KHZ        0x80000000  // 32KHz Pin Present.
+#define SYSCTL_DC3_CCP5         0x20000000  // CCP5 pin present
+#define SYSCTL_DC3_CCP4         0x10000000  // CCP4 pin present
+#define SYSCTL_DC3_CCP3         0x08000000  // CCP3 pin present
+#define SYSCTL_DC3_CCP2         0x04000000  // CCP2 pin present
+#define SYSCTL_DC3_CCP1         0x02000000  // CCP1 pin present
+#define SYSCTL_DC3_CCP0         0x01000000  // CCP0 pin present
+#define SYSCTL_DC3_ADC0AIN7     0x00800000  // AIN7 Pin Present.
+#define SYSCTL_DC3_ADC0AIN6     0x00400000  // AIN6 Pin Present.
+#define SYSCTL_DC3_ADC0AIN5     0x00200000  // AIN5 Pin Present.
+#define SYSCTL_DC3_ADC0AIN4     0x00100000  // AIN4 Pin Present.
+#define SYSCTL_DC3_ADC0AIN3     0x00080000  // AIN3 Pin Present.
+#define SYSCTL_DC3_ADC0AIN2     0x00040000  // AIN2 Pin Present.
+#define SYSCTL_DC3_ADC0AIN1     0x00020000  // AIN1 Pin Present.
+#define SYSCTL_DC3_ADC0AIN0     0x00010000  // AIN0 Pin Present.
+#define SYSCTL_DC3_PWMFAULT     0x00008000  // PWM Fault Pin Present.
+#define SYSCTL_DC3_C2O          0x00004000  // C2o pin present
+#define SYSCTL_DC3_C2PLUS       0x00002000  // C2+ pin present
+#define SYSCTL_DC3_C2MINUS      0x00001000  // C2- pin present
+#define SYSCTL_DC3_C1O          0x00000800  // C1o pin present
+#define SYSCTL_DC3_C1PLUS       0x00000400  // C1+ pin present
+#define SYSCTL_DC3_C1MINUS      0x00000200  // C1- pin present
+#define SYSCTL_DC3_C0O          0x00000100  // C0o pin present
+#define SYSCTL_DC3_C0PLUS       0x00000080  // C0+ pin present
+#define SYSCTL_DC3_C0MINUS      0x00000040  // C0- pin present
+#define SYSCTL_DC3_PWM5         0x00000020  // PWM5 pin present
+#define SYSCTL_DC3_PWM4         0x00000010  // PWM4 pin present
+#define SYSCTL_DC3_PWM3         0x00000008  // PWM3 pin present
+#define SYSCTL_DC3_PWM2         0x00000004  // PWM2 pin present
+#define SYSCTL_DC3_PWM1         0x00000002  // PWM1 pin present
+#define SYSCTL_DC3_PWM0         0x00000001  // PWM0 pin present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC4 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC4_ETH          0x50000000  // Ethernet present
+#define SYSCTL_DC4_EPHY0        0x40000000  // Ethernet PHY0 Present.
+#define SYSCTL_DC4_EMAC0        0x10000000  // Ethernet MAC0 Present.
+#define SYSCTL_DC4_E1588        0x01000000  // 1588 Capable.
+#define SYSCTL_DC4_PICAL        0x00040000  // When set, indicates that the
+                                            // USER can calibrate the PIOSC
+#define SYSCTL_DC4_CCP7         0x00008000  // CCP7 Pin Present.
+#define SYSCTL_DC4_CCP6         0x00004000  // CCP6 Pin Present.
+#define SYSCTL_DC4_UDMA         0x00002000  // Micro-DMA is present.
+#define SYSCTL_DC4_ROM          0x00001000  // Internal Code ROM is present.
+#define SYSCTL_DC4_GPIOJ        0x00000100  // GPIO Port J Present.
+#define SYSCTL_DC4_GPIOH        0x00000080  // GPIO port H present
+#define SYSCTL_DC4_GPIOG        0x00000040  // GPIO port G present
+#define SYSCTL_DC4_GPIOF        0x00000020  // GPIO port F present
+#define SYSCTL_DC4_GPIOE        0x00000010  // GPIO port E present
+#define SYSCTL_DC4_GPIOD        0x00000008  // GPIO port D present
+#define SYSCTL_DC4_GPIOC        0x00000004  // GPIO port C present
+#define SYSCTL_DC4_GPIOB        0x00000002  // GPIO port B present
+#define SYSCTL_DC4_GPIOA        0x00000001  // GPIO port A present
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PBORCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_PBORCTL_BORTIM_M 0x0000FFFC  // BOR Time Delay.
+#define SYSCTL_PBORCTL_BORIOR   0x00000002  // BOR interrupt or reset
+#define SYSCTL_PBORCTL_BORWT    0x00000001  // BOR wait and check for noise
+#define SYSCTL_PBORCTL_BORTIM_S 2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LDOPCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOPCTL_M        0x0000003F  // LDO Output Voltage.
+#define SYSCTL_LDOPCTL_2_55V    0x0000001F  // LDO output of 2.55V
+#define SYSCTL_LDOPCTL_2_60V    0x0000001E  // LDO output of 2.60V
+#define SYSCTL_LDOPCTL_2_65V    0x0000001D  // LDO output of 2.65V
+#define SYSCTL_LDOPCTL_2_70V    0x0000001C  // LDO output of 2.70V
+#define SYSCTL_LDOPCTL_2_75V    0x0000001B  // LDO output of 2.75V
+#define SYSCTL_LDOPCTL_2_25V    0x00000005  // LDO output of 2.25V
+#define SYSCTL_LDOPCTL_2_30V    0x00000004  // LDO output of 2.30V
+#define SYSCTL_LDOPCTL_2_35V    0x00000003  // LDO output of 2.35V
+#define SYSCTL_LDOPCTL_2_40V    0x00000002  // LDO output of 2.40V
+#define SYSCTL_LDOPCTL_2_45V    0x00000001  // LDO output of 2.45V
+#define SYSCTL_LDOPCTL_2_50V    0x00000000  // LDO output of 2.50V
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RESC register.
+//
+//*****************************************************************************
+#define SYSCTL_RESC_MOSCFAIL    0x00010000  // MOSC Failure Reset.
+#define SYSCTL_RESC_LDO         0x00000020  // LDO power OK lost reset
+#define SYSCTL_RESC_WDT1        0x00000020  // Watchdog Timer 1 Reset.
+#define SYSCTL_RESC_SW          0x00000010  // Software reset
+#define SYSCTL_RESC_WDT0        0x00000008  // Watchdog Timer 0 Reset.
+#define SYSCTL_RESC_BOR         0x00000004  // Brown-out reset
+#define SYSCTL_RESC_POR         0x00000002  // Power on reset
+#define SYSCTL_RESC_EXT         0x00000001  // External reset
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC_ACG          0x08000000  // Automatic clock gating
+#define SYSCTL_RCC_SYSDIV_M     0x07800000  // System Clock Divisor.
+#define SYSCTL_RCC_SYSDIV_2     0x00800000  // System clock /2
+#define SYSCTL_RCC_SYSDIV_3     0x01000000  // System clock /3
+#define SYSCTL_RCC_SYSDIV_4     0x01800000  // System clock /4
+#define SYSCTL_RCC_SYSDIV_5     0x02000000  // System clock /5
+#define SYSCTL_RCC_SYSDIV_6     0x02800000  // System clock /6
+#define SYSCTL_RCC_SYSDIV_7     0x03000000  // System clock /7
+#define SYSCTL_RCC_SYSDIV_8     0x03800000  // System clock /8
+#define SYSCTL_RCC_SYSDIV_9     0x04000000  // System clock /9
+#define SYSCTL_RCC_SYSDIV_10    0x04800000  // System clock /10
+#define SYSCTL_RCC_SYSDIV_11    0x05000000  // System clock /11
+#define SYSCTL_RCC_SYSDIV_12    0x05800000  // System clock /12
+#define SYSCTL_RCC_SYSDIV_13    0x06000000  // System clock /13
+#define SYSCTL_RCC_SYSDIV_14    0x06800000  // System clock /14
+#define SYSCTL_RCC_SYSDIV_15    0x07000000  // System clock /15
+#define SYSCTL_RCC_SYSDIV_16    0x07800000  // System clock /16
+#define SYSCTL_RCC_USESYSDIV    0x00400000  // Enable System Clock Divider.
+#define SYSCTL_RCC_USEPWMDIV    0x00100000  // Enable PWM Clock Divisor.
+#define SYSCTL_RCC_PWMDIV_M     0x000E0000  // PWM clock divider
+#define SYSCTL_RCC_PWMDIV_2     0x00000000  // PWM clock /2
+#define SYSCTL_RCC_PWMDIV_4     0x00020000  // PWM clock /4
+#define SYSCTL_RCC_PWMDIV_8     0x00040000  // PWM clock /8
+#define SYSCTL_RCC_PWMDIV_16    0x00060000  // PWM clock /16
+#define SYSCTL_RCC_PWMDIV_32    0x00080000  // PWM clock /32
+#define SYSCTL_RCC_PWMDIV_64    0x000A0000  // PWM clock /64
+#define SYSCTL_RCC_PWRDN        0x00002000  // PLL power down
+#define SYSCTL_RCC_OEN          0x00001000  // PLL Output Enable.
+#define SYSCTL_RCC_BYPASS       0x00000800  // PLL bypass
+#define SYSCTL_RCC_XTAL_M       0x000007C0  // Crystal attached to main osc
+#define SYSCTL_RCC_XTAL_1MHZ    0x00000000  // Using a 1MHz crystal
+#define SYSCTL_RCC_XTAL_1_84MHZ 0x00000040  // Using a 1.8432MHz crystal
+#define SYSCTL_RCC_XTAL_2MHZ    0x00000080  // Using a 2MHz crystal
+#define SYSCTL_RCC_XTAL_2_45MHZ 0x000000C0  // Using a 2.4576MHz crystal
+#define SYSCTL_RCC_XTAL_3_57MHZ 0x00000100  // Using a 3.579545MHz crystal
+#define SYSCTL_RCC_XTAL_3_68MHZ 0x00000140  // Using a 3.6864MHz crystal
+#define SYSCTL_RCC_XTAL_4MHZ    0x00000180  // Using a 4MHz crystal
+#define SYSCTL_RCC_XTAL_4_09MHZ 0x000001C0  // Using a 4.096MHz crystal
+#define SYSCTL_RCC_XTAL_4_91MHZ 0x00000200  // Using a 4.9152MHz crystal
+#define SYSCTL_RCC_XTAL_5MHZ    0x00000240  // Using a 5MHz crystal
+#define SYSCTL_RCC_XTAL_5_12MHZ 0x00000280  // Using a 5.12MHz crystal
+#define SYSCTL_RCC_XTAL_6MHZ    0x000002C0  // Using a 6MHz crystal
+#define SYSCTL_RCC_XTAL_6_14MHZ 0x00000300  // Using a 6.144MHz crystal
+#define SYSCTL_RCC_XTAL_7_37MHZ 0x00000340  // Using a 7.3728MHz crystal
+#define SYSCTL_RCC_XTAL_8MHZ    0x00000380  // Using a 8MHz crystal
+#define SYSCTL_RCC_XTAL_8_19MHZ 0x000003C0  // Using a 8.192MHz crystal
+#define SYSCTL_RCC_XTAL_10MHZ   0x00000400  // 10.0 MHz (USB)
+#define SYSCTL_RCC_XTAL_12MHZ   0x00000440  // 12.0 MHz (USB)
+#define SYSCTL_RCC_XTAL_12_2MHZ 0x00000480  // 12.288 MHz
+#define SYSCTL_RCC_XTAL_13_5MHZ 0x000004C0  // 13.56 MHz
+#define SYSCTL_RCC_XTAL_14_3MHZ 0x00000500  // 14.31818 MHz
+#define SYSCTL_RCC_XTAL_16MHZ   0x00000540  // 16.0 MHz (USB)
+#define SYSCTL_RCC_XTAL_16_3MHZ 0x00000580  // 16.384 MHz
+#define SYSCTL_RCC_PLLVER       0x00000400  // PLL verification timer enable
+#define SYSCTL_RCC_OSCSRC_M     0x00000030  // Oscillator input select
+#define SYSCTL_RCC_OSCSRC_MAIN  0x00000000  // Use the main oscillator
+#define SYSCTL_RCC_OSCSRC_INT   0x00000010  // Use the internal oscillator
+#define SYSCTL_RCC_OSCSRC_INT4  0x00000020  // Use the internal oscillator / 4
+#define SYSCTL_RCC_OSCSRC_30    0x00000030  // 30 KHz internal oscillator
+#define SYSCTL_RCC_IOSCVER      0x00000008  // Int. osc. verification timer en
+#define SYSCTL_RCC_MOSCVER      0x00000004  // Main osc. verification timer en
+#define SYSCTL_RCC_IOSCDIS      0x00000002  // Internal oscillator disable
+#define SYSCTL_RCC_MOSCDIS      0x00000001  // Main oscillator disable
+#define SYSCTL_RCC_SYSDIV_S     23          // Shift to the SYSDIV field
+#define SYSCTL_RCC_PWMDIV_S     17          // Shift to the PWMDIV field
+#define SYSCTL_RCC_XTAL_S       6           // Shift to the XTAL field
+#define SYSCTL_RCC_OSCSRC_S     4           // Shift to the OSCSRC field
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLCFG register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLCFG_OD_M      0x0000C000  // Output divider
+#define SYSCTL_PLLCFG_OD_1      0x00000000  // Output divider is 1
+#define SYSCTL_PLLCFG_OD_2      0x00004000  // Output divider is 2
+#define SYSCTL_PLLCFG_OD_4      0x00008000  // Output divider is 4
+#define SYSCTL_PLLCFG_F_M       0x00003FE0  // PLL F Value.
+#define SYSCTL_PLLCFG_R_M       0x0000001F  // PLL R Value.
+#define SYSCTL_PLLCFG_F_S       5
+#define SYSCTL_PLLCFG_R_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC2_USERCC2     0x80000000  // Use RCC2
+#define SYSCTL_RCC2_USEFRACT    0x40000000  // Use fractional divider
+#define SYSCTL_RCC2_SYSDIV2_M   0x1F800000  // System clock divider
+#define SYSCTL_RCC2_SYSDIV2_2   0x00800000  // System clock /2
+#define SYSCTL_RCC2_SYSDIV2_3   0x01000000  // System clock /3
+#define SYSCTL_RCC2_SYSDIV2_4   0x01800000  // System clock /4
+#define SYSCTL_RCC2_SYSDIV2_5   0x02000000  // System clock /5
+#define SYSCTL_RCC2_SYSDIV2_6   0x02800000  // System clock /6
+#define SYSCTL_RCC2_SYSDIV2_7   0x03000000  // System clock /7
+#define SYSCTL_RCC2_SYSDIV2_8   0x03800000  // System clock /8
+#define SYSCTL_RCC2_SYSDIV2_9   0x04000000  // System clock /9
+#define SYSCTL_RCC2_SYSDIV2_10  0x04800000  // System clock /10
+#define SYSCTL_RCC2_SYSDIV2_11  0x05000000  // System clock /11
+#define SYSCTL_RCC2_SYSDIV2_12  0x05800000  // System clock /12
+#define SYSCTL_RCC2_SYSDIV2_13  0x06000000  // System clock /13
+#define SYSCTL_RCC2_SYSDIV2_14  0x06800000  // System clock /14
+#define SYSCTL_RCC2_SYSDIV2_15  0x07000000  // System clock /15
+#define SYSCTL_RCC2_SYSDIV2_16  0x07800000  // System clock /16
+#define SYSCTL_RCC2_SYSDIV2_17  0x08000000  // System clock /17
+#define SYSCTL_RCC2_SYSDIV2_18  0x08800000  // System clock /18
+#define SYSCTL_RCC2_SYSDIV2_19  0x09000000  // System clock /19
+#define SYSCTL_RCC2_SYSDIV2_20  0x09800000  // System clock /20
+#define SYSCTL_RCC2_SYSDIV2_21  0x0A000000  // System clock /21
+#define SYSCTL_RCC2_SYSDIV2_22  0x0A800000  // System clock /22
+#define SYSCTL_RCC2_SYSDIV2_23  0x0B000000  // System clock /23
+#define SYSCTL_RCC2_SYSDIV2_24  0x0B800000  // System clock /24
+#define SYSCTL_RCC2_SYSDIV2_25  0x0C000000  // System clock /25
+#define SYSCTL_RCC2_SYSDIV2_26  0x0C800000  // System clock /26
+#define SYSCTL_RCC2_SYSDIV2_27  0x0D000000  // System clock /27
+#define SYSCTL_RCC2_SYSDIV2_28  0x0D800000  // System clock /28
+#define SYSCTL_RCC2_SYSDIV2_29  0x0E000000  // System clock /29
+#define SYSCTL_RCC2_SYSDIV2_30  0x0E800000  // System clock /30
+#define SYSCTL_RCC2_SYSDIV2_31  0x0F000000  // System clock /31
+#define SYSCTL_RCC2_SYSDIV2_32  0x0F800000  // System clock /32
+#define SYSCTL_RCC2_SYSDIV2_33  0x10000000  // System clock /33
+#define SYSCTL_RCC2_SYSDIV2_34  0x10800000  // System clock /34
+#define SYSCTL_RCC2_SYSDIV2_35  0x11000000  // System clock /35
+#define SYSCTL_RCC2_SYSDIV2_36  0x11800000  // System clock /36
+#define SYSCTL_RCC2_SYSDIV2_37  0x12000000  // System clock /37
+#define SYSCTL_RCC2_SYSDIV2_38  0x12800000  // System clock /38
+#define SYSCTL_RCC2_SYSDIV2_39  0x13000000  // System clock /39
+#define SYSCTL_RCC2_SYSDIV2_40  0x13800000  // System clock /40
+#define SYSCTL_RCC2_SYSDIV2_41  0x14000000  // System clock /41
+#define SYSCTL_RCC2_SYSDIV2_42  0x14800000  // System clock /42
+#define SYSCTL_RCC2_SYSDIV2_43  0x15000000  // System clock /43
+#define SYSCTL_RCC2_SYSDIV2_44  0x15800000  // System clock /44
+#define SYSCTL_RCC2_SYSDIV2_45  0x16000000  // System clock /45
+#define SYSCTL_RCC2_SYSDIV2_46  0x16800000  // System clock /46
+#define SYSCTL_RCC2_SYSDIV2_47  0x17000000  // System clock /47
+#define SYSCTL_RCC2_SYSDIV2_48  0x17800000  // System clock /48
+#define SYSCTL_RCC2_SYSDIV2_49  0x18000000  // System clock /49
+#define SYSCTL_RCC2_SYSDIV2_50  0x18800000  // System clock /50
+#define SYSCTL_RCC2_SYSDIV2_51  0x19000000  // System clock /51
+#define SYSCTL_RCC2_SYSDIV2_52  0x19800000  // System clock /52
+#define SYSCTL_RCC2_SYSDIV2_53  0x1A000000  // System clock /53
+#define SYSCTL_RCC2_SYSDIV2_54  0x1A800000  // System clock /54
+#define SYSCTL_RCC2_SYSDIV2_55  0x1B000000  // System clock /55
+#define SYSCTL_RCC2_SYSDIV2_56  0x1B800000  // System clock /56
+#define SYSCTL_RCC2_SYSDIV2_57  0x1C000000  // System clock /57
+#define SYSCTL_RCC2_SYSDIV2_58  0x1C800000  // System clock /58
+#define SYSCTL_RCC2_SYSDIV2_59  0x1D000000  // System clock /59
+#define SYSCTL_RCC2_SYSDIV2_60  0x1D800000  // System clock /60
+#define SYSCTL_RCC2_SYSDIV2_61  0x1E000000  // System clock /61
+#define SYSCTL_RCC2_SYSDIV2_62  0x1E800000  // System clock /62
+#define SYSCTL_RCC2_SYSDIV2_63  0x1F000000  // System clock /63
+#define SYSCTL_RCC2_SYSDIV2_64  0x1F800000  // System clock /64
+#define SYSCTL_RCC2_FRACT       0x00400000  // Fractional divide
+#define SYSCTL_RCC2_USBPWRDN    0x00004000  // Power-Down USB PLL.
+#define SYSCTL_RCC2_PWRDN2      0x00002000  // PLL power down
+#define SYSCTL_RCC2_BYPASS2     0x00000800  // PLL bypass
+#define SYSCTL_RCC2_OSCSRC2_M   0x00000070  // System Clock Source.
+#define SYSCTL_RCC2_OSCSRC2_MO  0x00000000  // Use the main oscillator
+#define SYSCTL_RCC2_OSCSRC2_IO  0x00000010  // Use the internal oscillator
+#define SYSCTL_RCC2_OSCSRC2_IO4 0x00000020  // Use the internal oscillator / 4
+#define SYSCTL_RCC2_OSCSRC2_30  0x00000030  // Use the 30 KHz internal osc.
+#define SYSCTL_RCC2_OSCSRC2_419 0x00000060  // Use the 4.19 MHz external osc.
+#define SYSCTL_RCC2_OSCSRC2_32  0x00000070  // Use the 32 KHz external osc.
+#define SYSCTL_RCC2_SYSDIV2_S   23          // Shift to the SYSDIV2 field
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSLPCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSLPCLKCFG_D_M   0x1F800000  // Divider Field Override.
+#define SYSCTL_DSLPCLKCFG_D_2   0x00800000  // System clock /2
+#define SYSCTL_DSLPCLKCFG_D_3   0x01000000  // System clock /3
+#define SYSCTL_DSLPCLKCFG_D_4   0x01800000  // System clock /4
+#define SYSCTL_DSLPCLKCFG_D_5   0x02000000  // System clock /5
+#define SYSCTL_DSLPCLKCFG_D_6   0x02800000  // System clock /6
+#define SYSCTL_DSLPCLKCFG_D_7   0x03000000  // System clock /7
+#define SYSCTL_DSLPCLKCFG_D_8   0x03800000  // System clock /8
+#define SYSCTL_DSLPCLKCFG_D_9   0x04000000  // System clock /9
+#define SYSCTL_DSLPCLKCFG_D_10  0x04800000  // System clock /10
+#define SYSCTL_DSLPCLKCFG_D_11  0x05000000  // System clock /11
+#define SYSCTL_DSLPCLKCFG_D_12  0x05800000  // System clock /12
+#define SYSCTL_DSLPCLKCFG_D_13  0x06000000  // System clock /13
+#define SYSCTL_DSLPCLKCFG_D_14  0x06800000  // System clock /14
+#define SYSCTL_DSLPCLKCFG_D_15  0x07000000  // System clock /15
+#define SYSCTL_DSLPCLKCFG_D_16  0x07800000  // System clock /16
+#define SYSCTL_DSLPCLKCFG_D_17  0x08000000  // System clock /17
+#define SYSCTL_DSLPCLKCFG_D_18  0x08800000  // System clock /18
+#define SYSCTL_DSLPCLKCFG_D_19  0x09000000  // System clock /19
+#define SYSCTL_DSLPCLKCFG_D_20  0x09800000  // System clock /20
+#define SYSCTL_DSLPCLKCFG_D_21  0x0A000000  // System clock /21
+#define SYSCTL_DSLPCLKCFG_D_22  0x0A800000  // System clock /22
+#define SYSCTL_DSLPCLKCFG_D_23  0x0B000000  // System clock /23
+#define SYSCTL_DSLPCLKCFG_D_24  0x0B800000  // System clock /24
+#define SYSCTL_DSLPCLKCFG_D_25  0x0C000000  // System clock /25
+#define SYSCTL_DSLPCLKCFG_D_26  0x0C800000  // System clock /26
+#define SYSCTL_DSLPCLKCFG_D_27  0x0D000000  // System clock /27
+#define SYSCTL_DSLPCLKCFG_D_28  0x0D800000  // System clock /28
+#define SYSCTL_DSLPCLKCFG_D_29  0x0E000000  // System clock /29
+#define SYSCTL_DSLPCLKCFG_D_30  0x0E800000  // System clock /30
+#define SYSCTL_DSLPCLKCFG_D_31  0x0F000000  // System clock /31
+#define SYSCTL_DSLPCLKCFG_D_32  0x0F800000  // System clock /32
+#define SYSCTL_DSLPCLKCFG_D_33  0x10000000  // System clock /33
+#define SYSCTL_DSLPCLKCFG_D_34  0x10800000  // System clock /34
+#define SYSCTL_DSLPCLKCFG_D_35  0x11000000  // System clock /35
+#define SYSCTL_DSLPCLKCFG_D_36  0x11800000  // System clock /36
+#define SYSCTL_DSLPCLKCFG_D_37  0x12000000  // System clock /37
+#define SYSCTL_DSLPCLKCFG_D_38  0x12800000  // System clock /38
+#define SYSCTL_DSLPCLKCFG_D_39  0x13000000  // System clock /39
+#define SYSCTL_DSLPCLKCFG_D_40  0x13800000  // System clock /40
+#define SYSCTL_DSLPCLKCFG_D_41  0x14000000  // System clock /41
+#define SYSCTL_DSLPCLKCFG_D_42  0x14800000  // System clock /42
+#define SYSCTL_DSLPCLKCFG_D_43  0x15000000  // System clock /43
+#define SYSCTL_DSLPCLKCFG_D_44  0x15800000  // System clock /44
+#define SYSCTL_DSLPCLKCFG_D_45  0x16000000  // System clock /45
+#define SYSCTL_DSLPCLKCFG_D_46  0x16800000  // System clock /46
+#define SYSCTL_DSLPCLKCFG_D_47  0x17000000  // System clock /47
+#define SYSCTL_DSLPCLKCFG_D_48  0x17800000  // System clock /48
+#define SYSCTL_DSLPCLKCFG_D_49  0x18000000  // System clock /49
+#define SYSCTL_DSLPCLKCFG_D_50  0x18800000  // System clock /50
+#define SYSCTL_DSLPCLKCFG_D_51  0x19000000  // System clock /51
+#define SYSCTL_DSLPCLKCFG_D_52  0x19800000  // System clock /52
+#define SYSCTL_DSLPCLKCFG_D_53  0x1A000000  // System clock /53
+#define SYSCTL_DSLPCLKCFG_D_54  0x1A800000  // System clock /54
+#define SYSCTL_DSLPCLKCFG_D_55  0x1B000000  // System clock /55
+#define SYSCTL_DSLPCLKCFG_D_56  0x1B800000  // System clock /56
+#define SYSCTL_DSLPCLKCFG_D_57  0x1C000000  // System clock /57
+#define SYSCTL_DSLPCLKCFG_D_58  0x1C800000  // System clock /58
+#define SYSCTL_DSLPCLKCFG_D_59  0x1D000000  // System clock /59
+#define SYSCTL_DSLPCLKCFG_D_60  0x1D800000  // System clock /60
+#define SYSCTL_DSLPCLKCFG_D_61  0x1E000000  // System clock /61
+#define SYSCTL_DSLPCLKCFG_D_62  0x1E800000  // System clock /62
+#define SYSCTL_DSLPCLKCFG_D_63  0x1F000000  // System clock /63
+#define SYSCTL_DSLPCLKCFG_D_64  0x1F800000  // System clock /64
+#define SYSCTL_DSLPCLKCFG_O_M   0x00000070  // Clock Source.
+#define SYSCTL_DSLPCLKCFG_O_IGN 0x00000000  // Do not override
+#define SYSCTL_DSLPCLKCFG_O_IO  0x00000010  // Use the internal oscillator
+#define SYSCTL_DSLPCLKCFG_O_30  0x00000030  // Use the 30 KHz internal osc.
+#define SYSCTL_DSLPCLKCFG_O_32  0x00000070  // Use the 32 KHz external osc.
+#define SYSCTL_DSLPCLKCFG_IOSC  0x00000001  // IOSC Clock Source.
+#define SYSCTL_DSLPCLKCFG_D_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_CLKVCLR register.
+//
+//*****************************************************************************
+#define SYSCTL_CLKVCLR_VERCLR   0x00000001  // Clock Verification Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LDOARST register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOARST_LDOARST  0x00000001  // LDO Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR0_WDT1       0x10000000  // WDT1 Reset Control.
+#define SYSCTL_SRCR0_CAN2       0x04000000  // CAN2 Reset Control.
+#define SYSCTL_SRCR0_CAN1       0x02000000  // CAN1 Reset Control.
+#define SYSCTL_SRCR0_CAN0       0x01000000  // CAN0 Reset Control.
+#define SYSCTL_SRCR0_PWM        0x00100000  // PWM Reset Control.
+#define SYSCTL_SRCR0_ADC1       0x00020000  // ADC1 Reset Control.
+#define SYSCTL_SRCR0_ADC0       0x00010000  // ADC0 Reset Control.
+#define SYSCTL_SRCR0_HIB        0x00000040  // HIB Reset Control.
+#define SYSCTL_SRCR0_WDT0       0x00000008  // WDT0 Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR1_EPI0       0x40000000  // EPI0 Reset Control.
+#define SYSCTL_SRCR1_I2S0       0x10000000  // I2S 0 Reset Control.
+#define SYSCTL_SRCR1_COMP2      0x04000000  // Analog Comp 2 Reset Control.
+#define SYSCTL_SRCR1_COMP1      0x02000000  // Analog Comp 1 Reset Control.
+#define SYSCTL_SRCR1_COMP0      0x01000000  // Analog Comp 0 Reset Control.
+#define SYSCTL_SRCR1_TIMER3     0x00080000  // Timer 3 Reset Control.
+#define SYSCTL_SRCR1_TIMER2     0x00040000  // Timer 2 Reset Control.
+#define SYSCTL_SRCR1_TIMER1     0x00020000  // Timer 1 Reset Control.
+#define SYSCTL_SRCR1_TIMER0     0x00010000  // Timer 0 Reset Control.
+#define SYSCTL_SRCR1_I2C1       0x00004000  // I2C1 Reset Control.
+#define SYSCTL_SRCR1_I2C0       0x00001000  // I2C0 Reset Control.
+#define SYSCTL_SRCR1_QEI1       0x00000200  // QEI1 Reset Control.
+#define SYSCTL_SRCR1_QEI0       0x00000100  // QEI0 Reset Control.
+#define SYSCTL_SRCR1_SSI1       0x00000020  // SSI1 Reset Control.
+#define SYSCTL_SRCR1_SSI0       0x00000010  // SSI0 Reset Control.
+#define SYSCTL_SRCR1_UART2      0x00000004  // UART2 Reset Control.
+#define SYSCTL_SRCR1_UART1      0x00000002  // UART1 Reset Control.
+#define SYSCTL_SRCR1_UART0      0x00000001  // UART0 Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR2_EPHY0      0x40000000  // PHY0 Reset Control.
+#define SYSCTL_SRCR2_EMAC0      0x10000000  // MAC0 Reset Control.
+#define SYSCTL_SRCR2_USB0       0x00010000  // USB0 Reset Control.
+#define SYSCTL_SRCR2_UDMA       0x00002000  // UDMA Reset Control.
+#define SYSCTL_SRCR2_GPIOJ      0x00000100  // Port J Reset Control.
+#define SYSCTL_SRCR2_GPIOH      0x00000080  // Port H Reset Control.
+#define SYSCTL_SRCR2_GPIOG      0x00000040  // Port G Reset Control.
+#define SYSCTL_SRCR2_GPIOF      0x00000020  // Port F Reset Control.
+#define SYSCTL_SRCR2_GPIOE      0x00000010  // Port E Reset Control.
+#define SYSCTL_SRCR2_GPIOD      0x00000008  // Port D Reset Control.
+#define SYSCTL_SRCR2_GPIOC      0x00000004  // Port C Reset Control.
+#define SYSCTL_SRCR2_GPIOB      0x00000002  // Port B Reset Control.
+#define SYSCTL_SRCR2_GPIOA      0x00000001  // Port A Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RIS register.
+//
+//*****************************************************************************
+#define SYSCTL_RIS_MOSCPUPRIS   0x00000100  // MOSC Power Up Raw Interrupt
+                                            // Status.
+#define SYSCTL_RIS_USBPLLLRIS   0x00000080  // USB PLL Lock Raw Interrupt
+                                            // Status.
+#define SYSCTL_RIS_PLLLRIS      0x00000040  // PLL Lock Raw Interrupt Status.
+#define SYSCTL_RIS_CLRIS        0x00000020  // Current Limit Raw Interrupt
+                                            // Status.
+#define SYSCTL_RIS_IOFRIS       0x00000010  // Internal Oscillator Fault Raw
+                                            // Interrupt Status.
+#define SYSCTL_RIS_MOFRIS       0x00000008  // Main Oscillator Fault Raw
+                                            // Interrupt Status.
+#define SYSCTL_RIS_LDORIS       0x00000004  // LDO Power Unregulated Raw
+                                            // Interrupt Status.
+#define SYSCTL_RIS_BORRIS       0x00000002  // Brown-Out Reset Raw Interrupt
+                                            // Status.
+#define SYSCTL_RIS_PLLFRIS      0x00000001  // PLL Fault Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_IMC register.
+//
+//*****************************************************************************
+#define SYSCTL_IMC_MOSCPUPIM    0x00000100  // MOSC Power Up Interrupt Mask.
+#define SYSCTL_IMC_USBPLLLIM    0x00000080  // USB PLL Lock Interrupt Mask.
+#define SYSCTL_IMC_PLLLIM       0x00000040  // PLL Lock Interrupt Mask.
+#define SYSCTL_IMC_CLIM         0x00000020  // Current Limit Interrupt Mask.
+#define SYSCTL_IMC_IOFIM        0x00000010  // Internal Oscillator Fault
+                                            // Interrupt Mask.
+#define SYSCTL_IMC_MOFIM        0x00000008  // Main Oscillator Fault Interrupt
+                                            // Mask.
+#define SYSCTL_IMC_LDOIM        0x00000004  // LDO Power Unregulated Interrupt
+                                            // Mask.
+#define SYSCTL_IMC_BORIM        0x00000002  // Brown-Out Reset Interrupt Mask.
+#define SYSCTL_IMC_PLLFIM       0x00000001  // PLL Fault Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MISC register.
+//
+//*****************************************************************************
+#define SYSCTL_MISC_MOSCPUPMIS  0x00000100  // MOSC Power Up Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_USBPLLLMIS  0x00000080  // USB PLL Lock Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_PLLLMIS     0x00000040  // PLL Lock Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_CLMIS       0x00000020  // Current Limit Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_IOFMIS      0x00000010  // Internal Oscillator Fault Masked
+                                            // Interrupt Status.
+#define SYSCTL_MISC_MOFMIS      0x00000008  // Main Oscillator Fault Masked
+                                            // Interrupt Status.
+#define SYSCTL_MISC_LDOMIS      0x00000004  // LDO Power Unregulated Masked
+                                            // Interrupt Status.
+#define SYSCTL_MISC_BORMIS      0x00000002  // BOR Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC0_WDT1       0x10000000  // WDT1 Clock Gating Control.
+#define SYSCTL_RCGC0_CAN2       0x04000000  // CAN2 Clock Gating Control.
+#define SYSCTL_RCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
+#define SYSCTL_RCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_RCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_RCGC0_ADC1       0x00020000  // ADC1 Clock Gating Control.
+#define SYSCTL_RCGC0_ADC0       0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_RCGC0_ADCSPD_M   0x00000F00  // ADC Sample Speed.
+#define SYSCTL_RCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_RCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_RCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_RCGC0_ADCSPD1M   0x00000300  // 1M samples/second
+#define SYSCTL_RCGC0_ADC1SPD_M  0x00000C00  // ADC1 Sample Speed.
+#define SYSCTL_RCGC0_ADC1SPD_1M 0x00000C00  // 1M samples/second
+#define SYSCTL_RCGC0_ADC0SPD_M  0x00000300  // ADC0 Sample Speed.
+#define SYSCTL_RCGC0_ADC0SPD_1M 0x00000300  // 1M samples/second
+#define SYSCTL_RCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_RCGC0_WDT0       0x00000008  // WDT0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC1_EPI0       0x40000000  // EPI0 Clock Gating.
+#define SYSCTL_RCGC1_I2S0       0x10000000  // I2S0 Clock Gating Control.
+#define SYSCTL_RCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_RCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_RCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_RCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_RCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_RCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
+#define SYSCTL_RCGC2_UDMA       0x00002000  // UDMA Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOJ      0x00000100  // Port J Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC0_WDT1       0x10000000  // WDT1 Clock Gating Control.
+#define SYSCTL_SCGC0_CAN2       0x04000000  // CAN2 Clock Gating Control.
+#define SYSCTL_SCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
+#define SYSCTL_SCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_SCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_SCGC0_ADC1       0x00020000  // ADC1 Clock Gating Control.
+#define SYSCTL_SCGC0_ADC0       0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_SCGC0_ADCSPD_M   0x00000F00  // ADC Sample Speed.
+#define SYSCTL_SCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_SCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_SCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_SCGC0_ADCSPD1M   0x00000300  // 1M samples/second
+#define SYSCTL_SCGC0_ADC1SPD_M  0x00000C00  // ADC1 Sample Speed.
+#define SYSCTL_SCGC0_ADC1SPD_1M 0x00000C00  // 1M samples/second
+#define SYSCTL_SCGC0_ADC0SPD_M  0x00000300  // ADC0 Sample Speed.
+#define SYSCTL_SCGC0_ADC0SPD_1M 0x00000300  // 1M samples/second
+#define SYSCTL_SCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_SCGC0_WDT0       0x00000008  // WDT0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC1_EPI0       0x40000000  // EPI0 Clock Gating.
+#define SYSCTL_SCGC1_I2S0       0x10000000  // I2S 0 Clock Gating.
+#define SYSCTL_SCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_SCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_SCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_SCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_SCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_SCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
+#define SYSCTL_SCGC2_UDMA       0x00002000  // UDMA Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOJ      0x00000100  // GPIO Port J Present.
+#define SYSCTL_SCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC0_WDT1       0x10000000  // WDT1 Clock Gating Control.
+#define SYSCTL_DCGC0_CAN2       0x04000000  // CAN2 Clock Gating Control.
+#define SYSCTL_DCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
+#define SYSCTL_DCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_DCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_DCGC0_ADC1       0x00020000  // ADC1 Clock Gating Control.
+#define SYSCTL_DCGC0_ADC0       0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_DCGC0_ADCSPD_M   0x00000F00  // ADC Sample Speed.
+#define SYSCTL_DCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_DCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_DCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_DCGC0_ADCSPD1M   0x00000300  // 1M samples/second
+#define SYSCTL_DCGC0_ADC1SPD_M  0x00000C00  // ADC1 Sample Speed.
+#define SYSCTL_DCGC0_ADC1SPD_1M 0x00000C00  // 1M samples/second
+#define SYSCTL_DCGC0_ADC0SPD_M  0x00000300  // ADC0 Sample Speed.
+#define SYSCTL_DCGC0_ADC0SPD_1M 0x00000300  // 1M samples/second
+#define SYSCTL_DCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_DCGC0_WDT0       0x00000008  // WDT0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC1_EPI0       0x40000000  // EPI0 Clock Gating.
+#define SYSCTL_DCGC1_I2S0       0x10000000  // I2S 0 Clock Gating.
+#define SYSCTL_DCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_DCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_DCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_DCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_DCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_DCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
+#define SYSCTL_DCGC2_UDMA       0x00002000  // UDMA Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOJ      0x00000100  // GPIO Port J Present.
+#define SYSCTL_DCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC5 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC5_PWMFAULT3    0x08000000  // PWM Fault 3 Pin Present.
+#define SYSCTL_DC5_PWMFAULT2    0x04000000  // PWM Fault 2 Pin Present.
+#define SYSCTL_DC5_PWMFAULT1    0x02000000  // PWM Fault 1 Pin Present.
+#define SYSCTL_DC5_PWMFAULT0    0x01000000  // PWM Fault 0 Pin Present.
+#define SYSCTL_DC5_PWMEFLT      0x00200000  // PWM Extended Fault feature is
+                                            // active.
+#define SYSCTL_DC5_PWMESYNC     0x00100000  // PWM Extended SYNC feature is
+                                            // active.
+#define SYSCTL_DC5_PWM7         0x00000080  // PWM7 Pin Present.
+#define SYSCTL_DC5_PWM6         0x00000040  // PWM6 Pin Present.
+#define SYSCTL_DC5_PWM5         0x00000020  // PWM5 Pin Present.
+#define SYSCTL_DC5_PWM4         0x00000010  // PWM4 Pin Present.
+#define SYSCTL_DC5_PWM3         0x00000008  // PWM3 Pin Present.
+#define SYSCTL_DC5_PWM2         0x00000004  // PWM2 Pin Present.
+#define SYSCTL_DC5_PWM1         0x00000002  // PWM1 Pin Present.
+#define SYSCTL_DC5_PWM0         0x00000001  // PWM0 Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC6 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC6_USB0PHY      0x00000010  // This specifies that USB0 PHY is
+                                            // present.
+#define SYSCTL_DC6_USB0_M       0x00000003  // This specifies that USB0 is
+                                            // present and its capability.
+#define SYSCTL_DC6_USB0_HOSTDEV 0x00000002  // USB is DEVICE or HOST
+#define SYSCTL_DC6_USB0_OTG     0x00000003  // USB is OTG
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_GPIOHSCTL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_GPIOHSCTL_PORTH  0x00000080  // Port H High-Speed.
+#define SYSCTL_GPIOHSCTL_PORTG  0x00000040  // Port G High-Speed.
+#define SYSCTL_GPIOHSCTL_PORTF  0x00000020  // Port F High-Speed.
+#define SYSCTL_GPIOHSCTL_PORTE  0x00000010  // Port E High-Speed.
+#define SYSCTL_GPIOHSCTL_PORTD  0x00000008  // Port D High-Speed.
+#define SYSCTL_GPIOHSCTL_PORTC  0x00000004  // Port C High-Speed.
+#define SYSCTL_GPIOHSCTL_PORTB  0x00000002  // Port B High-Speed.
+#define SYSCTL_GPIOHSCTL_PORTA  0x00000001  // Port A High-Speed.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MOSCCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_MOSCCTL_CVAL     0x00000001  // Clock Validation for MOSC.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC7 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC7_DMACH30      0x40000000  // SW.
+#define SYSCTL_DC7_DMACH29      0x20000000  // I2S0_TX.
+#define SYSCTL_DC7_DMACH28      0x10000000  // I2S0_RX.
+#define SYSCTL_DC7_DMACH27      0x08000000  // ADC1_SS3.
+#define SYSCTL_DC7_DMACH26      0x04000000  // ADC1_SS2.
+#define SYSCTL_DC7_DMACH25      0x02000000  // SSI1_TX / ADC1_SS1.
+#define SYSCTL_DC7_SSI1_TX      0x02000000  // SSI1 TX on uDMA Ch25.
+#define SYSCTL_DC7_SSI1_RX      0x01000000  // SSI1 RX on uDMA Ch24.
+#define SYSCTL_DC7_DMACH24      0x01000000  // SSI1_RX / ADC1_SS0.
+#define SYSCTL_DC7_UART1_TX     0x00800000  // UART1 TX on uDMA Ch23.
+#define SYSCTL_DC7_DMACH23      0x00800000  // UART1_TX.
+#define SYSCTL_DC7_DMACH22      0x00400000  // UART1_RX.
+#define SYSCTL_DC7_UART1_RX     0x00400000  // UART1 RX on uDMA Ch22.
+#define SYSCTL_DC7_DMACH21      0x00200000  // Timer1B / EPI0_TX.
+#define SYSCTL_DC7_DMACH20      0x00100000  // Timer1A / EPI0_RX.
+#define SYSCTL_DC7_DMACH19      0x00080000  // Timer0B / Timer1B.
+#define SYSCTL_DC7_DMACH18      0x00040000  // Timer0A / Timer1A.
+#define SYSCTL_DC7_DMACH17      0x00020000  // ADC0_SS3.
+#define SYSCTL_DC7_DMACH16      0x00010000  // ADC0_SS2.
+#define SYSCTL_DC7_DMACH15      0x00008000  // ADC0_SS1 / Timer2B.
+#define SYSCTL_DC7_DMACH14      0x00004000  // ADC0_SS0 / Timer2A.
+#define SYSCTL_DC7_DMACH13      0x00002000  // UART2_TX.
+#define SYSCTL_DC7_DMACH12      0x00001000  // UART2_RX.
+#define SYSCTL_DC7_SSI0_TX      0x00000800  // SSI0 TX on uDMA Ch11.
+#define SYSCTL_DC7_DMACH11      0x00000800  // SSI0_TX / UART1_TX.
+#define SYSCTL_DC7_SSI0_RX      0x00000400  // SSI0 RX on uDMA Ch10.
+#define SYSCTL_DC7_DMACH10      0x00000400  // SSI0_RX / UART1_RX.
+#define SYSCTL_DC7_UART0_TX     0x00000200  // UART0 TX on uDMA Ch9.
+#define SYSCTL_DC7_DMACH9       0x00000200  // UART0_TX / SSI1_TX.
+#define SYSCTL_DC7_DMACH8       0x00000100  // UART0_RX / SSI1_RX.
+#define SYSCTL_DC7_UART0_RX     0x00000100  // UART0 RX on uDMA Ch8.
+#define SYSCTL_DC7_DMACH7       0x00000080  // ETH_TX / Timer2B.
+#define SYSCTL_DC7_DMACH6       0x00000040  // ETH_RX / Timer2A.
+#define SYSCTL_DC7_DMACH5       0x00000020  // USB_EP3_TX / Timer2B.
+#define SYSCTL_DC7_USB_EP3_TX   0x00000020  // USB EP3 TX on uDMA Ch5.
+#define SYSCTL_DC7_USB_EP3_RX   0x00000010  // USB EP3 RX on uDMA Ch4.
+#define SYSCTL_DC7_DMACH4       0x00000010  // USB_EP3_RX / Timer2A.
+#define SYSCTL_DC7_USB_EP2_TX   0x00000008  // USB EP2 TX on uDMA Ch3.
+#define SYSCTL_DC7_DMACH3       0x00000008  // USB_EP2_TX / Timer3B.
+#define SYSCTL_DC7_USB_EP2_RX   0x00000004  // USB EP2 RX on uDMA Ch2.
+#define SYSCTL_DC7_DMACH2       0x00000004  // USB_EP2_RX / Timer3A.
+#define SYSCTL_DC7_USB_EP1_TX   0x00000002  // USB EP1 TX on uDMA Ch1.
+#define SYSCTL_DC7_DMACH1       0x00000002  // USB_EP1_TX / UART2_TX.
+#define SYSCTL_DC7_DMACH0       0x00000001  // USB_EP1_RX / UART2_RX.
+#define SYSCTL_DC7_USB_EP1_RX   0x00000001  // USB EP1 RX on uDMA Ch0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC8 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC8_ADC1AIN15    0x80000000  // ADC Module 1 AIN15 Pin Present.
+#define SYSCTL_DC8_ADC1AIN14    0x40000000  // ADC Module 1 AIN14 Pin Present.
+#define SYSCTL_DC8_ADC1AIN13    0x20000000  // ADC Module 1 AIN13 Pin Present.
+#define SYSCTL_DC8_ADC1AIN12    0x10000000  // ADC Module 1 AIN12 Pin Present.
+#define SYSCTL_DC8_ADC1AIN11    0x08000000  // ADC1 11 Pin Present.
+#define SYSCTL_DC8_ADC1AIN10    0x04000000  // ADC1 10 Pin Present.
+#define SYSCTL_DC8_ADC1AIN9     0x02000000  // ADC1 9 Pin Present.
+#define SYSCTL_DC8_ADC1AIN8     0x01000000  // ADC1 8 Pin Present.
+#define SYSCTL_DC8_ADC1AIN7     0x00800000  // ADC1 7 Pin Present.
+#define SYSCTL_DC8_ADC1AIN6     0x00400000  // ADC1 6 Pin Present.
+#define SYSCTL_DC8_ADC1AIN5     0x00200000  // ADC1 5 Pin Present.
+#define SYSCTL_DC8_ADC1AIN4     0x00100000  // ADC1 4 Pin Present.
+#define SYSCTL_DC8_ADC1AIN3     0x00080000  // ADC1 3 Pin Present.
+#define SYSCTL_DC8_ADC1AIN2     0x00040000  // ADC1 2 Pin Present.
+#define SYSCTL_DC8_ADC1AIN1     0x00020000  // ADC1 1 Pin Present.
+#define SYSCTL_DC8_ADC1AIN0     0x00010000  // ADC1 0 Pin Present.
+#define SYSCTL_DC8_ADC0AIN15    0x00008000  // ADC Module 0 AIN15 Pin Present.
+#define SYSCTL_DC8_ADC0AIN14    0x00004000  // ADC Module 0 AIN14 Pin Present.
+#define SYSCTL_DC8_ADC0AIN13    0x00002000  // ADC Module 0 AIN13 Pin Present.
+#define SYSCTL_DC8_ADC0AIN12    0x00001000  // ADC Module 0 AIN12 Pin Present.
+#define SYSCTL_DC8_ADC0AIN11    0x00000800  // ADC0 11 Pin Present.
+#define SYSCTL_DC8_ADC0AIN10    0x00000400  // ADC0 10 Pin Present.
+#define SYSCTL_DC8_ADC0AIN9     0x00000200  // ADC0 9 Pin Present.
+#define SYSCTL_DC8_ADC0AIN8     0x00000100  // ADC0 8 Pin Present.
+#define SYSCTL_DC8_ADC0AIN7     0x00000080  // ADC0 7 Pin Present.
+#define SYSCTL_DC8_ADC0AIN6     0x00000040  // ADC0 6 Pin Present.
+#define SYSCTL_DC8_ADC0AIN5     0x00000020  // ADC0 5 Pin Present.
+#define SYSCTL_DC8_ADC0AIN4     0x00000010  // ADC0 4 Pin Present.
+#define SYSCTL_DC8_ADC0AIN3     0x00000008  // ADC0 3 Pin Present.
+#define SYSCTL_DC8_ADC0AIN2     0x00000004  // ADC0 2 Pin Present.
+#define SYSCTL_DC8_ADC0AIN1     0x00000002  // ADC0 1 Pin Present.
+#define SYSCTL_DC8_ADC0AIN0     0x00000001  // ADC0 0 Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PIOSCCAL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PIOSCCAL_UTEN    0x80000000  // Use User Trim Value.
+#define SYSCTL_PIOSCCAL_CAL     0x00000200  // Start Calibration.
+#define SYSCTL_PIOSCCAL_UPDATE  0x00000100  // Update Trim.
+#define SYSCTL_PIOSCCAL_UT_M    0x0000007F  // User Trim Value.
+#define SYSCTL_PIOSCCAL_UT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PIOSCSTAT
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PIOSCSTAT_DT_M   0x007F0000  // Default Trim Value.
+#define SYSCTL_PIOSCSTAT_CR_M   0x00000300  // Calibration Result.
+#define SYSCTL_PIOSCSTAT_CRNONE 0x00000000  // Calibration has not been
+                                            // attempted.
+#define SYSCTL_PIOSCSTAT_CRPASS 0x00000100  // The last calibration operation
+                                            // completed to meet 1% accuracy.
+#define SYSCTL_PIOSCSTAT_CRFAIL 0x00000200  // The last calibration operation
+                                            // failed to meet 1% accuracy.
+#define SYSCTL_PIOSCSTAT_CT_M   0x0000007F  // Calibration Trim Value.
+#define SYSCTL_PIOSCSTAT_DT_S   16
+#define SYSCTL_PIOSCSTAT_CT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_I2SMCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_I2SMCLKCFG_RXEN  0x80000000  // RX Clock Enable.
+#define SYSCTL_I2SMCLKCFG_RXI_M 0x0FF00000  // RX Clock Integer Input.
+#define SYSCTL_I2SMCLKCFG_RXF_M 0x000F0000  // RX Clock Fractional Input.
+#define SYSCTL_I2SMCLKCFG_TXEN  0x00008000  // TX Clock Enable.
+#define SYSCTL_I2SMCLKCFG_TXI_M 0x00000FF0  // TX Clock Integer Input.
+#define SYSCTL_I2SMCLKCFG_TXF_M 0x0000000F  // TX Clock Fractional Input.
+#define SYSCTL_I2SMCLKCFG_RXI_S 20
+#define SYSCTL_I2SMCLKCFG_RXF_S 16
+#define SYSCTL_I2SMCLKCFG_TXI_S 4
+#define SYSCTL_I2SMCLKCFG_TXF_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC9 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC9_ADC1DC7      0x00800000  // ADC1 7 Dig Cmp Present.
+#define SYSCTL_DC9_ADC1DC6      0x00400000  // ADC1 6 Dig Cmp Present.
+#define SYSCTL_DC9_ADC1DC5      0x00200000  // ADC1 5 Dig Cmp Present.
+#define SYSCTL_DC9_ADC1DC4      0x00100000  // ADC1 4 Dig Cmp Present.
+#define SYSCTL_DC9_ADC1DC3      0x00080000  // ADC1 3 Dig Cmp Present.
+#define SYSCTL_DC9_ADC1DC2      0x00040000  // ADC1 2 Dig Cmp Present.
+#define SYSCTL_DC9_ADC1DC1      0x00020000  // ADC1 1 Dig Cmp Present.
+#define SYSCTL_DC9_ADC1DC0      0x00010000  // ADC1 0 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC7      0x00000080  // ADC0 7 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC6      0x00000040  // ADC0 6 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC5      0x00000020  // ADC0 5 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC4      0x00000010  // ADC0 4 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC3      0x00000008  // ADC0 3 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC2      0x00000004  // ADC0 2 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC1      0x00000002  // ADC0 1 Dig Cmp Present.
+#define SYSCTL_DC9_ADC0DC0      0x00000001  // ADC0 0 Dig Cmp Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_NVMSTAT register.
+//
+//*****************************************************************************
+#define SYSCTL_NVMSTAT_TPSW     0x00000010  // 1: Indicates 3rd party software
+                                            // in ROM.
+#define SYSCTL_NVMSTAT_FWB      0x00000001  // 32 Word flash write buffer
+                                            // function available.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSFLASHCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSFLASHCFG_SHDWN 0x00000001  // Flash Shutdown.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_GPIOHBCTL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_GPIOHBCTL_PORTJ  0x00000100  // Port J Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTH  0x00000080  // Port H Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTG  0x00000040  // Port G Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTF  0x00000020  // Port F Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTE  0x00000010  // Port E Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTD  0x00000008  // Port D Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTC  0x00000004  // Port C Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTB  0x00000002  // Port B Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTA  0x00000001  // Port A Advanced Host Bus.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the system control register
+// addresses.
+//
+//*****************************************************************************
+#define SYSCTL_USER0            0x400FE1E0  // NV User Register 0
+#define SYSCTL_USER1            0x400FE1E4  // NV User Register 1
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_DID0
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DID0_VER_MASK    0x70000000  // DID0 version mask
+#define SYSCTL_DID0_CLASS_MASK  0x00FF0000  // Device Class
+#define SYSCTL_DID0_MAJ_MASK    0x0000FF00  // Major revision mask
+#define SYSCTL_DID0_MAJ_A       0x00000000  // Major revision A
+#define SYSCTL_DID0_MAJ_B       0x00000100  // Major revision B
+#define SYSCTL_DID0_MAJ_C       0x00000200  // Major revision C
+#define SYSCTL_DID0_MIN_MASK    0x000000FF  // Minor revision mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_DID1
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DID1_VER_MASK    0xF0000000  // Register version mask
+#define SYSCTL_DID1_FAM_MASK    0x0F000000  // Family mask
+#define SYSCTL_DID1_FAM_S       0x00000000  // Stellaris family
+#define SYSCTL_DID1_PRTNO_MASK  0x00FF0000  // Part number mask
+#define SYSCTL_DID1_PINCNT_MASK 0x0000E000  // Pin count
+#define SYSCTL_DID1_TEMP_MASK   0x000000E0  // Temperature range mask
+#define SYSCTL_DID1_PKG_MASK    0x00000018  // Package mask
+#define SYSCTL_DID1_QUAL_MASK   0x00000003  // Qualification status mask
+#define SYSCTL_DID1_PRTNO_SHIFT 16
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_DC0
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DC0_SRAMSZ_MASK  0xFFFF0000  // SRAM size mask
+#define SYSCTL_DC0_FLASHSZ_MASK 0x0000FFFF  // Flash size mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_DC1
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DC1_ADC          0x00010000  // ADC module present
+#define SYSCTL_DC1_SYSDIV_MASK  0x0000F000  // Minimum system divider mask
+#define SYSCTL_DC1_ADCSPD_MASK  0x00000F00  // ADC speed mask
+#define SYSCTL_DC1_WDOG         0x00000008  // Watchdog present
+#define SYSCTL_DC1_WDT          0x00000008  // Watchdog Timer Present.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_DC2
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DC2_I2C          0x00001000  // I2C present
+#define SYSCTL_DC2_QEI          0x00000100  // QEI present
+#define SYSCTL_DC2_SSI          0x00000010  // SSI present
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_DC3
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DC3_ADC7         0x00800000  // ADC7 pin present
+#define SYSCTL_DC3_ADC6         0x00400000  // ADC6 pin present
+#define SYSCTL_DC3_ADC5         0x00200000  // ADC5 pin present
+#define SYSCTL_DC3_ADC4         0x00100000  // ADC4 pin present
+#define SYSCTL_DC3_ADC3         0x00080000  // ADC3 pin present
+#define SYSCTL_DC3_ADC2         0x00040000  // ADC2 pin present
+#define SYSCTL_DC3_ADC1         0x00020000  // ADC1 pin present
+#define SYSCTL_DC3_ADC0         0x00010000  // ADC0 pin present
+#define SYSCTL_DC3_MC_FAULT0    0x00008000  // MC0 fault pin present
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the
+// SYSCTL_PBORCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_PBORCTL_BOR_MASK 0x0000FFFC  // BOR wait timer
+#define SYSCTL_PBORCTL_BOR_SH   2
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the
+// SYSCTL_LDOPCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOPCTL_MASK     0x0000003F  // Voltage adjust mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_SRCR0,
+// SYSCTL_RCGC0, SYSCTL_SCGC0, and SYSCTL_DCGC0 registers.
+//
+//*****************************************************************************
+#define SYSCTL_SET0_CAN2        0x04000000  // CAN 2 module
+#define SYSCTL_SET0_CAN1        0x02000000  // CAN 1 module
+#define SYSCTL_SET0_CAN0        0x01000000  // CAN 0 module
+#define SYSCTL_SET0_PWM         0x00100000  // PWM module
+#define SYSCTL_SET0_ADC         0x00010000  // ADC module
+#define SYSCTL_SET0_ADCSPD_MASK 0x00000F00  // ADC speed mask
+#define SYSCTL_SET0_ADCSPD_125K 0x00000000  // 125Ksps ADC
+#define SYSCTL_SET0_ADCSPD_250K 0x00000100  // 250Ksps ADC
+#define SYSCTL_SET0_ADCSPD_500K 0x00000200  // 500Ksps ADC
+#define SYSCTL_SET0_ADCSPD_1M   0x00000300  // 1Msps ADC
+#define SYSCTL_SET0_HIB         0x00000040  // Hibernation module
+#define SYSCTL_SET0_WDOG        0x00000008  // Watchdog module
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_SRCR1,
+// SYSCTL_RCGC1, SYSCTL_SCGC1, and SYSCTL_DCGC1 registers.
+//
+//*****************************************************************************
+#define SYSCTL_SET1_COMP2       0x04000000  // Analog comparator module 2
+#define SYSCTL_SET1_COMP1       0x02000000  // Analog comparator module 1
+#define SYSCTL_SET1_COMP0       0x01000000  // Analog comparator module 0
+#define SYSCTL_SET1_TIMER3      0x00080000  // Timer module 3
+#define SYSCTL_SET1_TIMER2      0x00040000  // Timer module 2
+#define SYSCTL_SET1_TIMER1      0x00020000  // Timer module 1
+#define SYSCTL_SET1_TIMER0      0x00010000  // Timer module 0
+#define SYSCTL_SET1_I2C1        0x00002000  // I2C module 1
+#define SYSCTL_SET1_I2C0        0x00001000  // I2C module 0
+#define SYSCTL_SET1_I2C         0x00001000  // I2C module
+#define SYSCTL_SET1_QEI1        0x00000200  // QEI module 1
+#define SYSCTL_SET1_QEI         0x00000100  // QEI module
+#define SYSCTL_SET1_QEI0        0x00000100  // QEI module 0
+#define SYSCTL_SET1_SSI1        0x00000020  // SSI module 1
+#define SYSCTL_SET1_SSI0        0x00000010  // SSI module 0
+#define SYSCTL_SET1_SSI         0x00000010  // SSI module
+#define SYSCTL_SET1_UART2       0x00000004  // UART module 2
+#define SYSCTL_SET1_UART1       0x00000002  // UART module 1
+#define SYSCTL_SET1_UART0       0x00000001  // UART module 0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_SRCR2,
+// SYSCTL_RCGC2, SYSCTL_SCGC2, and SYSCTL_DCGC2 registers.
+//
+//*****************************************************************************
+#define SYSCTL_SET2_ETH         0x50000000  // ETH module
+#define SYSCTL_SET2_GPIOH       0x00000080  // GPIO H module
+#define SYSCTL_SET2_GPIOG       0x00000040  // GPIO G module
+#define SYSCTL_SET2_GPIOF       0x00000020  // GPIO F module
+#define SYSCTL_SET2_GPIOE       0x00000010  // GPIO E module
+#define SYSCTL_SET2_GPIOD       0x00000008  // GPIO D module
+#define SYSCTL_SET2_GPIOC       0x00000004  // GPIO C module
+#define SYSCTL_SET2_GPIOB       0x00000002  // GPIO B module
+#define SYSCTL_SET2_GPIOA       0x00000001  // GIPO A module
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_RIS,
+// SYSCTL_IMC, and SYSCTL_IMS registers.
+//
+//*****************************************************************************
+#define SYSCTL_INT_PLL_LOCK     0x00000040  // PLL lock interrupt
+#define SYSCTL_INT_CUR_LIMIT    0x00000020  // Current limit interrupt
+#define SYSCTL_INT_IOSC_FAIL    0x00000010  // Internal oscillator failure int
+#define SYSCTL_INT_MOSC_FAIL    0x00000008  // Main oscillator failure int
+#define SYSCTL_INT_POR          0x00000004  // Power on reset interrupt
+#define SYSCTL_INT_BOR          0x00000002  // Brown out interrupt
+#define SYSCTL_INT_PLL_FAIL     0x00000001  // PLL failure interrupt
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_RESC
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RESC_WDOG        0x00000008  // Watchdog reset
+#define SYSCTL_RESC_WDT         0x00000008  // Watchdog Timer Reset.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_RCC
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC_SYSDIV_MASK  0x07800000  // System clock divider
+#define SYSCTL_RCC_USE_SYSDIV   0x00400000  // Use sytem clock divider
+#define SYSCTL_RCC_USE_PWMDIV   0x00100000  // Use PWM clock divider
+#define SYSCTL_RCC_PWMDIV_MASK  0x000E0000  // PWM clock divider
+#define SYSCTL_RCC_OE           0x00001000  // PLL output enable
+#define SYSCTL_RCC_XTAL_3_68MHz 0x00000140  // Using a 3.6864 MHz crystal
+#define SYSCTL_RCC_XTAL_4MHz    0x00000180  // Using a 4 MHz crystal
+#define SYSCTL_RCC_XTAL_MASK    0x000003C0  // Crystal attached to main osc
+#define SYSCTL_RCC_OSCSRC_MASK  0x00000030  // Oscillator input select
+#define SYSCTL_RCC_SYSDIV_SHIFT 23          // Shift to the SYSDIV field
+#define SYSCTL_RCC_PWMDIV_SHIFT 17          // Shift to the PWMDIV field
+#define SYSCTL_RCC_XTAL_SHIFT   6           // Shift to the XTAL field
+#define SYSCTL_RCC_OSCSRC_SHIFT 4           // Shift to the OSCSRC field
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_PLLCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLCFG_OD_MASK   0x0000C000  // Output divider
+#define SYSCTL_PLLCFG_F_MASK    0x00003FE0  // PLL multiplier
+#define SYSCTL_PLLCFG_R_MASK    0x0000001F  // Input predivider
+#define SYSCTL_PLLCFG_F_SHIFT   5
+#define SYSCTL_PLLCFG_R_SHIFT   0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_RCC2
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC2_SYSDIV2_MSK 0x1F800000  // System clock divider
+#define SYSCTL_RCC2_OSCSRC2_MSK 0x00000070  // Oscillator input select
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the
+// SYSCTL_DSLPCLKCFG register.
+//
+//*****************************************************************************
+#define SYSCTL_DSLPCLKCFG_D_MSK 0x1F800000  // Deep sleep system clock override
+#define SYSCTL_DSLPCLKCFG_O_MSK 0x00000070  // Deep sleep oscillator override
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the
+// SYSCTL_CLKVCLR register.
+//
+//*****************************************************************************
+#define SYSCTL_CLKVCLR_CLR      0x00000001  // Clear clock verification fault
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the
+// SYSCTL_LDOARST register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOARST_ARST     0x00000001  // Allow LDO to reset device
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_SRCR0
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR0_ADC        0x00010000  // ADC0 Reset Control.
+#define SYSCTL_SRCR0_WDT        0x00000008  // WDT Reset Control.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_RCGC0
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_RCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_SCGC0
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_SCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the SYSCTL_DCGC0
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_DCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+#endif
+
+#endif // __HW_SYSCTL_H__


Property changes on: trunk/src/platform/lm3s/hw_sysctl.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_timer.h
===================================================================
--- trunk/src/platform/lm3s/hw_timer.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_timer.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,406 +1,452 @@
-//*****************************************************************************
-//
-// hw_timer.h - Defines and macros used when accessing the timer.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_TIMER_H__
-#define __HW_TIMER_H__
-
-//*****************************************************************************
-//
-// The following are defines for the timer register offsets.
-//
-//*****************************************************************************
-#define TIMER_O_CFG             0x00000000  // Configuration register
-#define TIMER_O_TAMR            0x00000004  // TimerA mode register
-#define TIMER_O_TBMR            0x00000008  // TimerB mode register
-#define TIMER_O_CTL             0x0000000C  // Control register
-#define TIMER_O_IMR             0x00000018  // Interrupt mask register
-#define TIMER_O_RIS             0x0000001C  // Interrupt status register
-#define TIMER_O_MIS             0x00000020  // Masked interrupt status reg.
-#define TIMER_O_ICR             0x00000024  // Interrupt clear register
-#define TIMER_O_TAILR           0x00000028  // TimerA interval load register
-#define TIMER_O_TBILR           0x0000002C  // TimerB interval load register
-#define TIMER_O_TAMATCHR        0x00000030  // TimerA match register
-#define TIMER_O_TBMATCHR        0x00000034  // TimerB match register
-#define TIMER_O_TAPR            0x00000038  // TimerA prescale register
-#define TIMER_O_TBPR            0x0000003C  // TimerB prescale register
-#define TIMER_O_TAPMR           0x00000040  // TimerA prescale match register
-#define TIMER_O_TBPMR           0x00000044  // TimerB prescale match register
-#define TIMER_O_TAR             0x00000048  // TimerA register
-#define TIMER_O_TBR             0x0000004C  // TimerB register
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_CFG register.
-//
-//*****************************************************************************
-#define TIMER_CFG_M             0x00000007  // GPTM Configuration.
-#define TIMER_CFG_16_BIT        0x00000004  // Two 16 bit timers
-#define TIMER_CFG_32_BIT_RTC    0x00000001  // 32 bit RTC
-#define TIMER_CFG_32_BIT_TIMER  0x00000000  // 32 bit timer
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_CTL register.
-//
-//*****************************************************************************
-#define TIMER_CTL_TBPWML        0x00004000  // TimerB PWM output level invert
-#define TIMER_CTL_TBOTE         0x00002000  // TimerB output trigger enable
-#define TIMER_CTL_TBEVENT_POS   0x00000000  // TimerB event mode - pos edge
-#define TIMER_CTL_TBEVENT_NEG   0x00000400  // TimerB event mode - neg edge
-#define TIMER_CTL_TBEVENT_BOTH  0x00000C00  // TimerB event mode - both edges
-#define TIMER_CTL_TBEVENT_M     0x00000C00  // GPTM TimerB Event Mode.
-#define TIMER_CTL_TBSTALL       0x00000200  // TimerB stall enable
-#define TIMER_CTL_TBEN          0x00000100  // TimerB enable
-#define TIMER_CTL_TAPWML        0x00000040  // TimerA PWM output level invert
-#define TIMER_CTL_TAOTE         0x00000020  // TimerA output trigger enable
-#define TIMER_CTL_RTCEN         0x00000010  // RTC counter enable
-#define TIMER_CTL_TAEVENT_M     0x0000000C  // GPTM TimerA Event Mode.
-#define TIMER_CTL_TAEVENT_POS   0x00000000  // TimerA event mode - pos edge
-#define TIMER_CTL_TAEVENT_NEG   0x00000004  // TimerA event mode - neg edge
-#define TIMER_CTL_TAEVENT_BOTH  0x0000000C  // TimerA event mode - both edges
-#define TIMER_CTL_TASTALL       0x00000002  // TimerA stall enable
-#define TIMER_CTL_TAEN          0x00000001  // TimerA enable
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_IMR register.
-//
-//*****************************************************************************
-#define TIMER_IMR_CBEIM         0x00000400  // CaptureB event interrupt mask
-#define TIMER_IMR_CBMIM         0x00000200  // CaptureB match interrupt mask
-#define TIMER_IMR_TBTOIM        0x00000100  // TimerB time out interrupt mask
-#define TIMER_IMR_RTCIM         0x00000008  // RTC interrupt mask
-#define TIMER_IMR_CAEIM         0x00000004  // CaptureA event interrupt mask
-#define TIMER_IMR_CAMIM         0x00000002  // CaptureA match interrupt mask
-#define TIMER_IMR_TATOIM        0x00000001  // TimerA time out interrupt mask
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_RIS register.
-//
-//*****************************************************************************
-#define TIMER_RIS_CBERIS        0x00000400  // CaptureB event raw int status
-#define TIMER_RIS_CBMRIS        0x00000200  // CaptureB match raw int status
-#define TIMER_RIS_TBTORIS       0x00000100  // TimerB time out raw int status
-#define TIMER_RIS_RTCRIS        0x00000008  // RTC raw int status
-#define TIMER_RIS_CAERIS        0x00000004  // CaptureA event raw int status
-#define TIMER_RIS_CAMRIS        0x00000002  // CaptureA match raw int status
-#define TIMER_RIS_TATORIS       0x00000001  // TimerA time out raw int status
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_ICR register.
-//
-//*****************************************************************************
-#define TIMER_ICR_CBECINT       0x00000400  // CaptureB event interrupt clear
-#define TIMER_ICR_CBMCINT       0x00000200  // CaptureB match interrupt clear
-#define TIMER_ICR_TBTOCINT      0x00000100  // TimerB time out interrupt clear
-#define TIMER_ICR_RTCCINT       0x00000008  // RTC interrupt clear
-#define TIMER_ICR_CAECINT       0x00000004  // CaptureA event interrupt clear
-#define TIMER_ICR_CAMCINT       0x00000002  // CaptureA match interrupt clear
-#define TIMER_ICR_TATOCINT      0x00000001  // TimerA time out interrupt clear
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_TAILR register.
-//
-//*****************************************************************************
-#define TIMER_TAILR_TAILRH_M    0xFFFF0000  // GPTM TimerA Interval Load
-                                            // Register High.
-#define TIMER_TAILR_TAILRL_M    0x0000FFFF  // GPTM TimerA Interval Load
-                                            // Register Low.
-#define TIMER_TAILR_TAILRH_S    16
-#define TIMER_TAILR_TAILRL_S    0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_TBILR register.
-//
-//*****************************************************************************
-#define TIMER_TBILR_TBILRL_M    0x0000FFFF  // GPTM TimerB Interval Load
-                                            // Register.
-#define TIMER_TBILR_TBILRL_S    0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_TAMATCHR register.
-//
-//*****************************************************************************
-#define TIMER_TAMATCHR_TAMRH_M  0xFFFF0000  // GPTM TimerA Match Register High.
-#define TIMER_TAMATCHR_TAMRL_M  0x0000FFFF  // GPTM TimerA Match Register Low.
-#define TIMER_TAMATCHR_TAMRH_S  16
-#define TIMER_TAMATCHR_TAMRL_S  0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_TBMATCHR register.
-//
-//*****************************************************************************
-#define TIMER_TBMATCHR_TBMRL_M  0x0000FFFF  // GPTM TimerB Match Register Low.
-#define TIMER_TBMATCHR_TBMRL_S  0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_TAR register.
-//
-//*****************************************************************************
-#define TIMER_TAR_TARH_M        0xFFFF0000  // GPTM TimerA Register High.
-#define TIMER_TAR_TARL_M        0x0000FFFF  // GPTM TimerA Register Low.
-#define TIMER_TAR_TARH_S        16
-#define TIMER_TAR_TARL_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_TBR register.
-//
-//*****************************************************************************
-#define TIMER_TBR_TBRL_M        0x0000FFFF  // GPTM TimerB.
-#define TIMER_TBR_TBRL_S        0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_O_TAMR register.
-//
-//*****************************************************************************
-#define TIMER_TAMR_TAAMS        0x00000008  // GPTM TimerA Alternate Mode
-                                            // Select.
-#define TIMER_TAMR_TACMR        0x00000004  // GPTM TimerA Capture Mode.
-#define TIMER_TAMR_TAMR_M       0x00000003  // GPTM TimerA Mode.
-#define TIMER_TAMR_TAMR_1_SHOT  0x00000001  // One-Shot Timer mode.
-#define TIMER_TAMR_TAMR_PERIOD  0x00000002  // Periodic Timer mode.
-#define TIMER_TAMR_TAMR_CAP     0x00000003  // Capture mode.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_O_TBMR register.
-//
-//*****************************************************************************
-#define TIMER_TBMR_TBAMS        0x00000008  // GPTM TimerB Alternate Mode
-                                            // Select.
-#define TIMER_TBMR_TBCMR        0x00000004  // GPTM TimerB Capture Mode.
-#define TIMER_TBMR_TBMR_M       0x00000003  // GPTM TimerB Mode.
-#define TIMER_TBMR_TBMR_1_SHOT  0x00000001  // One-Shot Timer mode.
-#define TIMER_TBMR_TBMR_PERIOD  0x00000002  // Periodic Timer mode.
-#define TIMER_TBMR_TBMR_CAP     0x00000003  // Capture mode.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_O_MIS register.
-//
-//*****************************************************************************
-#define TIMER_MIS_CBEMIS        0x00000400  // GPTM CaptureB Event Masked
-                                            // Interrupt.
-#define TIMER_MIS_CBMMIS        0x00000200  // GPTM CaptureB Match Masked
-                                            // Interrupt.
-#define TIMER_MIS_TBTOMIS       0x00000100  // GPTM TimerB Time-Out Masked
-                                            // Interrupt.
-#define TIMER_MIS_RTCMIS        0x00000008  // GPTM RTC Masked Interrupt.
-#define TIMER_MIS_CAEMIS        0x00000004  // GPTM CaptureA Event Masked
-                                            // Interrupt.
-#define TIMER_MIS_CAMMIS        0x00000002  // GPTM CaptureA Match Masked
-                                            // Interrupt.
-#define TIMER_MIS_TATOMIS       0x00000001  // GPTM TimerA Time-Out Masked
-                                            // Interrupt.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_O_TAPR register.
-//
-//*****************************************************************************
-#define TIMER_TAPR_TAPSR_M      0x000000FF  // GPTM TimerA Prescale.
-#define TIMER_TAPR_TAPSR_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_O_TBPR register.
-//
-//*****************************************************************************
-#define TIMER_TBPR_TBPSR_M      0x000000FF  // GPTM TimerB Prescale.
-#define TIMER_TBPR_TBPSR_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_O_TAPMR register.
-//
-//*****************************************************************************
-#define TIMER_TAPMR_TAPSMR_M    0x000000FF  // GPTM TimerA Prescale Match.
-#define TIMER_TAPMR_TAPSMR_S    0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the TIMER_O_TBPMR register.
-//
-//*****************************************************************************
-#define TIMER_TBPMR_TBPSMR_M    0x000000FF  // GPTM TimerB Prescale Match.
-#define TIMER_TBPMR_TBPSMR_S    0
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the reset values of the timer
-// registers.
-//
-//*****************************************************************************
-#define TIMER_RV_TAILR          0xFFFFFFFF  // TimerA interval load reg RV
-#define TIMER_RV_TAR            0xFFFFFFFF  // TimerA register RV
-#define TIMER_RV_TAMATCHR       0xFFFFFFFF  // TimerA match register RV
-#define TIMER_RV_TBILR          0x0000FFFF  // TimerB interval load reg RV
-#define TIMER_RV_TBMATCHR       0x0000FFFF  // TimerB match register RV
-#define TIMER_RV_TBR            0x0000FFFF  // TimerB register RV
-#define TIMER_RV_TAPR           0x00000000  // TimerA prescale register RV
-#define TIMER_RV_CFG            0x00000000  // Configuration register RV
-#define TIMER_RV_TBPMR          0x00000000  // TimerB prescale match regi RV
-#define TIMER_RV_TAPMR          0x00000000  // TimerA prescale match reg RV
-#define TIMER_RV_CTL            0x00000000  // Control register RV
-#define TIMER_RV_ICR            0x00000000  // Interrupt clear register RV
-#define TIMER_RV_TBMR           0x00000000  // TimerB mode register RV
-#define TIMER_RV_MIS            0x00000000  // Masked interrupt status reg RV
-#define TIMER_RV_RIS            0x00000000  // Interrupt status register RV
-#define TIMER_RV_TBPR           0x00000000  // TimerB prescale register RV
-#define TIMER_RV_IMR            0x00000000  // Interrupt mask register RV
-#define TIMER_RV_TAMR           0x00000000  // TimerA mode register RV
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_CFG
-// register.
-//
-//*****************************************************************************
-#define TIMER_CFG_CFG_MSK       0x00000007  // Configuration options mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_TnMR
-// register.
-//
-//*****************************************************************************
-#define TIMER_TNMR_TNAMS        0x00000008  // Alternate mode select
-#define TIMER_TNMR_TNCMR        0x00000004  // Capture mode - count or time
-#define TIMER_TNMR_TNTMR_MSK    0x00000003  // Timer mode mask
-#define TIMER_TNMR_TNTMR_1_SHOT 0x00000001  // Mode - one shot
-#define TIMER_TNMR_TNTMR_PERIOD 0x00000002  // Mode - periodic
-#define TIMER_TNMR_TNTMR_CAP    0x00000003  // Mode - capture
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_CTL
-// register.
-//
-//*****************************************************************************
-#define TIMER_CTL_TBEVENT_MSK   0x00000C00  // TimerB event mode mask
-#define TIMER_CTL_TAEVENT_MSK   0x0000000C  // TimerA event mode mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_MIS
-// register.
-//
-//*****************************************************************************
-#define TIMER_RIS_CBEMIS        0x00000400  // CaptureB event masked int status
-#define TIMER_RIS_CBMMIS        0x00000200  // CaptureB match masked int status
-#define TIMER_RIS_TBTOMIS       0x00000100  // TimerB time out masked int stat
-#define TIMER_RIS_RTCMIS        0x00000008  // RTC masked int status
-#define TIMER_RIS_CAEMIS        0x00000004  // CaptureA event masked int status
-#define TIMER_RIS_CAMMIS        0x00000002  // CaptureA match masked int status
-#define TIMER_RIS_TATOMIS       0x00000001  // TimerA time out masked int stat
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_TAILR
-// register.
-//
-//*****************************************************************************
-#define TIMER_TAILR_TAILRH      0xFFFF0000  // TimerB load val in 32 bit mode
-#define TIMER_TAILR_TAILRL      0x0000FFFF  // TimerA interval load value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_TBILR
-// register.
-//
-//*****************************************************************************
-#define TIMER_TBILR_TBILRL      0x0000FFFF  // TimerB interval load value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the
-// TIMER_TAMATCHR register.
-//
-//*****************************************************************************
-#define TIMER_TAMATCHR_TAMRH    0xFFFF0000  // TimerB match val in 32 bit mode
-#define TIMER_TAMATCHR_TAMRL    0x0000FFFF  // TimerA match value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the
-// TIMER_TBMATCHR register.
-//
-//*****************************************************************************
-#define TIMER_TBMATCHR_TBMRL    0x0000FFFF  // TimerB match load value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_TnPR
-// register.
-//
-//*****************************************************************************
-#define TIMER_TNPR_TNPSR        0x000000FF  // TimerN prescale value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_TnPMR
-// register.
-//
-//*****************************************************************************
-#define TIMER_TNPMR_TNPSMR      0x000000FF  // TimerN prescale match value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_TAR
-// register.
-//
-//*****************************************************************************
-#define TIMER_TAR_TARH          0xFFFF0000  // TimerB val in 32 bit mode
-#define TIMER_TAR_TARL          0x0000FFFF  // TimerA value
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the bit fields in the TIMER_TBR
-// register.
-//
-//*****************************************************************************
-#define TIMER_TBR_TBRL          0x0000FFFF  // TimerB value
-
-#endif
-
-#endif // __HW_TIMER_H__
+//*****************************************************************************
+//
+// hw_timer.h - Defines and macros used when accessing the timer.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_TIMER_H__
+#define __HW_TIMER_H__
+
+//*****************************************************************************
+//
+// The following are defines for the timer register offsets.
+//
+//*****************************************************************************
+#define TIMER_O_CFG             0x00000000  // Configuration register
+#define TIMER_O_TAMR            0x00000004  // TimerA mode register
+#define TIMER_O_TBMR            0x00000008  // TimerB mode register
+#define TIMER_O_CTL             0x0000000C  // Control register
+#define TIMER_O_IMR             0x00000018  // Interrupt mask register
+#define TIMER_O_RIS             0x0000001C  // Interrupt status register
+#define TIMER_O_MIS             0x00000020  // Masked interrupt status reg.
+#define TIMER_O_ICR             0x00000024  // Interrupt clear register
+#define TIMER_O_TAILR           0x00000028  // TimerA interval load register
+#define TIMER_O_TBILR           0x0000002C  // TimerB interval load register
+#define TIMER_O_TAMATCHR        0x00000030  // TimerA match register
+#define TIMER_O_TBMATCHR        0x00000034  // TimerB match register
+#define TIMER_O_TAPR            0x00000038  // TimerA prescale register
+#define TIMER_O_TBPR            0x0000003C  // TimerB prescale register
+#define TIMER_O_TAPMR           0x00000040  // TimerA prescale match register
+#define TIMER_O_TBPMR           0x00000044  // TimerB prescale match register
+#define TIMER_O_TAR             0x00000048  // TimerA register
+#define TIMER_O_TBR             0x0000004C  // TimerB register
+#define TIMER_O_TAV             0x00000050  // GPTM Timer A Value
+#define TIMER_O_TBV             0x00000054  // GPTM Timer B Value
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_CFG register.
+//
+//*****************************************************************************
+#define TIMER_CFG_M             0x00000007  // GPTM Configuration.
+#define TIMER_CFG_16_BIT        0x00000004  // Two 16 bit timers
+#define TIMER_CFG_32_BIT_RTC    0x00000001  // 32 bit RTC
+#define TIMER_CFG_32_BIT_TIMER  0x00000000  // 32 bit timer
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_CTL register.
+//
+//*****************************************************************************
+#define TIMER_CTL_TBPWML        0x00004000  // TimerB PWM output level invert
+#define TIMER_CTL_TBOTE         0x00002000  // TimerB output trigger enable
+#define TIMER_CTL_TBEVENT_POS   0x00000000  // TimerB event mode - pos edge
+#define TIMER_CTL_TBEVENT_NEG   0x00000400  // TimerB event mode - neg edge
+#define TIMER_CTL_TBEVENT_BOTH  0x00000C00  // TimerB event mode - both edges
+#define TIMER_CTL_TBEVENT_M     0x00000C00  // GPTM TimerB Event Mode.
+#define TIMER_CTL_TBSTALL       0x00000200  // TimerB stall enable
+#define TIMER_CTL_TBEN          0x00000100  // TimerB enable
+#define TIMER_CTL_TAPWML        0x00000040  // TimerA PWM output level invert
+#define TIMER_CTL_TAOTE         0x00000020  // TimerA output trigger enable
+#define TIMER_CTL_RTCEN         0x00000010  // RTC counter enable
+#define TIMER_CTL_TAEVENT_M     0x0000000C  // GPTM TimerA Event Mode.
+#define TIMER_CTL_TAEVENT_POS   0x00000000  // TimerA event mode - pos edge
+#define TIMER_CTL_TAEVENT_NEG   0x00000004  // TimerA event mode - neg edge
+#define TIMER_CTL_TAEVENT_BOTH  0x0000000C  // TimerA event mode - both edges
+#define TIMER_CTL_TASTALL       0x00000002  // TimerA stall enable
+#define TIMER_CTL_TAEN          0x00000001  // TimerA enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_IMR register.
+//
+//*****************************************************************************
+#define TIMER_IMR_TBMIM         0x00000800  // GPTM Timer B Mode Match
+                                            // Interrupt Mask.
+#define TIMER_IMR_CBEIM         0x00000400  // CaptureB event interrupt mask
+#define TIMER_IMR_CBMIM         0x00000200  // CaptureB match interrupt mask
+#define TIMER_IMR_TBTOIM        0x00000100  // TimerB time out interrupt mask
+#define TIMER_IMR_TAMIM         0x00000010  // GPTM Timer A Mode Match
+                                            // Interrupt Mask.
+#define TIMER_IMR_RTCIM         0x00000008  // RTC interrupt mask
+#define TIMER_IMR_CAEIM         0x00000004  // CaptureA event interrupt mask
+#define TIMER_IMR_CAMIM         0x00000002  // CaptureA match interrupt mask
+#define TIMER_IMR_TATOIM        0x00000001  // TimerA time out interrupt mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_RIS register.
+//
+//*****************************************************************************
+#define TIMER_RIS_TBMRIS        0x00000800  // GPTM Timer B Mode Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_CBERIS        0x00000400  // CaptureB event raw int status
+#define TIMER_RIS_CBMRIS        0x00000200  // CaptureB match raw int status
+#define TIMER_RIS_TBTORIS       0x00000100  // TimerB time out raw int status
+#define TIMER_RIS_TAMRIS        0x00000010  // GPTM Timer A Mode Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_RTCRIS        0x00000008  // RTC raw int status
+#define TIMER_RIS_CAERIS        0x00000004  // CaptureA event raw int status
+#define TIMER_RIS_CAMRIS        0x00000002  // CaptureA match raw int status
+#define TIMER_RIS_TATORIS       0x00000001  // TimerA time out raw int status
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_ICR register.
+//
+//*****************************************************************************
+#define TIMER_ICR_TBMCINT       0x00000800  // GPTM Timer B Mode Match
+                                            // Interrupt Clear.
+#define TIMER_ICR_CBECINT       0x00000400  // CaptureB event interrupt clear
+#define TIMER_ICR_CBMCINT       0x00000200  // CaptureB match interrupt clear
+#define TIMER_ICR_TBTOCINT      0x00000100  // TimerB time out interrupt clear
+#define TIMER_ICR_TAMCINT       0x00000010  // GPTM Timer A Mode Match
+                                            // Interrupt Clear.
+#define TIMER_ICR_RTCCINT       0x00000008  // RTC interrupt clear
+#define TIMER_ICR_CAECINT       0x00000004  // CaptureA event interrupt clear
+#define TIMER_ICR_CAMCINT       0x00000002  // CaptureA match interrupt clear
+#define TIMER_ICR_TATOCINT      0x00000001  // TimerA time out interrupt clear
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_TAILR register.
+//
+//*****************************************************************************
+#define TIMER_TAILR_TAILRH_M    0xFFFF0000  // GPTM TimerA Interval Load
+                                            // Register High.
+#define TIMER_TAILR_TAILRL_M    0x0000FFFF  // GPTM TimerA Interval Load
+                                            // Register Low.
+#define TIMER_TAILR_TAILRH_S    16
+#define TIMER_TAILR_TAILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_TBILR register.
+//
+//*****************************************************************************
+#define TIMER_TBILR_TBILRL_M    0x0000FFFF  // GPTM TimerB Interval Load
+                                            // Register.
+#define TIMER_TBILR_TBILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_TAMATCHR register.
+//
+//*****************************************************************************
+#define TIMER_TAMATCHR_TAMRH_M  0xFFFF0000  // GPTM TimerA Match Register High.
+#define TIMER_TAMATCHR_TAMRL_M  0x0000FFFF  // GPTM TimerA Match Register Low.
+#define TIMER_TAMATCHR_TAMRH_S  16
+#define TIMER_TAMATCHR_TAMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_TBMATCHR register.
+//
+//*****************************************************************************
+#define TIMER_TBMATCHR_TBMRL_M  0x0000FFFF  // GPTM TimerB Match Register Low.
+#define TIMER_TBMATCHR_TBMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_TAR register.
+//
+//*****************************************************************************
+#define TIMER_TAR_TARH_M        0xFFFF0000  // GPTM TimerA Register High.
+#define TIMER_TAR_TARL_M        0x0000FFFF  // GPTM TimerA Register Low.
+#define TIMER_TAR_TARH_S        16
+#define TIMER_TAR_TARL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_TBR register.
+//
+//*****************************************************************************
+#define TIMER_TBR_TBRL_M        0x0000FFFF  // GPTM TimerB.
+#define TIMER_TBR_TBRL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMR register.
+//
+//*****************************************************************************
+#define TIMER_TAMR_TASNAPS      0x00000080  // GPTM Timer A Snap-Shot Mode.
+#define TIMER_TAMR_TAWOT        0x00000040  // GPTM Timer A Wait-on-Trigger.
+#define TIMER_TAMR_TAMIE        0x00000020  // GPTM Timer A Match Interrupt
+                                            // Enable.
+#define TIMER_TAMR_TACDIR       0x00000010  // GPTM Timer A Count Direction.
+#define TIMER_TAMR_TAAMS        0x00000008  // GPTM TimerA Alternate Mode
+                                            // Select.
+#define TIMER_TAMR_TACMR        0x00000004  // GPTM TimerA Capture Mode.
+#define TIMER_TAMR_TAMR_M       0x00000003  // GPTM TimerA Mode.
+#define TIMER_TAMR_TAMR_1_SHOT  0x00000001  // One-Shot Timer mode.
+#define TIMER_TAMR_TAMR_PERIOD  0x00000002  // Periodic Timer mode.
+#define TIMER_TAMR_TAMR_CAP     0x00000003  // Capture mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMR register.
+//
+//*****************************************************************************
+#define TIMER_TBMR_TBSNAPS      0x00000080  // GPTM Timer B Snap-Shot Mode.
+#define TIMER_TBMR_TBWOT        0x00000040  // GPTM Timer B Wait-on-Trigger.
+#define TIMER_TBMR_TBMIE        0x00000020  // GPTM Timer B Match Interrupt
+                                            // Enable.
+#define TIMER_TBMR_TBCDIR       0x00000010  // GPTM Timer B Count Direction.
+#define TIMER_TBMR_TBAMS        0x00000008  // GPTM TimerB Alternate Mode
+                                            // Select.
+#define TIMER_TBMR_TBCMR        0x00000004  // GPTM TimerB Capture Mode.
+#define TIMER_TBMR_TBMR_M       0x00000003  // GPTM TimerB Mode.
+#define TIMER_TBMR_TBMR_1_SHOT  0x00000001  // One-Shot Timer mode.
+#define TIMER_TBMR_TBMR_PERIOD  0x00000002  // Periodic Timer mode.
+#define TIMER_TBMR_TBMR_CAP     0x00000003  // Capture mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_MIS register.
+//
+//*****************************************************************************
+#define TIMER_MIS_TBMMIS        0x00000800  // GPTM Timer B Mode Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_CBEMIS        0x00000400  // GPTM CaptureB Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CBMMIS        0x00000200  // GPTM CaptureB Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TBTOMIS       0x00000100  // GPTM TimerB Time-Out Masked
+                                            // Interrupt.
+#define TIMER_MIS_TAMMIS        0x00000010  // GPTM Timer A Mode Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_RTCMIS        0x00000008  // GPTM RTC Masked Interrupt.
+#define TIMER_MIS_CAEMIS        0x00000004  // GPTM CaptureA Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CAMMIS        0x00000002  // GPTM CaptureA Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TATOMIS       0x00000001  // GPTM TimerA Time-Out Masked
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPR register.
+//
+//*****************************************************************************
+#define TIMER_TAPR_TAPSR_M      0x000000FF  // GPTM TimerA Prescale.
+#define TIMER_TAPR_TAPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPR register.
+//
+//*****************************************************************************
+#define TIMER_TBPR_TBPSR_M      0x000000FF  // GPTM TimerB Prescale.
+#define TIMER_TBPR_TBPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPMR register.
+//
+//*****************************************************************************
+#define TIMER_TAPMR_TAPSMR_M    0x000000FF  // GPTM TimerA Prescale Match.
+#define TIMER_TAPMR_TAPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPMR register.
+//
+//*****************************************************************************
+#define TIMER_TBPMR_TBPSMR_M    0x000000FF  // GPTM TimerB Prescale Match.
+#define TIMER_TBPMR_TBPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAV register.
+//
+//*****************************************************************************
+#define TIMER_TAV_TAVH_M        0xFFFF0000  // GPTM Timer A Value High.
+#define TIMER_TAV_TAVL_M        0x0000FFFF  // GPTM Timer A Register Low.
+#define TIMER_TAV_TAVH_S        16
+#define TIMER_TAV_TAVL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBV register.
+//
+//*****************************************************************************
+#define TIMER_TBV_TBVL_M        0x0000FFFF  // GPTM Timer B Register.
+#define TIMER_TBV_TBVL_S        0
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the reset values of the timer
+// registers.
+//
+//*****************************************************************************
+#define TIMER_RV_TAILR          0xFFFFFFFF  // TimerA interval load reg RV
+#define TIMER_RV_TAR            0xFFFFFFFF  // TimerA register RV
+#define TIMER_RV_TAMATCHR       0xFFFFFFFF  // TimerA match register RV
+#define TIMER_RV_TBILR          0x0000FFFF  // TimerB interval load reg RV
+#define TIMER_RV_TBMATCHR       0x0000FFFF  // TimerB match register RV
+#define TIMER_RV_TBR            0x0000FFFF  // TimerB register RV
+#define TIMER_RV_TAPR           0x00000000  // TimerA prescale register RV
+#define TIMER_RV_CFG            0x00000000  // Configuration register RV
+#define TIMER_RV_TBPMR          0x00000000  // TimerB prescale match regi RV
+#define TIMER_RV_TAPMR          0x00000000  // TimerA prescale match reg RV
+#define TIMER_RV_CTL            0x00000000  // Control register RV
+#define TIMER_RV_ICR            0x00000000  // Interrupt clear register RV
+#define TIMER_RV_TBMR           0x00000000  // TimerB mode register RV
+#define TIMER_RV_MIS            0x00000000  // Masked interrupt status reg RV
+#define TIMER_RV_RIS            0x00000000  // Interrupt status register RV
+#define TIMER_RV_TBPR           0x00000000  // TimerB prescale register RV
+#define TIMER_RV_IMR            0x00000000  // Interrupt mask register RV
+#define TIMER_RV_TAMR           0x00000000  // TimerA mode register RV
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_CFG
+// register.
+//
+//*****************************************************************************
+#define TIMER_CFG_CFG_MSK       0x00000007  // Configuration options mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_TnMR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TNMR_TNAMS        0x00000008  // Alternate mode select
+#define TIMER_TNMR_TNCMR        0x00000004  // Capture mode - count or time
+#define TIMER_TNMR_TNTMR_MSK    0x00000003  // Timer mode mask
+#define TIMER_TNMR_TNTMR_1_SHOT 0x00000001  // Mode - one shot
+#define TIMER_TNMR_TNTMR_PERIOD 0x00000002  // Mode - periodic
+#define TIMER_TNMR_TNTMR_CAP    0x00000003  // Mode - capture
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_CTL
+// register.
+//
+//*****************************************************************************
+#define TIMER_CTL_TBEVENT_MSK   0x00000C00  // TimerB event mode mask
+#define TIMER_CTL_TAEVENT_MSK   0x0000000C  // TimerA event mode mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_MIS
+// register.
+//
+//*****************************************************************************
+#define TIMER_RIS_CBEMIS        0x00000400  // CaptureB event masked int status
+#define TIMER_RIS_CBMMIS        0x00000200  // CaptureB match masked int status
+#define TIMER_RIS_TBTOMIS       0x00000100  // TimerB time out masked int stat
+#define TIMER_RIS_RTCMIS        0x00000008  // RTC masked int status
+#define TIMER_RIS_CAEMIS        0x00000004  // CaptureA event masked int status
+#define TIMER_RIS_CAMMIS        0x00000002  // CaptureA match masked int status
+#define TIMER_RIS_TATOMIS       0x00000001  // TimerA time out masked int stat
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_TAILR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TAILR_TAILRH      0xFFFF0000  // TimerB load val in 32 bit mode
+#define TIMER_TAILR_TAILRL      0x0000FFFF  // TimerA interval load value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_TBILR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TBILR_TBILRL      0x0000FFFF  // TimerB interval load value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the
+// TIMER_TAMATCHR register.
+//
+//*****************************************************************************
+#define TIMER_TAMATCHR_TAMRH    0xFFFF0000  // TimerB match val in 32 bit mode
+#define TIMER_TAMATCHR_TAMRL    0x0000FFFF  // TimerA match value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the
+// TIMER_TBMATCHR register.
+//
+//*****************************************************************************
+#define TIMER_TBMATCHR_TBMRL    0x0000FFFF  // TimerB match load value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_TnPR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TNPR_TNPSR        0x000000FF  // TimerN prescale value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_TnPMR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TNPMR_TNPSMR      0x000000FF  // TimerN prescale match value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_TAR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TAR_TARH          0xFFFF0000  // TimerB val in 32 bit mode
+#define TIMER_TAR_TARL          0x0000FFFF  // TimerA value
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the TIMER_TBR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TBR_TBRL          0x0000FFFF  // TimerB value
+
+#endif
+
+#endif // __HW_TIMER_H__


Property changes on: trunk/src/platform/lm3s/hw_timer.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_types.h
===================================================================
--- trunk/src/platform/lm3s/hw_types.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_types.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,158 +1,176 @@
-//*****************************************************************************
-//
-// hw_types.h - Common types and macros.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_TYPES_H__
-#define __HW_TYPES_H__
-
-//*****************************************************************************
-//
-// Define a boolean type, and values for true and false.
-//
-//*****************************************************************************
-typedef unsigned char tBoolean;
-
-#ifndef true
-#define true 1
-#endif
-
-#ifndef false
-#define false 0
-#endif
-
-//*****************************************************************************
-//
-// Macros for hardware access, both direct and via the bit-band region.
-//
-//*****************************************************************************
-#define HWREG(x)                                                              \
-        (*((volatile unsigned long *)(x)))
-#define HWREGH(x)                                                             \
-        (*((volatile unsigned short *)(x)))
-#define HWREGB(x)                                                             \
-        (*((volatile unsigned char *)(x)))
-#define HWREGBITW(x, b)                                                       \
-        HWREG(((unsigned long)(x) &amp; 0xF0000000) | 0x02000000 |                \
-              (((unsigned long)(x) &amp; 0x000FFFFF) &lt;&lt; 5) | ((b) &lt;&lt; 2))
-#define HWREGBITH(x, b)                                                       \
-        HWREGH(((unsigned long)(x) &amp; 0xF0000000) | 0x02000000 |               \
-               (((unsigned long)(x) &amp; 0x000FFFFF) &lt;&lt; 5) | ((b) &lt;&lt; 2))
-#define HWREGBITB(x, b)                                                       \
-        HWREGB(((unsigned long)(x) &amp; 0xF0000000) | 0x02000000 |               \
-               (((unsigned long)(x) &amp; 0x000FFFFF) &lt;&lt; 5) | ((b) &lt;&lt; 2))
-
-//*****************************************************************************
-//
-// Helper Macros for determining silicon revisions, etc.
-//
-// These macros will be used by Driverlib at &quot;run-time&quot; to create necessary
-// conditional code blocks that will allow a single version of the Driverlib
-// &quot;binary&quot; code to support multiple(all) Stellaris silicon revisions.
-//
-// It is expected that these macros will be used inside of a standard 'C'
-// conditional block of code, e.g.
-//
-//     if(CLASS_IS_SANDSTORM)
-//     {
-//         do some Sandstorm-class specific code here.
-//     }
-//
-// By default, these macros will be defined as run-time checks of the
-// appropriate register(s) to allow creation of run-time conditional code
-// blocks for a common DriverLib across the entire Stellaris family.
-//
-// However, if code-space optimization is required, these macros can be &quot;hard-
-// coded&quot; for a specific version of Stellaris silicon.  Many compilers will
-// then detect the &quot;hard-coded&quot; conditionals, and appropriately optimize the
-// code blocks, eliminating any &quot;unreachable&quot; code.  This would result in
-// a smaller Driverlib, thus producing a smaller final application size, but
-// at the cost of limiting the Driverlib binary to a specific Stellaris
-// silicon revision.
-//
-//*****************************************************************************
-#ifndef CLASS_IS_SANDSTORM
-#define CLASS_IS_SANDSTORM                                                    \
-        (((HWREG(SYSCTL_DID0) &amp; SYSCTL_DID0_VER_M) == SYSCTL_DID0_VER_0) ||   \
-         ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
-          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_SANDSTORM)))
-#endif
-
-#ifndef CLASS_IS_FURY
-#define CLASS_IS_FURY                                                        \
-        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
-         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_FURY))
-#endif
-
-#ifndef CLASS_IS_DUSTDEVIL
-#define CLASS_IS_DUSTDEVIL                                                   \
-        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
-         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_DUSTDEVIL))
-#endif
-
-#ifndef REVISION_IS_A0
-#define REVISION_IS_A0                                                     \
-        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
-         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
-#endif
-
-#ifndef REVISION_IS_A1
-#define REVISION_IS_A1                                                     \
-        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
-         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
-#endif
-
-#ifndef REVISION_IS_A2
-#define REVISION_IS_A2                                                     \
-        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
-         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_2))
-#endif
-
-#ifndef REVISION_IS_C1
-#define REVISION_IS_C1                                                     \
-        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
-         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_1))
-#endif
-
-#ifndef REVISION_IS_C2
-#define REVISION_IS_C2                                                     \
-        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
-         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_2))
-#endif
-
-//*****************************************************************************
-//
-// Deprecated silicon class and revision detection macros.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-#define DEVICE_IS_SANDSTORM     CLASS_IS_SANDSTORM
-#define DEVICE_IS_FURY          CLASS_IS_FURY
-#define DEVICE_IS_REVA2         REVISION_IS_A2
-#define DEVICE_IS_REVC1         REVISION_IS_C1
-#define DEVICE_IS_REVC2         REVISION_IS_C2
-#endif
-
-#endif // __HW_TYPES_H__
+//*****************************************************************************
+//
+// hw_types.h - Common types and macros.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_TYPES_H__
+#define __HW_TYPES_H__
+
+//*****************************************************************************
+//
+// Define a boolean type, and values for true and false.
+//
+//*****************************************************************************
+typedef unsigned char tBoolean;
+
+#ifndef true
+#define true 1
+#endif
+
+#ifndef false
+#define false 0
+#endif
+
+//*****************************************************************************
+//
+// Macros for hardware access, both direct and via the bit-band region.
+//
+//*****************************************************************************
+#define HWREG(x)                                                              \
+        (*((volatile unsigned long *)(x)))
+#define HWREGH(x)                                                             \
+        (*((volatile unsigned short *)(x)))
+#define HWREGB(x)                                                             \
+        (*((volatile unsigned char *)(x)))
+#define HWREGBITW(x, b)                                                       \
+        HWREG(((unsigned long)(x) &amp; 0xF0000000) | 0x02000000 |                \
+              (((unsigned long)(x) &amp; 0x000FFFFF) &lt;&lt; 5) | ((b) &lt;&lt; 2))
+#define HWREGBITH(x, b)                                                       \
+        HWREGH(((unsigned long)(x) &amp; 0xF0000000) | 0x02000000 |               \
+               (((unsigned long)(x) &amp; 0x000FFFFF) &lt;&lt; 5) | ((b) &lt;&lt; 2))
+#define HWREGBITB(x, b)                                                       \
+        HWREGB(((unsigned long)(x) &amp; 0xF0000000) | 0x02000000 |               \
+               (((unsigned long)(x) &amp; 0x000FFFFF) &lt;&lt; 5) | ((b) &lt;&lt; 2))
+
+//*****************************************************************************
+//
+// Helper Macros for determining silicon revisions, etc.
+//
+// These macros will be used by Driverlib at &quot;run-time&quot; to create necessary
+// conditional code blocks that will allow a single version of the Driverlib
+// &quot;binary&quot; code to support multiple(all) Stellaris silicon revisions.
+//
+// It is expected that these macros will be used inside of a standard 'C'
+// conditional block of code, e.g.
+//
+//     if(CLASS_IS_SANDSTORM)
+//     {
+//         do some Sandstorm-class specific code here.
+//     }
+//
+// By default, these macros will be defined as run-time checks of the
+// appropriate register(s) to allow creation of run-time conditional code
+// blocks for a common DriverLib across the entire Stellaris family.
+//
+// However, if code-space optimization is required, these macros can be &quot;hard-
+// coded&quot; for a specific version of Stellaris silicon.  Many compilers will
+// then detect the &quot;hard-coded&quot; conditionals, and appropriately optimize the
+// code blocks, eliminating any &quot;unreachable&quot; code.  This would result in
+// a smaller Driverlib, thus producing a smaller final application size, but
+// at the cost of limiting the Driverlib binary to a specific Stellaris
+// silicon revision.
+//
+//*****************************************************************************
+#ifndef CLASS_IS_SANDSTORM
+#define CLASS_IS_SANDSTORM                                                    \
+        (((HWREG(SYSCTL_DID0) &amp; SYSCTL_DID0_VER_M) == SYSCTL_DID0_VER_0) ||   \
+         ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
+          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_SANDSTORM)))
+#endif
+
+#ifndef CLASS_IS_FURY
+#define CLASS_IS_FURY                                                        \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
+         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_FURY))
+#endif
+
+#ifndef CLASS_IS_DUSTDEVIL
+#define CLASS_IS_DUSTDEVIL                                                   \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
+         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_DUSTDEVIL))
+#endif
+
+#ifndef CLASS_IS_TEMPEST
+#define CLASS_IS_TEMPEST                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
+         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_TEMPEST))
+#endif
+
+#ifndef REVISION_IS_A0
+#define REVISION_IS_A0                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
+         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
+#endif
+
+#ifndef REVISION_IS_A1
+#define REVISION_IS_A1                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
+         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
+#endif
+
+#ifndef REVISION_IS_A2
+#define REVISION_IS_A2                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
+         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_2))
+#endif
+
+#ifndef REVISION_IS_B0
+#define REVISION_IS_B0                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
+         (SYSCTL_DID0_MAJ_REVB | SYSCTL_DID0_MIN_0))
+#endif
+
+#ifndef REVISION_IS_B1
+#define REVISION_IS_B1                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
+         (SYSCTL_DID0_MAJ_REVB | SYSCTL_DID0_MIN_1))
+#endif
+
+#ifndef REVISION_IS_C1
+#define REVISION_IS_C1                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
+         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_1))
+#endif
+
+#ifndef REVISION_IS_C2
+#define REVISION_IS_C2                                                     \
+        ((HWREG(SYSCTL_DID0) &amp; (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
+         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_2))
+#endif
+
+//*****************************************************************************
+//
+// Deprecated silicon class and revision detection macros.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#define DEVICE_IS_SANDSTORM     CLASS_IS_SANDSTORM
+#define DEVICE_IS_FURY          CLASS_IS_FURY
+#define DEVICE_IS_REVA2         REVISION_IS_A2
+#define DEVICE_IS_REVC1         REVISION_IS_C1
+#define DEVICE_IS_REVC2         REVISION_IS_C2
+#endif
+
+#endif // __HW_TYPES_H__


Property changes on: trunk/src/platform/lm3s/hw_types.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/hw_uart.h
===================================================================
--- trunk/src/platform/lm3s/hw_uart.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_uart.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,340 +1,436 @@
-//*****************************************************************************
-//
-// hw_uart.h - Macros and defines used when accessing the UART hardware
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-//
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Firmware Development Package.
-//
-//*****************************************************************************
-
-#ifndef __HW_UART_H__
-#define __HW_UART_H__
-
-//*****************************************************************************
-//
-// The following are defines for the UART Register offsets.
-//
-//*****************************************************************************
-#define UART_O_DR               0x00000000  // Data Register
-#define UART_O_RSR              0x00000004  // Receive Status Register (read)
-#define UART_O_ECR              0x00000004  // Error Clear Register (write)
-#define UART_O_FR               0x00000018  // Flag Register (read only)
-#define UART_O_ILPR             0x00000020  // UART IrDA Low-Power Register
-#define UART_O_IBRD             0x00000024  // Integer Baud Rate Divisor Reg
-#define UART_O_FBRD             0x00000028  // Fractional Baud Rate Divisor Reg
-#define UART_O_LCRH             0x0000002C  // UART Line Control
-#define UART_O_CTL              0x00000030  // Control Register
-#define UART_O_IFLS             0x00000034  // Interrupt FIFO Level Select Reg
-#define UART_O_IM               0x00000038  // Interrupt Mask Set/Clear Reg
-#define UART_O_RIS              0x0000003C  // Raw Interrupt Status Register
-#define UART_O_MIS              0x00000040  // Masked Interrupt Status Register
-#define UART_O_ICR              0x00000044  // Interrupt Clear Register
-#define UART_O_DMACTL           0x00000048  // UART DMA Control
-
-//*****************************************************************************
-//
-// The following are defines for the Data Register bits
-//
-//*****************************************************************************
-#define UART_DR_OE              0x00000800  // Overrun Error
-#define UART_DR_BE              0x00000400  // Break Error
-#define UART_DR_PE              0x00000200  // Parity Error
-#define UART_DR_FE              0x00000100  // Framing Error
-#define UART_DR_DATA_M          0x000000FF  // Data Transmitted or Received.
-#define UART_DR_DATA_S          0
-
-//*****************************************************************************
-//
-// The following are defines for the Receive Status Register bits
-//
-//*****************************************************************************
-#define UART_RSR_OE             0x00000008  // Overrun Error
-#define UART_RSR_BE             0x00000004  // Break Error
-#define UART_RSR_PE             0x00000002  // Parity Error
-#define UART_RSR_FE             0x00000001  // Framing Error
-
-//*****************************************************************************
-//
-// The following are defines for the Flag Register bits
-//
-//*****************************************************************************
-#define UART_FR_TXFE            0x00000080  // TX FIFO Empty
-#define UART_FR_RXFF            0x00000040  // RX FIFO Full
-#define UART_FR_TXFF            0x00000020  // TX FIFO Full
-#define UART_FR_RXFE            0x00000010  // RX FIFO Empty
-#define UART_FR_BUSY            0x00000008  // UART Busy
-
-//*****************************************************************************
-//
-// The following are defines for the Integer baud-rate divisor
-//
-//*****************************************************************************
-#define UART_IBRD_DIVINT_M      0x0000FFFF  // Integer Baud-Rate Divisor.
-#define UART_IBRD_DIVINT_S      0
-
-//*****************************************************************************
-//
-// The following are defines for the Fractional baud-rate divisor
-//
-//*****************************************************************************
-#define UART_FBRD_DIVFRAC_M     0x0000003F  // Fractional Baud-Rate Divisor.
-#define UART_FBRD_DIVFRAC_S     0
-
-//*****************************************************************************
-//
-// The following are defines for the Control Register bits
-//
-//*****************************************************************************
-#define UART_CTL_RXE            0x00000200  // Receive Enable
-#define UART_CTL_TXE            0x00000100  // Transmit Enable
-#define UART_CTL_LBE            0x00000080  // Loopback Enable
-#define UART_CTL_SIRLP          0x00000004  // SIR (IrDA) Low Power Enable
-#define UART_CTL_SIREN          0x00000002  // SIR (IrDA) Enable
-#define UART_CTL_UARTEN         0x00000001  // UART Enable
-
-//*****************************************************************************
-//
-// The following are defines for the Interrupt FIFO Level Select Register bits
-//
-//*****************************************************************************
-#define UART_IFLS_RX_M          0x00000038  // RX FIFO Level Interrupt Mask
-#define UART_IFLS_RX1_8         0x00000000  // 1/8 Full
-#define UART_IFLS_RX2_8         0x00000008  // 1/4 Full
-#define UART_IFLS_RX4_8         0x00000010  // 1/2 Full
-#define UART_IFLS_RX6_8         0x00000018  // 3/4 Full
-#define UART_IFLS_RX7_8         0x00000020  // 7/8 Full
-#define UART_IFLS_TX_M          0x00000007  // TX FIFO Level Interrupt Mask
-#define UART_IFLS_TX1_8         0x00000000  // 1/8 Full
-#define UART_IFLS_TX2_8         0x00000001  // 1/4 Full
-#define UART_IFLS_TX4_8         0x00000002  // 1/2 Full
-#define UART_IFLS_TX6_8         0x00000003  // 3/4 Full
-#define UART_IFLS_TX7_8         0x00000004  // 7/8 Full
-
-//*****************************************************************************
-//
-// The following are defines for the Interrupt Mask Set/Clear Register bits
-//
-//*****************************************************************************
-#define UART_IM_OEIM            0x00000400  // Overrun Error Interrupt Mask
-#define UART_IM_BEIM            0x00000200  // Break Error Interrupt Mask
-#define UART_IM_PEIM            0x00000100  // Parity Error Interrupt Mask
-#define UART_IM_FEIM            0x00000080  // Framing Error Interrupt Mask
-#define UART_IM_RTIM            0x00000040  // Receive Timeout Interrupt Mask
-#define UART_IM_TXIM            0x00000020  // Transmit Interrupt Mask
-#define UART_IM_RXIM            0x00000010  // Receive Interrupt Mask
-
-//*****************************************************************************
-//
-// The following are defines for the Raw Interrupt Status Register
-//
-//*****************************************************************************
-#define UART_RIS_OERIS          0x00000400  // Overrun Error Interrupt Status
-#define UART_RIS_BERIS          0x00000200  // Break Error Interrupt Status
-#define UART_RIS_PERIS          0x00000100  // Parity Error Interrupt Status
-#define UART_RIS_FERIS          0x00000080  // Framing Error Interrupt Status
-#define UART_RIS_RTRIS          0x00000040  // Receive Timeout Interrupt Status
-#define UART_RIS_TXRIS          0x00000020  // Transmit Interrupt Status
-#define UART_RIS_RXRIS          0x00000010  // Receive Interrupt Status
-
-//*****************************************************************************
-//
-// The following are defines for the Masked Interrupt Status Register
-//
-//*****************************************************************************
-#define UART_MIS_OEMIS          0x00000400  // Overrun Error Interrupt Status
-#define UART_MIS_BEMIS          0x00000200  // Break Error Interrupt Status
-#define UART_MIS_PEMIS          0x00000100  // Parity Error Interrupt Status
-#define UART_MIS_FEMIS          0x00000080  // Framing Error Interrupt Status
-#define UART_MIS_RTMIS          0x00000040  // Receive Timeout Interrupt Status
-#define UART_MIS_TXMIS          0x00000020  // Transmit Interrupt Status
-#define UART_MIS_RXMIS          0x00000010  // Receive Interrupt Status
-
-//*****************************************************************************
-//
-// The following are defines for the Interrupt Clear Register bits
-//
-//*****************************************************************************
-#define UART_ICR_OEIC           0x00000400  // Overrun Error Interrupt Clear
-#define UART_ICR_BEIC           0x00000200  // Break Error Interrupt Clear
-#define UART_ICR_PEIC           0x00000100  // Parity Error Interrupt Clear
-#define UART_ICR_FEIC           0x00000080  // Framing Error Interrupt Clear
-#define UART_ICR_RTIC           0x00000040  // Receive Timeout Interrupt Clear
-#define UART_ICR_TXIC           0x00000020  // Transmit Interrupt Clear
-#define UART_ICR_RXIC           0x00000010  // Receive Interrupt Clear
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the UART_O_ECR register.
-//
-//*****************************************************************************
-#define UART_ECR_DATA_M         0x000000FF  // Error Clear.
-#define UART_ECR_DATA_S         0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the UART_O_LCRH register.
-//
-//*****************************************************************************
-#define UART_LCRH_SPS           0x00000080  // UART Stick Parity Select.
-#define UART_LCRH_WLEN_M        0x00000060  // UART Word Length.
-#define UART_LCRH_WLEN_5        0x00000000  // 5 bits (default)
-#define UART_LCRH_WLEN_6        0x00000020  // 6 bits
-#define UART_LCRH_WLEN_7        0x00000040  // 7 bits
-#define UART_LCRH_WLEN_8        0x00000060  // 8 bits
-#define UART_LCRH_FEN           0x00000010  // UART Enable FIFOs.
-#define UART_LCRH_STP2          0x00000008  // UART Two Stop Bits Select.
-#define UART_LCRH_EPS           0x00000004  // UART Even Parity Select.
-#define UART_LCRH_PEN           0x00000002  // UART Parity Enable.
-#define UART_LCRH_BRK           0x00000001  // UART Send Break.
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the UART_O_ILPR register.
-//
-//*****************************************************************************
-#define UART_ILPR_ILPDVSR_M     0x000000FF  // IrDA Low-Power Divisor.
-#define UART_ILPR_ILPDVSR_S     0
-
-//*****************************************************************************
-//
-// The following are defines for the bit fields in the UART_O_DMACTL register.
-//
-//*****************************************************************************
-#define UART_DMACTL_DMAERR      0x00000004  // DMA on Error.
-#define UART_DMACTL_TXDMAE      0x00000002  // Transmit DMA Enable.
-#define UART_DMACTL_RXDMAE      0x00000001  // Receive DMA Enable.
-
-//*****************************************************************************
-//
-// The following definitions are deprecated.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the UART Register offsets.
-//
-//*****************************************************************************
-#define UART_O_LCR_H            0x0000002C  // Line Control Register, HIGH byte
-#define UART_O_PeriphID4        0x00000FD0
-#define UART_O_PeriphID5        0x00000FD4
-#define UART_O_PeriphID6        0x00000FD8
-#define UART_O_PeriphID7        0x00000FDC
-#define UART_O_PeriphID0        0x00000FE0
-#define UART_O_PeriphID1        0x00000FE4
-#define UART_O_PeriphID2        0x00000FE8
-#define UART_O_PeriphID3        0x00000FEC
-#define UART_O_PCellID0         0x00000FF0
-#define UART_O_PCellID1         0x00000FF4
-#define UART_O_PCellID2         0x00000FF8
-#define UART_O_PCellID3         0x00000FFC
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the Data Register bits
-//
-//*****************************************************************************
-#define UART_DR_DATA_MASK       0x000000FF  // UART data
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the Integer baud-rate divisor
-//
-//*****************************************************************************
-#define UART_IBRD_DIVINT_MASK   0x0000FFFF  // Integer baud-rate divisor
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the Fractional baud-rate divisor
-//
-//*****************************************************************************
-#define UART_FBRD_DIVFRAC_MASK  0x0000003F  // Fractional baud-rate divisor
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the Line Control Register High bits
-//
-//*****************************************************************************
-#define UART_LCR_H_SPS          0x00000080  // Stick Parity Select
-#define UART_LCR_H_WLEN         0x00000060  // Word length
-#define UART_LCR_H_WLEN_5       0x00000000  // 5 bit data
-#define UART_LCR_H_WLEN_6       0x00000020  // 6 bit data
-#define UART_LCR_H_WLEN_7       0x00000040  // 7 bit data
-#define UART_LCR_H_WLEN_8       0x00000060  // 8 bit data
-#define UART_LCR_H_FEN          0x00000010  // Enable FIFO
-#define UART_LCR_H_STP2         0x00000008  // Two Stop Bits Select
-#define UART_LCR_H_EPS          0x00000004  // Even Parity Select
-#define UART_LCR_H_PEN          0x00000002  // Parity Enable
-#define UART_LCR_H_BRK          0x00000001  // Send Break
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the Interrupt FIFO Level Select
-// Register bits
-//
-//*****************************************************************************
-#define UART_IFLS_RX_MASK       0x00000038  // RX FIFO level mask
-#define UART_IFLS_TX_MASK       0x00000007  // TX FIFO level mask
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the Interrupt Clear Register bits
-//
-//*****************************************************************************
-#define UART_RSR_ANY            (UART_RSR_OE | UART_RSR_BE | UART_RSR_PE | \
-                                 UART_RSR_FE)
-
-//*****************************************************************************
-//
-// The following are deprecated defines for the Reset Values for UART
-// Registers.
-//
-//*****************************************************************************
-#define UART_RV_CTL             0x00000300
-#define UART_RV_PCellID1        0x000000F0
-#define UART_RV_PCellID3        0x000000B1
-#define UART_RV_FR              0x00000090
-#define UART_RV_PeriphID2       0x00000018
-#define UART_RV_IFLS            0x00000012
-#define UART_RV_PeriphID0       0x00000011
-#define UART_RV_PCellID0        0x0000000D
-#define UART_RV_PCellID2        0x00000005
-#define UART_RV_PeriphID3       0x00000001
-#define UART_RV_PeriphID4       0x00000000
-#define UART_RV_LCR_H           0x00000000
-#define UART_RV_PeriphID6       0x00000000
-#define UART_RV_DR              0x00000000
-#define UART_RV_RSR             0x00000000
-#define UART_RV_ECR             0x00000000
-#define UART_RV_PeriphID5       0x00000000
-#define UART_RV_RIS             0x00000000
-#define UART_RV_FBRD            0x00000000
-#define UART_RV_IM              0x00000000
-#define UART_RV_MIS             0x00000000
-#define UART_RV_ICR             0x00000000
-#define UART_RV_PeriphID1       0x00000000
-#define UART_RV_PeriphID7       0x00000000
-#define UART_RV_IBRD            0x00000000
-
-#endif
-
-#endif // __HW_UART_H__
+//*****************************************************************************
+//
+// hw_uart.h - Macros and defines used when accessing the UART hardware
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_UART_H__
+#define __HW_UART_H__
+
+//*****************************************************************************
+//
+// The following are defines for the UART Register offsets.
+//
+//*****************************************************************************
+#define UART_O_DR               0x00000000  // Data Register
+#define UART_O_RSR              0x00000004  // Receive Status Register (read)
+#define UART_O_ECR              0x00000004  // Error Clear Register (write)
+#define UART_O_FR               0x00000018  // Flag Register (read only)
+#define UART_O_ILPR             0x00000020  // UART IrDA Low-Power Register
+#define UART_O_IBRD             0x00000024  // Integer Baud Rate Divisor Reg
+#define UART_O_FBRD             0x00000028  // Fractional Baud Rate Divisor Reg
+#define UART_O_LCRH             0x0000002C  // UART Line Control
+#define UART_O_CTL              0x00000030  // Control Register
+#define UART_O_IFLS             0x00000034  // Interrupt FIFO Level Select Reg
+#define UART_O_IM               0x00000038  // Interrupt Mask Set/Clear Reg
+#define UART_O_RIS              0x0000003C  // Raw Interrupt Status Register
+#define UART_O_MIS              0x00000040  // Masked Interrupt Status Register
+#define UART_O_ICR              0x00000044  // Interrupt Clear Register
+#define UART_O_DMACTL           0x00000048  // UART DMA Control
+#define UART_O_LCTL             0x00000090  // UART LIN Control
+#define UART_O_LSS              0x00000094  // UART LIN Snap Shot
+#define UART_O_LTIM             0x00000098  // UART LIN Timer
+
+//*****************************************************************************
+//
+// The following are defines for the Data Register bits
+//
+//*****************************************************************************
+#define UART_DR_OE              0x00000800  // Overrun Error
+#define UART_DR_BE              0x00000400  // Break Error
+#define UART_DR_PE              0x00000200  // Parity Error
+#define UART_DR_FE              0x00000100  // Framing Error
+#define UART_DR_DATA_M          0x000000FF  // Data Transmitted or Received.
+#define UART_DR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the Receive Status Register bits
+//
+//*****************************************************************************
+#define UART_RSR_OE             0x00000008  // Overrun Error
+#define UART_RSR_BE             0x00000004  // Break Error
+#define UART_RSR_PE             0x00000002  // Parity Error
+#define UART_RSR_FE             0x00000001  // Framing Error
+
+//*****************************************************************************
+//
+// The following are defines for the Flag Register bits
+//
+//*****************************************************************************
+#define UART_FR_RI              0x00000100  // Ring Indicator.
+#define UART_FR_TXFE            0x00000080  // TX FIFO Empty
+#define UART_FR_RXFF            0x00000040  // RX FIFO Full
+#define UART_FR_TXFF            0x00000020  // TX FIFO Full
+#define UART_FR_RXFE            0x00000010  // RX FIFO Empty
+#define UART_FR_BUSY            0x00000008  // UART Busy
+#define UART_FR_DCD             0x00000004  // Data Carrier Detect.
+#define UART_FR_DSR             0x00000002  // Data Set Ready.
+#define UART_FR_CTS             0x00000001  // Clear To Send.
+
+//*****************************************************************************
+//
+// The following are defines for the Integer baud-rate divisor
+//
+//*****************************************************************************
+#define UART_IBRD_DIVINT_M      0x0000FFFF  // Integer Baud-Rate Divisor.
+#define UART_IBRD_DIVINT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the Fractional baud-rate divisor
+//
+//*****************************************************************************
+#define UART_FBRD_DIVFRAC_M     0x0000003F  // Fractional Baud-Rate Divisor.
+#define UART_FBRD_DIVFRAC_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the Control Register bits
+//
+//*****************************************************************************
+#define UART_CTL_CTSEN          0x00008000  // Enable Clear To Send.
+#define UART_CTL_RTSEN          0x00004000  // Enable Request to Send.
+#define UART_CTL_RTS            0x00000800  // Request to Send.
+#define UART_CTL_DTR            0x00000400  // Data Terminal Ready.
+#define UART_CTL_RXE            0x00000200  // Receive Enable
+#define UART_CTL_TXE            0x00000100  // Transmit Enable
+#define UART_CTL_LBE            0x00000080  // Loopback Enable
+#define UART_CTL_LIN            0x00000040  // LIN Mode Enable.
+#define UART_CTL_HSE            0x00000020  // High-Speed Enable.
+#define UART_CTL_EOT            0x00000010  // End of Transmission.
+#define UART_CTL_SMART          0x00000008  // ISO 7816 Smart Card Support.
+#define UART_CTL_SIRLP          0x00000004  // SIR (IrDA) Low Power Enable
+#define UART_CTL_SIREN          0x00000002  // SIR (IrDA) Enable
+#define UART_CTL_UARTEN         0x00000001  // UART Enable
+
+//*****************************************************************************
+//
+// The following are defines for the Interrupt FIFO Level Select Register bits
+//
+//*****************************************************************************
+#define UART_IFLS_RX_M          0x00000038  // RX FIFO Level Interrupt Mask
+#define UART_IFLS_RX1_8         0x00000000  // 1/8 Full
+#define UART_IFLS_RX2_8         0x00000008  // 1/4 Full
+#define UART_IFLS_RX4_8         0x00000010  // 1/2 Full
+#define UART_IFLS_RX6_8         0x00000018  // 3/4 Full
+#define UART_IFLS_RX7_8         0x00000020  // 7/8 Full
+#define UART_IFLS_TX_M          0x00000007  // TX FIFO Level Interrupt Mask
+#define UART_IFLS_TX1_8         0x00000000  // 1/8 Full
+#define UART_IFLS_TX2_8         0x00000001  // 1/4 Full
+#define UART_IFLS_TX4_8         0x00000002  // 1/2 Full
+#define UART_IFLS_TX6_8         0x00000003  // 3/4 Full
+#define UART_IFLS_TX7_8         0x00000004  // 7/8 Full
+
+//*****************************************************************************
+//
+// The following are defines for the Interrupt Mask Set/Clear Register bits
+//
+//*****************************************************************************
+#define UART_IM_LME5IM          0x00008000  // LIN Mode Edge 5 Interrupt Mask.
+#define UART_IM_LME1IM          0x00004000  // LIN Mode Edge 1 Interrupt Mask.
+#define UART_IM_LMSBIM          0x00002000  // LIN Mode Sync Break Interrupt
+                                            // Mask.
+#define UART_IM_OEIM            0x00000400  // Overrun Error Interrupt Mask
+#define UART_IM_BEIM            0x00000200  // Break Error Interrupt Mask
+#define UART_IM_PEIM            0x00000100  // Parity Error Interrupt Mask
+#define UART_IM_FEIM            0x00000080  // Framing Error Interrupt Mask
+#define UART_IM_RTIM            0x00000040  // Receive Timeout Interrupt Mask
+#define UART_IM_TXIM            0x00000020  // Transmit Interrupt Mask
+#define UART_IM_RXIM            0x00000010  // Receive Interrupt Mask
+#define UART_IM_DSRMIM          0x00000008  // UART Data Set Ready Modem
+                                            // Interrupt Mask.
+#define UART_IM_DCDMIM          0x00000004  // UART Data Carrier Detect Modem
+                                            // Interrupt Mask.
+#define UART_IM_CTSMIM          0x00000002  // UART Clear to Send Modem
+                                            // Interrupt Mask.
+#define UART_IM_RIMIM           0x00000001  // UART Ring Indicator Modem
+                                            // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the Raw Interrupt Status Register
+//
+//*****************************************************************************
+#define UART_RIS_LME5RIS        0x00008000  // LIN Mode Edge 5 Raw Interrupt
+                                            // Status.
+#define UART_RIS_LME1RIS        0x00004000  // LIN Mode Edge 1 Raw Interrupt
+                                            // Status.
+#define UART_RIS_LMSBRIS        0x00002000  // LIN Mode Sync Break Raw
+                                            // Interrupt Status.
+#define UART_RIS_OERIS          0x00000400  // Overrun Error Interrupt Status
+#define UART_RIS_BERIS          0x00000200  // Break Error Interrupt Status
+#define UART_RIS_PERIS          0x00000100  // Parity Error Interrupt Status
+#define UART_RIS_FERIS          0x00000080  // Framing Error Interrupt Status
+#define UART_RIS_RTRIS          0x00000040  // Receive Timeout Interrupt Status
+#define UART_RIS_TXRIS          0x00000020  // Transmit Interrupt Status
+#define UART_RIS_RXRIS          0x00000010  // Receive Interrupt Status
+#define UART_RIS_DSRRIS         0x00000008  // UART Data Set Ready Modem Raw
+                                            // Interrupt Status.
+#define UART_RIS_DCDRIS         0x00000004  // UART Data Carrier Detect odem
+                                            // Raw Interrupt Status.
+#define UART_RIS_CTSRIS         0x00000002  // UART Clear to Send Modem Raw
+                                            // Interrupt Status.
+#define UART_RIS_RIRIS          0x00000001  // UART Ring Indicator Modem Raw
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the Masked Interrupt Status Register
+//
+//*****************************************************************************
+#define UART_MIS_LME5MIS        0x00008000  // LIN Mode Edge 5 Masked Interrupt
+                                            // Status.
+#define UART_MIS_LME1MIS        0x00004000  // LIN Mode Edge 1 Masked Interrupt
+                                            // Status.
+#define UART_MIS_LMSBMIS        0x00002000  // LIN Mode Sync Break Masked
+                                            // Interrupt Status.
+#define UART_MIS_OEMIS          0x00000400  // Overrun Error Interrupt Status
+#define UART_MIS_BEMIS          0x00000200  // Break Error Interrupt Status
+#define UART_MIS_PEMIS          0x00000100  // Parity Error Interrupt Status
+#define UART_MIS_FEMIS          0x00000080  // Framing Error Interrupt Status
+#define UART_MIS_RTMIS          0x00000040  // Receive Timeout Interrupt Status
+#define UART_MIS_TXMIS          0x00000020  // Transmit Interrupt Status
+#define UART_MIS_RXMIS          0x00000010  // Receive Interrupt Status
+#define UART_MIS_DSRMIS         0x00000008  // UART Data Set Ready Modem Masked
+                                            // Interrupt Status.
+#define UART_MIS_DCDMIS         0x00000004  // UART Data Carrier Detect odem
+                                            // Masked Interrupt Status.
+#define UART_MIS_CTSMIS         0x00000002  // UART Clear to Send Modem Masked
+                                            // Interrupt Status.
+#define UART_MIS_RIMIS          0x00000001  // UART Ring Indicator Modem Masked
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the Interrupt Clear Register bits
+//
+//*****************************************************************************
+#define UART_ICR_LME5MIC        0x00008000  // LIN Mode Edge 5 Interrupt Clear.
+#define UART_ICR_LME1MIC        0x00004000  // LIN Mode Edge 1 Interrupt Clear.
+#define UART_ICR_LMSBMIC        0x00002000  // LIN Mode Sync Break Interrupt
+                                            // Clear.
+#define UART_ICR_OEIC           0x00000400  // Overrun Error Interrupt Clear
+#define UART_ICR_BEIC           0x00000200  // Break Error Interrupt Clear
+#define UART_ICR_PEIC           0x00000100  // Parity Error Interrupt Clear
+#define UART_ICR_FEIC           0x00000080  // Framing Error Interrupt Clear
+#define UART_ICR_RTIC           0x00000040  // Receive Timeout Interrupt Clear
+#define UART_ICR_TXIC           0x00000020  // Transmit Interrupt Clear
+#define UART_ICR_RXIC           0x00000010  // Receive Interrupt Clear
+#define UART_ICR_DSRMIC         0x00000008  // UART Data Set Ready Modem
+                                            // Interrupt Clear.
+#define UART_ICR_DCDMIC         0x00000004  // UART Data Carrier Detect odem
+                                            // Interrupt Clear.
+#define UART_ICR_CTSMIC         0x00000002  // UART Clear to Send Modem
+                                            // Interrupt Clear.
+#define UART_ICR_RIMIC          0x00000001  // UART Ring Indicator Modem
+                                            // Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ECR register.
+//
+//*****************************************************************************
+#define UART_ECR_DATA_M         0x000000FF  // Error Clear.
+#define UART_ECR_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCRH register.
+//
+//*****************************************************************************
+#define UART_LCRH_SPS           0x00000080  // UART Stick Parity Select.
+#define UART_LCRH_WLEN_M        0x00000060  // UART Word Length.
+#define UART_LCRH_WLEN_5        0x00000000  // 5 bits (default)
+#define UART_LCRH_WLEN_6        0x00000020  // 6 bits
+#define UART_LCRH_WLEN_7        0x00000040  // 7 bits
+#define UART_LCRH_WLEN_8        0x00000060  // 8 bits
+#define UART_LCRH_FEN           0x00000010  // UART Enable FIFOs.
+#define UART_LCRH_STP2          0x00000008  // UART Two Stop Bits Select.
+#define UART_LCRH_EPS           0x00000004  // UART Even Parity Select.
+#define UART_LCRH_PEN           0x00000002  // UART Parity Enable.
+#define UART_LCRH_BRK           0x00000001  // UART Send Break.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ILPR register.
+//
+//*****************************************************************************
+#define UART_ILPR_ILPDVSR_M     0x000000FF  // IrDA Low-Power Divisor.
+#define UART_ILPR_ILPDVSR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DMACTL register.
+//
+//*****************************************************************************
+#define UART_DMACTL_DMAERR      0x00000004  // DMA on Error.
+#define UART_DMACTL_TXDMAE      0x00000002  // Transmit DMA Enable.
+#define UART_DMACTL_RXDMAE      0x00000001  // Receive DMA Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCTL register.
+//
+//*****************************************************************************
+#define UART_LCTL_BLEN_M        0x00000030  // Sync Break Length.
+#define UART_LCTL_BLEN_13T      0x00000000  // Sync break length is 13T bits
+                                            // (default)
+#define UART_LCTL_BLEN_14T      0x00000010  // Sync break length is 14T bits
+#define UART_LCTL_BLEN_15T      0x00000020  // Sync break length is 15T bits
+#define UART_LCTL_BLEN_16T      0x00000030  // Sync break length is 16T bits
+#define UART_LCTL_MASTER        0x00000001  // LIN Master Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LSS register.
+//
+//*****************************************************************************
+#define UART_LSS_TSS_M          0x0000FFFF  // Timer Snap Shot.
+#define UART_LSS_TSS_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LTIM register.
+//
+//*****************************************************************************
+#define UART_LTIM_TIMER_M       0x0000FFFF  // Timer Value.
+#define UART_LTIM_TIMER_S       0
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the UART Register offsets.
+//
+//*****************************************************************************
+#define UART_O_LCR_H            0x0000002C  // Line Control Register, HIGH byte
+#define UART_O_PeriphID4        0x00000FD0
+#define UART_O_PeriphID5        0x00000FD4
+#define UART_O_PeriphID6        0x00000FD8
+#define UART_O_PeriphID7        0x00000FDC
+#define UART_O_PeriphID0        0x00000FE0
+#define UART_O_PeriphID1        0x00000FE4
+#define UART_O_PeriphID2        0x00000FE8
+#define UART_O_PeriphID3        0x00000FEC
+#define UART_O_PCellID0         0x00000FF0
+#define UART_O_PCellID1         0x00000FF4
+#define UART_O_PCellID2         0x00000FF8
+#define UART_O_PCellID3         0x00000FFC
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Data Register bits
+//
+//*****************************************************************************
+#define UART_DR_DATA_MASK       0x000000FF  // UART data
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Integer baud-rate divisor
+//
+//*****************************************************************************
+#define UART_IBRD_DIVINT_MASK   0x0000FFFF  // Integer baud-rate divisor
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Fractional baud-rate divisor
+//
+//*****************************************************************************
+#define UART_FBRD_DIVFRAC_MASK  0x0000003F  // Fractional baud-rate divisor
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Line Control Register High bits
+//
+//*****************************************************************************
+#define UART_LCR_H_SPS          0x00000080  // Stick Parity Select
+#define UART_LCR_H_WLEN         0x00000060  // Word length
+#define UART_LCR_H_WLEN_5       0x00000000  // 5 bit data
+#define UART_LCR_H_WLEN_6       0x00000020  // 6 bit data
+#define UART_LCR_H_WLEN_7       0x00000040  // 7 bit data
+#define UART_LCR_H_WLEN_8       0x00000060  // 8 bit data
+#define UART_LCR_H_FEN          0x00000010  // Enable FIFO
+#define UART_LCR_H_STP2         0x00000008  // Two Stop Bits Select
+#define UART_LCR_H_EPS          0x00000004  // Even Parity Select
+#define UART_LCR_H_PEN          0x00000002  // Parity Enable
+#define UART_LCR_H_BRK          0x00000001  // Send Break
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Interrupt FIFO Level Select
+// Register bits
+//
+//*****************************************************************************
+#define UART_IFLS_RX_MASK       0x00000038  // RX FIFO level mask
+#define UART_IFLS_TX_MASK       0x00000007  // TX FIFO level mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Interrupt Clear Register bits
+//
+//*****************************************************************************
+#define UART_RSR_ANY            (UART_RSR_OE | UART_RSR_BE | UART_RSR_PE | \
+                                 UART_RSR_FE)
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Reset Values for UART
+// Registers.
+//
+//*****************************************************************************
+#define UART_RV_CTL             0x00000300
+#define UART_RV_PCellID1        0x000000F0
+#define UART_RV_PCellID3        0x000000B1
+#define UART_RV_FR              0x00000090
+#define UART_RV_PeriphID2       0x00000018
+#define UART_RV_IFLS            0x00000012
+#define UART_RV_PeriphID0       0x00000011
+#define UART_RV_PCellID0        0x0000000D
+#define UART_RV_PCellID2        0x00000005
+#define UART_RV_PeriphID3       0x00000001
+#define UART_RV_PeriphID4       0x00000000
+#define UART_RV_LCR_H           0x00000000
+#define UART_RV_PeriphID6       0x00000000
+#define UART_RV_DR              0x00000000
+#define UART_RV_RSR             0x00000000
+#define UART_RV_ECR             0x00000000
+#define UART_RV_PeriphID5       0x00000000
+#define UART_RV_RIS             0x00000000
+#define UART_RV_FBRD            0x00000000
+#define UART_RV_IM              0x00000000
+#define UART_RV_MIS             0x00000000
+#define UART_RV_ICR             0x00000000
+#define UART_RV_PeriphID1       0x00000000
+#define UART_RV_PeriphID7       0x00000000
+#define UART_RV_IBRD            0x00000000
+
+#endif
+
+#endif // __HW_UART_H__


Property changes on: trunk/src/platform/lm3s/hw_uart.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_udma.h
===================================================================
--- trunk/src/platform/lm3s/hw_udma.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_udma.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,320 @@
+//*****************************************************************************
+//
+// hw_udma.h - Macros for use in accessing the UDMA registers.
+//
+// Copyright (c) 2007-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_UDMA_H__
+#define __HW_UDMA_H__
+
+//*****************************************************************************
+//
+// The following are defines for the Micro Direct Memory Access (uDMA) offsets.
+//
+//*****************************************************************************
+#define UDMA_STAT               0x400FF000  // DMA Status
+#define UDMA_CFG                0x400FF004  // DMA Configuration
+#define UDMA_CTLBASE            0x400FF008  // DMA Channel Control Base Pointer
+#define UDMA_ALTBASE            0x400FF00C  // DMA Alternate Channel Control
+                                            // Base Pointer
+#define UDMA_WAITSTAT           0x400FF010  // DMA Channel Wait on Request
+                                            // Status
+#define UDMA_SWREQ              0x400FF014  // DMA Channel Software Request
+#define UDMA_USEBURSTSET        0x400FF018  // DMA Channel Useburst Set
+#define UDMA_USEBURSTCLR        0x400FF01C  // DMA Channel Useburst Clear
+#define UDMA_REQMASKSET         0x400FF020  // DMA Channel Request Mask Set
+#define UDMA_REQMASKCLR         0x400FF024  // DMA Channel Request Mask Clear
+#define UDMA_ENASET             0x400FF028  // DMA Channel Enable Set
+#define UDMA_ENACLR             0x400FF02C  // DMA Channel Enable Clear
+#define UDMA_ALTSET             0x400FF030  // DMA Channel Primary Alternate
+                                            // Set
+#define UDMA_ALTCLR             0x400FF034  // DMA Channel Primary Alternate
+                                            // Clear
+#define UDMA_PRIOSET            0x400FF038  // DMA Channel Priority Set
+#define UDMA_PRIOCLR            0x400FF03C  // DMA Channel Priority Clear
+#define UDMA_ERRCLR             0x400FF04C  // DMA Bus Error Clear
+#define UDMA_CHALT              0x400FF500  // DMA Channel Alternate Select
+#define UDMA_CHIS               0x400FF504  // DMA Channel Interrupt Status
+
+//*****************************************************************************
+//
+// Micro Direct Memory Access (uDMA) offsets.
+//
+//*****************************************************************************
+#define UDMA_O_SRCENDP          0x00000000  // DMA Channel Source Address End
+                                            // Pointer
+#define UDMA_O_DSTENDP          0x00000004  // DMA Channel Destination Address
+                                            // End Pointer
+#define UDMA_O_CHCTL            0x00000008  // DMA Channel Control Word
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_SRCENDP register.
+//
+//*****************************************************************************
+#define UDMA_SRCENDP_ADDR_M     0xFFFFFFFF  // Source Address End Pointer.
+#define UDMA_SRCENDP_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_STAT register.
+//
+//*****************************************************************************
+#define UDMA_STAT_DMACHANS_M    0x001F0000  // Available DMA Channels Minus 1.
+#define UDMA_STAT_STATE_M       0x000000F0  // Control State Machine State.
+#define UDMA_STAT_STATE_IDLE    0x00000000  // Idle
+#define UDMA_STAT_STATE_RD_CTRL 0x00000010  // Reading channel controller data
+#define UDMA_STAT_STATE_RD_SRCENDP \
+                                0x00000020  // Reading source end pointer
+#define UDMA_STAT_STATE_RD_DSTENDP \
+                                0x00000030  // Reading destination end pointer
+#define UDMA_STAT_STATE_RD_SRCDAT \
+                                0x00000040  // Reading source data
+#define UDMA_STAT_STATE_WR_DSTDAT \
+                                0x00000050  // Writing destination data
+#define UDMA_STAT_STATE_WAIT    0x00000060  // Waiting for DMA request to clear
+#define UDMA_STAT_STATE_WR_CTRL 0x00000070  // Writing channel controller data
+#define UDMA_STAT_STATE_STALL   0x00000080  // Stalled
+#define UDMA_STAT_STATE_DONE    0x00000090  // Done
+#define UDMA_STAT_STATE_UNDEF   0x000000A0  // Undefined
+#define UDMA_STAT_MASTEN        0x00000001  // Master Enable.
+#define UDMA_STAT_DMACHANS_S    16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_DSTENDP register.
+//
+//*****************************************************************************
+#define UDMA_DSTENDP_ADDR_M     0xFFFFFFFF  // Destination Address End Pointer.
+#define UDMA_DSTENDP_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CFG register.
+//
+//*****************************************************************************
+#define UDMA_CFG_MASTEN         0x00000001  // Controller Master Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CTLBASE register.
+//
+//*****************************************************************************
+#define UDMA_CTLBASE_ADDR_M     0xFFFFFC00  // Channel Control Base Address.
+#define UDMA_CTLBASE_ADDR_S     10
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_CHCTL register.
+//
+//*****************************************************************************
+#define UDMA_CHCTL_DSTINC_M     0xC0000000  // Destination Address Increment.
+#define UDMA_CHCTL_DSTINC_8     0x00000000  // Byte
+#define UDMA_CHCTL_DSTINC_16    0x40000000  // Half-word
+#define UDMA_CHCTL_DSTINC_32    0x80000000  // Word
+#define UDMA_CHCTL_DSTINC_NONE  0xC0000000  // No increment
+#define UDMA_CHCTL_DSTSIZE_M    0x30000000  // Destination Data Size.
+#define UDMA_CHCTL_DSTSIZE_8    0x00000000  // Byte
+#define UDMA_CHCTL_DSTSIZE_16   0x10000000  // Half-word
+#define UDMA_CHCTL_DSTSIZE_32   0x20000000  // Word
+#define UDMA_CHCTL_SRCINC_M     0x0C000000  // Source Address Increment.
+#define UDMA_CHCTL_SRCINC_8     0x00000000  // Byte
+#define UDMA_CHCTL_SRCINC_16    0x04000000  // Half-word
+#define UDMA_CHCTL_SRCINC_32    0x08000000  // Word
+#define UDMA_CHCTL_SRCINC_NONE  0x0C000000  // No increment
+#define UDMA_CHCTL_SRCSIZE_M    0x03000000  // Source Data Size.
+#define UDMA_CHCTL_SRCSIZE_8    0x00000000  // Byte
+#define UDMA_CHCTL_SRCSIZE_16   0x01000000  // Half-word
+#define UDMA_CHCTL_SRCSIZE_32   0x02000000  // Word
+#define UDMA_CHCTL_ARBSIZE_M    0x0003C000  // Arbitration Size.
+#define UDMA_CHCTL_ARBSIZE_1    0x00000000  // 1 Transfer
+#define UDMA_CHCTL_ARBSIZE_2    0x00004000  // 2 Transfers
+#define UDMA_CHCTL_ARBSIZE_4    0x00008000  // 4 Transfers
+#define UDMA_CHCTL_ARBSIZE_8    0x0000C000  // 8 Transfers
+#define UDMA_CHCTL_ARBSIZE_16   0x00010000  // 16 Transfers
+#define UDMA_CHCTL_ARBSIZE_32   0x00014000  // 32 Transfers
+#define UDMA_CHCTL_ARBSIZE_64   0x00018000  // 64 Transfers
+#define UDMA_CHCTL_ARBSIZE_128  0x0001C000  // 128 Transfers
+#define UDMA_CHCTL_ARBSIZE_256  0x00020000  // 256 Transfers
+#define UDMA_CHCTL_ARBSIZE_512  0x00024000  // 512 Transfers
+#define UDMA_CHCTL_ARBSIZE_1024 0x00028000  // 1024 Transfers
+#define UDMA_CHCTL_XFERSIZE_M   0x00003FF0  // Transfer Size (minus 1).
+#define UDMA_CHCTL_NXTUSEBURST  0x00000008  // Next Useburst.
+#define UDMA_CHCTL_XFERMODE_M   0x00000007  // DMA Transfer Mode.
+#define UDMA_CHCTL_XFERMODE_STOP \
+                                0x00000000  // Stop
+#define UDMA_CHCTL_XFERMODE_BASIC \
+                                0x00000001  // Basic
+#define UDMA_CHCTL_XFERMODE_AUTO \
+                                0x00000002  // Auto-Request
+#define UDMA_CHCTL_XFERMODE_PINGPONG \
+                                0x00000003  // Ping-Pong
+#define UDMA_CHCTL_XFERMODE_MEM_SG \
+                                0x00000004  // Memory Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_MEM_SGA \
+                                0x00000005  // Alternate Memory Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_PER_SG \
+                                0x00000006  // Peripheral Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_PER_SGA \
+                                0x00000007  // Alternate Peripheral
+                                            // Scatter-Gather
+#define UDMA_CHCTL_XFERSIZE_S   4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTBASE register.
+//
+//*****************************************************************************
+#define UDMA_ALTBASE_ADDR_M     0xFFFFFFFF  // Alternate Channel Address
+                                            // Pointer.
+#define UDMA_ALTBASE_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_WAITSTAT register.
+//
+//*****************************************************************************
+#define UDMA_WAITSTAT_WAITREQ_M 0xFFFFFFFF  // Channel [n] Wait Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_SWREQ register.
+//
+//*****************************************************************************
+#define UDMA_SWREQ_M            0xFFFFFFFF  // Channel [n] Software Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_USEBURSTSET
+// register.
+//
+//*****************************************************************************
+#define UDMA_USEBURSTSET_SET_M  0xFFFFFFFF  // Channel [n] Useburst Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_USEBURSTCLR
+// register.
+//
+//*****************************************************************************
+#define UDMA_USEBURSTCLR_CLR_M  0xFFFFFFFF  // Channel [n] Useburst Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_REQMASKSET
+// register.
+//
+//*****************************************************************************
+#define UDMA_REQMASKSET_SET_M   0xFFFFFFFF  // Channel [n] Request Mask Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_REQMASKCLR
+// register.
+//
+//*****************************************************************************
+#define UDMA_REQMASKCLR_CLR_M   0xFFFFFFFF  // Channel [n] Request Mask Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ENASET register.
+//
+//*****************************************************************************
+#define UDMA_ENASET_SET_M       0xFFFFFFFF  // Channel [n] Enable Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ENACLR register.
+//
+//*****************************************************************************
+#define UDMA_ENACLR_CLR_M       0xFFFFFFFF  // Clear Channel [n] Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTSET register.
+//
+//*****************************************************************************
+#define UDMA_ALTSET_SET_M       0xFFFFFFFF  // Channel [n] Alternate Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTCLR register.
+//
+//*****************************************************************************
+#define UDMA_ALTCLR_CLR_M       0xFFFFFFFF  // Channel [n] Alternate Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_PRIOSET register.
+//
+//*****************************************************************************
+#define UDMA_PRIOSET_SET_M      0xFFFFFFFF  // Channel [n] Priority Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_PRIOCLR register.
+//
+//*****************************************************************************
+#define UDMA_PRIOCLR_CLR_M      0xFFFFFFFF  // Channel [n] Priority Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ERRCLR register.
+//
+//*****************************************************************************
+#define UDMA_ERRCLR_ERRCLR      0x00000001  // DMA Bus Error Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHALT register.
+//
+//*****************************************************************************
+#define UDMA_CHALT_M            0xFFFFFFFF  // Channel [n] Alternate Assignment
+                                            // Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHIS register.
+//
+//*****************************************************************************
+#define UDMA_CHIS_M             0xFFFFFFFF  // Channel [n] Interrupt Status.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the UDMA_ENASET
+// register.
+//
+//*****************************************************************************
+#define UDMA_ENASET_CHENSET_M   0xFFFFFFFF  // Channel [n] Enable Set.
+
+#endif
+
+#endif // __HW_UDMA_H__


Property changes on: trunk/src/platform/lm3s/hw_udma.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_usb.h
===================================================================
--- trunk/src/platform/lm3s/hw_usb.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_usb.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,4638 @@
+//*****************************************************************************
+//
+// hw_usb.h - Macros for use in accessing the USB registers.
+//
+// Copyright (c) 2007-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_USB_H__
+#define __HW_USB_H__
+
+//*****************************************************************************
+//
+// The following are defines for the Univeral Serial Bus (USB) Controller
+// offsets.
+//
+//*****************************************************************************
+#define USB_O_FADDR             0x00000000  // USB Device Functional Address
+#define USB_O_POWER             0x00000001  // USB Power
+#define USB_O_TXIS              0x00000002  // USB Transmit Interrupt Status
+#define USB_O_RXIS              0x00000004  // USB Receive Interrupt Status
+#define USB_O_TXIE              0x00000006  // USB Transmit Interrupt Enable
+#define USB_O_RXIE              0x00000008  // USB Receive Interrupt Enable
+#define USB_O_IS                0x0000000A  // USB General Interrupt Status
+#define USB_O_IE                0x0000000B  // USB Interrupt Enable
+#define USB_O_FRAME             0x0000000C  // USB Frame Value
+#define USB_O_EPIDX             0x0000000E  // USB Endpoint Index
+#define USB_O_TEST              0x0000000F  // USB Test Mode
+#define USB_O_FIFO0             0x00000020  // USB FIFO Endpoint 0
+#define USB_O_FIFO1             0x00000024  // USB FIFO Endpoint 1
+#define USB_O_FIFO2             0x00000028  // USB FIFO Endpoint 2
+#define USB_O_FIFO3             0x0000002C  // USB FIFO Endpoint 3
+#define USB_O_FIFO4             0x00000030  // USB FIFO Endpoint 4
+#define USB_O_FIFO5             0x00000034  // USB FIFO Endpoint 5
+#define USB_O_FIFO6             0x00000038  // USB FIFO Endpoint 6
+#define USB_O_FIFO7             0x0000003C  // USB FIFO Endpoint 7
+#define USB_O_FIFO8             0x00000040  // USB FIFO Endpoint 8
+#define USB_O_FIFO9             0x00000044  // USB FIFO Endpoint 9
+#define USB_O_FIFO10            0x00000048  // USB FIFO Endpoint 10
+#define USB_O_FIFO11            0x0000004C  // USB FIFO Endpoint 11
+#define USB_O_FIFO12            0x00000050  // USB FIFO Endpoint 12
+#define USB_O_FIFO13            0x00000054  // USB FIFO Endpoint 13
+#define USB_O_FIFO14            0x00000058  // USB FIFO Endpoint 14
+#define USB_O_FIFO15            0x0000005C  // USB FIFO Endpoint 15
+#define USB_O_DEVCTL            0x00000060  // USB Device Control
+#define USB_O_TXFIFOSZ          0x00000062  // USB Transmit Dynamic FIFO Sizing
+#define USB_O_RXFIFOSZ          0x00000063  // USB Receive Dynamic FIFO Sizing
+#define USB_O_TXFIFOADD         0x00000064  // USB Transmit FIFO Start Address
+#define USB_O_RXFIFOADD         0x00000066  // USB Receive FIFO Start Address
+#define USB_O_CONTIM            0x0000007A  // USB Connect Timing
+#define USB_O_VPLEN             0x0000007B  // USB OTG VBus Pulse Timing
+#define USB_O_FSEOF             0x0000007D  // USB Full-Speed Last Transaction
+                                            // to End of Frame Timing
+#define USB_O_LSEOF             0x0000007E  // USB Low-Speed Last Transaction
+                                            // to End of Frame Timing
+#define USB_O_TXFUNCADDR0       0x00000080  // USB Transmit Functional Address
+                                            // Endpoint 0
+#define USB_O_TXHUBADDR0        0x00000082  // USB Transmit Hub Address
+                                            // Endpoint 0
+#define USB_O_TXHUBPORT0        0x00000083  // USB Transmit Hub Port Endpoint 0
+#define USB_O_TXFUNCADDR1       0x00000088  // USB Transmit Functional Address
+                                            // Endpoint 1
+#define USB_O_TXHUBADDR1        0x0000008A  // USB Transmit Hub Address
+                                            // Endpoint 1
+#define USB_O_TXHUBPORT1        0x0000008B  // USB Transmit Hub Port Endpoint 1
+#define USB_O_RXFUNCADDR1       0x0000008C  // USB Receive Functional Address
+                                            // Endpoint 1
+#define USB_O_RXHUBADDR1        0x0000008E  // USB Receive Hub Address Endpoint
+                                            // 1
+#define USB_O_RXHUBPORT1        0x0000008F  // USB Receive Hub Port Endpoint 1
+#define USB_O_TXFUNCADDR2       0x00000090  // USB Transmit Functional Address
+                                            // Endpoint 2
+#define USB_O_TXHUBADDR2        0x00000092  // USB Transmit Hub Address
+                                            // Endpoint 2
+#define USB_O_TXHUBPORT2        0x00000093  // USB Transmit Hub Port Endpoint 2
+#define USB_O_RXFUNCADDR2       0x00000094  // USB Receive Functional Address
+                                            // Endpoint 2
+#define USB_O_RXHUBADDR2        0x00000096  // USB Receive Hub Address Endpoint
+                                            // 2
+#define USB_O_RXHUBPORT2        0x00000097  // USB Receive Hub Port Endpoint 2
+#define USB_O_TXFUNCADDR3       0x00000098  // USB Transmit Functional Address
+                                            // Endpoint 3
+#define USB_O_TXHUBADDR3        0x0000009A  // USB Transmit Hub Address
+                                            // Endpoint 3
+#define USB_O_TXHUBPORT3        0x0000009B  // USB Transmit Hub Port Endpoint 3
+#define USB_O_RXFUNCADDR3       0x0000009C  // USB Receive Functional Address
+                                            // Endpoint 3
+#define USB_O_RXHUBADDR3        0x0000009E  // USB Receive Hub Address Endpoint
+                                            // 3
+#define USB_O_RXHUBPORT3        0x0000009F  // USB Receive Hub Port Endpoint 3
+#define USB_O_TXFUNCADDR4       0x000000A0  // USB Transmit Functional Address
+                                            // Endpoint 4
+#define USB_O_TXHUBADDR4        0x000000A2  // USB Transmit Hub Address
+                                            // Endpoint 4
+#define USB_O_TXHUBPORT4        0x000000A3  // USB Transmit Hub Port Endpoint 4
+#define USB_O_RXFUNCADDR4       0x000000A4  // USB Receive Functional Address
+                                            // Endpoint 4
+#define USB_O_RXHUBADDR4        0x000000A6  // USB Receive Hub Address Endpoint
+                                            // 4
+#define USB_O_RXHUBPORT4        0x000000A7  // USB Receive Hub Port Endpoint 4
+#define USB_O_TXFUNCADDR5       0x000000A8  // USB Transmit Functional Address
+                                            // Endpoint 5
+#define USB_O_TXHUBADDR5        0x000000AA  // USB Transmit Hub Address
+                                            // Endpoint 5
+#define USB_O_TXHUBPORT5        0x000000AB  // USB Transmit Hub Port Endpoint 5
+#define USB_O_RXFUNCADDR5       0x000000AC  // USB Receive Functional Address
+                                            // Endpoint 5
+#define USB_O_RXHUBADDR5        0x000000AE  // USB Receive Hub Address Endpoint
+                                            // 5
+#define USB_O_RXHUBPORT5        0x000000AF  // USB Receive Hub Port Endpoint 5
+#define USB_O_TXFUNCADDR6       0x000000B0  // USB Transmit Functional Address
+                                            // Endpoint 6
+#define USB_O_TXHUBADDR6        0x000000B2  // USB Transmit Hub Address
+                                            // Endpoint 6
+#define USB_O_TXHUBPORT6        0x000000B3  // USB Transmit Hub Port Endpoint 6
+#define USB_O_RXFUNCADDR6       0x000000B4  // USB Receive Functional Address
+                                            // Endpoint 6
+#define USB_O_RXHUBADDR6        0x000000B6  // USB Receive Hub Address Endpoint
+                                            // 6
+#define USB_O_RXHUBPORT6        0x000000B7  // USB Receive Hub Port Endpoint 6
+#define USB_O_TXFUNCADDR7       0x000000B8  // USB Transmit Functional Address
+                                            // Endpoint 7
+#define USB_O_TXHUBADDR7        0x000000BA  // USB Transmit Hub Address
+                                            // Endpoint 7
+#define USB_O_TXHUBPORT7        0x000000BB  // USB Transmit Hub Port Endpoint 7
+#define USB_O_RXFUNCADDR7       0x000000BC  // USB Receive Functional Address
+                                            // Endpoint 7
+#define USB_O_RXHUBADDR7        0x000000BE  // USB Receive Hub Address Endpoint
+                                            // 7
+#define USB_O_RXHUBPORT7        0x000000BF  // USB Receive Hub Port Endpoint 7
+#define USB_O_TXFUNCADDR8       0x000000C0  // USB Transmit Functional Address
+                                            // Endpoint 8
+#define USB_O_TXHUBADDR8        0x000000C2  // USB Transmit Hub Address
+                                            // Endpoint 8
+#define USB_O_TXHUBPORT8        0x000000C3  // USB Transmit Hub Port Endpoint 8
+#define USB_O_RXFUNCADDR8       0x000000C4  // USB Receive Functional Address
+                                            // Endpoint 8
+#define USB_O_RXHUBADDR8        0x000000C6  // USB Receive Hub Address Endpoint
+                                            // 8
+#define USB_O_RXHUBPORT8        0x000000C7  // USB Receive Hub Port Endpoint 8
+#define USB_O_TXFUNCADDR9       0x000000C8  // USB Transmit Functional Address
+                                            // Endpoint 9
+#define USB_O_TXHUBADDR9        0x000000CA  // USB Transmit Hub Address
+                                            // Endpoint 9
+#define USB_O_TXHUBPORT9        0x000000CB  // USB Transmit Hub Port Endpoint 9
+#define USB_O_RXFUNCADDR9       0x000000CC  // USB Receive Functional Address
+                                            // Endpoint 9
+#define USB_O_RXHUBADDR9        0x000000CE  // USB Receive Hub Address Endpoint
+                                            // 9
+#define USB_O_RXHUBPORT9        0x000000CF  // USB Receive Hub Port Endpoint 9
+#define USB_O_TXFUNCADDR10      0x000000D0  // USB Transmit Functional Address
+                                            // Endpoint 10
+#define USB_O_TXHUBADDR10       0x000000D2  // USB Transmit Hub Address
+                                            // Endpoint 10
+#define USB_O_TXHUBPORT10       0x000000D3  // USB Transmit Hub Port Endpoint
+                                            // 10
+#define USB_O_RXFUNCADDR10      0x000000D4  // USB Receive Functional Address
+                                            // Endpoint 10
+#define USB_O_RXHUBADDR10       0x000000D6  // USB Receive Hub Address Endpoint
+                                            // 10
+#define USB_O_RXHUBPORT10       0x000000D7  // USB Receive Hub Port Endpoint 10
+#define USB_O_TXFUNCADDR11      0x000000D8  // USB Transmit Functional Address
+                                            // Endpoint 11
+#define USB_O_TXHUBADDR11       0x000000DA  // USB Transmit Hub Address
+                                            // Endpoint 11
+#define USB_O_TXHUBPORT11       0x000000DB  // USB Transmit Hub Port Endpoint
+                                            // 11
+#define USB_O_RXFUNCADDR11      0x000000DC  // USB Receive Functional Address
+                                            // Endpoint 11
+#define USB_O_RXHUBADDR11       0x000000DE  // USB Receive Hub Address Endpoint
+                                            // 11
+#define USB_O_RXHUBPORT11       0x000000DF  // USB Receive Hub Port Endpoint 11
+#define USB_O_TXFUNCADDR12      0x000000E0  // USB Transmit Functional Address
+                                            // Endpoint 12
+#define USB_O_TXHUBADDR12       0x000000E2  // USB Transmit Hub Address
+                                            // Endpoint 12
+#define USB_O_TXHUBPORT12       0x000000E3  // USB Transmit Hub Port Endpoint
+                                            // 12
+#define USB_O_RXFUNCADDR12      0x000000E4  // USB Receive Functional Address
+                                            // Endpoint 12
+#define USB_O_RXHUBADDR12       0x000000E6  // USB Receive Hub Address Endpoint
+                                            // 12
+#define USB_O_RXHUBPORT12       0x000000E7  // USB Receive Hub Port Endpoint 12
+#define USB_O_TXFUNCADDR13      0x000000E8  // USB Transmit Functional Address
+                                            // Endpoint 13
+#define USB_O_TXHUBADDR13       0x000000EA  // USB Transmit Hub Address
+                                            // Endpoint 13
+#define USB_O_TXHUBPORT13       0x000000EB  // USB Transmit Hub Port Endpoint
+                                            // 13
+#define USB_O_RXFUNCADDR13      0x000000EC  // USB Receive Functional Address
+                                            // Endpoint 13
+#define USB_O_RXHUBADDR13       0x000000EE  // USB Receive Hub Address Endpoint
+                                            // 13
+#define USB_O_RXHUBPORT13       0x000000EF  // USB Receive Hub Port Endpoint 13
+#define USB_O_TXFUNCADDR14      0x000000F0  // USB Transmit Functional Address
+                                            // Endpoint 14
+#define USB_O_TXHUBADDR14       0x000000F2  // USB Transmit Hub Address
+                                            // Endpoint 14
+#define USB_O_TXHUBPORT14       0x000000F3  // USB Transmit Hub Port Endpoint
+                                            // 14
+#define USB_O_RXFUNCADDR14      0x000000F4  // USB Receive Functional Address
+                                            // Endpoint 14
+#define USB_O_RXHUBADDR14       0x000000F6  // USB Receive Hub Address Endpoint
+                                            // 14
+#define USB_O_RXHUBPORT14       0x000000F7  // USB Receive Hub Port Endpoint 14
+#define USB_O_TXFUNCADDR15      0x000000F8  // USB Transmit Functional Address
+                                            // Endpoint 15
+#define USB_O_TXHUBADDR15       0x000000FA  // USB Transmit Hub Address
+                                            // Endpoint 15
+#define USB_O_TXHUBPORT15       0x000000FB  // USB Transmit Hub Port Endpoint
+                                            // 15
+#define USB_O_RXFUNCADDR15      0x000000FC  // USB Receive Functional Address
+                                            // Endpoint 15
+#define USB_O_RXHUBADDR15       0x000000FE  // USB Receive Hub Address Endpoint
+                                            // 15
+#define USB_O_RXHUBPORT15       0x000000FF  // USB Receive Hub Port Endpoint 15
+#define USB_O_CSRL0             0x00000102  // USB Control and Status Endpoint
+                                            // 0 Low
+#define USB_O_CSRH0             0x00000103  // USB Control and Status Endpoint
+                                            // 0 High
+#define USB_O_COUNT0            0x00000108  // USB Receive Byte Count Endpoint
+                                            // 0
+#define USB_O_TYPE0             0x0000010A  // USB Type Endpoint 0
+#define USB_O_NAKLMT            0x0000010B  // USB NAK Limit
+#define USB_O_TXMAXP1           0x00000110  // USB Maximum Transmit Data
+                                            // Endpoint 1
+#define USB_O_TXCSRL1           0x00000112  // USB Transmit Control and Status
+                                            // Endpoint 1 Low
+#define USB_O_TXCSRH1           0x00000113  // USB Transmit Control and Status
+                                            // Endpoint 1 High
+#define USB_O_RXMAXP1           0x00000114  // USB Maximum Receive Data
+                                            // Endpoint 1
+#define USB_O_RXCSRL1           0x00000116  // USB Receive Control and Status
+                                            // Endpoint 1 Low
+#define USB_O_RXCSRH1           0x00000117  // USB Receive Control and Status
+                                            // Endpoint 1 High
+#define USB_O_RXCOUNT1          0x00000118  // USB Receive Byte Count Endpoint
+                                            // 1
+#define USB_O_TXTYPE1           0x0000011A  // USB Host Transmit Configure Type
+                                            // Endpoint 1
+#define USB_O_TXINTERVAL1       0x0000011B  // USB Host Transmit Interval
+                                            // Endpoint 1
+#define USB_O_RXTYPE1           0x0000011C  // USB Host Configure Receive Type
+                                            // Endpoint 1
+#define USB_O_RXINTERVAL1       0x0000011D  // USB Host Receive Polling
+                                            // Interval Endpoint 1
+#define USB_O_TXMAXP2           0x00000120  // USB Maximum Transmit Data
+                                            // Endpoint 2
+#define USB_O_TXCSRL2           0x00000122  // USB Transmit Control and Status
+                                            // Endpoint 2 Low
+#define USB_O_TXCSRH2           0x00000123  // USB Transmit Control and Status
+                                            // Endpoint 2 High
+#define USB_O_RXMAXP2           0x00000124  // USB Maximum Receive Data
+                                            // Endpoint 2
+#define USB_O_RXCSRL2           0x00000126  // USB Receive Control and Status
+                                            // Endpoint 2 Low
+#define USB_O_RXCSRH2           0x00000127  // USB Receive Control and Status
+                                            // Endpoint 2 High
+#define USB_O_RXCOUNT2          0x00000128  // USB Receive Byte Count Endpoint
+                                            // 2
+#define USB_O_TXTYPE2           0x0000012A  // USB Host Transmit Configure Type
+                                            // Endpoint 2
+#define USB_O_TXINTERVAL2       0x0000012B  // USB Host Transmit Interval
+                                            // Endpoint 2
+#define USB_O_RXTYPE2           0x0000012C  // USB Host Configure Receive Type
+                                            // Endpoint 2
+#define USB_O_RXINTERVAL2       0x0000012D  // USB Host Receive Polling
+                                            // Interval Endpoint 2
+#define USB_O_TXMAXP3           0x00000130  // USB Maximum Transmit Data
+                                            // Endpoint 3
+#define USB_O_TXCSRL3           0x00000132  // USB Transmit Control and Status
+                                            // Endpoint 3 Low
+#define USB_O_TXCSRH3           0x00000133  // USB Transmit Control and Status
+                                            // Endpoint 3 High
+#define USB_O_RXMAXP3           0x00000134  // USB Maximum Receive Data
+                                            // Endpoint 3
+#define USB_O_RXCSRL3           0x00000136  // USB Receive Control and Status
+                                            // Endpoint 3 Low
+#define USB_O_RXCSRH3           0x00000137  // USB Receive Control and Status
+                                            // Endpoint 3 High
+#define USB_O_RXCOUNT3          0x00000138  // USB Receive Byte Count Endpoint
+                                            // 3
+#define USB_O_TXTYPE3           0x0000013A  // USB Host Transmit Configure Type
+                                            // Endpoint 3
+#define USB_O_TXINTERVAL3       0x0000013B  // USB Host Transmit Interval
+                                            // Endpoint 3
+#define USB_O_RXTYPE3           0x0000013C  // USB Host Configure Receive Type
+                                            // Endpoint 3
+#define USB_O_RXINTERVAL3       0x0000013D  // USB Host Receive Polling
+                                            // Interval Endpoint 3
+#define USB_O_TXMAXP4           0x00000140  // USB Maximum Transmit Data
+                                            // Endpoint 4
+#define USB_O_TXCSRL4           0x00000142  // USB Transmit Control and Status
+                                            // Endpoint 4 Low
+#define USB_O_TXCSRH4           0x00000143  // USB Transmit Control and Status
+                                            // Endpoint 4 High
+#define USB_O_RXMAXP4           0x00000144  // USB Maximum Receive Data
+                                            // Endpoint 4
+#define USB_O_RXCSRL4           0x00000146  // USB Receive Control and Status
+                                            // Endpoint 4 Low
+#define USB_O_RXCSRH4           0x00000147  // USB Receive Control and Status
+                                            // Endpoint 4 High
+#define USB_O_RXCOUNT4          0x00000148  // USB Receive Byte Count Endpoint
+                                            // 4
+#define USB_O_TXTYPE4           0x0000014A  // USB Host Transmit Configure Type
+                                            // Endpoint 4
+#define USB_O_TXINTERVAL4       0x0000014B  // USB Host Transmit Interval
+                                            // Endpoint 4
+#define USB_O_RXTYPE4           0x0000014C  // USB Host Configure Receive Type
+                                            // Endpoint 4
+#define USB_O_RXINTERVAL4       0x0000014D  // USB Host Receive Polling
+                                            // Interval Endpoint 4
+#define USB_O_TXMAXP5           0x00000150  // USB Maximum Transmit Data
+                                            // Endpoint 5
+#define USB_O_TXCSRL5           0x00000152  // USB Transmit Control and Status
+                                            // Endpoint 5 Low
+#define USB_O_TXCSRH5           0x00000153  // USB Transmit Control and Status
+                                            // Endpoint 5 High
+#define USB_O_RXMAXP5           0x00000154  // USB Maximum Receive Data
+                                            // Endpoint 5
+#define USB_O_RXCSRL5           0x00000156  // USB Receive Control and Status
+                                            // Endpoint 5 Low
+#define USB_O_RXCSRH5           0x00000157  // USB Receive Control and Status
+                                            // Endpoint 5 High
+#define USB_O_RXCOUNT5          0x00000158  // USB Receive Byte Count Endpoint
+                                            // 5
+#define USB_O_TXTYPE5           0x0000015A  // USB Host Transmit Configure Type
+                                            // Endpoint 5
+#define USB_O_TXINTERVAL5       0x0000015B  // USB Host Transmit Interval
+                                            // Endpoint 5
+#define USB_O_RXTYPE5           0x0000015C  // USB Host Configure Receive Type
+                                            // Endpoint 5
+#define USB_O_RXINTERVAL5       0x0000015D  // USB Host Receive Polling
+                                            // Interval Endpoint 5
+#define USB_O_TXMAXP6           0x00000160  // USB Maximum Transmit Data
+                                            // Endpoint 6
+#define USB_O_TXCSRL6           0x00000162  // USB Transmit Control and Status
+                                            // Endpoint 6 Low
+#define USB_O_TXCSRH6           0x00000163  // USB Transmit Control and Status
+                                            // Endpoint 6 High
+#define USB_O_RXMAXP6           0x00000164  // USB Maximum Receive Data
+                                            // Endpoint 6
+#define USB_O_RXCSRL6           0x00000166  // USB Receive Control and Status
+                                            // Endpoint 6 Low
+#define USB_O_RXCSRH6           0x00000167  // USB Receive Control and Status
+                                            // Endpoint 6 High
+#define USB_O_RXCOUNT6          0x00000168  // USB Receive Byte Count Endpoint
+                                            // 6
+#define USB_O_TXTYPE6           0x0000016A  // USB Host Transmit Configure Type
+                                            // Endpoint 6
+#define USB_O_TXINTERVAL6       0x0000016B  // USB Host Transmit Interval
+                                            // Endpoint 6
+#define USB_O_RXTYPE6           0x0000016C  // USB Host Configure Receive Type
+                                            // Endpoint 6
+#define USB_O_RXINTERVAL6       0x0000016D  // USB Host Receive Polling
+                                            // Interval Endpoint 6
+#define USB_O_TXMAXP7           0x00000170  // USB Maximum Transmit Data
+                                            // Endpoint 7
+#define USB_O_TXCSRL7           0x00000172  // USB Transmit Control and Status
+                                            // Endpoint 7 Low
+#define USB_O_TXCSRH7           0x00000173  // USB Transmit Control and Status
+                                            // Endpoint 7 High
+#define USB_O_RXMAXP7           0x00000174  // USB Maximum Receive Data
+                                            // Endpoint 7
+#define USB_O_RXCSRL7           0x00000176  // USB Receive Control and Status
+                                            // Endpoint 7 Low
+#define USB_O_RXCSRH7           0x00000177  // USB Receive Control and Status
+                                            // Endpoint 7 High
+#define USB_O_RXCOUNT7          0x00000178  // USB Receive Byte Count Endpoint
+                                            // 7
+#define USB_O_TXTYPE7           0x0000017A  // USB Host Transmit Configure Type
+                                            // Endpoint 7
+#define USB_O_TXINTERVAL7       0x0000017B  // USB Host Transmit Interval
+                                            // Endpoint 7
+#define USB_O_RXTYPE7           0x0000017C  // USB Host Configure Receive Type
+                                            // Endpoint 7
+#define USB_O_RXINTERVAL7       0x0000017D  // USB Host Receive Polling
+                                            // Interval Endpoint 7
+#define USB_O_TXMAXP8           0x00000180  // USB Maximum Transmit Data
+                                            // Endpoint 8
+#define USB_O_TXCSRL8           0x00000182  // USB Transmit Control and Status
+                                            // Endpoint 8 Low
+#define USB_O_TXCSRH8           0x00000183  // USB Transmit Control and Status
+                                            // Endpoint 8 High
+#define USB_O_RXMAXP8           0x00000184  // USB Maximum Receive Data
+                                            // Endpoint 8
+#define USB_O_RXCSRL8           0x00000186  // USB Receive Control and Status
+                                            // Endpoint 8 Low
+#define USB_O_RXCSRH8           0x00000187  // USB Receive Control and Status
+                                            // Endpoint 8 High
+#define USB_O_RXCOUNT8          0x00000188  // USB Receive Byte Count Endpoint
+                                            // 8
+#define USB_O_TXTYPE8           0x0000018A  // USB Host Transmit Configure Type
+                                            // Endpoint 8
+#define USB_O_TXINTERVAL8       0x0000018B  // USB Host Transmit Interval
+                                            // Endpoint 8
+#define USB_O_RXTYPE8           0x0000018C  // USB Host Configure Receive Type
+                                            // Endpoint 8
+#define USB_O_RXINTERVAL8       0x0000018D  // USB Host Receive Polling
+                                            // Interval Endpoint 8
+#define USB_O_TXMAXP9           0x00000190  // USB Maximum Transmit Data
+                                            // Endpoint 9
+#define USB_O_TXCSRL9           0x00000192  // USB Transmit Control and Status
+                                            // Endpoint 9 Low
+#define USB_O_TXCSRH9           0x00000193  // USB Transmit Control and Status
+                                            // Endpoint 9 High
+#define USB_O_RXMAXP9           0x00000194  // USB Maximum Receive Data
+                                            // Endpoint 9
+#define USB_O_RXCSRL9           0x00000196  // USB Receive Control and Status
+                                            // Endpoint 9 Low
+#define USB_O_RXCSRH9           0x00000197  // USB Receive Control and Status
+                                            // Endpoint 9 High
+#define USB_O_RXCOUNT9          0x00000198  // USB Receive Byte Count Endpoint
+                                            // 9
+#define USB_O_TXTYPE9           0x0000019A  // USB Host Transmit Configure Type
+                                            // Endpoint 9
+#define USB_O_TXINTERVAL9       0x0000019B  // USB Host Transmit Interval
+                                            // Endpoint 9
+#define USB_O_RXTYPE9           0x0000019C  // USB Host Configure Receive Type
+                                            // Endpoint 9
+#define USB_O_RXINTERVAL9       0x0000019D  // USB Host Receive Polling
+                                            // Interval Endpoint 9
+#define USB_O_TXMAXP10          0x000001A0  // USB Maximum Transmit Data
+                                            // Endpoint 10
+#define USB_O_TXCSRL10          0x000001A2  // USB Transmit Control and Status
+                                            // Endpoint 10 Low
+#define USB_O_TXCSRH10          0x000001A3  // USB Transmit Control and Status
+                                            // Endpoint 10 High
+#define USB_O_RXMAXP10          0x000001A4  // USB Maximum Receive Data
+                                            // Endpoint 10
+#define USB_O_RXCSRL10          0x000001A6  // USB Receive Control and Status
+                                            // Endpoint 10 Low
+#define USB_O_RXCSRH10          0x000001A7  // USB Receive Control and Status
+                                            // Endpoint 10 High
+#define USB_O_RXCOUNT10         0x000001A8  // USB Receive Byte Count Endpoint
+                                            // 10
+#define USB_O_TXTYPE10          0x000001AA  // USB Host Transmit Configure Type
+                                            // Endpoint 10
+#define USB_O_TXINTERVAL10      0x000001AB  // USB Host Transmit Interval
+                                            // Endpoint 10
+#define USB_O_RXTYPE10          0x000001AC  // USB Host Configure Receive Type
+                                            // Endpoint 10
+#define USB_O_RXINTERVAL10      0x000001AD  // USB Host Receive Polling
+                                            // Interval Endpoint 10
+#define USB_O_TXMAXP11          0x000001B0  // USB Maximum Transmit Data
+                                            // Endpoint 11
+#define USB_O_TXCSRL11          0x000001B2  // USB Transmit Control and Status
+                                            // Endpoint 11 Low
+#define USB_O_TXCSRH11          0x000001B3  // USB Transmit Control and Status
+                                            // Endpoint 11 High
+#define USB_O_RXMAXP11          0x000001B4  // USB Maximum Receive Data
+                                            // Endpoint 11
+#define USB_O_RXCSRL11          0x000001B6  // USB Receive Control and Status
+                                            // Endpoint 11 Low
+#define USB_O_RXCSRH11          0x000001B7  // USB Receive Control and Status
+                                            // Endpoint 11 High
+#define USB_O_RXCOUNT11         0x000001B8  // USB Receive Byte Count Endpoint
+                                            // 11
+#define USB_O_TXTYPE11          0x000001BA  // USB Host Transmit Configure Type
+                                            // Endpoint 11
+#define USB_O_TXINTERVAL11      0x000001BB  // USB Host Transmit Interval
+                                            // Endpoint 11
+#define USB_O_RXTYPE11          0x000001BC  // USB Host Configure Receive Type
+                                            // Endpoint 11
+#define USB_O_RXINTERVAL11      0x000001BD  // USB Host Receive Polling
+                                            // Interval Endpoint 11
+#define USB_O_TXMAXP12          0x000001C0  // USB Maximum Transmit Data
+                                            // Endpoint 12
+#define USB_O_TXCSRL12          0x000001C2  // USB Transmit Control and Status
+                                            // Endpoint 12 Low
+#define USB_O_TXCSRH12          0x000001C3  // USB Transmit Control and Status
+                                            // Endpoint 12 High
+#define USB_O_RXMAXP12          0x000001C4  // USB Maximum Receive Data
+                                            // Endpoint 12
+#define USB_O_RXCSRL12          0x000001C6  // USB Receive Control and Status
+                                            // Endpoint 12 Low
+#define USB_O_RXCSRH12          0x000001C7  // USB Receive Control and Status
+                                            // Endpoint 12 High
+#define USB_O_RXCOUNT12         0x000001C8  // USB Receive Byte Count Endpoint
+                                            // 12
+#define USB_O_TXTYPE12          0x000001CA  // USB Host Transmit Configure Type
+                                            // Endpoint 12
+#define USB_O_TXINTERVAL12      0x000001CB  // USB Host Transmit Interval
+                                            // Endpoint 12
+#define USB_O_RXTYPE12          0x000001CC  // USB Host Configure Receive Type
+                                            // Endpoint 12
+#define USB_O_RXINTERVAL12      0x000001CD  // USB Host Receive Polling
+                                            // Interval Endpoint 12
+#define USB_O_TXMAXP13          0x000001D0  // USB Maximum Transmit Data
+                                            // Endpoint 13
+#define USB_O_TXCSRL13          0x000001D2  // USB Transmit Control and Status
+                                            // Endpoint 13 Low
+#define USB_O_TXCSRH13          0x000001D3  // USB Transmit Control and Status
+                                            // Endpoint 13 High
+#define USB_O_RXMAXP13          0x000001D4  // USB Maximum Receive Data
+                                            // Endpoint 13
+#define USB_O_RXCSRL13          0x000001D6  // USB Receive Control and Status
+                                            // Endpoint 13 Low
+#define USB_O_RXCSRH13          0x000001D7  // USB Receive Control and Status
+                                            // Endpoint 13 High
+#define USB_O_RXCOUNT13         0x000001D8  // USB Receive Byte Count Endpoint
+                                            // 13
+#define USB_O_TXTYPE13          0x000001DA  // USB Host Transmit Configure Type
+                                            // Endpoint 13
+#define USB_O_TXINTERVAL13      0x000001DB  // USB Host Transmit Interval
+                                            // Endpoint 13
+#define USB_O_RXTYPE13          0x000001DC  // USB Host Configure Receive Type
+                                            // Endpoint 13
+#define USB_O_RXINTERVAL13      0x000001DD  // USB Host Receive Polling
+                                            // Interval Endpoint 13
+#define USB_O_TXMAXP14          0x000001E0  // USB Maximum Transmit Data
+                                            // Endpoint 14
+#define USB_O_TXCSRL14          0x000001E2  // USB Transmit Control and Status
+                                            // Endpoint 14 Low
+#define USB_O_TXCSRH14          0x000001E3  // USB Transmit Control and Status
+                                            // Endpoint 14 High
+#define USB_O_RXMAXP14          0x000001E4  // USB Maximum Receive Data
+                                            // Endpoint 14
+#define USB_O_RXCSRL14          0x000001E6  // USB Receive Control and Status
+                                            // Endpoint 14 Low
+#define USB_O_RXCSRH14          0x000001E7  // USB Receive Control and Status
+                                            // Endpoint 14 High
+#define USB_O_RXCOUNT14         0x000001E8  // USB Receive Byte Count Endpoint
+                                            // 14
+#define USB_O_TXTYPE14          0x000001EA  // USB Host Transmit Configure Type
+                                            // Endpoint 14
+#define USB_O_TXINTERVAL14      0x000001EB  // USB Host Transmit Interval
+                                            // Endpoint 14
+#define USB_O_RXTYPE14          0x000001EC  // USB Host Configure Receive Type
+                                            // Endpoint 14
+#define USB_O_RXINTERVAL14      0x000001ED  // USB Host Receive Polling
+                                            // Interval Endpoint 14
+#define USB_O_TXMAXP15          0x000001F0  // USB Maximum Transmit Data
+                                            // Endpoint 15
+#define USB_O_TXCSRL15          0x000001F2  // USB Transmit Control and Status
+                                            // Endpoint 15 Low
+#define USB_O_TXCSRH15          0x000001F3  // USB Transmit Control and Status
+                                            // Endpoint 15 High
+#define USB_O_RXMAXP15          0x000001F4  // USB Maximum Receive Data
+                                            // Endpoint 15
+#define USB_O_RXCSRL15          0x000001F6  // USB Receive Control and Status
+                                            // Endpoint 15 Low
+#define USB_O_RXCSRH15          0x000001F7  // USB Receive Control and Status
+                                            // Endpoint 15 High
+#define USB_O_RXCOUNT15         0x000001F8  // USB Receive Byte Count Endpoint
+                                            // 15
+#define USB_O_TXTYPE15          0x000001FA  // USB Host Transmit Configure Type
+                                            // Endpoint 15
+#define USB_O_TXINTERVAL15      0x000001FB  // USB Host Transmit Interval
+                                            // Endpoint 15
+#define USB_O_RXTYPE15          0x000001FC  // USB Host Configure Receive Type
+                                            // Endpoint 15
+#define USB_O_RXINTERVAL15      0x000001FD  // USB Host Receive Polling
+                                            // Interval Endpoint 15
+#define USB_O_RQPKTCOUNT1       0x00000304  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 1
+#define USB_O_RQPKTCOUNT2       0x00000308  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 2
+#define USB_O_RQPKTCOUNT3       0x0000030C  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 3
+#define USB_O_RQPKTCOUNT4       0x00000310  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 4
+#define USB_O_RQPKTCOUNT5       0x00000314  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 5
+#define USB_O_RQPKTCOUNT6       0x00000318  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 6
+#define USB_O_RQPKTCOUNT7       0x0000031C  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 7
+#define USB_O_RQPKTCOUNT8       0x00000320  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 8
+#define USB_O_RQPKTCOUNT9       0x00000324  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 9
+#define USB_O_RQPKTCOUNT10      0x00000328  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 10
+#define USB_O_RQPKTCOUNT11      0x0000032C  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 11
+#define USB_O_RQPKTCOUNT12      0x00000330  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 12
+#define USB_O_RQPKTCOUNT13      0x00000334  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 13
+#define USB_O_RQPKTCOUNT14      0x00000338  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 14
+#define USB_O_RQPKTCOUNT15      0x0000033C  // USB Request Packet Count in
+                                            // Block Transfer Endpoint 15
+#define USB_O_RXDPKTBUFDIS      0x00000340  // USB Receive Double Packet Buffer
+                                            // Disable
+#define USB_O_TXDPKTBUFDIS      0x00000342  // USB Transmit Double Packet
+                                            // Buffer Disable
+#define USB_O_EPC               0x00000400  // USB External Power Control
+#define USB_O_EPCRIS            0x00000404  // USB External Power Control Raw
+                                            // Interrupt Status
+#define USB_O_EPCIM             0x00000408  // USB External Power Control
+                                            // Interrupt Mask
+#define USB_O_EPCISC            0x0000040C  // USB External Power Control
+                                            // Interrupt Status and Clear
+#define USB_O_DRRIS             0x00000410  // USB Device Resume Raw Interrupt
+                                            // Status
+#define USB_O_DRIM              0x00000414  // USB Device Resume Interrupt Mask
+#define USB_O_DRISC             0x00000418  // USB Device Resume Interrupt
+                                            // Status and Clear
+#define USB_O_GPCS              0x0000041C  // USB General-Purpose Control and
+                                            // Status
+#define USB_O_VDC               0x00000430  // USB VBUS Droop Control
+#define USB_O_VDCRIS            0x00000434  // USB VBUS Droop Control Raw
+                                            // Interrupt Status
+#define USB_O_VDCIM             0x00000438  // USB VBUS Droop Control Interrupt
+                                            // Mask
+#define USB_O_VDCISC            0x0000043C  // USB VBUS Droop Control Interrupt
+                                            // Status and Clear
+#define USB_O_IDVRIS            0x00000444  // USB ID Valid Detect Raw
+                                            // Interrupt Status
+#define USB_O_IDVIM             0x00000448  // USB ID Valid Detect Interrupt
+                                            // Mask
+#define USB_O_IDVISC            0x0000044C  // USB ID Valid Detect Interrupt
+                                            // Status and Clear
+#define USB_O_EPS               0x00000450  // USB End-Point Select
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FADDR register.
+//
+//*****************************************************************************
+#define USB_FADDR_M             0x0000007F  // Function Address.
+#define USB_FADDR_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_POWER register.
+//
+//*****************************************************************************
+#define USB_POWER_ISOUP         0x00000080  // ISO Update.
+#define USB_POWER_SOFTCONN      0x00000040  // Soft Connect/Disconnect.
+#define USB_POWER_RESET         0x00000008  // Reset.
+#define USB_POWER_RESUME        0x00000004  // Resume Signaling.
+#define USB_POWER_SUSPEND       0x00000002  // Suspend Mode.
+#define USB_POWER_PWRDNPHY      0x00000001  // Power Down PHY.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXIS register.
+//
+//*****************************************************************************
+#define USB_TXIS_EP15           0x00008000  // TX Endpoint 15 Interrupt.
+#define USB_TXIS_EP14           0x00004000  // TX Endpoint 14 Interrupt.
+#define USB_TXIS_EP13           0x00002000  // TX Endpoint 13 Interrupt.
+#define USB_TXIS_EP12           0x00001000  // TX Endpoint 12 Interrupt.
+#define USB_TXIS_EP11           0x00000800  // TX Endpoint 11 Interrupt.
+#define USB_TXIS_EP10           0x00000400  // TX Endpoint 10 Interrupt.
+#define USB_TXIS_EP9            0x00000200  // TX Endpoint 9 Interrupt.
+#define USB_TXIS_EP8            0x00000100  // TX Endpoint 8 Interrupt.
+#define USB_TXIS_EP7            0x00000080  // TX Endpoint 7 Interrupt.
+#define USB_TXIS_EP6            0x00000040  // TX Endpoint 6 Interrupt.
+#define USB_TXIS_EP5            0x00000020  // TX Endpoint 5 Interrupt.
+#define USB_TXIS_EP4            0x00000010  // TX Endpoint 4 Interrupt.
+#define USB_TXIS_EP3            0x00000008  // TX Endpoint 3 Interrupt.
+#define USB_TXIS_EP2            0x00000004  // TX Endpoint 2 Interrupt.
+#define USB_TXIS_EP1            0x00000002  // TX Endpoint 1 Interrupt.
+#define USB_TXIS_EP0            0x00000001  // TX and RX Endpoint 0 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXIS register.
+//
+//*****************************************************************************
+#define USB_RXIS_EP15           0x00008000  // RX Endpoint 15 Interrupt.
+#define USB_RXIS_EP14           0x00004000  // RX Endpoint 14 Interrupt.
+#define USB_RXIS_EP13           0x00002000  // RX Endpoint 13 Interrupt.
+#define USB_RXIS_EP12           0x00001000  // RX Endpoint 12 Interrupt.
+#define USB_RXIS_EP11           0x00000800  // RX Endpoint 11 Interrupt.
+#define USB_RXIS_EP10           0x00000400  // RX Endpoint 10 Interrupt.
+#define USB_RXIS_EP9            0x00000200  // RX Endpoint 9 Interrupt.
+#define USB_RXIS_EP8            0x00000100  // RX Endpoint 8 Interrupt.
+#define USB_RXIS_EP7            0x00000080  // RX Endpoint 7 Interrupt.
+#define USB_RXIS_EP6            0x00000040  // RX Endpoint 6 Interrupt.
+#define USB_RXIS_EP5            0x00000020  // RX Endpoint 5 Interrupt.
+#define USB_RXIS_EP4            0x00000010  // RX Endpoint 4 Interrupt.
+#define USB_RXIS_EP3            0x00000008  // RX Endpoint 3 Interrupt.
+#define USB_RXIS_EP2            0x00000004  // RX Endpoint 2 Interrupt.
+#define USB_RXIS_EP1            0x00000002  // RX Endpoint 1 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXIE register.
+//
+//*****************************************************************************
+#define USB_TXIE_EP15           0x00008000  // TX Endpoint 15 Interrupt Enable.
+#define USB_TXIE_EP14           0x00004000  // TX Endpoint 14 Interrupt Enable.
+#define USB_TXIE_EP13           0x00002000  // TX Endpoint 13 Interrupt Enable.
+#define USB_TXIE_EP12           0x00001000  // TX Endpoint 12 Interrupt Enable.
+#define USB_TXIE_EP11           0x00000800  // TX Endpoint 11 Interrupt Enable.
+#define USB_TXIE_EP10           0x00000400  // TX Endpoint 10 Interrupt Enable.
+#define USB_TXIE_EP9            0x00000200  // TX Endpoint 9 Interrupt Enable.
+#define USB_TXIE_EP8            0x00000100  // TX Endpoint 8 Interrupt Enable.
+#define USB_TXIE_EP7            0x00000080  // TX Endpoint 7 Interrupt Enable.
+#define USB_TXIE_EP6            0x00000040  // TX Endpoint 6 Interrupt Enable.
+#define USB_TXIE_EP5            0x00000020  // TX Endpoint 5 Interrupt Enable.
+#define USB_TXIE_EP4            0x00000010  // TX Endpoint 4 Interrupt Enable.
+#define USB_TXIE_EP3            0x00000008  // TX Endpoint 3 Interrupt Enable.
+#define USB_TXIE_EP2            0x00000004  // TX Endpoint 2 Interrupt Enable.
+#define USB_TXIE_EP1            0x00000002  // TX Endpoint 1 Interrupt Enable.
+#define USB_TXIE_EP0            0x00000001  // TX and RX Endpoint 0 Interrupt
+                                            // Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXIE register.
+//
+//*****************************************************************************
+#define USB_RXIE_EP15           0x00008000  // RX Endpoint 15 Interrupt Enable.
+#define USB_RXIE_EP14           0x00004000  // RX Endpoint 14 Interrupt Enable.
+#define USB_RXIE_EP13           0x00002000  // RX Endpoint 13 Interrupt Enable.
+#define USB_RXIE_EP12           0x00001000  // RX Endpoint 12 Interrupt Enable.
+#define USB_RXIE_EP11           0x00000800  // RX Endpoint 11 Interrupt Enable.
+#define USB_RXIE_EP10           0x00000400  // RX Endpoint 10 Interrupt Enable.
+#define USB_RXIE_EP9            0x00000200  // RX Endpoint 9 Interrupt Enable.
+#define USB_RXIE_EP8            0x00000100  // RX Endpoint 8 Interrupt Enable.
+#define USB_RXIE_EP7            0x00000080  // RX Endpoint 7 Interrupt Enable.
+#define USB_RXIE_EP6            0x00000040  // RX Endpoint 6 Interrupt Enable.
+#define USB_RXIE_EP5            0x00000020  // RX Endpoint 5 Interrupt Enable.
+#define USB_RXIE_EP4            0x00000010  // RX Endpoint 4 Interrupt Enable.
+#define USB_RXIE_EP3            0x00000008  // RX Endpoint 3 Interrupt Enable.
+#define USB_RXIE_EP2            0x00000004  // RX Endpoint 2 Interrupt Enable.
+#define USB_RXIE_EP1            0x00000002  // RX Endpoint 1 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IS register.
+//
+//*****************************************************************************
+#define USB_IS_VBUSERR          0x00000080  // VBus Error.
+#define USB_IS_SESREQ           0x00000040  // Session Request.
+#define USB_IS_DISCON           0x00000020  // Session Disconnect.
+#define USB_IS_CONN             0x00000010  // Session Connect.
+#define USB_IS_SOF              0x00000008  // Start of Frame.
+#define USB_IS_BABBLE           0x00000004  // Babble Detected.
+#define USB_IS_RESET            0x00000004  // Reset Signal Detected.
+#define USB_IS_RESUME           0x00000002  // Resume Signal Detected.
+#define USB_IS_SUSPEND          0x00000001  // Suspend Signal Detected.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IE register.
+//
+//*****************************************************************************
+#define USB_IE_VBUSERR          0x00000080  // Enable VBUS Error Interrupt.
+#define USB_IE_SESREQ           0x00000040  // Enable Session Request
+                                            // Interrupt.
+#define USB_IE_DISCON           0x00000020  // Enable Disconnect Interrupt.
+#define USB_IE_CONN             0x00000010  // Enable Connect Interrupt.
+#define USB_IE_SOF              0x00000008  // Enable Start-of-Frame Interrupt.
+#define USB_IE_BABBLE           0x00000004  // Enable Babble Interrupt.
+#define USB_IE_RESET            0x00000004  // Enable Reset Interrupt.
+#define USB_IE_RESUME           0x00000002  // Enable Resume Interrupt.
+#define USB_IE_SUSPND           0x00000001  // Enable Suspend Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FRAME register.
+//
+//*****************************************************************************
+#define USB_FRAME_M             0x000007FF  // Frame Number.
+#define USB_FRAME_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPIDX register.
+//
+//*****************************************************************************
+#define USB_EPIDX_EPIDX_M       0x0000000F  // Endpoint Index.
+#define USB_EPIDX_EPIDX_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TEST register.
+//
+//*****************************************************************************
+#define USB_TEST_FORCEH         0x00000080  // Force Host Mode.
+#define USB_TEST_FIFOACC        0x00000040  // FIFO Access.
+#define USB_TEST_FORCEFS        0x00000020  // Force Full Speed.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO0 register.
+//
+//*****************************************************************************
+#define USB_FIFO0_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO0_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO1 register.
+//
+//*****************************************************************************
+#define USB_FIFO1_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO1_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO2 register.
+//
+//*****************************************************************************
+#define USB_FIFO2_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO2_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO3 register.
+//
+//*****************************************************************************
+#define USB_FIFO3_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO3_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DEVCTL register.
+//
+//*****************************************************************************
+#define USB_DEVCTL_DEV          0x00000080  // Device Mode.
+#define USB_DEVCTL_FSDEV        0x00000040  // Full-Speed Device Detected.
+#define USB_DEVCTL_LSDEV        0x00000020  // Low-Speed Device Detected.
+#define USB_DEVCTL_VBUS_M       0x00000018  // VBus Level.
+#define USB_DEVCTL_VBUS_NONE    0x00000000  // Below SessionEnd
+#define USB_DEVCTL_VBUS_SEND    0x00000008  // Above SessionEnd, below AValid
+#define USB_DEVCTL_VBUS_AVALID  0x00000010  // Above AValid, below VBusValid
+#define USB_DEVCTL_VBUS_VALID   0x00000018  // Above VBusValid
+#define USB_DEVCTL_HOST         0x00000004  // Host Mode.
+#define USB_DEVCTL_HOSTREQ      0x00000002  // Host Request.
+#define USB_DEVCTL_SESSION      0x00000001  // Session Start/End.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFIFOSZ register.
+//
+//*****************************************************************************
+#define USB_TXFIFOSZ_DPB        0x00000010  // Double Packet Buffer Support.
+#define USB_TXFIFOSZ_SIZE_M     0x0000000F  // Max Packet Size.
+#define USB_TXFIFOSZ_SIZE_8     0x00000000  // 8
+#define USB_TXFIFOSZ_SIZE_16    0x00000001  // 16
+#define USB_TXFIFOSZ_SIZE_32    0x00000002  // 32
+#define USB_TXFIFOSZ_SIZE_64    0x00000003  // 64
+#define USB_TXFIFOSZ_SIZE_128   0x00000004  // 128
+#define USB_TXFIFOSZ_SIZE_256   0x00000005  // 256
+#define USB_TXFIFOSZ_SIZE_512   0x00000006  // 512
+#define USB_TXFIFOSZ_SIZE_1024  0x00000007  // 1024
+#define USB_TXFIFOSZ_SIZE_2048  0x00000008  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFIFOSZ register.
+//
+//*****************************************************************************
+#define USB_RXFIFOSZ_DPB        0x00000010  // Double Packet Buffer Support.
+#define USB_RXFIFOSZ_SIZE_M     0x0000000F  // Max Packet Size.
+#define USB_RXFIFOSZ_SIZE_8     0x00000000  // 8
+#define USB_RXFIFOSZ_SIZE_16    0x00000001  // 16
+#define USB_RXFIFOSZ_SIZE_32    0x00000002  // 32
+#define USB_RXFIFOSZ_SIZE_64    0x00000003  // 64
+#define USB_RXFIFOSZ_SIZE_128   0x00000004  // 128
+#define USB_RXFIFOSZ_SIZE_256   0x00000005  // 256
+#define USB_RXFIFOSZ_SIZE_512   0x00000006  // 512
+#define USB_RXFIFOSZ_SIZE_1024  0x00000007  // 1024
+#define USB_RXFIFOSZ_SIZE_2048  0x00000008  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFIFOADD
+// register.
+//
+//*****************************************************************************
+#define USB_TXFIFOADD_ADDR_M    0x00001FFF  // Transmit/Receive Start Address.
+#define USB_TXFIFOADD_ADDR_0    0x00000000  // 0
+#define USB_TXFIFOADD_ADDR_8    0x00000001  // 8
+#define USB_TXFIFOADD_ADDR_16   0x00000002  // 16
+#define USB_TXFIFOADD_ADDR_32   0x00000003  // 32
+#define USB_TXFIFOADD_ADDR_64   0x00000004  // 64
+#define USB_TXFIFOADD_ADDR_128  0x00000005  // 128
+#define USB_TXFIFOADD_ADDR_256  0x00000006  // 256
+#define USB_TXFIFOADD_ADDR_512  0x00000007  // 512
+#define USB_TXFIFOADD_ADDR_1024 0x00000008  // 1024
+#define USB_TXFIFOADD_ADDR_2048 0x00000009  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFIFOADD
+// register.
+//
+//*****************************************************************************
+#define USB_RXFIFOADD_ADDR_M    0x00001FFF  // Transmit/Receive Start Address.
+#define USB_RXFIFOADD_ADDR_0    0x00000000  // 0
+#define USB_RXFIFOADD_ADDR_8    0x00000001  // 8
+#define USB_RXFIFOADD_ADDR_16   0x00000002  // 16
+#define USB_RXFIFOADD_ADDR_32   0x00000003  // 32
+#define USB_RXFIFOADD_ADDR_64   0x00000004  // 64
+#define USB_RXFIFOADD_ADDR_128  0x00000005  // 128
+#define USB_RXFIFOADD_ADDR_256  0x00000006  // 256
+#define USB_RXFIFOADD_ADDR_512  0x00000007  // 512
+#define USB_RXFIFOADD_ADDR_1024 0x00000008  // 1024
+#define USB_RXFIFOADD_ADDR_2048 0x00000009  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CONTIM register.
+//
+//*****************************************************************************
+#define USB_CONTIM_WTCON_M      0x000000F0  // Connect Wait.
+#define USB_CONTIM_WTID_M       0x0000000F  // Wait ID.
+#define USB_CONTIM_WTCON_S      4
+#define USB_CONTIM_WTID_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FSEOF register.
+//
+//*****************************************************************************
+#define USB_FSEOF_FSEOFG_M      0x000000FF  // Full-Speed End-of-Frame Gap.
+#define USB_FSEOF_FSEOFG_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LSEOF register.
+//
+//*****************************************************************************
+#define USB_LSEOF_LSEOFG_M      0x000000FF  // Low-Speed End-of-Frame Gap.
+#define USB_LSEOF_LSEOFG_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR0
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR0_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR0_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR0
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR0_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR0_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR0_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT0
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT0_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT0_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR1_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR1_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR1_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR1_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR1_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT1
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT1_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT1_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR1_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR1_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR1_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR1_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR1_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT1
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT1_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT1_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR2_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR2_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR2_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR2_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR2_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT2
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT2_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT2_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR2_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR2_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR2_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR2_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR2_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT2
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT2_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT2_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR3_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR3_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR3_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR3_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR3_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT3
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT3_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT3_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR3_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR3_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR3_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR3_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR3_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT3
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT3_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT3_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CSRL0 register.
+//
+//*****************************************************************************
+#define USB_CSRL0_NAKTO         0x00000080  // NAK Timeout.
+#define USB_CSRL0_SETENDC       0x00000080  // Setup End Clear.
+#define USB_CSRL0_STATUS        0x00000040  // Status Packet.
+#define USB_CSRL0_RXRDYC        0x00000040  // RXRDY Clear.
+#define USB_CSRL0_REQPKT        0x00000020  // Request Packet.
+#define USB_CSRL0_STALL         0x00000020  // Send Stall.
+#define USB_CSRL0_SETEND        0x00000010  // Setup End.
+#define USB_CSRL0_ERROR         0x00000010  // Error.
+#define USB_CSRL0_DATAEND       0x00000008  // Data End.
+#define USB_CSRL0_SETUP         0x00000008  // Setup Packet.
+#define USB_CSRL0_STALLED       0x00000004  // Endpoint Stalled.
+#define USB_CSRL0_TXRDY         0x00000002  // Transmit Packet Ready.
+#define USB_CSRL0_RXRDY         0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CSRH0 register.
+//
+//*****************************************************************************
+#define USB_CSRH0_DTWE          0x00000004  // Data Toggle Write Enable.
+#define USB_CSRH0_DT            0x00000002  // Data Toggle.
+#define USB_CSRH0_FLUSH         0x00000001  // Flush FIFO.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_COUNT0 register.
+//
+//*****************************************************************************
+#define USB_COUNT0_COUNT_M      0x0000007F  // Count.
+#define USB_COUNT0_COUNT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TYPE0 register.
+//
+//*****************************************************************************
+#define USB_TYPE0_SPEED_M       0x000000C0  // Operating Speed.
+#define USB_TYPE0_SPEED_FULL    0x00000080  // Full
+#define USB_TYPE0_SPEED_LOW     0x000000C0  // Low
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_NAKLMT register.
+//
+//*****************************************************************************
+#define USB_NAKLMT_NAKLMT_M     0x0000001F  // EP0 NAK Limit.
+#define USB_NAKLMT_NAKLMT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP1 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP1_MULT_M      0x0000F800  // Multiplier.
+#define USB_TXMAXP1_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP1_MULT_S      11
+#define USB_TXMAXP1_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL1 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL1_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL1_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL1_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL1_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL1_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL1_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL1_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL1_ERROR       0x00000004  // Error.
+#define USB_TXCSRL1_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL1_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL1_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH1 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH1_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH1_ISO         0x00000040  // ISO.
+#define USB_TXCSRH1_MODE        0x00000020  // Mode.
+#define USB_TXCSRH1_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH1_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH1_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH1_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH1_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP1 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP1_MULT_M      0x0000F800  // Multiplier.
+#define USB_RXMAXP1_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP1_MULT_S      11
+#define USB_RXMAXP1_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL1 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL1_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL1_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL1_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL1_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL1_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL1_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL1_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL1_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL1_ERROR       0x00000004  // Error.
+#define USB_RXCSRL1_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL1_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH1 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH1_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH1_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH1_ISO         0x00000040  // ISO.
+#define USB_RXCSRH1_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH1_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH1_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH1_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH1_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH1_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH1_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT1 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT1_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT1_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE1 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE1_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE1_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE1_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE1_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE1_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE1_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE1_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE1_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE1_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE1_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE1_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL1
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL1_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL1_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL1_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL1_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE1 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE1_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE1_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE1_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE1_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE1_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE1_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE1_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE1_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE1_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE1_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE1_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL1
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL1_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL1_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL1_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL1_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP2 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP2_MULT_M      0x0000F800  // Multiplier.
+#define USB_TXMAXP2_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP2_MULT_S      11
+#define USB_TXMAXP2_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL2 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL2_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL2_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL2_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL2_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL2_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL2_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL2_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL2_ERROR       0x00000004  // Error.
+#define USB_TXCSRL2_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL2_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL2_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH2 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH2_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH2_ISO         0x00000040  // ISO.
+#define USB_TXCSRH2_MODE        0x00000020  // Mode.
+#define USB_TXCSRH2_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH2_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH2_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH2_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH2_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP2 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP2_MULT_M      0x0000F800  // Multiplier.
+#define USB_RXMAXP2_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP2_MULT_S      11
+#define USB_RXMAXP2_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL2 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL2_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL2_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL2_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL2_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL2_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL2_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL2_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL2_ERROR       0x00000004  // Error.
+#define USB_RXCSRL2_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL2_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL2_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH2 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH2_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH2_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH2_ISO         0x00000040  // ISO.
+#define USB_RXCSRH2_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH2_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH2_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH2_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH2_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH2_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH2_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT2 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT2_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT2_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE2 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE2_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE2_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE2_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE2_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE2_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE2_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE2_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE2_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE2_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE2_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE2_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL2
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL2_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL2_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL2_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL2_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE2 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE2_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE2_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE2_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE2_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE2_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE2_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE2_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE2_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE2_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE2_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE2_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL2
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL2_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL2_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL2_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL2_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP3 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP3_MULT_M      0x0000F800  // Multiplier.
+#define USB_TXMAXP3_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP3_MULT_S      11
+#define USB_TXMAXP3_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL3 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL3_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL3_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL3_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL3_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL3_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL3_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL3_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL3_ERROR       0x00000004  // Error.
+#define USB_TXCSRL3_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL3_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL3_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH3 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH3_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH3_ISO         0x00000040  // ISO.
+#define USB_TXCSRH3_MODE        0x00000020  // Mode.
+#define USB_TXCSRH3_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH3_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH3_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH3_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH3_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP3 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP3_MULT_M      0x0000F800  // Multiplier.
+#define USB_RXMAXP3_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP3_MULT_S      11
+#define USB_RXMAXP3_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL3 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL3_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL3_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL3_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL3_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL3_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL3_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL3_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL3_ERROR       0x00000004  // Error.
+#define USB_RXCSRL3_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL3_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL3_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH3 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH3_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH3_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH3_ISO         0x00000040  // ISO.
+#define USB_RXCSRH3_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH3_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH3_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH3_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH3_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH3_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH3_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT3 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT3_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT3_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE3 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE3_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE3_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE3_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE3_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE3_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE3_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE3_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE3_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE3_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE3_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE3_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL3
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL3_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL3_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL3_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL3_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE3 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE3_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE3_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE3_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE3_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE3_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE3_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE3_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE3_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE3_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE3_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE3_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL3
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL3_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL3_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL3_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL3_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT1
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT1_M       0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT2
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT2_M       0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT2_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT3
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT3_M       0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT3_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXDPKTBUFDIS
+// register.
+//
+//*****************************************************************************
+#define USB_RXDPKTBUFDIS_EP15   0x00008000  // EP15 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP14   0x00004000  // EP14 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP13   0x00002000  // EP13 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP12   0x00001000  // EP12 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP11   0x00000800  // EP11 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP10   0x00000400  // EP10 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP9    0x00000200  // EP9 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP8    0x00000100  // EP8 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP7    0x00000080  // EP7 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP6    0x00000040  // EP6 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP5    0x00000020  // EP5 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP4    0x00000010  // EP4 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP3    0x00000008  // EP3 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP2    0x00000004  // EP2 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP1    0x00000002  // EP1 RX Double-Packet Buffer
+                                            // Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXDPKTBUFDIS
+// register.
+//
+//*****************************************************************************
+#define USB_TXDPKTBUFDIS_EP15   0x00008000  // EP15 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP14   0x00004000  // EP14 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP13   0x00002000  // EP13 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP12   0x00001000  // EP12 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP11   0x00000800  // EP11 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP10   0x00000400  // EP10 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP9    0x00000200  // EP9 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP8    0x00000100  // EP8 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP7    0x00000080  // EP7 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP6    0x00000040  // EP6 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP5    0x00000020  // EP5 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP4    0x00000010  // EP4 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP3    0x00000008  // EP3 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP2    0x00000004  // EP2 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP1    0x00000002  // EP1 TX Double-Packet Buffer
+                                            // Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPC register.
+//
+//*****************************************************************************
+#define USB_EPC_PFLTACT_M       0x00000300  // Power Fault Action.
+#define USB_EPC_PFLTACT_UNCHG   0x00000000  // Unchanged
+#define USB_EPC_PFLTACT_TRIS    0x00000100  // Tristate
+#define USB_EPC_PFLTACT_LOW     0x00000200  // Low
+#define USB_EPC_PFLTACT_HIGH    0x00000300  // High
+#define USB_EPC_PFLTAEN         0x00000040  // Power Fault Action Enable.
+#define USB_EPC_PFLTSEN_HIGH    0x00000020  // Power Fault Sense.
+#define USB_EPC_PFLTEN          0x00000010  // Power Fault Input Enable.
+#define USB_EPC_EPENDE          0x00000004  // EPEN Drive Enable.
+#define USB_EPC_EPEN_M          0x00000003  // External Power Supply Enable
+                                            // Configuration.
+#define USB_EPC_EPEN_LOW        0x00000000  // Power Enable Active Low
+#define USB_EPC_EPEN_HIGH       0x00000001  // Power Enable Active High
+#define USB_EPC_EPEN_VBLOW      0x00000002  // Power Enable High if VBUS Low
+#define USB_EPC_EPEN_VBHIGH     0x00000003  // Power Enable High if VBUS High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCRIS register.
+//
+//*****************************************************************************
+#define USB_EPCRIS_PF           0x00000001  // USB Power Fault Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCIM register.
+//
+//*****************************************************************************
+#define USB_EPCIM_PF            0x00000001  // USB Power Fault Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCISC register.
+//
+//*****************************************************************************
+#define USB_EPCISC_PF           0x00000001  // USB Power Fault Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRRIS register.
+//
+//*****************************************************************************
+#define USB_DRRIS_RESUME        0x00000001  // Resume Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRIM register.
+//
+//*****************************************************************************
+#define USB_DRIM_RESUME         0x00000001  // Resume Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRISC register.
+//
+//*****************************************************************************
+#define USB_DRISC_RESUME        0x00000001  // Resume Interrupt Status and
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_GPCS register.
+//
+//*****************************************************************************
+#define USB_GPCS_DEVMOD         0x00000001  // Device Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VPLEN register.
+//
+//*****************************************************************************
+#define USB_VPLEN_VPLEN_M       0x000000FF  // VBus Pulse Length.
+#define USB_VPLEN_VPLEN_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDC register.
+//
+//*****************************************************************************
+#define USB_VDC_VBDEN           0x00000001  // VBUS Droop Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCRIS register.
+//
+//*****************************************************************************
+#define USB_VDCRIS_VD           0x00000001  // VBUS Droop Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCIM register.
+//
+//*****************************************************************************
+#define USB_VDCIM_VD            0x00000001  // VBUS Droop Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCISC register.
+//
+//*****************************************************************************
+#define USB_VDCISC_VD           0x00000001  // VBUS Droop Interrupt Status and
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IDVRIS register.
+//
+//*****************************************************************************
+#define USB_IDVRIS_ID           0x00000001  // ID Valid Detect Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IDVIM register.
+//
+//*****************************************************************************
+#define USB_IDVIM_ID            0x00000001  // ID Valid Detect Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IDVISC register.
+//
+//*****************************************************************************
+#define USB_IDVISC_ID           0x00000001  // ID Valid Detect Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO4 register.
+//
+//*****************************************************************************
+#define USB_FIFO4_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO4_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO5 register.
+//
+//*****************************************************************************
+#define USB_FIFO5_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO5_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO6 register.
+//
+//*****************************************************************************
+#define USB_FIFO6_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO6_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO7 register.
+//
+//*****************************************************************************
+#define USB_FIFO7_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO7_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO8 register.
+//
+//*****************************************************************************
+#define USB_FIFO8_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO8_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO9 register.
+//
+//*****************************************************************************
+#define USB_FIFO9_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO9_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO10 register.
+//
+//*****************************************************************************
+#define USB_FIFO10_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO10_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO11 register.
+//
+//*****************************************************************************
+#define USB_FIFO11_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO11_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO12 register.
+//
+//*****************************************************************************
+#define USB_FIFO12_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO12_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO13 register.
+//
+//*****************************************************************************
+#define USB_FIFO13_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO13_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO14 register.
+//
+//*****************************************************************************
+#define USB_FIFO14_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO14_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO15 register.
+//
+//*****************************************************************************
+#define USB_FIFO15_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO15_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR4_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR4_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR4_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR4_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR4_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT4
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT4_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT4_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR4_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR4_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR4_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR4_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR4_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT4
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT4_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT4_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR5_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR5_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR5_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR5_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR5_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT5
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT5_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT5_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR5_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR5_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR5_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR5_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR5_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT5
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT5_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT5_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR6_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR6_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR6_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR6_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR6_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT6
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT6_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT6_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR6_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR6_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR6_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR6_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR6_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT6
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT6_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT6_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR7_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR7_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR7_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR7_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR7_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT7
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT7_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT7_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR7_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR7_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR7_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR7_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR7_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT7
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT7_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT7_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR8_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR8_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR8_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR8_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR8_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT8
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT8_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT8_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR8_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR8_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR8_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR8_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR8_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT8
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT8_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT8_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR9_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR9_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR9_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR9_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR9_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT9
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT9_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT9_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR9_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR9_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR9_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR9_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR9_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT9
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT9_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT9_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR10_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR10_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR10_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR10_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR10_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT10
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT10_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT10_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR10_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR10_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR10_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR10_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR10_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT10
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT10_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT10_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR11_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR11_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR11_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR11_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR11_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT11
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT11_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT11_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR11_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR11_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR11_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR11_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR11_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT11
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT11_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT11_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR12_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR12_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR12_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR12_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR12_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT12
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT12_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT12_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR12_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR12_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR12_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR12_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR12_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT12
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT12_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT12_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR13_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR13_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR13_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR13_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR13_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT13
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT13_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT13_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR13_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR13_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR13_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR13_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR13_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT13
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT13_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT13_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR14_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR14_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR14_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR14_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR14_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT14
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT14_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT14_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR14_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR14_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR14_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR14_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR14_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT14
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT14_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT14_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR15_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR15_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR15_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR15_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR15_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT15
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT15_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT15_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR15_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR15_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR15_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR15_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR15_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT15
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT15_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT15_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP4 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP4_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP4_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL4 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL4_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL4_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL4_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL4_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL4_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL4_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL4_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL4_ERROR       0x00000004  // Error.
+#define USB_TXCSRL4_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL4_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL4_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH4 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH4_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH4_ISO         0x00000040  // ISO.
+#define USB_TXCSRH4_MODE        0x00000020  // Mode.
+#define USB_TXCSRH4_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH4_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH4_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH4_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH4_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP4 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP4_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP4_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL4 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL4_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL4_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL4_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL4_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL4_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL4_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL4_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL4_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL4_ERROR       0x00000004  // Error.
+#define USB_RXCSRL4_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL4_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH4 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH4_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH4_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH4_ISO         0x00000040  // ISO.
+#define USB_RXCSRH4_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH4_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH4_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH4_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH4_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH4_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH4_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT4 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT4_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT4_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE4 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE4_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE4_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE4_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE4_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE4_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE4_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE4_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE4_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE4_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE4_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE4_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL4
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL4_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL4_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL4_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL4_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE4 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE4_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE4_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE4_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE4_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE4_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE4_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE4_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE4_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE4_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE4_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE4_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL4
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL4_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL4_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL4_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL4_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP5 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP5_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP5_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL5 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL5_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL5_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL5_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL5_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL5_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL5_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL5_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL5_ERROR       0x00000004  // Error.
+#define USB_TXCSRL5_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL5_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL5_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH5 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH5_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH5_ISO         0x00000040  // ISO.
+#define USB_TXCSRH5_MODE        0x00000020  // Mode.
+#define USB_TXCSRH5_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH5_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH5_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH5_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH5_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP5 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP5_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP5_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL5 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL5_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL5_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL5_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL5_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL5_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL5_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL5_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL5_ERROR       0x00000004  // Error.
+#define USB_RXCSRL5_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL5_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL5_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH5 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH5_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH5_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH5_ISO         0x00000040  // ISO.
+#define USB_RXCSRH5_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH5_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH5_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH5_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH5_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH5_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH5_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT5 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT5_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT5_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE5 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE5_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE5_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE5_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE5_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE5_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE5_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE5_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE5_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE5_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE5_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE5_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL5
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL5_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL5_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL5_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL5_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE5 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE5_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE5_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE5_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE5_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE5_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE5_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE5_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE5_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE5_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE5_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE5_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL5
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL5_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL5_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL5_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL5_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP6 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP6_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP6_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL6 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL6_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL6_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL6_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL6_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL6_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL6_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL6_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL6_ERROR       0x00000004  // Error.
+#define USB_TXCSRL6_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL6_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL6_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH6 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH6_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH6_ISO         0x00000040  // ISO.
+#define USB_TXCSRH6_MODE        0x00000020  // Mode.
+#define USB_TXCSRH6_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH6_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH6_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH6_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH6_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP6 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP6_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP6_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL6 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL6_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL6_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL6_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL6_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL6_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL6_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL6_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL6_ERROR       0x00000004  // Error.
+#define USB_RXCSRL6_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL6_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL6_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH6 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH6_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH6_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH6_ISO         0x00000040  // ISO.
+#define USB_RXCSRH6_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH6_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH6_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH6_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH6_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH6_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH6_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT6 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT6_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT6_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE6 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE6_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE6_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE6_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE6_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE6_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE6_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE6_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE6_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE6_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE6_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE6_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL6
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL6_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL6_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL6_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL6_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE6 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE6_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE6_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE6_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE6_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE6_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE6_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE6_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE6_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE6_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE6_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE6_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL6
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL6_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL6_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL6_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL6_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP7 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP7_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP7_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL7 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL7_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL7_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL7_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL7_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL7_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL7_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL7_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL7_ERROR       0x00000004  // Error.
+#define USB_TXCSRL7_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL7_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL7_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH7 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH7_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH7_ISO         0x00000040  // ISO.
+#define USB_TXCSRH7_MODE        0x00000020  // Mode.
+#define USB_TXCSRH7_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH7_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH7_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH7_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH7_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP7 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP7_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP7_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL7 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL7_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL7_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL7_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL7_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL7_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL7_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL7_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL7_ERROR       0x00000004  // Error.
+#define USB_RXCSRL7_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL7_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL7_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH7 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH7_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH7_ISO         0x00000040  // ISO.
+#define USB_RXCSRH7_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH7_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH7_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH7_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH7_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH7_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH7_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH7_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT7 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT7_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT7_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE7 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE7_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE7_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE7_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE7_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE7_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE7_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE7_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE7_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE7_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE7_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE7_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL7
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL7_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL7_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL7_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL7_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE7 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE7_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE7_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE7_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE7_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE7_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE7_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE7_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE7_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE7_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE7_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE7_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL7
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL7_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL7_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL7_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL7_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP8 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP8_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP8_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL8 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL8_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL8_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL8_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL8_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL8_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL8_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL8_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL8_ERROR       0x00000004  // Error.
+#define USB_TXCSRL8_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL8_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL8_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH8 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH8_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH8_ISO         0x00000040  // ISO.
+#define USB_TXCSRH8_MODE        0x00000020  // Mode.
+#define USB_TXCSRH8_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH8_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH8_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH8_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH8_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP8 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP8_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP8_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL8 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL8_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL8_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL8_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL8_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL8_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL8_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL8_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL8_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL8_ERROR       0x00000004  // Error.
+#define USB_RXCSRL8_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL8_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH8 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH8_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH8_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH8_ISO         0x00000040  // ISO.
+#define USB_RXCSRH8_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH8_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH8_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH8_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH8_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH8_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH8_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT8 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT8_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT8_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE8 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE8_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE8_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE8_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE8_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE8_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE8_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE8_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE8_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE8_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE8_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE8_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL8
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL8_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL8_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL8_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL8_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE8 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE8_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE8_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE8_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE8_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE8_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE8_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE8_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE8_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE8_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE8_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE8_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL8
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL8_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL8_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL8_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL8_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP9 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP9_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP9_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL9 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL9_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL9_NAKTO       0x00000080  // NAK Timeout
+#define USB_TXCSRL9_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL9_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL9_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL9_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL9_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL9_ERROR       0x00000004  // Error.
+#define USB_TXCSRL9_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL9_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL9_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH9 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH9_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH9_ISO         0x00000040  // ISO.
+#define USB_TXCSRH9_MODE        0x00000020  // Mode.
+#define USB_TXCSRH9_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH9_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH9_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH9_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH9_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP9 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP9_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP9_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL9 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL9_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL9_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL9_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL9_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL9_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL9_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL9_NAKTO       0x00000008  // NAK Timeout.
+#define USB_RXCSRL9_ERROR       0x00000004  // Error.
+#define USB_RXCSRL9_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL9_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL9_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH9 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH9_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH9_ISO         0x00000040  // ISO.
+#define USB_RXCSRH9_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH9_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH9_PIDERR      0x00000010  // PID Error.
+#define USB_RXCSRH9_DISNYET     0x00000010  // Disable NYET
+#define USB_RXCSRH9_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH9_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH9_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH9_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT9 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT9_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT9_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE9 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE9_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE9_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE9_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE9_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE9_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE9_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE9_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE9_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE9_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE9_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE9_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL9
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL9_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL9_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL9_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL9_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE9 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE9_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE9_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE9_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE9_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE9_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE9_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE9_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE9_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE9_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE9_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE9_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL9
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL9_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL9_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL9_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL9_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP10 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP10_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP10_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL10 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL10_NAKTO      0x00000080  // NAK Timeout
+#define USB_TXCSRL10_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL10_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL10_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL10_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL10_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL10_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL10_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL10_ERROR      0x00000004  // Error.
+#define USB_TXCSRL10_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL10_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH10 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH10_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH10_ISO        0x00000040  // ISO.
+#define USB_TXCSRH10_MODE       0x00000020  // Mode.
+#define USB_TXCSRH10_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH10_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH10_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH10_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH10_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP10 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP10_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP10_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL10 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL10_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL10_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL10_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL10_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL10_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL10_NAKTO      0x00000008  // NAK Timeout.
+#define USB_RXCSRL10_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL10_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL10_ERROR      0x00000004  // Error.
+#define USB_RXCSRL10_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL10_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH10 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH10_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH10_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH10_ISO        0x00000040  // ISO.
+#define USB_RXCSRH10_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH10_PIDERR     0x00000010  // PID Error.
+#define USB_RXCSRH10_DISNYET    0x00000010  // Disable NYET
+#define USB_RXCSRH10_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH10_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH10_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH10_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT10
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT10_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT10_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE10 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE10_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE10_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE10_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE10_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE10_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE10_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE10_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE10_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE10_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE10_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE10_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL10
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL10_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL10_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL10_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL10_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE10 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE10_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE10_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE10_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE10_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE10_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE10_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE10_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE10_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE10_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE10_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE10_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL10
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL10_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL10_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL10_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL10_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP11 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP11_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP11_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL11 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL11_NAKTO      0x00000080  // NAK Timeout
+#define USB_TXCSRL11_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL11_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL11_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL11_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL11_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL11_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL11_ERROR      0x00000004  // Error.
+#define USB_TXCSRL11_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL11_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL11_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH11 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH11_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH11_ISO        0x00000040  // ISO.
+#define USB_TXCSRH11_MODE       0x00000020  // Mode.
+#define USB_TXCSRH11_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH11_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH11_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH11_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH11_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP11 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP11_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP11_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL11 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL11_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL11_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL11_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL11_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL11_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL11_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL11_NAKTO      0x00000008  // NAK Timeout.
+#define USB_RXCSRL11_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL11_ERROR      0x00000004  // Error.
+#define USB_RXCSRL11_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL11_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH11 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH11_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH11_ISO        0x00000040  // ISO.
+#define USB_RXCSRH11_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH11_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH11_DISNYET    0x00000010  // Disable NYET
+#define USB_RXCSRH11_PIDERR     0x00000010  // PID Error.
+#define USB_RXCSRH11_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH11_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH11_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH11_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT11
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT11_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT11_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE11 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE11_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE11_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE11_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE11_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE11_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE11_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE11_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE11_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE11_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE11_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE11_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL11
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL11_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL11_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL11_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL11_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE11 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE11_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE11_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE11_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE11_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE11_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE11_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE11_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE11_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE11_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE11_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE11_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL11
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL11_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL11_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL11_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL11_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP12 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP12_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP12_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL12 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL12_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL12_NAKTO      0x00000080  // NAK Timeout
+#define USB_TXCSRL12_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL12_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL12_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL12_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL12_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL12_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL12_ERROR      0x00000004  // Error.
+#define USB_TXCSRL12_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL12_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH12 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH12_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH12_ISO        0x00000040  // ISO.
+#define USB_TXCSRH12_MODE       0x00000020  // Mode.
+#define USB_TXCSRH12_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH12_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH12_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH12_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH12_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP12 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP12_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP12_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL12 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL12_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL12_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL12_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL12_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL12_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL12_NAKTO      0x00000008  // NAK Timeout.
+#define USB_RXCSRL12_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL12_ERROR      0x00000004  // Error.
+#define USB_RXCSRL12_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL12_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL12_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH12 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH12_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH12_ISO        0x00000040  // ISO.
+#define USB_RXCSRH12_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH12_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH12_PIDERR     0x00000010  // PID Error.
+#define USB_RXCSRH12_DISNYET    0x00000010  // Disable NYET
+#define USB_RXCSRH12_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH12_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH12_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH12_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT12
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT12_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT12_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE12 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE12_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE12_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE12_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE12_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE12_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE12_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE12_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE12_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE12_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE12_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE12_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL12
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL12_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL12_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL12_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL12_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE12 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE12_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE12_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE12_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE12_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE12_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE12_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE12_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE12_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE12_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE12_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE12_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL12
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL12_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL12_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL12_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL12_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP13 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP13_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP13_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL13 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL13_NAKTO      0x00000080  // NAK Timeout
+#define USB_TXCSRL13_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL13_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL13_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL13_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL13_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL13_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL13_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL13_ERROR      0x00000004  // Error.
+#define USB_TXCSRL13_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL13_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH13 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH13_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH13_ISO        0x00000040  // ISO.
+#define USB_TXCSRH13_MODE       0x00000020  // Mode.
+#define USB_TXCSRH13_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH13_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH13_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH13_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH13_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP13 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP13_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP13_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL13 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL13_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL13_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL13_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL13_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL13_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL13_NAKTO      0x00000008  // NAK Timeout.
+#define USB_RXCSRL13_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL13_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL13_ERROR      0x00000004  // Error.
+#define USB_RXCSRL13_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL13_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH13 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH13_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH13_ISO        0x00000040  // ISO.
+#define USB_RXCSRH13_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH13_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH13_DISNYET    0x00000010  // Disable NYET
+#define USB_RXCSRH13_PIDERR     0x00000010  // PID Error.
+#define USB_RXCSRH13_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH13_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH13_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH13_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT13
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT13_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT13_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE13 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE13_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE13_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE13_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE13_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE13_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE13_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE13_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE13_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE13_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE13_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE13_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL13
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL13_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL13_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL13_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL13_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE13 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE13_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE13_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE13_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE13_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE13_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE13_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE13_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE13_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE13_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE13_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE13_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL13
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL13_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL13_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL13_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL13_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP14 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP14_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP14_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL14 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL14_NAKTO      0x00000080  // NAK Timeout
+#define USB_TXCSRL14_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL14_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL14_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL14_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL14_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL14_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL14_ERROR      0x00000004  // Error.
+#define USB_TXCSRL14_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL14_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL14_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH14 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH14_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH14_ISO        0x00000040  // ISO.
+#define USB_TXCSRH14_MODE       0x00000020  // Mode.
+#define USB_TXCSRH14_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH14_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH14_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH14_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH14_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP14 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP14_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP14_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL14 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL14_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL14_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL14_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL14_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL14_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL14_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL14_NAKTO      0x00000008  // NAK Timeout.
+#define USB_RXCSRL14_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL14_ERROR      0x00000004  // Error.
+#define USB_RXCSRL14_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL14_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH14 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH14_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH14_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH14_ISO        0x00000040  // ISO.
+#define USB_RXCSRH14_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH14_PIDERR     0x00000010  // PID Error.
+#define USB_RXCSRH14_DISNYET    0x00000010  // Disable NYET
+#define USB_RXCSRH14_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH14_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH14_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH14_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT14
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT14_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT14_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE14 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE14_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE14_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE14_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE14_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE14_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE14_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE14_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE14_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE14_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE14_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE14_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL14
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL14_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL14_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL14_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL14_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE14 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE14_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE14_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE14_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE14_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE14_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE14_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE14_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE14_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE14_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE14_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE14_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL14
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL14_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL14_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL14_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL14_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP15 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP15_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP15_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL15 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL15_NAKTO      0x00000080  // NAK Timeout
+#define USB_TXCSRL15_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL15_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL15_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL15_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL15_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL15_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL15_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL15_ERROR      0x00000004  // Error.
+#define USB_TXCSRL15_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL15_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH15 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH15_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH15_ISO        0x00000040  // ISO.
+#define USB_TXCSRH15_MODE       0x00000020  // Mode.
+#define USB_TXCSRH15_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH15_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH15_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH15_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH15_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP15 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP15_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP15_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL15 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL15_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL15_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL15_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL15_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL15_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL15_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL15_NAKTO      0x00000008  // NAK Timeout.
+#define USB_RXCSRL15_ERROR      0x00000004  // Error.
+#define USB_RXCSRL15_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL15_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL15_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH15 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH15_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH15_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH15_ISO        0x00000040  // ISO.
+#define USB_RXCSRH15_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH15_PIDERR     0x00000010  // PID Error.
+#define USB_RXCSRH15_DISNYET    0x00000010  // Disable NYET
+#define USB_RXCSRH15_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH15_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH15_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH15_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT15
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT15_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT15_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE15 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE15_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE15_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE15_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE15_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE15_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE15_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE15_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE15_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE15_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE15_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE15_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL15
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL15_TXPOLL_M \
+                                0x000000FF  // TX Polling
+#define USB_TXINTERVAL15_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_TXINTERVAL15_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL15_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE15 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE15_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE15_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE15_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE15_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE15_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE15_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE15_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE15_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE15_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE15_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE15_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL15
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL15_TXPOLL_M \
+                                0x000000FF  // RX Polling
+#define USB_RXINTERVAL15_NAKLMT_M \
+                                0x000000FF  // NAK Limit.
+#define USB_RXINTERVAL15_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL15_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT4
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT4_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT4_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT5
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT5_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT5_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT6
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT6_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT6_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT7
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT7_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT7_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT8
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT8_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT8_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT9
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT9_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT9_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT10
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT10_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT10_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT11
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT11_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT11_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT12
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT12_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT12_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT13
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT13_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT13_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT14
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT14_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT14_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT15
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT15_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT15_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPS register.
+//
+//*****************************************************************************
+#define USB_EPS_DMAC_M          0x00000F00  // DMA C Select.
+#define USB_EPS_DMAB_M          0x000000F0  // DMA B Select.
+#define USB_EPS_DMAA_M          0x0000000F  // DMA A Select.
+#define USB_EPS_DMAC_S          8
+#define USB_EPS_DMAB_S          4
+#define USB_EPS_DMAA_S          0
+
+#endif // __HW_USB_H__


Property changes on: trunk/src/platform/lm3s/hw_usb.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/hw_watchdog.h
===================================================================
--- trunk/src/platform/lm3s/hw_watchdog.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/hw_watchdog.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,178 @@
+//*****************************************************************************
+//
+// hw_watchdog.h - Macros used when accessing the Watchdog Timer hardware.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_WATCHDOG_H__
+#define __HW_WATCHDOG_H__
+
+//*****************************************************************************
+//
+// The following are defines for the Watchdog Timer register offsets.
+//
+//*****************************************************************************
+#define WDT_O_LOAD              0x00000000  // Load register
+#define WDT_O_VALUE             0x00000004  // Current value register
+#define WDT_O_CTL               0x00000008  // Control register
+#define WDT_O_ICR               0x0000000C  // Interrupt clear register
+#define WDT_O_RIS               0x00000010  // Raw interrupt status register
+#define WDT_O_MIS               0x00000014  // Masked interrupt status register
+#define WDT_O_TEST              0x00000418  // Test register
+#define WDT_O_LOCK              0x00000C00  // Lock register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_CTL register.
+//
+//*****************************************************************************
+#define WDT_CTL_RESEN           0x00000002  // Enable reset output
+#define WDT_CTL_INTEN           0x00000001  // Enable the WDT counter and int
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_ISR, WDT_RIS, and
+// WDT_MIS registers.
+//
+//*****************************************************************************
+#define WDT_INT_TIMEOUT         0x00000001  // Watchdog timer expired
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_TEST register.
+//
+//*****************************************************************************
+#define WDT_TEST_STALL          0x00000100  // Watchdog stall enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_LOCK register.
+//
+//*****************************************************************************
+#define WDT_LOCK_M              0xFFFFFFFF  // Watchdog Lock.
+#define WDT_LOCK_UNLOCK         0x1ACCE551  // Unlocks the watchdog timer
+#define WDT_LOCK_LOCKED         0x00000001  // Watchdog timer is locked
+#define WDT_LOCK_UNLOCKED       0x00000000  // Watchdog timer is unlocked
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOAD register.
+//
+//*****************************************************************************
+#define WDT_LOAD_M              0xFFFFFFFF  // Watchdog Load Value.
+#define WDT_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_VALUE register.
+//
+//*****************************************************************************
+#define WDT_VALUE_M             0xFFFFFFFF  // Watchdog Value.
+#define WDT_VALUE_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_ICR register.
+//
+//*****************************************************************************
+#define WDT_ICR_M               0xFFFFFFFF  // Watchdog Interrupt Clear.
+#define WDT_ICR_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_RIS register.
+//
+//*****************************************************************************
+#define WDT_RIS_WDTRIS          0x00000001  // Watchdog Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_MIS register.
+//
+//*****************************************************************************
+#define WDT_MIS_WDTMIS          0x00000001  // Watchdog Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the Watchdog Timer register
+// offsets.
+//
+//*****************************************************************************
+#define WDT_O_PeriphID4         0x00000FD0
+#define WDT_O_PeriphID5         0x00000FD4
+#define WDT_O_PeriphID6         0x00000FD8
+#define WDT_O_PeriphID7         0x00000FDC
+#define WDT_O_PeriphID0         0x00000FE0
+#define WDT_O_PeriphID1         0x00000FE4
+#define WDT_O_PeriphID2         0x00000FE8
+#define WDT_O_PeriphID3         0x00000FEC
+#define WDT_O_PCellID0          0x00000FF0
+#define WDT_O_PCellID1          0x00000FF4
+#define WDT_O_PCellID2          0x00000FF8
+#define WDT_O_PCellID3          0x00000FFC
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the WDT_TEST
+// register.
+//
+//*****************************************************************************
+#define WDT_TEST_STALL_EN       0x00000100  // Watchdog stall enable
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the reset values for the WDT
+// registers.
+//
+//*****************************************************************************
+#define WDT_RV_VALUE            0xFFFFFFFF  // Current value register
+#define WDT_RV_LOAD             0xFFFFFFFF  // Load register
+#define WDT_RV_PCellID1         0x000000F0
+#define WDT_RV_PCellID3         0x000000B1
+#define WDT_RV_PeriphID1        0x00000018
+#define WDT_RV_PeriphID2        0x00000018
+#define WDT_RV_PCellID0         0x0000000D
+#define WDT_RV_PCellID2         0x00000005
+#define WDT_RV_PeriphID0        0x00000005
+#define WDT_RV_PeriphID3        0x00000001
+#define WDT_RV_PeriphID5        0x00000000
+#define WDT_RV_RIS              0x00000000  // Raw interrupt status register
+#define WDT_RV_CTL              0x00000000  // Control register
+#define WDT_RV_PeriphID4        0x00000000
+#define WDT_RV_PeriphID6        0x00000000
+#define WDT_RV_PeriphID7        0x00000000
+#define WDT_RV_LOCK             0x00000000  // Lock register
+#define WDT_RV_MIS              0x00000000  // Masked interrupt status register
+
+#endif
+
+#endif // __HW_WATCHDOG_H__


Property changes on: trunk/src/platform/lm3s/hw_watchdog.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/interrupt.c
===================================================================
--- trunk/src/platform/lm3s/interrupt.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/interrupt.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,550 +1,550 @@
-//*****************************************************************************
-//
-// interrupt.c - Driver for the NVIC Interrupt Controller.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup interrupt_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_nvic.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;cpu.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-
-//*****************************************************************************
-//
-// This is a mapping between priority grouping encodings and the number of
-// preemption priority bits.
-//
-//*****************************************************************************
-static const unsigned long g_pulPriority[] =
-{
-    NVIC_APINT_PRIGROUP_0_8, NVIC_APINT_PRIGROUP_1_7, NVIC_APINT_PRIGROUP_2_6,
-    NVIC_APINT_PRIGROUP_3_5, NVIC_APINT_PRIGROUP_4_4, NVIC_APINT_PRIGROUP_5_3,
-    NVIC_APINT_PRIGROUP_6_2, NVIC_APINT_PRIGROUP_7_1
-};
-
-//*****************************************************************************
-//
-// This is a mapping between interrupt number and the register that contains
-// the priority encoding for that interrupt.
-//
-//*****************************************************************************
-static const unsigned long g_pulRegs[] =
-{
-    0, NVIC_SYS_PRI1, NVIC_SYS_PRI2, NVIC_SYS_PRI3, NVIC_PRI0, NVIC_PRI1,
-    NVIC_PRI2, NVIC_PRI3, NVIC_PRI4, NVIC_PRI5, NVIC_PRI6, NVIC_PRI7,
-    NVIC_PRI8, NVIC_PRI9, NVIC_PRI10, NVIC_PRI11
-};
-
-//*****************************************************************************
-//
-//! \internal
-//! The default interrupt handler.
-//!
-//! This is the default interrupt handler for all interrupts.  It simply loops
-//! forever so that the system state is preserved for observation by a
-//! debugger.  Since interrupts should be disabled before unregistering the
-//! corresponding handler, this should never be called.
-//!
-//! \return None.
-//
-//*****************************************************************************
-static void
-IntDefaultHandler(void)
-{
-    //
-    // Go into an infinite loop.
-    //
-    while(1)
-    {
-    }
-}
-
-//*****************************************************************************
-//
-// The processor vector table.
-//
-// This contains a list of the handlers for the various interrupt sources in
-// the system.  The layout of this list is defined by the hardware; assertion
-// of an interrupt causes the processor to start executing directly at the
-// address given in the corresponding location in this list.
-//
-//*****************************************************************************
-#if defined(ewarm)
-static __no_init void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void) @ &quot;VTABLE&quot;;
-#elif defined(sourcerygxx)
-static __attribute__((section(&quot;.cs3.region-head.ram&quot;)))
-void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void);
-#else
-static __attribute__((section(&quot;vtable&quot;)))
-void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void);
-#endif
-
-//*****************************************************************************
-//
-//! Enables the processor interrupt.
-//!
-//! Allows the processor to respond to interrupts.  This does not affect the
-//! set of interrupts enabled in the interrupt controller; it just gates the
-//! single interrupt from the controller to the processor.
-//!
-//! \note Previously, this function had no return value.  As such, it was
-//! possible to include &lt;tt&gt;interrupt.h&lt;/tt&gt; and call this function without
-//! having included &lt;tt&gt;hw_types.h&lt;/tt&gt;.  Now that the return is a
-//! &lt;tt&gt;tBoolean&lt;/tt&gt;, a compiler error will occur in this case.  The solution
-//! is to include &lt;tt&gt;hw_types.h&lt;/tt&gt; before including &lt;tt&gt;interrupt.h&lt;/tt&gt;.
-//!
-//! \return Returns \b true if interrupts were disabled when the function was
-//! called or \b false if they were initially enabled.
-//
-//*****************************************************************************
-tBoolean
-IntMasterEnable(void)
-{
-    //
-    // Enable processor interrupts.
-    //
-    return(CPUcpsie());
-}
-
-//*****************************************************************************
-//
-//! Disables the processor interrupt.
-//!
-//! Prevents the processor from receiving interrupts.  This does not affect the
-//! set of interrupts enabled in the interrupt controller; it just gates the
-//! single interrupt from the controller to the processor.
-//!
-//! \note Previously, this function had no return value.  As such, it was
-//! possible to include &lt;tt&gt;interrupt.h&lt;/tt&gt; and call this function without
-//! having included &lt;tt&gt;hw_types.h&lt;/tt&gt;.  Now that the return is a
-//! &lt;tt&gt;tBoolean&lt;/tt&gt;, a compiler error will occur in this case.  The solution
-//! is to include &lt;tt&gt;hw_types.h&lt;/tt&gt; before including &lt;tt&gt;interrupt.h&lt;/tt&gt;.
-//!
-//! \return Returns \b true if interrupts were already disabled when the
-//! function was called or \b false if they were initially enabled.
-//
-//*****************************************************************************
-tBoolean
-IntMasterDisable(void)
-{
-    //
-    // Disable processor interrupts.
-    //
-    return(CPUcpsid());
-}
-
-//*****************************************************************************
-//
-//! Registers a function to be called when an interrupt occurs.
-//!
-//! \param ulInterrupt specifies the interrupt in question.
-//! \param pfnHandler is a pointer to the function to be called.
-//!
-//! This function is used to specify the handler function to be called when the
-//! given interrupt is asserted to the processor.  When the interrupt occurs,
-//! if it is enabled (via IntEnable()), the handler function will be called in
-//! interrupt context.  Since the handler function can preempt other code, care
-//! must be taken to protect memory or peripherals that are accessed by the
-//! handler and other non-handler code.
-//!
-//! \note The use of this function (directly or indirectly via a peripheral
-//! driver interrupt register function) moves the interrupt vector table from
-//! flash to SRAM.  Therefore, care must be taken when linking the application
-//! to ensure that the SRAM vector table is located at the beginning of SRAM;
-//! otherwise NVIC will not look in the correct portion of memory for the
-//! vector table (it requires the vector table be on a 1 kB memory alignment).
-//! Normally, the SRAM vector table is so placed via the use of linker scripts;
-//! some tool chains, such as the evaluation version of RV-MDK, do not support
-//! linker scripts and therefore will not produce a valid executable.  See the
-//! discussion of compile-time versus run-time interrupt handler registration
-//! in the introduction to this chapter.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-IntRegister(unsigned long ulInterrupt, void (*pfnHandler)(void))
-{
-    unsigned long ulIdx, ulValue;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
-
-    //
-    // Make sure that the RAM vector table is correctly aligned.
-    //
-    ASSERT(((unsigned long)g_pfnRAMVectors &amp; 0x000003ff) == 0);
-
-    //
-    // See if the RAM vector table has been initialized.
-    //
-    if(HWREG(NVIC_VTABLE) != (unsigned long)g_pfnRAMVectors)
-    {
-        //
-        // Copy the vector table from the beginning of FLASH to the RAM vector
-        // table.
-        //
-        ulValue = HWREG(NVIC_VTABLE);
-        for(ulIdx = 0; ulIdx &lt; NUM_INTERRUPTS; ulIdx++)
-        {
-            g_pfnRAMVectors[ulIdx] = (void (*)(void))HWREG((ulIdx * 4) +
-                                                     ulValue);
-        }
-
-        //
-        // Point NVIC at the RAM vector table.
-        //
-        HWREG(NVIC_VTABLE) = (unsigned long)g_pfnRAMVectors;
-    }
-
-    //
-    // Save the interrupt handler.
-    //
-    g_pfnRAMVectors[ulInterrupt] = pfnHandler;
-}
-
-//*****************************************************************************
-//
-//! Unregisters the function to be called when an interrupt occurs.
-//!
-//! \param ulInterrupt specifies the interrupt in question.
-//!
-//! This function is used to indicate that no handler should be called when the
-//! given interrupt is asserted to the processor.  The interrupt source will be
-//! automatically disabled (via IntDisable()) if necessary.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-IntUnregister(unsigned long ulInterrupt)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
-
-    //
-    // Reset the interrupt handler.
-    //
-    g_pfnRAMVectors[ulInterrupt] = IntDefaultHandler;
-}
-
-//*****************************************************************************
-//
-//! Sets the priority grouping of the interrupt controller.
-//!
-//! \param ulBits specifies the number of bits of preemptable priority.
-//!
-//! This function specifies the split between preemptable priority levels and
-//! subpriority levels in the interrupt priority specification.  The range of
-//! the grouping values are dependent upon the hardware implementation; on
-//! the Stellaris family, three bits are available for hardware interrupt
-//! prioritization and therefore priority grouping values of three through
-//! seven have the same effect.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-IntPriorityGroupingSet(unsigned long ulBits)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBits &lt; NUM_PRIORITY);
-
-    //
-    // Set the priority grouping.
-    //
-    HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | g_pulPriority[ulBits];
-}
-
-//*****************************************************************************
-//
-//! Gets the priority grouping of the interrupt controller.
-//!
-//! This function returns the split between preemptable priority levels and
-//! subpriority levels in the interrupt priority specification.
-//!
-//! \return The number of bits of preemptable priority.
-//
-//*****************************************************************************
-unsigned long
-IntPriorityGroupingGet(void)
-{
-    unsigned long ulLoop, ulValue;
-
-    //
-    // Read the priority grouping.
-    //
-    ulValue = HWREG(NVIC_APINT) &amp; NVIC_APINT_PRIGROUP_M;
-
-    //
-    // Loop through the priority grouping values.
-    //
-    for(ulLoop = 0; ulLoop &lt; NUM_PRIORITY; ulLoop++)
-    {
-        //
-        // Stop looping if this value matches.
-        //
-        if(ulValue == g_pulPriority[ulLoop])
-        {
-            break;
-        }
-    }
-
-    //
-    // Return the number of priority bits.
-    //
-    return(ulLoop);
-}
-
-//*****************************************************************************
-//
-//! Sets the priority of an interrupt.
-//!
-//! \param ulInterrupt specifies the interrupt in question.
-//! \param ucPriority specifies the priority of the interrupt.
-//!
-//! This function is used to set the priority of an interrupt.  When multiple
-//! interrupts are asserted simultaneously, the ones with the highest priority
-//! are processed before the lower priority interrupts.  Smaller numbers
-//! correspond to higher interrupt priorities; priority 0 is the highest
-//! interrupt priority.
-//!
-//! The hardware priority mechanism will only look at the upper N bits of the
-//! priority level (where N is 3 for the Stellaris family), so any
-//! prioritization must be performed in those bits.  The remaining bits can be
-//! used to sub-prioritize the interrupt sources, and may be used by the
-//! hardware priority mechanism on a future part.  This arrangement allows
-//! priorities to migrate to different NVIC implementations without changing
-//! the gross prioritization of the interrupts.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-IntPrioritySet(unsigned long ulInterrupt, unsigned char ucPriority)
-{
-    unsigned long ulTemp;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulInterrupt &gt;= 4) &amp;&amp; (ulInterrupt &lt; NUM_INTERRUPTS));
-
-    //
-    // Set the interrupt priority.
-    //
-    ulTemp = HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]);
-    ulTemp &amp;= ~(0xFF &lt;&lt; (8 * (ulInterrupt &amp; 3)));
-    ulTemp |= ucPriority &lt;&lt; (8 * (ulInterrupt &amp; 3));
-    HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]) = ulTemp;
-}
-
-//*****************************************************************************
-//
-//! Gets the priority of an interrupt.
-//!
-//! \param ulInterrupt specifies the interrupt in question.
-//!
-//! This function gets the priority of an interrupt.  See IntPrioritySet() for
-//! a definition of the priority value.
-//!
-//! \return Returns the interrupt priority, or -1 if an invalid interrupt was
-//! specified.
-//
-//*****************************************************************************
-long
-IntPriorityGet(unsigned long ulInterrupt)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulInterrupt &gt;= 4) &amp;&amp; (ulInterrupt &lt; NUM_INTERRUPTS));
-
-    //
-    // Return the interrupt priority.
-    //
-    return((HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]) &gt;&gt; (8 * (ulInterrupt &amp; 3))) &amp;
-           0xFF);
-}
-
-//*****************************************************************************
-//
-//! Enables an interrupt.
-//!
-//! \param ulInterrupt specifies the interrupt to be enabled.
-//!
-//! The specified interrupt is enabled in the interrupt controller.  Other
-//! enables for the interrupt (such as at the peripheral level) are unaffected
-//! by this function.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-IntEnable(unsigned long ulInterrupt)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
-
-    //
-    // Determine the interrupt to enable.
-    //
-    if(ulInterrupt == FAULT_MPU)
-    {
-        //
-        // Enable the MemManage interrupt.
-        //
-        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_MEM;
-    }
-    else if(ulInterrupt == FAULT_BUS)
-    {
-        //
-        // Enable the bus fault interrupt.
-        //
-        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_BUS;
-    }
-    else if(ulInterrupt == FAULT_USAGE)
-    {
-        //
-        // Enable the usage fault interrupt.
-        //
-        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_USAGE;
-    }
-    else if(ulInterrupt == FAULT_SYSTICK)
-    {
-        //
-        // Enable the System Tick interrupt.
-        //
-        HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
-    }
-    else if((ulInterrupt &gt;= 16) &amp;&amp; (ulInterrupt &lt;= 47))
-    {
-        //
-        // Enable the general interrupt.
-        //
-        HWREG(NVIC_EN0) = 1 &lt;&lt; (ulInterrupt - 16);
-    }
-    else if(ulInterrupt &gt;= 48)
-    {
-        //
-        // Enable the general interrupt.
-        //
-        HWREG(NVIC_EN1) = 1 &lt;&lt; (ulInterrupt - 48);
-    }
-}
-
-//*****************************************************************************
-//
-//! Disables an interrupt.
-//!
-//! \param ulInterrupt specifies the interrupt to be disabled.
-//!
-//! The specified interrupt is disabled in the interrupt controller.  Other
-//! enables for the interrupt (such as at the peripheral level) are unaffected
-//! by this function.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-IntDisable(unsigned long ulInterrupt)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
-
-    //
-    // Determine the interrupt to disable.
-    //
-    if(ulInterrupt == FAULT_MPU)
-    {
-        //
-        // Disable the MemManage interrupt.
-        //
-        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_MEM);
-    }
-    else if(ulInterrupt == FAULT_BUS)
-    {
-        //
-        // Disable the bus fault interrupt.
-        //
-        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_BUS);
-    }
-    else if(ulInterrupt == FAULT_USAGE)
-    {
-        //
-        // Disable the usage fault interrupt.
-        //
-        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_USAGE);
-    }
-    else if(ulInterrupt == FAULT_SYSTICK)
-    {
-        //
-        // Disable the System Tick interrupt.
-        //
-        HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
-    }
-    else if((ulInterrupt &gt;= 16) &amp;&amp; (ulInterrupt &lt;= 47))
-    {
-        //
-        // Disable the general interrupt.
-        //
-        HWREG(NVIC_DIS0) = 1 &lt;&lt; (ulInterrupt - 16);
-    }
-    else if(ulInterrupt &gt;= 48)
-    {
-        //
-        // Disable the general interrupt.
-        //
-        HWREG(NVIC_DIS1) = 1 &lt;&lt; (ulInterrupt - 48);
-    }
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// interrupt.c - Driver for the NVIC Interrupt Controller.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup interrupt_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_nvic.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;cpu.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// This is a mapping between priority grouping encodings and the number of
+// preemption priority bits.
+//
+//*****************************************************************************
+static const unsigned long g_pulPriority[] =
+{
+    NVIC_APINT_PRIGROUP_0_8, NVIC_APINT_PRIGROUP_1_7, NVIC_APINT_PRIGROUP_2_6,
+    NVIC_APINT_PRIGROUP_3_5, NVIC_APINT_PRIGROUP_4_4, NVIC_APINT_PRIGROUP_5_3,
+    NVIC_APINT_PRIGROUP_6_2, NVIC_APINT_PRIGROUP_7_1
+};
+
+//*****************************************************************************
+//
+// This is a mapping between interrupt number and the register that contains
+// the priority encoding for that interrupt.
+//
+//*****************************************************************************
+static const unsigned long g_pulRegs[] =
+{
+    0, NVIC_SYS_PRI1, NVIC_SYS_PRI2, NVIC_SYS_PRI3, NVIC_PRI0, NVIC_PRI1,
+    NVIC_PRI2, NVIC_PRI3, NVIC_PRI4, NVIC_PRI5, NVIC_PRI6, NVIC_PRI7,
+    NVIC_PRI8, NVIC_PRI9, NVIC_PRI10, NVIC_PRI11, NVIC_PRI12, NVIC_PRI13
+};
+
+//*****************************************************************************
+//
+//! \internal
+//! The default interrupt handler.
+//!
+//! This is the default interrupt handler for all interrupts.  It simply loops
+//! forever so that the system state is preserved for observation by a
+//! debugger.  Since interrupts should be disabled before unregistering the
+//! corresponding handler, this should never be called.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+IntDefaultHandler(void)
+{
+    //
+    // Go into an infinite loop.
+    //
+    while(1)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+// The processor vector table.
+//
+// This contains a list of the handlers for the various interrupt sources in
+// the system.  The layout of this list is defined by the hardware; assertion
+// of an interrupt causes the processor to start executing directly at the
+// address given in the corresponding location in this list.
+//
+//*****************************************************************************
+#if defined(ewarm)
+static __no_init void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void) @ &quot;VTABLE&quot;;
+#elif defined(sourcerygxx)
+static __attribute__((section(&quot;.cs3.region-head.ram&quot;)))
+void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void);
+#else
+static __attribute__((section(&quot;vtable&quot;)))
+void (*g_pfnRAMVectors[NUM_INTERRUPTS])(void);
+#endif
+
+//*****************************************************************************
+//
+//! Enables the processor interrupt.
+//!
+//! Allows the processor to respond to interrupts.  This does not affect the
+//! set of interrupts enabled in the interrupt controller; it just gates the
+//! single interrupt from the controller to the processor.
+//!
+//! \note Previously, this function had no return value.  As such, it was
+//! possible to include &lt;tt&gt;interrupt.h&lt;/tt&gt; and call this function without
+//! having included &lt;tt&gt;hw_types.h&lt;/tt&gt;.  Now that the return is a
+//! &lt;tt&gt;tBoolean&lt;/tt&gt;, a compiler error will occur in this case.  The solution
+//! is to include &lt;tt&gt;hw_types.h&lt;/tt&gt; before including &lt;tt&gt;interrupt.h&lt;/tt&gt;.
+//!
+//! \return Returns \b true if interrupts were disabled when the function was
+//! called or \b false if they were initially enabled.
+//
+//*****************************************************************************
+tBoolean
+IntMasterEnable(void)
+{
+    //
+    // Enable processor interrupts.
+    //
+    return(CPUcpsie());
+}
+
+//*****************************************************************************
+//
+//! Disables the processor interrupt.
+//!
+//! Prevents the processor from receiving interrupts.  This does not affect the
+//! set of interrupts enabled in the interrupt controller; it just gates the
+//! single interrupt from the controller to the processor.
+//!
+//! \note Previously, this function had no return value.  As such, it was
+//! possible to include &lt;tt&gt;interrupt.h&lt;/tt&gt; and call this function without
+//! having included &lt;tt&gt;hw_types.h&lt;/tt&gt;.  Now that the return is a
+//! &lt;tt&gt;tBoolean&lt;/tt&gt;, a compiler error will occur in this case.  The solution
+//! is to include &lt;tt&gt;hw_types.h&lt;/tt&gt; before including &lt;tt&gt;interrupt.h&lt;/tt&gt;.
+//!
+//! \return Returns \b true if interrupts were already disabled when the
+//! function was called or \b false if they were initially enabled.
+//
+//*****************************************************************************
+tBoolean
+IntMasterDisable(void)
+{
+    //
+    // Disable processor interrupts.
+    //
+    return(CPUcpsid());
+}
+
+//*****************************************************************************
+//
+//! Registers a function to be called when an interrupt occurs.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//! \param pfnHandler is a pointer to the function to be called.
+//!
+//! This function is used to specify the handler function to be called when the
+//! given interrupt is asserted to the processor.  When the interrupt occurs,
+//! if it is enabled (via IntEnable()), the handler function will be called in
+//! interrupt context.  Since the handler function can preempt other code, care
+//! must be taken to protect memory or peripherals that are accessed by the
+//! handler and other non-handler code.
+//!
+//! \note The use of this function (directly or indirectly via a peripheral
+//! driver interrupt register function) moves the interrupt vector table from
+//! flash to SRAM.  Therefore, care must be taken when linking the application
+//! to ensure that the SRAM vector table is located at the beginning of SRAM;
+//! otherwise NVIC will not look in the correct portion of memory for the
+//! vector table (it requires the vector table be on a 1 kB memory alignment).
+//! Normally, the SRAM vector table is so placed via the use of linker scripts;
+//! some tool chains, such as the evaluation version of RV-MDK, do not support
+//! linker scripts and therefore will not produce a valid executable.  See the
+//! discussion of compile-time versus run-time interrupt handler registration
+//! in the introduction to this chapter.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntRegister(unsigned long ulInterrupt, void (*pfnHandler)(void))
+{
+    unsigned long ulIdx, ulValue;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Make sure that the RAM vector table is correctly aligned.
+    //
+    ASSERT(((unsigned long)g_pfnRAMVectors &amp; 0x000003ff) == 0);
+
+    //
+    // See if the RAM vector table has been initialized.
+    //
+    if(HWREG(NVIC_VTABLE) != (unsigned long)g_pfnRAMVectors)
+    {
+        //
+        // Copy the vector table from the beginning of FLASH to the RAM vector
+        // table.
+        //
+        ulValue = HWREG(NVIC_VTABLE);
+        for(ulIdx = 0; ulIdx &lt; NUM_INTERRUPTS; ulIdx++)
+        {
+            g_pfnRAMVectors[ulIdx] = (void (*)(void))HWREG((ulIdx * 4) +
+                                                     ulValue);
+        }
+
+        //
+        // Point NVIC at the RAM vector table.
+        //
+        HWREG(NVIC_VTABLE) = (unsigned long)g_pfnRAMVectors;
+    }
+
+    //
+    // Save the interrupt handler.
+    //
+    g_pfnRAMVectors[ulInterrupt] = pfnHandler;
+}
+
+//*****************************************************************************
+//
+//! Unregisters the function to be called when an interrupt occurs.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//!
+//! This function is used to indicate that no handler should be called when the
+//! given interrupt is asserted to the processor.  The interrupt source will be
+//! automatically disabled (via IntDisable()) if necessary.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntUnregister(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Reset the interrupt handler.
+    //
+    g_pfnRAMVectors[ulInterrupt] = IntDefaultHandler;
+}
+
+//*****************************************************************************
+//
+//! Sets the priority grouping of the interrupt controller.
+//!
+//! \param ulBits specifies the number of bits of preemptable priority.
+//!
+//! This function specifies the split between preemptable priority levels and
+//! subpriority levels in the interrupt priority specification.  The range of
+//! the grouping values are dependent upon the hardware implementation; on
+//! the Stellaris family, three bits are available for hardware interrupt
+//! prioritization and therefore priority grouping values of three through
+//! seven have the same effect.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntPriorityGroupingSet(unsigned long ulBits)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBits &lt; NUM_PRIORITY);
+
+    //
+    // Set the priority grouping.
+    //
+    HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | g_pulPriority[ulBits];
+}
+
+//*****************************************************************************
+//
+//! Gets the priority grouping of the interrupt controller.
+//!
+//! This function returns the split between preemptable priority levels and
+//! subpriority levels in the interrupt priority specification.
+//!
+//! \return The number of bits of preemptable priority.
+//
+//*****************************************************************************
+unsigned long
+IntPriorityGroupingGet(void)
+{
+    unsigned long ulLoop, ulValue;
+
+    //
+    // Read the priority grouping.
+    //
+    ulValue = HWREG(NVIC_APINT) &amp; NVIC_APINT_PRIGROUP_M;
+
+    //
+    // Loop through the priority grouping values.
+    //
+    for(ulLoop = 0; ulLoop &lt; NUM_PRIORITY; ulLoop++)
+    {
+        //
+        // Stop looping if this value matches.
+        //
+        if(ulValue == g_pulPriority[ulLoop])
+        {
+            break;
+        }
+    }
+
+    //
+    // Return the number of priority bits.
+    //
+    return(ulLoop);
+}
+
+//*****************************************************************************
+//
+//! Sets the priority of an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//! \param ucPriority specifies the priority of the interrupt.
+//!
+//! This function is used to set the priority of an interrupt.  When multiple
+//! interrupts are asserted simultaneously, the ones with the highest priority
+//! are processed before the lower priority interrupts.  Smaller numbers
+//! correspond to higher interrupt priorities; priority 0 is the highest
+//! interrupt priority.
+//!
+//! The hardware priority mechanism will only look at the upper N bits of the
+//! priority level (where N is 3 for the Stellaris family), so any
+//! prioritization must be performed in those bits.  The remaining bits can be
+//! used to sub-prioritize the interrupt sources, and may be used by the
+//! hardware priority mechanism on a future part.  This arrangement allows
+//! priorities to migrate to different NVIC implementations without changing
+//! the gross prioritization of the interrupts.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntPrioritySet(unsigned long ulInterrupt, unsigned char ucPriority)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulInterrupt &gt;= 4) &amp;&amp; (ulInterrupt &lt; NUM_INTERRUPTS));
+
+    //
+    // Set the interrupt priority.
+    //
+    ulTemp = HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]);
+    ulTemp &amp;= ~(0xFF &lt;&lt; (8 * (ulInterrupt &amp; 3)));
+    ulTemp |= ucPriority &lt;&lt; (8 * (ulInterrupt &amp; 3));
+    HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Gets the priority of an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt in question.
+//!
+//! This function gets the priority of an interrupt.  See IntPrioritySet() for
+//! a definition of the priority value.
+//!
+//! \return Returns the interrupt priority, or -1 if an invalid interrupt was
+//! specified.
+//
+//*****************************************************************************
+long
+IntPriorityGet(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulInterrupt &gt;= 4) &amp;&amp; (ulInterrupt &lt; NUM_INTERRUPTS));
+
+    //
+    // Return the interrupt priority.
+    //
+    return((HWREG(g_pulRegs[ulInterrupt &gt;&gt; 2]) &gt;&gt; (8 * (ulInterrupt &amp; 3))) &amp;
+           0xFF);
+}
+
+//*****************************************************************************
+//
+//! Enables an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt to be enabled.
+//!
+//! The specified interrupt is enabled in the interrupt controller.  Other
+//! enables for the interrupt (such as at the peripheral level) are unaffected
+//! by this function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntEnable(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Determine the interrupt to enable.
+    //
+    if(ulInterrupt == FAULT_MPU)
+    {
+        //
+        // Enable the MemManage interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_MEM;
+    }
+    else if(ulInterrupt == FAULT_BUS)
+    {
+        //
+        // Enable the bus fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_BUS;
+    }
+    else if(ulInterrupt == FAULT_USAGE)
+    {
+        //
+        // Enable the usage fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_USAGE;
+    }
+    else if(ulInterrupt == FAULT_SYSTICK)
+    {
+        //
+        // Enable the System Tick interrupt.
+        //
+        HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
+    }
+    else if((ulInterrupt &gt;= 16) &amp;&amp; (ulInterrupt &lt;= 47))
+    {
+        //
+        // Enable the general interrupt.
+        //
+        HWREG(NVIC_EN0) = 1 &lt;&lt; (ulInterrupt - 16);
+    }
+    else if(ulInterrupt &gt;= 48)
+    {
+        //
+        // Enable the general interrupt.
+        //
+        HWREG(NVIC_EN1) = 1 &lt;&lt; (ulInterrupt - 48);
+    }
+}
+
+//*****************************************************************************
+//
+//! Disables an interrupt.
+//!
+//! \param ulInterrupt specifies the interrupt to be disabled.
+//!
+//! The specified interrupt is disabled in the interrupt controller.  Other
+//! enables for the interrupt (such as at the peripheral level) are unaffected
+//! by this function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+IntDisable(unsigned long ulInterrupt)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulInterrupt &lt; NUM_INTERRUPTS);
+
+    //
+    // Determine the interrupt to disable.
+    //
+    if(ulInterrupt == FAULT_MPU)
+    {
+        //
+        // Disable the MemManage interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_MEM);
+    }
+    else if(ulInterrupt == FAULT_BUS)
+    {
+        //
+        // Disable the bus fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_BUS);
+    }
+    else if(ulInterrupt == FAULT_USAGE)
+    {
+        //
+        // Disable the usage fault interrupt.
+        //
+        HWREG(NVIC_SYS_HND_CTRL) &amp;= ~(NVIC_SYS_HND_CTRL_USAGE);
+    }
+    else if(ulInterrupt == FAULT_SYSTICK)
+    {
+        //
+        // Disable the System Tick interrupt.
+        //
+        HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
+    }
+    else if((ulInterrupt &gt;= 16) &amp;&amp; (ulInterrupt &lt;= 47))
+    {
+        //
+        // Disable the general interrupt.
+        //
+        HWREG(NVIC_DIS0) = 1 &lt;&lt; (ulInterrupt - 16);
+    }
+    else if(ulInterrupt &gt;= 48)
+    {
+        //
+        // Disable the general interrupt.
+        //
+        HWREG(NVIC_DIS1) = 1 &lt;&lt; (ulInterrupt - 48);
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/interrupt.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/interrupt.h
===================================================================
--- trunk/src/platform/lm3s/interrupt.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/interrupt.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,76 +1,76 @@
-//*****************************************************************************
-//
-// interrupt.h - Prototypes for the NVIC Interrupt Controller Driver.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __INTERRUPT_H__
-#define __INTERRUPT_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Macro to generate an interrupt priority mask based on the number of bits
-// of priority supported by the hardware.
-//
-//*****************************************************************************
-#define INT_PRIORITY_MASK       ((0xFF &lt;&lt; (8 - NUM_PRIORITY_BITS)) &amp; 0xFF)
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern tBoolean IntMasterEnable(void);
-extern tBoolean IntMasterDisable(void);
-extern void IntRegister(unsigned long ulInterrupt, void (*pfnHandler)(void));
-extern void IntUnregister(unsigned long ulInterrupt);
-extern void IntPriorityGroupingSet(unsigned long ulBits);
-extern unsigned long IntPriorityGroupingGet(void);
-extern void IntPrioritySet(unsigned long ulInterrupt,
-                           unsigned char ucPriority);
-extern long IntPriorityGet(unsigned long ulInterrupt);
-extern void IntEnable(unsigned long ulInterrupt);
-extern void IntDisable(unsigned long ulInterrupt);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __INTERRUPT_H__
+//*****************************************************************************
+//
+// interrupt.h - Prototypes for the NVIC Interrupt Controller Driver.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __INTERRUPT_H__
+#define __INTERRUPT_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Macro to generate an interrupt priority mask based on the number of bits
+// of priority supported by the hardware.
+//
+//*****************************************************************************
+#define INT_PRIORITY_MASK       ((0xFF &lt;&lt; (8 - NUM_PRIORITY_BITS)) &amp; 0xFF)
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern tBoolean IntMasterEnable(void);
+extern tBoolean IntMasterDisable(void);
+extern void IntRegister(unsigned long ulInterrupt, void (*pfnHandler)(void));
+extern void IntUnregister(unsigned long ulInterrupt);
+extern void IntPriorityGroupingSet(unsigned long ulBits);
+extern unsigned long IntPriorityGroupingGet(void);
+extern void IntPrioritySet(unsigned long ulInterrupt,
+                           unsigned char ucPriority);
+extern long IntPriorityGet(unsigned long ulInterrupt);
+extern void IntEnable(unsigned long ulInterrupt);
+extern void IntDisable(unsigned long ulInterrupt);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __INTERRUPT_H__


Property changes on: trunk/src/platform/lm3s/interrupt.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/lm3s6918.h
===================================================================
--- trunk/src/platform/lm3s/lm3s6918.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/lm3s6918.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,4036 @@
+//*****************************************************************************
+//
+// lm3s6918.h - LM3S6918 Register Definitions
+//
+// Copyright (c) 2007-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __LM3S6918_H__
+#define __LM3S6918_H__
+
+//*****************************************************************************
+//
+// Watchdog Timer (WATCHDOG)
+//
+//*****************************************************************************
+#define WATCHDOG_LOAD_R         (*((volatile unsigned long *)0x40000000))
+#define WATCHDOG_VALUE_R        (*((volatile unsigned long *)0x40000004))
+#define WATCHDOG_CTL_R          (*((volatile unsigned long *)0x40000008))
+#define WATCHDOG_ICR_R          (*((volatile unsigned long *)0x4000000C))
+#define WATCHDOG_RIS_R          (*((volatile unsigned long *)0x40000010))
+#define WATCHDOG_MIS_R          (*((volatile unsigned long *)0x40000014))
+#define WATCHDOG_TEST_R         (*((volatile unsigned long *)0x40000418))
+#define WATCHDOG_LOCK_R         (*((volatile unsigned long *)0x40000C00))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTA)
+//
+//*****************************************************************************
+#define GPIO_PORTA_DATA_BITS_R  ((volatile unsigned long *)0x40004000)
+#define GPIO_PORTA_DATA_R       (*((volatile unsigned long *)0x400043FC))
+#define GPIO_PORTA_DIR_R        (*((volatile unsigned long *)0x40004400))
+#define GPIO_PORTA_IS_R         (*((volatile unsigned long *)0x40004404))
+#define GPIO_PORTA_IBE_R        (*((volatile unsigned long *)0x40004408))
+#define GPIO_PORTA_IEV_R        (*((volatile unsigned long *)0x4000440C))
+#define GPIO_PORTA_IM_R         (*((volatile unsigned long *)0x40004410))
+#define GPIO_PORTA_RIS_R        (*((volatile unsigned long *)0x40004414))
+#define GPIO_PORTA_MIS_R        (*((volatile unsigned long *)0x40004418))
+#define GPIO_PORTA_ICR_R        (*((volatile unsigned long *)0x4000441C))
+#define GPIO_PORTA_AFSEL_R      (*((volatile unsigned long *)0x40004420))
+#define GPIO_PORTA_DR2R_R       (*((volatile unsigned long *)0x40004500))
+#define GPIO_PORTA_DR4R_R       (*((volatile unsigned long *)0x40004504))
+#define GPIO_PORTA_DR8R_R       (*((volatile unsigned long *)0x40004508))
+#define GPIO_PORTA_ODR_R        (*((volatile unsigned long *)0x4000450C))
+#define GPIO_PORTA_PUR_R        (*((volatile unsigned long *)0x40004510))
+#define GPIO_PORTA_PDR_R        (*((volatile unsigned long *)0x40004514))
+#define GPIO_PORTA_SLR_R        (*((volatile unsigned long *)0x40004518))
+#define GPIO_PORTA_DEN_R        (*((volatile unsigned long *)0x4000451C))
+#define GPIO_PORTA_LOCK_R       (*((volatile unsigned long *)0x40004520))
+#define GPIO_PORTA_CR_R         (*((volatile unsigned long *)0x40004524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTB)
+//
+//*****************************************************************************
+#define GPIO_PORTB_DATA_BITS_R  ((volatile unsigned long *)0x40005000)
+#define GPIO_PORTB_DATA_R       (*((volatile unsigned long *)0x400053FC))
+#define GPIO_PORTB_DIR_R        (*((volatile unsigned long *)0x40005400))
+#define GPIO_PORTB_IS_R         (*((volatile unsigned long *)0x40005404))
+#define GPIO_PORTB_IBE_R        (*((volatile unsigned long *)0x40005408))
+#define GPIO_PORTB_IEV_R        (*((volatile unsigned long *)0x4000540C))
+#define GPIO_PORTB_IM_R         (*((volatile unsigned long *)0x40005410))
+#define GPIO_PORTB_RIS_R        (*((volatile unsigned long *)0x40005414))
+#define GPIO_PORTB_MIS_R        (*((volatile unsigned long *)0x40005418))
+#define GPIO_PORTB_ICR_R        (*((volatile unsigned long *)0x4000541C))
+#define GPIO_PORTB_AFSEL_R      (*((volatile unsigned long *)0x40005420))
+#define GPIO_PORTB_DR2R_R       (*((volatile unsigned long *)0x40005500))
+#define GPIO_PORTB_DR4R_R       (*((volatile unsigned long *)0x40005504))
+#define GPIO_PORTB_DR8R_R       (*((volatile unsigned long *)0x40005508))
+#define GPIO_PORTB_ODR_R        (*((volatile unsigned long *)0x4000550C))
+#define GPIO_PORTB_PUR_R        (*((volatile unsigned long *)0x40005510))
+#define GPIO_PORTB_PDR_R        (*((volatile unsigned long *)0x40005514))
+#define GPIO_PORTB_SLR_R        (*((volatile unsigned long *)0x40005518))
+#define GPIO_PORTB_DEN_R        (*((volatile unsigned long *)0x4000551C))
+#define GPIO_PORTB_LOCK_R       (*((volatile unsigned long *)0x40005520))
+#define GPIO_PORTB_CR_R         (*((volatile unsigned long *)0x40005524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTC)
+//
+//*****************************************************************************
+#define GPIO_PORTC_DATA_BITS_R  ((volatile unsigned long *)0x40006000)
+#define GPIO_PORTC_DATA_R       (*((volatile unsigned long *)0x400063FC))
+#define GPIO_PORTC_DIR_R        (*((volatile unsigned long *)0x40006400))
+#define GPIO_PORTC_IS_R         (*((volatile unsigned long *)0x40006404))
+#define GPIO_PORTC_IBE_R        (*((volatile unsigned long *)0x40006408))
+#define GPIO_PORTC_IEV_R        (*((volatile unsigned long *)0x4000640C))
+#define GPIO_PORTC_IM_R         (*((volatile unsigned long *)0x40006410))
+#define GPIO_PORTC_RIS_R        (*((volatile unsigned long *)0x40006414))
+#define GPIO_PORTC_MIS_R        (*((volatile unsigned long *)0x40006418))
+#define GPIO_PORTC_ICR_R        (*((volatile unsigned long *)0x4000641C))
+#define GPIO_PORTC_AFSEL_R      (*((volatile unsigned long *)0x40006420))
+#define GPIO_PORTC_DR2R_R       (*((volatile unsigned long *)0x40006500))
+#define GPIO_PORTC_DR4R_R       (*((volatile unsigned long *)0x40006504))
+#define GPIO_PORTC_DR8R_R       (*((volatile unsigned long *)0x40006508))
+#define GPIO_PORTC_ODR_R        (*((volatile unsigned long *)0x4000650C))
+#define GPIO_PORTC_PUR_R        (*((volatile unsigned long *)0x40006510))
+#define GPIO_PORTC_PDR_R        (*((volatile unsigned long *)0x40006514))
+#define GPIO_PORTC_SLR_R        (*((volatile unsigned long *)0x40006518))
+#define GPIO_PORTC_DEN_R        (*((volatile unsigned long *)0x4000651C))
+#define GPIO_PORTC_LOCK_R       (*((volatile unsigned long *)0x40006520))
+#define GPIO_PORTC_CR_R         (*((volatile unsigned long *)0x40006524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTD)
+//
+//*****************************************************************************
+#define GPIO_PORTD_DATA_BITS_R  ((volatile unsigned long *)0x40007000)
+#define GPIO_PORTD_DATA_R       (*((volatile unsigned long *)0x400073FC))
+#define GPIO_PORTD_DIR_R        (*((volatile unsigned long *)0x40007400))
+#define GPIO_PORTD_IS_R         (*((volatile unsigned long *)0x40007404))
+#define GPIO_PORTD_IBE_R        (*((volatile unsigned long *)0x40007408))
+#define GPIO_PORTD_IEV_R        (*((volatile unsigned long *)0x4000740C))
+#define GPIO_PORTD_IM_R         (*((volatile unsigned long *)0x40007410))
+#define GPIO_PORTD_RIS_R        (*((volatile unsigned long *)0x40007414))
+#define GPIO_PORTD_MIS_R        (*((volatile unsigned long *)0x40007418))
+#define GPIO_PORTD_ICR_R        (*((volatile unsigned long *)0x4000741C))
+#define GPIO_PORTD_AFSEL_R      (*((volatile unsigned long *)0x40007420))
+#define GPIO_PORTD_DR2R_R       (*((volatile unsigned long *)0x40007500))
+#define GPIO_PORTD_DR4R_R       (*((volatile unsigned long *)0x40007504))
+#define GPIO_PORTD_DR8R_R       (*((volatile unsigned long *)0x40007508))
+#define GPIO_PORTD_ODR_R        (*((volatile unsigned long *)0x4000750C))
+#define GPIO_PORTD_PUR_R        (*((volatile unsigned long *)0x40007510))
+#define GPIO_PORTD_PDR_R        (*((volatile unsigned long *)0x40007514))
+#define GPIO_PORTD_SLR_R        (*((volatile unsigned long *)0x40007518))
+#define GPIO_PORTD_DEN_R        (*((volatile unsigned long *)0x4000751C))
+#define GPIO_PORTD_LOCK_R       (*((volatile unsigned long *)0x40007520))
+#define GPIO_PORTD_CR_R         (*((volatile unsigned long *)0x40007524))
+
+//*****************************************************************************
+//
+// Synchronous Serial Interface (SSI0)
+//
+//*****************************************************************************
+#define SSI0_CR0_R              (*((volatile unsigned long *)0x40008000))
+#define SSI0_CR1_R              (*((volatile unsigned long *)0x40008004))
+#define SSI0_DR_R               (*((volatile unsigned long *)0x40008008))
+#define SSI0_SR_R               (*((volatile unsigned long *)0x4000800C))
+#define SSI0_CPSR_R             (*((volatile unsigned long *)0x40008010))
+#define SSI0_IM_R               (*((volatile unsigned long *)0x40008014))
+#define SSI0_RIS_R              (*((volatile unsigned long *)0x40008018))
+#define SSI0_MIS_R              (*((volatile unsigned long *)0x4000801C))
+#define SSI0_ICR_R              (*((volatile unsigned long *)0x40008020))
+
+//*****************************************************************************
+//
+// Synchronous Serial Interface (SSI1)
+//
+//*****************************************************************************
+#define SSI1_CR0_R              (*((volatile unsigned long *)0x40009000))
+#define SSI1_CR1_R              (*((volatile unsigned long *)0x40009004))
+#define SSI1_DR_R               (*((volatile unsigned long *)0x40009008))
+#define SSI1_SR_R               (*((volatile unsigned long *)0x4000900C))
+#define SSI1_CPSR_R             (*((volatile unsigned long *)0x40009010))
+#define SSI1_IM_R               (*((volatile unsigned long *)0x40009014))
+#define SSI1_RIS_R              (*((volatile unsigned long *)0x40009018))
+#define SSI1_MIS_R              (*((volatile unsigned long *)0x4000901C))
+#define SSI1_ICR_R              (*((volatile unsigned long *)0x40009020))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART0)
+//
+//*****************************************************************************
+#define UART0_DR_R              (*((volatile unsigned long *)0x4000C000))
+#define UART0_RSR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_ECR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_FR_R              (*((volatile unsigned long *)0x4000C018))
+#define UART0_ILPR_R            (*((volatile unsigned long *)0x4000C020))
+#define UART0_IBRD_R            (*((volatile unsigned long *)0x4000C024))
+#define UART0_FBRD_R            (*((volatile unsigned long *)0x4000C028))
+#define UART0_LCRH_R            (*((volatile unsigned long *)0x4000C02C))
+#define UART0_CTL_R             (*((volatile unsigned long *)0x4000C030))
+#define UART0_IFLS_R            (*((volatile unsigned long *)0x4000C034))
+#define UART0_IM_R              (*((volatile unsigned long *)0x4000C038))
+#define UART0_RIS_R             (*((volatile unsigned long *)0x4000C03C))
+#define UART0_MIS_R             (*((volatile unsigned long *)0x4000C040))
+#define UART0_ICR_R             (*((volatile unsigned long *)0x4000C044))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART1)
+//
+//*****************************************************************************
+#define UART1_DR_R              (*((volatile unsigned long *)0x4000D000))
+#define UART1_RSR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_ECR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_FR_R              (*((volatile unsigned long *)0x4000D018))
+#define UART1_ILPR_R            (*((volatile unsigned long *)0x4000D020))
+#define UART1_IBRD_R            (*((volatile unsigned long *)0x4000D024))
+#define UART1_FBRD_R            (*((volatile unsigned long *)0x4000D028))
+#define UART1_LCRH_R            (*((volatile unsigned long *)0x4000D02C))
+#define UART1_CTL_R             (*((volatile unsigned long *)0x4000D030))
+#define UART1_IFLS_R            (*((volatile unsigned long *)0x4000D034))
+#define UART1_IM_R              (*((volatile unsigned long *)0x4000D038))
+#define UART1_RIS_R             (*((volatile unsigned long *)0x4000D03C))
+#define UART1_MIS_R             (*((volatile unsigned long *)0x4000D040))
+#define UART1_ICR_R             (*((volatile unsigned long *)0x4000D044))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (MASTER) Interface
+//
+//*****************************************************************************
+#define I2C0_MASTER_MSA_R       (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SOAR_R      (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SCSR_R      (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_MCS_R       (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_SDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MTPR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SIMR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SRIS_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MIMR_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MRIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SMIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SICR_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MMIS_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MICR_R      (*((volatile unsigned long *)0x4002001C))
+#define I2C0_MASTER_MCR_R       (*((volatile unsigned long *)0x40020020))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (SLAVE) Interface
+//
+//*****************************************************************************
+#define I2C0_SLAVE_MSA_R        (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SOAR_R       (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SCSR_R       (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_MCS_R        (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_SDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MTPR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SIMR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SRIS_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MIMR_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MRIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SMIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SICR_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MMIS_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MICR_R       (*((volatile unsigned long *)0x4002081C))
+#define I2C0_SLAVE_MCR_R        (*((volatile unsigned long *)0x40020820))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (MASTER) Interface
+//
+//*****************************************************************************
+#define I2C1_MASTER_MSA_R       (*((volatile unsigned long *)0x40021000))
+#define I2C1_MASTER_SOAR_R      (*((volatile unsigned long *)0x40021000))
+#define I2C1_MASTER_SCSR_R      (*((volatile unsigned long *)0x40021004))
+#define I2C1_MASTER_MCS_R       (*((volatile unsigned long *)0x40021004))
+#define I2C1_MASTER_SDR_R       (*((volatile unsigned long *)0x40021008))
+#define I2C1_MASTER_MDR_R       (*((volatile unsigned long *)0x40021008))
+#define I2C1_MASTER_MTPR_R      (*((volatile unsigned long *)0x4002100C))
+#define I2C1_MASTER_SIMR_R      (*((volatile unsigned long *)0x4002100C))
+#define I2C1_MASTER_SRIS_R      (*((volatile unsigned long *)0x40021010))
+#define I2C1_MASTER_MIMR_R      (*((volatile unsigned long *)0x40021010))
+#define I2C1_MASTER_MRIS_R      (*((volatile unsigned long *)0x40021014))
+#define I2C1_MASTER_SMIS_R      (*((volatile unsigned long *)0x40021014))
+#define I2C1_MASTER_SICR_R      (*((volatile unsigned long *)0x40021018))
+#define I2C1_MASTER_MMIS_R      (*((volatile unsigned long *)0x40021018))
+#define I2C1_MASTER_MICR_R      (*((volatile unsigned long *)0x4002101C))
+#define I2C1_MASTER_MCR_R       (*((volatile unsigned long *)0x40021020))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (SLAVE) Interface
+//
+//*****************************************************************************
+#define I2C1_SLAVE_MSA_R        (*((volatile unsigned long *)0x40021800))
+#define I2C1_SLAVE_SOAR_R       (*((volatile unsigned long *)0x40021800))
+#define I2C1_SLAVE_SCSR_R       (*((volatile unsigned long *)0x40021804))
+#define I2C1_SLAVE_MCS_R        (*((volatile unsigned long *)0x40021804))
+#define I2C1_SLAVE_SDR_R        (*((volatile unsigned long *)0x40021808))
+#define I2C1_SLAVE_MDR_R        (*((volatile unsigned long *)0x40021808))
+#define I2C1_SLAVE_MTPR_R       (*((volatile unsigned long *)0x4002180C))
+#define I2C1_SLAVE_SIMR_R       (*((volatile unsigned long *)0x4002180C))
+#define I2C1_SLAVE_SRIS_R       (*((volatile unsigned long *)0x40021810))
+#define I2C1_SLAVE_MIMR_R       (*((volatile unsigned long *)0x40021810))
+#define I2C1_SLAVE_MRIS_R       (*((volatile unsigned long *)0x40021814))
+#define I2C1_SLAVE_SMIS_R       (*((volatile unsigned long *)0x40021814))
+#define I2C1_SLAVE_SICR_R       (*((volatile unsigned long *)0x40021818))
+#define I2C1_SLAVE_MMIS_R       (*((volatile unsigned long *)0x40021818))
+#define I2C1_SLAVE_MICR_R       (*((volatile unsigned long *)0x4002181C))
+#define I2C1_SLAVE_MCR_R        (*((volatile unsigned long *)0x40021820))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTE)
+//
+//*****************************************************************************
+#define GPIO_PORTE_DATA_BITS_R  ((volatile unsigned long *)0x40024000)
+#define GPIO_PORTE_DATA_R       (*((volatile unsigned long *)0x400243FC))
+#define GPIO_PORTE_DIR_R        (*((volatile unsigned long *)0x40024400))
+#define GPIO_PORTE_IS_R         (*((volatile unsigned long *)0x40024404))
+#define GPIO_PORTE_IBE_R        (*((volatile unsigned long *)0x40024408))
+#define GPIO_PORTE_IEV_R        (*((volatile unsigned long *)0x4002440C))
+#define GPIO_PORTE_IM_R         (*((volatile unsigned long *)0x40024410))
+#define GPIO_PORTE_RIS_R        (*((volatile unsigned long *)0x40024414))
+#define GPIO_PORTE_MIS_R        (*((volatile unsigned long *)0x40024418))
+#define GPIO_PORTE_ICR_R        (*((volatile unsigned long *)0x4002441C))
+#define GPIO_PORTE_AFSEL_R      (*((volatile unsigned long *)0x40024420))
+#define GPIO_PORTE_DR2R_R       (*((volatile unsigned long *)0x40024500))
+#define GPIO_PORTE_DR4R_R       (*((volatile unsigned long *)0x40024504))
+#define GPIO_PORTE_DR8R_R       (*((volatile unsigned long *)0x40024508))
+#define GPIO_PORTE_ODR_R        (*((volatile unsigned long *)0x4002450C))
+#define GPIO_PORTE_PUR_R        (*((volatile unsigned long *)0x40024510))
+#define GPIO_PORTE_PDR_R        (*((volatile unsigned long *)0x40024514))
+#define GPIO_PORTE_SLR_R        (*((volatile unsigned long *)0x40024518))
+#define GPIO_PORTE_DEN_R        (*((volatile unsigned long *)0x4002451C))
+#define GPIO_PORTE_LOCK_R       (*((volatile unsigned long *)0x40024520))
+#define GPIO_PORTE_CR_R         (*((volatile unsigned long *)0x40024524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTF)
+//
+//*****************************************************************************
+#define GPIO_PORTF_DATA_BITS_R  ((volatile unsigned long *)0x40025000)
+#define GPIO_PORTF_DATA_R       (*((volatile unsigned long *)0x400253FC))
+#define GPIO_PORTF_DIR_R        (*((volatile unsigned long *)0x40025400))
+#define GPIO_PORTF_IS_R         (*((volatile unsigned long *)0x40025404))
+#define GPIO_PORTF_IBE_R        (*((volatile unsigned long *)0x40025408))
+#define GPIO_PORTF_IEV_R        (*((volatile unsigned long *)0x4002540C))
+#define GPIO_PORTF_IM_R         (*((volatile unsigned long *)0x40025410))
+#define GPIO_PORTF_RIS_R        (*((volatile unsigned long *)0x40025414))
+#define GPIO_PORTF_MIS_R        (*((volatile unsigned long *)0x40025418))
+#define GPIO_PORTF_ICR_R        (*((volatile unsigned long *)0x4002541C))
+#define GPIO_PORTF_AFSEL_R      (*((volatile unsigned long *)0x40025420))
+#define GPIO_PORTF_DR2R_R       (*((volatile unsigned long *)0x40025500))
+#define GPIO_PORTF_DR4R_R       (*((volatile unsigned long *)0x40025504))
+#define GPIO_PORTF_DR8R_R       (*((volatile unsigned long *)0x40025508))
+#define GPIO_PORTF_ODR_R        (*((volatile unsigned long *)0x4002550C))
+#define GPIO_PORTF_PUR_R        (*((volatile unsigned long *)0x40025510))
+#define GPIO_PORTF_PDR_R        (*((volatile unsigned long *)0x40025514))
+#define GPIO_PORTF_SLR_R        (*((volatile unsigned long *)0x40025518))
+#define GPIO_PORTF_DEN_R        (*((volatile unsigned long *)0x4002551C))
+#define GPIO_PORTF_LOCK_R       (*((volatile unsigned long *)0x40025520))
+#define GPIO_PORTF_CR_R         (*((volatile unsigned long *)0x40025524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTG)
+//
+//*****************************************************************************
+#define GPIO_PORTG_DATA_BITS_R  ((volatile unsigned long *)0x40026000)
+#define GPIO_PORTG_DATA_R       (*((volatile unsigned long *)0x400263FC))
+#define GPIO_PORTG_DIR_R        (*((volatile unsigned long *)0x40026400))
+#define GPIO_PORTG_IS_R         (*((volatile unsigned long *)0x40026404))
+#define GPIO_PORTG_IBE_R        (*((volatile unsigned long *)0x40026408))
+#define GPIO_PORTG_IEV_R        (*((volatile unsigned long *)0x4002640C))
+#define GPIO_PORTG_IM_R         (*((volatile unsigned long *)0x40026410))
+#define GPIO_PORTG_RIS_R        (*((volatile unsigned long *)0x40026414))
+#define GPIO_PORTG_MIS_R        (*((volatile unsigned long *)0x40026418))
+#define GPIO_PORTG_ICR_R        (*((volatile unsigned long *)0x4002641C))
+#define GPIO_PORTG_AFSEL_R      (*((volatile unsigned long *)0x40026420))
+#define GPIO_PORTG_DR2R_R       (*((volatile unsigned long *)0x40026500))
+#define GPIO_PORTG_DR4R_R       (*((volatile unsigned long *)0x40026504))
+#define GPIO_PORTG_DR8R_R       (*((volatile unsigned long *)0x40026508))
+#define GPIO_PORTG_ODR_R        (*((volatile unsigned long *)0x4002650C))
+#define GPIO_PORTG_PUR_R        (*((volatile unsigned long *)0x40026510))
+#define GPIO_PORTG_PDR_R        (*((volatile unsigned long *)0x40026514))
+#define GPIO_PORTG_SLR_R        (*((volatile unsigned long *)0x40026518))
+#define GPIO_PORTG_DEN_R        (*((volatile unsigned long *)0x4002651C))
+#define GPIO_PORTG_LOCK_R       (*((volatile unsigned long *)0x40026520))
+#define GPIO_PORTG_CR_R         (*((volatile unsigned long *)0x40026524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTH)
+//
+//*****************************************************************************
+#define GPIO_PORTH_DATA_BITS_R  ((volatile unsigned long *)0x40027000)
+#define GPIO_PORTH_DATA_R       (*((volatile unsigned long *)0x400273FC))
+#define GPIO_PORTH_DIR_R        (*((volatile unsigned long *)0x40027400))
+#define GPIO_PORTH_IS_R         (*((volatile unsigned long *)0x40027404))
+#define GPIO_PORTH_IBE_R        (*((volatile unsigned long *)0x40027408))
+#define GPIO_PORTH_IEV_R        (*((volatile unsigned long *)0x4002740C))
+#define GPIO_PORTH_IM_R         (*((volatile unsigned long *)0x40027410))
+#define GPIO_PORTH_RIS_R        (*((volatile unsigned long *)0x40027414))
+#define GPIO_PORTH_MIS_R        (*((volatile unsigned long *)0x40027418))
+#define GPIO_PORTH_ICR_R        (*((volatile unsigned long *)0x4002741C))
+#define GPIO_PORTH_AFSEL_R      (*((volatile unsigned long *)0x40027420))
+#define GPIO_PORTH_DR2R_R       (*((volatile unsigned long *)0x40027500))
+#define GPIO_PORTH_DR4R_R       (*((volatile unsigned long *)0x40027504))
+#define GPIO_PORTH_DR8R_R       (*((volatile unsigned long *)0x40027508))
+#define GPIO_PORTH_ODR_R        (*((volatile unsigned long *)0x4002750C))
+#define GPIO_PORTH_PUR_R        (*((volatile unsigned long *)0x40027510))
+#define GPIO_PORTH_PDR_R        (*((volatile unsigned long *)0x40027514))
+#define GPIO_PORTH_SLR_R        (*((volatile unsigned long *)0x40027518))
+#define GPIO_PORTH_DEN_R        (*((volatile unsigned long *)0x4002751C))
+#define GPIO_PORTH_LOCK_R       (*((volatile unsigned long *)0x40027520))
+#define GPIO_PORTH_CR_R         (*((volatile unsigned long *)0x40027524))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER0)
+//
+//*****************************************************************************
+#define TIMER0_CFG_R            (*((volatile unsigned long *)0x40030000))
+#define TIMER0_TAMR_R           (*((volatile unsigned long *)0x40030004))
+#define TIMER0_TBMR_R           (*((volatile unsigned long *)0x40030008))
+#define TIMER0_CTL_R            (*((volatile unsigned long *)0x4003000C))
+#define TIMER0_IMR_R            (*((volatile unsigned long *)0x40030018))
+#define TIMER0_RIS_R            (*((volatile unsigned long *)0x4003001C))
+#define TIMER0_MIS_R            (*((volatile unsigned long *)0x40030020))
+#define TIMER0_ICR_R            (*((volatile unsigned long *)0x40030024))
+#define TIMER0_TAILR_R          (*((volatile unsigned long *)0x40030028))
+#define TIMER0_TBILR_R          (*((volatile unsigned long *)0x4003002C))
+#define TIMER0_TAMATCHR_R       (*((volatile unsigned long *)0x40030030))
+#define TIMER0_TBMATCHR_R       (*((volatile unsigned long *)0x40030034))
+#define TIMER0_TAPR_R           (*((volatile unsigned long *)0x40030038))
+#define TIMER0_TBPR_R           (*((volatile unsigned long *)0x4003003C))
+#define TIMER0_TAPMR_R          (*((volatile unsigned long *)0x40030040))
+#define TIMER0_TBPMR_R          (*((volatile unsigned long *)0x40030044))
+#define TIMER0_TAR_R            (*((volatile unsigned long *)0x40030048))
+#define TIMER0_TBR_R            (*((volatile unsigned long *)0x4003004C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER1)
+//
+//*****************************************************************************
+#define TIMER1_CFG_R            (*((volatile unsigned long *)0x40031000))
+#define TIMER1_TAMR_R           (*((volatile unsigned long *)0x40031004))
+#define TIMER1_TBMR_R           (*((volatile unsigned long *)0x40031008))
+#define TIMER1_CTL_R            (*((volatile unsigned long *)0x4003100C))
+#define TIMER1_IMR_R            (*((volatile unsigned long *)0x40031018))
+#define TIMER1_RIS_R            (*((volatile unsigned long *)0x4003101C))
+#define TIMER1_MIS_R            (*((volatile unsigned long *)0x40031020))
+#define TIMER1_ICR_R            (*((volatile unsigned long *)0x40031024))
+#define TIMER1_TAILR_R          (*((volatile unsigned long *)0x40031028))
+#define TIMER1_TBILR_R          (*((volatile unsigned long *)0x4003102C))
+#define TIMER1_TAMATCHR_R       (*((volatile unsigned long *)0x40031030))
+#define TIMER1_TBMATCHR_R       (*((volatile unsigned long *)0x40031034))
+#define TIMER1_TAPR_R           (*((volatile unsigned long *)0x40031038))
+#define TIMER1_TBPR_R           (*((volatile unsigned long *)0x4003103C))
+#define TIMER1_TAPMR_R          (*((volatile unsigned long *)0x40031040))
+#define TIMER1_TBPMR_R          (*((volatile unsigned long *)0x40031044))
+#define TIMER1_TAR_R            (*((volatile unsigned long *)0x40031048))
+#define TIMER1_TBR_R            (*((volatile unsigned long *)0x4003104C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER2)
+//
+//*****************************************************************************
+#define TIMER2_CFG_R            (*((volatile unsigned long *)0x40032000))
+#define TIMER2_TAMR_R           (*((volatile unsigned long *)0x40032004))
+#define TIMER2_TBMR_R           (*((volatile unsigned long *)0x40032008))
+#define TIMER2_CTL_R            (*((volatile unsigned long *)0x4003200C))
+#define TIMER2_IMR_R            (*((volatile unsigned long *)0x40032018))
+#define TIMER2_RIS_R            (*((volatile unsigned long *)0x4003201C))
+#define TIMER2_MIS_R            (*((volatile unsigned long *)0x40032020))
+#define TIMER2_ICR_R            (*((volatile unsigned long *)0x40032024))
+#define TIMER2_TAILR_R          (*((volatile unsigned long *)0x40032028))
+#define TIMER2_TBILR_R          (*((volatile unsigned long *)0x4003202C))
+#define TIMER2_TAMATCHR_R       (*((volatile unsigned long *)0x40032030))
+#define TIMER2_TBMATCHR_R       (*((volatile unsigned long *)0x40032034))
+#define TIMER2_TAPR_R           (*((volatile unsigned long *)0x40032038))
+#define TIMER2_TBPR_R           (*((volatile unsigned long *)0x4003203C))
+#define TIMER2_TAPMR_R          (*((volatile unsigned long *)0x40032040))
+#define TIMER2_TBPMR_R          (*((volatile unsigned long *)0x40032044))
+#define TIMER2_TAR_R            (*((volatile unsigned long *)0x40032048))
+#define TIMER2_TBR_R            (*((volatile unsigned long *)0x4003204C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER3)
+//
+//*****************************************************************************
+#define TIMER3_CFG_R            (*((volatile unsigned long *)0x40033000))
+#define TIMER3_TAMR_R           (*((volatile unsigned long *)0x40033004))
+#define TIMER3_TBMR_R           (*((volatile unsigned long *)0x40033008))
+#define TIMER3_CTL_R            (*((volatile unsigned long *)0x4003300C))
+#define TIMER3_IMR_R            (*((volatile unsigned long *)0x40033018))
+#define TIMER3_RIS_R            (*((volatile unsigned long *)0x4003301C))
+#define TIMER3_MIS_R            (*((volatile unsigned long *)0x40033020))
+#define TIMER3_ICR_R            (*((volatile unsigned long *)0x40033024))
+#define TIMER3_TAILR_R          (*((volatile unsigned long *)0x40033028))
+#define TIMER3_TBILR_R          (*((volatile unsigned long *)0x4003302C))
+#define TIMER3_TAMATCHR_R       (*((volatile unsigned long *)0x40033030))
+#define TIMER3_TBMATCHR_R       (*((volatile unsigned long *)0x40033034))
+#define TIMER3_TAPR_R           (*((volatile unsigned long *)0x40033038))
+#define TIMER3_TBPR_R           (*((volatile unsigned long *)0x4003303C))
+#define TIMER3_TAPMR_R          (*((volatile unsigned long *)0x40033040))
+#define TIMER3_TBPMR_R          (*((volatile unsigned long *)0x40033044))
+#define TIMER3_TAR_R            (*((volatile unsigned long *)0x40033048))
+#define TIMER3_TBR_R            (*((volatile unsigned long *)0x4003304C))
+
+//*****************************************************************************
+//
+// Analog-to-Digital Converter (ADC)
+//
+//*****************************************************************************
+#define ADC_ACTSS_R             (*((volatile unsigned long *)0x40038000))
+#define ADC_RIS_R               (*((volatile unsigned long *)0x40038004))
+#define ADC_IM_R                (*((volatile unsigned long *)0x40038008))
+#define ADC_ISC_R               (*((volatile unsigned long *)0x4003800C))
+#define ADC_OSTAT_R             (*((volatile unsigned long *)0x40038010))
+#define ADC_EMUX_R              (*((volatile unsigned long *)0x40038014))
+#define ADC_USTAT_R             (*((volatile unsigned long *)0x40038018))
+#define ADC_SSPRI_R             (*((volatile unsigned long *)0x40038020))
+#define ADC_PSSI_R              (*((volatile unsigned long *)0x40038028))
+#define ADC_SAC_R               (*((volatile unsigned long *)0x40038030))
+#define ADC_SSMUX0_R            (*((volatile unsigned long *)0x40038040))
+#define ADC_SSCTL0_R            (*((volatile unsigned long *)0x40038044))
+#define ADC_SSFIFO0_R           (*((volatile unsigned long *)0x40038048))
+#define ADC_SSFSTAT0_R          (*((volatile unsigned long *)0x4003804C))
+#define ADC_SSMUX1_R            (*((volatile unsigned long *)0x40038060))
+#define ADC_SSCTL1_R            (*((volatile unsigned long *)0x40038064))
+#define ADC_SSFIFO1_R           (*((volatile unsigned long *)0x40038068))
+#define ADC_SSFSTAT1_R          (*((volatile unsigned long *)0x4003806C))
+#define ADC_SSMUX2_R            (*((volatile unsigned long *)0x40038080))
+#define ADC_SSCTL2_R            (*((volatile unsigned long *)0x40038084))
+#define ADC_SSFIFO2_R           (*((volatile unsigned long *)0x40038088))
+#define ADC_SSFSTAT2_R          (*((volatile unsigned long *)0x4003808C))
+#define ADC_SSMUX3_R            (*((volatile unsigned long *)0x400380A0))
+#define ADC_SSCTL3_R            (*((volatile unsigned long *)0x400380A4))
+#define ADC_SSFIFO3_R           (*((volatile unsigned long *)0x400380A8))
+#define ADC_SSFSTAT3_R          (*((volatile unsigned long *)0x400380AC))
+#define ADC_TMLB_R              (*((volatile unsigned long *)0x40038100))
+
+//*****************************************************************************
+//
+// Analog Comparators (COMP)
+//
+//*****************************************************************************
+#define COMP_ACMIS_R            (*((volatile unsigned long *)0x4003C000))
+#define COMP_ACRIS_R            (*((volatile unsigned long *)0x4003C004))
+#define COMP_ACINTEN_R          (*((volatile unsigned long *)0x4003C008))
+#define COMP_ACREFCTL_R         (*((volatile unsigned long *)0x4003C010))
+#define COMP_ACSTAT0_R          (*((volatile unsigned long *)0x4003C020))
+#define COMP_ACCTL0_R           (*((volatile unsigned long *)0x4003C024))
+#define COMP_ACSTAT1_R          (*((volatile unsigned long *)0x4003C040))
+#define COMP_ACCTL1_R           (*((volatile unsigned long *)0x4003C044))
+
+//*****************************************************************************
+//
+// Ethernet Controller (MAC)
+//
+//*****************************************************************************
+#define MAC_MR0_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_RIS_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_IACK_R              (*((volatile unsigned long *)0x40048000))
+#define MAC_MR1_R               (*((volatile unsigned long *)0x40048001))
+#define MAC_MR2_R               (*((volatile unsigned long *)0x40048002))
+#define MAC_MR3_R               (*((volatile unsigned long *)0x40048003))
+#define MAC_IM_R                (*((volatile unsigned long *)0x40048004))
+#define MAC_MR4_R               (*((volatile unsigned long *)0x40048004))
+#define MAC_MR5_R               (*((volatile unsigned long *)0x40048005))
+#define MAC_MR6_R               (*((volatile unsigned long *)0x40048006))
+#define MAC_RCTL_R              (*((volatile unsigned long *)0x40048008))
+#define MAC_TCTL_R              (*((volatile unsigned long *)0x4004800C))
+#define MAC_DATA_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR16_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR17_R              (*((volatile unsigned long *)0x40048011))
+#define MAC_MR18_R              (*((volatile unsigned long *)0x40048012))
+#define MAC_MR19_R              (*((volatile unsigned long *)0x40048013))
+#define MAC_IA0_R               (*((volatile unsigned long *)0x40048014))
+#define MAC_MR23_R              (*((volatile unsigned long *)0x40048017))
+#define MAC_IA1_R               (*((volatile unsigned long *)0x40048018))
+#define MAC_MR24_R              (*((volatile unsigned long *)0x40048018))
+#define MAC_THR_R               (*((volatile unsigned long *)0x4004801C))
+#define MAC_MCTL_R              (*((volatile unsigned long *)0x40048020))
+#define MAC_MDV_R               (*((volatile unsigned long *)0x40048024))
+#define MAC_MTXD_R              (*((volatile unsigned long *)0x4004802C))
+#define MAC_MRXD_R              (*((volatile unsigned long *)0x40048030))
+#define MAC_NP_R                (*((volatile unsigned long *)0x40048034))
+#define MAC_TR_R                (*((volatile unsigned long *)0x40048038))
+
+//*****************************************************************************
+//
+// Hibernation Module (HIB)
+//
+//*****************************************************************************
+#define HIB_RTCC_R              (*((volatile unsigned long *)0x400FC000))
+#define HIB_RTCM0_R             (*((volatile unsigned long *)0x400FC004))
+#define HIB_RTCM1_R             (*((volatile unsigned long *)0x400FC008))
+#define HIB_RTCLD_R             (*((volatile unsigned long *)0x400FC00C))
+#define HIB_CTL_R               (*((volatile unsigned long *)0x400FC010))
+#define HIB_IM_R                (*((volatile unsigned long *)0x400FC014))
+#define HIB_RIS_R               (*((volatile unsigned long *)0x400FC018))
+#define HIB_MIS_R               (*((volatile unsigned long *)0x400FC01C))
+#define HIB_IC_R                (*((volatile unsigned long *)0x400FC020))
+#define HIB_RTCT_R              (*((volatile unsigned long *)0x400FC024))
+#define HIB_DATA_R              (*((volatile unsigned long *)0x400FC030))
+
+//*****************************************************************************
+//
+// Internal Memory (FLASH)
+//
+//*****************************************************************************
+#define FLASH_FMA_R             (*((volatile unsigned long *)0x400FD000))
+#define FLASH_FMD_R             (*((volatile unsigned long *)0x400FD004))
+#define FLASH_FMC_R             (*((volatile unsigned long *)0x400FD008))
+#define FLASH_FCRIS_R           (*((volatile unsigned long *)0x400FD00C))
+#define FLASH_FCIM_R            (*((volatile unsigned long *)0x400FD010))
+#define FLASH_FCMISC_R          (*((volatile unsigned long *)0x400FD014))
+#define FLASH_USECRL_R          (*((volatile unsigned long *)0x400FE140))
+#define FLASH_USERDBG_R         (*((volatile unsigned long *)0x400FE1D0))
+#define FLASH_USERREG0_R        (*((volatile unsigned long *)0x400FE1E0))
+#define FLASH_USERREG1_R        (*((volatile unsigned long *)0x400FE1E4))
+#define FLASH_FMPRE0_R          (*((volatile unsigned long *)0x400FE200))
+#define FLASH_FMPRE1_R          (*((volatile unsigned long *)0x400FE204))
+#define FLASH_FMPRE2_R          (*((volatile unsigned long *)0x400FE208))
+#define FLASH_FMPRE3_R          (*((volatile unsigned long *)0x400FE20C))
+#define FLASH_FMPPE0_R          (*((volatile unsigned long *)0x400FE400))
+#define FLASH_FMPPE1_R          (*((volatile unsigned long *)0x400FE404))
+#define FLASH_FMPPE2_R          (*((volatile unsigned long *)0x400FE408))
+#define FLASH_FMPPE3_R          (*((volatile unsigned long *)0x400FE40C))
+
+//*****************************************************************************
+//
+// System Control (SYSCTL)
+//
+//*****************************************************************************
+#define SYSCTL_DID0_R           (*((volatile unsigned long *)0x400FE000))
+#define SYSCTL_DID1_R           (*((volatile unsigned long *)0x400FE004))
+#define SYSCTL_DC0_R            (*((volatile unsigned long *)0x400FE008))
+#define SYSCTL_DC1_R            (*((volatile unsigned long *)0x400FE010))
+#define SYSCTL_DC2_R            (*((volatile unsigned long *)0x400FE014))
+#define SYSCTL_DC3_R            (*((volatile unsigned long *)0x400FE018))
+#define SYSCTL_DC4_R            (*((volatile unsigned long *)0x400FE01C))
+#define SYSCTL_PBORCTL_R        (*((volatile unsigned long *)0x400FE030))
+#define SYSCTL_LDOPCTL_R        (*((volatile unsigned long *)0x400FE034))
+#define SYSCTL_SRCR0_R          (*((volatile unsigned long *)0x400FE040))
+#define SYSCTL_SRCR1_R          (*((volatile unsigned long *)0x400FE044))
+#define SYSCTL_SRCR2_R          (*((volatile unsigned long *)0x400FE048))
+#define SYSCTL_RIS_R            (*((volatile unsigned long *)0x400FE050))
+#define SYSCTL_IMC_R            (*((volatile unsigned long *)0x400FE054))
+#define SYSCTL_MISC_R           (*((volatile unsigned long *)0x400FE058))
+#define SYSCTL_RESC_R           (*((volatile unsigned long *)0x400FE05C))
+#define SYSCTL_RCC_R            (*((volatile unsigned long *)0x400FE060))
+#define SYSCTL_PLLCFG_R         (*((volatile unsigned long *)0x400FE064))
+#define SYSCTL_RCC2_R           (*((volatile unsigned long *)0x400FE070))
+#define SYSCTL_RCGC0_R          (*((volatile unsigned long *)0x400FE100))
+#define SYSCTL_RCGC1_R          (*((volatile unsigned long *)0x400FE104))
+#define SYSCTL_RCGC2_R          (*((volatile unsigned long *)0x400FE108))
+#define SYSCTL_SCGC0_R          (*((volatile unsigned long *)0x400FE110))
+#define SYSCTL_SCGC1_R          (*((volatile unsigned long *)0x400FE114))
+#define SYSCTL_SCGC2_R          (*((volatile unsigned long *)0x400FE118))
+#define SYSCTL_DCGC0_R          (*((volatile unsigned long *)0x400FE120))
+#define SYSCTL_DCGC1_R          (*((volatile unsigned long *)0x400FE124))
+#define SYSCTL_DCGC2_R          (*((volatile unsigned long *)0x400FE128))
+#define SYSCTL_DSLPCLKCFG_R     (*((volatile unsigned long *)0x400FE144))
+
+//*****************************************************************************
+//
+// Nested Vectored Interrupt Ctrl (NVIC)
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_R         (*((volatile unsigned long *)0xE000E004))
+#define NVIC_ST_CTRL_R          (*((volatile unsigned long *)0xE000E010))
+#define NVIC_ST_RELOAD_R        (*((volatile unsigned long *)0xE000E014))
+#define NVIC_ST_CURRENT_R       (*((volatile unsigned long *)0xE000E018))
+#define NVIC_ST_CAL_R           (*((volatile unsigned long *)0xE000E01C))
+#define NVIC_EN0_R              (*((volatile unsigned long *)0xE000E100))
+#define NVIC_EN1_R              (*((volatile unsigned long *)0xE000E104))
+#define NVIC_DIS0_R             (*((volatile unsigned long *)0xE000E180))
+#define NVIC_DIS1_R             (*((volatile unsigned long *)0xE000E184))
+#define NVIC_PEND0_R            (*((volatile unsigned long *)0xE000E200))
+#define NVIC_PEND1_R            (*((volatile unsigned long *)0xE000E204))
+#define NVIC_UNPEND0_R          (*((volatile unsigned long *)0xE000E280))
+#define NVIC_UNPEND1_R          (*((volatile unsigned long *)0xE000E284))
+#define NVIC_ACTIVE0_R          (*((volatile unsigned long *)0xE000E300))
+#define NVIC_ACTIVE1_R          (*((volatile unsigned long *)0xE000E304))
+#define NVIC_PRI0_R             (*((volatile unsigned long *)0xE000E400))
+#define NVIC_PRI1_R             (*((volatile unsigned long *)0xE000E404))
+#define NVIC_PRI2_R             (*((volatile unsigned long *)0xE000E408))
+#define NVIC_PRI3_R             (*((volatile unsigned long *)0xE000E40C))
+#define NVIC_PRI4_R             (*((volatile unsigned long *)0xE000E410))
+#define NVIC_PRI5_R             (*((volatile unsigned long *)0xE000E414))
+#define NVIC_PRI6_R             (*((volatile unsigned long *)0xE000E418))
+#define NVIC_PRI7_R             (*((volatile unsigned long *)0xE000E41C))
+#define NVIC_PRI8_R             (*((volatile unsigned long *)0xE000E420))
+#define NVIC_PRI9_R             (*((volatile unsigned long *)0xE000E424))
+#define NVIC_PRI10_R            (*((volatile unsigned long *)0xE000E428))
+#define NVIC_CPUID_R            (*((volatile unsigned long *)0xE000ED00))
+#define NVIC_INT_CTRL_R         (*((volatile unsigned long *)0xE000ED04))
+#define NVIC_VTABLE_R           (*((volatile unsigned long *)0xE000ED08))
+#define NVIC_APINT_R            (*((volatile unsigned long *)0xE000ED0C))
+#define NVIC_SYS_CTRL_R         (*((volatile unsigned long *)0xE000ED10))
+#define NVIC_CFG_CTRL_R         (*((volatile unsigned long *)0xE000ED14))
+#define NVIC_SYS_PRI1_R         (*((volatile unsigned long *)0xE000ED18))
+#define NVIC_SYS_PRI2_R         (*((volatile unsigned long *)0xE000ED1C))
+#define NVIC_SYS_PRI3_R         (*((volatile unsigned long *)0xE000ED20))
+#define NVIC_SYS_HND_CTRL_R     (*((volatile unsigned long *)0xE000ED24))
+#define NVIC_FAULT_STAT_R       (*((volatile unsigned long *)0xE000ED28))
+#define NVIC_HFAULT_STAT_R      (*((volatile unsigned long *)0xE000ED2C))
+#define NVIC_DEBUG_STAT_R       (*((volatile unsigned long *)0xE000ED30))
+#define NVIC_MM_ADDR_R          (*((volatile unsigned long *)0xE000ED34))
+#define NVIC_FAULT_ADDR_R       (*((volatile unsigned long *)0xE000ED38))
+#define NVIC_MPU_TYPE_R         (*((volatile unsigned long *)0xE000ED90))
+#define NVIC_MPU_CTRL_R         (*((volatile unsigned long *)0xE000ED94))
+#define NVIC_MPU_NUMBER_R       (*((volatile unsigned long *)0xE000ED98))
+#define NVIC_MPU_R              (*((volatile unsigned long *)0xE000ED9C))
+#define NVIC_MPU_ATTR_R         (*((volatile unsigned long *)0xE000EDA0))
+#define NVIC_DBG_CTRL_R         (*((volatile unsigned long *)0xE000EDF0))
+#define NVIC_DBG_XFER_R         (*((volatile unsigned long *)0xE000EDF4))
+#define NVIC_DBG_DATA_R         (*((volatile unsigned long *)0xE000EDF8))
+#define NVIC_DBG_INT_R          (*((volatile unsigned long *)0xE000EDFC))
+#define NVIC_SW_TRIG_R          (*((volatile unsigned long *)0xE000EF00))
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOAD register.
+//
+//*****************************************************************************
+#define WDT_LOAD_M              0xFFFFFFFF  // Watchdog Load Value.
+#define WDT_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_VALUE register.
+//
+//*****************************************************************************
+#define WDT_VALUE_M             0xFFFFFFFF  // Watchdog Value.
+#define WDT_VALUE_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_CTL register.
+//
+//*****************************************************************************
+#define WDT_CTL_RESEN           0x00000002  // Watchdog Reset Enable.
+#define WDT_CTL_INTEN           0x00000001  // Watchdog Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_ICR register.
+//
+//*****************************************************************************
+#define WDT_ICR_M               0xFFFFFFFF  // Watchdog Interrupt Clear.
+#define WDT_ICR_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_RIS register.
+//
+//*****************************************************************************
+#define WDT_RIS_WDTRIS          0x00000001  // Watchdog Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_MIS register.
+//
+//*****************************************************************************
+#define WDT_MIS_WDTMIS          0x00000001  // Watchdog Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_TEST register.
+//
+//*****************************************************************************
+#define WDT_TEST_STALL          0x00000100  // Watchdog Stall Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOCK register.
+//
+//*****************************************************************************
+#define WDT_LOCK_M              0xFFFFFFFF  // Watchdog Lock.
+#define WDT_LOCK_UNLOCKED       0x00000000  // Unlocked
+#define WDT_LOCK_LOCKED         0x00000001  // Locked
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_O_LOCK register.
+//
+//*****************************************************************************
+#define GPIO_LOCK_M             0xFFFFFFFF  // GPIO Lock.
+#define GPIO_LOCK_UNLOCKED      0x00000000  // unlocked
+#define GPIO_LOCK_LOCKED        0x00000001  // locked
+#define GPIO_LOCK_KEY           0x1ACCE551  // Unlocks the GPIO_CR register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR0 register.
+//
+//*****************************************************************************
+#define SSI_CR0_SCR_M           0x0000FF00  // SSI Serial Clock Rate.
+#define SSI_CR0_SPH             0x00000080  // SSI Serial Clock Phase.
+#define SSI_CR0_SPO             0x00000040  // SSI Serial Clock Polarity.
+#define SSI_CR0_FRF_M           0x00000030  // SSI Frame Format Select.
+#define SSI_CR0_FRF_MOTO        0x00000000  // Freescale SPI Frame Format
+#define SSI_CR0_FRF_TI          0x00000010  // Texas Instruments Synchronous
+                                            // Serial Frame Format
+#define SSI_CR0_FRF_NMW         0x00000020  // MICROWIRE Frame Format
+#define SSI_CR0_DSS_M           0x0000000F  // SSI Data Size Select.
+#define SSI_CR0_DSS_4           0x00000003  // 4-bit data
+#define SSI_CR0_DSS_5           0x00000004  // 5-bit data
+#define SSI_CR0_DSS_6           0x00000005  // 6-bit data
+#define SSI_CR0_DSS_7           0x00000006  // 7-bit data
+#define SSI_CR0_DSS_8           0x00000007  // 8-bit data
+#define SSI_CR0_DSS_9           0x00000008  // 9-bit data
+#define SSI_CR0_DSS_10          0x00000009  // 10-bit data
+#define SSI_CR0_DSS_11          0x0000000A  // 11-bit data
+#define SSI_CR0_DSS_12          0x0000000B  // 12-bit data
+#define SSI_CR0_DSS_13          0x0000000C  // 13-bit data
+#define SSI_CR0_DSS_14          0x0000000D  // 14-bit data
+#define SSI_CR0_DSS_15          0x0000000E  // 15-bit data
+#define SSI_CR0_DSS_16          0x0000000F  // 16-bit data
+#define SSI_CR0_SCR_S           8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR1 register.
+//
+//*****************************************************************************
+#define SSI_CR1_SOD             0x00000008  // SSI Slave Mode Output Disable.
+#define SSI_CR1_MS              0x00000004  // SSI Master/Slave Select.
+#define SSI_CR1_SSE             0x00000002  // SSI Synchronous Serial Port
+                                            // Enable.
+#define SSI_CR1_LBM             0x00000001  // SSI Loopback Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DR register.
+//
+//*****************************************************************************
+#define SSI_DR_DATA_M           0x0000FFFF  // SSI Receive/Transmit Data.
+#define SSI_DR_DATA_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_SR register.
+//
+//*****************************************************************************
+#define SSI_SR_BSY              0x00000010  // SSI Busy Bit.
+#define SSI_SR_RFF              0x00000008  // SSI Receive FIFO Full.
+#define SSI_SR_RNE              0x00000004  // SSI Receive FIFO Not Empty.
+#define SSI_SR_TNF              0x00000002  // SSI Transmit FIFO Not Full.
+#define SSI_SR_TFE              0x00000001  // SSI Transmit FIFO Empty.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CPSR register.
+//
+//*****************************************************************************
+#define SSI_CPSR_CPSDVSR_M      0x000000FF  // SSI Clock Prescale Divisor.
+#define SSI_CPSR_CPSDVSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_IM register.
+//
+//*****************************************************************************
+#define SSI_IM_TXIM             0x00000008  // SSI Transmit FIFO Interrupt
+                                            // Mask.
+#define SSI_IM_RXIM             0x00000004  // SSI Receive FIFO Interrupt Mask.
+#define SSI_IM_RTIM             0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Mask.
+#define SSI_IM_RORIM            0x00000001  // SSI Receive Overrun Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_RIS register.
+//
+//*****************************************************************************
+#define SSI_RIS_TXRIS           0x00000008  // SSI Transmit FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RXRIS           0x00000004  // SSI Receive FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RTRIS           0x00000002  // SSI Receive Time-Out Raw
+                                            // Interrupt Status.
+#define SSI_RIS_RORRIS          0x00000001  // SSI Receive Overrun Raw
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_MIS register.
+//
+//*****************************************************************************
+#define SSI_MIS_TXMIS           0x00000008  // SSI Transmit FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RXMIS           0x00000004  // SSI Receive FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RTMIS           0x00000002  // SSI Receive Time-Out Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RORMIS          0x00000001  // SSI Receive Overrun Masked
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_ICR register.
+//
+//*****************************************************************************
+#define SSI_ICR_RTIC            0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Clear.
+#define SSI_ICR_RORIC           0x00000001  // SSI Receive Overrun Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DR register.
+//
+//*****************************************************************************
+#define UART_DR_OE              0x00000800  // UART Overrun Error.
+#define UART_DR_BE              0x00000400  // UART Break Error.
+#define UART_DR_PE              0x00000200  // UART Parity Error.
+#define UART_DR_FE              0x00000100  // UART Framing Error.
+#define UART_DR_DATA_M          0x000000FF  // Data Transmitted or Received.
+#define UART_DR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RSR register.
+//
+//*****************************************************************************
+#define UART_RSR_OE             0x00000008  // UART Overrun Error.
+#define UART_RSR_BE             0x00000004  // UART Break Error.
+#define UART_RSR_PE             0x00000002  // UART Parity Error.
+#define UART_RSR_FE             0x00000001  // UART Framing Error.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ECR register.
+//
+//*****************************************************************************
+#define UART_ECR_DATA_M         0x000000FF  // Error Clear.
+#define UART_ECR_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FR register.
+//
+//*****************************************************************************
+#define UART_FR_TXFE            0x00000080  // UART Transmit FIFO Empty.
+#define UART_FR_RXFF            0x00000040  // UART Receive FIFO Full.
+#define UART_FR_TXFF            0x00000020  // UART Transmit FIFO Full.
+#define UART_FR_RXFE            0x00000010  // UART Receive FIFO Empty.
+#define UART_FR_BUSY            0x00000008  // UART Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ILPR register.
+//
+//*****************************************************************************
+#define UART_ILPR_ILPDVSR_M     0x000000FF  // IrDA Low-Power Divisor.
+#define UART_ILPR_ILPDVSR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IBRD register.
+//
+//*****************************************************************************
+#define UART_IBRD_DIVINT_M      0x0000FFFF  // Integer Baud-Rate Divisor.
+#define UART_IBRD_DIVINT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FBRD register.
+//
+//*****************************************************************************
+#define UART_FBRD_DIVFRAC_M     0x0000003F  // Fractional Baud-Rate Divisor.
+#define UART_FBRD_DIVFRAC_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCRH register.
+//
+//*****************************************************************************
+#define UART_LCRH_SPS           0x00000080  // UART Stick Parity Select.
+#define UART_LCRH_WLEN_M        0x00000060  // UART Word Length.
+#define UART_LCRH_WLEN_5        0x00000000  // 5 bits (default)
+#define UART_LCRH_WLEN_6        0x00000020  // 6 bits
+#define UART_LCRH_WLEN_7        0x00000040  // 7 bits
+#define UART_LCRH_WLEN_8        0x00000060  // 8 bits
+#define UART_LCRH_FEN           0x00000010  // UART Enable FIFOs.
+#define UART_LCRH_STP2          0x00000008  // UART Two Stop Bits Select.
+#define UART_LCRH_EPS           0x00000004  // UART Even Parity Select.
+#define UART_LCRH_PEN           0x00000002  // UART Parity Enable.
+#define UART_LCRH_BRK           0x00000001  // UART Send Break.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_CTL register.
+//
+//*****************************************************************************
+#define UART_CTL_RXE            0x00000200  // UART Receive Enable.
+#define UART_CTL_TXE            0x00000100  // UART Transmit Enable.
+#define UART_CTL_LBE            0x00000080  // UART Loop Back Enable.
+#define UART_CTL_SIRLP          0x00000004  // UART SIR Low Power Mode.
+#define UART_CTL_SIREN          0x00000002  // UART SIR Enable.
+#define UART_CTL_UARTEN         0x00000001  // UART Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IFLS register.
+//
+//*****************************************************************************
+#define UART_IFLS_RX_M          0x00000038  // UART Receive Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_RX1_8         0x00000000  // RX FIFO &lt;= 1/8 full
+#define UART_IFLS_RX2_8         0x00000008  // RX FIFO &lt;= 1/4 full
+#define UART_IFLS_RX4_8         0x00000010  // RX FIFO &lt;= 1/2 full (default)
+#define UART_IFLS_RX6_8         0x00000018  // RX FIFO &lt;= 3/4 full
+#define UART_IFLS_RX7_8         0x00000020  // RX FIFO &lt;= 7/8 full
+#define UART_IFLS_TX_M          0x00000007  // UART Transmit Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_TX1_8         0x00000000  // TX FIFO &gt;= 1/8 full
+#define UART_IFLS_TX2_8         0x00000001  // TX FIFO &gt;= 1/4 full
+#define UART_IFLS_TX4_8         0x00000002  // TX FIFO &gt;= 1/2 full (default)
+#define UART_IFLS_TX6_8         0x00000003  // TX FIFO &gt;= 3/4 full
+#define UART_IFLS_TX7_8         0x00000004  // TX FIFO &gt;= 7/8 full
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IM register.
+//
+//*****************************************************************************
+#define UART_IM_OEIM            0x00000400  // UART Overrun Error Interrupt
+                                            // Mask.
+#define UART_IM_BEIM            0x00000200  // UART Break Error Interrupt Mask.
+#define UART_IM_PEIM            0x00000100  // UART Parity Error Interrupt
+                                            // Mask.
+#define UART_IM_FEIM            0x00000080  // UART Framing Error Interrupt
+                                            // Mask.
+#define UART_IM_RTIM            0x00000040  // UART Receive Time-Out Interrupt
+                                            // Mask.
+#define UART_IM_TXIM            0x00000020  // UART Transmit Interrupt Mask.
+#define UART_IM_RXIM            0x00000010  // UART Receive Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RIS register.
+//
+//*****************************************************************************
+#define UART_RIS_OERIS          0x00000400  // UART Overrun Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_BERIS          0x00000200  // UART Break Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_PERIS          0x00000100  // UART Parity Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_FERIS          0x00000080  // UART Framing Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_RTRIS          0x00000040  // UART Receive Time-Out Raw
+                                            // Interrupt Status.
+#define UART_RIS_TXRIS          0x00000020  // UART Transmit Raw Interrupt
+                                            // Status.
+#define UART_RIS_RXRIS          0x00000010  // UART Receive Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_MIS register.
+//
+//*****************************************************************************
+#define UART_MIS_OEMIS          0x00000400  // UART Overrun Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_BEMIS          0x00000200  // UART Break Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_PEMIS          0x00000100  // UART Parity Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_FEMIS          0x00000080  // UART Framing Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_RTMIS          0x00000040  // UART Receive Time-Out Masked
+                                            // Interrupt Status.
+#define UART_MIS_TXMIS          0x00000020  // UART Transmit Masked Interrupt
+                                            // Status.
+#define UART_MIS_RXMIS          0x00000010  // UART Receive Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ICR register.
+//
+//*****************************************************************************
+#define UART_ICR_OEIC           0x00000400  // Overrun Error Interrupt Clear.
+#define UART_ICR_BEIC           0x00000200  // Break Error Interrupt Clear.
+#define UART_ICR_PEIC           0x00000100  // Parity Error Interrupt Clear.
+#define UART_ICR_FEIC           0x00000080  // Framing Error Interrupt Clear.
+#define UART_ICR_RTIC           0x00000040  // Receive Time-Out Interrupt
+                                            // Clear.
+#define UART_ICR_TXIC           0x00000020  // Transmit Interrupt Clear.
+#define UART_ICR_RXIC           0x00000010  // Receive Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MSA register.
+//
+//*****************************************************************************
+#define I2C_MSA_SA_M            0x000000FE  // I2C Slave Address.
+#define I2C_MSA_RS              0x00000001  // Receive not send.
+#define I2C_MSA_SA_S            1
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SOAR register.
+//
+//*****************************************************************************
+#define I2C_SOAR_OAR_M          0x0000007F  // I2C Slave Own Address.
+#define I2C_SOAR_OAR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SCSR register.
+//
+//*****************************************************************************
+#define I2C_SCSR_FBR            0x00000004  // First Byte Received.
+#define I2C_SCSR_TREQ           0x00000002  // Transmit Request.
+#define I2C_SCSR_DA             0x00000001  // Device Active.
+#define I2C_SCSR_RREQ           0x00000001  // Receive Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCS register.
+//
+//*****************************************************************************
+#define I2C_MCS_BUSBSY          0x00000040  // Bus Busy.
+#define I2C_MCS_IDLE            0x00000020  // I2C Idle.
+#define I2C_MCS_ARBLST          0x00000010  // Arbitration Lost.
+#define I2C_MCS_ACK             0x00000008  // Data Acknowledge Enable.
+#define I2C_MCS_DATACK          0x00000008  // Acknowledge Data.
+#define I2C_MCS_ADRACK          0x00000004  // Acknowledge Address.
+#define I2C_MCS_STOP            0x00000004  // Generate STOP.
+#define I2C_MCS_START           0x00000002  // Generate START.
+#define I2C_MCS_ERROR           0x00000002  // Error.
+#define I2C_MCS_RUN             0x00000001  // I2C Master Enable.
+#define I2C_MCS_BUSY            0x00000001  // I2C Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SDR register.
+//
+//*****************************************************************************
+#define I2C_SDR_DATA_M          0x000000FF  // Data for Transfer.
+#define I2C_SDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MDR register.
+//
+//*****************************************************************************
+#define I2C_MDR_DATA_M          0x000000FF  // Data Transferred.
+#define I2C_MDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MTPR register.
+//
+//*****************************************************************************
+#define I2C_MTPR_TPR_M          0x000000FF  // SCL Clock Period.
+#define I2C_MTPR_TPR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SIMR register.
+//
+//*****************************************************************************
+#define I2C_SIMR_IM             0x00000001  // Data Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SRIS register.
+//
+//*****************************************************************************
+#define I2C_SRIS_RIS            0x00000001  // Data Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MIMR register.
+//
+//*****************************************************************************
+#define I2C_MIMR_IM             0x00000001  // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MRIS register.
+//
+//*****************************************************************************
+#define I2C_MRIS_RIS            0x00000001  // Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SMIS register.
+//
+//*****************************************************************************
+#define I2C_SMIS_MIS            0x00000001  // Data Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SICR register.
+//
+//*****************************************************************************
+#define I2C_SICR_IC             0x00000001  // Data Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MMIS register.
+//
+//*****************************************************************************
+#define I2C_MMIS_MIS            0x00000001  // Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MICR register.
+//
+//*****************************************************************************
+#define I2C_MICR_IC             0x00000001  // Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCR register.
+//
+//*****************************************************************************
+#define I2C_MCR_SFE             0x00000020  // I2C Slave Function Enable.
+#define I2C_MCR_MFE             0x00000010  // I2C Master Function Enable.
+#define I2C_MCR_LPBK            0x00000001  // I2C Loopback.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CFG register.
+//
+//*****************************************************************************
+#define TIMER_CFG_M             0x00000007  // GPTM Configuration.
+#define TIMER_CFG_32_BIT_TIMER  0x00000000  // 32-bit timer configuration.
+#define TIMER_CFG_32_BIT_RTC    0x00000001  // 32-bit real-time clock (RTC)
+                                            // counter configuration.
+#define TIMER_CFG_16_BIT        0x00000004  // 16-bit timer configuration,
+                                            // function is controlled by bits
+                                            // 1:0 of GPTMTAMR and GPTMTBMR.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMR register.
+//
+//*****************************************************************************
+#define TIMER_TAMR_TAAMS        0x00000008  // GPTM TimerA Alternate Mode
+                                            // Select.
+#define TIMER_TAMR_TACMR        0x00000004  // GPTM TimerA Capture Mode.
+#define TIMER_TAMR_TAMR_M       0x00000003  // GPTM TimerA Mode.
+#define TIMER_TAMR_TAMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TAMR_TAMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TAMR_TAMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMR register.
+//
+//*****************************************************************************
+#define TIMER_TBMR_TBAMS        0x00000008  // GPTM TimerB Alternate Mode
+                                            // Select.
+#define TIMER_TBMR_TBCMR        0x00000004  // GPTM TimerB Capture Mode.
+#define TIMER_TBMR_TBMR_M       0x00000003  // GPTM TimerB Mode.
+#define TIMER_TBMR_TBMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TBMR_TBMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TBMR_TBMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CTL register.
+//
+//*****************************************************************************
+#define TIMER_CTL_TBPWML        0x00004000  // GPTM TimerB PWM Output Level.
+#define TIMER_CTL_TBOTE         0x00002000  // GPTM TimerB Output Trigger
+                                            // Enable.
+#define TIMER_CTL_TBEVENT_M     0x00000C00  // GPTM TimerB Event Mode.
+#define TIMER_CTL_TBEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TBEVENT_NEG   0x00000400  // Negative edge
+#define TIMER_CTL_TBEVENT_BOTH  0x00000C00  // Both edges
+#define TIMER_CTL_TBSTALL       0x00000200  // GPTM TimerB Stall Enable.
+#define TIMER_CTL_TBEN          0x00000100  // GPTM TimerB Enable.
+#define TIMER_CTL_TAPWML        0x00000040  // GPTM TimerA PWM Output Level.
+#define TIMER_CTL_TAOTE         0x00000020  // GPTM TimerA Output Trigger
+                                            // Enable.
+#define TIMER_CTL_RTCEN         0x00000010  // GPTM RTC Enable.
+#define TIMER_CTL_TAEVENT_M     0x0000000C  // GPTM TimerA Event Mode.
+#define TIMER_CTL_TAEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TAEVENT_NEG   0x00000004  // Negative edge
+#define TIMER_CTL_TAEVENT_BOTH  0x0000000C  // Both edges
+#define TIMER_CTL_TASTALL       0x00000002  // GPTM TimerA Stall Enable.
+#define TIMER_CTL_TAEN          0x00000001  // GPTM TimerA Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_IMR register.
+//
+//*****************************************************************************
+#define TIMER_IMR_CBEIM         0x00000400  // GPTM CaptureB Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CBMIM         0x00000200  // GPTM CaptureB Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TBTOIM        0x00000100  // GPTM TimerB Time-Out Interrupt
+                                            // Mask.
+#define TIMER_IMR_RTCIM         0x00000008  // GPTM RTC Interrupt Mask.
+#define TIMER_IMR_CAEIM         0x00000004  // GPTM CaptureA Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CAMIM         0x00000002  // GPTM CaptureA Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TATOIM        0x00000001  // GPTM TimerA Time-Out Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_RIS register.
+//
+//*****************************************************************************
+#define TIMER_RIS_CBERIS        0x00000400  // GPTM CaptureB Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CBMRIS        0x00000200  // GPTM CaptureB Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TBTORIS       0x00000100  // GPTM TimerB Time-Out Raw
+                                            // Interrupt.
+#define TIMER_RIS_RTCRIS        0x00000008  // GPTM RTC Raw Interrupt.
+#define TIMER_RIS_CAERIS        0x00000004  // GPTM CaptureA Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CAMRIS        0x00000002  // GPTM CaptureA Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TATORIS       0x00000001  // GPTM TimerA Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_MIS register.
+//
+//*****************************************************************************
+#define TIMER_MIS_CBEMIS        0x00000400  // GPTM CaptureB Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CBMMIS        0x00000200  // GPTM CaptureB Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TBTOMIS       0x00000100  // GPTM TimerB Time-Out Masked
+                                            // Interrupt.
+#define TIMER_MIS_RTCMIS        0x00000008  // GPTM RTC Masked Interrupt.
+#define TIMER_MIS_CAEMIS        0x00000004  // GPTM CaptureA Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CAMMIS        0x00000002  // GPTM CaptureA Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TATOMIS       0x00000001  // GPTM TimerA Time-Out Masked
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_ICR register.
+//
+//*****************************************************************************
+#define TIMER_ICR_CBECINT       0x00000400  // GPTM CaptureB Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CBMCINT       0x00000200  // GPTM CaptureB Match Interrupt
+                                            // Clear.
+#define TIMER_ICR_TBTOCINT      0x00000100  // GPTM TimerB Time-Out Interrupt
+                                            // Clear.
+#define TIMER_ICR_RTCCINT       0x00000008  // GPTM RTC Interrupt Clear.
+#define TIMER_ICR_CAECINT       0x00000004  // GPTM CaptureA Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CAMCINT       0x00000002  // GPTM CaptureA Match Raw
+                                            // Interrupt.
+#define TIMER_ICR_TATOCINT      0x00000001  // GPTM TimerA Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAILR register.
+//
+//*****************************************************************************
+#define TIMER_TAILR_TAILRH_M    0xFFFF0000  // GPTM TimerA Interval Load
+                                            // Register High.
+#define TIMER_TAILR_TAILRL_M    0x0000FFFF  // GPTM TimerA Interval Load
+                                            // Register Low.
+#define TIMER_TAILR_TAILRH_S    16
+#define TIMER_TAILR_TAILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBILR register.
+//
+//*****************************************************************************
+#define TIMER_TBILR_TBILRL_M    0x0000FFFF  // GPTM TimerB Interval Load
+                                            // Register.
+#define TIMER_TBILR_TBILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TAMATCHR_TAMRH_M  0xFFFF0000  // GPTM TimerA Match Register High.
+#define TIMER_TAMATCHR_TAMRL_M  0x0000FFFF  // GPTM TimerA Match Register Low.
+#define TIMER_TAMATCHR_TAMRH_S  16
+#define TIMER_TAMATCHR_TAMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TBMATCHR_TBMRL_M  0x0000FFFF  // GPTM TimerB Match Register Low.
+#define TIMER_TBMATCHR_TBMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPR register.
+//
+//*****************************************************************************
+#define TIMER_TAPR_TAPSR_M      0x000000FF  // GPTM TimerA Prescale.
+#define TIMER_TAPR_TAPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPR register.
+//
+//*****************************************************************************
+#define TIMER_TBPR_TBPSR_M      0x000000FF  // GPTM TimerB Prescale.
+#define TIMER_TBPR_TBPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPMR register.
+//
+//*****************************************************************************
+#define TIMER_TAPMR_TAPSMR_M    0x000000FF  // GPTM TimerA Prescale Match.
+#define TIMER_TAPMR_TAPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPMR register.
+//
+//*****************************************************************************
+#define TIMER_TBPMR_TBPSMR_M    0x000000FF  // GPTM TimerB Prescale Match.
+#define TIMER_TBPMR_TBPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAR register.
+//
+//*****************************************************************************
+#define TIMER_TAR_TARH_M        0xFFFF0000  // GPTM TimerA Register High.
+#define TIMER_TAR_TARL_M        0x0000FFFF  // GPTM TimerA Register Low.
+#define TIMER_TAR_TARH_S        16
+#define TIMER_TAR_TARL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBR register.
+//
+//*****************************************************************************
+#define TIMER_TBR_TBRL_M        0x0000FFFF  // GPTM TimerB.
+#define TIMER_TBR_TBRL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ACTSS register.
+//
+//*****************************************************************************
+#define ADC_ACTSS_ASEN3         0x00000008  // ADC SS3 Enable.
+#define ADC_ACTSS_ASEN2         0x00000004  // ADC SS2 Enable.
+#define ADC_ACTSS_ASEN1         0x00000002  // ADC SS1 Enable.
+#define ADC_ACTSS_ASEN0         0x00000001  // ADC SS0 Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_RIS register.
+//
+//*****************************************************************************
+#define ADC_RIS_INR3            0x00000008  // SS3 Raw Interrupt Status.
+#define ADC_RIS_INR2            0x00000004  // SS2 Raw Interrupt Status.
+#define ADC_RIS_INR1            0x00000002  // SS1 Raw Interrupt Status.
+#define ADC_RIS_INR0            0x00000001  // SS0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_IM register.
+//
+//*****************************************************************************
+#define ADC_IM_MASK3            0x00000008  // SS3 Interrupt Mask.
+#define ADC_IM_MASK2            0x00000004  // SS2 Interrupt Mask.
+#define ADC_IM_MASK1            0x00000002  // SS1 Interrupt Mask.
+#define ADC_IM_MASK0            0x00000001  // SS0 Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ISC register.
+//
+//*****************************************************************************
+#define ADC_ISC_IN3             0x00000008  // SS3 Interrupt Status and Clear.
+#define ADC_ISC_IN2             0x00000004  // SS2 Interrupt Status and Clear.
+#define ADC_ISC_IN1             0x00000002  // SS1 Interrupt Status and Clear.
+#define ADC_ISC_IN0             0x00000001  // SS0 Interrupt Status and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_OSTAT register.
+//
+//*****************************************************************************
+#define ADC_OSTAT_OV3           0x00000008  // SS3 FIFO Overflow.
+#define ADC_OSTAT_OV2           0x00000004  // SS2 FIFO Overflow.
+#define ADC_OSTAT_OV1           0x00000002  // SS1 FIFO Overflow.
+#define ADC_OSTAT_OV0           0x00000001  // SS0 FIFO Overflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_EMUX register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_M          0x0000F000  // SS3 Trigger Select.
+#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog Comparator 0
+#define ADC_EMUX_EM3_COMP1      0x00002000  // Analog Comparator 1
+#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External (GPIO PB4)
+#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer
+#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always (continuously sample)
+#define ADC_EMUX_EM2_M          0x00000F00  // SS2 Trigger Select.
+#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog Comparator 0
+#define ADC_EMUX_EM2_COMP1      0x00000200  // Analog Comparator 1
+#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External (GPIO PB4)
+#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer
+#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always (continuously sample)
+#define ADC_EMUX_EM1_M          0x000000F0  // SS1 Trigger Select.
+#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog Comparator 0
+#define ADC_EMUX_EM1_COMP1      0x00000020  // Analog Comparator 1
+#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External (GPIO PB4)
+#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer
+#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always (continuously sample)
+#define ADC_EMUX_EM0_M          0x0000000F  // SS0 Trigger Select.
+#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog Comparator 0
+#define ADC_EMUX_EM0_COMP1      0x00000002  // Analog Comparator 1
+#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External (GPIO PB4)
+#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer
+#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always (continuously sample)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_USTAT register.
+//
+//*****************************************************************************
+#define ADC_USTAT_UV3           0x00000008  // SS3 FIFO Underflow.
+#define ADC_USTAT_UV2           0x00000004  // SS2 FIFO Underflow.
+#define ADC_USTAT_UV1           0x00000002  // SS1 FIFO Underflow.
+#define ADC_USTAT_UV0           0x00000001  // SS0 FIFO Underflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSPRI register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_M         0x00003000  // SS3 Priority.
+#define ADC_SSPRI_SS3_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS3_2ND       0x00001000  // Second priority
+#define ADC_SSPRI_SS3_3RD       0x00002000  // Third priority
+#define ADC_SSPRI_SS3_4TH       0x00003000  // Fourth priority
+#define ADC_SSPRI_SS2_M         0x00000300  // SS2 Priority.
+#define ADC_SSPRI_SS2_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS2_2ND       0x00000100  // Second priority
+#define ADC_SSPRI_SS2_3RD       0x00000200  // Third priority
+#define ADC_SSPRI_SS2_4TH       0x00000300  // Fourth priority
+#define ADC_SSPRI_SS1_M         0x00000030  // SS1 Priority.
+#define ADC_SSPRI_SS1_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS1_2ND       0x00000010  // Second priority
+#define ADC_SSPRI_SS1_3RD       0x00000020  // Third priority
+#define ADC_SSPRI_SS1_4TH       0x00000030  // Fourth priority
+#define ADC_SSPRI_SS0_M         0x00000003  // SS0 Priority.
+#define ADC_SSPRI_SS0_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS0_2ND       0x00000001  // Second priority
+#define ADC_SSPRI_SS0_3RD       0x00000002  // Third priority
+#define ADC_SSPRI_SS0_4TH       0x00000003  // Fourth priority
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_PSSI register.
+//
+//*****************************************************************************
+#define ADC_PSSI_SS3            0x00000008  // SS3 Initiate.
+#define ADC_PSSI_SS2            0x00000004  // SS2 Initiate.
+#define ADC_PSSI_SS1            0x00000002  // SS1 Initiate.
+#define ADC_PSSI_SS0            0x00000001  // SS0 Initiate.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SAC register.
+//
+//*****************************************************************************
+#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control.
+#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
+#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
+#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
+#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
+#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
+#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
+#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX0_MUX7_M       0x70000000  // 8th Sample Input Select.
+#define ADC_SSMUX0_MUX6_M       0x07000000  // 7th Sample Input Select.
+#define ADC_SSMUX0_MUX5_M       0x00700000  // 6th Sample Input Select.
+#define ADC_SSMUX0_MUX4_M       0x00070000  // 5th Sample Input Select.
+#define ADC_SSMUX0_MUX3_M       0x00007000  // 4th Sample Input Select.
+#define ADC_SSMUX0_MUX2_M       0x00000700  // 3rd Sample Input Select.
+#define ADC_SSMUX0_MUX1_M       0x00000070  // 2nd Sample Input Select.
+#define ADC_SSMUX0_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX0_MUX7_S       28
+#define ADC_SSMUX0_MUX6_S       24
+#define ADC_SSMUX0_MUX5_S       20
+#define ADC_SSMUX0_MUX4_S       16
+#define ADC_SSMUX0_MUX3_S       12
+#define ADC_SSMUX0_MUX2_S       8
+#define ADC_SSMUX0_MUX1_S       4
+#define ADC_SSMUX0_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable.
+#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence.
+#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Diff Input Select.
+#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable.
+#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence.
+#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Diff Input Select.
+#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable.
+#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence.
+#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Diff Input Select.
+#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable.
+#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence.
+#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Diff Input Select.
+#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO0_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT0_HPTR_S     4
+#define ADC_SSFSTAT0_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX1_MUX3_M       0x00007000  // 4th Sample Input Select.
+#define ADC_SSMUX1_MUX2_M       0x00000700  // 3rd Sample Input Select.
+#define ADC_SSMUX1_MUX1_M       0x00000070  // 2nd Sample Input Select.
+#define ADC_SSMUX1_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX1_MUX3_S       12
+#define ADC_SSMUX1_MUX2_S       8
+#define ADC_SSMUX1_MUX1_S       4
+#define ADC_SSMUX1_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO1_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT1_HPTR_S     4
+#define ADC_SSFSTAT1_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX2_MUX3_M       0x00007000  // 4th Sample Input Select.
+#define ADC_SSMUX2_MUX2_M       0x00000700  // 3rd Sample Input Select.
+#define ADC_SSMUX2_MUX1_M       0x00000070  // 2nd Sample Input Select.
+#define ADC_SSMUX2_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX2_MUX3_S       12
+#define ADC_SSMUX2_MUX2_S       8
+#define ADC_SSMUX2_MUX1_S       4
+#define ADC_SSMUX2_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO2_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT2_HPTR_S     4
+#define ADC_SSFSTAT2_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX3_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX3_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL3_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL3_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL3_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO3_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT3_HPTR_S     4
+#define ADC_SSFSTAT3_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_TMLB register.
+//
+//*****************************************************************************
+#define ADC_TMLB_LB             0x00000001  // Loopback Mode Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_TMLB_CNT_M   0x000003C0  // Continuous Sample Counter.
+#define ADC_SSFIFO_TMLB_CONT    0x00000020  // Continuation Sample Indicator.
+#define ADC_SSFIFO_TMLB_DIFF    0x00000010  // Differential Sample Indicator.
+#define ADC_SSFIFO_TMLB_TS      0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_SSFIFO_TMLB_MUX_M   0x00000007  // Analog Input Indicator.
+#define ADC_SSFIFO_TMLB_CNT_S   6           // Sample counter shift
+#define ADC_SSFIFO_TMLB_MUX_S   0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_TMLB_CNT_M          0x000003C0  // Continuous Sample Counter.
+#define ADC_TMLB_CONT           0x00000020  // Continuation Sample Indicator.
+#define ADC_TMLB_DIFF           0x00000010  // Differential Sample Indicator.
+#define ADC_TMLB_TS             0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_TMLB_MUX_M          0x00000007  // Analog Input Indicator.
+#define ADC_TMLB_CNT_S          6           // Sample counter shift
+#define ADC_TMLB_MUX_S          0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACMIS register.
+//
+//*****************************************************************************
+#define COMP_ACMIS_IN1          0x00000002  // Comparator 1 Masked Interrupt
+                                            // Status.
+#define COMP_ACMIS_IN0          0x00000001  // Comparator 0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACRIS register.
+//
+//*****************************************************************************
+#define COMP_ACRIS_IN1          0x00000002  // Comparator 1 Interrupt Status.
+#define COMP_ACRIS_IN0          0x00000001  // Comparator 0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACINTEN register.
+//
+//*****************************************************************************
+#define COMP_ACINTEN_IN1        0x00000002  // Comparator 1 Interrupt Enable.
+#define COMP_ACINTEN_IN0        0x00000001  // Comparator 0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACREFCTL
+// register.
+//
+//*****************************************************************************
+#define COMP_ACREFCTL_EN        0x00000200  // Resistor Ladder Enable.
+#define COMP_ACREFCTL_RNG       0x00000100  // Resistor Ladder Range.
+#define COMP_ACREFCTL_VREF_M    0x0000000F  // Resistor Ladder Voltage Ref.
+#define COMP_ACREFCTL_VREF_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT0 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT0_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL0 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL0_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL0_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL0_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL0_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL0_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL0_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL0_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL0_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL0_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL0_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL0_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL0_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL0_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL0_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL0_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL0_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL0_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL0_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT1 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT1_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL1 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL1_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL1_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL1_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL1_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL1_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL1_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL1_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL1_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL1_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL1_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL1_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL1_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL1_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL1_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL1_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL1_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL1_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL1_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR0 register.
+//
+//*****************************************************************************
+#define PHY_MR0_RESET           0x00008000  // Reset Registers.
+#define PHY_MR0_LOOPBK          0x00004000  // Loopback Mode.
+#define PHY_MR0_SPEEDSL         0x00002000  // Speed Select.
+#define PHY_MR0_ANEGEN          0x00001000  // Auto-Negotiation Enable.
+#define PHY_MR0_PWRDN           0x00000800  // Power Down.
+#define PHY_MR0_ISO             0x00000400  // Isolate.
+#define PHY_MR0_RANEG           0x00000200  // Restart Auto-Negotiation.
+#define PHY_MR0_DUPLEX          0x00000100  // Set Duplex Mode.
+#define PHY_MR0_COLT            0x00000080  // Collision Test.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RIS register.
+//
+//*****************************************************************************
+#define MAC_RIS_PHYINT          0x00000040  // PHY Interrupt.
+#define MAC_RIS_MDINT           0x00000020  // MII Transaction Complete.
+#define MAC_RIS_RXER            0x00000010  // Receive Error.
+#define MAC_RIS_FOV             0x00000008  // FIFO Overrun.
+#define MAC_RIS_TXEMP           0x00000004  // Transmit FIFO Empty.
+#define MAC_RIS_TXER            0x00000002  // Transmit Error.
+#define MAC_RIS_RXINT           0x00000001  // Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IACK register.
+//
+//*****************************************************************************
+#define MAC_IACK_PHYINT         0x00000040  // Clear PHY Interrupt.
+#define MAC_IACK_MDINT          0x00000020  // Clear MII Transaction Complete.
+#define MAC_IACK_RXER           0x00000010  // Clear Receive Error.
+#define MAC_IACK_FOV            0x00000008  // Clear FIFO Overrun.
+#define MAC_IACK_TXEMP          0x00000004  // Clear Transmit FIFO Empty.
+#define MAC_IACK_TXER           0x00000002  // Clear Transmit Error.
+#define MAC_IACK_RXINT          0x00000001  // Clear Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR1 register.
+//
+//*****************************************************************************
+#define PHY_MR1_100X_F          0x00004000  // 100BASE-TX Full-Duplex Mode.
+#define PHY_MR1_100X_H          0x00002000  // 100BASE-TX Half-Duplex Mode.
+#define PHY_MR1_10T_F           0x00001000  // 10BASE-T Full-Duplex Mode.
+#define PHY_MR1_10T_H           0x00000800  // 10BASE-T Half-Duplex Mode.
+#define PHY_MR1_MFPS            0x00000040  // Management Frames with Preamble
+                                            // Suppressed.
+#define PHY_MR1_ANEGC           0x00000020  // Auto-Negotiation Complete.
+#define PHY_MR1_RFAULT          0x00000010  // Remote Fault.
+#define PHY_MR1_ANEGA           0x00000008  // Auto-Negotiation.
+#define PHY_MR1_LINK            0x00000004  // Link Made.
+#define PHY_MR1_JAB             0x00000002  // Jabber Condition.
+#define PHY_MR1_EXTD            0x00000001  // Extended Capabilities.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR2 register.
+//
+//*****************************************************************************
+#define PHY_MR2_OUI_M           0x0000FFFF  // Organizationally Unique
+                                            // Identifier[21:6].
+#define PHY_MR2_OUI_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR3 register.
+//
+//*****************************************************************************
+#define PHY_MR3_OUI_M           0x0000FC00  // Organizationally Unique
+                                            // Identifier[5:0].
+#define PHY_MR3_MN_M            0x000003F0  // Model Number.
+#define PHY_MR3_RN_M            0x0000000F  // Revision Number.
+#define PHY_MR3_OUI_S           10
+#define PHY_MR3_MN_S            4
+#define PHY_MR3_RN_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IM register.
+//
+//*****************************************************************************
+#define MAC_IM_PHYINTM          0x00000040  // Mask PHY Interrupt.
+#define MAC_IM_MDINTM           0x00000020  // Mask MII Transaction Complete.
+#define MAC_IM_RXERM            0x00000010  // Mask Receive Error.
+#define MAC_IM_FOVM             0x00000008  // Mask FIFO Overrun.
+#define MAC_IM_TXEMPM           0x00000004  // Mask Transmit FIFO Empty.
+#define MAC_IM_TXERM            0x00000002  // Mask Transmit Error.
+#define MAC_IM_RXINTM           0x00000001  // Mask Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR4 register.
+//
+//*****************************************************************************
+#define PHY_MR4_NP              0x00008000  // Next Page.
+#define PHY_MR4_RF              0x00002000  // Remote Fault.
+#define PHY_MR4_A3              0x00000100  // Technology Ability Field[3].
+#define PHY_MR4_A2              0x00000080  // Technology Ability Field[2].
+#define PHY_MR4_A1              0x00000040  // Technology Ability Field[1].
+#define PHY_MR4_A0              0x00000020  // Technology Ability Field[0].
+#define PHY_MR4_S_M             0x0000001F  // Selector Field.
+#define PHY_MR4_S_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR5 register.
+//
+//*****************************************************************************
+#define PHY_MR5_NP              0x00008000  // Next Page.
+#define PHY_MR5_ACK             0x00004000  // Acknowledge.
+#define PHY_MR5_RF              0x00002000  // Remote Fault.
+#define PHY_MR5_A_M             0x00001FE0  // Technology Ability Field.
+#define PHY_MR5_S_M             0x0000001F  // Selector Field.
+#define PHY_MR5_S_8023          0x00000001  // IEEE Std 802.3
+#define PHY_MR5_S_8029          0x00000002  // IEEE Std 802.9 ISLAN-16T
+#define PHY_MR5_S_8025          0x00000003  // IEEE Std 802.5
+#define PHY_MR5_S_1394          0x00000004  // IEEE Std 1394
+#define PHY_MR5_A_S             5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR6 register.
+//
+//*****************************************************************************
+#define PHY_MR6_PDF             0x00000010  // Parallel Detection Fault.
+#define PHY_MR6_LPNPA           0x00000008  // Link Partner is Next Page Able.
+#define PHY_MR6_PRX             0x00000002  // New Page Received.
+#define PHY_MR6_LPANEGA         0x00000001  // Link Partner is Auto-Negotiation
+                                            // Able.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RCTL register.
+//
+//*****************************************************************************
+#define MAC_RCTL_RSTFIFO        0x00000010  // Clear Receive FIFO.
+#define MAC_RCTL_BADCRC         0x00000008  // Enable Reject Bad CRC.
+#define MAC_RCTL_PRMS           0x00000004  // Enable Promiscuous Mode.
+#define MAC_RCTL_AMUL           0x00000002  // Enable Multicast Frames.
+#define MAC_RCTL_RXEN           0x00000001  // Enable Receiver.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TCTL register.
+//
+//*****************************************************************************
+#define MAC_TCTL_DUPLEX         0x00000010  // Enable Duplex Mode.
+#define MAC_TCTL_CRC            0x00000004  // Enable CRC Generation.
+#define MAC_TCTL_PADEN          0x00000002  // Enable Packet Padding.
+#define MAC_TCTL_TXEN           0x00000001  // Enable Transmitter.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_DATA register.
+//
+//*****************************************************************************
+#define MAC_DATA_TXDATA_M       0xFFFFFFFF  // Transmit FIFO Data.
+#define MAC_DATA_RXDATA_M       0xFFFFFFFF  // Receive FIFO Data.
+#define MAC_DATA_RXDATA_S       0
+#define MAC_DATA_TXDATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR16 register.
+//
+//*****************************************************************************
+#define PHY_MR16_RPTR           0x00008000  // Repeater Mode.
+#define PHY_MR16_INPOL          0x00004000  // Interrupt Polarity.
+#define PHY_MR16_TXHIM          0x00001000  // Transmit High Impedance Mode.
+#define PHY_MR16_SQEI           0x00000800  // SQE Inhibit Testing.
+#define PHY_MR16_NL10           0x00000400  // Natural Loopback Mode.
+#define PHY_MR16_APOL           0x00000020  // Auto-Polarity Disable.
+#define PHY_MR16_RVSPOL         0x00000010  // Receive Data Polarity.
+#define PHY_MR16_PCSBP          0x00000002  // PCS Bypass.
+#define PHY_MR16_RXCC           0x00000001  // Receive Clock Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR17 register.
+//
+//*****************************************************************************
+#define PHY_MR17_JABBER_IE      0x00008000  // Jabber Interrupt Enable.
+#define PHY_MR17_RXER_IE        0x00004000  // Receive Error Interrupt Enable.
+#define PHY_MR17_PRX_IE         0x00002000  // Page Received Interrupt Enable.
+#define PHY_MR17_PDF_IE         0x00001000  // Parallel Detection Fault
+                                            // Interrupt Enable.
+#define PHY_MR17_LPACK_IE       0x00000800  // LP Acknowledge Interrupt Enable.
+#define PHY_MR17_LSCHG_IE       0x00000400  // Link Status Change Interrupt
+                                            // Enable.
+#define PHY_MR17_RFAULT_IE      0x00000200  // Remote Fault Interrupt Enable.
+#define PHY_MR17_ANEGCOMP_IE    0x00000100  // Auto-Negotiation Complete
+                                            // Interrupt Enable.
+#define PHY_MR17_JABBER_INT     0x00000080  // Jabber Event Interrupt.
+#define PHY_MR17_RXER_INT       0x00000040  // Receive Error Interrupt.
+#define PHY_MR17_PRX_INT        0x00000020  // Page Receive Interrupt.
+#define PHY_MR17_PDF_INT        0x00000010  // Parallel Detection Fault
+                                            // Interrupt.
+#define PHY_MR17_LPACK_INT      0x00000008  // LP Acknowledge Interrupt.
+#define PHY_MR17_LSCHG_INT      0x00000004  // Link Status Change Interrupt.
+#define PHY_MR17_RFAULT_INT     0x00000002  // Remote Fault Interrupt.
+#define PHY_MR17_ANEGCOMP_INT   0x00000001  // Auto-Negotiation Complete
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR18 register.
+//
+//*****************************************************************************
+#define PHY_MR18_ANEGF          0x00001000  // Auto-Negotiation Failure.
+#define PHY_MR18_DPLX           0x00000800  // Duplex Mode.
+#define PHY_MR18_RATE           0x00000400  // Rate.
+#define PHY_MR18_RXSD           0x00000200  // Receive Detection.
+#define PHY_MR18_RX_LOCK        0x00000100  // Receive PLL Lock.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR19 register.
+//
+//*****************************************************************************
+#define PHY_MR19_TXO_M          0x0000C000  // Transmit Amplitude Selection.
+#define PHY_MR19_TXO_00DB       0x00000000  // Gain set for 0.0dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_04DB       0x00004000  // Gain set for 0.4dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_08DB       0x00008000  // Gain set for 0.8dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_12DB       0x0000C000  // Gain set for 1.2dB of insertion
+                                            // loss
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA0 register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4_M       0xFF000000  // MAC Address Octet 4.
+#define MAC_IA0_MACOCT3_M       0x00FF0000  // MAC Address Octet 3.
+#define MAC_IA0_MACOCT2_M       0x0000FF00  // MAC Address Octet 2.
+#define MAC_IA0_MACOCT1_M       0x000000FF  // MAC Address Octet 1.
+#define MAC_IA0_MACOCT4_S       24
+#define MAC_IA0_MACOCT3_S       16
+#define MAC_IA0_MACOCT2_S       8
+#define MAC_IA0_MACOCT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR23 register.
+//
+//*****************************************************************************
+#define PHY_MR23_LED1_M         0x000000F0  // LED1 Source.
+#define PHY_MR23_LED1_LINK      0x00000000  // Link OK
+#define PHY_MR23_LED1_RXTX      0x00000010  // RX or TX Activity (Default LED1)
+#define PHY_MR23_LED1_100       0x00000050  // 100BASE-TX mode
+#define PHY_MR23_LED1_10        0x00000060  // 10BASE-T mode
+#define PHY_MR23_LED1_DUPLEX    0x00000070  // Full-Duplex
+#define PHY_MR23_LED1_LINKACT   0x00000080  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+#define PHY_MR23_LED0_M         0x0000000F  // LED0 Source.
+#define PHY_MR23_LED0_LINK      0x00000000  // Link OK (Default LED0)
+#define PHY_MR23_LED0_RXTX      0x00000001  // RX or TX Activity
+#define PHY_MR23_LED0_100       0x00000005  // 100BASE-TX mode
+#define PHY_MR23_LED0_10        0x00000006  // 10BASE-T mode
+#define PHY_MR23_LED0_DUPLEX    0x00000007  // Full-Duplex
+#define PHY_MR23_LED0_LINKACT   0x00000008  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA1 register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6_M       0x0000FF00  // MAC Address Octet 6.
+#define MAC_IA1_MACOCT5_M       0x000000FF  // MAC Address Octet 5.
+#define MAC_IA1_MACOCT6_S       8
+#define MAC_IA1_MACOCT5_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR24 register.
+//
+//*****************************************************************************
+#define PHY_MR24_PD_MODE        0x00000080  // Parallel Detection Mode.
+#define PHY_MR24_AUTO_SW        0x00000040  // Auto-Switching Enable.
+#define PHY_MR24_MDIX           0x00000020  // Auto-Switching Configuration.
+#define PHY_MR24_MDIX_CM        0x00000010  // Auto-Switching Complete.
+#define PHY_MR24_MDIX_SD_M      0x0000000F  // Auto-Switching Seed.
+#define PHY_MR24_MDIX_SD_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_THR register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH_M        0x0000003F  // Threshold Value.
+#define MAC_THR_THRESH_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MCTL register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR_M       0x000000F8  // MII Register Address.
+#define MAC_MCTL_WRITE          0x00000002  // MII Register Transaction Type.
+#define MAC_MCTL_START          0x00000001  // MII Register Transaction Enable.
+#define MAC_MCTL_REGADR_S       3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MDV register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV_M           0x000000FF  // Clock Divider.
+#define MAC_MDV_DIV_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MTXD register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX_M         0x0000FFFF  // MII Register Transmit Data.
+#define MAC_MTXD_MDTX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MRXD register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX_M         0x0000FFFF  // MII Register Receive Data.
+#define MAC_MRXD_MDRX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_NP register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR_M            0x0000003F  // Number of Packets in Receive
+                                            // FIFO.
+#define MAC_NP_NPR_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TR register.
+//
+//*****************************************************************************
+#define MAC_TR_NEWTX            0x00000001  // New Transmission.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCC register.
+//
+//*****************************************************************************
+#define HIB_RTCC_M              0xFFFFFFFF  // RTC Counter.
+#define HIB_RTCC_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCM0 register.
+//
+//*****************************************************************************
+#define HIB_RTCM0_M             0xFFFFFFFF  // RTC Match 0.
+#define HIB_RTCM0_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCM1 register.
+//
+//*****************************************************************************
+#define HIB_RTCM1_M             0xFFFFFFFF  // RTC Match 1.
+#define HIB_RTCM1_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCLD register.
+//
+//*****************************************************************************
+#define HIB_RTCLD_M             0xFFFFFFFF  // RTC Load.
+#define HIB_RTCLD_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CTL register.
+//
+//*****************************************************************************
+#define HIB_CTL_VABORT          0x00000080  // Power Cut Abort Enable.
+#define HIB_CTL_CLK32EN         0x00000040  // Clocking Enable.
+#define HIB_CTL_LOWBATEN        0x00000020  // Low Battery Monitoring Enable.
+#define HIB_CTL_PINWEN          0x00000010  // External WAKE Pin Enable.
+#define HIB_CTL_RTCWEN          0x00000008  // RTC Wake-up Enable.
+#define HIB_CTL_CLKSEL          0x00000004  // Hibernation Module Clock Select.
+#define HIB_CTL_HIBREQ          0x00000002  // Hibernation Request.
+#define HIB_CTL_RTCEN           0x00000001  // RTC Timer Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IM register.
+//
+//*****************************************************************************
+#define HIB_IM_EXTW             0x00000008  // External Wake-Up Interrupt Mask.
+#define HIB_IM_LOWBAT           0x00000004  // Low Battery Voltage Interrupt
+                                            // Mask.
+#define HIB_IM_RTCALT1          0x00000002  // RTC Alert1 Interrupt Mask.
+#define HIB_IM_RTCALT0          0x00000001  // RTC Alert0 Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RIS register.
+//
+//*****************************************************************************
+#define HIB_RIS_EXTW            0x00000008  // External Wake-Up Raw Interrupt
+                                            // Status.
+#define HIB_RIS_LOWBAT          0x00000004  // Low Battery Voltage Raw
+                                            // Interrupt Status.
+#define HIB_RIS_RTCALT1         0x00000002  // RTC Alert1 Raw Interrupt Status.
+#define HIB_RIS_RTCALT0         0x00000001  // RTC Alert0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_MIS register.
+//
+//*****************************************************************************
+#define HIB_MIS_EXTW            0x00000008  // External Wake-Up Masked
+                                            // Interrupt Status.
+#define HIB_MIS_LOWBAT          0x00000004  // Low Battery Voltage Masked
+                                            // Interrupt Status.
+#define HIB_MIS_RTCALT1         0x00000002  // RTC Alert1 Masked Interrupt
+                                            // Status.
+#define HIB_MIS_RTCALT0         0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IC register.
+//
+//*****************************************************************************
+#define HIB_IC_EXTW             0x00000008  // External Wake-Up Masked
+                                            // Interrupt Clear.
+#define HIB_IC_LOWBAT           0x00000004  // Low Battery Voltage Masked
+                                            // Interrupt Clear.
+#define HIB_IC_RTCALT1          0x00000002  // RTC Alert1 Masked Interrupt
+                                            // Clear.
+#define HIB_IC_RTCALT0          0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCT register.
+//
+//*****************************************************************************
+#define HIB_RTCT_TRIM_M         0x0000FFFF  // RTC Trim Value.
+#define HIB_RTCT_TRIM_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_DATA register.
+//
+//*****************************************************************************
+#define HIB_DATA_RTD_M          0xFFFFFFFF  // Hibernation Module NV
+                                            // Registers[63:0].
+#define HIB_DATA_RTD_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMA register.
+//
+//*****************************************************************************
+#define FLASH_FMA_OFFSET_M      0x0003FFFF  // Address Offset.
+#define FLASH_FMA_OFFSET_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMD register.
+//
+//*****************************************************************************
+#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value.
+#define FLASH_FMD_DATA_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_M       0xFFFF0000  // Flash Write Key.
+#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
+#define FLASH_FMC_COMT          0x00000008  // Commit Register Value.
+#define FLASH_FMC_MERASE        0x00000004  // Mass Erase Flash Memory.
+#define FLASH_FMC_ERASE         0x00000002  // Erase a Page of Flash Memory.
+#define FLASH_FMC_WRITE         0x00000001  // Write a Word into Flash Memory.
+#define FLASH_FMC_WRKEY_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCRIS register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt
+                                            // Status.
+#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCIM register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask.
+#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCMISC register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
+                                            // Status and Clear.
+#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USECRL register.
+//
+//*****************************************************************************
+#define FLASH_USECRL_M          0x000000FF  // Microsecond Reload Value.
+#define FLASH_USECRL_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERDBG register.
+//
+//*****************************************************************************
+#define FLASH_USERDBG_NW        0x80000000  // User Debug Not Written.
+#define FLASH_USERDBG_DATA_M    0x7FFFFFFC  // User Data.
+#define FLASH_USERDBG_DBG1      0x00000002  // Debug Control 1.
+#define FLASH_USERDBG_DBG0      0x00000001  // Debug Control 0.
+#define FLASH_USERDBG_DATA_S    2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG0 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG0_NW       0x80000000  // Not Written.
+#define FLASH_USERREG0_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG0_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG1 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG1_NW       0x80000000  // Not Written.
+#define FLASH_USERREG1_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG1_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the erase size of the FLASH block that is
+// erased by an erase operation, and the protect size is the size of the FLASH
+// block that is protected by each protection register.
+//
+//*****************************************************************************
+#define FLASH_PROTECT_SIZE      0x00000800
+#define FLASH_ERASE_SIZE        0x00000400
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID0_VER_M       0x70000000  // DID0 Version.
+#define SYSCTL_DID0_VER_1       0x10000000  // Second version of the DID0
+                                            // register format.
+#define SYSCTL_DID0_CLASS_M     0x00FF0000  // Device Class.
+#define SYSCTL_DID0_CLASS_FURY  0x00010000  // Stellaris(r) Fury-class devices.
+#define SYSCTL_DID0_MAJ_M       0x0000FF00  // Major Revision.
+#define SYSCTL_DID0_MAJ_REVA    0x00000000  // Revision A (initial device)
+#define SYSCTL_DID0_MAJ_REVB    0x00000100  // Revision B (first base layer
+                                            // revision)
+#define SYSCTL_DID0_MAJ_REVC    0x00000200  // Revision C (second base layer
+                                            // revision)
+#define SYSCTL_DID0_MIN_M       0x000000FF  // Minor Revision.
+#define SYSCTL_DID0_MIN_0       0x00000000  // Initial device, or a major
+                                            // revision update.
+#define SYSCTL_DID0_MIN_1       0x00000001  // First metal layer change.
+#define SYSCTL_DID0_MIN_2       0x00000002  // Second metal layer change.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID1_VER_M       0xF0000000  // DID1 Version.
+#define SYSCTL_DID1_VER_1       0x10000000  // Second version of the DID1
+                                            // register format.
+#define SYSCTL_DID1_FAM_M       0x0F000000  // Family.
+#define SYSCTL_DID1_FAM_STELLARIS \
+                                0x00000000  // Stellaris family of
+                                            // microcontollers, that is, all
+                                            // devices with external part
+                                            // numbers starting with LM3S.
+#define SYSCTL_DID1_PRTNO_M     0x00FF0000  // Part Number.
+#define SYSCTL_DID1_PRTNO_6918  0x00E80000  // LM3S6918
+#define SYSCTL_DID1_PINCNT_M    0x0000E000  // Package Pin Count.
+#define SYSCTL_DID1_PINCNT_100  0x00004000  // 100-pin or 108-ball package
+#define SYSCTL_DID1_TEMP_M      0x000000E0  // Temperature Range.
+#define SYSCTL_DID1_TEMP_C      0x00000000  // Commercial temperature range (0C
+                                            // to 70C)
+#define SYSCTL_DID1_TEMP_I      0x00000020  // Industrial temperature range
+                                            // (-40C to 85C)
+#define SYSCTL_DID1_TEMP_E      0x00000040  // Extended temperature range (-40C
+                                            // to 105C)
+#define SYSCTL_DID1_PKG_M       0x00000018  // Package Type.
+#define SYSCTL_DID1_PKG_28SOIC  0x00000000  // SOIC package
+#define SYSCTL_DID1_PKG_48QFP   0x00000008  // LQFP package
+#define SYSCTL_DID1_PKG_BGA     0x00000010  // BGA package
+#define SYSCTL_DID1_ROHS        0x00000004  // RoHS-Compliance.
+#define SYSCTL_DID1_QUAL_M      0x00000003  // Qualification Status.
+#define SYSCTL_DID1_QUAL_ES     0x00000000  // Engineering Sample (unqualified)
+#define SYSCTL_DID1_QUAL_PP     0x00000001  // Pilot Production (unqualified)
+#define SYSCTL_DID1_QUAL_FQ     0x00000002  // Fully Qualified
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC0_SRAMSZ_M     0xFFFF0000  // SRAM Size.
+#define SYSCTL_DC0_SRAMSZ_64KB  0x00FF0000  // 64 KB of SRAM
+#define SYSCTL_DC0_FLASHSZ_M    0x0000FFFF  // Flash Size.
+#define SYSCTL_DC0_FLASHSZ_256K 0x0000007F  // 256 KB of Flash
+#define SYSCTL_DC0_SRAMSZ_S     16          // SRAM size shift
+#define SYSCTL_DC0_FLASHSZ_S    0           // Flash size shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC1_ADC          0x00010000  // ADC Module Present.
+#define SYSCTL_DC1_MINSYSDIV_M  0x0000F000  // System Clock Divider.
+#define SYSCTL_DC1_MINSYSDIV_50 0x00003000  // Specifies a 50-MHz CPU clock
+                                            // with a PLL divider of 4.
+#define SYSCTL_DC1_ADCSPD_M     0x00000300  // Max ADC Speed.
+#define SYSCTL_DC1_ADCSPD_500K  0x00000200  // 500K samples/second
+#define SYSCTL_DC1_MPU          0x00000080  // MPU Present.
+#define SYSCTL_DC1_HIB          0x00000040  // Hibernation Module Present.
+#define SYSCTL_DC1_TEMP         0x00000020  // Temp Sensor Present.
+#define SYSCTL_DC1_PLL          0x00000010  // PLL Present.
+#define SYSCTL_DC1_WDT          0x00000008  // Watchdog Timer Present.
+#define SYSCTL_DC1_SWO          0x00000004  // SWO Trace Port Present.
+#define SYSCTL_DC1_SWD          0x00000002  // SWD Present.
+#define SYSCTL_DC1_JTAG         0x00000001  // JTAG Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC2_COMP1        0x02000000  // Analog Comparator 1 Present.
+#define SYSCTL_DC2_COMP0        0x01000000  // Analog Comparator 0 Present.
+#define SYSCTL_DC2_TIMER3       0x00080000  // Timer 3 Present.
+#define SYSCTL_DC2_TIMER2       0x00040000  // Timer 2 Present.
+#define SYSCTL_DC2_TIMER1       0x00020000  // Timer 1 Present.
+#define SYSCTL_DC2_TIMER0       0x00010000  // Timer 0 Present.
+#define SYSCTL_DC2_I2C1         0x00004000  // I2C Module 1 Present.
+#define SYSCTL_DC2_I2C0         0x00001000  // I2C Module 0 Present.
+#define SYSCTL_DC2_SSI1         0x00000020  // SSI1 Present.
+#define SYSCTL_DC2_SSI0         0x00000010  // SSI0 Present.
+#define SYSCTL_DC2_UART1        0x00000002  // UART1 Present.
+#define SYSCTL_DC2_UART0        0x00000001  // UART0 Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC3 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC3_32KHZ        0x80000000  // 32KHz Input Clock Available.
+#define SYSCTL_DC3_CCP5         0x20000000  // CCP5 Pin Present.
+#define SYSCTL_DC3_CCP4         0x10000000  // CCP4 Pin Present.
+#define SYSCTL_DC3_CCP3         0x08000000  // CCP3 Pin Present.
+#define SYSCTL_DC3_CCP2         0x04000000  // CCP2 Pin Present.
+#define SYSCTL_DC3_CCP1         0x02000000  // CCP1 Pin Present.
+#define SYSCTL_DC3_CCP0         0x01000000  // CCP0 Pin Present.
+#define SYSCTL_DC3_ADC7         0x00800000  // ADC7 Pin Present.
+#define SYSCTL_DC3_ADC6         0x00400000  // ADC6 Pin Present.
+#define SYSCTL_DC3_ADC5         0x00200000  // ADC5 Pin Present.
+#define SYSCTL_DC3_ADC4         0x00100000  // ADC4 Pin Present.
+#define SYSCTL_DC3_ADC3         0x00080000  // ADC3 Pin Present.
+#define SYSCTL_DC3_ADC2         0x00040000  // ADC2 Pin Present.
+#define SYSCTL_DC3_ADC1         0x00020000  // ADC1 Pin Present.
+#define SYSCTL_DC3_ADC0         0x00010000  // ADC0 Pin Present.
+#define SYSCTL_DC3_C1PLUS       0x00000400  // C1+ Pin Present.
+#define SYSCTL_DC3_C1MINUS      0x00000200  // C1- Pin Present.
+#define SYSCTL_DC3_C0O          0x00000100  // C0o Pin Present.
+#define SYSCTL_DC3_C0PLUS       0x00000080  // C0+ Pin Present.
+#define SYSCTL_DC3_C0MINUS      0x00000040  // C0- Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC4 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC4_EPHY0        0x40000000  // Ethernet PHY0 Present.
+#define SYSCTL_DC4_EMAC0        0x10000000  // Ethernet MAC0 Present.
+#define SYSCTL_DC4_GPIOH        0x00000080  // GPIO Port H Present.
+#define SYSCTL_DC4_GPIOG        0x00000040  // GPIO Port G Present.
+#define SYSCTL_DC4_GPIOF        0x00000020  // GPIO Port F Present.
+#define SYSCTL_DC4_GPIOE        0x00000010  // GPIO Port E Present.
+#define SYSCTL_DC4_GPIOD        0x00000008  // GPIO Port D Present.
+#define SYSCTL_DC4_GPIOC        0x00000004  // GPIO Port C Present.
+#define SYSCTL_DC4_GPIOB        0x00000002  // GPIO Port B Present.
+#define SYSCTL_DC4_GPIOA        0x00000001  // GPIO Port A Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PBORCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_PBORCTL_BORIOR   0x00000002  // BOR Interrupt or Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LDOPCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOPCTL_M        0x0000003F  // LDO Output Voltage.
+#define SYSCTL_LDOPCTL_2_50V    0x00000000  // 2.50
+#define SYSCTL_LDOPCTL_2_45V    0x00000001  // 2.45
+#define SYSCTL_LDOPCTL_2_40V    0x00000002  // 2.40
+#define SYSCTL_LDOPCTL_2_35V    0x00000003  // 2.35
+#define SYSCTL_LDOPCTL_2_30V    0x00000004  // 2.30
+#define SYSCTL_LDOPCTL_2_25V    0x00000005  // 2.25
+#define SYSCTL_LDOPCTL_2_75V    0x0000001B  // 2.75
+#define SYSCTL_LDOPCTL_2_70V    0x0000001C  // 2.70
+#define SYSCTL_LDOPCTL_2_65V    0x0000001D  // 2.65
+#define SYSCTL_LDOPCTL_2_60V    0x0000001E  // 2.60
+#define SYSCTL_LDOPCTL_2_55V    0x0000001F  // 2.55
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR0_ADC        0x00010000  // ADC0 Reset Control.
+#define SYSCTL_SRCR0_HIB        0x00000040  // HIB Reset Control.
+#define SYSCTL_SRCR0_WDT        0x00000008  // WDT Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR1_COMP1      0x02000000  // Analog Comp 1 Reset Control.
+#define SYSCTL_SRCR1_COMP0      0x01000000  // Analog Comp 0 Reset Control.
+#define SYSCTL_SRCR1_TIMER3     0x00080000  // Timer 3 Reset Control.
+#define SYSCTL_SRCR1_TIMER2     0x00040000  // Timer 2 Reset Control.
+#define SYSCTL_SRCR1_TIMER1     0x00020000  // Timer 1 Reset Control.
+#define SYSCTL_SRCR1_TIMER0     0x00010000  // Timer 0 Reset Control.
+#define SYSCTL_SRCR1_I2C1       0x00004000  // I2C1 Reset Control.
+#define SYSCTL_SRCR1_I2C0       0x00001000  // I2C0 Reset Control.
+#define SYSCTL_SRCR1_SSI1       0x00000020  // SSI1 Reset Control.
+#define SYSCTL_SRCR1_SSI0       0x00000010  // SSI0 Reset Control.
+#define SYSCTL_SRCR1_UART1      0x00000002  // UART1 Reset Control.
+#define SYSCTL_SRCR1_UART0      0x00000001  // UART0 Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR2_EPHY0      0x40000000  // PHY0 Reset Control.
+#define SYSCTL_SRCR2_EMAC0      0x10000000  // MAC0 Reset Control.
+#define SYSCTL_SRCR2_GPIOH      0x00000080  // Port H Reset Control.
+#define SYSCTL_SRCR2_GPIOG      0x00000040  // Port G Reset Control.
+#define SYSCTL_SRCR2_GPIOF      0x00000020  // Port F Reset Control.
+#define SYSCTL_SRCR2_GPIOE      0x00000010  // Port E Reset Control.
+#define SYSCTL_SRCR2_GPIOD      0x00000008  // Port D Reset Control.
+#define SYSCTL_SRCR2_GPIOC      0x00000004  // Port C Reset Control.
+#define SYSCTL_SRCR2_GPIOB      0x00000002  // Port B Reset Control.
+#define SYSCTL_SRCR2_GPIOA      0x00000001  // Port A Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RIS register.
+//
+//*****************************************************************************
+#define SYSCTL_RIS_PLLLRIS      0x00000040  // PLL Lock Raw Interrupt Status.
+#define SYSCTL_RIS_BORRIS       0x00000002  // Brown-Out Reset Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_IMC register.
+//
+//*****************************************************************************
+#define SYSCTL_IMC_PLLLIM       0x00000040  // PLL Lock Interrupt Mask.
+#define SYSCTL_IMC_BORIM        0x00000002  // Brown-Out Reset Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MISC register.
+//
+//*****************************************************************************
+#define SYSCTL_MISC_PLLLMIS     0x00000040  // PLL Lock Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_BORMIS      0x00000002  // BOR Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RESC register.
+//
+//*****************************************************************************
+#define SYSCTL_RESC_LDO         0x00000020  // LDO Reset.
+#define SYSCTL_RESC_SW          0x00000010  // Software Reset.
+#define SYSCTL_RESC_WDT         0x00000008  // Watchdog Timer Reset.
+#define SYSCTL_RESC_BOR         0x00000004  // Brown-Out Reset.
+#define SYSCTL_RESC_POR         0x00000002  // Power-On Reset.
+#define SYSCTL_RESC_EXT         0x00000001  // External Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC_ACG          0x08000000  // Auto Clock Gating.
+#define SYSCTL_RCC_SYSDIV_M     0x07800000  // System Clock Divisor.
+#define SYSCTL_RCC_SYSDIV_2     0x00800000  // /2
+#define SYSCTL_RCC_SYSDIV_3     0x01000000  // /3
+#define SYSCTL_RCC_SYSDIV_4     0x01800000  // /4
+#define SYSCTL_RCC_SYSDIV_5     0x02000000  // /5
+#define SYSCTL_RCC_SYSDIV_6     0x02800000  // /6
+#define SYSCTL_RCC_SYSDIV_7     0x03000000  // /7
+#define SYSCTL_RCC_SYSDIV_8     0x03800000  // /8
+#define SYSCTL_RCC_SYSDIV_9     0x04000000  // /9
+#define SYSCTL_RCC_SYSDIV_10    0x04800000  // /10
+#define SYSCTL_RCC_SYSDIV_11    0x05000000  // /11
+#define SYSCTL_RCC_SYSDIV_12    0x05800000  // /12
+#define SYSCTL_RCC_SYSDIV_13    0x06000000  // /13
+#define SYSCTL_RCC_SYSDIV_14    0x06800000  // /14
+#define SYSCTL_RCC_SYSDIV_15    0x07000000  // /15
+#define SYSCTL_RCC_SYSDIV_16    0x07800000  // /16
+#define SYSCTL_RCC_USESYSDIV    0x00400000  // Enable System Clock Divider.
+#define SYSCTL_RCC_PWRDN        0x00002000  // PLL Power Down.
+#define SYSCTL_RCC_BYPASS       0x00000800  // PLL Bypass.
+#define SYSCTL_RCC_XTAL_M       0x000003C0  // Crystal Value.
+#define SYSCTL_RCC_XTAL_1MHZ    0x00000000  // 1.000
+#define SYSCTL_RCC_XTAL_1_84MHZ 0x00000040  // 1.8432
+#define SYSCTL_RCC_XTAL_2MHZ    0x00000080  // 2.000
+#define SYSCTL_RCC_XTAL_2_45MHZ 0x000000C0  // 2.4576
+#define SYSCTL_RCC_XTAL_3_57MHZ 0x00000100  // 3.579545 MHz
+#define SYSCTL_RCC_XTAL_3_68MHZ 0x00000140  // 3.6864 MHz
+#define SYSCTL_RCC_XTAL_4MHZ    0x00000180  // 4 MHz
+#define SYSCTL_RCC_XTAL_4_09MHZ 0x000001C0  // 4.096 MHz
+#define SYSCTL_RCC_XTAL_4_91MHZ 0x00000200  // 4.9152 MHz
+#define SYSCTL_RCC_XTAL_5MHZ    0x00000240  // 5 MHz
+#define SYSCTL_RCC_XTAL_5_12MHZ 0x00000280  // 5.12 MHz
+#define SYSCTL_RCC_XTAL_6MHZ    0x000002C0  // 6 MHz (reset value)
+#define SYSCTL_RCC_XTAL_6_14MHZ 0x00000300  // 6.144 MHz
+#define SYSCTL_RCC_XTAL_7_37MHZ 0x00000340  // 7.3728 MHz
+#define SYSCTL_RCC_XTAL_8MHZ    0x00000380  // 8 MHz
+#define SYSCTL_RCC_XTAL_8_19MHZ 0x000003C0  // 8.192 MHz
+#define SYSCTL_RCC_OSCSRC_M     0x00000030  // Oscillator Source.
+#define SYSCTL_RCC_OSCSRC_MAIN  0x00000000  // MOSC
+#define SYSCTL_RCC_OSCSRC_INT   0x00000010  // IOSC
+#define SYSCTL_RCC_OSCSRC_INT4  0x00000020  // IOSC/4
+#define SYSCTL_RCC_OSCSRC_30    0x00000030  // 30 kHz
+#define SYSCTL_RCC_IOSCDIS      0x00000002  // Internal Oscillator Disable.
+#define SYSCTL_RCC_MOSCDIS      0x00000001  // Main Oscillator Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLCFG register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLCFG_F_M       0x00003FE0  // PLL F Value.
+#define SYSCTL_PLLCFG_R_M       0x0000001F  // PLL R Value.
+#define SYSCTL_PLLCFG_F_S       5
+#define SYSCTL_PLLCFG_R_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC2_USERCC2     0x80000000  // Use RCC2.
+#define SYSCTL_RCC2_SYSDIV2_M   0x1F800000  // System Clock Divisor.
+#define SYSCTL_RCC2_SYSDIV2_2   0x00800000  // System clock /2
+#define SYSCTL_RCC2_SYSDIV2_3   0x01000000  // System clock /3
+#define SYSCTL_RCC2_SYSDIV2_4   0x01800000  // System clock /4
+#define SYSCTL_RCC2_SYSDIV2_5   0x02000000  // System clock /5
+#define SYSCTL_RCC2_SYSDIV2_6   0x02800000  // System clock /6
+#define SYSCTL_RCC2_SYSDIV2_7   0x03000000  // System clock /7
+#define SYSCTL_RCC2_SYSDIV2_8   0x03800000  // System clock /8
+#define SYSCTL_RCC2_SYSDIV2_9   0x04000000  // System clock /9
+#define SYSCTL_RCC2_SYSDIV2_10  0x04800000  // System clock /10
+#define SYSCTL_RCC2_SYSDIV2_11  0x05000000  // System clock /11
+#define SYSCTL_RCC2_SYSDIV2_12  0x05800000  // System clock /12
+#define SYSCTL_RCC2_SYSDIV2_13  0x06000000  // System clock /13
+#define SYSCTL_RCC2_SYSDIV2_14  0x06800000  // System clock /14
+#define SYSCTL_RCC2_SYSDIV2_15  0x07000000  // System clock /15
+#define SYSCTL_RCC2_SYSDIV2_16  0x07800000  // System clock /16
+#define SYSCTL_RCC2_SYSDIV2_17  0x08000000  // System clock /17
+#define SYSCTL_RCC2_SYSDIV2_18  0x08800000  // System clock /18
+#define SYSCTL_RCC2_SYSDIV2_19  0x09000000  // System clock /19
+#define SYSCTL_RCC2_SYSDIV2_20  0x09800000  // System clock /20
+#define SYSCTL_RCC2_SYSDIV2_21  0x0A000000  // System clock /21
+#define SYSCTL_RCC2_SYSDIV2_22  0x0A800000  // System clock /22
+#define SYSCTL_RCC2_SYSDIV2_23  0x0B000000  // System clock /23
+#define SYSCTL_RCC2_SYSDIV2_24  0x0B800000  // System clock /24
+#define SYSCTL_RCC2_SYSDIV2_25  0x0C000000  // System clock /25
+#define SYSCTL_RCC2_SYSDIV2_26  0x0C800000  // System clock /26
+#define SYSCTL_RCC2_SYSDIV2_27  0x0D000000  // System clock /27
+#define SYSCTL_RCC2_SYSDIV2_28  0x0D800000  // System clock /28
+#define SYSCTL_RCC2_SYSDIV2_29  0x0E000000  // System clock /29
+#define SYSCTL_RCC2_SYSDIV2_30  0x0E800000  // System clock /30
+#define SYSCTL_RCC2_SYSDIV2_31  0x0F000000  // System clock /31
+#define SYSCTL_RCC2_SYSDIV2_32  0x0F800000  // System clock /32
+#define SYSCTL_RCC2_SYSDIV2_33  0x10000000  // System clock /33
+#define SYSCTL_RCC2_SYSDIV2_34  0x10800000  // System clock /34
+#define SYSCTL_RCC2_SYSDIV2_35  0x11000000  // System clock /35
+#define SYSCTL_RCC2_SYSDIV2_36  0x11800000  // System clock /36
+#define SYSCTL_RCC2_SYSDIV2_37  0x12000000  // System clock /37
+#define SYSCTL_RCC2_SYSDIV2_38  0x12800000  // System clock /38
+#define SYSCTL_RCC2_SYSDIV2_39  0x13000000  // System clock /39
+#define SYSCTL_RCC2_SYSDIV2_40  0x13800000  // System clock /40
+#define SYSCTL_RCC2_SYSDIV2_41  0x14000000  // System clock /41
+#define SYSCTL_RCC2_SYSDIV2_42  0x14800000  // System clock /42
+#define SYSCTL_RCC2_SYSDIV2_43  0x15000000  // System clock /43
+#define SYSCTL_RCC2_SYSDIV2_44  0x15800000  // System clock /44
+#define SYSCTL_RCC2_SYSDIV2_45  0x16000000  // System clock /45
+#define SYSCTL_RCC2_SYSDIV2_46  0x16800000  // System clock /46
+#define SYSCTL_RCC2_SYSDIV2_47  0x17000000  // System clock /47
+#define SYSCTL_RCC2_SYSDIV2_48  0x17800000  // System clock /48
+#define SYSCTL_RCC2_SYSDIV2_49  0x18000000  // System clock /49
+#define SYSCTL_RCC2_SYSDIV2_50  0x18800000  // System clock /50
+#define SYSCTL_RCC2_SYSDIV2_51  0x19000000  // System clock /51
+#define SYSCTL_RCC2_SYSDIV2_52  0x19800000  // System clock /52
+#define SYSCTL_RCC2_SYSDIV2_53  0x1A000000  // System clock /53
+#define SYSCTL_RCC2_SYSDIV2_54  0x1A800000  // System clock /54
+#define SYSCTL_RCC2_SYSDIV2_55  0x1B000000  // System clock /55
+#define SYSCTL_RCC2_SYSDIV2_56  0x1B800000  // System clock /56
+#define SYSCTL_RCC2_SYSDIV2_57  0x1C000000  // System clock /57
+#define SYSCTL_RCC2_SYSDIV2_58  0x1C800000  // System clock /58
+#define SYSCTL_RCC2_SYSDIV2_59  0x1D000000  // System clock /59
+#define SYSCTL_RCC2_SYSDIV2_60  0x1D800000  // System clock /60
+#define SYSCTL_RCC2_SYSDIV2_61  0x1E000000  // System clock /61
+#define SYSCTL_RCC2_SYSDIV2_62  0x1E800000  // System clock /62
+#define SYSCTL_RCC2_SYSDIV2_63  0x1F000000  // System clock /63
+#define SYSCTL_RCC2_SYSDIV2_64  0x1F800000  // System clock /64
+#define SYSCTL_RCC2_PWRDN2      0x00002000  // Power-Down PLL.
+#define SYSCTL_RCC2_BYPASS2     0x00000800  // Bypass PLL.
+#define SYSCTL_RCC2_OSCSRC2_M   0x00000070  // Oscillator Source.
+#define SYSCTL_RCC2_OSCSRC2_MO  0x00000000  // MOSC
+#define SYSCTL_RCC2_OSCSRC2_IO  0x00000010  // IOSC
+#define SYSCTL_RCC2_OSCSRC2_IO4 0x00000020  // IOSC/4
+#define SYSCTL_RCC2_OSCSRC2_30  0x00000030  // 30 kHz
+#define SYSCTL_RCC2_OSCSRC2_32  0x00000070  // 32 kHz
+#define SYSCTL_RCC2_SYSDIV2_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_RCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_RCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_RCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_RCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_RCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_RCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_RCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_RCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_RCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_SCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_SCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_SCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_SCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_SCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_SCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_SCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_SCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_SCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_DCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_DCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_DCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_DCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_DCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_DCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_DCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_DCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_DCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSLPCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSLPCLKCFG_D_M   0x1F800000  // Divider Field Override.
+#define SYSCTL_DSLPCLKCFG_O_M   0x00000070  // Clock Source.
+#define SYSCTL_DSLPCLKCFG_O_IGN 0x00000000  // MOSC
+#define SYSCTL_DSLPCLKCFG_O_IO  0x00000010  // IOSC
+#define SYSCTL_DSLPCLKCFG_O_30  0x00000030  // 30 kHz
+#define SYSCTL_DSLPCLKCFG_O_32  0x00000070  // 32 kHz
+#define SYSCTL_DSLPCLKCFG_D_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_LINES_M   0x0000001F  // Number of interrupt lines (x32)
+#define NVIC_INT_TYPE_LINES_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CTRL_COUNT      0x00010000  // Count flag
+#define NVIC_ST_CTRL_CLK_SRC    0x00000004  // Clock Source
+#define NVIC_ST_CTRL_INTEN      0x00000002  // Interrupt enable
+#define NVIC_ST_CTRL_ENABLE     0x00000001  // Counter mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_RELOAD register.
+//
+//*****************************************************************************
+#define NVIC_ST_RELOAD_M        0x00FFFFFF  // Counter load value
+#define NVIC_ST_RELOAD_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CURRENT
+// register.
+//
+//*****************************************************************************
+#define NVIC_ST_CURRENT_M       0x00FFFFFF  // Counter current value
+#define NVIC_ST_CURRENT_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CAL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CAL_NOREF       0x80000000  // No reference clock
+#define NVIC_ST_CAL_SKEW        0x40000000  // Clock skew
+#define NVIC_ST_CAL_ONEMS_M     0x00FFFFFF  // 1ms reference value
+#define NVIC_ST_CAL_ONEMS_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN0 register.
+//
+//*****************************************************************************
+#define NVIC_EN0_INT31          0x80000000  // Interrupt 31 enable
+#define NVIC_EN0_INT30          0x40000000  // Interrupt 30 enable
+#define NVIC_EN0_INT29          0x20000000  // Interrupt 29 enable
+#define NVIC_EN0_INT28          0x10000000  // Interrupt 28 enable
+#define NVIC_EN0_INT27          0x08000000  // Interrupt 27 enable
+#define NVIC_EN0_INT26          0x04000000  // Interrupt 26 enable
+#define NVIC_EN0_INT25          0x02000000  // Interrupt 25 enable
+#define NVIC_EN0_INT24          0x01000000  // Interrupt 24 enable
+#define NVIC_EN0_INT23          0x00800000  // Interrupt 23 enable
+#define NVIC_EN0_INT22          0x00400000  // Interrupt 22 enable
+#define NVIC_EN0_INT21          0x00200000  // Interrupt 21 enable
+#define NVIC_EN0_INT20          0x00100000  // Interrupt 20 enable
+#define NVIC_EN0_INT19          0x00080000  // Interrupt 19 enable
+#define NVIC_EN0_INT18          0x00040000  // Interrupt 18 enable
+#define NVIC_EN0_INT17          0x00020000  // Interrupt 17 enable
+#define NVIC_EN0_INT16          0x00010000  // Interrupt 16 enable
+#define NVIC_EN0_INT15          0x00008000  // Interrupt 15 enable
+#define NVIC_EN0_INT14          0x00004000  // Interrupt 14 enable
+#define NVIC_EN0_INT13          0x00002000  // Interrupt 13 enable
+#define NVIC_EN0_INT12          0x00001000  // Interrupt 12 enable
+#define NVIC_EN0_INT11          0x00000800  // Interrupt 11 enable
+#define NVIC_EN0_INT10          0x00000400  // Interrupt 10 enable
+#define NVIC_EN0_INT9           0x00000200  // Interrupt 9 enable
+#define NVIC_EN0_INT8           0x00000100  // Interrupt 8 enable
+#define NVIC_EN0_INT7           0x00000080  // Interrupt 7 enable
+#define NVIC_EN0_INT6           0x00000040  // Interrupt 6 enable
+#define NVIC_EN0_INT5           0x00000020  // Interrupt 5 enable
+#define NVIC_EN0_INT4           0x00000010  // Interrupt 4 enable
+#define NVIC_EN0_INT3           0x00000008  // Interrupt 3 enable
+#define NVIC_EN0_INT2           0x00000004  // Interrupt 2 enable
+#define NVIC_EN0_INT1           0x00000002  // Interrupt 1 enable
+#define NVIC_EN0_INT0           0x00000001  // Interrupt 0 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN1 register.
+//
+//*****************************************************************************
+#define NVIC_EN1_INT59          0x08000000  // Interrupt 59 enable
+#define NVIC_EN1_INT58          0x04000000  // Interrupt 58 enable
+#define NVIC_EN1_INT57          0x02000000  // Interrupt 57 enable
+#define NVIC_EN1_INT56          0x01000000  // Interrupt 56 enable
+#define NVIC_EN1_INT55          0x00800000  // Interrupt 55 enable
+#define NVIC_EN1_INT54          0x00400000  // Interrupt 54 enable
+#define NVIC_EN1_INT53          0x00200000  // Interrupt 53 enable
+#define NVIC_EN1_INT52          0x00100000  // Interrupt 52 enable
+#define NVIC_EN1_INT51          0x00080000  // Interrupt 51 enable
+#define NVIC_EN1_INT50          0x00040000  // Interrupt 50 enable
+#define NVIC_EN1_INT49          0x00020000  // Interrupt 49 enable
+#define NVIC_EN1_INT48          0x00010000  // Interrupt 48 enable
+#define NVIC_EN1_INT47          0x00008000  // Interrupt 47 enable
+#define NVIC_EN1_INT46          0x00004000  // Interrupt 46 enable
+#define NVIC_EN1_INT45          0x00002000  // Interrupt 45 enable
+#define NVIC_EN1_INT44          0x00001000  // Interrupt 44 enable
+#define NVIC_EN1_INT43          0x00000800  // Interrupt 43 enable
+#define NVIC_EN1_INT42          0x00000400  // Interrupt 42 enable
+#define NVIC_EN1_INT41          0x00000200  // Interrupt 41 enable
+#define NVIC_EN1_INT40          0x00000100  // Interrupt 40 enable
+#define NVIC_EN1_INT39          0x00000080  // Interrupt 39 enable
+#define NVIC_EN1_INT38          0x00000040  // Interrupt 38 enable
+#define NVIC_EN1_INT37          0x00000020  // Interrupt 37 enable
+#define NVIC_EN1_INT36          0x00000010  // Interrupt 36 enable
+#define NVIC_EN1_INT35          0x00000008  // Interrupt 35 enable
+#define NVIC_EN1_INT34          0x00000004  // Interrupt 34 enable
+#define NVIC_EN1_INT33          0x00000002  // Interrupt 33 enable
+#define NVIC_EN1_INT32          0x00000001  // Interrupt 32 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS0 register.
+//
+//*****************************************************************************
+#define NVIC_DIS0_INT31         0x80000000  // Interrupt 31 disable
+#define NVIC_DIS0_INT30         0x40000000  // Interrupt 30 disable
+#define NVIC_DIS0_INT29         0x20000000  // Interrupt 29 disable
+#define NVIC_DIS0_INT28         0x10000000  // Interrupt 28 disable
+#define NVIC_DIS0_INT27         0x08000000  // Interrupt 27 disable
+#define NVIC_DIS0_INT26         0x04000000  // Interrupt 26 disable
+#define NVIC_DIS0_INT25         0x02000000  // Interrupt 25 disable
+#define NVIC_DIS0_INT24         0x01000000  // Interrupt 24 disable
+#define NVIC_DIS0_INT23         0x00800000  // Interrupt 23 disable
+#define NVIC_DIS0_INT22         0x00400000  // Interrupt 22 disable
+#define NVIC_DIS0_INT21         0x00200000  // Interrupt 21 disable
+#define NVIC_DIS0_INT20         0x00100000  // Interrupt 20 disable
+#define NVIC_DIS0_INT19         0x00080000  // Interrupt 19 disable
+#define NVIC_DIS0_INT18         0x00040000  // Interrupt 18 disable
+#define NVIC_DIS0_INT17         0x00020000  // Interrupt 17 disable
+#define NVIC_DIS0_INT16         0x00010000  // Interrupt 16 disable
+#define NVIC_DIS0_INT15         0x00008000  // Interrupt 15 disable
+#define NVIC_DIS0_INT14         0x00004000  // Interrupt 14 disable
+#define NVIC_DIS0_INT13         0x00002000  // Interrupt 13 disable
+#define NVIC_DIS0_INT12         0x00001000  // Interrupt 12 disable
+#define NVIC_DIS0_INT11         0x00000800  // Interrupt 11 disable
+#define NVIC_DIS0_INT10         0x00000400  // Interrupt 10 disable
+#define NVIC_DIS0_INT9          0x00000200  // Interrupt 9 disable
+#define NVIC_DIS0_INT8          0x00000100  // Interrupt 8 disable
+#define NVIC_DIS0_INT7          0x00000080  // Interrupt 7 disable
+#define NVIC_DIS0_INT6          0x00000040  // Interrupt 6 disable
+#define NVIC_DIS0_INT5          0x00000020  // Interrupt 5 disable
+#define NVIC_DIS0_INT4          0x00000010  // Interrupt 4 disable
+#define NVIC_DIS0_INT3          0x00000008  // Interrupt 3 disable
+#define NVIC_DIS0_INT2          0x00000004  // Interrupt 2 disable
+#define NVIC_DIS0_INT1          0x00000002  // Interrupt 1 disable
+#define NVIC_DIS0_INT0          0x00000001  // Interrupt 0 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS1 register.
+//
+//*****************************************************************************
+#define NVIC_DIS1_INT59         0x08000000  // Interrupt 59 disable
+#define NVIC_DIS1_INT58         0x04000000  // Interrupt 58 disable
+#define NVIC_DIS1_INT57         0x02000000  // Interrupt 57 disable
+#define NVIC_DIS1_INT56         0x01000000  // Interrupt 56 disable
+#define NVIC_DIS1_INT55         0x00800000  // Interrupt 55 disable
+#define NVIC_DIS1_INT54         0x00400000  // Interrupt 54 disable
+#define NVIC_DIS1_INT53         0x00200000  // Interrupt 53 disable
+#define NVIC_DIS1_INT52         0x00100000  // Interrupt 52 disable
+#define NVIC_DIS1_INT51         0x00080000  // Interrupt 51 disable
+#define NVIC_DIS1_INT50         0x00040000  // Interrupt 50 disable
+#define NVIC_DIS1_INT49         0x00020000  // Interrupt 49 disable
+#define NVIC_DIS1_INT48         0x00010000  // Interrupt 48 disable
+#define NVIC_DIS1_INT47         0x00008000  // Interrupt 47 disable
+#define NVIC_DIS1_INT46         0x00004000  // Interrupt 46 disable
+#define NVIC_DIS1_INT45         0x00002000  // Interrupt 45 disable
+#define NVIC_DIS1_INT44         0x00001000  // Interrupt 44 disable
+#define NVIC_DIS1_INT43         0x00000800  // Interrupt 43 disable
+#define NVIC_DIS1_INT42         0x00000400  // Interrupt 42 disable
+#define NVIC_DIS1_INT41         0x00000200  // Interrupt 41 disable
+#define NVIC_DIS1_INT40         0x00000100  // Interrupt 40 disable
+#define NVIC_DIS1_INT39         0x00000080  // Interrupt 39 disable
+#define NVIC_DIS1_INT38         0x00000040  // Interrupt 38 disable
+#define NVIC_DIS1_INT37         0x00000020  // Interrupt 37 disable
+#define NVIC_DIS1_INT36         0x00000010  // Interrupt 36 disable
+#define NVIC_DIS1_INT35         0x00000008  // Interrupt 35 disable
+#define NVIC_DIS1_INT34         0x00000004  // Interrupt 34 disable
+#define NVIC_DIS1_INT33         0x00000002  // Interrupt 33 disable
+#define NVIC_DIS1_INT32         0x00000001  // Interrupt 32 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND0 register.
+//
+//*****************************************************************************
+#define NVIC_PEND0_INT31        0x80000000  // Interrupt 31 pend
+#define NVIC_PEND0_INT30        0x40000000  // Interrupt 30 pend
+#define NVIC_PEND0_INT29        0x20000000  // Interrupt 29 pend
+#define NVIC_PEND0_INT28        0x10000000  // Interrupt 28 pend
+#define NVIC_PEND0_INT27        0x08000000  // Interrupt 27 pend
+#define NVIC_PEND0_INT26        0x04000000  // Interrupt 26 pend
+#define NVIC_PEND0_INT25        0x02000000  // Interrupt 25 pend
+#define NVIC_PEND0_INT24        0x01000000  // Interrupt 24 pend
+#define NVIC_PEND0_INT23        0x00800000  // Interrupt 23 pend
+#define NVIC_PEND0_INT22        0x00400000  // Interrupt 22 pend
+#define NVIC_PEND0_INT21        0x00200000  // Interrupt 21 pend
+#define NVIC_PEND0_INT20        0x00100000  // Interrupt 20 pend
+#define NVIC_PEND0_INT19        0x00080000  // Interrupt 19 pend
+#define NVIC_PEND0_INT18        0x00040000  // Interrupt 18 pend
+#define NVIC_PEND0_INT17        0x00020000  // Interrupt 17 pend
+#define NVIC_PEND0_INT16        0x00010000  // Interrupt 16 pend
+#define NVIC_PEND0_INT15        0x00008000  // Interrupt 15 pend
+#define NVIC_PEND0_INT14        0x00004000  // Interrupt 14 pend
+#define NVIC_PEND0_INT13        0x00002000  // Interrupt 13 pend
+#define NVIC_PEND0_INT12        0x00001000  // Interrupt 12 pend
+#define NVIC_PEND0_INT11        0x00000800  // Interrupt 11 pend
+#define NVIC_PEND0_INT10        0x00000400  // Interrupt 10 pend
+#define NVIC_PEND0_INT9         0x00000200  // Interrupt 9 pend
+#define NVIC_PEND0_INT8         0x00000100  // Interrupt 8 pend
+#define NVIC_PEND0_INT7         0x00000080  // Interrupt 7 pend
+#define NVIC_PEND0_INT6         0x00000040  // Interrupt 6 pend
+#define NVIC_PEND0_INT5         0x00000020  // Interrupt 5 pend
+#define NVIC_PEND0_INT4         0x00000010  // Interrupt 4 pend
+#define NVIC_PEND0_INT3         0x00000008  // Interrupt 3 pend
+#define NVIC_PEND0_INT2         0x00000004  // Interrupt 2 pend
+#define NVIC_PEND0_INT1         0x00000002  // Interrupt 1 pend
+#define NVIC_PEND0_INT0         0x00000001  // Interrupt 0 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND1 register.
+//
+//*****************************************************************************
+#define NVIC_PEND1_INT59        0x08000000  // Interrupt 59 pend
+#define NVIC_PEND1_INT58        0x04000000  // Interrupt 58 pend
+#define NVIC_PEND1_INT57        0x02000000  // Interrupt 57 pend
+#define NVIC_PEND1_INT56        0x01000000  // Interrupt 56 pend
+#define NVIC_PEND1_INT55        0x00800000  // Interrupt 55 pend
+#define NVIC_PEND1_INT54        0x00400000  // Interrupt 54 pend
+#define NVIC_PEND1_INT53        0x00200000  // Interrupt 53 pend
+#define NVIC_PEND1_INT52        0x00100000  // Interrupt 52 pend
+#define NVIC_PEND1_INT51        0x00080000  // Interrupt 51 pend
+#define NVIC_PEND1_INT50        0x00040000  // Interrupt 50 pend
+#define NVIC_PEND1_INT49        0x00020000  // Interrupt 49 pend
+#define NVIC_PEND1_INT48        0x00010000  // Interrupt 48 pend
+#define NVIC_PEND1_INT47        0x00008000  // Interrupt 47 pend
+#define NVIC_PEND1_INT46        0x00004000  // Interrupt 46 pend
+#define NVIC_PEND1_INT45        0x00002000  // Interrupt 45 pend
+#define NVIC_PEND1_INT44        0x00001000  // Interrupt 44 pend
+#define NVIC_PEND1_INT43        0x00000800  // Interrupt 43 pend
+#define NVIC_PEND1_INT42        0x00000400  // Interrupt 42 pend
+#define NVIC_PEND1_INT41        0x00000200  // Interrupt 41 pend
+#define NVIC_PEND1_INT40        0x00000100  // Interrupt 40 pend
+#define NVIC_PEND1_INT39        0x00000080  // Interrupt 39 pend
+#define NVIC_PEND1_INT38        0x00000040  // Interrupt 38 pend
+#define NVIC_PEND1_INT37        0x00000020  // Interrupt 37 pend
+#define NVIC_PEND1_INT36        0x00000010  // Interrupt 36 pend
+#define NVIC_PEND1_INT35        0x00000008  // Interrupt 35 pend
+#define NVIC_PEND1_INT34        0x00000004  // Interrupt 34 pend
+#define NVIC_PEND1_INT33        0x00000002  // Interrupt 33 pend
+#define NVIC_PEND1_INT32        0x00000001  // Interrupt 32 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND0 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND0_INT31      0x80000000  // Interrupt 31 unpend
+#define NVIC_UNPEND0_INT30      0x40000000  // Interrupt 30 unpend
+#define NVIC_UNPEND0_INT29      0x20000000  // Interrupt 29 unpend
+#define NVIC_UNPEND0_INT28      0x10000000  // Interrupt 28 unpend
+#define NVIC_UNPEND0_INT27      0x08000000  // Interrupt 27 unpend
+#define NVIC_UNPEND0_INT26      0x04000000  // Interrupt 26 unpend
+#define NVIC_UNPEND0_INT25      0x02000000  // Interrupt 25 unpend
+#define NVIC_UNPEND0_INT24      0x01000000  // Interrupt 24 unpend
+#define NVIC_UNPEND0_INT23      0x00800000  // Interrupt 23 unpend
+#define NVIC_UNPEND0_INT22      0x00400000  // Interrupt 22 unpend
+#define NVIC_UNPEND0_INT21      0x00200000  // Interrupt 21 unpend
+#define NVIC_UNPEND0_INT20      0x00100000  // Interrupt 20 unpend
+#define NVIC_UNPEND0_INT19      0x00080000  // Interrupt 19 unpend
+#define NVIC_UNPEND0_INT18      0x00040000  // Interrupt 18 unpend
+#define NVIC_UNPEND0_INT17      0x00020000  // Interrupt 17 unpend
+#define NVIC_UNPEND0_INT16      0x00010000  // Interrupt 16 unpend
+#define NVIC_UNPEND0_INT15      0x00008000  // Interrupt 15 unpend
+#define NVIC_UNPEND0_INT14      0x00004000  // Interrupt 14 unpend
+#define NVIC_UNPEND0_INT13      0x00002000  // Interrupt 13 unpend
+#define NVIC_UNPEND0_INT12      0x00001000  // Interrupt 12 unpend
+#define NVIC_UNPEND0_INT11      0x00000800  // Interrupt 11 unpend
+#define NVIC_UNPEND0_INT10      0x00000400  // Interrupt 10 unpend
+#define NVIC_UNPEND0_INT9       0x00000200  // Interrupt 9 unpend
+#define NVIC_UNPEND0_INT8       0x00000100  // Interrupt 8 unpend
+#define NVIC_UNPEND0_INT7       0x00000080  // Interrupt 7 unpend
+#define NVIC_UNPEND0_INT6       0x00000040  // Interrupt 6 unpend
+#define NVIC_UNPEND0_INT5       0x00000020  // Interrupt 5 unpend
+#define NVIC_UNPEND0_INT4       0x00000010  // Interrupt 4 unpend
+#define NVIC_UNPEND0_INT3       0x00000008  // Interrupt 3 unpend
+#define NVIC_UNPEND0_INT2       0x00000004  // Interrupt 2 unpend
+#define NVIC_UNPEND0_INT1       0x00000002  // Interrupt 1 unpend
+#define NVIC_UNPEND0_INT0       0x00000001  // Interrupt 0 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND1 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND1_INT59      0x08000000  // Interrupt 59 unpend
+#define NVIC_UNPEND1_INT58      0x04000000  // Interrupt 58 unpend
+#define NVIC_UNPEND1_INT57      0x02000000  // Interrupt 57 unpend
+#define NVIC_UNPEND1_INT56      0x01000000  // Interrupt 56 unpend
+#define NVIC_UNPEND1_INT55      0x00800000  // Interrupt 55 unpend
+#define NVIC_UNPEND1_INT54      0x00400000  // Interrupt 54 unpend
+#define NVIC_UNPEND1_INT53      0x00200000  // Interrupt 53 unpend
+#define NVIC_UNPEND1_INT52      0x00100000  // Interrupt 52 unpend
+#define NVIC_UNPEND1_INT51      0x00080000  // Interrupt 51 unpend
+#define NVIC_UNPEND1_INT50      0x00040000  // Interrupt 50 unpend
+#define NVIC_UNPEND1_INT49      0x00020000  // Interrupt 49 unpend
+#define NVIC_UNPEND1_INT48      0x00010000  // Interrupt 48 unpend
+#define NVIC_UNPEND1_INT47      0x00008000  // Interrupt 47 unpend
+#define NVIC_UNPEND1_INT46      0x00004000  // Interrupt 46 unpend
+#define NVIC_UNPEND1_INT45      0x00002000  // Interrupt 45 unpend
+#define NVIC_UNPEND1_INT44      0x00001000  // Interrupt 44 unpend
+#define NVIC_UNPEND1_INT43      0x00000800  // Interrupt 43 unpend
+#define NVIC_UNPEND1_INT42      0x00000400  // Interrupt 42 unpend
+#define NVIC_UNPEND1_INT41      0x00000200  // Interrupt 41 unpend
+#define NVIC_UNPEND1_INT40      0x00000100  // Interrupt 40 unpend
+#define NVIC_UNPEND1_INT39      0x00000080  // Interrupt 39 unpend
+#define NVIC_UNPEND1_INT38      0x00000040  // Interrupt 38 unpend
+#define NVIC_UNPEND1_INT37      0x00000020  // Interrupt 37 unpend
+#define NVIC_UNPEND1_INT36      0x00000010  // Interrupt 36 unpend
+#define NVIC_UNPEND1_INT35      0x00000008  // Interrupt 35 unpend
+#define NVIC_UNPEND1_INT34      0x00000004  // Interrupt 34 unpend
+#define NVIC_UNPEND1_INT33      0x00000002  // Interrupt 33 unpend
+#define NVIC_UNPEND1_INT32      0x00000001  // Interrupt 32 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE0 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE0_INT31      0x80000000  // Interrupt 31 active
+#define NVIC_ACTIVE0_INT30      0x40000000  // Interrupt 30 active
+#define NVIC_ACTIVE0_INT29      0x20000000  // Interrupt 29 active
+#define NVIC_ACTIVE0_INT28      0x10000000  // Interrupt 28 active
+#define NVIC_ACTIVE0_INT27      0x08000000  // Interrupt 27 active
+#define NVIC_ACTIVE0_INT26      0x04000000  // Interrupt 26 active
+#define NVIC_ACTIVE0_INT25      0x02000000  // Interrupt 25 active
+#define NVIC_ACTIVE0_INT24      0x01000000  // Interrupt 24 active
+#define NVIC_ACTIVE0_INT23      0x00800000  // Interrupt 23 active
+#define NVIC_ACTIVE0_INT22      0x00400000  // Interrupt 22 active
+#define NVIC_ACTIVE0_INT21      0x00200000  // Interrupt 21 active
+#define NVIC_ACTIVE0_INT20      0x00100000  // Interrupt 20 active
+#define NVIC_ACTIVE0_INT19      0x00080000  // Interrupt 19 active
+#define NVIC_ACTIVE0_INT18      0x00040000  // Interrupt 18 active
+#define NVIC_ACTIVE0_INT17      0x00020000  // Interrupt 17 active
+#define NVIC_ACTIVE0_INT16      0x00010000  // Interrupt 16 active
+#define NVIC_ACTIVE0_INT15      0x00008000  // Interrupt 15 active
+#define NVIC_ACTIVE0_INT14      0x00004000  // Interrupt 14 active
+#define NVIC_ACTIVE0_INT13      0x00002000  // Interrupt 13 active
+#define NVIC_ACTIVE0_INT12      0x00001000  // Interrupt 12 active
+#define NVIC_ACTIVE0_INT11      0x00000800  // Interrupt 11 active
+#define NVIC_ACTIVE0_INT10      0x00000400  // Interrupt 10 active
+#define NVIC_ACTIVE0_INT9       0x00000200  // Interrupt 9 active
+#define NVIC_ACTIVE0_INT8       0x00000100  // Interrupt 8 active
+#define NVIC_ACTIVE0_INT7       0x00000080  // Interrupt 7 active
+#define NVIC_ACTIVE0_INT6       0x00000040  // Interrupt 6 active
+#define NVIC_ACTIVE0_INT5       0x00000020  // Interrupt 5 active
+#define NVIC_ACTIVE0_INT4       0x00000010  // Interrupt 4 active
+#define NVIC_ACTIVE0_INT3       0x00000008  // Interrupt 3 active
+#define NVIC_ACTIVE0_INT2       0x00000004  // Interrupt 2 active
+#define NVIC_ACTIVE0_INT1       0x00000002  // Interrupt 1 active
+#define NVIC_ACTIVE0_INT0       0x00000001  // Interrupt 0 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE1 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE1_INT59      0x08000000  // Interrupt 59 active
+#define NVIC_ACTIVE1_INT58      0x04000000  // Interrupt 58 active
+#define NVIC_ACTIVE1_INT57      0x02000000  // Interrupt 57 active
+#define NVIC_ACTIVE1_INT56      0x01000000  // Interrupt 56 active
+#define NVIC_ACTIVE1_INT55      0x00800000  // Interrupt 55 active
+#define NVIC_ACTIVE1_INT54      0x00400000  // Interrupt 54 active
+#define NVIC_ACTIVE1_INT53      0x00200000  // Interrupt 53 active
+#define NVIC_ACTIVE1_INT52      0x00100000  // Interrupt 52 active
+#define NVIC_ACTIVE1_INT51      0x00080000  // Interrupt 51 active
+#define NVIC_ACTIVE1_INT50      0x00040000  // Interrupt 50 active
+#define NVIC_ACTIVE1_INT49      0x00020000  // Interrupt 49 active
+#define NVIC_ACTIVE1_INT48      0x00010000  // Interrupt 48 active
+#define NVIC_ACTIVE1_INT47      0x00008000  // Interrupt 47 active
+#define NVIC_ACTIVE1_INT46      0x00004000  // Interrupt 46 active
+#define NVIC_ACTIVE1_INT45      0x00002000  // Interrupt 45 active
+#define NVIC_ACTIVE1_INT44      0x00001000  // Interrupt 44 active
+#define NVIC_ACTIVE1_INT43      0x00000800  // Interrupt 43 active
+#define NVIC_ACTIVE1_INT42      0x00000400  // Interrupt 42 active
+#define NVIC_ACTIVE1_INT41      0x00000200  // Interrupt 41 active
+#define NVIC_ACTIVE1_INT40      0x00000100  // Interrupt 40 active
+#define NVIC_ACTIVE1_INT39      0x00000080  // Interrupt 39 active
+#define NVIC_ACTIVE1_INT38      0x00000040  // Interrupt 38 active
+#define NVIC_ACTIVE1_INT37      0x00000020  // Interrupt 37 active
+#define NVIC_ACTIVE1_INT36      0x00000010  // Interrupt 36 active
+#define NVIC_ACTIVE1_INT35      0x00000008  // Interrupt 35 active
+#define NVIC_ACTIVE1_INT34      0x00000004  // Interrupt 34 active
+#define NVIC_ACTIVE1_INT33      0x00000002  // Interrupt 33 active
+#define NVIC_ACTIVE1_INT32      0x00000001  // Interrupt 32 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI0 register.
+//
+//*****************************************************************************
+#define NVIC_PRI0_INT3_M        0xFF000000  // Interrupt 3 priority mask
+#define NVIC_PRI0_INT2_M        0x00FF0000  // Interrupt 2 priority mask
+#define NVIC_PRI0_INT1_M        0x0000FF00  // Interrupt 1 priority mask
+#define NVIC_PRI0_INT0_M        0x000000FF  // Interrupt 0 priority mask
+#define NVIC_PRI0_INT3_S        24
+#define NVIC_PRI0_INT2_S        16
+#define NVIC_PRI0_INT1_S        8
+#define NVIC_PRI0_INT0_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_PRI1_INT7_M        0xFF000000  // Interrupt 7 priority mask
+#define NVIC_PRI1_INT6_M        0x00FF0000  // Interrupt 6 priority mask
+#define NVIC_PRI1_INT5_M        0x0000FF00  // Interrupt 5 priority mask
+#define NVIC_PRI1_INT4_M        0x000000FF  // Interrupt 4 priority mask
+#define NVIC_PRI1_INT7_S        24
+#define NVIC_PRI1_INT6_S        16
+#define NVIC_PRI1_INT5_S        8
+#define NVIC_PRI1_INT4_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_PRI2_INT11_M       0xFF000000  // Interrupt 11 priority mask
+#define NVIC_PRI2_INT10_M       0x00FF0000  // Interrupt 10 priority mask
+#define NVIC_PRI2_INT9_M        0x0000FF00  // Interrupt 9 priority mask
+#define NVIC_PRI2_INT8_M        0x000000FF  // Interrupt 8 priority mask
+#define NVIC_PRI2_INT11_S       24
+#define NVIC_PRI2_INT10_S       16
+#define NVIC_PRI2_INT9_S        8
+#define NVIC_PRI2_INT8_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_PRI3_INT15_M       0xFF000000  // Interrupt 15 priority mask
+#define NVIC_PRI3_INT14_M       0x00FF0000  // Interrupt 14 priority mask
+#define NVIC_PRI3_INT13_M       0x0000FF00  // Interrupt 13 priority mask
+#define NVIC_PRI3_INT12_M       0x000000FF  // Interrupt 12 priority mask
+#define NVIC_PRI3_INT15_S       24
+#define NVIC_PRI3_INT14_S       16
+#define NVIC_PRI3_INT13_S       8
+#define NVIC_PRI3_INT12_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI4 register.
+//
+//*****************************************************************************
+#define NVIC_PRI4_INT19_M       0xFF000000  // Interrupt 19 priority mask
+#define NVIC_PRI4_INT18_M       0x00FF0000  // Interrupt 18 priority mask
+#define NVIC_PRI4_INT17_M       0x0000FF00  // Interrupt 17 priority mask
+#define NVIC_PRI4_INT16_M       0x000000FF  // Interrupt 16 priority mask
+#define NVIC_PRI4_INT19_S       24
+#define NVIC_PRI4_INT18_S       16
+#define NVIC_PRI4_INT17_S       8
+#define NVIC_PRI4_INT16_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI5 register.
+//
+//*****************************************************************************
+#define NVIC_PRI5_INT23_M       0xFF000000  // Interrupt 23 priority mask
+#define NVIC_PRI5_INT22_M       0x00FF0000  // Interrupt 22 priority mask
+#define NVIC_PRI5_INT21_M       0x0000FF00  // Interrupt 21 priority mask
+#define NVIC_PRI5_INT20_M       0x000000FF  // Interrupt 20 priority mask
+#define NVIC_PRI5_INT23_S       24
+#define NVIC_PRI5_INT22_S       16
+#define NVIC_PRI5_INT21_S       8
+#define NVIC_PRI5_INT20_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI6 register.
+//
+//*****************************************************************************
+#define NVIC_PRI6_INT27_M       0xFF000000  // Interrupt 27 priority mask
+#define NVIC_PRI6_INT26_M       0x00FF0000  // Interrupt 26 priority mask
+#define NVIC_PRI6_INT25_M       0x0000FF00  // Interrupt 25 priority mask
+#define NVIC_PRI6_INT24_M       0x000000FF  // Interrupt 24 priority mask
+#define NVIC_PRI6_INT27_S       24
+#define NVIC_PRI6_INT26_S       16
+#define NVIC_PRI6_INT25_S       8
+#define NVIC_PRI6_INT24_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI7 register.
+//
+//*****************************************************************************
+#define NVIC_PRI7_INT31_M       0xFF000000  // Interrupt 31 priority mask
+#define NVIC_PRI7_INT30_M       0x00FF0000  // Interrupt 30 priority mask
+#define NVIC_PRI7_INT29_M       0x0000FF00  // Interrupt 29 priority mask
+#define NVIC_PRI7_INT28_M       0x000000FF  // Interrupt 28 priority mask
+#define NVIC_PRI7_INT31_S       24
+#define NVIC_PRI7_INT30_S       16
+#define NVIC_PRI7_INT29_S       8
+#define NVIC_PRI7_INT28_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI8 register.
+//
+//*****************************************************************************
+#define NVIC_PRI8_INT35_M       0xFF000000  // Interrupt 35 priority mask
+#define NVIC_PRI8_INT34_M       0x00FF0000  // Interrupt 34 priority mask
+#define NVIC_PRI8_INT33_M       0x0000FF00  // Interrupt 33 priority mask
+#define NVIC_PRI8_INT32_M       0x000000FF  // Interrupt 32 priority mask
+#define NVIC_PRI8_INT35_S       24
+#define NVIC_PRI8_INT34_S       16
+#define NVIC_PRI8_INT33_S       8
+#define NVIC_PRI8_INT32_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI9 register.
+//
+//*****************************************************************************
+#define NVIC_PRI9_INT39_M       0xFF000000  // Interrupt 39 priority mask
+#define NVIC_PRI9_INT38_M       0x00FF0000  // Interrupt 38 priority mask
+#define NVIC_PRI9_INT37_M       0x0000FF00  // Interrupt 37 priority mask
+#define NVIC_PRI9_INT36_M       0x000000FF  // Interrupt 36 priority mask
+#define NVIC_PRI9_INT39_S       24
+#define NVIC_PRI9_INT38_S       16
+#define NVIC_PRI9_INT37_S       8
+#define NVIC_PRI9_INT36_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI10 register.
+//
+//*****************************************************************************
+#define NVIC_PRI10_INT43_M      0xFF000000  // Interrupt 43 priority mask
+#define NVIC_PRI10_INT42_M      0x00FF0000  // Interrupt 42 priority mask
+#define NVIC_PRI10_INT41_M      0x0000FF00  // Interrupt 41 priority mask
+#define NVIC_PRI10_INT40_M      0x000000FF  // Interrupt 40 priority mask
+#define NVIC_PRI10_INT43_S      24
+#define NVIC_PRI10_INT42_S      16
+#define NVIC_PRI10_INT41_S      8
+#define NVIC_PRI10_INT40_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CPUID register.
+//
+//*****************************************************************************
+#define NVIC_CPUID_IMP_M        0xFF000000  // Implementer
+#define NVIC_CPUID_VAR_M        0x00F00000  // Variant
+#define NVIC_CPUID_PARTNO_M     0x0000FFF0  // Processor part number
+#define NVIC_CPUID_REV_M        0x0000000F  // Revision
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_INT_CTRL_NMI_SET   0x80000000  // Pend a NMI
+#define NVIC_INT_CTRL_PEND_SV   0x10000000  // Pend a PendSV
+#define NVIC_INT_CTRL_UNPEND_SV 0x08000000  // Unpend a PendSV
+#define NVIC_INT_CTRL_ISR_PRE   0x00800000  // Debug interrupt handling
+#define NVIC_INT_CTRL_ISR_PEND  0x00400000  // Debug interrupt pending
+#define NVIC_INT_CTRL_VEC_PEN_M 0x003FF000  // Highest pending exception
+#define NVIC_INT_CTRL_RET_BASE  0x00000800  // Return to base
+#define NVIC_INT_CTRL_VEC_ACT_M 0x000003FF  // Current active exception
+#define NVIC_INT_CTRL_VEC_PEN_S 12
+#define NVIC_INT_CTRL_VEC_ACT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_VTABLE register.
+//
+//*****************************************************************************
+#define NVIC_VTABLE_BASE        0x20000000  // Vector table base
+#define NVIC_VTABLE_OFFSET_M    0x1FFFFF00  // Vector table offset
+#define NVIC_VTABLE_OFFSET_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_APINT register.
+//
+//*****************************************************************************
+#define NVIC_APINT_VECTKEY_M    0xFFFF0000  // Vector key mask
+#define NVIC_APINT_VECTKEY      0x05FA0000  // Vector key
+#define NVIC_APINT_ENDIANESS    0x00008000  // Data endianess
+#define NVIC_APINT_PRIGROUP_M   0x00000700  // Priority group
+#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
+#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
+#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
+#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
+#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
+#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
+#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
+#define NVIC_APINT_SYSRESETREQ  0x00000004  // System reset request
+#define NVIC_APINT_VECT_CLR_ACT 0x00000002  // Clear active NMI/fault info
+#define NVIC_APINT_VECT_RESET   0x00000001  // System reset
+#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_SYS_CTRL_SEVONPEND 0x00000010  // Wakeup on pend
+#define NVIC_SYS_CTRL_SLEEPDEEP 0x00000004  // Deep sleep enable
+#define NVIC_SYS_CTRL_SLEEPEXIT 0x00000002  // Sleep on ISR exit
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CFG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_CFG_CTRL_BFHFNMIGN 0x00000100  // Ignore bus fault in NMI/fault
+#define NVIC_CFG_CTRL_DIV0      0x00000010  // Trap on divide by 0
+#define NVIC_CFG_CTRL_UNALIGNED 0x00000008  // Trap on unaligned access
+#define NVIC_CFG_CTRL_DEEP_PEND 0x00000004  // Allow deep interrupt trigger
+#define NVIC_CFG_CTRL_MAIN_PEND 0x00000002  // Allow main interrupt trigger
+#define NVIC_CFG_CTRL_BASE_THR  0x00000001  // Thread state control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI1_RES_M     0xFF000000  // Priority of reserved handler
+#define NVIC_SYS_PRI1_USAGE_M   0x00FF0000  // Priority of usage fault handler
+#define NVIC_SYS_PRI1_BUS_M     0x0000FF00  // Priority of bus fault handler
+#define NVIC_SYS_PRI1_MEM_M     0x000000FF  // Priority of mem manage handler
+#define NVIC_SYS_PRI1_USAGE_S   16
+#define NVIC_SYS_PRI1_BUS_S     8
+#define NVIC_SYS_PRI1_MEM_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI2_SVC_M     0xFF000000  // Priority of SVCall handler
+#define NVIC_SYS_PRI2_RES_M     0x00FFFFFF  // Priority of reserved handlers
+#define NVIC_SYS_PRI2_SVC_S     24
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI3_TICK_M    0xFF000000  // Priority of Sys Tick handler
+#define NVIC_SYS_PRI3_PENDSV_M  0x00FF0000  // Priority of PendSV handler
+#define NVIC_SYS_PRI3_RES_M     0x0000FF00  // Priority of reserved handler
+#define NVIC_SYS_PRI3_DEBUG_M   0x000000FF  // Priority of debug handler
+#define NVIC_SYS_PRI3_TICK_S    24
+#define NVIC_SYS_PRI3_PENDSV_S  16
+#define NVIC_SYS_PRI3_DEBUG_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_HND_CTRL
+// register.
+//
+//*****************************************************************************
+#define NVIC_SYS_HND_CTRL_USAGE 0x00040000  // Usage fault enable
+#define NVIC_SYS_HND_CTRL_BUS   0x00020000  // Bus fault enable
+#define NVIC_SYS_HND_CTRL_MEM   0x00010000  // Mem manage fault enable
+#define NVIC_SYS_HND_CTRL_SVC   0x00008000  // SVCall is pended
+#define NVIC_SYS_HND_CTRL_BUSP  0x00004000  // Bus fault is pended
+#define NVIC_SYS_HND_CTRL_TICK  0x00000800  // Sys tick is active
+#define NVIC_SYS_HND_CTRL_PNDSV 0x00000400  // PendSV is active
+#define NVIC_SYS_HND_CTRL_MON   0x00000100  // Monitor is active
+#define NVIC_SYS_HND_CTRL_SVCA  0x00000080  // SVCall is active
+#define NVIC_SYS_HND_CTRL_USGA  0x00000008  // Usage fault is active
+#define NVIC_SYS_HND_CTRL_BUSA  0x00000002  // Bus fault is active
+#define NVIC_SYS_HND_CTRL_MEMA  0x00000001  // Mem manage is active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_STAT_DIV0    0x02000000  // Divide by zero fault
+#define NVIC_FAULT_STAT_UNALIGN 0x01000000  // Unaligned access fault
+#define NVIC_FAULT_STAT_NOCP    0x00080000  // No coprocessor fault
+#define NVIC_FAULT_STAT_INVPC   0x00040000  // Invalid PC fault
+#define NVIC_FAULT_STAT_INVSTAT 0x00020000  // Invalid state fault
+#define NVIC_FAULT_STAT_UNDEF   0x00010000  // Undefined instruction fault
+#define NVIC_FAULT_STAT_BFARV   0x00008000  // BFAR is valid
+#define NVIC_FAULT_STAT_BSTKE   0x00001000  // Stack bus fault
+#define NVIC_FAULT_STAT_BUSTKE  0x00000800  // Unstack bus fault
+#define NVIC_FAULT_STAT_IMPRE   0x00000400  // Imprecise data bus error
+#define NVIC_FAULT_STAT_PRECISE 0x00000200  // Precise data bus error
+#define NVIC_FAULT_STAT_IBUS    0x00000100  // Instruction bus fault
+#define NVIC_FAULT_STAT_MMARV   0x00000080  // MMAR is valid
+#define NVIC_FAULT_STAT_MSTKE   0x00000010  // Stack access violation
+#define NVIC_FAULT_STAT_MUSTKE  0x00000008  // Unstack access violation
+#define NVIC_FAULT_STAT_DERR    0x00000002  // Data access violation
+#define NVIC_FAULT_STAT_IERR    0x00000001  // Instruction access violation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_HFAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_HFAULT_STAT_DBG    0x80000000  // Debug event
+#define NVIC_HFAULT_STAT_FORCED 0x40000000  // Cannot execute fault handler
+#define NVIC_HFAULT_STAT_VECT   0x00000002  // Vector table read fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DEBUG_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_DEBUG_STAT_EXTRNL  0x00000010  // EDBGRQ asserted
+#define NVIC_DEBUG_STAT_VCATCH  0x00000008  // Vector catch
+#define NVIC_DEBUG_STAT_DWTTRAP 0x00000004  // DWT match
+#define NVIC_DEBUG_STAT_BKPT    0x00000002  // Breakpoint instruction
+#define NVIC_DEBUG_STAT_HALTED  0x00000001  // Halt request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MM_ADDR register.
+//
+//*****************************************************************************
+#define NVIC_MM_ADDR_M          0xFFFFFFFF  // Data fault address
+#define NVIC_MM_ADDR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_ADDR
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_ADDR_M       0xFFFFFFFF  // Data bus fault address
+#define NVIC_FAULT_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_TYPE_IREGION_M 0x00FF0000  // Number of I regions
+#define NVIC_MPU_TYPE_DREGION_M 0x0000FF00  // Number of D regions
+#define NVIC_MPU_TYPE_SEPARATE  0x00000001  // Separate or unified MPU
+#define NVIC_MPU_TYPE_IREGION_S 16
+#define NVIC_MPU_TYPE_DREGION_S 8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_MPU_CTRL_PRIVDEFEN 0x00000004  // MPU default region in priv mode
+#define NVIC_MPU_CTRL_HFNMIENA  0x00000002  // MPU enabled during faults
+#define NVIC_MPU_CTRL_ENABLE    0x00000001  // MPU enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_NUMBER
+// register.
+//
+//*****************************************************************************
+#define NVIC_MPU_NUMBER_M       0x000000FF  // MPU region to access
+#define NVIC_MPU_NUMBER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE_ADDR_M    0xFFFFFFE0  // Base address mask
+#define NVIC_MPU_BASE_VALID     0x00000010  // Region number valid
+#define NVIC_MPU_BASE_REGION_M  0x0000000F  // Region number
+#define NVIC_MPU_BASE_ADDR_S    8
+#define NVIC_MPU_BASE_REGION_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR_M         0xFFFF0000  // Attributes
+#define NVIC_MPU_ATTR_AP_NO_NO  0x00000000  // prv: no access, usr: no access
+#define NVIC_MPU_ATTR_BUFFRABLE 0x00010000  // Bufferable
+#define NVIC_MPU_ATTR_CACHEABLE 0x00020000  // Cacheable
+#define NVIC_MPU_ATTR_SHAREABLE 0x00040000  // Shareable
+#define NVIC_MPU_ATTR_TEX_M     0x00380000  // Type extension mask
+#define NVIC_MPU_ATTR_AP_RW_NO  0x01000000  // prv: rw, usr: none
+#define NVIC_MPU_ATTR_AP_RW_RO  0x02000000  // prv: rw, usr: read-only
+#define NVIC_MPU_ATTR_AP_RW_RW  0x03000000  // prv: rw, usr: rw
+#define NVIC_MPU_ATTR_AP_RO_NO  0x05000000  // prv: ro, usr: none
+#define NVIC_MPU_ATTR_AP_RO_RO  0x06000000  // prv: ro, usr: ro
+#define NVIC_MPU_ATTR_AP_M      0x07000000  // Access permissions mask
+#define NVIC_MPU_ATTR_XN        0x10000000  // Execute disable
+#define NVIC_MPU_ATTR_SRD_M     0x0000FF00  // Sub-region disable mask
+#define NVIC_MPU_ATTR_SRD_0     0x00000100  // Sub-region 0 disable
+#define NVIC_MPU_ATTR_SRD_1     0x00000200  // Sub-region 1 disable
+#define NVIC_MPU_ATTR_SRD_2     0x00000400  // Sub-region 2 disable
+#define NVIC_MPU_ATTR_SRD_3     0x00000800  // Sub-region 3 disable
+#define NVIC_MPU_ATTR_SRD_4     0x00001000  // Sub-region 4 disable
+#define NVIC_MPU_ATTR_SRD_5     0x00002000  // Sub-region 5 disable
+#define NVIC_MPU_ATTR_SRD_6     0x00004000  // Sub-region 6 disable
+#define NVIC_MPU_ATTR_SRD_7     0x00008000  // Sub-region 7 disable
+#define NVIC_MPU_ATTR_SIZE_M    0x0000003E  // Region size mask
+#define NVIC_MPU_ATTR_SIZE_32B  0x00000008  // Region size 32 bytes
+#define NVIC_MPU_ATTR_SIZE_64B  0x0000000A  // Region size 64 bytes
+#define NVIC_MPU_ATTR_SIZE_128B 0x0000000C  // Region size 128 bytes
+#define NVIC_MPU_ATTR_SIZE_256B 0x0000000E  // Region size 256 bytes
+#define NVIC_MPU_ATTR_SIZE_512B 0x00000010  // Region size 512 bytes
+#define NVIC_MPU_ATTR_SIZE_1K   0x00000012  // Region size 1 Kbytes
+#define NVIC_MPU_ATTR_SIZE_2K   0x00000014  // Region size 2 Kbytes
+#define NVIC_MPU_ATTR_SIZE_4K   0x00000016  // Region size 4 Kbytes
+#define NVIC_MPU_ATTR_SIZE_8K   0x00000018  // Region size 8 Kbytes
+#define NVIC_MPU_ATTR_SIZE_16K  0x0000001A  // Region size 16 Kbytes
+#define NVIC_MPU_ATTR_SIZE_32K  0x0000001C  // Region size 32 Kbytes
+#define NVIC_MPU_ATTR_SIZE_64K  0x0000001E  // Region size 64 Kbytes
+#define NVIC_MPU_ATTR_SIZE_128K 0x00000020  // Region size 128 Kbytes
+#define NVIC_MPU_ATTR_SIZE_256K 0x00000022  // Region size 256 Kbytes
+#define NVIC_MPU_ATTR_SIZE_512K 0x00000024  // Region size 512 Kbytes
+#define NVIC_MPU_ATTR_SIZE_1M   0x00000026  // Region size 1 Mbytes
+#define NVIC_MPU_ATTR_SIZE_2M   0x00000028  // Region size 2 Mbytes
+#define NVIC_MPU_ATTR_SIZE_4M   0x0000002A  // Region size 4 Mbytes
+#define NVIC_MPU_ATTR_SIZE_8M   0x0000002C  // Region size 8 Mbytes
+#define NVIC_MPU_ATTR_SIZE_16M  0x0000002E  // Region size 16 Mbytes
+#define NVIC_MPU_ATTR_SIZE_32M  0x00000030  // Region size 32 Mbytes
+#define NVIC_MPU_ATTR_SIZE_64M  0x00000032  // Region size 64 Mbytes
+#define NVIC_MPU_ATTR_SIZE_128M 0x00000034  // Region size 128 Mbytes
+#define NVIC_MPU_ATTR_SIZE_256M 0x00000036  // Region size 256 Mbytes
+#define NVIC_MPU_ATTR_SIZE_512M 0x00000038  // Region size 512 Mbytes
+#define NVIC_MPU_ATTR_SIZE_1G   0x0000003A  // Region size 1 Gbytes
+#define NVIC_MPU_ATTR_SIZE_2G   0x0000003C  // Region size 2 Gbytes
+#define NVIC_MPU_ATTR_SIZE_4G   0x0000003E  // Region size 4 Gbytes
+#define NVIC_MPU_ATTR_ENABLE    0x00000001  // Region enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_DBG_CTRL_DBGKEY_M  0xFFFF0000  // Debug key mask
+#define NVIC_DBG_CTRL_DBGKEY    0xA05F0000  // Debug key
+#define NVIC_DBG_CTRL_S_RESET_ST \
+                                0x02000000  // Core has reset since last read
+#define NVIC_DBG_CTRL_S_RETIRE_ST \
+                                0x01000000  // Core has executed insruction
+                                            // since last read
+#define NVIC_DBG_CTRL_S_LOCKUP  0x00080000  // Core is locked up
+#define NVIC_DBG_CTRL_S_SLEEP   0x00040000  // Core is sleeping
+#define NVIC_DBG_CTRL_S_HALT    0x00020000  // Core status on halt
+#define NVIC_DBG_CTRL_S_REGRDY  0x00010000  // Register read/write available
+#define NVIC_DBG_CTRL_C_SNAPSTALL \
+                                0x00000020  // Breaks a stalled load/store
+#define NVIC_DBG_CTRL_C_MASKINT 0x00000008  // Mask interrupts when stepping
+#define NVIC_DBG_CTRL_C_STEP    0x00000004  // Step the core
+#define NVIC_DBG_CTRL_C_HALT    0x00000002  // Halt the core
+#define NVIC_DBG_CTRL_C_DEBUGEN 0x00000001  // Enable debug
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_XFER register.
+//
+//*****************************************************************************
+#define NVIC_DBG_XFER_REG_WNR   0x00010000  // Write or not read
+#define NVIC_DBG_XFER_REG_SEL_M 0x0000001F  // Register
+#define NVIC_DBG_XFER_REG_CFBP  0x00000014  // Control/Fault/BasePri/PriMask
+#define NVIC_DBG_XFER_REG_DSP   0x00000013  // Deep SP
+#define NVIC_DBG_XFER_REG_PSP   0x00000012  // Process SP
+#define NVIC_DBG_XFER_REG_MSP   0x00000011  // Main SP
+#define NVIC_DBG_XFER_REG_FLAGS 0x00000010  // xPSR/Flags register
+#define NVIC_DBG_XFER_REG_R15   0x0000000F  // Register R15
+#define NVIC_DBG_XFER_REG_R14   0x0000000E  // Register R14
+#define NVIC_DBG_XFER_REG_R13   0x0000000D  // Register R13
+#define NVIC_DBG_XFER_REG_R12   0x0000000C  // Register R12
+#define NVIC_DBG_XFER_REG_R11   0x0000000B  // Register R11
+#define NVIC_DBG_XFER_REG_R10   0x0000000A  // Register R10
+#define NVIC_DBG_XFER_REG_R9    0x00000009  // Register R9
+#define NVIC_DBG_XFER_REG_R8    0x00000008  // Register R8
+#define NVIC_DBG_XFER_REG_R7    0x00000007  // Register R7
+#define NVIC_DBG_XFER_REG_R6    0x00000006  // Register R6
+#define NVIC_DBG_XFER_REG_R5    0x00000005  // Register R5
+#define NVIC_DBG_XFER_REG_R4    0x00000004  // Register R4
+#define NVIC_DBG_XFER_REG_R3    0x00000003  // Register R3
+#define NVIC_DBG_XFER_REG_R2    0x00000002  // Register R2
+#define NVIC_DBG_XFER_REG_R1    0x00000001  // Register R1
+#define NVIC_DBG_XFER_REG_R0    0x00000000  // Register R0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_DATA register.
+//
+//*****************************************************************************
+#define NVIC_DBG_DATA_M         0xFFFFFFFF  // Data temporary cache
+#define NVIC_DBG_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_INT register.
+//
+//*****************************************************************************
+#define NVIC_DBG_INT_HARDERR    0x00000400  // Debug trap on hard fault
+#define NVIC_DBG_INT_INTERR     0x00000200  // Debug trap on interrupt errors
+#define NVIC_DBG_INT_BUSERR     0x00000100  // Debug trap on bus error
+#define NVIC_DBG_INT_STATERR    0x00000080  // Debug trap on usage fault state
+#define NVIC_DBG_INT_CHKERR     0x00000040  // Debug trap on usage fault check
+#define NVIC_DBG_INT_NOCPERR    0x00000020  // Debug trap on coprocessor error
+#define NVIC_DBG_INT_MMERR      0x00000010  // Debug trap on mem manage fault
+#define NVIC_DBG_INT_RESET      0x00000008  // Core reset status
+#define NVIC_DBG_INT_RSTPENDCLR 0x00000004  // Clear pending core reset
+#define NVIC_DBG_INT_RSTPENDING 0x00000002  // Core reset is pending
+#define NVIC_DBG_INT_RSTVCATCH  0x00000001  // Reset vector catch
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SW_TRIG register.
+//
+//*****************************************************************************
+#define NVIC_SW_TRIG_INTID_M    0x000003FF  // Interrupt to trigger
+#define NVIC_SW_TRIG_INTID_S    0
+
+#endif // __LM3S6918_H__


Property changes on: trunk/src/platform/lm3s/lm3s6918.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/lm3s6965.h
===================================================================
--- trunk/src/platform/lm3s/lm3s6965.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/lm3s6965.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,4565 @@
+//*****************************************************************************
+//
+// lm3s6965.h - LM3S6965 Register Definitions
+//
+// Copyright (c) 2007-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __LM3S6965_H__
+#define __LM3S6965_H__
+
+//*****************************************************************************
+//
+// Watchdog Timer (WATCHDOG)
+//
+//*****************************************************************************
+#define WATCHDOG_LOAD_R         (*((volatile unsigned long *)0x40000000))
+#define WATCHDOG_VALUE_R        (*((volatile unsigned long *)0x40000004))
+#define WATCHDOG_CTL_R          (*((volatile unsigned long *)0x40000008))
+#define WATCHDOG_ICR_R          (*((volatile unsigned long *)0x4000000C))
+#define WATCHDOG_RIS_R          (*((volatile unsigned long *)0x40000010))
+#define WATCHDOG_MIS_R          (*((volatile unsigned long *)0x40000014))
+#define WATCHDOG_TEST_R         (*((volatile unsigned long *)0x40000418))
+#define WATCHDOG_LOCK_R         (*((volatile unsigned long *)0x40000C00))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTA)
+//
+//*****************************************************************************
+#define GPIO_PORTA_DATA_BITS_R  ((volatile unsigned long *)0x40004000)
+#define GPIO_PORTA_DATA_R       (*((volatile unsigned long *)0x400043FC))
+#define GPIO_PORTA_DIR_R        (*((volatile unsigned long *)0x40004400))
+#define GPIO_PORTA_IS_R         (*((volatile unsigned long *)0x40004404))
+#define GPIO_PORTA_IBE_R        (*((volatile unsigned long *)0x40004408))
+#define GPIO_PORTA_IEV_R        (*((volatile unsigned long *)0x4000440C))
+#define GPIO_PORTA_IM_R         (*((volatile unsigned long *)0x40004410))
+#define GPIO_PORTA_RIS_R        (*((volatile unsigned long *)0x40004414))
+#define GPIO_PORTA_MIS_R        (*((volatile unsigned long *)0x40004418))
+#define GPIO_PORTA_ICR_R        (*((volatile unsigned long *)0x4000441C))
+#define GPIO_PORTA_AFSEL_R      (*((volatile unsigned long *)0x40004420))
+#define GPIO_PORTA_DR2R_R       (*((volatile unsigned long *)0x40004500))
+#define GPIO_PORTA_DR4R_R       (*((volatile unsigned long *)0x40004504))
+#define GPIO_PORTA_DR8R_R       (*((volatile unsigned long *)0x40004508))
+#define GPIO_PORTA_ODR_R        (*((volatile unsigned long *)0x4000450C))
+#define GPIO_PORTA_PUR_R        (*((volatile unsigned long *)0x40004510))
+#define GPIO_PORTA_PDR_R        (*((volatile unsigned long *)0x40004514))
+#define GPIO_PORTA_SLR_R        (*((volatile unsigned long *)0x40004518))
+#define GPIO_PORTA_DEN_R        (*((volatile unsigned long *)0x4000451C))
+#define GPIO_PORTA_LOCK_R       (*((volatile unsigned long *)0x40004520))
+#define GPIO_PORTA_CR_R         (*((volatile unsigned long *)0x40004524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTB)
+//
+//*****************************************************************************
+#define GPIO_PORTB_DATA_BITS_R  ((volatile unsigned long *)0x40005000)
+#define GPIO_PORTB_DATA_R       (*((volatile unsigned long *)0x400053FC))
+#define GPIO_PORTB_DIR_R        (*((volatile unsigned long *)0x40005400))
+#define GPIO_PORTB_IS_R         (*((volatile unsigned long *)0x40005404))
+#define GPIO_PORTB_IBE_R        (*((volatile unsigned long *)0x40005408))
+#define GPIO_PORTB_IEV_R        (*((volatile unsigned long *)0x4000540C))
+#define GPIO_PORTB_IM_R         (*((volatile unsigned long *)0x40005410))
+#define GPIO_PORTB_RIS_R        (*((volatile unsigned long *)0x40005414))
+#define GPIO_PORTB_MIS_R        (*((volatile unsigned long *)0x40005418))
+#define GPIO_PORTB_ICR_R        (*((volatile unsigned long *)0x4000541C))
+#define GPIO_PORTB_AFSEL_R      (*((volatile unsigned long *)0x40005420))
+#define GPIO_PORTB_DR2R_R       (*((volatile unsigned long *)0x40005500))
+#define GPIO_PORTB_DR4R_R       (*((volatile unsigned long *)0x40005504))
+#define GPIO_PORTB_DR8R_R       (*((volatile unsigned long *)0x40005508))
+#define GPIO_PORTB_ODR_R        (*((volatile unsigned long *)0x4000550C))
+#define GPIO_PORTB_PUR_R        (*((volatile unsigned long *)0x40005510))
+#define GPIO_PORTB_PDR_R        (*((volatile unsigned long *)0x40005514))
+#define GPIO_PORTB_SLR_R        (*((volatile unsigned long *)0x40005518))
+#define GPIO_PORTB_DEN_R        (*((volatile unsigned long *)0x4000551C))
+#define GPIO_PORTB_LOCK_R       (*((volatile unsigned long *)0x40005520))
+#define GPIO_PORTB_CR_R         (*((volatile unsigned long *)0x40005524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTC)
+//
+//*****************************************************************************
+#define GPIO_PORTC_DATA_BITS_R  ((volatile unsigned long *)0x40006000)
+#define GPIO_PORTC_DATA_R       (*((volatile unsigned long *)0x400063FC))
+#define GPIO_PORTC_DIR_R        (*((volatile unsigned long *)0x40006400))
+#define GPIO_PORTC_IS_R         (*((volatile unsigned long *)0x40006404))
+#define GPIO_PORTC_IBE_R        (*((volatile unsigned long *)0x40006408))
+#define GPIO_PORTC_IEV_R        (*((volatile unsigned long *)0x4000640C))
+#define GPIO_PORTC_IM_R         (*((volatile unsigned long *)0x40006410))
+#define GPIO_PORTC_RIS_R        (*((volatile unsigned long *)0x40006414))
+#define GPIO_PORTC_MIS_R        (*((volatile unsigned long *)0x40006418))
+#define GPIO_PORTC_ICR_R        (*((volatile unsigned long *)0x4000641C))
+#define GPIO_PORTC_AFSEL_R      (*((volatile unsigned long *)0x40006420))
+#define GPIO_PORTC_DR2R_R       (*((volatile unsigned long *)0x40006500))
+#define GPIO_PORTC_DR4R_R       (*((volatile unsigned long *)0x40006504))
+#define GPIO_PORTC_DR8R_R       (*((volatile unsigned long *)0x40006508))
+#define GPIO_PORTC_ODR_R        (*((volatile unsigned long *)0x4000650C))
+#define GPIO_PORTC_PUR_R        (*((volatile unsigned long *)0x40006510))
+#define GPIO_PORTC_PDR_R        (*((volatile unsigned long *)0x40006514))
+#define GPIO_PORTC_SLR_R        (*((volatile unsigned long *)0x40006518))
+#define GPIO_PORTC_DEN_R        (*((volatile unsigned long *)0x4000651C))
+#define GPIO_PORTC_LOCK_R       (*((volatile unsigned long *)0x40006520))
+#define GPIO_PORTC_CR_R         (*((volatile unsigned long *)0x40006524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTD)
+//
+//*****************************************************************************
+#define GPIO_PORTD_DATA_BITS_R  ((volatile unsigned long *)0x40007000)
+#define GPIO_PORTD_DATA_R       (*((volatile unsigned long *)0x400073FC))
+#define GPIO_PORTD_DIR_R        (*((volatile unsigned long *)0x40007400))
+#define GPIO_PORTD_IS_R         (*((volatile unsigned long *)0x40007404))
+#define GPIO_PORTD_IBE_R        (*((volatile unsigned long *)0x40007408))
+#define GPIO_PORTD_IEV_R        (*((volatile unsigned long *)0x4000740C))
+#define GPIO_PORTD_IM_R         (*((volatile unsigned long *)0x40007410))
+#define GPIO_PORTD_RIS_R        (*((volatile unsigned long *)0x40007414))
+#define GPIO_PORTD_MIS_R        (*((volatile unsigned long *)0x40007418))
+#define GPIO_PORTD_ICR_R        (*((volatile unsigned long *)0x4000741C))
+#define GPIO_PORTD_AFSEL_R      (*((volatile unsigned long *)0x40007420))
+#define GPIO_PORTD_DR2R_R       (*((volatile unsigned long *)0x40007500))
+#define GPIO_PORTD_DR4R_R       (*((volatile unsigned long *)0x40007504))
+#define GPIO_PORTD_DR8R_R       (*((volatile unsigned long *)0x40007508))
+#define GPIO_PORTD_ODR_R        (*((volatile unsigned long *)0x4000750C))
+#define GPIO_PORTD_PUR_R        (*((volatile unsigned long *)0x40007510))
+#define GPIO_PORTD_PDR_R        (*((volatile unsigned long *)0x40007514))
+#define GPIO_PORTD_SLR_R        (*((volatile unsigned long *)0x40007518))
+#define GPIO_PORTD_DEN_R        (*((volatile unsigned long *)0x4000751C))
+#define GPIO_PORTD_LOCK_R       (*((volatile unsigned long *)0x40007520))
+#define GPIO_PORTD_CR_R         (*((volatile unsigned long *)0x40007524))
+
+//*****************************************************************************
+//
+// Synchronous Serial Interface (SSI0)
+//
+//*****************************************************************************
+#define SSI0_CR0_R              (*((volatile unsigned long *)0x40008000))
+#define SSI0_CR1_R              (*((volatile unsigned long *)0x40008004))
+#define SSI0_DR_R               (*((volatile unsigned long *)0x40008008))
+#define SSI0_SR_R               (*((volatile unsigned long *)0x4000800C))
+#define SSI0_CPSR_R             (*((volatile unsigned long *)0x40008010))
+#define SSI0_IM_R               (*((volatile unsigned long *)0x40008014))
+#define SSI0_RIS_R              (*((volatile unsigned long *)0x40008018))
+#define SSI0_MIS_R              (*((volatile unsigned long *)0x4000801C))
+#define SSI0_ICR_R              (*((volatile unsigned long *)0x40008020))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART0)
+//
+//*****************************************************************************
+#define UART0_DR_R              (*((volatile unsigned long *)0x4000C000))
+#define UART0_RSR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_ECR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_FR_R              (*((volatile unsigned long *)0x4000C018))
+#define UART0_ILPR_R            (*((volatile unsigned long *)0x4000C020))
+#define UART0_IBRD_R            (*((volatile unsigned long *)0x4000C024))
+#define UART0_FBRD_R            (*((volatile unsigned long *)0x4000C028))
+#define UART0_LCRH_R            (*((volatile unsigned long *)0x4000C02C))
+#define UART0_CTL_R             (*((volatile unsigned long *)0x4000C030))
+#define UART0_IFLS_R            (*((volatile unsigned long *)0x4000C034))
+#define UART0_IM_R              (*((volatile unsigned long *)0x4000C038))
+#define UART0_RIS_R             (*((volatile unsigned long *)0x4000C03C))
+#define UART0_MIS_R             (*((volatile unsigned long *)0x4000C040))
+#define UART0_ICR_R             (*((volatile unsigned long *)0x4000C044))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART1)
+//
+//*****************************************************************************
+#define UART1_DR_R              (*((volatile unsigned long *)0x4000D000))
+#define UART1_RSR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_ECR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_FR_R              (*((volatile unsigned long *)0x4000D018))
+#define UART1_ILPR_R            (*((volatile unsigned long *)0x4000D020))
+#define UART1_IBRD_R            (*((volatile unsigned long *)0x4000D024))
+#define UART1_FBRD_R            (*((volatile unsigned long *)0x4000D028))
+#define UART1_LCRH_R            (*((volatile unsigned long *)0x4000D02C))
+#define UART1_CTL_R             (*((volatile unsigned long *)0x4000D030))
+#define UART1_IFLS_R            (*((volatile unsigned long *)0x4000D034))
+#define UART1_IM_R              (*((volatile unsigned long *)0x4000D038))
+#define UART1_RIS_R             (*((volatile unsigned long *)0x4000D03C))
+#define UART1_MIS_R             (*((volatile unsigned long *)0x4000D040))
+#define UART1_ICR_R             (*((volatile unsigned long *)0x4000D044))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART2)
+//
+//*****************************************************************************
+#define UART2_DR_R              (*((volatile unsigned long *)0x4000E000))
+#define UART2_RSR_R             (*((volatile unsigned long *)0x4000E004))
+#define UART2_ECR_R             (*((volatile unsigned long *)0x4000E004))
+#define UART2_FR_R              (*((volatile unsigned long *)0x4000E018))
+#define UART2_ILPR_R            (*((volatile unsigned long *)0x4000E020))
+#define UART2_IBRD_R            (*((volatile unsigned long *)0x4000E024))
+#define UART2_FBRD_R            (*((volatile unsigned long *)0x4000E028))
+#define UART2_LCRH_R            (*((volatile unsigned long *)0x4000E02C))
+#define UART2_CTL_R             (*((volatile unsigned long *)0x4000E030))
+#define UART2_IFLS_R            (*((volatile unsigned long *)0x4000E034))
+#define UART2_IM_R              (*((volatile unsigned long *)0x4000E038))
+#define UART2_RIS_R             (*((volatile unsigned long *)0x4000E03C))
+#define UART2_MIS_R             (*((volatile unsigned long *)0x4000E040))
+#define UART2_ICR_R             (*((volatile unsigned long *)0x4000E044))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (MASTER) Interface
+//
+//*****************************************************************************
+#define I2C0_MASTER_MSA_R       (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SOAR_R      (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SCSR_R      (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_MCS_R       (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_SDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MTPR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SIMR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SRIS_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MIMR_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MRIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SMIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SICR_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MMIS_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MICR_R      (*((volatile unsigned long *)0x4002001C))
+#define I2C0_MASTER_MCR_R       (*((volatile unsigned long *)0x40020020))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (SLAVE) Interface
+//
+//*****************************************************************************
+#define I2C0_SLAVE_MSA_R        (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SOAR_R       (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SCSR_R       (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_MCS_R        (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_SDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MTPR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SIMR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SRIS_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MIMR_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MRIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SMIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SICR_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MMIS_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MICR_R       (*((volatile unsigned long *)0x4002081C))
+#define I2C0_SLAVE_MCR_R        (*((volatile unsigned long *)0x40020820))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (MASTER) Interface
+//
+//*****************************************************************************
+#define I2C1_MASTER_MSA_R       (*((volatile unsigned long *)0x40021000))
+#define I2C1_MASTER_SOAR_R      (*((volatile unsigned long *)0x40021000))
+#define I2C1_MASTER_SCSR_R      (*((volatile unsigned long *)0x40021004))
+#define I2C1_MASTER_MCS_R       (*((volatile unsigned long *)0x40021004))
+#define I2C1_MASTER_SDR_R       (*((volatile unsigned long *)0x40021008))
+#define I2C1_MASTER_MDR_R       (*((volatile unsigned long *)0x40021008))
+#define I2C1_MASTER_MTPR_R      (*((volatile unsigned long *)0x4002100C))
+#define I2C1_MASTER_SIMR_R      (*((volatile unsigned long *)0x4002100C))
+#define I2C1_MASTER_SRIS_R      (*((volatile unsigned long *)0x40021010))
+#define I2C1_MASTER_MIMR_R      (*((volatile unsigned long *)0x40021010))
+#define I2C1_MASTER_MRIS_R      (*((volatile unsigned long *)0x40021014))
+#define I2C1_MASTER_SMIS_R      (*((volatile unsigned long *)0x40021014))
+#define I2C1_MASTER_SICR_R      (*((volatile unsigned long *)0x40021018))
+#define I2C1_MASTER_MMIS_R      (*((volatile unsigned long *)0x40021018))
+#define I2C1_MASTER_MICR_R      (*((volatile unsigned long *)0x4002101C))
+#define I2C1_MASTER_MCR_R       (*((volatile unsigned long *)0x40021020))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (SLAVE) Interface
+//
+//*****************************************************************************
+#define I2C1_SLAVE_MSA_R        (*((volatile unsigned long *)0x40021800))
+#define I2C1_SLAVE_SOAR_R       (*((volatile unsigned long *)0x40021800))
+#define I2C1_SLAVE_SCSR_R       (*((volatile unsigned long *)0x40021804))
+#define I2C1_SLAVE_MCS_R        (*((volatile unsigned long *)0x40021804))
+#define I2C1_SLAVE_SDR_R        (*((volatile unsigned long *)0x40021808))
+#define I2C1_SLAVE_MDR_R        (*((volatile unsigned long *)0x40021808))
+#define I2C1_SLAVE_MTPR_R       (*((volatile unsigned long *)0x4002180C))
+#define I2C1_SLAVE_SIMR_R       (*((volatile unsigned long *)0x4002180C))
+#define I2C1_SLAVE_SRIS_R       (*((volatile unsigned long *)0x40021810))
+#define I2C1_SLAVE_MIMR_R       (*((volatile unsigned long *)0x40021810))
+#define I2C1_SLAVE_MRIS_R       (*((volatile unsigned long *)0x40021814))
+#define I2C1_SLAVE_SMIS_R       (*((volatile unsigned long *)0x40021814))
+#define I2C1_SLAVE_SICR_R       (*((volatile unsigned long *)0x40021818))
+#define I2C1_SLAVE_MMIS_R       (*((volatile unsigned long *)0x40021818))
+#define I2C1_SLAVE_MICR_R       (*((volatile unsigned long *)0x4002181C))
+#define I2C1_SLAVE_MCR_R        (*((volatile unsigned long *)0x40021820))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTE)
+//
+//*****************************************************************************
+#define GPIO_PORTE_DATA_BITS_R  ((volatile unsigned long *)0x40024000)
+#define GPIO_PORTE_DATA_R       (*((volatile unsigned long *)0x400243FC))
+#define GPIO_PORTE_DIR_R        (*((volatile unsigned long *)0x40024400))
+#define GPIO_PORTE_IS_R         (*((volatile unsigned long *)0x40024404))
+#define GPIO_PORTE_IBE_R        (*((volatile unsigned long *)0x40024408))
+#define GPIO_PORTE_IEV_R        (*((volatile unsigned long *)0x4002440C))
+#define GPIO_PORTE_IM_R         (*((volatile unsigned long *)0x40024410))
+#define GPIO_PORTE_RIS_R        (*((volatile unsigned long *)0x40024414))
+#define GPIO_PORTE_MIS_R        (*((volatile unsigned long *)0x40024418))
+#define GPIO_PORTE_ICR_R        (*((volatile unsigned long *)0x4002441C))
+#define GPIO_PORTE_AFSEL_R      (*((volatile unsigned long *)0x40024420))
+#define GPIO_PORTE_DR2R_R       (*((volatile unsigned long *)0x40024500))
+#define GPIO_PORTE_DR4R_R       (*((volatile unsigned long *)0x40024504))
+#define GPIO_PORTE_DR8R_R       (*((volatile unsigned long *)0x40024508))
+#define GPIO_PORTE_ODR_R        (*((volatile unsigned long *)0x4002450C))
+#define GPIO_PORTE_PUR_R        (*((volatile unsigned long *)0x40024510))
+#define GPIO_PORTE_PDR_R        (*((volatile unsigned long *)0x40024514))
+#define GPIO_PORTE_SLR_R        (*((volatile unsigned long *)0x40024518))
+#define GPIO_PORTE_DEN_R        (*((volatile unsigned long *)0x4002451C))
+#define GPIO_PORTE_LOCK_R       (*((volatile unsigned long *)0x40024520))
+#define GPIO_PORTE_CR_R         (*((volatile unsigned long *)0x40024524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTF)
+//
+//*****************************************************************************
+#define GPIO_PORTF_DATA_BITS_R  ((volatile unsigned long *)0x40025000)
+#define GPIO_PORTF_DATA_R       (*((volatile unsigned long *)0x400253FC))
+#define GPIO_PORTF_DIR_R        (*((volatile unsigned long *)0x40025400))
+#define GPIO_PORTF_IS_R         (*((volatile unsigned long *)0x40025404))
+#define GPIO_PORTF_IBE_R        (*((volatile unsigned long *)0x40025408))
+#define GPIO_PORTF_IEV_R        (*((volatile unsigned long *)0x4002540C))
+#define GPIO_PORTF_IM_R         (*((volatile unsigned long *)0x40025410))
+#define GPIO_PORTF_RIS_R        (*((volatile unsigned long *)0x40025414))
+#define GPIO_PORTF_MIS_R        (*((volatile unsigned long *)0x40025418))
+#define GPIO_PORTF_ICR_R        (*((volatile unsigned long *)0x4002541C))
+#define GPIO_PORTF_AFSEL_R      (*((volatile unsigned long *)0x40025420))
+#define GPIO_PORTF_DR2R_R       (*((volatile unsigned long *)0x40025500))
+#define GPIO_PORTF_DR4R_R       (*((volatile unsigned long *)0x40025504))
+#define GPIO_PORTF_DR8R_R       (*((volatile unsigned long *)0x40025508))
+#define GPIO_PORTF_ODR_R        (*((volatile unsigned long *)0x4002550C))
+#define GPIO_PORTF_PUR_R        (*((volatile unsigned long *)0x40025510))
+#define GPIO_PORTF_PDR_R        (*((volatile unsigned long *)0x40025514))
+#define GPIO_PORTF_SLR_R        (*((volatile unsigned long *)0x40025518))
+#define GPIO_PORTF_DEN_R        (*((volatile unsigned long *)0x4002551C))
+#define GPIO_PORTF_LOCK_R       (*((volatile unsigned long *)0x40025520))
+#define GPIO_PORTF_CR_R         (*((volatile unsigned long *)0x40025524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTG)
+//
+//*****************************************************************************
+#define GPIO_PORTG_DATA_BITS_R  ((volatile unsigned long *)0x40026000)
+#define GPIO_PORTG_DATA_R       (*((volatile unsigned long *)0x400263FC))
+#define GPIO_PORTG_DIR_R        (*((volatile unsigned long *)0x40026400))
+#define GPIO_PORTG_IS_R         (*((volatile unsigned long *)0x40026404))
+#define GPIO_PORTG_IBE_R        (*((volatile unsigned long *)0x40026408))
+#define GPIO_PORTG_IEV_R        (*((volatile unsigned long *)0x4002640C))
+#define GPIO_PORTG_IM_R         (*((volatile unsigned long *)0x40026410))
+#define GPIO_PORTG_RIS_R        (*((volatile unsigned long *)0x40026414))
+#define GPIO_PORTG_MIS_R        (*((volatile unsigned long *)0x40026418))
+#define GPIO_PORTG_ICR_R        (*((volatile unsigned long *)0x4002641C))
+#define GPIO_PORTG_AFSEL_R      (*((volatile unsigned long *)0x40026420))
+#define GPIO_PORTG_DR2R_R       (*((volatile unsigned long *)0x40026500))
+#define GPIO_PORTG_DR4R_R       (*((volatile unsigned long *)0x40026504))
+#define GPIO_PORTG_DR8R_R       (*((volatile unsigned long *)0x40026508))
+#define GPIO_PORTG_ODR_R        (*((volatile unsigned long *)0x4002650C))
+#define GPIO_PORTG_PUR_R        (*((volatile unsigned long *)0x40026510))
+#define GPIO_PORTG_PDR_R        (*((volatile unsigned long *)0x40026514))
+#define GPIO_PORTG_SLR_R        (*((volatile unsigned long *)0x40026518))
+#define GPIO_PORTG_DEN_R        (*((volatile unsigned long *)0x4002651C))
+#define GPIO_PORTG_LOCK_R       (*((volatile unsigned long *)0x40026520))
+#define GPIO_PORTG_CR_R         (*((volatile unsigned long *)0x40026524))
+
+//*****************************************************************************
+//
+// Pulse Width Modulator (PWM)
+//
+//*****************************************************************************
+#define PWM_CTL_R               (*((volatile unsigned long *)0x40028000))
+#define PWM_SYNC_R              (*((volatile unsigned long *)0x40028004))
+#define PWM_ENABLE_R            (*((volatile unsigned long *)0x40028008))
+#define PWM_INVERT_R            (*((volatile unsigned long *)0x4002800C))
+#define PWM_FAULT_R             (*((volatile unsigned long *)0x40028010))
+#define PWM_INTEN_R             (*((volatile unsigned long *)0x40028014))
+#define PWM_RIS_R               (*((volatile unsigned long *)0x40028018))
+#define PWM_ISC_R               (*((volatile unsigned long *)0x4002801C))
+#define PWM_STATUS_R            (*((volatile unsigned long *)0x40028020))
+#define PWM_0_CTL_R             (*((volatile unsigned long *)0x40028040))
+#define PWM_0_INTEN_R           (*((volatile unsigned long *)0x40028044))
+#define PWM_0_RIS_R             (*((volatile unsigned long *)0x40028048))
+#define PWM_0_ISC_R             (*((volatile unsigned long *)0x4002804C))
+#define PWM_0_LOAD_R            (*((volatile unsigned long *)0x40028050))
+#define PWM_0_COUNT_R           (*((volatile unsigned long *)0x40028054))
+#define PWM_0_CMPA_R            (*((volatile unsigned long *)0x40028058))
+#define PWM_0_CMPB_R            (*((volatile unsigned long *)0x4002805C))
+#define PWM_0_GENA_R            (*((volatile unsigned long *)0x40028060))
+#define PWM_0_GENB_R            (*((volatile unsigned long *)0x40028064))
+#define PWM_0_DBCTL_R           (*((volatile unsigned long *)0x40028068))
+#define PWM_0_DBRISE_R          (*((volatile unsigned long *)0x4002806C))
+#define PWM_0_DBFALL_R          (*((volatile unsigned long *)0x40028070))
+#define PWM_1_CTL_R             (*((volatile unsigned long *)0x40028080))
+#define PWM_1_INTEN_R           (*((volatile unsigned long *)0x40028084))
+#define PWM_1_RIS_R             (*((volatile unsigned long *)0x40028088))
+#define PWM_1_ISC_R             (*((volatile unsigned long *)0x4002808C))
+#define PWM_1_LOAD_R            (*((volatile unsigned long *)0x40028090))
+#define PWM_1_COUNT_R           (*((volatile unsigned long *)0x40028094))
+#define PWM_1_CMPA_R            (*((volatile unsigned long *)0x40028098))
+#define PWM_1_CMPB_R            (*((volatile unsigned long *)0x4002809C))
+#define PWM_1_GENA_R            (*((volatile unsigned long *)0x400280A0))
+#define PWM_1_GENB_R            (*((volatile unsigned long *)0x400280A4))
+#define PWM_1_DBCTL_R           (*((volatile unsigned long *)0x400280A8))
+#define PWM_1_DBRISE_R          (*((volatile unsigned long *)0x400280AC))
+#define PWM_1_DBFALL_R          (*((volatile unsigned long *)0x400280B0))
+#define PWM_2_CTL_R             (*((volatile unsigned long *)0x400280C0))
+#define PWM_2_INTEN_R           (*((volatile unsigned long *)0x400280C4))
+#define PWM_2_RIS_R             (*((volatile unsigned long *)0x400280C8))
+#define PWM_2_ISC_R             (*((volatile unsigned long *)0x400280CC))
+#define PWM_2_LOAD_R            (*((volatile unsigned long *)0x400280D0))
+#define PWM_2_COUNT_R           (*((volatile unsigned long *)0x400280D4))
+#define PWM_2_CMPA_R            (*((volatile unsigned long *)0x400280D8))
+#define PWM_2_CMPB_R            (*((volatile unsigned long *)0x400280DC))
+#define PWM_2_GENA_R            (*((volatile unsigned long *)0x400280E0))
+#define PWM_2_GENB_R            (*((volatile unsigned long *)0x400280E4))
+#define PWM_2_DBCTL_R           (*((volatile unsigned long *)0x400280E8))
+#define PWM_2_DBRISE_R          (*((volatile unsigned long *)0x400280EC))
+#define PWM_2_DBFALL_R          (*((volatile unsigned long *)0x400280F0))
+
+//*****************************************************************************
+//
+// Quadrature Encoder Interface (QEI0)
+//
+//*****************************************************************************
+#define QEI0_CTL_R              (*((volatile unsigned long *)0x4002C000))
+#define QEI0_STAT_R             (*((volatile unsigned long *)0x4002C004))
+#define QEI0_POS_R              (*((volatile unsigned long *)0x4002C008))
+#define QEI0_MAXPOS_R           (*((volatile unsigned long *)0x4002C00C))
+#define QEI0_LOAD_R             (*((volatile unsigned long *)0x4002C010))
+#define QEI0_TIME_R             (*((volatile unsigned long *)0x4002C014))
+#define QEI0_COUNT_R            (*((volatile unsigned long *)0x4002C018))
+#define QEI0_SPEED_R            (*((volatile unsigned long *)0x4002C01C))
+#define QEI0_INTEN_R            (*((volatile unsigned long *)0x4002C020))
+#define QEI0_RIS_R              (*((volatile unsigned long *)0x4002C024))
+#define QEI0_ISC_R              (*((volatile unsigned long *)0x4002C028))
+
+//*****************************************************************************
+//
+// Quadrature Encoder Interface (QEI1)
+//
+//*****************************************************************************
+#define QEI1_CTL_R              (*((volatile unsigned long *)0x4002D000))
+#define QEI1_STAT_R             (*((volatile unsigned long *)0x4002D004))
+#define QEI1_POS_R              (*((volatile unsigned long *)0x4002D008))
+#define QEI1_MAXPOS_R           (*((volatile unsigned long *)0x4002D00C))
+#define QEI1_LOAD_R             (*((volatile unsigned long *)0x4002D010))
+#define QEI1_TIME_R             (*((volatile unsigned long *)0x4002D014))
+#define QEI1_COUNT_R            (*((volatile unsigned long *)0x4002D018))
+#define QEI1_SPEED_R            (*((volatile unsigned long *)0x4002D01C))
+#define QEI1_INTEN_R            (*((volatile unsigned long *)0x4002D020))
+#define QEI1_RIS_R              (*((volatile unsigned long *)0x4002D024))
+#define QEI1_ISC_R              (*((volatile unsigned long *)0x4002D028))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER0)
+//
+//*****************************************************************************
+#define TIMER0_CFG_R            (*((volatile unsigned long *)0x40030000))
+#define TIMER0_TAMR_R           (*((volatile unsigned long *)0x40030004))
+#define TIMER0_TBMR_R           (*((volatile unsigned long *)0x40030008))
+#define TIMER0_CTL_R            (*((volatile unsigned long *)0x4003000C))
+#define TIMER0_IMR_R            (*((volatile unsigned long *)0x40030018))
+#define TIMER0_RIS_R            (*((volatile unsigned long *)0x4003001C))
+#define TIMER0_MIS_R            (*((volatile unsigned long *)0x40030020))
+#define TIMER0_ICR_R            (*((volatile unsigned long *)0x40030024))
+#define TIMER0_TAILR_R          (*((volatile unsigned long *)0x40030028))
+#define TIMER0_TBILR_R          (*((volatile unsigned long *)0x4003002C))
+#define TIMER0_TAMATCHR_R       (*((volatile unsigned long *)0x40030030))
+#define TIMER0_TBMATCHR_R       (*((volatile unsigned long *)0x40030034))
+#define TIMER0_TAPR_R           (*((volatile unsigned long *)0x40030038))
+#define TIMER0_TBPR_R           (*((volatile unsigned long *)0x4003003C))
+#define TIMER0_TAPMR_R          (*((volatile unsigned long *)0x40030040))
+#define TIMER0_TBPMR_R          (*((volatile unsigned long *)0x40030044))
+#define TIMER0_TAR_R            (*((volatile unsigned long *)0x40030048))
+#define TIMER0_TBR_R            (*((volatile unsigned long *)0x4003004C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER1)
+//
+//*****************************************************************************
+#define TIMER1_CFG_R            (*((volatile unsigned long *)0x40031000))
+#define TIMER1_TAMR_R           (*((volatile unsigned long *)0x40031004))
+#define TIMER1_TBMR_R           (*((volatile unsigned long *)0x40031008))
+#define TIMER1_CTL_R            (*((volatile unsigned long *)0x4003100C))
+#define TIMER1_IMR_R            (*((volatile unsigned long *)0x40031018))
+#define TIMER1_RIS_R            (*((volatile unsigned long *)0x4003101C))
+#define TIMER1_MIS_R            (*((volatile unsigned long *)0x40031020))
+#define TIMER1_ICR_R            (*((volatile unsigned long *)0x40031024))
+#define TIMER1_TAILR_R          (*((volatile unsigned long *)0x40031028))
+#define TIMER1_TBILR_R          (*((volatile unsigned long *)0x4003102C))
+#define TIMER1_TAMATCHR_R       (*((volatile unsigned long *)0x40031030))
+#define TIMER1_TBMATCHR_R       (*((volatile unsigned long *)0x40031034))
+#define TIMER1_TAPR_R           (*((volatile unsigned long *)0x40031038))
+#define TIMER1_TBPR_R           (*((volatile unsigned long *)0x4003103C))
+#define TIMER1_TAPMR_R          (*((volatile unsigned long *)0x40031040))
+#define TIMER1_TBPMR_R          (*((volatile unsigned long *)0x40031044))
+#define TIMER1_TAR_R            (*((volatile unsigned long *)0x40031048))
+#define TIMER1_TBR_R            (*((volatile unsigned long *)0x4003104C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER2)
+//
+//*****************************************************************************
+#define TIMER2_CFG_R            (*((volatile unsigned long *)0x40032000))
+#define TIMER2_TAMR_R           (*((volatile unsigned long *)0x40032004))
+#define TIMER2_TBMR_R           (*((volatile unsigned long *)0x40032008))
+#define TIMER2_CTL_R            (*((volatile unsigned long *)0x4003200C))
+#define TIMER2_IMR_R            (*((volatile unsigned long *)0x40032018))
+#define TIMER2_RIS_R            (*((volatile unsigned long *)0x4003201C))
+#define TIMER2_MIS_R            (*((volatile unsigned long *)0x40032020))
+#define TIMER2_ICR_R            (*((volatile unsigned long *)0x40032024))
+#define TIMER2_TAILR_R          (*((volatile unsigned long *)0x40032028))
+#define TIMER2_TBILR_R          (*((volatile unsigned long *)0x4003202C))
+#define TIMER2_TAMATCHR_R       (*((volatile unsigned long *)0x40032030))
+#define TIMER2_TBMATCHR_R       (*((volatile unsigned long *)0x40032034))
+#define TIMER2_TAPR_R           (*((volatile unsigned long *)0x40032038))
+#define TIMER2_TBPR_R           (*((volatile unsigned long *)0x4003203C))
+#define TIMER2_TAPMR_R          (*((volatile unsigned long *)0x40032040))
+#define TIMER2_TBPMR_R          (*((volatile unsigned long *)0x40032044))
+#define TIMER2_TAR_R            (*((volatile unsigned long *)0x40032048))
+#define TIMER2_TBR_R            (*((volatile unsigned long *)0x4003204C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER3)
+//
+//*****************************************************************************
+#define TIMER3_CFG_R            (*((volatile unsigned long *)0x40033000))
+#define TIMER3_TAMR_R           (*((volatile unsigned long *)0x40033004))
+#define TIMER3_TBMR_R           (*((volatile unsigned long *)0x40033008))
+#define TIMER3_CTL_R            (*((volatile unsigned long *)0x4003300C))
+#define TIMER3_IMR_R            (*((volatile unsigned long *)0x40033018))
+#define TIMER3_RIS_R            (*((volatile unsigned long *)0x4003301C))
+#define TIMER3_MIS_R            (*((volatile unsigned long *)0x40033020))
+#define TIMER3_ICR_R            (*((volatile unsigned long *)0x40033024))
+#define TIMER3_TAILR_R          (*((volatile unsigned long *)0x40033028))
+#define TIMER3_TBILR_R          (*((volatile unsigned long *)0x4003302C))
+#define TIMER3_TAMATCHR_R       (*((volatile unsigned long *)0x40033030))
+#define TIMER3_TBMATCHR_R       (*((volatile unsigned long *)0x40033034))
+#define TIMER3_TAPR_R           (*((volatile unsigned long *)0x40033038))
+#define TIMER3_TBPR_R           (*((volatile unsigned long *)0x4003303C))
+#define TIMER3_TAPMR_R          (*((volatile unsigned long *)0x40033040))
+#define TIMER3_TBPMR_R          (*((volatile unsigned long *)0x40033044))
+#define TIMER3_TAR_R            (*((volatile unsigned long *)0x40033048))
+#define TIMER3_TBR_R            (*((volatile unsigned long *)0x4003304C))
+
+//*****************************************************************************
+//
+// Analog-to-Digital Converter (ADC)
+//
+//*****************************************************************************
+#define ADC_ACTSS_R             (*((volatile unsigned long *)0x40038000))
+#define ADC_RIS_R               (*((volatile unsigned long *)0x40038004))
+#define ADC_IM_R                (*((volatile unsigned long *)0x40038008))
+#define ADC_ISC_R               (*((volatile unsigned long *)0x4003800C))
+#define ADC_OSTAT_R             (*((volatile unsigned long *)0x40038010))
+#define ADC_EMUX_R              (*((volatile unsigned long *)0x40038014))
+#define ADC_USTAT_R             (*((volatile unsigned long *)0x40038018))
+#define ADC_SSPRI_R             (*((volatile unsigned long *)0x40038020))
+#define ADC_PSSI_R              (*((volatile unsigned long *)0x40038028))
+#define ADC_SAC_R               (*((volatile unsigned long *)0x40038030))
+#define ADC_SSMUX0_R            (*((volatile unsigned long *)0x40038040))
+#define ADC_SSCTL0_R            (*((volatile unsigned long *)0x40038044))
+#define ADC_SSFIFO0_R           (*((volatile unsigned long *)0x40038048))
+#define ADC_SSFSTAT0_R          (*((volatile unsigned long *)0x4003804C))
+#define ADC_SSMUX1_R            (*((volatile unsigned long *)0x40038060))
+#define ADC_SSCTL1_R            (*((volatile unsigned long *)0x40038064))
+#define ADC_SSFIFO1_R           (*((volatile unsigned long *)0x40038068))
+#define ADC_SSFSTAT1_R          (*((volatile unsigned long *)0x4003806C))
+#define ADC_SSMUX2_R            (*((volatile unsigned long *)0x40038080))
+#define ADC_SSCTL2_R            (*((volatile unsigned long *)0x40038084))
+#define ADC_SSFIFO2_R           (*((volatile unsigned long *)0x40038088))
+#define ADC_SSFSTAT2_R          (*((volatile unsigned long *)0x4003808C))
+#define ADC_SSMUX3_R            (*((volatile unsigned long *)0x400380A0))
+#define ADC_SSCTL3_R            (*((volatile unsigned long *)0x400380A4))
+#define ADC_SSFIFO3_R           (*((volatile unsigned long *)0x400380A8))
+#define ADC_SSFSTAT3_R          (*((volatile unsigned long *)0x400380AC))
+#define ADC_TMLB_R              (*((volatile unsigned long *)0x40038100))
+
+//*****************************************************************************
+//
+// Analog Comparators (COMP)
+//
+//*****************************************************************************
+#define COMP_ACMIS_R            (*((volatile unsigned long *)0x4003C000))
+#define COMP_ACRIS_R            (*((volatile unsigned long *)0x4003C004))
+#define COMP_ACINTEN_R          (*((volatile unsigned long *)0x4003C008))
+#define COMP_ACREFCTL_R         (*((volatile unsigned long *)0x4003C010))
+#define COMP_ACSTAT0_R          (*((volatile unsigned long *)0x4003C020))
+#define COMP_ACCTL0_R           (*((volatile unsigned long *)0x4003C024))
+#define COMP_ACSTAT1_R          (*((volatile unsigned long *)0x4003C040))
+#define COMP_ACCTL1_R           (*((volatile unsigned long *)0x4003C044))
+
+//*****************************************************************************
+//
+// Ethernet Controller (MAC)
+//
+//*****************************************************************************
+#define MAC_MR0_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_RIS_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_IACK_R              (*((volatile unsigned long *)0x40048000))
+#define MAC_MR1_R               (*((volatile unsigned long *)0x40048001))
+#define MAC_MR2_R               (*((volatile unsigned long *)0x40048002))
+#define MAC_MR3_R               (*((volatile unsigned long *)0x40048003))
+#define MAC_IM_R                (*((volatile unsigned long *)0x40048004))
+#define MAC_MR4_R               (*((volatile unsigned long *)0x40048004))
+#define MAC_MR5_R               (*((volatile unsigned long *)0x40048005))
+#define MAC_MR6_R               (*((volatile unsigned long *)0x40048006))
+#define MAC_RCTL_R              (*((volatile unsigned long *)0x40048008))
+#define MAC_TCTL_R              (*((volatile unsigned long *)0x4004800C))
+#define MAC_DATA_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR16_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR17_R              (*((volatile unsigned long *)0x40048011))
+#define MAC_MR18_R              (*((volatile unsigned long *)0x40048012))
+#define MAC_MR19_R              (*((volatile unsigned long *)0x40048013))
+#define MAC_IA0_R               (*((volatile unsigned long *)0x40048014))
+#define MAC_MR23_R              (*((volatile unsigned long *)0x40048017))
+#define MAC_IA1_R               (*((volatile unsigned long *)0x40048018))
+#define MAC_MR24_R              (*((volatile unsigned long *)0x40048018))
+#define MAC_THR_R               (*((volatile unsigned long *)0x4004801C))
+#define MAC_MCTL_R              (*((volatile unsigned long *)0x40048020))
+#define MAC_MDV_R               (*((volatile unsigned long *)0x40048024))
+#define MAC_MTXD_R              (*((volatile unsigned long *)0x4004802C))
+#define MAC_MRXD_R              (*((volatile unsigned long *)0x40048030))
+#define MAC_NP_R                (*((volatile unsigned long *)0x40048034))
+#define MAC_TR_R                (*((volatile unsigned long *)0x40048038))
+
+//*****************************************************************************
+//
+// Hibernation Module (HIB)
+//
+//*****************************************************************************
+#define HIB_RTCC_R              (*((volatile unsigned long *)0x400FC000))
+#define HIB_RTCM0_R             (*((volatile unsigned long *)0x400FC004))
+#define HIB_RTCM1_R             (*((volatile unsigned long *)0x400FC008))
+#define HIB_RTCLD_R             (*((volatile unsigned long *)0x400FC00C))
+#define HIB_CTL_R               (*((volatile unsigned long *)0x400FC010))
+#define HIB_IM_R                (*((volatile unsigned long *)0x400FC014))
+#define HIB_RIS_R               (*((volatile unsigned long *)0x400FC018))
+#define HIB_MIS_R               (*((volatile unsigned long *)0x400FC01C))
+#define HIB_IC_R                (*((volatile unsigned long *)0x400FC020))
+#define HIB_RTCT_R              (*((volatile unsigned long *)0x400FC024))
+#define HIB_DATA_R              (*((volatile unsigned long *)0x400FC030))
+
+//*****************************************************************************
+//
+// Internal Memory (FLASH)
+//
+//*****************************************************************************
+#define FLASH_FMA_R             (*((volatile unsigned long *)0x400FD000))
+#define FLASH_FMD_R             (*((volatile unsigned long *)0x400FD004))
+#define FLASH_FMC_R             (*((volatile unsigned long *)0x400FD008))
+#define FLASH_FCRIS_R           (*((volatile unsigned long *)0x400FD00C))
+#define FLASH_FCIM_R            (*((volatile unsigned long *)0x400FD010))
+#define FLASH_FCMISC_R          (*((volatile unsigned long *)0x400FD014))
+#define FLASH_USECRL_R          (*((volatile unsigned long *)0x400FE140))
+#define FLASH_USERDBG_R         (*((volatile unsigned long *)0x400FE1D0))
+#define FLASH_USERREG0_R        (*((volatile unsigned long *)0x400FE1E0))
+#define FLASH_USERREG1_R        (*((volatile unsigned long *)0x400FE1E4))
+#define FLASH_FMPRE0_R          (*((volatile unsigned long *)0x400FE200))
+#define FLASH_FMPRE1_R          (*((volatile unsigned long *)0x400FE204))
+#define FLASH_FMPRE2_R          (*((volatile unsigned long *)0x400FE208))
+#define FLASH_FMPRE3_R          (*((volatile unsigned long *)0x400FE20C))
+#define FLASH_FMPPE0_R          (*((volatile unsigned long *)0x400FE400))
+#define FLASH_FMPPE1_R          (*((volatile unsigned long *)0x400FE404))
+#define FLASH_FMPPE2_R          (*((volatile unsigned long *)0x400FE408))
+#define FLASH_FMPPE3_R          (*((volatile unsigned long *)0x400FE40C))
+
+//*****************************************************************************
+//
+// System Control (SYSCTL)
+//
+//*****************************************************************************
+#define SYSCTL_DID0_R           (*((volatile unsigned long *)0x400FE000))
+#define SYSCTL_DID1_R           (*((volatile unsigned long *)0x400FE004))
+#define SYSCTL_DC0_R            (*((volatile unsigned long *)0x400FE008))
+#define SYSCTL_DC1_R            (*((volatile unsigned long *)0x400FE010))
+#define SYSCTL_DC2_R            (*((volatile unsigned long *)0x400FE014))
+#define SYSCTL_DC3_R            (*((volatile unsigned long *)0x400FE018))
+#define SYSCTL_DC4_R            (*((volatile unsigned long *)0x400FE01C))
+#define SYSCTL_PBORCTL_R        (*((volatile unsigned long *)0x400FE030))
+#define SYSCTL_LDOPCTL_R        (*((volatile unsigned long *)0x400FE034))
+#define SYSCTL_SRCR0_R          (*((volatile unsigned long *)0x400FE040))
+#define SYSCTL_SRCR1_R          (*((volatile unsigned long *)0x400FE044))
+#define SYSCTL_SRCR2_R          (*((volatile unsigned long *)0x400FE048))
+#define SYSCTL_RIS_R            (*((volatile unsigned long *)0x400FE050))
+#define SYSCTL_IMC_R            (*((volatile unsigned long *)0x400FE054))
+#define SYSCTL_MISC_R           (*((volatile unsigned long *)0x400FE058))
+#define SYSCTL_RESC_R           (*((volatile unsigned long *)0x400FE05C))
+#define SYSCTL_RCC_R            (*((volatile unsigned long *)0x400FE060))
+#define SYSCTL_PLLCFG_R         (*((volatile unsigned long *)0x400FE064))
+#define SYSCTL_RCC2_R           (*((volatile unsigned long *)0x400FE070))
+#define SYSCTL_RCGC0_R          (*((volatile unsigned long *)0x400FE100))
+#define SYSCTL_RCGC1_R          (*((volatile unsigned long *)0x400FE104))
+#define SYSCTL_RCGC2_R          (*((volatile unsigned long *)0x400FE108))
+#define SYSCTL_SCGC0_R          (*((volatile unsigned long *)0x400FE110))
+#define SYSCTL_SCGC1_R          (*((volatile unsigned long *)0x400FE114))
+#define SYSCTL_SCGC2_R          (*((volatile unsigned long *)0x400FE118))
+#define SYSCTL_DCGC0_R          (*((volatile unsigned long *)0x400FE120))
+#define SYSCTL_DCGC1_R          (*((volatile unsigned long *)0x400FE124))
+#define SYSCTL_DCGC2_R          (*((volatile unsigned long *)0x400FE128))
+#define SYSCTL_DSLPCLKCFG_R     (*((volatile unsigned long *)0x400FE144))
+
+//*****************************************************************************
+//
+// Nested Vectored Interrupt Ctrl (NVIC)
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_R         (*((volatile unsigned long *)0xE000E004))
+#define NVIC_ST_CTRL_R          (*((volatile unsigned long *)0xE000E010))
+#define NVIC_ST_RELOAD_R        (*((volatile unsigned long *)0xE000E014))
+#define NVIC_ST_CURRENT_R       (*((volatile unsigned long *)0xE000E018))
+#define NVIC_ST_CAL_R           (*((volatile unsigned long *)0xE000E01C))
+#define NVIC_EN0_R              (*((volatile unsigned long *)0xE000E100))
+#define NVIC_EN1_R              (*((volatile unsigned long *)0xE000E104))
+#define NVIC_DIS0_R             (*((volatile unsigned long *)0xE000E180))
+#define NVIC_DIS1_R             (*((volatile unsigned long *)0xE000E184))
+#define NVIC_PEND0_R            (*((volatile unsigned long *)0xE000E200))
+#define NVIC_PEND1_R            (*((volatile unsigned long *)0xE000E204))
+#define NVIC_UNPEND0_R          (*((volatile unsigned long *)0xE000E280))
+#define NVIC_UNPEND1_R          (*((volatile unsigned long *)0xE000E284))
+#define NVIC_ACTIVE0_R          (*((volatile unsigned long *)0xE000E300))
+#define NVIC_ACTIVE1_R          (*((volatile unsigned long *)0xE000E304))
+#define NVIC_PRI0_R             (*((volatile unsigned long *)0xE000E400))
+#define NVIC_PRI1_R             (*((volatile unsigned long *)0xE000E404))
+#define NVIC_PRI2_R             (*((volatile unsigned long *)0xE000E408))
+#define NVIC_PRI3_R             (*((volatile unsigned long *)0xE000E40C))
+#define NVIC_PRI4_R             (*((volatile unsigned long *)0xE000E410))
+#define NVIC_PRI5_R             (*((volatile unsigned long *)0xE000E414))
+#define NVIC_PRI6_R             (*((volatile unsigned long *)0xE000E418))
+#define NVIC_PRI7_R             (*((volatile unsigned long *)0xE000E41C))
+#define NVIC_PRI8_R             (*((volatile unsigned long *)0xE000E420))
+#define NVIC_PRI9_R             (*((volatile unsigned long *)0xE000E424))
+#define NVIC_PRI10_R            (*((volatile unsigned long *)0xE000E428))
+#define NVIC_CPUID_R            (*((volatile unsigned long *)0xE000ED00))
+#define NVIC_INT_CTRL_R         (*((volatile unsigned long *)0xE000ED04))
+#define NVIC_VTABLE_R           (*((volatile unsigned long *)0xE000ED08))
+#define NVIC_APINT_R            (*((volatile unsigned long *)0xE000ED0C))
+#define NVIC_SYS_CTRL_R         (*((volatile unsigned long *)0xE000ED10))
+#define NVIC_CFG_CTRL_R         (*((volatile unsigned long *)0xE000ED14))
+#define NVIC_SYS_PRI1_R         (*((volatile unsigned long *)0xE000ED18))
+#define NVIC_SYS_PRI2_R         (*((volatile unsigned long *)0xE000ED1C))
+#define NVIC_SYS_PRI3_R         (*((volatile unsigned long *)0xE000ED20))
+#define NVIC_SYS_HND_CTRL_R     (*((volatile unsigned long *)0xE000ED24))
+#define NVIC_FAULT_STAT_R       (*((volatile unsigned long *)0xE000ED28))
+#define NVIC_HFAULT_STAT_R      (*((volatile unsigned long *)0xE000ED2C))
+#define NVIC_DEBUG_STAT_R       (*((volatile unsigned long *)0xE000ED30))
+#define NVIC_MM_ADDR_R          (*((volatile unsigned long *)0xE000ED34))
+#define NVIC_FAULT_ADDR_R       (*((volatile unsigned long *)0xE000ED38))
+#define NVIC_MPU_TYPE_R         (*((volatile unsigned long *)0xE000ED90))
+#define NVIC_MPU_CTRL_R         (*((volatile unsigned long *)0xE000ED94))
+#define NVIC_MPU_NUMBER_R       (*((volatile unsigned long *)0xE000ED98))
+#define NVIC_MPU_R              (*((volatile unsigned long *)0xE000ED9C))
+#define NVIC_MPU_ATTR_R         (*((volatile unsigned long *)0xE000EDA0))
+#define NVIC_DBG_CTRL_R         (*((volatile unsigned long *)0xE000EDF0))
+#define NVIC_DBG_XFER_R         (*((volatile unsigned long *)0xE000EDF4))
+#define NVIC_DBG_DATA_R         (*((volatile unsigned long *)0xE000EDF8))
+#define NVIC_DBG_INT_R          (*((volatile unsigned long *)0xE000EDFC))
+#define NVIC_SW_TRIG_R          (*((volatile unsigned long *)0xE000EF00))
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOAD register.
+//
+//*****************************************************************************
+#define WDT_LOAD_M              0xFFFFFFFF  // Watchdog Load Value.
+#define WDT_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_VALUE register.
+//
+//*****************************************************************************
+#define WDT_VALUE_M             0xFFFFFFFF  // Watchdog Value.
+#define WDT_VALUE_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_CTL register.
+//
+//*****************************************************************************
+#define WDT_CTL_RESEN           0x00000002  // Watchdog Reset Enable.
+#define WDT_CTL_INTEN           0x00000001  // Watchdog Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_ICR register.
+//
+//*****************************************************************************
+#define WDT_ICR_M               0xFFFFFFFF  // Watchdog Interrupt Clear.
+#define WDT_ICR_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_RIS register.
+//
+//*****************************************************************************
+#define WDT_RIS_WDTRIS          0x00000001  // Watchdog Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_MIS register.
+//
+//*****************************************************************************
+#define WDT_MIS_WDTMIS          0x00000001  // Watchdog Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_TEST register.
+//
+//*****************************************************************************
+#define WDT_TEST_STALL          0x00000100  // Watchdog Stall Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOCK register.
+//
+//*****************************************************************************
+#define WDT_LOCK_M              0xFFFFFFFF  // Watchdog Lock.
+#define WDT_LOCK_UNLOCKED       0x00000000  // Unlocked
+#define WDT_LOCK_LOCKED         0x00000001  // Locked
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_O_LOCK register.
+//
+//*****************************************************************************
+#define GPIO_LOCK_M             0xFFFFFFFF  // GPIO Lock.
+#define GPIO_LOCK_UNLOCKED      0x00000000  // unlocked
+#define GPIO_LOCK_LOCKED        0x00000001  // locked
+#define GPIO_LOCK_KEY           0x1ACCE551  // Unlocks the GPIO_CR register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR0 register.
+//
+//*****************************************************************************
+#define SSI_CR0_SCR_M           0x0000FF00  // SSI Serial Clock Rate.
+#define SSI_CR0_SPH             0x00000080  // SSI Serial Clock Phase.
+#define SSI_CR0_SPO             0x00000040  // SSI Serial Clock Polarity.
+#define SSI_CR0_FRF_M           0x00000030  // SSI Frame Format Select.
+#define SSI_CR0_FRF_MOTO        0x00000000  // Freescale SPI Frame Format
+#define SSI_CR0_FRF_TI          0x00000010  // Texas Instruments Synchronous
+                                            // Serial Frame Format
+#define SSI_CR0_FRF_NMW         0x00000020  // MICROWIRE Frame Format
+#define SSI_CR0_DSS_M           0x0000000F  // SSI Data Size Select.
+#define SSI_CR0_DSS_4           0x00000003  // 4-bit data
+#define SSI_CR0_DSS_5           0x00000004  // 5-bit data
+#define SSI_CR0_DSS_6           0x00000005  // 6-bit data
+#define SSI_CR0_DSS_7           0x00000006  // 7-bit data
+#define SSI_CR0_DSS_8           0x00000007  // 8-bit data
+#define SSI_CR0_DSS_9           0x00000008  // 9-bit data
+#define SSI_CR0_DSS_10          0x00000009  // 10-bit data
+#define SSI_CR0_DSS_11          0x0000000A  // 11-bit data
+#define SSI_CR0_DSS_12          0x0000000B  // 12-bit data
+#define SSI_CR0_DSS_13          0x0000000C  // 13-bit data
+#define SSI_CR0_DSS_14          0x0000000D  // 14-bit data
+#define SSI_CR0_DSS_15          0x0000000E  // 15-bit data
+#define SSI_CR0_DSS_16          0x0000000F  // 16-bit data
+#define SSI_CR0_SCR_S           8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR1 register.
+//
+//*****************************************************************************
+#define SSI_CR1_SOD             0x00000008  // SSI Slave Mode Output Disable.
+#define SSI_CR1_MS              0x00000004  // SSI Master/Slave Select.
+#define SSI_CR1_SSE             0x00000002  // SSI Synchronous Serial Port
+                                            // Enable.
+#define SSI_CR1_LBM             0x00000001  // SSI Loopback Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DR register.
+//
+//*****************************************************************************
+#define SSI_DR_DATA_M           0x0000FFFF  // SSI Receive/Transmit Data.
+#define SSI_DR_DATA_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_SR register.
+//
+//*****************************************************************************
+#define SSI_SR_BSY              0x00000010  // SSI Busy Bit.
+#define SSI_SR_RFF              0x00000008  // SSI Receive FIFO Full.
+#define SSI_SR_RNE              0x00000004  // SSI Receive FIFO Not Empty.
+#define SSI_SR_TNF              0x00000002  // SSI Transmit FIFO Not Full.
+#define SSI_SR_TFE              0x00000001  // SSI Transmit FIFO Empty.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CPSR register.
+//
+//*****************************************************************************
+#define SSI_CPSR_CPSDVSR_M      0x000000FF  // SSI Clock Prescale Divisor.
+#define SSI_CPSR_CPSDVSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_IM register.
+//
+//*****************************************************************************
+#define SSI_IM_TXIM             0x00000008  // SSI Transmit FIFO Interrupt
+                                            // Mask.
+#define SSI_IM_RXIM             0x00000004  // SSI Receive FIFO Interrupt Mask.
+#define SSI_IM_RTIM             0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Mask.
+#define SSI_IM_RORIM            0x00000001  // SSI Receive Overrun Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_RIS register.
+//
+//*****************************************************************************
+#define SSI_RIS_TXRIS           0x00000008  // SSI Transmit FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RXRIS           0x00000004  // SSI Receive FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RTRIS           0x00000002  // SSI Receive Time-Out Raw
+                                            // Interrupt Status.
+#define SSI_RIS_RORRIS          0x00000001  // SSI Receive Overrun Raw
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_MIS register.
+//
+//*****************************************************************************
+#define SSI_MIS_TXMIS           0x00000008  // SSI Transmit FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RXMIS           0x00000004  // SSI Receive FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RTMIS           0x00000002  // SSI Receive Time-Out Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RORMIS          0x00000001  // SSI Receive Overrun Masked
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_ICR register.
+//
+//*****************************************************************************
+#define SSI_ICR_RTIC            0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Clear.
+#define SSI_ICR_RORIC           0x00000001  // SSI Receive Overrun Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DR register.
+//
+//*****************************************************************************
+#define UART_DR_OE              0x00000800  // UART Overrun Error.
+#define UART_DR_BE              0x00000400  // UART Break Error.
+#define UART_DR_PE              0x00000200  // UART Parity Error.
+#define UART_DR_FE              0x00000100  // UART Framing Error.
+#define UART_DR_DATA_M          0x000000FF  // Data Transmitted or Received.
+#define UART_DR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RSR register.
+//
+//*****************************************************************************
+#define UART_RSR_OE             0x00000008  // UART Overrun Error.
+#define UART_RSR_BE             0x00000004  // UART Break Error.
+#define UART_RSR_PE             0x00000002  // UART Parity Error.
+#define UART_RSR_FE             0x00000001  // UART Framing Error.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ECR register.
+//
+//*****************************************************************************
+#define UART_ECR_DATA_M         0x000000FF  // Error Clear.
+#define UART_ECR_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FR register.
+//
+//*****************************************************************************
+#define UART_FR_TXFE            0x00000080  // UART Transmit FIFO Empty.
+#define UART_FR_RXFF            0x00000040  // UART Receive FIFO Full.
+#define UART_FR_TXFF            0x00000020  // UART Transmit FIFO Full.
+#define UART_FR_RXFE            0x00000010  // UART Receive FIFO Empty.
+#define UART_FR_BUSY            0x00000008  // UART Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ILPR register.
+//
+//*****************************************************************************
+#define UART_ILPR_ILPDVSR_M     0x000000FF  // IrDA Low-Power Divisor.
+#define UART_ILPR_ILPDVSR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IBRD register.
+//
+//*****************************************************************************
+#define UART_IBRD_DIVINT_M      0x0000FFFF  // Integer Baud-Rate Divisor.
+#define UART_IBRD_DIVINT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FBRD register.
+//
+//*****************************************************************************
+#define UART_FBRD_DIVFRAC_M     0x0000003F  // Fractional Baud-Rate Divisor.
+#define UART_FBRD_DIVFRAC_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCRH register.
+//
+//*****************************************************************************
+#define UART_LCRH_SPS           0x00000080  // UART Stick Parity Select.
+#define UART_LCRH_WLEN_M        0x00000060  // UART Word Length.
+#define UART_LCRH_WLEN_5        0x00000000  // 5 bits (default)
+#define UART_LCRH_WLEN_6        0x00000020  // 6 bits
+#define UART_LCRH_WLEN_7        0x00000040  // 7 bits
+#define UART_LCRH_WLEN_8        0x00000060  // 8 bits
+#define UART_LCRH_FEN           0x00000010  // UART Enable FIFOs.
+#define UART_LCRH_STP2          0x00000008  // UART Two Stop Bits Select.
+#define UART_LCRH_EPS           0x00000004  // UART Even Parity Select.
+#define UART_LCRH_PEN           0x00000002  // UART Parity Enable.
+#define UART_LCRH_BRK           0x00000001  // UART Send Break.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_CTL register.
+//
+//*****************************************************************************
+#define UART_CTL_RXE            0x00000200  // UART Receive Enable.
+#define UART_CTL_TXE            0x00000100  // UART Transmit Enable.
+#define UART_CTL_LBE            0x00000080  // UART Loop Back Enable.
+#define UART_CTL_SIRLP          0x00000004  // UART SIR Low Power Mode.
+#define UART_CTL_SIREN          0x00000002  // UART SIR Enable.
+#define UART_CTL_UARTEN         0x00000001  // UART Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IFLS register.
+//
+//*****************************************************************************
+#define UART_IFLS_RX_M          0x00000038  // UART Receive Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_RX1_8         0x00000000  // RX FIFO &lt;= 1/8 full
+#define UART_IFLS_RX2_8         0x00000008  // RX FIFO &lt;= 1/4 full
+#define UART_IFLS_RX4_8         0x00000010  // RX FIFO &lt;= 1/2 full (default)
+#define UART_IFLS_RX6_8         0x00000018  // RX FIFO &lt;= 3/4 full
+#define UART_IFLS_RX7_8         0x00000020  // RX FIFO &lt;= 7/8 full
+#define UART_IFLS_TX_M          0x00000007  // UART Transmit Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_TX1_8         0x00000000  // TX FIFO &gt;= 1/8 full
+#define UART_IFLS_TX2_8         0x00000001  // TX FIFO &gt;= 1/4 full
+#define UART_IFLS_TX4_8         0x00000002  // TX FIFO &gt;= 1/2 full (default)
+#define UART_IFLS_TX6_8         0x00000003  // TX FIFO &gt;= 3/4 full
+#define UART_IFLS_TX7_8         0x00000004  // TX FIFO &gt;= 7/8 full
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IM register.
+//
+//*****************************************************************************
+#define UART_IM_OEIM            0x00000400  // UART Overrun Error Interrupt
+                                            // Mask.
+#define UART_IM_BEIM            0x00000200  // UART Break Error Interrupt Mask.
+#define UART_IM_PEIM            0x00000100  // UART Parity Error Interrupt
+                                            // Mask.
+#define UART_IM_FEIM            0x00000080  // UART Framing Error Interrupt
+                                            // Mask.
+#define UART_IM_RTIM            0x00000040  // UART Receive Time-Out Interrupt
+                                            // Mask.
+#define UART_IM_TXIM            0x00000020  // UART Transmit Interrupt Mask.
+#define UART_IM_RXIM            0x00000010  // UART Receive Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RIS register.
+//
+//*****************************************************************************
+#define UART_RIS_OERIS          0x00000400  // UART Overrun Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_BERIS          0x00000200  // UART Break Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_PERIS          0x00000100  // UART Parity Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_FERIS          0x00000080  // UART Framing Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_RTRIS          0x00000040  // UART Receive Time-Out Raw
+                                            // Interrupt Status.
+#define UART_RIS_TXRIS          0x00000020  // UART Transmit Raw Interrupt
+                                            // Status.
+#define UART_RIS_RXRIS          0x00000010  // UART Receive Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_MIS register.
+//
+//*****************************************************************************
+#define UART_MIS_OEMIS          0x00000400  // UART Overrun Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_BEMIS          0x00000200  // UART Break Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_PEMIS          0x00000100  // UART Parity Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_FEMIS          0x00000080  // UART Framing Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_RTMIS          0x00000040  // UART Receive Time-Out Masked
+                                            // Interrupt Status.
+#define UART_MIS_TXMIS          0x00000020  // UART Transmit Masked Interrupt
+                                            // Status.
+#define UART_MIS_RXMIS          0x00000010  // UART Receive Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ICR register.
+//
+//*****************************************************************************
+#define UART_ICR_OEIC           0x00000400  // Overrun Error Interrupt Clear.
+#define UART_ICR_BEIC           0x00000200  // Break Error Interrupt Clear.
+#define UART_ICR_PEIC           0x00000100  // Parity Error Interrupt Clear.
+#define UART_ICR_FEIC           0x00000080  // Framing Error Interrupt Clear.
+#define UART_ICR_RTIC           0x00000040  // Receive Time-Out Interrupt
+                                            // Clear.
+#define UART_ICR_TXIC           0x00000020  // Transmit Interrupt Clear.
+#define UART_ICR_RXIC           0x00000010  // Receive Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MSA register.
+//
+//*****************************************************************************
+#define I2C_MSA_SA_M            0x000000FE  // I2C Slave Address.
+#define I2C_MSA_RS              0x00000001  // Receive not send.
+#define I2C_MSA_SA_S            1
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SOAR register.
+//
+//*****************************************************************************
+#define I2C_SOAR_OAR_M          0x0000007F  // I2C Slave Own Address.
+#define I2C_SOAR_OAR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SCSR register.
+//
+//*****************************************************************************
+#define I2C_SCSR_FBR            0x00000004  // First Byte Received.
+#define I2C_SCSR_TREQ           0x00000002  // Transmit Request.
+#define I2C_SCSR_DA             0x00000001  // Device Active.
+#define I2C_SCSR_RREQ           0x00000001  // Receive Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCS register.
+//
+//*****************************************************************************
+#define I2C_MCS_BUSBSY          0x00000040  // Bus Busy.
+#define I2C_MCS_IDLE            0x00000020  // I2C Idle.
+#define I2C_MCS_ARBLST          0x00000010  // Arbitration Lost.
+#define I2C_MCS_ACK             0x00000008  // Data Acknowledge Enable.
+#define I2C_MCS_DATACK          0x00000008  // Acknowledge Data.
+#define I2C_MCS_ADRACK          0x00000004  // Acknowledge Address.
+#define I2C_MCS_STOP            0x00000004  // Generate STOP.
+#define I2C_MCS_START           0x00000002  // Generate START.
+#define I2C_MCS_ERROR           0x00000002  // Error.
+#define I2C_MCS_RUN             0x00000001  // I2C Master Enable.
+#define I2C_MCS_BUSY            0x00000001  // I2C Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SDR register.
+//
+//*****************************************************************************
+#define I2C_SDR_DATA_M          0x000000FF  // Data for Transfer.
+#define I2C_SDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MDR register.
+//
+//*****************************************************************************
+#define I2C_MDR_DATA_M          0x000000FF  // Data Transferred.
+#define I2C_MDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MTPR register.
+//
+//*****************************************************************************
+#define I2C_MTPR_TPR_M          0x000000FF  // SCL Clock Period.
+#define I2C_MTPR_TPR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SIMR register.
+//
+//*****************************************************************************
+#define I2C_SIMR_IM             0x00000001  // Data Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SRIS register.
+//
+//*****************************************************************************
+#define I2C_SRIS_RIS            0x00000001  // Data Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MIMR register.
+//
+//*****************************************************************************
+#define I2C_MIMR_IM             0x00000001  // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MRIS register.
+//
+//*****************************************************************************
+#define I2C_MRIS_RIS            0x00000001  // Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SMIS register.
+//
+//*****************************************************************************
+#define I2C_SMIS_MIS            0x00000001  // Data Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SICR register.
+//
+//*****************************************************************************
+#define I2C_SICR_IC             0x00000001  // Data Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MMIS register.
+//
+//*****************************************************************************
+#define I2C_MMIS_MIS            0x00000001  // Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MICR register.
+//
+//*****************************************************************************
+#define I2C_MICR_IC             0x00000001  // Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCR register.
+//
+//*****************************************************************************
+#define I2C_MCR_SFE             0x00000020  // I2C Slave Function Enable.
+#define I2C_MCR_MFE             0x00000010  // I2C Master Function Enable.
+#define I2C_MCR_LPBK            0x00000001  // I2C Loopback.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_CTL register.
+//
+//*****************************************************************************
+#define PWM_CTL_GLOBALSYNC2     0x00000004  // Update PWM Generator 2.
+#define PWM_CTL_GLOBALSYNC1     0x00000002  // Update PWM Generator 1.
+#define PWM_CTL_GLOBALSYNC0     0x00000001  // Update PWM Generator 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_SYNC register.
+//
+//*****************************************************************************
+#define PWM_SYNC_SYNC2          0x00000004  // Reset Generator 2 Counter.
+#define PWM_SYNC_SYNC1          0x00000002  // Reset Generator 1 Counter.
+#define PWM_SYNC_SYNC0          0x00000001  // Reset Generator 0 Counter.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ENABLE register.
+//
+//*****************************************************************************
+#define PWM_ENABLE_PWM5EN       0x00000020  // PWM5 Output Enable.
+#define PWM_ENABLE_PWM4EN       0x00000010  // PWM4 Output Enable.
+#define PWM_ENABLE_PWM3EN       0x00000008  // PWM3 Output Enable.
+#define PWM_ENABLE_PWM2EN       0x00000004  // PWM2 Output Enable.
+#define PWM_ENABLE_PWM1EN       0x00000002  // PWM1 Output Enable.
+#define PWM_ENABLE_PWM0EN       0x00000001  // PWM0 Output Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INVERT register.
+//
+//*****************************************************************************
+#define PWM_INVERT_PWM5INV      0x00000020  // Invert PWM5 Signal.
+#define PWM_INVERT_PWM4INV      0x00000010  // Invert PWM4 Signal.
+#define PWM_INVERT_PWM3INV      0x00000008  // Invert PWM3 Signal.
+#define PWM_INVERT_PWM2INV      0x00000004  // Invert PWM2 Signal.
+#define PWM_INVERT_PWM1INV      0x00000002  // Invert PWM1 Signal.
+#define PWM_INVERT_PWM0INV      0x00000001  // Invert PWM0 Signal.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_FAULT register.
+//
+//*****************************************************************************
+#define PWM_FAULT_FAULT5        0x00000020  // PWM5 Fault.
+#define PWM_FAULT_FAULT4        0x00000010  // PWM4 Fault.
+#define PWM_FAULT_FAULT3        0x00000008  // PWM3 Fault.
+#define PWM_FAULT_FAULT2        0x00000004  // PWM2 Fault.
+#define PWM_FAULT_FAULT1        0x00000002  // PWM1 Fault.
+#define PWM_FAULT_FAULT0        0x00000001  // PWM0 Fault.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INTEN register.
+//
+//*****************************************************************************
+#define PWM_INTEN_INTFAULT      0x00010000  // Fault Interrupt Enable.
+#define PWM_INTEN_INTPWM2       0x00000004  // PWM2 Interrupt Enable.
+#define PWM_INTEN_INTPWM1       0x00000002  // PWM1 Interrupt Enable.
+#define PWM_INTEN_INTPWM0       0x00000001  // PWM0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_RIS register.
+//
+//*****************************************************************************
+#define PWM_RIS_INTFAULT        0x00010000  // Fault Interrupt Asserted.
+#define PWM_RIS_INTPWM2         0x00000004  // PWM2 Interrupt Asserted.
+#define PWM_RIS_INTPWM1         0x00000002  // PWM1 Interrupt Asserted.
+#define PWM_RIS_INTPWM0         0x00000001  // PWM0 Interrupt Asserted.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ISC register.
+//
+//*****************************************************************************
+#define PWM_ISC_INTFAULT        0x00010000  // Fault Interrupt Asserted.
+#define PWM_ISC_INTPWM2         0x00000004  // PWM2 Interrupt Status.
+#define PWM_ISC_INTPWM1         0x00000002  // PWM1 Interrupt Status.
+#define PWM_ISC_INTPWM0         0x00000001  // PWM0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_STATUS register.
+//
+//*****************************************************************************
+#define PWM_STATUS_FAULT        0x00000001  // Fault Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CTL,
+// PWM_O_1_CTL, and PWM_O_2_CTL registers.
+//
+//*****************************************************************************
+#define PWM_X_CTL_CMPBUPD       0x00000020  // Comparator B Update Mode.
+#define PWM_X_CTL_CMPAUPD       0x00000010  // Comparator A Update Mode.
+#define PWM_X_CTL_LOADUPD       0x00000008  // Load Register Update Mode.
+#define PWM_X_CTL_DEBUG         0x00000004  // Debug Mode.
+#define PWM_X_CTL_MODE          0x00000002  // Counter Mode.
+#define PWM_X_CTL_ENABLE        0x00000001  // PWM Block Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_INTEN,
+// PWM_O_1_INTEN, and PWM_O_2_INTEN registers.
+//
+//*****************************************************************************
+#define PWM_X_INTEN_TRCMPBD     0x00002000  // Trigger for Counter=Comparator B
+                                            // Down.
+#define PWM_X_INTEN_TRCMPBU     0x00001000  // Trigger for Counter=Comparator B
+                                            // Up.
+#define PWM_X_INTEN_TRCMPAD     0x00000800  // Trigger for Counter=Comparator A
+                                            // Down.
+#define PWM_X_INTEN_TRCMPAU     0x00000400  // Trigger for Counter=Comparator A
+                                            // Up.
+#define PWM_X_INTEN_TRCNTLOAD   0x00000200  // Trigger for Counter=Load.
+#define PWM_X_INTEN_TRCNTZERO   0x00000100  // Trigger for Counter=0.
+#define PWM_X_INTEN_INTCMPBD    0x00000020  // Interrupt for Counter=Comparator
+                                            // B Down.
+#define PWM_X_INTEN_INTCMPBU    0x00000010  // Interrupt for Counter=Comparator
+                                            // B Up.
+#define PWM_X_INTEN_INTCMPAD    0x00000008  // Interrupt for Counter=Comparator
+                                            // A Down.
+#define PWM_X_INTEN_INTCMPAU    0x00000004  // Interrupt for Counter=Comparator
+                                            // A Up.
+#define PWM_X_INTEN_INTCNTLOAD  0x00000002  // Interrupt for Counter=Load.
+#define PWM_X_INTEN_INTCNTZERO  0x00000001  // Interrupt for Counter=0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_RIS,
+// PWM_O_1_RIS, and PWM_O_2_RIS registers.
+//
+//*****************************************************************************
+#define PWM_X_RIS_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPBU      0x00000010  // Comparator B Up Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPAU      0x00000004  // Comparator A Up Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCNTLOAD    0x00000002  // Counter=Load Interrupt Status.
+#define PWM_X_RIS_INTCNTZERO    0x00000001  // Counter=0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_ISC,
+// PWM_O_1_ISC, and PWM_O_2_ISC registers.
+//
+//*****************************************************************************
+#define PWM_X_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt.
+#define PWM_X_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt.
+#define PWM_X_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt.
+#define PWM_X_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt.
+#define PWM_X_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt.
+#define PWM_X_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_LOAD,
+// PWM_O_1_LOAD, and PWM_O_2_LOAD registers.
+//
+//*****************************************************************************
+#define PWM_X_LOAD_M            0x0000FFFF  // Counter Load Value.
+#define PWM_X_LOAD_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_COUNT,
+// PWM_O_1_COUNT, and PWM_O_2_COUNT registers.
+//
+//*****************************************************************************
+#define PWM_X_COUNT_M           0x0000FFFF  // Counter Value.
+#define PWM_X_COUNT_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPA,
+// PWM_O_1_CMPA, and PWM_O_2_CMPA registers.
+//
+//*****************************************************************************
+#define PWM_X_CMPA_M            0x0000FFFF  // Comparator A Value.
+#define PWM_X_CMPA_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPB,
+// PWM_O_1_CMPB, and PWM_O_2_CMPB registers.
+//
+//*****************************************************************************
+#define PWM_X_CMPB_M            0x0000FFFF  // Comparator B Value.
+#define PWM_X_CMPB_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENA,
+// PWM_O_1_GENA, and PWM_O_2_GENA registers.
+//
+//*****************************************************************************
+#define PWM_X_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENA_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENA_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENA_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENA_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENA_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENA_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENA_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENA_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENA_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENA_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENA_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENB,
+// PWM_O_1_GENB, and PWM_O_2_GENB registers.
+//
+//*****************************************************************************
+#define PWM_X_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENB_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENB_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENB_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENB_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENB_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENB_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENB_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENB_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENB_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENB_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENB_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBCTL,
+// PWM_O_1_DBCTL, and PWM_O_2_DBCTL registers.
+//
+//*****************************************************************************
+#define PWM_X_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBRISE,
+// PWM_O_1_DBRISE, and PWM_O_2_DBRISE registers.
+//
+//*****************************************************************************
+#define PWM_X_DBRISE_DELAY_M    0x00000FFF  // Dead-Band Rise Delay.
+#define PWM_X_DBRISE_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBFALL,
+// PWM_O_1_DBFALL, and PWM_O_2_DBFALL registers.
+//
+//*****************************************************************************
+#define PWM_X_DBFALL_DELAY_M    0x00000FFF  // Dead-Band Fall Delay.
+#define PWM_X_DBFALL_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_CTL register.
+//
+//*****************************************************************************
+#define QEI_CTL_STALLEN         0x00001000  // Stall QEI.
+#define QEI_CTL_INVI            0x00000800  // Invert Index Pulse.
+#define QEI_CTL_INVB            0x00000400  // Invert PhB.
+#define QEI_CTL_INVA            0x00000200  // Invert PhA.
+#define QEI_CTL_VELDIV_M        0x000001C0  // Predivide Velocity.
+#define QEI_CTL_VELDIV_1        0x00000000  // /1
+#define QEI_CTL_VELDIV_2        0x00000040  // /2
+#define QEI_CTL_VELDIV_4        0x00000080  // /4
+#define QEI_CTL_VELDIV_8        0x000000C0  // /8
+#define QEI_CTL_VELDIV_16       0x00000100  // /16
+#define QEI_CTL_VELDIV_32       0x00000140  // /32
+#define QEI_CTL_VELDIV_64       0x00000180  // /64
+#define QEI_CTL_VELDIV_128      0x000001C0  // /128
+#define QEI_CTL_VELEN           0x00000020  // Capture Velocity.
+#define QEI_CTL_RESMODE         0x00000010  // Reset Mode.
+#define QEI_CTL_CAPMODE         0x00000008  // Capture Mode.
+#define QEI_CTL_SIGMODE         0x00000004  // Signal Mode.
+#define QEI_CTL_SWAP            0x00000002  // Swap Signals.
+#define QEI_CTL_ENABLE          0x00000001  // Enable QEI.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_STAT register.
+//
+//*****************************************************************************
+#define QEI_STAT_DIRECTION      0x00000002  // Direction of Rotation.
+#define QEI_STAT_ERROR          0x00000001  // Error Detected.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_POS register.
+//
+//*****************************************************************************
+#define QEI_POS_M               0xFFFFFFFF  // Current Position Integrator
+                                            // Value.
+#define QEI_POS_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_MAXPOS register.
+//
+//*****************************************************************************
+#define QEI_MAXPOS_M            0xFFFFFFFF  // Maximum Position Integrator
+                                            // Value.
+#define QEI_MAXPOS_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_LOAD register.
+//
+//*****************************************************************************
+#define QEI_LOAD_M              0xFFFFFFFF  // Velocity Timer Load Value.
+#define QEI_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_TIME register.
+//
+//*****************************************************************************
+#define QEI_TIME_M              0xFFFFFFFF  // Velocity Timer Current Value.
+#define QEI_TIME_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_COUNT register.
+//
+//*****************************************************************************
+#define QEI_COUNT_M             0xFFFFFFFF  // Velocity Pulse Count.
+#define QEI_COUNT_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_SPEED register.
+//
+//*****************************************************************************
+#define QEI_SPEED_M             0xFFFFFFFF  // Velocity.
+#define QEI_SPEED_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_INTEN register.
+//
+//*****************************************************************************
+#define QEI_INTEN_ERROR         0x00000008  // Phase Error Interrupt Enable.
+#define QEI_INTEN_DIR           0x00000004  // Direction Change Interrupt
+                                            // Enable.
+#define QEI_INTEN_TIMER         0x00000002  // Timer Expires Interrupt Enable.
+#define QEI_INTEN_INDEX         0x00000001  // Index Pulse Detected Interrupt
+                                            // Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_RIS register.
+//
+//*****************************************************************************
+#define QEI_RIS_ERROR           0x00000008  // Phase Error Detected.
+#define QEI_RIS_DIR             0x00000004  // Direction Change Detected.
+#define QEI_RIS_TIMER           0x00000002  // Velocity Timer Expired.
+#define QEI_RIS_INDEX           0x00000001  // Index Pulse Asserted.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_ISC register.
+//
+//*****************************************************************************
+#define QEI_ISC_ERROR           0x00000008  // Phase Error Interrupt.
+#define QEI_ISC_DIR             0x00000004  // Direction Change Interrupt.
+#define QEI_ISC_TIMER           0x00000002  // Velocity Timer Expired
+                                            // Interrupt.
+#define QEI_ISC_INDEX           0x00000001  // Index Pulse Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CFG register.
+//
+//*****************************************************************************
+#define TIMER_CFG_M             0x00000007  // GPTM Configuration.
+#define TIMER_CFG_32_BIT_TIMER  0x00000000  // 32-bit timer configuration.
+#define TIMER_CFG_32_BIT_RTC    0x00000001  // 32-bit real-time clock (RTC)
+                                            // counter configuration.
+#define TIMER_CFG_16_BIT        0x00000004  // 16-bit timer configuration,
+                                            // function is controlled by bits
+                                            // 1:0 of GPTMTAMR and GPTMTBMR.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMR register.
+//
+//*****************************************************************************
+#define TIMER_TAMR_TAAMS        0x00000008  // GPTM TimerA Alternate Mode
+                                            // Select.
+#define TIMER_TAMR_TACMR        0x00000004  // GPTM TimerA Capture Mode.
+#define TIMER_TAMR_TAMR_M       0x00000003  // GPTM TimerA Mode.
+#define TIMER_TAMR_TAMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TAMR_TAMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TAMR_TAMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMR register.
+//
+//*****************************************************************************
+#define TIMER_TBMR_TBAMS        0x00000008  // GPTM TimerB Alternate Mode
+                                            // Select.
+#define TIMER_TBMR_TBCMR        0x00000004  // GPTM TimerB Capture Mode.
+#define TIMER_TBMR_TBMR_M       0x00000003  // GPTM TimerB Mode.
+#define TIMER_TBMR_TBMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TBMR_TBMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TBMR_TBMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CTL register.
+//
+//*****************************************************************************
+#define TIMER_CTL_TBPWML        0x00004000  // GPTM TimerB PWM Output Level.
+#define TIMER_CTL_TBOTE         0x00002000  // GPTM TimerB Output Trigger
+                                            // Enable.
+#define TIMER_CTL_TBEVENT_M     0x00000C00  // GPTM TimerB Event Mode.
+#define TIMER_CTL_TBEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TBEVENT_NEG   0x00000400  // Negative edge
+#define TIMER_CTL_TBEVENT_BOTH  0x00000C00  // Both edges
+#define TIMER_CTL_TBSTALL       0x00000200  // GPTM TimerB Stall Enable.
+#define TIMER_CTL_TBEN          0x00000100  // GPTM TimerB Enable.
+#define TIMER_CTL_TAPWML        0x00000040  // GPTM TimerA PWM Output Level.
+#define TIMER_CTL_TAOTE         0x00000020  // GPTM TimerA Output Trigger
+                                            // Enable.
+#define TIMER_CTL_RTCEN         0x00000010  // GPTM RTC Enable.
+#define TIMER_CTL_TAEVENT_M     0x0000000C  // GPTM TimerA Event Mode.
+#define TIMER_CTL_TAEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TAEVENT_NEG   0x00000004  // Negative edge
+#define TIMER_CTL_TAEVENT_BOTH  0x0000000C  // Both edges
+#define TIMER_CTL_TASTALL       0x00000002  // GPTM TimerA Stall Enable.
+#define TIMER_CTL_TAEN          0x00000001  // GPTM TimerA Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_IMR register.
+//
+//*****************************************************************************
+#define TIMER_IMR_CBEIM         0x00000400  // GPTM CaptureB Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CBMIM         0x00000200  // GPTM CaptureB Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TBTOIM        0x00000100  // GPTM TimerB Time-Out Interrupt
+                                            // Mask.
+#define TIMER_IMR_RTCIM         0x00000008  // GPTM RTC Interrupt Mask.
+#define TIMER_IMR_CAEIM         0x00000004  // GPTM CaptureA Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CAMIM         0x00000002  // GPTM CaptureA Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TATOIM        0x00000001  // GPTM TimerA Time-Out Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_RIS register.
+//
+//*****************************************************************************
+#define TIMER_RIS_CBERIS        0x00000400  // GPTM CaptureB Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CBMRIS        0x00000200  // GPTM CaptureB Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TBTORIS       0x00000100  // GPTM TimerB Time-Out Raw
+                                            // Interrupt.
+#define TIMER_RIS_RTCRIS        0x00000008  // GPTM RTC Raw Interrupt.
+#define TIMER_RIS_CAERIS        0x00000004  // GPTM CaptureA Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CAMRIS        0x00000002  // GPTM CaptureA Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TATORIS       0x00000001  // GPTM TimerA Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_MIS register.
+//
+//*****************************************************************************
+#define TIMER_MIS_CBEMIS        0x00000400  // GPTM CaptureB Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CBMMIS        0x00000200  // GPTM CaptureB Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TBTOMIS       0x00000100  // GPTM TimerB Time-Out Masked
+                                            // Interrupt.
+#define TIMER_MIS_RTCMIS        0x00000008  // GPTM RTC Masked Interrupt.
+#define TIMER_MIS_CAEMIS        0x00000004  // GPTM CaptureA Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CAMMIS        0x00000002  // GPTM CaptureA Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TATOMIS       0x00000001  // GPTM TimerA Time-Out Masked
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_ICR register.
+//
+//*****************************************************************************
+#define TIMER_ICR_CBECINT       0x00000400  // GPTM CaptureB Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CBMCINT       0x00000200  // GPTM CaptureB Match Interrupt
+                                            // Clear.
+#define TIMER_ICR_TBTOCINT      0x00000100  // GPTM TimerB Time-Out Interrupt
+                                            // Clear.
+#define TIMER_ICR_RTCCINT       0x00000008  // GPTM RTC Interrupt Clear.
+#define TIMER_ICR_CAECINT       0x00000004  // GPTM CaptureA Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CAMCINT       0x00000002  // GPTM CaptureA Match Raw
+                                            // Interrupt.
+#define TIMER_ICR_TATOCINT      0x00000001  // GPTM TimerA Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAILR register.
+//
+//*****************************************************************************
+#define TIMER_TAILR_TAILRH_M    0xFFFF0000  // GPTM TimerA Interval Load
+                                            // Register High.
+#define TIMER_TAILR_TAILRL_M    0x0000FFFF  // GPTM TimerA Interval Load
+                                            // Register Low.
+#define TIMER_TAILR_TAILRH_S    16
+#define TIMER_TAILR_TAILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBILR register.
+//
+//*****************************************************************************
+#define TIMER_TBILR_TBILRL_M    0x0000FFFF  // GPTM TimerB Interval Load
+                                            // Register.
+#define TIMER_TBILR_TBILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TAMATCHR_TAMRH_M  0xFFFF0000  // GPTM TimerA Match Register High.
+#define TIMER_TAMATCHR_TAMRL_M  0x0000FFFF  // GPTM TimerA Match Register Low.
+#define TIMER_TAMATCHR_TAMRH_S  16
+#define TIMER_TAMATCHR_TAMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TBMATCHR_TBMRL_M  0x0000FFFF  // GPTM TimerB Match Register Low.
+#define TIMER_TBMATCHR_TBMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPR register.
+//
+//*****************************************************************************
+#define TIMER_TAPR_TAPSR_M      0x000000FF  // GPTM TimerA Prescale.
+#define TIMER_TAPR_TAPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPR register.
+//
+//*****************************************************************************
+#define TIMER_TBPR_TBPSR_M      0x000000FF  // GPTM TimerB Prescale.
+#define TIMER_TBPR_TBPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPMR register.
+//
+//*****************************************************************************
+#define TIMER_TAPMR_TAPSMR_M    0x000000FF  // GPTM TimerA Prescale Match.
+#define TIMER_TAPMR_TAPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPMR register.
+//
+//*****************************************************************************
+#define TIMER_TBPMR_TBPSMR_M    0x000000FF  // GPTM TimerB Prescale Match.
+#define TIMER_TBPMR_TBPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAR register.
+//
+//*****************************************************************************
+#define TIMER_TAR_TARH_M        0xFFFF0000  // GPTM TimerA Register High.
+#define TIMER_TAR_TARL_M        0x0000FFFF  // GPTM TimerA Register Low.
+#define TIMER_TAR_TARH_S        16
+#define TIMER_TAR_TARL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBR register.
+//
+//*****************************************************************************
+#define TIMER_TBR_TBRL_M        0x0000FFFF  // GPTM TimerB.
+#define TIMER_TBR_TBRL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ACTSS register.
+//
+//*****************************************************************************
+#define ADC_ACTSS_ASEN3         0x00000008  // ADC SS3 Enable.
+#define ADC_ACTSS_ASEN2         0x00000004  // ADC SS2 Enable.
+#define ADC_ACTSS_ASEN1         0x00000002  // ADC SS1 Enable.
+#define ADC_ACTSS_ASEN0         0x00000001  // ADC SS0 Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_RIS register.
+//
+//*****************************************************************************
+#define ADC_RIS_INR3            0x00000008  // SS3 Raw Interrupt Status.
+#define ADC_RIS_INR2            0x00000004  // SS2 Raw Interrupt Status.
+#define ADC_RIS_INR1            0x00000002  // SS1 Raw Interrupt Status.
+#define ADC_RIS_INR0            0x00000001  // SS0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_IM register.
+//
+//*****************************************************************************
+#define ADC_IM_MASK3            0x00000008  // SS3 Interrupt Mask.
+#define ADC_IM_MASK2            0x00000004  // SS2 Interrupt Mask.
+#define ADC_IM_MASK1            0x00000002  // SS1 Interrupt Mask.
+#define ADC_IM_MASK0            0x00000001  // SS0 Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ISC register.
+//
+//*****************************************************************************
+#define ADC_ISC_IN3             0x00000008  // SS3 Interrupt Status and Clear.
+#define ADC_ISC_IN2             0x00000004  // SS2 Interrupt Status and Clear.
+#define ADC_ISC_IN1             0x00000002  // SS1 Interrupt Status and Clear.
+#define ADC_ISC_IN0             0x00000001  // SS0 Interrupt Status and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_OSTAT register.
+//
+//*****************************************************************************
+#define ADC_OSTAT_OV3           0x00000008  // SS3 FIFO Overflow.
+#define ADC_OSTAT_OV2           0x00000004  // SS2 FIFO Overflow.
+#define ADC_OSTAT_OV1           0x00000002  // SS1 FIFO Overflow.
+#define ADC_OSTAT_OV0           0x00000001  // SS0 FIFO Overflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_EMUX register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_M          0x0000F000  // SS3 Trigger Select.
+#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog Comparator 0
+#define ADC_EMUX_EM3_COMP1      0x00002000  // Analog Comparator 1
+#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External (GPIO PB4)
+#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer
+#define ADC_EMUX_EM3_PWM0       0x00006000  // PWM0
+#define ADC_EMUX_EM3_PWM1       0x00007000  // PWM1
+#define ADC_EMUX_EM3_PWM2       0x00008000  // PWM2
+#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always (continuously sample)
+#define ADC_EMUX_EM2_M          0x00000F00  // SS2 Trigger Select.
+#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog Comparator 0
+#define ADC_EMUX_EM2_COMP1      0x00000200  // Analog Comparator 1
+#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External (GPIO PB4)
+#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer
+#define ADC_EMUX_EM2_PWM0       0x00000600  // PWM0
+#define ADC_EMUX_EM2_PWM1       0x00000700  // PWM1
+#define ADC_EMUX_EM2_PWM2       0x00000800  // PWM2
+#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always (continuously sample)
+#define ADC_EMUX_EM1_M          0x000000F0  // SS1 Trigger Select.
+#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog Comparator 0
+#define ADC_EMUX_EM1_COMP1      0x00000020  // Analog Comparator 1
+#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External (GPIO PB4)
+#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer
+#define ADC_EMUX_EM1_PWM0       0x00000060  // PWM0
+#define ADC_EMUX_EM1_PWM1       0x00000070  // PWM1
+#define ADC_EMUX_EM1_PWM2       0x00000080  // PWM2
+#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always (continuously sample)
+#define ADC_EMUX_EM0_M          0x0000000F  // SS0 Trigger Select.
+#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog Comparator 0
+#define ADC_EMUX_EM0_COMP1      0x00000002  // Analog Comparator 1
+#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External (GPIO PB4)
+#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer
+#define ADC_EMUX_EM0_PWM0       0x00000006  // PWM0
+#define ADC_EMUX_EM0_PWM1       0x00000007  // PWM1
+#define ADC_EMUX_EM0_PWM2       0x00000008  // PWM2
+#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always (continuously sample)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_USTAT register.
+//
+//*****************************************************************************
+#define ADC_USTAT_UV3           0x00000008  // SS3 FIFO Underflow.
+#define ADC_USTAT_UV2           0x00000004  // SS2 FIFO Underflow.
+#define ADC_USTAT_UV1           0x00000002  // SS1 FIFO Underflow.
+#define ADC_USTAT_UV0           0x00000001  // SS0 FIFO Underflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSPRI register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_M         0x00003000  // SS3 Priority.
+#define ADC_SSPRI_SS3_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS3_2ND       0x00001000  // Second priority
+#define ADC_SSPRI_SS3_3RD       0x00002000  // Third priority
+#define ADC_SSPRI_SS3_4TH       0x00003000  // Fourth priority
+#define ADC_SSPRI_SS2_M         0x00000300  // SS2 Priority.
+#define ADC_SSPRI_SS2_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS2_2ND       0x00000100  // Second priority
+#define ADC_SSPRI_SS2_3RD       0x00000200  // Third priority
+#define ADC_SSPRI_SS2_4TH       0x00000300  // Fourth priority
+#define ADC_SSPRI_SS1_M         0x00000030  // SS1 Priority.
+#define ADC_SSPRI_SS1_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS1_2ND       0x00000010  // Second priority
+#define ADC_SSPRI_SS1_3RD       0x00000020  // Third priority
+#define ADC_SSPRI_SS1_4TH       0x00000030  // Fourth priority
+#define ADC_SSPRI_SS0_M         0x00000003  // SS0 Priority.
+#define ADC_SSPRI_SS0_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS0_2ND       0x00000001  // Second priority
+#define ADC_SSPRI_SS0_3RD       0x00000002  // Third priority
+#define ADC_SSPRI_SS0_4TH       0x00000003  // Fourth priority
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_PSSI register.
+//
+//*****************************************************************************
+#define ADC_PSSI_SS3            0x00000008  // SS3 Initiate.
+#define ADC_PSSI_SS2            0x00000004  // SS2 Initiate.
+#define ADC_PSSI_SS1            0x00000002  // SS1 Initiate.
+#define ADC_PSSI_SS0            0x00000001  // SS0 Initiate.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SAC register.
+//
+//*****************************************************************************
+#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control.
+#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
+#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
+#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
+#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
+#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
+#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
+#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX0_MUX7_M       0x30000000  // 8th Sample Input Select.
+#define ADC_SSMUX0_MUX6_M       0x03000000  // 7th Sample Input Select.
+#define ADC_SSMUX0_MUX5_M       0x00300000  // 6th Sample Input Select.
+#define ADC_SSMUX0_MUX4_M       0x00030000  // 5th Sample Input Select.
+#define ADC_SSMUX0_MUX3_M       0x00003000  // 4th Sample Input Select.
+#define ADC_SSMUX0_MUX2_M       0x00000300  // 3rd Sample Input Select.
+#define ADC_SSMUX0_MUX1_M       0x00000030  // 2nd Sample Input Select.
+#define ADC_SSMUX0_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX0_MUX7_S       28
+#define ADC_SSMUX0_MUX6_S       24
+#define ADC_SSMUX0_MUX5_S       20
+#define ADC_SSMUX0_MUX4_S       16
+#define ADC_SSMUX0_MUX3_S       12
+#define ADC_SSMUX0_MUX2_S       8
+#define ADC_SSMUX0_MUX1_S       4
+#define ADC_SSMUX0_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable.
+#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence.
+#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Diff Input Select.
+#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable.
+#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence.
+#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Diff Input Select.
+#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable.
+#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence.
+#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Diff Input Select.
+#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable.
+#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence.
+#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Diff Input Select.
+#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO0_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT0_HPTR_S     4
+#define ADC_SSFSTAT0_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX1_MUX3_M       0x00003000  // 4th Sample Input Select.
+#define ADC_SSMUX1_MUX2_M       0x00000300  // 3rd Sample Input Select.
+#define ADC_SSMUX1_MUX1_M       0x00000030  // 2nd Sample Input Select.
+#define ADC_SSMUX1_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX1_MUX3_S       12
+#define ADC_SSMUX1_MUX2_S       8
+#define ADC_SSMUX1_MUX1_S       4
+#define ADC_SSMUX1_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO1_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT1_HPTR_S     4
+#define ADC_SSFSTAT1_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX2_MUX3_M       0x00003000  // 4th Sample Input Select.
+#define ADC_SSMUX2_MUX2_M       0x00000300  // 3rd Sample Input Select.
+#define ADC_SSMUX2_MUX1_M       0x00000030  // 2nd Sample Input Select.
+#define ADC_SSMUX2_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX2_MUX3_S       12
+#define ADC_SSMUX2_MUX2_S       8
+#define ADC_SSMUX2_MUX1_S       4
+#define ADC_SSMUX2_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO2_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT2_HPTR_S     4
+#define ADC_SSFSTAT2_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX3_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX3_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL3_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL3_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL3_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO3_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT3_HPTR_S     4
+#define ADC_SSFSTAT3_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_TMLB register.
+//
+//*****************************************************************************
+#define ADC_TMLB_LB             0x00000001  // Loopback Mode Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_TMLB_CNT_M   0x000003C0  // Continuous Sample Counter.
+#define ADC_SSFIFO_TMLB_CONT    0x00000020  // Continuation Sample Indicator.
+#define ADC_SSFIFO_TMLB_DIFF    0x00000010  // Differential Sample Indicator.
+#define ADC_SSFIFO_TMLB_TS      0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_SSFIFO_TMLB_MUX_M   0x00000007  // Analog Input Indicator.
+#define ADC_SSFIFO_TMLB_CNT_S   6           // Sample counter shift
+#define ADC_SSFIFO_TMLB_MUX_S   0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_TMLB_CNT_M          0x000003C0  // Continuous Sample Counter.
+#define ADC_TMLB_CONT           0x00000020  // Continuation Sample Indicator.
+#define ADC_TMLB_DIFF           0x00000010  // Differential Sample Indicator.
+#define ADC_TMLB_TS             0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_TMLB_MUX_M          0x00000007  // Analog Input Indicator.
+#define ADC_TMLB_CNT_S          6           // Sample counter shift
+#define ADC_TMLB_MUX_S          0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACMIS register.
+//
+//*****************************************************************************
+#define COMP_ACMIS_IN1          0x00000002  // Comparator 1 Masked Interrupt
+                                            // Status.
+#define COMP_ACMIS_IN0          0x00000001  // Comparator 0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACRIS register.
+//
+//*****************************************************************************
+#define COMP_ACRIS_IN1          0x00000002  // Comparator 1 Interrupt Status.
+#define COMP_ACRIS_IN0          0x00000001  // Comparator 0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACINTEN register.
+//
+//*****************************************************************************
+#define COMP_ACINTEN_IN1        0x00000002  // Comparator 1 Interrupt Enable.
+#define COMP_ACINTEN_IN0        0x00000001  // Comparator 0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACREFCTL
+// register.
+//
+//*****************************************************************************
+#define COMP_ACREFCTL_EN        0x00000200  // Resistor Ladder Enable.
+#define COMP_ACREFCTL_RNG       0x00000100  // Resistor Ladder Range.
+#define COMP_ACREFCTL_VREF_M    0x0000000F  // Resistor Ladder Voltage Ref.
+#define COMP_ACREFCTL_VREF_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT0 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT0_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL0 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL0_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL0_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL0_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL0_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL0_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL0_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL0_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL0_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL0_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL0_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL0_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL0_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL0_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL0_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL0_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL0_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL0_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL0_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT1 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT1_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL1 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL1_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL1_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL1_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL1_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL1_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL1_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL1_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL1_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL1_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL1_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL1_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL1_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL1_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL1_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL1_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL1_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL1_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL1_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR0 register.
+//
+//*****************************************************************************
+#define PHY_MR0_RESET           0x00008000  // Reset Registers.
+#define PHY_MR0_LOOPBK          0x00004000  // Loopback Mode.
+#define PHY_MR0_SPEEDSL         0x00002000  // Speed Select.
+#define PHY_MR0_ANEGEN          0x00001000  // Auto-Negotiation Enable.
+#define PHY_MR0_PWRDN           0x00000800  // Power Down.
+#define PHY_MR0_ISO             0x00000400  // Isolate.
+#define PHY_MR0_RANEG           0x00000200  // Restart Auto-Negotiation.
+#define PHY_MR0_DUPLEX          0x00000100  // Set Duplex Mode.
+#define PHY_MR0_COLT            0x00000080  // Collision Test.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RIS register.
+//
+//*****************************************************************************
+#define MAC_RIS_PHYINT          0x00000040  // PHY Interrupt.
+#define MAC_RIS_MDINT           0x00000020  // MII Transaction Complete.
+#define MAC_RIS_RXER            0x00000010  // Receive Error.
+#define MAC_RIS_FOV             0x00000008  // FIFO Overrun.
+#define MAC_RIS_TXEMP           0x00000004  // Transmit FIFO Empty.
+#define MAC_RIS_TXER            0x00000002  // Transmit Error.
+#define MAC_RIS_RXINT           0x00000001  // Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IACK register.
+//
+//*****************************************************************************
+#define MAC_IACK_PHYINT         0x00000040  // Clear PHY Interrupt.
+#define MAC_IACK_MDINT          0x00000020  // Clear MII Transaction Complete.
+#define MAC_IACK_RXER           0x00000010  // Clear Receive Error.
+#define MAC_IACK_FOV            0x00000008  // Clear FIFO Overrun.
+#define MAC_IACK_TXEMP          0x00000004  // Clear Transmit FIFO Empty.
+#define MAC_IACK_TXER           0x00000002  // Clear Transmit Error.
+#define MAC_IACK_RXINT          0x00000001  // Clear Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR1 register.
+//
+//*****************************************************************************
+#define PHY_MR1_100X_F          0x00004000  // 100BASE-TX Full-Duplex Mode.
+#define PHY_MR1_100X_H          0x00002000  // 100BASE-TX Half-Duplex Mode.
+#define PHY_MR1_10T_F           0x00001000  // 10BASE-T Full-Duplex Mode.
+#define PHY_MR1_10T_H           0x00000800  // 10BASE-T Half-Duplex Mode.
+#define PHY_MR1_MFPS            0x00000040  // Management Frames with Preamble
+                                            // Suppressed.
+#define PHY_MR1_ANEGC           0x00000020  // Auto-Negotiation Complete.
+#define PHY_MR1_RFAULT          0x00000010  // Remote Fault.
+#define PHY_MR1_ANEGA           0x00000008  // Auto-Negotiation.
+#define PHY_MR1_LINK            0x00000004  // Link Made.
+#define PHY_MR1_JAB             0x00000002  // Jabber Condition.
+#define PHY_MR1_EXTD            0x00000001  // Extended Capabilities.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR2 register.
+//
+//*****************************************************************************
+#define PHY_MR2_OUI_M           0x0000FFFF  // Organizationally Unique
+                                            // Identifier[21:6].
+#define PHY_MR2_OUI_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR3 register.
+//
+//*****************************************************************************
+#define PHY_MR3_OUI_M           0x0000FC00  // Organizationally Unique
+                                            // Identifier[5:0].
+#define PHY_MR3_MN_M            0x000003F0  // Model Number.
+#define PHY_MR3_RN_M            0x0000000F  // Revision Number.
+#define PHY_MR3_OUI_S           10
+#define PHY_MR3_MN_S            4
+#define PHY_MR3_RN_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IM register.
+//
+//*****************************************************************************
+#define MAC_IM_PHYINTM          0x00000040  // Mask PHY Interrupt.
+#define MAC_IM_MDINTM           0x00000020  // Mask MII Transaction Complete.
+#define MAC_IM_RXERM            0x00000010  // Mask Receive Error.
+#define MAC_IM_FOVM             0x00000008  // Mask FIFO Overrun.
+#define MAC_IM_TXEMPM           0x00000004  // Mask Transmit FIFO Empty.
+#define MAC_IM_TXERM            0x00000002  // Mask Transmit Error.
+#define MAC_IM_RXINTM           0x00000001  // Mask Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR4 register.
+//
+//*****************************************************************************
+#define PHY_MR4_NP              0x00008000  // Next Page.
+#define PHY_MR4_RF              0x00002000  // Remote Fault.
+#define PHY_MR4_A3              0x00000100  // Technology Ability Field[3].
+#define PHY_MR4_A2              0x00000080  // Technology Ability Field[2].
+#define PHY_MR4_A1              0x00000040  // Technology Ability Field[1].
+#define PHY_MR4_A0              0x00000020  // Technology Ability Field[0].
+#define PHY_MR4_S_M             0x0000001F  // Selector Field.
+#define PHY_MR4_S_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR5 register.
+//
+//*****************************************************************************
+#define PHY_MR5_NP              0x00008000  // Next Page.
+#define PHY_MR5_ACK             0x00004000  // Acknowledge.
+#define PHY_MR5_RF              0x00002000  // Remote Fault.
+#define PHY_MR5_A_M             0x00001FE0  // Technology Ability Field.
+#define PHY_MR5_S_M             0x0000001F  // Selector Field.
+#define PHY_MR5_S_8023          0x00000001  // IEEE Std 802.3
+#define PHY_MR5_S_8029          0x00000002  // IEEE Std 802.9 ISLAN-16T
+#define PHY_MR5_S_8025          0x00000003  // IEEE Std 802.5
+#define PHY_MR5_S_1394          0x00000004  // IEEE Std 1394
+#define PHY_MR5_A_S             5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR6 register.
+//
+//*****************************************************************************
+#define PHY_MR6_PDF             0x00000010  // Parallel Detection Fault.
+#define PHY_MR6_LPNPA           0x00000008  // Link Partner is Next Page Able.
+#define PHY_MR6_PRX             0x00000002  // New Page Received.
+#define PHY_MR6_LPANEGA         0x00000001  // Link Partner is Auto-Negotiation
+                                            // Able.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RCTL register.
+//
+//*****************************************************************************
+#define MAC_RCTL_RSTFIFO        0x00000010  // Clear Receive FIFO.
+#define MAC_RCTL_BADCRC         0x00000008  // Enable Reject Bad CRC.
+#define MAC_RCTL_PRMS           0x00000004  // Enable Promiscuous Mode.
+#define MAC_RCTL_AMUL           0x00000002  // Enable Multicast Frames.
+#define MAC_RCTL_RXEN           0x00000001  // Enable Receiver.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TCTL register.
+//
+//*****************************************************************************
+#define MAC_TCTL_DUPLEX         0x00000010  // Enable Duplex Mode.
+#define MAC_TCTL_CRC            0x00000004  // Enable CRC Generation.
+#define MAC_TCTL_PADEN          0x00000002  // Enable Packet Padding.
+#define MAC_TCTL_TXEN           0x00000001  // Enable Transmitter.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_DATA register.
+//
+//*****************************************************************************
+#define MAC_DATA_TXDATA_M       0xFFFFFFFF  // Transmit FIFO Data.
+#define MAC_DATA_RXDATA_M       0xFFFFFFFF  // Receive FIFO Data.
+#define MAC_DATA_RXDATA_S       0
+#define MAC_DATA_TXDATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR16 register.
+//
+//*****************************************************************************
+#define PHY_MR16_RPTR           0x00008000  // Repeater Mode.
+#define PHY_MR16_INPOL          0x00004000  // Interrupt Polarity.
+#define PHY_MR16_TXHIM          0x00001000  // Transmit High Impedance Mode.
+#define PHY_MR16_SQEI           0x00000800  // SQE Inhibit Testing.
+#define PHY_MR16_NL10           0x00000400  // Natural Loopback Mode.
+#define PHY_MR16_APOL           0x00000020  // Auto-Polarity Disable.
+#define PHY_MR16_RVSPOL         0x00000010  // Receive Data Polarity.
+#define PHY_MR16_PCSBP          0x00000002  // PCS Bypass.
+#define PHY_MR16_RXCC           0x00000001  // Receive Clock Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR17 register.
+//
+//*****************************************************************************
+#define PHY_MR17_JABBER_IE      0x00008000  // Jabber Interrupt Enable.
+#define PHY_MR17_RXER_IE        0x00004000  // Receive Error Interrupt Enable.
+#define PHY_MR17_PRX_IE         0x00002000  // Page Received Interrupt Enable.
+#define PHY_MR17_PDF_IE         0x00001000  // Parallel Detection Fault
+                                            // Interrupt Enable.
+#define PHY_MR17_LPACK_IE       0x00000800  // LP Acknowledge Interrupt Enable.
+#define PHY_MR17_LSCHG_IE       0x00000400  // Link Status Change Interrupt
+                                            // Enable.
+#define PHY_MR17_RFAULT_IE      0x00000200  // Remote Fault Interrupt Enable.
+#define PHY_MR17_ANEGCOMP_IE    0x00000100  // Auto-Negotiation Complete
+                                            // Interrupt Enable.
+#define PHY_MR17_JABBER_INT     0x00000080  // Jabber Event Interrupt.
+#define PHY_MR17_RXER_INT       0x00000040  // Receive Error Interrupt.
+#define PHY_MR17_PRX_INT        0x00000020  // Page Receive Interrupt.
+#define PHY_MR17_PDF_INT        0x00000010  // Parallel Detection Fault
+                                            // Interrupt.
+#define PHY_MR17_LPACK_INT      0x00000008  // LP Acknowledge Interrupt.
+#define PHY_MR17_LSCHG_INT      0x00000004  // Link Status Change Interrupt.
+#define PHY_MR17_RFAULT_INT     0x00000002  // Remote Fault Interrupt.
+#define PHY_MR17_ANEGCOMP_INT   0x00000001  // Auto-Negotiation Complete
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR18 register.
+//
+//*****************************************************************************
+#define PHY_MR18_ANEGF          0x00001000  // Auto-Negotiation Failure.
+#define PHY_MR18_DPLX           0x00000800  // Duplex Mode.
+#define PHY_MR18_RATE           0x00000400  // Rate.
+#define PHY_MR18_RXSD           0x00000200  // Receive Detection.
+#define PHY_MR18_RX_LOCK        0x00000100  // Receive PLL Lock.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR19 register.
+//
+//*****************************************************************************
+#define PHY_MR19_TXO_M          0x0000C000  // Transmit Amplitude Selection.
+#define PHY_MR19_TXO_00DB       0x00000000  // Gain set for 0.0dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_04DB       0x00004000  // Gain set for 0.4dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_08DB       0x00008000  // Gain set for 0.8dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_12DB       0x0000C000  // Gain set for 1.2dB of insertion
+                                            // loss
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA0 register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4_M       0xFF000000  // MAC Address Octet 4.
+#define MAC_IA0_MACOCT3_M       0x00FF0000  // MAC Address Octet 3.
+#define MAC_IA0_MACOCT2_M       0x0000FF00  // MAC Address Octet 2.
+#define MAC_IA0_MACOCT1_M       0x000000FF  // MAC Address Octet 1.
+#define MAC_IA0_MACOCT4_S       24
+#define MAC_IA0_MACOCT3_S       16
+#define MAC_IA0_MACOCT2_S       8
+#define MAC_IA0_MACOCT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR23 register.
+//
+//*****************************************************************************
+#define PHY_MR23_LED1_M         0x000000F0  // LED1 Source.
+#define PHY_MR23_LED1_LINK      0x00000000  // Link OK
+#define PHY_MR23_LED1_RXTX      0x00000010  // RX or TX Activity (Default LED1)
+#define PHY_MR23_LED1_100       0x00000050  // 100BASE-TX mode
+#define PHY_MR23_LED1_10        0x00000060  // 10BASE-T mode
+#define PHY_MR23_LED1_DUPLEX    0x00000070  // Full-Duplex
+#define PHY_MR23_LED1_LINKACT   0x00000080  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+#define PHY_MR23_LED0_M         0x0000000F  // LED0 Source.
+#define PHY_MR23_LED0_LINK      0x00000000  // Link OK (Default LED0)
+#define PHY_MR23_LED0_RXTX      0x00000001  // RX or TX Activity
+#define PHY_MR23_LED0_100       0x00000005  // 100BASE-TX mode
+#define PHY_MR23_LED0_10        0x00000006  // 10BASE-T mode
+#define PHY_MR23_LED0_DUPLEX    0x00000007  // Full-Duplex
+#define PHY_MR23_LED0_LINKACT   0x00000008  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA1 register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6_M       0x0000FF00  // MAC Address Octet 6.
+#define MAC_IA1_MACOCT5_M       0x000000FF  // MAC Address Octet 5.
+#define MAC_IA1_MACOCT6_S       8
+#define MAC_IA1_MACOCT5_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR24 register.
+//
+//*****************************************************************************
+#define PHY_MR24_PD_MODE        0x00000080  // Parallel Detection Mode.
+#define PHY_MR24_AUTO_SW        0x00000040  // Auto-Switching Enable.
+#define PHY_MR24_MDIX           0x00000020  // Auto-Switching Configuration.
+#define PHY_MR24_MDIX_CM        0x00000010  // Auto-Switching Complete.
+#define PHY_MR24_MDIX_SD_M      0x0000000F  // Auto-Switching Seed.
+#define PHY_MR24_MDIX_SD_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_THR register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH_M        0x0000003F  // Threshold Value.
+#define MAC_THR_THRESH_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MCTL register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR_M       0x000000F8  // MII Register Address.
+#define MAC_MCTL_WRITE          0x00000002  // MII Register Transaction Type.
+#define MAC_MCTL_START          0x00000001  // MII Register Transaction Enable.
+#define MAC_MCTL_REGADR_S       3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MDV register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV_M           0x000000FF  // Clock Divider.
+#define MAC_MDV_DIV_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MTXD register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX_M         0x0000FFFF  // MII Register Transmit Data.
+#define MAC_MTXD_MDTX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MRXD register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX_M         0x0000FFFF  // MII Register Receive Data.
+#define MAC_MRXD_MDRX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_NP register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR_M            0x0000003F  // Number of Packets in Receive
+                                            // FIFO.
+#define MAC_NP_NPR_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TR register.
+//
+//*****************************************************************************
+#define MAC_TR_NEWTX            0x00000001  // New Transmission.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCC register.
+//
+//*****************************************************************************
+#define HIB_RTCC_M              0xFFFFFFFF  // RTC Counter.
+#define HIB_RTCC_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCM0 register.
+//
+//*****************************************************************************
+#define HIB_RTCM0_M             0xFFFFFFFF  // RTC Match 0.
+#define HIB_RTCM0_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCM1 register.
+//
+//*****************************************************************************
+#define HIB_RTCM1_M             0xFFFFFFFF  // RTC Match 1.
+#define HIB_RTCM1_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCLD register.
+//
+//*****************************************************************************
+#define HIB_RTCLD_M             0xFFFFFFFF  // RTC Load.
+#define HIB_RTCLD_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CTL register.
+//
+//*****************************************************************************
+#define HIB_CTL_VABORT          0x00000080  // Power Cut Abort Enable.
+#define HIB_CTL_CLK32EN         0x00000040  // Clocking Enable.
+#define HIB_CTL_LOWBATEN        0x00000020  // Low Battery Monitoring Enable.
+#define HIB_CTL_PINWEN          0x00000010  // External WAKE Pin Enable.
+#define HIB_CTL_RTCWEN          0x00000008  // RTC Wake-up Enable.
+#define HIB_CTL_CLKSEL          0x00000004  // Hibernation Module Clock Select.
+#define HIB_CTL_HIBREQ          0x00000002  // Hibernation Request.
+#define HIB_CTL_RTCEN           0x00000001  // RTC Timer Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IM register.
+//
+//*****************************************************************************
+#define HIB_IM_EXTW             0x00000008  // External Wake-Up Interrupt Mask.
+#define HIB_IM_LOWBAT           0x00000004  // Low Battery Voltage Interrupt
+                                            // Mask.
+#define HIB_IM_RTCALT1          0x00000002  // RTC Alert1 Interrupt Mask.
+#define HIB_IM_RTCALT0          0x00000001  // RTC Alert0 Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RIS register.
+//
+//*****************************************************************************
+#define HIB_RIS_EXTW            0x00000008  // External Wake-Up Raw Interrupt
+                                            // Status.
+#define HIB_RIS_LOWBAT          0x00000004  // Low Battery Voltage Raw
+                                            // Interrupt Status.
+#define HIB_RIS_RTCALT1         0x00000002  // RTC Alert1 Raw Interrupt Status.
+#define HIB_RIS_RTCALT0         0x00000001  // RTC Alert0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_MIS register.
+//
+//*****************************************************************************
+#define HIB_MIS_EXTW            0x00000008  // External Wake-Up Masked
+                                            // Interrupt Status.
+#define HIB_MIS_LOWBAT          0x00000004  // Low Battery Voltage Masked
+                                            // Interrupt Status.
+#define HIB_MIS_RTCALT1         0x00000002  // RTC Alert1 Masked Interrupt
+                                            // Status.
+#define HIB_MIS_RTCALT0         0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IC register.
+//
+//*****************************************************************************
+#define HIB_IC_EXTW             0x00000008  // External Wake-Up Masked
+                                            // Interrupt Clear.
+#define HIB_IC_LOWBAT           0x00000004  // Low Battery Voltage Masked
+                                            // Interrupt Clear.
+#define HIB_IC_RTCALT1          0x00000002  // RTC Alert1 Masked Interrupt
+                                            // Clear.
+#define HIB_IC_RTCALT0          0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCT register.
+//
+//*****************************************************************************
+#define HIB_RTCT_TRIM_M         0x0000FFFF  // RTC Trim Value.
+#define HIB_RTCT_TRIM_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_DATA register.
+//
+//*****************************************************************************
+#define HIB_DATA_RTD_M          0xFFFFFFFF  // Hibernation Module NV
+                                            // Registers[63:0].
+#define HIB_DATA_RTD_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMA register.
+//
+//*****************************************************************************
+#define FLASH_FMA_OFFSET_M      0x0003FFFF  // Address Offset.
+#define FLASH_FMA_OFFSET_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMD register.
+//
+//*****************************************************************************
+#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value.
+#define FLASH_FMD_DATA_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_M       0xFFFF0000  // Flash Write Key.
+#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
+#define FLASH_FMC_COMT          0x00000008  // Commit Register Value.
+#define FLASH_FMC_MERASE        0x00000004  // Mass Erase Flash Memory.
+#define FLASH_FMC_ERASE         0x00000002  // Erase a Page of Flash Memory.
+#define FLASH_FMC_WRITE         0x00000001  // Write a Word into Flash Memory.
+#define FLASH_FMC_WRKEY_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCRIS register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt
+                                            // Status.
+#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCIM register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask.
+#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCMISC register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
+                                            // Status and Clear.
+#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USECRL register.
+//
+//*****************************************************************************
+#define FLASH_USECRL_M          0x000000FF  // Microsecond Reload Value.
+#define FLASH_USECRL_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERDBG register.
+//
+//*****************************************************************************
+#define FLASH_USERDBG_NW        0x80000000  // User Debug Not Written.
+#define FLASH_USERDBG_DATA_M    0x7FFFFFFC  // User Data.
+#define FLASH_USERDBG_DBG1      0x00000002  // Debug Control 1.
+#define FLASH_USERDBG_DBG0      0x00000001  // Debug Control 0.
+#define FLASH_USERDBG_DATA_S    2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG0 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG0_NW       0x80000000  // Not Written.
+#define FLASH_USERREG0_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG0_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG1 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG1_NW       0x80000000  // Not Written.
+#define FLASH_USERREG1_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG1_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the erase size of the FLASH block that is
+// erased by an erase operation, and the protect size is the size of the FLASH
+// block that is protected by each protection register.
+//
+//*****************************************************************************
+#define FLASH_PROTECT_SIZE      0x00000800
+#define FLASH_ERASE_SIZE        0x00000400
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID0_VER_M       0x70000000  // DID0 Version.
+#define SYSCTL_DID0_VER_1       0x10000000  // Second version of the DID0
+                                            // register format.
+#define SYSCTL_DID0_CLASS_M     0x00FF0000  // Device Class.
+#define SYSCTL_DID0_CLASS_FURY  0x00010000  // Stellaris(r) Fury-class devices.
+#define SYSCTL_DID0_MAJ_M       0x0000FF00  // Major Revision.
+#define SYSCTL_DID0_MAJ_REVA    0x00000000  // Revision A (initial device)
+#define SYSCTL_DID0_MAJ_REVB    0x00000100  // Revision B (first base layer
+                                            // revision)
+#define SYSCTL_DID0_MAJ_REVC    0x00000200  // Revision C (second base layer
+                                            // revision)
+#define SYSCTL_DID0_MIN_M       0x000000FF  // Minor Revision.
+#define SYSCTL_DID0_MIN_0       0x00000000  // Initial device, or a major
+                                            // revision update.
+#define SYSCTL_DID0_MIN_1       0x00000001  // First metal layer change.
+#define SYSCTL_DID0_MIN_2       0x00000002  // Second metal layer change.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID1_VER_M       0xF0000000  // DID1 Version.
+#define SYSCTL_DID1_VER_1       0x10000000  // Second version of the DID1
+                                            // register format.
+#define SYSCTL_DID1_FAM_M       0x0F000000  // Family.
+#define SYSCTL_DID1_FAM_STELLARIS \
+                                0x00000000  // Stellaris family of
+                                            // microcontollers, that is, all
+                                            // devices with external part
+                                            // numbers starting with LM3S.
+#define SYSCTL_DID1_PRTNO_M     0x00FF0000  // Part Number.
+#define SYSCTL_DID1_PRTNO_6965  0x00730000  // LM3S6965
+#define SYSCTL_DID1_PINCNT_M    0x0000E000  // Package Pin Count.
+#define SYSCTL_DID1_PINCNT_100  0x00004000  // 100-pin or 108-ball package
+#define SYSCTL_DID1_TEMP_M      0x000000E0  // Temperature Range.
+#define SYSCTL_DID1_TEMP_C      0x00000000  // Commercial temperature range (0C
+                                            // to 70C)
+#define SYSCTL_DID1_TEMP_I      0x00000020  // Industrial temperature range
+                                            // (-40C to 85C)
+#define SYSCTL_DID1_TEMP_E      0x00000040  // Extended temperature range (-40C
+                                            // to 105C)
+#define SYSCTL_DID1_PKG_M       0x00000018  // Package Type.
+#define SYSCTL_DID1_PKG_28SOIC  0x00000000  // SOIC package
+#define SYSCTL_DID1_PKG_48QFP   0x00000008  // LQFP package
+#define SYSCTL_DID1_PKG_BGA     0x00000010  // BGA package
+#define SYSCTL_DID1_ROHS        0x00000004  // RoHS-Compliance.
+#define SYSCTL_DID1_QUAL_M      0x00000003  // Qualification Status.
+#define SYSCTL_DID1_QUAL_ES     0x00000000  // Engineering Sample (unqualified)
+#define SYSCTL_DID1_QUAL_PP     0x00000001  // Pilot Production (unqualified)
+#define SYSCTL_DID1_QUAL_FQ     0x00000002  // Fully Qualified
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC0_SRAMSZ_M     0xFFFF0000  // SRAM Size.
+#define SYSCTL_DC0_SRAMSZ_64KB  0x00FF0000  // 64 KB of SRAM
+#define SYSCTL_DC0_FLASHSZ_M    0x0000FFFF  // Flash Size.
+#define SYSCTL_DC0_FLASHSZ_256K 0x0000007F  // 256 KB of Flash
+#define SYSCTL_DC0_SRAMSZ_S     16          // SRAM size shift
+#define SYSCTL_DC0_FLASHSZ_S    0           // Flash size shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC1_PWM          0x00100000  // PWM Module Present.
+#define SYSCTL_DC1_ADC          0x00010000  // ADC Module Present.
+#define SYSCTL_DC1_MINSYSDIV_M  0x0000F000  // System Clock Divider.
+#define SYSCTL_DC1_MINSYSDIV_50 0x00003000  // Specifies a 50-MHz CPU clock
+                                            // with a PLL divider of 4.
+#define SYSCTL_DC1_ADCSPD_M     0x00000300  // Max ADC Speed.
+#define SYSCTL_DC1_ADCSPD_1M    0x00000300  // 1M samples/second
+#define SYSCTL_DC1_MPU          0x00000080  // MPU Present.
+#define SYSCTL_DC1_HIB          0x00000040  // Hibernation Module Present.
+#define SYSCTL_DC1_TEMP         0x00000020  // Temp Sensor Present.
+#define SYSCTL_DC1_PLL          0x00000010  // PLL Present.
+#define SYSCTL_DC1_WDT          0x00000008  // Watchdog Timer Present.
+#define SYSCTL_DC1_SWO          0x00000004  // SWO Trace Port Present.
+#define SYSCTL_DC1_SWD          0x00000002  // SWD Present.
+#define SYSCTL_DC1_JTAG         0x00000001  // JTAG Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC2_COMP1        0x02000000  // Analog Comparator 1 Present.
+#define SYSCTL_DC2_COMP0        0x01000000  // Analog Comparator 0 Present.
+#define SYSCTL_DC2_TIMER3       0x00080000  // Timer 3 Present.
+#define SYSCTL_DC2_TIMER2       0x00040000  // Timer 2 Present.
+#define SYSCTL_DC2_TIMER1       0x00020000  // Timer 1 Present.
+#define SYSCTL_DC2_TIMER0       0x00010000  // Timer 0 Present.
+#define SYSCTL_DC2_I2C1         0x00004000  // I2C Module 1 Present.
+#define SYSCTL_DC2_I2C0         0x00001000  // I2C Module 0 Present.
+#define SYSCTL_DC2_QEI1         0x00000200  // QEI1 Present.
+#define SYSCTL_DC2_QEI0         0x00000100  // QEI0 Present.
+#define SYSCTL_DC2_SSI0         0x00000010  // SSI0 Present.
+#define SYSCTL_DC2_UART2        0x00000004  // UART2 Present.
+#define SYSCTL_DC2_UART1        0x00000002  // UART1 Present.
+#define SYSCTL_DC2_UART0        0x00000001  // UART0 Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC3 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC3_32KHZ        0x80000000  // 32KHz Input Clock Available.
+#define SYSCTL_DC3_CCP3         0x08000000  // CCP3 Pin Present.
+#define SYSCTL_DC3_CCP2         0x04000000  // CCP2 Pin Present.
+#define SYSCTL_DC3_CCP1         0x02000000  // CCP1 Pin Present.
+#define SYSCTL_DC3_CCP0         0x01000000  // CCP0 Pin Present.
+#define SYSCTL_DC3_ADC3         0x00080000  // ADC3 Pin Present.
+#define SYSCTL_DC3_ADC2         0x00040000  // ADC2 Pin Present.
+#define SYSCTL_DC3_ADC1         0x00020000  // ADC1 Pin Present.
+#define SYSCTL_DC3_ADC0         0x00010000  // ADC0 Pin Present.
+#define SYSCTL_DC3_PWMFAULT     0x00008000  // PWM Fault Pin Present.
+#define SYSCTL_DC3_C1PLUS       0x00000400  // C1+ Pin Present.
+#define SYSCTL_DC3_C1MINUS      0x00000200  // C1- Pin Present.
+#define SYSCTL_DC3_C0O          0x00000100  // C0o Pin Present.
+#define SYSCTL_DC3_C0PLUS       0x00000080  // C0+ Pin Present.
+#define SYSCTL_DC3_C0MINUS      0x00000040  // C0- Pin Present.
+#define SYSCTL_DC3_PWM5         0x00000020  // PWM5 Pin Present.
+#define SYSCTL_DC3_PWM4         0x00000010  // PWM4 Pin Present.
+#define SYSCTL_DC3_PWM3         0x00000008  // PWM3 Pin Present.
+#define SYSCTL_DC3_PWM2         0x00000004  // PWM2 Pin Present.
+#define SYSCTL_DC3_PWM1         0x00000002  // PWM1 Pin Present.
+#define SYSCTL_DC3_PWM0         0x00000001  // PWM0 Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC4 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC4_EPHY0        0x40000000  // Ethernet PHY0 Present.
+#define SYSCTL_DC4_EMAC0        0x10000000  // Ethernet MAC0 Present.
+#define SYSCTL_DC4_GPIOG        0x00000040  // GPIO Port G Present.
+#define SYSCTL_DC4_GPIOF        0x00000020  // GPIO Port F Present.
+#define SYSCTL_DC4_GPIOE        0x00000010  // GPIO Port E Present.
+#define SYSCTL_DC4_GPIOD        0x00000008  // GPIO Port D Present.
+#define SYSCTL_DC4_GPIOC        0x00000004  // GPIO Port C Present.
+#define SYSCTL_DC4_GPIOB        0x00000002  // GPIO Port B Present.
+#define SYSCTL_DC4_GPIOA        0x00000001  // GPIO Port A Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PBORCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_PBORCTL_BORIOR   0x00000002  // BOR Interrupt or Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LDOPCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOPCTL_M        0x0000003F  // LDO Output Voltage.
+#define SYSCTL_LDOPCTL_2_50V    0x00000000  // 2.50
+#define SYSCTL_LDOPCTL_2_45V    0x00000001  // 2.45
+#define SYSCTL_LDOPCTL_2_40V    0x00000002  // 2.40
+#define SYSCTL_LDOPCTL_2_35V    0x00000003  // 2.35
+#define SYSCTL_LDOPCTL_2_30V    0x00000004  // 2.30
+#define SYSCTL_LDOPCTL_2_25V    0x00000005  // 2.25
+#define SYSCTL_LDOPCTL_2_75V    0x0000001B  // 2.75
+#define SYSCTL_LDOPCTL_2_70V    0x0000001C  // 2.70
+#define SYSCTL_LDOPCTL_2_65V    0x0000001D  // 2.65
+#define SYSCTL_LDOPCTL_2_60V    0x0000001E  // 2.60
+#define SYSCTL_LDOPCTL_2_55V    0x0000001F  // 2.55
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR0_PWM        0x00100000  // PWM Reset Control.
+#define SYSCTL_SRCR0_ADC        0x00010000  // ADC0 Reset Control.
+#define SYSCTL_SRCR0_HIB        0x00000040  // HIB Reset Control.
+#define SYSCTL_SRCR0_WDT        0x00000008  // WDT Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR1_COMP1      0x02000000  // Analog Comp 1 Reset Control.
+#define SYSCTL_SRCR1_COMP0      0x01000000  // Analog Comp 0 Reset Control.
+#define SYSCTL_SRCR1_TIMER3     0x00080000  // Timer 3 Reset Control.
+#define SYSCTL_SRCR1_TIMER2     0x00040000  // Timer 2 Reset Control.
+#define SYSCTL_SRCR1_TIMER1     0x00020000  // Timer 1 Reset Control.
+#define SYSCTL_SRCR1_TIMER0     0x00010000  // Timer 0 Reset Control.
+#define SYSCTL_SRCR1_I2C1       0x00004000  // I2C1 Reset Control.
+#define SYSCTL_SRCR1_I2C0       0x00001000  // I2C0 Reset Control.
+#define SYSCTL_SRCR1_QEI1       0x00000200  // QEI1 Reset Control.
+#define SYSCTL_SRCR1_QEI0       0x00000100  // QEI0 Reset Control.
+#define SYSCTL_SRCR1_SSI0       0x00000010  // SSI0 Reset Control.
+#define SYSCTL_SRCR1_UART2      0x00000004  // UART2 Reset Control.
+#define SYSCTL_SRCR1_UART1      0x00000002  // UART1 Reset Control.
+#define SYSCTL_SRCR1_UART0      0x00000001  // UART0 Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR2_EPHY0      0x40000000  // PHY0 Reset Control.
+#define SYSCTL_SRCR2_EMAC0      0x10000000  // MAC0 Reset Control.
+#define SYSCTL_SRCR2_GPIOG      0x00000040  // Port G Reset Control.
+#define SYSCTL_SRCR2_GPIOF      0x00000020  // Port F Reset Control.
+#define SYSCTL_SRCR2_GPIOE      0x00000010  // Port E Reset Control.
+#define SYSCTL_SRCR2_GPIOD      0x00000008  // Port D Reset Control.
+#define SYSCTL_SRCR2_GPIOC      0x00000004  // Port C Reset Control.
+#define SYSCTL_SRCR2_GPIOB      0x00000002  // Port B Reset Control.
+#define SYSCTL_SRCR2_GPIOA      0x00000001  // Port A Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RIS register.
+//
+//*****************************************************************************
+#define SYSCTL_RIS_PLLLRIS      0x00000040  // PLL Lock Raw Interrupt Status.
+#define SYSCTL_RIS_BORRIS       0x00000002  // Brown-Out Reset Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_IMC register.
+//
+//*****************************************************************************
+#define SYSCTL_IMC_PLLLIM       0x00000040  // PLL Lock Interrupt Mask.
+#define SYSCTL_IMC_BORIM        0x00000002  // Brown-Out Reset Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MISC register.
+//
+//*****************************************************************************
+#define SYSCTL_MISC_PLLLMIS     0x00000040  // PLL Lock Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_BORMIS      0x00000002  // BOR Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RESC register.
+//
+//*****************************************************************************
+#define SYSCTL_RESC_LDO         0x00000020  // LDO Reset.
+#define SYSCTL_RESC_SW          0x00000010  // Software Reset.
+#define SYSCTL_RESC_WDT         0x00000008  // Watchdog Timer Reset.
+#define SYSCTL_RESC_BOR         0x00000004  // Brown-Out Reset.
+#define SYSCTL_RESC_POR         0x00000002  // Power-On Reset.
+#define SYSCTL_RESC_EXT         0x00000001  // External Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC_ACG          0x08000000  // Auto Clock Gating.
+#define SYSCTL_RCC_SYSDIV_M     0x07800000  // System Clock Divisor.
+#define SYSCTL_RCC_SYSDIV_2     0x00800000  // /2
+#define SYSCTL_RCC_SYSDIV_3     0x01000000  // /3
+#define SYSCTL_RCC_SYSDIV_4     0x01800000  // /4
+#define SYSCTL_RCC_SYSDIV_5     0x02000000  // /5
+#define SYSCTL_RCC_SYSDIV_6     0x02800000  // /6
+#define SYSCTL_RCC_SYSDIV_7     0x03000000  // /7
+#define SYSCTL_RCC_SYSDIV_8     0x03800000  // /8
+#define SYSCTL_RCC_SYSDIV_9     0x04000000  // /9
+#define SYSCTL_RCC_SYSDIV_10    0x04800000  // /10
+#define SYSCTL_RCC_SYSDIV_11    0x05000000  // /11
+#define SYSCTL_RCC_SYSDIV_12    0x05800000  // /12
+#define SYSCTL_RCC_SYSDIV_13    0x06000000  // /13
+#define SYSCTL_RCC_SYSDIV_14    0x06800000  // /14
+#define SYSCTL_RCC_SYSDIV_15    0x07000000  // /15
+#define SYSCTL_RCC_SYSDIV_16    0x07800000  // /16
+#define SYSCTL_RCC_USESYSDIV    0x00400000  // Enable System Clock Divider.
+#define SYSCTL_RCC_USEPWMDIV    0x00100000  // Enable PWM Clock Divisor.
+#define SYSCTL_RCC_PWMDIV_M     0x000E0000  // PWM Unit Clock Divisor.
+#define SYSCTL_RCC_PWMDIV_2     0x00000000  // /2
+#define SYSCTL_RCC_PWMDIV_4     0x00020000  // /4
+#define SYSCTL_RCC_PWMDIV_8     0x00040000  // /8
+#define SYSCTL_RCC_PWMDIV_16    0x00060000  // /16
+#define SYSCTL_RCC_PWMDIV_32    0x00080000  // /32
+#define SYSCTL_RCC_PWMDIV_64    0x000A0000  // /64
+#define SYSCTL_RCC_PWRDN        0x00002000  // PLL Power Down.
+#define SYSCTL_RCC_BYPASS       0x00000800  // PLL Bypass.
+#define SYSCTL_RCC_XTAL_M       0x000003C0  // Crystal Value.
+#define SYSCTL_RCC_XTAL_1MHZ    0x00000000  // 1.000
+#define SYSCTL_RCC_XTAL_1_84MHZ 0x00000040  // 1.8432
+#define SYSCTL_RCC_XTAL_2MHZ    0x00000080  // 2.000
+#define SYSCTL_RCC_XTAL_2_45MHZ 0x000000C0  // 2.4576
+#define SYSCTL_RCC_XTAL_3_57MHZ 0x00000100  // 3.579545 MHz
+#define SYSCTL_RCC_XTAL_3_68MHZ 0x00000140  // 3.6864 MHz
+#define SYSCTL_RCC_XTAL_4MHZ    0x00000180  // 4 MHz
+#define SYSCTL_RCC_XTAL_4_09MHZ 0x000001C0  // 4.096 MHz
+#define SYSCTL_RCC_XTAL_4_91MHZ 0x00000200  // 4.9152 MHz
+#define SYSCTL_RCC_XTAL_5MHZ    0x00000240  // 5 MHz
+#define SYSCTL_RCC_XTAL_5_12MHZ 0x00000280  // 5.12 MHz
+#define SYSCTL_RCC_XTAL_6MHZ    0x000002C0  // 6 MHz (reset value)
+#define SYSCTL_RCC_XTAL_6_14MHZ 0x00000300  // 6.144 MHz
+#define SYSCTL_RCC_XTAL_7_37MHZ 0x00000340  // 7.3728 MHz
+#define SYSCTL_RCC_XTAL_8MHZ    0x00000380  // 8 MHz
+#define SYSCTL_RCC_XTAL_8_19MHZ 0x000003C0  // 8.192 MHz
+#define SYSCTL_RCC_OSCSRC_M     0x00000030  // Oscillator Source.
+#define SYSCTL_RCC_OSCSRC_MAIN  0x00000000  // MOSC
+#define SYSCTL_RCC_OSCSRC_INT   0x00000010  // IOSC
+#define SYSCTL_RCC_OSCSRC_INT4  0x00000020  // IOSC/4
+#define SYSCTL_RCC_OSCSRC_30    0x00000030  // 30 kHz
+#define SYSCTL_RCC_IOSCDIS      0x00000002  // Internal Oscillator Disable.
+#define SYSCTL_RCC_MOSCDIS      0x00000001  // Main Oscillator Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLCFG register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLCFG_F_M       0x00003FE0  // PLL F Value.
+#define SYSCTL_PLLCFG_R_M       0x0000001F  // PLL R Value.
+#define SYSCTL_PLLCFG_F_S       5
+#define SYSCTL_PLLCFG_R_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC2_USERCC2     0x80000000  // Use RCC2.
+#define SYSCTL_RCC2_SYSDIV2_M   0x1F800000  // System Clock Divisor.
+#define SYSCTL_RCC2_SYSDIV2_2   0x00800000  // System clock /2
+#define SYSCTL_RCC2_SYSDIV2_3   0x01000000  // System clock /3
+#define SYSCTL_RCC2_SYSDIV2_4   0x01800000  // System clock /4
+#define SYSCTL_RCC2_SYSDIV2_5   0x02000000  // System clock /5
+#define SYSCTL_RCC2_SYSDIV2_6   0x02800000  // System clock /6
+#define SYSCTL_RCC2_SYSDIV2_7   0x03000000  // System clock /7
+#define SYSCTL_RCC2_SYSDIV2_8   0x03800000  // System clock /8
+#define SYSCTL_RCC2_SYSDIV2_9   0x04000000  // System clock /9
+#define SYSCTL_RCC2_SYSDIV2_10  0x04800000  // System clock /10
+#define SYSCTL_RCC2_SYSDIV2_11  0x05000000  // System clock /11
+#define SYSCTL_RCC2_SYSDIV2_12  0x05800000  // System clock /12
+#define SYSCTL_RCC2_SYSDIV2_13  0x06000000  // System clock /13
+#define SYSCTL_RCC2_SYSDIV2_14  0x06800000  // System clock /14
+#define SYSCTL_RCC2_SYSDIV2_15  0x07000000  // System clock /15
+#define SYSCTL_RCC2_SYSDIV2_16  0x07800000  // System clock /16
+#define SYSCTL_RCC2_SYSDIV2_17  0x08000000  // System clock /17
+#define SYSCTL_RCC2_SYSDIV2_18  0x08800000  // System clock /18
+#define SYSCTL_RCC2_SYSDIV2_19  0x09000000  // System clock /19
+#define SYSCTL_RCC2_SYSDIV2_20  0x09800000  // System clock /20
+#define SYSCTL_RCC2_SYSDIV2_21  0x0A000000  // System clock /21
+#define SYSCTL_RCC2_SYSDIV2_22  0x0A800000  // System clock /22
+#define SYSCTL_RCC2_SYSDIV2_23  0x0B000000  // System clock /23
+#define SYSCTL_RCC2_SYSDIV2_24  0x0B800000  // System clock /24
+#define SYSCTL_RCC2_SYSDIV2_25  0x0C000000  // System clock /25
+#define SYSCTL_RCC2_SYSDIV2_26  0x0C800000  // System clock /26
+#define SYSCTL_RCC2_SYSDIV2_27  0x0D000000  // System clock /27
+#define SYSCTL_RCC2_SYSDIV2_28  0x0D800000  // System clock /28
+#define SYSCTL_RCC2_SYSDIV2_29  0x0E000000  // System clock /29
+#define SYSCTL_RCC2_SYSDIV2_30  0x0E800000  // System clock /30
+#define SYSCTL_RCC2_SYSDIV2_31  0x0F000000  // System clock /31
+#define SYSCTL_RCC2_SYSDIV2_32  0x0F800000  // System clock /32
+#define SYSCTL_RCC2_SYSDIV2_33  0x10000000  // System clock /33
+#define SYSCTL_RCC2_SYSDIV2_34  0x10800000  // System clock /34
+#define SYSCTL_RCC2_SYSDIV2_35  0x11000000  // System clock /35
+#define SYSCTL_RCC2_SYSDIV2_36  0x11800000  // System clock /36
+#define SYSCTL_RCC2_SYSDIV2_37  0x12000000  // System clock /37
+#define SYSCTL_RCC2_SYSDIV2_38  0x12800000  // System clock /38
+#define SYSCTL_RCC2_SYSDIV2_39  0x13000000  // System clock /39
+#define SYSCTL_RCC2_SYSDIV2_40  0x13800000  // System clock /40
+#define SYSCTL_RCC2_SYSDIV2_41  0x14000000  // System clock /41
+#define SYSCTL_RCC2_SYSDIV2_42  0x14800000  // System clock /42
+#define SYSCTL_RCC2_SYSDIV2_43  0x15000000  // System clock /43
+#define SYSCTL_RCC2_SYSDIV2_44  0x15800000  // System clock /44
+#define SYSCTL_RCC2_SYSDIV2_45  0x16000000  // System clock /45
+#define SYSCTL_RCC2_SYSDIV2_46  0x16800000  // System clock /46
+#define SYSCTL_RCC2_SYSDIV2_47  0x17000000  // System clock /47
+#define SYSCTL_RCC2_SYSDIV2_48  0x17800000  // System clock /48
+#define SYSCTL_RCC2_SYSDIV2_49  0x18000000  // System clock /49
+#define SYSCTL_RCC2_SYSDIV2_50  0x18800000  // System clock /50
+#define SYSCTL_RCC2_SYSDIV2_51  0x19000000  // System clock /51
+#define SYSCTL_RCC2_SYSDIV2_52  0x19800000  // System clock /52
+#define SYSCTL_RCC2_SYSDIV2_53  0x1A000000  // System clock /53
+#define SYSCTL_RCC2_SYSDIV2_54  0x1A800000  // System clock /54
+#define SYSCTL_RCC2_SYSDIV2_55  0x1B000000  // System clock /55
+#define SYSCTL_RCC2_SYSDIV2_56  0x1B800000  // System clock /56
+#define SYSCTL_RCC2_SYSDIV2_57  0x1C000000  // System clock /57
+#define SYSCTL_RCC2_SYSDIV2_58  0x1C800000  // System clock /58
+#define SYSCTL_RCC2_SYSDIV2_59  0x1D000000  // System clock /59
+#define SYSCTL_RCC2_SYSDIV2_60  0x1D800000  // System clock /60
+#define SYSCTL_RCC2_SYSDIV2_61  0x1E000000  // System clock /61
+#define SYSCTL_RCC2_SYSDIV2_62  0x1E800000  // System clock /62
+#define SYSCTL_RCC2_SYSDIV2_63  0x1F000000  // System clock /63
+#define SYSCTL_RCC2_SYSDIV2_64  0x1F800000  // System clock /64
+#define SYSCTL_RCC2_PWRDN2      0x00002000  // Power-Down PLL.
+#define SYSCTL_RCC2_BYPASS2     0x00000800  // Bypass PLL.
+#define SYSCTL_RCC2_OSCSRC2_M   0x00000070  // Oscillator Source.
+#define SYSCTL_RCC2_OSCSRC2_MO  0x00000000  // MOSC
+#define SYSCTL_RCC2_OSCSRC2_IO  0x00000010  // IOSC
+#define SYSCTL_RCC2_OSCSRC2_IO4 0x00000020  // IOSC/4
+#define SYSCTL_RCC2_OSCSRC2_30  0x00000030  // 30 kHz
+#define SYSCTL_RCC2_OSCSRC2_32  0x00000070  // 32 kHz
+#define SYSCTL_RCC2_SYSDIV2_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_RCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_RCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_RCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_RCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_RCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_RCGC0_ADCSPD1M   0x00000300  // 1M samples/second
+#define SYSCTL_RCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_RCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_RCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_RCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_RCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_RCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_SCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_SCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_SCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_SCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_SCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_SCGC0_ADCSPD1M   0x00000300  // 1M samples/second
+#define SYSCTL_SCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_SCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_SCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_SCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_SCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_SCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_DCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_DCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_DCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_DCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_DCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_DCGC0_ADCSPD1M   0x00000300  // 1M samples/second
+#define SYSCTL_DCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_DCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_DCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_DCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_DCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_DCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSLPCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSLPCLKCFG_D_M   0x1F800000  // Divider Field Override.
+#define SYSCTL_DSLPCLKCFG_O_M   0x00000070  // Clock Source.
+#define SYSCTL_DSLPCLKCFG_O_IGN 0x00000000  // MOSC
+#define SYSCTL_DSLPCLKCFG_O_IO  0x00000010  // IOSC
+#define SYSCTL_DSLPCLKCFG_O_30  0x00000030  // 30 kHz
+#define SYSCTL_DSLPCLKCFG_O_32  0x00000070  // 32 kHz
+#define SYSCTL_DSLPCLKCFG_D_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_LINES_M   0x0000001F  // Number of interrupt lines (x32)
+#define NVIC_INT_TYPE_LINES_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CTRL_COUNT      0x00010000  // Count flag
+#define NVIC_ST_CTRL_CLK_SRC    0x00000004  // Clock Source
+#define NVIC_ST_CTRL_INTEN      0x00000002  // Interrupt enable
+#define NVIC_ST_CTRL_ENABLE     0x00000001  // Counter mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_RELOAD register.
+//
+//*****************************************************************************
+#define NVIC_ST_RELOAD_M        0x00FFFFFF  // Counter load value
+#define NVIC_ST_RELOAD_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CURRENT
+// register.
+//
+//*****************************************************************************
+#define NVIC_ST_CURRENT_M       0x00FFFFFF  // Counter current value
+#define NVIC_ST_CURRENT_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CAL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CAL_NOREF       0x80000000  // No reference clock
+#define NVIC_ST_CAL_SKEW        0x40000000  // Clock skew
+#define NVIC_ST_CAL_ONEMS_M     0x00FFFFFF  // 1ms reference value
+#define NVIC_ST_CAL_ONEMS_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN0 register.
+//
+//*****************************************************************************
+#define NVIC_EN0_INT31          0x80000000  // Interrupt 31 enable
+#define NVIC_EN0_INT30          0x40000000  // Interrupt 30 enable
+#define NVIC_EN0_INT29          0x20000000  // Interrupt 29 enable
+#define NVIC_EN0_INT28          0x10000000  // Interrupt 28 enable
+#define NVIC_EN0_INT27          0x08000000  // Interrupt 27 enable
+#define NVIC_EN0_INT26          0x04000000  // Interrupt 26 enable
+#define NVIC_EN0_INT25          0x02000000  // Interrupt 25 enable
+#define NVIC_EN0_INT24          0x01000000  // Interrupt 24 enable
+#define NVIC_EN0_INT23          0x00800000  // Interrupt 23 enable
+#define NVIC_EN0_INT22          0x00400000  // Interrupt 22 enable
+#define NVIC_EN0_INT21          0x00200000  // Interrupt 21 enable
+#define NVIC_EN0_INT20          0x00100000  // Interrupt 20 enable
+#define NVIC_EN0_INT19          0x00080000  // Interrupt 19 enable
+#define NVIC_EN0_INT18          0x00040000  // Interrupt 18 enable
+#define NVIC_EN0_INT17          0x00020000  // Interrupt 17 enable
+#define NVIC_EN0_INT16          0x00010000  // Interrupt 16 enable
+#define NVIC_EN0_INT15          0x00008000  // Interrupt 15 enable
+#define NVIC_EN0_INT14          0x00004000  // Interrupt 14 enable
+#define NVIC_EN0_INT13          0x00002000  // Interrupt 13 enable
+#define NVIC_EN0_INT12          0x00001000  // Interrupt 12 enable
+#define NVIC_EN0_INT11          0x00000800  // Interrupt 11 enable
+#define NVIC_EN0_INT10          0x00000400  // Interrupt 10 enable
+#define NVIC_EN0_INT9           0x00000200  // Interrupt 9 enable
+#define NVIC_EN0_INT8           0x00000100  // Interrupt 8 enable
+#define NVIC_EN0_INT7           0x00000080  // Interrupt 7 enable
+#define NVIC_EN0_INT6           0x00000040  // Interrupt 6 enable
+#define NVIC_EN0_INT5           0x00000020  // Interrupt 5 enable
+#define NVIC_EN0_INT4           0x00000010  // Interrupt 4 enable
+#define NVIC_EN0_INT3           0x00000008  // Interrupt 3 enable
+#define NVIC_EN0_INT2           0x00000004  // Interrupt 2 enable
+#define NVIC_EN0_INT1           0x00000002  // Interrupt 1 enable
+#define NVIC_EN0_INT0           0x00000001  // Interrupt 0 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN1 register.
+//
+//*****************************************************************************
+#define NVIC_EN1_INT59          0x08000000  // Interrupt 59 enable
+#define NVIC_EN1_INT58          0x04000000  // Interrupt 58 enable
+#define NVIC_EN1_INT57          0x02000000  // Interrupt 57 enable
+#define NVIC_EN1_INT56          0x01000000  // Interrupt 56 enable
+#define NVIC_EN1_INT55          0x00800000  // Interrupt 55 enable
+#define NVIC_EN1_INT54          0x00400000  // Interrupt 54 enable
+#define NVIC_EN1_INT53          0x00200000  // Interrupt 53 enable
+#define NVIC_EN1_INT52          0x00100000  // Interrupt 52 enable
+#define NVIC_EN1_INT51          0x00080000  // Interrupt 51 enable
+#define NVIC_EN1_INT50          0x00040000  // Interrupt 50 enable
+#define NVIC_EN1_INT49          0x00020000  // Interrupt 49 enable
+#define NVIC_EN1_INT48          0x00010000  // Interrupt 48 enable
+#define NVIC_EN1_INT47          0x00008000  // Interrupt 47 enable
+#define NVIC_EN1_INT46          0x00004000  // Interrupt 46 enable
+#define NVIC_EN1_INT45          0x00002000  // Interrupt 45 enable
+#define NVIC_EN1_INT44          0x00001000  // Interrupt 44 enable
+#define NVIC_EN1_INT43          0x00000800  // Interrupt 43 enable
+#define NVIC_EN1_INT42          0x00000400  // Interrupt 42 enable
+#define NVIC_EN1_INT41          0x00000200  // Interrupt 41 enable
+#define NVIC_EN1_INT40          0x00000100  // Interrupt 40 enable
+#define NVIC_EN1_INT39          0x00000080  // Interrupt 39 enable
+#define NVIC_EN1_INT38          0x00000040  // Interrupt 38 enable
+#define NVIC_EN1_INT37          0x00000020  // Interrupt 37 enable
+#define NVIC_EN1_INT36          0x00000010  // Interrupt 36 enable
+#define NVIC_EN1_INT35          0x00000008  // Interrupt 35 enable
+#define NVIC_EN1_INT34          0x00000004  // Interrupt 34 enable
+#define NVIC_EN1_INT33          0x00000002  // Interrupt 33 enable
+#define NVIC_EN1_INT32          0x00000001  // Interrupt 32 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS0 register.
+//
+//*****************************************************************************
+#define NVIC_DIS0_INT31         0x80000000  // Interrupt 31 disable
+#define NVIC_DIS0_INT30         0x40000000  // Interrupt 30 disable
+#define NVIC_DIS0_INT29         0x20000000  // Interrupt 29 disable
+#define NVIC_DIS0_INT28         0x10000000  // Interrupt 28 disable
+#define NVIC_DIS0_INT27         0x08000000  // Interrupt 27 disable
+#define NVIC_DIS0_INT26         0x04000000  // Interrupt 26 disable
+#define NVIC_DIS0_INT25         0x02000000  // Interrupt 25 disable
+#define NVIC_DIS0_INT24         0x01000000  // Interrupt 24 disable
+#define NVIC_DIS0_INT23         0x00800000  // Interrupt 23 disable
+#define NVIC_DIS0_INT22         0x00400000  // Interrupt 22 disable
+#define NVIC_DIS0_INT21         0x00200000  // Interrupt 21 disable
+#define NVIC_DIS0_INT20         0x00100000  // Interrupt 20 disable
+#define NVIC_DIS0_INT19         0x00080000  // Interrupt 19 disable
+#define NVIC_DIS0_INT18         0x00040000  // Interrupt 18 disable
+#define NVIC_DIS0_INT17         0x00020000  // Interrupt 17 disable
+#define NVIC_DIS0_INT16         0x00010000  // Interrupt 16 disable
+#define NVIC_DIS0_INT15         0x00008000  // Interrupt 15 disable
+#define NVIC_DIS0_INT14         0x00004000  // Interrupt 14 disable
+#define NVIC_DIS0_INT13         0x00002000  // Interrupt 13 disable
+#define NVIC_DIS0_INT12         0x00001000  // Interrupt 12 disable
+#define NVIC_DIS0_INT11         0x00000800  // Interrupt 11 disable
+#define NVIC_DIS0_INT10         0x00000400  // Interrupt 10 disable
+#define NVIC_DIS0_INT9          0x00000200  // Interrupt 9 disable
+#define NVIC_DIS0_INT8          0x00000100  // Interrupt 8 disable
+#define NVIC_DIS0_INT7          0x00000080  // Interrupt 7 disable
+#define NVIC_DIS0_INT6          0x00000040  // Interrupt 6 disable
+#define NVIC_DIS0_INT5          0x00000020  // Interrupt 5 disable
+#define NVIC_DIS0_INT4          0x00000010  // Interrupt 4 disable
+#define NVIC_DIS0_INT3          0x00000008  // Interrupt 3 disable
+#define NVIC_DIS0_INT2          0x00000004  // Interrupt 2 disable
+#define NVIC_DIS0_INT1          0x00000002  // Interrupt 1 disable
+#define NVIC_DIS0_INT0          0x00000001  // Interrupt 0 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS1 register.
+//
+//*****************************************************************************
+#define NVIC_DIS1_INT59         0x08000000  // Interrupt 59 disable
+#define NVIC_DIS1_INT58         0x04000000  // Interrupt 58 disable
+#define NVIC_DIS1_INT57         0x02000000  // Interrupt 57 disable
+#define NVIC_DIS1_INT56         0x01000000  // Interrupt 56 disable
+#define NVIC_DIS1_INT55         0x00800000  // Interrupt 55 disable
+#define NVIC_DIS1_INT54         0x00400000  // Interrupt 54 disable
+#define NVIC_DIS1_INT53         0x00200000  // Interrupt 53 disable
+#define NVIC_DIS1_INT52         0x00100000  // Interrupt 52 disable
+#define NVIC_DIS1_INT51         0x00080000  // Interrupt 51 disable
+#define NVIC_DIS1_INT50         0x00040000  // Interrupt 50 disable
+#define NVIC_DIS1_INT49         0x00020000  // Interrupt 49 disable
+#define NVIC_DIS1_INT48         0x00010000  // Interrupt 48 disable
+#define NVIC_DIS1_INT47         0x00008000  // Interrupt 47 disable
+#define NVIC_DIS1_INT46         0x00004000  // Interrupt 46 disable
+#define NVIC_DIS1_INT45         0x00002000  // Interrupt 45 disable
+#define NVIC_DIS1_INT44         0x00001000  // Interrupt 44 disable
+#define NVIC_DIS1_INT43         0x00000800  // Interrupt 43 disable
+#define NVIC_DIS1_INT42         0x00000400  // Interrupt 42 disable
+#define NVIC_DIS1_INT41         0x00000200  // Interrupt 41 disable
+#define NVIC_DIS1_INT40         0x00000100  // Interrupt 40 disable
+#define NVIC_DIS1_INT39         0x00000080  // Interrupt 39 disable
+#define NVIC_DIS1_INT38         0x00000040  // Interrupt 38 disable
+#define NVIC_DIS1_INT37         0x00000020  // Interrupt 37 disable
+#define NVIC_DIS1_INT36         0x00000010  // Interrupt 36 disable
+#define NVIC_DIS1_INT35         0x00000008  // Interrupt 35 disable
+#define NVIC_DIS1_INT34         0x00000004  // Interrupt 34 disable
+#define NVIC_DIS1_INT33         0x00000002  // Interrupt 33 disable
+#define NVIC_DIS1_INT32         0x00000001  // Interrupt 32 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND0 register.
+//
+//*****************************************************************************
+#define NVIC_PEND0_INT31        0x80000000  // Interrupt 31 pend
+#define NVIC_PEND0_INT30        0x40000000  // Interrupt 30 pend
+#define NVIC_PEND0_INT29        0x20000000  // Interrupt 29 pend
+#define NVIC_PEND0_INT28        0x10000000  // Interrupt 28 pend
+#define NVIC_PEND0_INT27        0x08000000  // Interrupt 27 pend
+#define NVIC_PEND0_INT26        0x04000000  // Interrupt 26 pend
+#define NVIC_PEND0_INT25        0x02000000  // Interrupt 25 pend
+#define NVIC_PEND0_INT24        0x01000000  // Interrupt 24 pend
+#define NVIC_PEND0_INT23        0x00800000  // Interrupt 23 pend
+#define NVIC_PEND0_INT22        0x00400000  // Interrupt 22 pend
+#define NVIC_PEND0_INT21        0x00200000  // Interrupt 21 pend
+#define NVIC_PEND0_INT20        0x00100000  // Interrupt 20 pend
+#define NVIC_PEND0_INT19        0x00080000  // Interrupt 19 pend
+#define NVIC_PEND0_INT18        0x00040000  // Interrupt 18 pend
+#define NVIC_PEND0_INT17        0x00020000  // Interrupt 17 pend
+#define NVIC_PEND0_INT16        0x00010000  // Interrupt 16 pend
+#define NVIC_PEND0_INT15        0x00008000  // Interrupt 15 pend
+#define NVIC_PEND0_INT14        0x00004000  // Interrupt 14 pend
+#define NVIC_PEND0_INT13        0x00002000  // Interrupt 13 pend
+#define NVIC_PEND0_INT12        0x00001000  // Interrupt 12 pend
+#define NVIC_PEND0_INT11        0x00000800  // Interrupt 11 pend
+#define NVIC_PEND0_INT10        0x00000400  // Interrupt 10 pend
+#define NVIC_PEND0_INT9         0x00000200  // Interrupt 9 pend
+#define NVIC_PEND0_INT8         0x00000100  // Interrupt 8 pend
+#define NVIC_PEND0_INT7         0x00000080  // Interrupt 7 pend
+#define NVIC_PEND0_INT6         0x00000040  // Interrupt 6 pend
+#define NVIC_PEND0_INT5         0x00000020  // Interrupt 5 pend
+#define NVIC_PEND0_INT4         0x00000010  // Interrupt 4 pend
+#define NVIC_PEND0_INT3         0x00000008  // Interrupt 3 pend
+#define NVIC_PEND0_INT2         0x00000004  // Interrupt 2 pend
+#define NVIC_PEND0_INT1         0x00000002  // Interrupt 1 pend
+#define NVIC_PEND0_INT0         0x00000001  // Interrupt 0 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND1 register.
+//
+//*****************************************************************************
+#define NVIC_PEND1_INT59        0x08000000  // Interrupt 59 pend
+#define NVIC_PEND1_INT58        0x04000000  // Interrupt 58 pend
+#define NVIC_PEND1_INT57        0x02000000  // Interrupt 57 pend
+#define NVIC_PEND1_INT56        0x01000000  // Interrupt 56 pend
+#define NVIC_PEND1_INT55        0x00800000  // Interrupt 55 pend
+#define NVIC_PEND1_INT54        0x00400000  // Interrupt 54 pend
+#define NVIC_PEND1_INT53        0x00200000  // Interrupt 53 pend
+#define NVIC_PEND1_INT52        0x00100000  // Interrupt 52 pend
+#define NVIC_PEND1_INT51        0x00080000  // Interrupt 51 pend
+#define NVIC_PEND1_INT50        0x00040000  // Interrupt 50 pend
+#define NVIC_PEND1_INT49        0x00020000  // Interrupt 49 pend
+#define NVIC_PEND1_INT48        0x00010000  // Interrupt 48 pend
+#define NVIC_PEND1_INT47        0x00008000  // Interrupt 47 pend
+#define NVIC_PEND1_INT46        0x00004000  // Interrupt 46 pend
+#define NVIC_PEND1_INT45        0x00002000  // Interrupt 45 pend
+#define NVIC_PEND1_INT44        0x00001000  // Interrupt 44 pend
+#define NVIC_PEND1_INT43        0x00000800  // Interrupt 43 pend
+#define NVIC_PEND1_INT42        0x00000400  // Interrupt 42 pend
+#define NVIC_PEND1_INT41        0x00000200  // Interrupt 41 pend
+#define NVIC_PEND1_INT40        0x00000100  // Interrupt 40 pend
+#define NVIC_PEND1_INT39        0x00000080  // Interrupt 39 pend
+#define NVIC_PEND1_INT38        0x00000040  // Interrupt 38 pend
+#define NVIC_PEND1_INT37        0x00000020  // Interrupt 37 pend
+#define NVIC_PEND1_INT36        0x00000010  // Interrupt 36 pend
+#define NVIC_PEND1_INT35        0x00000008  // Interrupt 35 pend
+#define NVIC_PEND1_INT34        0x00000004  // Interrupt 34 pend
+#define NVIC_PEND1_INT33        0x00000002  // Interrupt 33 pend
+#define NVIC_PEND1_INT32        0x00000001  // Interrupt 32 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND0 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND0_INT31      0x80000000  // Interrupt 31 unpend
+#define NVIC_UNPEND0_INT30      0x40000000  // Interrupt 30 unpend
+#define NVIC_UNPEND0_INT29      0x20000000  // Interrupt 29 unpend
+#define NVIC_UNPEND0_INT28      0x10000000  // Interrupt 28 unpend
+#define NVIC_UNPEND0_INT27      0x08000000  // Interrupt 27 unpend
+#define NVIC_UNPEND0_INT26      0x04000000  // Interrupt 26 unpend
+#define NVIC_UNPEND0_INT25      0x02000000  // Interrupt 25 unpend
+#define NVIC_UNPEND0_INT24      0x01000000  // Interrupt 24 unpend
+#define NVIC_UNPEND0_INT23      0x00800000  // Interrupt 23 unpend
+#define NVIC_UNPEND0_INT22      0x00400000  // Interrupt 22 unpend
+#define NVIC_UNPEND0_INT21      0x00200000  // Interrupt 21 unpend
+#define NVIC_UNPEND0_INT20      0x00100000  // Interrupt 20 unpend
+#define NVIC_UNPEND0_INT19      0x00080000  // Interrupt 19 unpend
+#define NVIC_UNPEND0_INT18      0x00040000  // Interrupt 18 unpend
+#define NVIC_UNPEND0_INT17      0x00020000  // Interrupt 17 unpend
+#define NVIC_UNPEND0_INT16      0x00010000  // Interrupt 16 unpend
+#define NVIC_UNPEND0_INT15      0x00008000  // Interrupt 15 unpend
+#define NVIC_UNPEND0_INT14      0x00004000  // Interrupt 14 unpend
+#define NVIC_UNPEND0_INT13      0x00002000  // Interrupt 13 unpend
+#define NVIC_UNPEND0_INT12      0x00001000  // Interrupt 12 unpend
+#define NVIC_UNPEND0_INT11      0x00000800  // Interrupt 11 unpend
+#define NVIC_UNPEND0_INT10      0x00000400  // Interrupt 10 unpend
+#define NVIC_UNPEND0_INT9       0x00000200  // Interrupt 9 unpend
+#define NVIC_UNPEND0_INT8       0x00000100  // Interrupt 8 unpend
+#define NVIC_UNPEND0_INT7       0x00000080  // Interrupt 7 unpend
+#define NVIC_UNPEND0_INT6       0x00000040  // Interrupt 6 unpend
+#define NVIC_UNPEND0_INT5       0x00000020  // Interrupt 5 unpend
+#define NVIC_UNPEND0_INT4       0x00000010  // Interrupt 4 unpend
+#define NVIC_UNPEND0_INT3       0x00000008  // Interrupt 3 unpend
+#define NVIC_UNPEND0_INT2       0x00000004  // Interrupt 2 unpend
+#define NVIC_UNPEND0_INT1       0x00000002  // Interrupt 1 unpend
+#define NVIC_UNPEND0_INT0       0x00000001  // Interrupt 0 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND1 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND1_INT59      0x08000000  // Interrupt 59 unpend
+#define NVIC_UNPEND1_INT58      0x04000000  // Interrupt 58 unpend
+#define NVIC_UNPEND1_INT57      0x02000000  // Interrupt 57 unpend
+#define NVIC_UNPEND1_INT56      0x01000000  // Interrupt 56 unpend
+#define NVIC_UNPEND1_INT55      0x00800000  // Interrupt 55 unpend
+#define NVIC_UNPEND1_INT54      0x00400000  // Interrupt 54 unpend
+#define NVIC_UNPEND1_INT53      0x00200000  // Interrupt 53 unpend
+#define NVIC_UNPEND1_INT52      0x00100000  // Interrupt 52 unpend
+#define NVIC_UNPEND1_INT51      0x00080000  // Interrupt 51 unpend
+#define NVIC_UNPEND1_INT50      0x00040000  // Interrupt 50 unpend
+#define NVIC_UNPEND1_INT49      0x00020000  // Interrupt 49 unpend
+#define NVIC_UNPEND1_INT48      0x00010000  // Interrupt 48 unpend
+#define NVIC_UNPEND1_INT47      0x00008000  // Interrupt 47 unpend
+#define NVIC_UNPEND1_INT46      0x00004000  // Interrupt 46 unpend
+#define NVIC_UNPEND1_INT45      0x00002000  // Interrupt 45 unpend
+#define NVIC_UNPEND1_INT44      0x00001000  // Interrupt 44 unpend
+#define NVIC_UNPEND1_INT43      0x00000800  // Interrupt 43 unpend
+#define NVIC_UNPEND1_INT42      0x00000400  // Interrupt 42 unpend
+#define NVIC_UNPEND1_INT41      0x00000200  // Interrupt 41 unpend
+#define NVIC_UNPEND1_INT40      0x00000100  // Interrupt 40 unpend
+#define NVIC_UNPEND1_INT39      0x00000080  // Interrupt 39 unpend
+#define NVIC_UNPEND1_INT38      0x00000040  // Interrupt 38 unpend
+#define NVIC_UNPEND1_INT37      0x00000020  // Interrupt 37 unpend
+#define NVIC_UNPEND1_INT36      0x00000010  // Interrupt 36 unpend
+#define NVIC_UNPEND1_INT35      0x00000008  // Interrupt 35 unpend
+#define NVIC_UNPEND1_INT34      0x00000004  // Interrupt 34 unpend
+#define NVIC_UNPEND1_INT33      0x00000002  // Interrupt 33 unpend
+#define NVIC_UNPEND1_INT32      0x00000001  // Interrupt 32 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE0 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE0_INT31      0x80000000  // Interrupt 31 active
+#define NVIC_ACTIVE0_INT30      0x40000000  // Interrupt 30 active
+#define NVIC_ACTIVE0_INT29      0x20000000  // Interrupt 29 active
+#define NVIC_ACTIVE0_INT28      0x10000000  // Interrupt 28 active
+#define NVIC_ACTIVE0_INT27      0x08000000  // Interrupt 27 active
+#define NVIC_ACTIVE0_INT26      0x04000000  // Interrupt 26 active
+#define NVIC_ACTIVE0_INT25      0x02000000  // Interrupt 25 active
+#define NVIC_ACTIVE0_INT24      0x01000000  // Interrupt 24 active
+#define NVIC_ACTIVE0_INT23      0x00800000  // Interrupt 23 active
+#define NVIC_ACTIVE0_INT22      0x00400000  // Interrupt 22 active
+#define NVIC_ACTIVE0_INT21      0x00200000  // Interrupt 21 active
+#define NVIC_ACTIVE0_INT20      0x00100000  // Interrupt 20 active
+#define NVIC_ACTIVE0_INT19      0x00080000  // Interrupt 19 active
+#define NVIC_ACTIVE0_INT18      0x00040000  // Interrupt 18 active
+#define NVIC_ACTIVE0_INT17      0x00020000  // Interrupt 17 active
+#define NVIC_ACTIVE0_INT16      0x00010000  // Interrupt 16 active
+#define NVIC_ACTIVE0_INT15      0x00008000  // Interrupt 15 active
+#define NVIC_ACTIVE0_INT14      0x00004000  // Interrupt 14 active
+#define NVIC_ACTIVE0_INT13      0x00002000  // Interrupt 13 active
+#define NVIC_ACTIVE0_INT12      0x00001000  // Interrupt 12 active
+#define NVIC_ACTIVE0_INT11      0x00000800  // Interrupt 11 active
+#define NVIC_ACTIVE0_INT10      0x00000400  // Interrupt 10 active
+#define NVIC_ACTIVE0_INT9       0x00000200  // Interrupt 9 active
+#define NVIC_ACTIVE0_INT8       0x00000100  // Interrupt 8 active
+#define NVIC_ACTIVE0_INT7       0x00000080  // Interrupt 7 active
+#define NVIC_ACTIVE0_INT6       0x00000040  // Interrupt 6 active
+#define NVIC_ACTIVE0_INT5       0x00000020  // Interrupt 5 active
+#define NVIC_ACTIVE0_INT4       0x00000010  // Interrupt 4 active
+#define NVIC_ACTIVE0_INT3       0x00000008  // Interrupt 3 active
+#define NVIC_ACTIVE0_INT2       0x00000004  // Interrupt 2 active
+#define NVIC_ACTIVE0_INT1       0x00000002  // Interrupt 1 active
+#define NVIC_ACTIVE0_INT0       0x00000001  // Interrupt 0 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE1 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE1_INT59      0x08000000  // Interrupt 59 active
+#define NVIC_ACTIVE1_INT58      0x04000000  // Interrupt 58 active
+#define NVIC_ACTIVE1_INT57      0x02000000  // Interrupt 57 active
+#define NVIC_ACTIVE1_INT56      0x01000000  // Interrupt 56 active
+#define NVIC_ACTIVE1_INT55      0x00800000  // Interrupt 55 active
+#define NVIC_ACTIVE1_INT54      0x00400000  // Interrupt 54 active
+#define NVIC_ACTIVE1_INT53      0x00200000  // Interrupt 53 active
+#define NVIC_ACTIVE1_INT52      0x00100000  // Interrupt 52 active
+#define NVIC_ACTIVE1_INT51      0x00080000  // Interrupt 51 active
+#define NVIC_ACTIVE1_INT50      0x00040000  // Interrupt 50 active
+#define NVIC_ACTIVE1_INT49      0x00020000  // Interrupt 49 active
+#define NVIC_ACTIVE1_INT48      0x00010000  // Interrupt 48 active
+#define NVIC_ACTIVE1_INT47      0x00008000  // Interrupt 47 active
+#define NVIC_ACTIVE1_INT46      0x00004000  // Interrupt 46 active
+#define NVIC_ACTIVE1_INT45      0x00002000  // Interrupt 45 active
+#define NVIC_ACTIVE1_INT44      0x00001000  // Interrupt 44 active
+#define NVIC_ACTIVE1_INT43      0x00000800  // Interrupt 43 active
+#define NVIC_ACTIVE1_INT42      0x00000400  // Interrupt 42 active
+#define NVIC_ACTIVE1_INT41      0x00000200  // Interrupt 41 active
+#define NVIC_ACTIVE1_INT40      0x00000100  // Interrupt 40 active
+#define NVIC_ACTIVE1_INT39      0x00000080  // Interrupt 39 active
+#define NVIC_ACTIVE1_INT38      0x00000040  // Interrupt 38 active
+#define NVIC_ACTIVE1_INT37      0x00000020  // Interrupt 37 active
+#define NVIC_ACTIVE1_INT36      0x00000010  // Interrupt 36 active
+#define NVIC_ACTIVE1_INT35      0x00000008  // Interrupt 35 active
+#define NVIC_ACTIVE1_INT34      0x00000004  // Interrupt 34 active
+#define NVIC_ACTIVE1_INT33      0x00000002  // Interrupt 33 active
+#define NVIC_ACTIVE1_INT32      0x00000001  // Interrupt 32 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI0 register.
+//
+//*****************************************************************************
+#define NVIC_PRI0_INT3_M        0xFF000000  // Interrupt 3 priority mask
+#define NVIC_PRI0_INT2_M        0x00FF0000  // Interrupt 2 priority mask
+#define NVIC_PRI0_INT1_M        0x0000FF00  // Interrupt 1 priority mask
+#define NVIC_PRI0_INT0_M        0x000000FF  // Interrupt 0 priority mask
+#define NVIC_PRI0_INT3_S        24
+#define NVIC_PRI0_INT2_S        16
+#define NVIC_PRI0_INT1_S        8
+#define NVIC_PRI0_INT0_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_PRI1_INT7_M        0xFF000000  // Interrupt 7 priority mask
+#define NVIC_PRI1_INT6_M        0x00FF0000  // Interrupt 6 priority mask
+#define NVIC_PRI1_INT5_M        0x0000FF00  // Interrupt 5 priority mask
+#define NVIC_PRI1_INT4_M        0x000000FF  // Interrupt 4 priority mask
+#define NVIC_PRI1_INT7_S        24
+#define NVIC_PRI1_INT6_S        16
+#define NVIC_PRI1_INT5_S        8
+#define NVIC_PRI1_INT4_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_PRI2_INT11_M       0xFF000000  // Interrupt 11 priority mask
+#define NVIC_PRI2_INT10_M       0x00FF0000  // Interrupt 10 priority mask
+#define NVIC_PRI2_INT9_M        0x0000FF00  // Interrupt 9 priority mask
+#define NVIC_PRI2_INT8_M        0x000000FF  // Interrupt 8 priority mask
+#define NVIC_PRI2_INT11_S       24
+#define NVIC_PRI2_INT10_S       16
+#define NVIC_PRI2_INT9_S        8
+#define NVIC_PRI2_INT8_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_PRI3_INT15_M       0xFF000000  // Interrupt 15 priority mask
+#define NVIC_PRI3_INT14_M       0x00FF0000  // Interrupt 14 priority mask
+#define NVIC_PRI3_INT13_M       0x0000FF00  // Interrupt 13 priority mask
+#define NVIC_PRI3_INT12_M       0x000000FF  // Interrupt 12 priority mask
+#define NVIC_PRI3_INT15_S       24
+#define NVIC_PRI3_INT14_S       16
+#define NVIC_PRI3_INT13_S       8
+#define NVIC_PRI3_INT12_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI4 register.
+//
+//*****************************************************************************
+#define NVIC_PRI4_INT19_M       0xFF000000  // Interrupt 19 priority mask
+#define NVIC_PRI4_INT18_M       0x00FF0000  // Interrupt 18 priority mask
+#define NVIC_PRI4_INT17_M       0x0000FF00  // Interrupt 17 priority mask
+#define NVIC_PRI4_INT16_M       0x000000FF  // Interrupt 16 priority mask
+#define NVIC_PRI4_INT19_S       24
+#define NVIC_PRI4_INT18_S       16
+#define NVIC_PRI4_INT17_S       8
+#define NVIC_PRI4_INT16_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI5 register.
+//
+//*****************************************************************************
+#define NVIC_PRI5_INT23_M       0xFF000000  // Interrupt 23 priority mask
+#define NVIC_PRI5_INT22_M       0x00FF0000  // Interrupt 22 priority mask
+#define NVIC_PRI5_INT21_M       0x0000FF00  // Interrupt 21 priority mask
+#define NVIC_PRI5_INT20_M       0x000000FF  // Interrupt 20 priority mask
+#define NVIC_PRI5_INT23_S       24
+#define NVIC_PRI5_INT22_S       16
+#define NVIC_PRI5_INT21_S       8
+#define NVIC_PRI5_INT20_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI6 register.
+//
+//*****************************************************************************
+#define NVIC_PRI6_INT27_M       0xFF000000  // Interrupt 27 priority mask
+#define NVIC_PRI6_INT26_M       0x00FF0000  // Interrupt 26 priority mask
+#define NVIC_PRI6_INT25_M       0x0000FF00  // Interrupt 25 priority mask
+#define NVIC_PRI6_INT24_M       0x000000FF  // Interrupt 24 priority mask
+#define NVIC_PRI6_INT27_S       24
+#define NVIC_PRI6_INT26_S       16
+#define NVIC_PRI6_INT25_S       8
+#define NVIC_PRI6_INT24_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI7 register.
+//
+//*****************************************************************************
+#define NVIC_PRI7_INT31_M       0xFF000000  // Interrupt 31 priority mask
+#define NVIC_PRI7_INT30_M       0x00FF0000  // Interrupt 30 priority mask
+#define NVIC_PRI7_INT29_M       0x0000FF00  // Interrupt 29 priority mask
+#define NVIC_PRI7_INT28_M       0x000000FF  // Interrupt 28 priority mask
+#define NVIC_PRI7_INT31_S       24
+#define NVIC_PRI7_INT30_S       16
+#define NVIC_PRI7_INT29_S       8
+#define NVIC_PRI7_INT28_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI8 register.
+//
+//*****************************************************************************
+#define NVIC_PRI8_INT35_M       0xFF000000  // Interrupt 35 priority mask
+#define NVIC_PRI8_INT34_M       0x00FF0000  // Interrupt 34 priority mask
+#define NVIC_PRI8_INT33_M       0x0000FF00  // Interrupt 33 priority mask
+#define NVIC_PRI8_INT32_M       0x000000FF  // Interrupt 32 priority mask
+#define NVIC_PRI8_INT35_S       24
+#define NVIC_PRI8_INT34_S       16
+#define NVIC_PRI8_INT33_S       8
+#define NVIC_PRI8_INT32_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI9 register.
+//
+//*****************************************************************************
+#define NVIC_PRI9_INT39_M       0xFF000000  // Interrupt 39 priority mask
+#define NVIC_PRI9_INT38_M       0x00FF0000  // Interrupt 38 priority mask
+#define NVIC_PRI9_INT37_M       0x0000FF00  // Interrupt 37 priority mask
+#define NVIC_PRI9_INT36_M       0x000000FF  // Interrupt 36 priority mask
+#define NVIC_PRI9_INT39_S       24
+#define NVIC_PRI9_INT38_S       16
+#define NVIC_PRI9_INT37_S       8
+#define NVIC_PRI9_INT36_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI10 register.
+//
+//*****************************************************************************
+#define NVIC_PRI10_INT43_M      0xFF000000  // Interrupt 43 priority mask
+#define NVIC_PRI10_INT42_M      0x00FF0000  // Interrupt 42 priority mask
+#define NVIC_PRI10_INT41_M      0x0000FF00  // Interrupt 41 priority mask
+#define NVIC_PRI10_INT40_M      0x000000FF  // Interrupt 40 priority mask
+#define NVIC_PRI10_INT43_S      24
+#define NVIC_PRI10_INT42_S      16
+#define NVIC_PRI10_INT41_S      8
+#define NVIC_PRI10_INT40_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CPUID register.
+//
+//*****************************************************************************
+#define NVIC_CPUID_IMP_M        0xFF000000  // Implementer
+#define NVIC_CPUID_VAR_M        0x00F00000  // Variant
+#define NVIC_CPUID_PARTNO_M     0x0000FFF0  // Processor part number
+#define NVIC_CPUID_REV_M        0x0000000F  // Revision
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_INT_CTRL_NMI_SET   0x80000000  // Pend a NMI
+#define NVIC_INT_CTRL_PEND_SV   0x10000000  // Pend a PendSV
+#define NVIC_INT_CTRL_UNPEND_SV 0x08000000  // Unpend a PendSV
+#define NVIC_INT_CTRL_ISR_PRE   0x00800000  // Debug interrupt handling
+#define NVIC_INT_CTRL_ISR_PEND  0x00400000  // Debug interrupt pending
+#define NVIC_INT_CTRL_VEC_PEN_M 0x003FF000  // Highest pending exception
+#define NVIC_INT_CTRL_RET_BASE  0x00000800  // Return to base
+#define NVIC_INT_CTRL_VEC_ACT_M 0x000003FF  // Current active exception
+#define NVIC_INT_CTRL_VEC_PEN_S 12
+#define NVIC_INT_CTRL_VEC_ACT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_VTABLE register.
+//
+//*****************************************************************************
+#define NVIC_VTABLE_BASE        0x20000000  // Vector table base
+#define NVIC_VTABLE_OFFSET_M    0x1FFFFF00  // Vector table offset
+#define NVIC_VTABLE_OFFSET_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_APINT register.
+//
+//*****************************************************************************
+#define NVIC_APINT_VECTKEY_M    0xFFFF0000  // Vector key mask
+#define NVIC_APINT_VECTKEY      0x05FA0000  // Vector key
+#define NVIC_APINT_ENDIANESS    0x00008000  // Data endianess
+#define NVIC_APINT_PRIGROUP_M   0x00000700  // Priority group
+#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
+#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
+#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
+#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
+#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
+#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
+#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
+#define NVIC_APINT_SYSRESETREQ  0x00000004  // System reset request
+#define NVIC_APINT_VECT_CLR_ACT 0x00000002  // Clear active NMI/fault info
+#define NVIC_APINT_VECT_RESET   0x00000001  // System reset
+#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_SYS_CTRL_SEVONPEND 0x00000010  // Wakeup on pend
+#define NVIC_SYS_CTRL_SLEEPDEEP 0x00000004  // Deep sleep enable
+#define NVIC_SYS_CTRL_SLEEPEXIT 0x00000002  // Sleep on ISR exit
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CFG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_CFG_CTRL_BFHFNMIGN 0x00000100  // Ignore bus fault in NMI/fault
+#define NVIC_CFG_CTRL_DIV0      0x00000010  // Trap on divide by 0
+#define NVIC_CFG_CTRL_UNALIGNED 0x00000008  // Trap on unaligned access
+#define NVIC_CFG_CTRL_DEEP_PEND 0x00000004  // Allow deep interrupt trigger
+#define NVIC_CFG_CTRL_MAIN_PEND 0x00000002  // Allow main interrupt trigger
+#define NVIC_CFG_CTRL_BASE_THR  0x00000001  // Thread state control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI1_RES_M     0xFF000000  // Priority of reserved handler
+#define NVIC_SYS_PRI1_USAGE_M   0x00FF0000  // Priority of usage fault handler
+#define NVIC_SYS_PRI1_BUS_M     0x0000FF00  // Priority of bus fault handler
+#define NVIC_SYS_PRI1_MEM_M     0x000000FF  // Priority of mem manage handler
+#define NVIC_SYS_PRI1_USAGE_S   16
+#define NVIC_SYS_PRI1_BUS_S     8
+#define NVIC_SYS_PRI1_MEM_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI2_SVC_M     0xFF000000  // Priority of SVCall handler
+#define NVIC_SYS_PRI2_RES_M     0x00FFFFFF  // Priority of reserved handlers
+#define NVIC_SYS_PRI2_SVC_S     24
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI3_TICK_M    0xFF000000  // Priority of Sys Tick handler
+#define NVIC_SYS_PRI3_PENDSV_M  0x00FF0000  // Priority of PendSV handler
+#define NVIC_SYS_PRI3_RES_M     0x0000FF00  // Priority of reserved handler
+#define NVIC_SYS_PRI3_DEBUG_M   0x000000FF  // Priority of debug handler
+#define NVIC_SYS_PRI3_TICK_S    24
+#define NVIC_SYS_PRI3_PENDSV_S  16
+#define NVIC_SYS_PRI3_DEBUG_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_HND_CTRL
+// register.
+//
+//*****************************************************************************
+#define NVIC_SYS_HND_CTRL_USAGE 0x00040000  // Usage fault enable
+#define NVIC_SYS_HND_CTRL_BUS   0x00020000  // Bus fault enable
+#define NVIC_SYS_HND_CTRL_MEM   0x00010000  // Mem manage fault enable
+#define NVIC_SYS_HND_CTRL_SVC   0x00008000  // SVCall is pended
+#define NVIC_SYS_HND_CTRL_BUSP  0x00004000  // Bus fault is pended
+#define NVIC_SYS_HND_CTRL_TICK  0x00000800  // Sys tick is active
+#define NVIC_SYS_HND_CTRL_PNDSV 0x00000400  // PendSV is active
+#define NVIC_SYS_HND_CTRL_MON   0x00000100  // Monitor is active
+#define NVIC_SYS_HND_CTRL_SVCA  0x00000080  // SVCall is active
+#define NVIC_SYS_HND_CTRL_USGA  0x00000008  // Usage fault is active
+#define NVIC_SYS_HND_CTRL_BUSA  0x00000002  // Bus fault is active
+#define NVIC_SYS_HND_CTRL_MEMA  0x00000001  // Mem manage is active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_STAT_DIV0    0x02000000  // Divide by zero fault
+#define NVIC_FAULT_STAT_UNALIGN 0x01000000  // Unaligned access fault
+#define NVIC_FAULT_STAT_NOCP    0x00080000  // No coprocessor fault
+#define NVIC_FAULT_STAT_INVPC   0x00040000  // Invalid PC fault
+#define NVIC_FAULT_STAT_INVSTAT 0x00020000  // Invalid state fault
+#define NVIC_FAULT_STAT_UNDEF   0x00010000  // Undefined instruction fault
+#define NVIC_FAULT_STAT_BFARV   0x00008000  // BFAR is valid
+#define NVIC_FAULT_STAT_BSTKE   0x00001000  // Stack bus fault
+#define NVIC_FAULT_STAT_BUSTKE  0x00000800  // Unstack bus fault
+#define NVIC_FAULT_STAT_IMPRE   0x00000400  // Imprecise data bus error
+#define NVIC_FAULT_STAT_PRECISE 0x00000200  // Precise data bus error
+#define NVIC_FAULT_STAT_IBUS    0x00000100  // Instruction bus fault
+#define NVIC_FAULT_STAT_MMARV   0x00000080  // MMAR is valid
+#define NVIC_FAULT_STAT_MSTKE   0x00000010  // Stack access violation
+#define NVIC_FAULT_STAT_MUSTKE  0x00000008  // Unstack access violation
+#define NVIC_FAULT_STAT_DERR    0x00000002  // Data access violation
+#define NVIC_FAULT_STAT_IERR    0x00000001  // Instruction access violation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_HFAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_HFAULT_STAT_DBG    0x80000000  // Debug event
+#define NVIC_HFAULT_STAT_FORCED 0x40000000  // Cannot execute fault handler
+#define NVIC_HFAULT_STAT_VECT   0x00000002  // Vector table read fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DEBUG_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_DEBUG_STAT_EXTRNL  0x00000010  // EDBGRQ asserted
+#define NVIC_DEBUG_STAT_VCATCH  0x00000008  // Vector catch
+#define NVIC_DEBUG_STAT_DWTTRAP 0x00000004  // DWT match
+#define NVIC_DEBUG_STAT_BKPT    0x00000002  // Breakpoint instruction
+#define NVIC_DEBUG_STAT_HALTED  0x00000001  // Halt request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MM_ADDR register.
+//
+//*****************************************************************************
+#define NVIC_MM_ADDR_M          0xFFFFFFFF  // Data fault address
+#define NVIC_MM_ADDR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_ADDR
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_ADDR_M       0xFFFFFFFF  // Data bus fault address
+#define NVIC_FAULT_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_TYPE_IREGION_M 0x00FF0000  // Number of I regions
+#define NVIC_MPU_TYPE_DREGION_M 0x0000FF00  // Number of D regions
+#define NVIC_MPU_TYPE_SEPARATE  0x00000001  // Separate or unified MPU
+#define NVIC_MPU_TYPE_IREGION_S 16
+#define NVIC_MPU_TYPE_DREGION_S 8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_MPU_CTRL_PRIVDEFEN 0x00000004  // MPU default region in priv mode
+#define NVIC_MPU_CTRL_HFNMIENA  0x00000002  // MPU enabled during faults
+#define NVIC_MPU_CTRL_ENABLE    0x00000001  // MPU enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_NUMBER
+// register.
+//
+//*****************************************************************************
+#define NVIC_MPU_NUMBER_M       0x000000FF  // MPU region to access
+#define NVIC_MPU_NUMBER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE_ADDR_M    0xFFFFFFE0  // Base address mask
+#define NVIC_MPU_BASE_VALID     0x00000010  // Region number valid
+#define NVIC_MPU_BASE_REGION_M  0x0000000F  // Region number
+#define NVIC_MPU_BASE_ADDR_S    8
+#define NVIC_MPU_BASE_REGION_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR_M         0xFFFF0000  // Attributes
+#define NVIC_MPU_ATTR_AP_NO_NO  0x00000000  // prv: no access, usr: no access
+#define NVIC_MPU_ATTR_BUFFRABLE 0x00010000  // Bufferable
+#define NVIC_MPU_ATTR_CACHEABLE 0x00020000  // Cacheable
+#define NVIC_MPU_ATTR_SHAREABLE 0x00040000  // Shareable
+#define NVIC_MPU_ATTR_TEX_M     0x00380000  // Type extension mask
+#define NVIC_MPU_ATTR_AP_RW_NO  0x01000000  // prv: rw, usr: none
+#define NVIC_MPU_ATTR_AP_RW_RO  0x02000000  // prv: rw, usr: read-only
+#define NVIC_MPU_ATTR_AP_RW_RW  0x03000000  // prv: rw, usr: rw
+#define NVIC_MPU_ATTR_AP_RO_NO  0x05000000  // prv: ro, usr: none
+#define NVIC_MPU_ATTR_AP_RO_RO  0x06000000  // prv: ro, usr: ro
+#define NVIC_MPU_ATTR_AP_M      0x07000000  // Access permissions mask
+#define NVIC_MPU_ATTR_XN        0x10000000  // Execute disable
+#define NVIC_MPU_ATTR_SRD_M     0x0000FF00  // Sub-region disable mask
+#define NVIC_MPU_ATTR_SRD_0     0x00000100  // Sub-region 0 disable
+#define NVIC_MPU_ATTR_SRD_1     0x00000200  // Sub-region 1 disable
+#define NVIC_MPU_ATTR_SRD_2     0x00000400  // Sub-region 2 disable
+#define NVIC_MPU_ATTR_SRD_3     0x00000800  // Sub-region 3 disable
+#define NVIC_MPU_ATTR_SRD_4     0x00001000  // Sub-region 4 disable
+#define NVIC_MPU_ATTR_SRD_5     0x00002000  // Sub-region 5 disable
+#define NVIC_MPU_ATTR_SRD_6     0x00004000  // Sub-region 6 disable
+#define NVIC_MPU_ATTR_SRD_7     0x00008000  // Sub-region 7 disable
+#define NVIC_MPU_ATTR_SIZE_M    0x0000003E  // Region size mask
+#define NVIC_MPU_ATTR_SIZE_32B  0x00000008  // Region size 32 bytes
+#define NVIC_MPU_ATTR_SIZE_64B  0x0000000A  // Region size 64 bytes
+#define NVIC_MPU_ATTR_SIZE_128B 0x0000000C  // Region size 128 bytes
+#define NVIC_MPU_ATTR_SIZE_256B 0x0000000E  // Region size 256 bytes
+#define NVIC_MPU_ATTR_SIZE_512B 0x00000010  // Region size 512 bytes
+#define NVIC_MPU_ATTR_SIZE_1K   0x00000012  // Region size 1 Kbytes
+#define NVIC_MPU_ATTR_SIZE_2K   0x00000014  // Region size 2 Kbytes
+#define NVIC_MPU_ATTR_SIZE_4K   0x00000016  // Region size 4 Kbytes
+#define NVIC_MPU_ATTR_SIZE_8K   0x00000018  // Region size 8 Kbytes
+#define NVIC_MPU_ATTR_SIZE_16K  0x0000001A  // Region size 16 Kbytes
+#define NVIC_MPU_ATTR_SIZE_32K  0x0000001C  // Region size 32 Kbytes
+#define NVIC_MPU_ATTR_SIZE_64K  0x0000001E  // Region size 64 Kbytes
+#define NVIC_MPU_ATTR_SIZE_128K 0x00000020  // Region size 128 Kbytes
+#define NVIC_MPU_ATTR_SIZE_256K 0x00000022  // Region size 256 Kbytes
+#define NVIC_MPU_ATTR_SIZE_512K 0x00000024  // Region size 512 Kbytes
+#define NVIC_MPU_ATTR_SIZE_1M   0x00000026  // Region size 1 Mbytes
+#define NVIC_MPU_ATTR_SIZE_2M   0x00000028  // Region size 2 Mbytes
+#define NVIC_MPU_ATTR_SIZE_4M   0x0000002A  // Region size 4 Mbytes
+#define NVIC_MPU_ATTR_SIZE_8M   0x0000002C  // Region size 8 Mbytes
+#define NVIC_MPU_ATTR_SIZE_16M  0x0000002E  // Region size 16 Mbytes
+#define NVIC_MPU_ATTR_SIZE_32M  0x00000030  // Region size 32 Mbytes
+#define NVIC_MPU_ATTR_SIZE_64M  0x00000032  // Region size 64 Mbytes
+#define NVIC_MPU_ATTR_SIZE_128M 0x00000034  // Region size 128 Mbytes
+#define NVIC_MPU_ATTR_SIZE_256M 0x00000036  // Region size 256 Mbytes
+#define NVIC_MPU_ATTR_SIZE_512M 0x00000038  // Region size 512 Mbytes
+#define NVIC_MPU_ATTR_SIZE_1G   0x0000003A  // Region size 1 Gbytes
+#define NVIC_MPU_ATTR_SIZE_2G   0x0000003C  // Region size 2 Gbytes
+#define NVIC_MPU_ATTR_SIZE_4G   0x0000003E  // Region size 4 Gbytes
+#define NVIC_MPU_ATTR_ENABLE    0x00000001  // Region enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_DBG_CTRL_DBGKEY_M  0xFFFF0000  // Debug key mask
+#define NVIC_DBG_CTRL_DBGKEY    0xA05F0000  // Debug key
+#define NVIC_DBG_CTRL_S_RESET_ST \
+                                0x02000000  // Core has reset since last read
+#define NVIC_DBG_CTRL_S_RETIRE_ST \
+                                0x01000000  // Core has executed insruction
+                                            // since last read
+#define NVIC_DBG_CTRL_S_LOCKUP  0x00080000  // Core is locked up
+#define NVIC_DBG_CTRL_S_SLEEP   0x00040000  // Core is sleeping
+#define NVIC_DBG_CTRL_S_HALT    0x00020000  // Core status on halt
+#define NVIC_DBG_CTRL_S_REGRDY  0x00010000  // Register read/write available
+#define NVIC_DBG_CTRL_C_SNAPSTALL \
+                                0x00000020  // Breaks a stalled load/store
+#define NVIC_DBG_CTRL_C_MASKINT 0x00000008  // Mask interrupts when stepping
+#define NVIC_DBG_CTRL_C_STEP    0x00000004  // Step the core
+#define NVIC_DBG_CTRL_C_HALT    0x00000002  // Halt the core
+#define NVIC_DBG_CTRL_C_DEBUGEN 0x00000001  // Enable debug
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_XFER register.
+//
+//*****************************************************************************
+#define NVIC_DBG_XFER_REG_WNR   0x00010000  // Write or not read
+#define NVIC_DBG_XFER_REG_SEL_M 0x0000001F  // Register
+#define NVIC_DBG_XFER_REG_CFBP  0x00000014  // Control/Fault/BasePri/PriMask
+#define NVIC_DBG_XFER_REG_DSP   0x00000013  // Deep SP
+#define NVIC_DBG_XFER_REG_PSP   0x00000012  // Process SP
+#define NVIC_DBG_XFER_REG_MSP   0x00000011  // Main SP
+#define NVIC_DBG_XFER_REG_FLAGS 0x00000010  // xPSR/Flags register
+#define NVIC_DBG_XFER_REG_R15   0x0000000F  // Register R15
+#define NVIC_DBG_XFER_REG_R14   0x0000000E  // Register R14
+#define NVIC_DBG_XFER_REG_R13   0x0000000D  // Register R13
+#define NVIC_DBG_XFER_REG_R12   0x0000000C  // Register R12
+#define NVIC_DBG_XFER_REG_R11   0x0000000B  // Register R11
+#define NVIC_DBG_XFER_REG_R10   0x0000000A  // Register R10
+#define NVIC_DBG_XFER_REG_R9    0x00000009  // Register R9
+#define NVIC_DBG_XFER_REG_R8    0x00000008  // Register R8
+#define NVIC_DBG_XFER_REG_R7    0x00000007  // Register R7
+#define NVIC_DBG_XFER_REG_R6    0x00000006  // Register R6
+#define NVIC_DBG_XFER_REG_R5    0x00000005  // Register R5
+#define NVIC_DBG_XFER_REG_R4    0x00000004  // Register R4
+#define NVIC_DBG_XFER_REG_R3    0x00000003  // Register R3
+#define NVIC_DBG_XFER_REG_R2    0x00000002  // Register R2
+#define NVIC_DBG_XFER_REG_R1    0x00000001  // Register R1
+#define NVIC_DBG_XFER_REG_R0    0x00000000  // Register R0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_DATA register.
+//
+//*****************************************************************************
+#define NVIC_DBG_DATA_M         0xFFFFFFFF  // Data temporary cache
+#define NVIC_DBG_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_INT register.
+//
+//*****************************************************************************
+#define NVIC_DBG_INT_HARDERR    0x00000400  // Debug trap on hard fault
+#define NVIC_DBG_INT_INTERR     0x00000200  // Debug trap on interrupt errors
+#define NVIC_DBG_INT_BUSERR     0x00000100  // Debug trap on bus error
+#define NVIC_DBG_INT_STATERR    0x00000080  // Debug trap on usage fault state
+#define NVIC_DBG_INT_CHKERR     0x00000040  // Debug trap on usage fault check
+#define NVIC_DBG_INT_NOCPERR    0x00000020  // Debug trap on coprocessor error
+#define NVIC_DBG_INT_MMERR      0x00000010  // Debug trap on mem manage fault
+#define NVIC_DBG_INT_RESET      0x00000008  // Core reset status
+#define NVIC_DBG_INT_RSTPENDCLR 0x00000004  // Clear pending core reset
+#define NVIC_DBG_INT_RSTPENDING 0x00000002  // Core reset is pending
+#define NVIC_DBG_INT_RSTVCATCH  0x00000001  // Reset vector catch
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SW_TRIG register.
+//
+//*****************************************************************************
+#define NVIC_SW_TRIG_INTID_M    0x000003FF  // Interrupt to trigger
+#define NVIC_SW_TRIG_INTID_S    0
+
+#endif // __LM3S6965_H__


Property changes on: trunk/src/platform/lm3s/lm3s6965.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/lm3s8962.h
===================================================================
--- trunk/src/platform/lm3s/lm3s8962.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/lm3s8962.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,4880 @@
+//*****************************************************************************
+//
+// lm3s8962.h - LM3S8962 Register Definitions
+//
+// Copyright (c) 2007-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __LM3S8962_H__
+#define __LM3S8962_H__
+
+//*****************************************************************************
+//
+// Watchdog Timer (WATCHDOG)
+//
+//*****************************************************************************
+#define WATCHDOG_LOAD_R         (*((volatile unsigned long *)0x40000000))
+#define WATCHDOG_VALUE_R        (*((volatile unsigned long *)0x40000004))
+#define WATCHDOG_CTL_R          (*((volatile unsigned long *)0x40000008))
+#define WATCHDOG_ICR_R          (*((volatile unsigned long *)0x4000000C))
+#define WATCHDOG_RIS_R          (*((volatile unsigned long *)0x40000010))
+#define WATCHDOG_MIS_R          (*((volatile unsigned long *)0x40000014))
+#define WATCHDOG_TEST_R         (*((volatile unsigned long *)0x40000418))
+#define WATCHDOG_LOCK_R         (*((volatile unsigned long *)0x40000C00))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTA)
+//
+//*****************************************************************************
+#define GPIO_PORTA_DATA_BITS_R  ((volatile unsigned long *)0x40004000)
+#define GPIO_PORTA_DATA_R       (*((volatile unsigned long *)0x400043FC))
+#define GPIO_PORTA_DIR_R        (*((volatile unsigned long *)0x40004400))
+#define GPIO_PORTA_IS_R         (*((volatile unsigned long *)0x40004404))
+#define GPIO_PORTA_IBE_R        (*((volatile unsigned long *)0x40004408))
+#define GPIO_PORTA_IEV_R        (*((volatile unsigned long *)0x4000440C))
+#define GPIO_PORTA_IM_R         (*((volatile unsigned long *)0x40004410))
+#define GPIO_PORTA_RIS_R        (*((volatile unsigned long *)0x40004414))
+#define GPIO_PORTA_MIS_R        (*((volatile unsigned long *)0x40004418))
+#define GPIO_PORTA_ICR_R        (*((volatile unsigned long *)0x4000441C))
+#define GPIO_PORTA_AFSEL_R      (*((volatile unsigned long *)0x40004420))
+#define GPIO_PORTA_DR2R_R       (*((volatile unsigned long *)0x40004500))
+#define GPIO_PORTA_DR4R_R       (*((volatile unsigned long *)0x40004504))
+#define GPIO_PORTA_DR8R_R       (*((volatile unsigned long *)0x40004508))
+#define GPIO_PORTA_ODR_R        (*((volatile unsigned long *)0x4000450C))
+#define GPIO_PORTA_PUR_R        (*((volatile unsigned long *)0x40004510))
+#define GPIO_PORTA_PDR_R        (*((volatile unsigned long *)0x40004514))
+#define GPIO_PORTA_SLR_R        (*((volatile unsigned long *)0x40004518))
+#define GPIO_PORTA_DEN_R        (*((volatile unsigned long *)0x4000451C))
+#define GPIO_PORTA_LOCK_R       (*((volatile unsigned long *)0x40004520))
+#define GPIO_PORTA_CR_R         (*((volatile unsigned long *)0x40004524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTB)
+//
+//*****************************************************************************
+#define GPIO_PORTB_DATA_BITS_R  ((volatile unsigned long *)0x40005000)
+#define GPIO_PORTB_DATA_R       (*((volatile unsigned long *)0x400053FC))
+#define GPIO_PORTB_DIR_R        (*((volatile unsigned long *)0x40005400))
+#define GPIO_PORTB_IS_R         (*((volatile unsigned long *)0x40005404))
+#define GPIO_PORTB_IBE_R        (*((volatile unsigned long *)0x40005408))
+#define GPIO_PORTB_IEV_R        (*((volatile unsigned long *)0x4000540C))
+#define GPIO_PORTB_IM_R         (*((volatile unsigned long *)0x40005410))
+#define GPIO_PORTB_RIS_R        (*((volatile unsigned long *)0x40005414))
+#define GPIO_PORTB_MIS_R        (*((volatile unsigned long *)0x40005418))
+#define GPIO_PORTB_ICR_R        (*((volatile unsigned long *)0x4000541C))
+#define GPIO_PORTB_AFSEL_R      (*((volatile unsigned long *)0x40005420))
+#define GPIO_PORTB_DR2R_R       (*((volatile unsigned long *)0x40005500))
+#define GPIO_PORTB_DR4R_R       (*((volatile unsigned long *)0x40005504))
+#define GPIO_PORTB_DR8R_R       (*((volatile unsigned long *)0x40005508))
+#define GPIO_PORTB_ODR_R        (*((volatile unsigned long *)0x4000550C))
+#define GPIO_PORTB_PUR_R        (*((volatile unsigned long *)0x40005510))
+#define GPIO_PORTB_PDR_R        (*((volatile unsigned long *)0x40005514))
+#define GPIO_PORTB_SLR_R        (*((volatile unsigned long *)0x40005518))
+#define GPIO_PORTB_DEN_R        (*((volatile unsigned long *)0x4000551C))
+#define GPIO_PORTB_LOCK_R       (*((volatile unsigned long *)0x40005520))
+#define GPIO_PORTB_CR_R         (*((volatile unsigned long *)0x40005524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTC)
+//
+//*****************************************************************************
+#define GPIO_PORTC_DATA_BITS_R  ((volatile unsigned long *)0x40006000)
+#define GPIO_PORTC_DATA_R       (*((volatile unsigned long *)0x400063FC))
+#define GPIO_PORTC_DIR_R        (*((volatile unsigned long *)0x40006400))
+#define GPIO_PORTC_IS_R         (*((volatile unsigned long *)0x40006404))
+#define GPIO_PORTC_IBE_R        (*((volatile unsigned long *)0x40006408))
+#define GPIO_PORTC_IEV_R        (*((volatile unsigned long *)0x4000640C))
+#define GPIO_PORTC_IM_R         (*((volatile unsigned long *)0x40006410))
+#define GPIO_PORTC_RIS_R        (*((volatile unsigned long *)0x40006414))
+#define GPIO_PORTC_MIS_R        (*((volatile unsigned long *)0x40006418))
+#define GPIO_PORTC_ICR_R        (*((volatile unsigned long *)0x4000641C))
+#define GPIO_PORTC_AFSEL_R      (*((volatile unsigned long *)0x40006420))
+#define GPIO_PORTC_DR2R_R       (*((volatile unsigned long *)0x40006500))
+#define GPIO_PORTC_DR4R_R       (*((volatile unsigned long *)0x40006504))
+#define GPIO_PORTC_DR8R_R       (*((volatile unsigned long *)0x40006508))
+#define GPIO_PORTC_ODR_R        (*((volatile unsigned long *)0x4000650C))
+#define GPIO_PORTC_PUR_R        (*((volatile unsigned long *)0x40006510))
+#define GPIO_PORTC_PDR_R        (*((volatile unsigned long *)0x40006514))
+#define GPIO_PORTC_SLR_R        (*((volatile unsigned long *)0x40006518))
+#define GPIO_PORTC_DEN_R        (*((volatile unsigned long *)0x4000651C))
+#define GPIO_PORTC_LOCK_R       (*((volatile unsigned long *)0x40006520))
+#define GPIO_PORTC_CR_R         (*((volatile unsigned long *)0x40006524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTD)
+//
+//*****************************************************************************
+#define GPIO_PORTD_DATA_BITS_R  ((volatile unsigned long *)0x40007000)
+#define GPIO_PORTD_DATA_R       (*((volatile unsigned long *)0x400073FC))
+#define GPIO_PORTD_DIR_R        (*((volatile unsigned long *)0x40007400))
+#define GPIO_PORTD_IS_R         (*((volatile unsigned long *)0x40007404))
+#define GPIO_PORTD_IBE_R        (*((volatile unsigned long *)0x40007408))
+#define GPIO_PORTD_IEV_R        (*((volatile unsigned long *)0x4000740C))
+#define GPIO_PORTD_IM_R         (*((volatile unsigned long *)0x40007410))
+#define GPIO_PORTD_RIS_R        (*((volatile unsigned long *)0x40007414))
+#define GPIO_PORTD_MIS_R        (*((volatile unsigned long *)0x40007418))
+#define GPIO_PORTD_ICR_R        (*((volatile unsigned long *)0x4000741C))
+#define GPIO_PORTD_AFSEL_R      (*((volatile unsigned long *)0x40007420))
+#define GPIO_PORTD_DR2R_R       (*((volatile unsigned long *)0x40007500))
+#define GPIO_PORTD_DR4R_R       (*((volatile unsigned long *)0x40007504))
+#define GPIO_PORTD_DR8R_R       (*((volatile unsigned long *)0x40007508))
+#define GPIO_PORTD_ODR_R        (*((volatile unsigned long *)0x4000750C))
+#define GPIO_PORTD_PUR_R        (*((volatile unsigned long *)0x40007510))
+#define GPIO_PORTD_PDR_R        (*((volatile unsigned long *)0x40007514))
+#define GPIO_PORTD_SLR_R        (*((volatile unsigned long *)0x40007518))
+#define GPIO_PORTD_DEN_R        (*((volatile unsigned long *)0x4000751C))
+#define GPIO_PORTD_LOCK_R       (*((volatile unsigned long *)0x40007520))
+#define GPIO_PORTD_CR_R         (*((volatile unsigned long *)0x40007524))
+
+//*****************************************************************************
+//
+// Synchronous Serial Interface (SSI0)
+//
+//*****************************************************************************
+#define SSI0_CR0_R              (*((volatile unsigned long *)0x40008000))
+#define SSI0_CR1_R              (*((volatile unsigned long *)0x40008004))
+#define SSI0_DR_R               (*((volatile unsigned long *)0x40008008))
+#define SSI0_SR_R               (*((volatile unsigned long *)0x4000800C))
+#define SSI0_CPSR_R             (*((volatile unsigned long *)0x40008010))
+#define SSI0_IM_R               (*((volatile unsigned long *)0x40008014))
+#define SSI0_RIS_R              (*((volatile unsigned long *)0x40008018))
+#define SSI0_MIS_R              (*((volatile unsigned long *)0x4000801C))
+#define SSI0_ICR_R              (*((volatile unsigned long *)0x40008020))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART0)
+//
+//*****************************************************************************
+#define UART0_DR_R              (*((volatile unsigned long *)0x4000C000))
+#define UART0_RSR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_ECR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_FR_R              (*((volatile unsigned long *)0x4000C018))
+#define UART0_ILPR_R            (*((volatile unsigned long *)0x4000C020))
+#define UART0_IBRD_R            (*((volatile unsigned long *)0x4000C024))
+#define UART0_FBRD_R            (*((volatile unsigned long *)0x4000C028))
+#define UART0_LCRH_R            (*((volatile unsigned long *)0x4000C02C))
+#define UART0_CTL_R             (*((volatile unsigned long *)0x4000C030))
+#define UART0_IFLS_R            (*((volatile unsigned long *)0x4000C034))
+#define UART0_IM_R              (*((volatile unsigned long *)0x4000C038))
+#define UART0_RIS_R             (*((volatile unsigned long *)0x4000C03C))
+#define UART0_MIS_R             (*((volatile unsigned long *)0x4000C040))
+#define UART0_ICR_R             (*((volatile unsigned long *)0x4000C044))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART1)
+//
+//*****************************************************************************
+#define UART1_DR_R              (*((volatile unsigned long *)0x4000D000))
+#define UART1_RSR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_ECR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_FR_R              (*((volatile unsigned long *)0x4000D018))
+#define UART1_ILPR_R            (*((volatile unsigned long *)0x4000D020))
+#define UART1_IBRD_R            (*((volatile unsigned long *)0x4000D024))
+#define UART1_FBRD_R            (*((volatile unsigned long *)0x4000D028))
+#define UART1_LCRH_R            (*((volatile unsigned long *)0x4000D02C))
+#define UART1_CTL_R             (*((volatile unsigned long *)0x4000D030))
+#define UART1_IFLS_R            (*((volatile unsigned long *)0x4000D034))
+#define UART1_IM_R              (*((volatile unsigned long *)0x4000D038))
+#define UART1_RIS_R             (*((volatile unsigned long *)0x4000D03C))
+#define UART1_MIS_R             (*((volatile unsigned long *)0x4000D040))
+#define UART1_ICR_R             (*((volatile unsigned long *)0x4000D044))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (MASTER) Interface
+//
+//*****************************************************************************
+#define I2C0_MASTER_MSA_R       (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SOAR_R      (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SCSR_R      (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_MCS_R       (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_SDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MTPR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SIMR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SRIS_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MIMR_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MRIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SMIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SICR_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MMIS_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MICR_R      (*((volatile unsigned long *)0x4002001C))
+#define I2C0_MASTER_MCR_R       (*((volatile unsigned long *)0x40020020))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (SLAVE) Interface
+//
+//*****************************************************************************
+#define I2C0_SLAVE_MSA_R        (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SOAR_R       (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SCSR_R       (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_MCS_R        (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_SDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MTPR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SIMR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SRIS_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MIMR_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MRIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SMIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SICR_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MMIS_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MICR_R       (*((volatile unsigned long *)0x4002081C))
+#define I2C0_SLAVE_MCR_R        (*((volatile unsigned long *)0x40020820))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTE)
+//
+//*****************************************************************************
+#define GPIO_PORTE_DATA_BITS_R  ((volatile unsigned long *)0x40024000)
+#define GPIO_PORTE_DATA_R       (*((volatile unsigned long *)0x400243FC))
+#define GPIO_PORTE_DIR_R        (*((volatile unsigned long *)0x40024400))
+#define GPIO_PORTE_IS_R         (*((volatile unsigned long *)0x40024404))
+#define GPIO_PORTE_IBE_R        (*((volatile unsigned long *)0x40024408))
+#define GPIO_PORTE_IEV_R        (*((volatile unsigned long *)0x4002440C))
+#define GPIO_PORTE_IM_R         (*((volatile unsigned long *)0x40024410))
+#define GPIO_PORTE_RIS_R        (*((volatile unsigned long *)0x40024414))
+#define GPIO_PORTE_MIS_R        (*((volatile unsigned long *)0x40024418))
+#define GPIO_PORTE_ICR_R        (*((volatile unsigned long *)0x4002441C))
+#define GPIO_PORTE_AFSEL_R      (*((volatile unsigned long *)0x40024420))
+#define GPIO_PORTE_DR2R_R       (*((volatile unsigned long *)0x40024500))
+#define GPIO_PORTE_DR4R_R       (*((volatile unsigned long *)0x40024504))
+#define GPIO_PORTE_DR8R_R       (*((volatile unsigned long *)0x40024508))
+#define GPIO_PORTE_ODR_R        (*((volatile unsigned long *)0x4002450C))
+#define GPIO_PORTE_PUR_R        (*((volatile unsigned long *)0x40024510))
+#define GPIO_PORTE_PDR_R        (*((volatile unsigned long *)0x40024514))
+#define GPIO_PORTE_SLR_R        (*((volatile unsigned long *)0x40024518))
+#define GPIO_PORTE_DEN_R        (*((volatile unsigned long *)0x4002451C))
+#define GPIO_PORTE_LOCK_R       (*((volatile unsigned long *)0x40024520))
+#define GPIO_PORTE_CR_R         (*((volatile unsigned long *)0x40024524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTF)
+//
+//*****************************************************************************
+#define GPIO_PORTF_DATA_BITS_R  ((volatile unsigned long *)0x40025000)
+#define GPIO_PORTF_DATA_R       (*((volatile unsigned long *)0x400253FC))
+#define GPIO_PORTF_DIR_R        (*((volatile unsigned long *)0x40025400))
+#define GPIO_PORTF_IS_R         (*((volatile unsigned long *)0x40025404))
+#define GPIO_PORTF_IBE_R        (*((volatile unsigned long *)0x40025408))
+#define GPIO_PORTF_IEV_R        (*((volatile unsigned long *)0x4002540C))
+#define GPIO_PORTF_IM_R         (*((volatile unsigned long *)0x40025410))
+#define GPIO_PORTF_RIS_R        (*((volatile unsigned long *)0x40025414))
+#define GPIO_PORTF_MIS_R        (*((volatile unsigned long *)0x40025418))
+#define GPIO_PORTF_ICR_R        (*((volatile unsigned long *)0x4002541C))
+#define GPIO_PORTF_AFSEL_R      (*((volatile unsigned long *)0x40025420))
+#define GPIO_PORTF_DR2R_R       (*((volatile unsigned long *)0x40025500))
+#define GPIO_PORTF_DR4R_R       (*((volatile unsigned long *)0x40025504))
+#define GPIO_PORTF_DR8R_R       (*((volatile unsigned long *)0x40025508))
+#define GPIO_PORTF_ODR_R        (*((volatile unsigned long *)0x4002550C))
+#define GPIO_PORTF_PUR_R        (*((volatile unsigned long *)0x40025510))
+#define GPIO_PORTF_PDR_R        (*((volatile unsigned long *)0x40025514))
+#define GPIO_PORTF_SLR_R        (*((volatile unsigned long *)0x40025518))
+#define GPIO_PORTF_DEN_R        (*((volatile unsigned long *)0x4002551C))
+#define GPIO_PORTF_LOCK_R       (*((volatile unsigned long *)0x40025520))
+#define GPIO_PORTF_CR_R         (*((volatile unsigned long *)0x40025524))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTG)
+//
+//*****************************************************************************
+#define GPIO_PORTG_DATA_BITS_R  ((volatile unsigned long *)0x40026000)
+#define GPIO_PORTG_DATA_R       (*((volatile unsigned long *)0x400263FC))
+#define GPIO_PORTG_DIR_R        (*((volatile unsigned long *)0x40026400))
+#define GPIO_PORTG_IS_R         (*((volatile unsigned long *)0x40026404))
+#define GPIO_PORTG_IBE_R        (*((volatile unsigned long *)0x40026408))
+#define GPIO_PORTG_IEV_R        (*((volatile unsigned long *)0x4002640C))
+#define GPIO_PORTG_IM_R         (*((volatile unsigned long *)0x40026410))
+#define GPIO_PORTG_RIS_R        (*((volatile unsigned long *)0x40026414))
+#define GPIO_PORTG_MIS_R        (*((volatile unsigned long *)0x40026418))
+#define GPIO_PORTG_ICR_R        (*((volatile unsigned long *)0x4002641C))
+#define GPIO_PORTG_AFSEL_R      (*((volatile unsigned long *)0x40026420))
+#define GPIO_PORTG_DR2R_R       (*((volatile unsigned long *)0x40026500))
+#define GPIO_PORTG_DR4R_R       (*((volatile unsigned long *)0x40026504))
+#define GPIO_PORTG_DR8R_R       (*((volatile unsigned long *)0x40026508))
+#define GPIO_PORTG_ODR_R        (*((volatile unsigned long *)0x4002650C))
+#define GPIO_PORTG_PUR_R        (*((volatile unsigned long *)0x40026510))
+#define GPIO_PORTG_PDR_R        (*((volatile unsigned long *)0x40026514))
+#define GPIO_PORTG_SLR_R        (*((volatile unsigned long *)0x40026518))
+#define GPIO_PORTG_DEN_R        (*((volatile unsigned long *)0x4002651C))
+#define GPIO_PORTG_LOCK_R       (*((volatile unsigned long *)0x40026520))
+#define GPIO_PORTG_CR_R         (*((volatile unsigned long *)0x40026524))
+
+//*****************************************************************************
+//
+// Pulse Width Modulator (PWM)
+//
+//*****************************************************************************
+#define PWM_CTL_R               (*((volatile unsigned long *)0x40028000))
+#define PWM_SYNC_R              (*((volatile unsigned long *)0x40028004))
+#define PWM_ENABLE_R            (*((volatile unsigned long *)0x40028008))
+#define PWM_INVERT_R            (*((volatile unsigned long *)0x4002800C))
+#define PWM_FAULT_R             (*((volatile unsigned long *)0x40028010))
+#define PWM_INTEN_R             (*((volatile unsigned long *)0x40028014))
+#define PWM_RIS_R               (*((volatile unsigned long *)0x40028018))
+#define PWM_ISC_R               (*((volatile unsigned long *)0x4002801C))
+#define PWM_STATUS_R            (*((volatile unsigned long *)0x40028020))
+#define PWM_0_CTL_R             (*((volatile unsigned long *)0x40028040))
+#define PWM_0_INTEN_R           (*((volatile unsigned long *)0x40028044))
+#define PWM_0_RIS_R             (*((volatile unsigned long *)0x40028048))
+#define PWM_0_ISC_R             (*((volatile unsigned long *)0x4002804C))
+#define PWM_0_LOAD_R            (*((volatile unsigned long *)0x40028050))
+#define PWM_0_COUNT_R           (*((volatile unsigned long *)0x40028054))
+#define PWM_0_CMPA_R            (*((volatile unsigned long *)0x40028058))
+#define PWM_0_CMPB_R            (*((volatile unsigned long *)0x4002805C))
+#define PWM_0_GENA_R            (*((volatile unsigned long *)0x40028060))
+#define PWM_0_GENB_R            (*((volatile unsigned long *)0x40028064))
+#define PWM_0_DBCTL_R           (*((volatile unsigned long *)0x40028068))
+#define PWM_0_DBRISE_R          (*((volatile unsigned long *)0x4002806C))
+#define PWM_0_DBFALL_R          (*((volatile unsigned long *)0x40028070))
+#define PWM_1_CTL_R             (*((volatile unsigned long *)0x40028080))
+#define PWM_1_INTEN_R           (*((volatile unsigned long *)0x40028084))
+#define PWM_1_RIS_R             (*((volatile unsigned long *)0x40028088))
+#define PWM_1_ISC_R             (*((volatile unsigned long *)0x4002808C))
+#define PWM_1_LOAD_R            (*((volatile unsigned long *)0x40028090))
+#define PWM_1_COUNT_R           (*((volatile unsigned long *)0x40028094))
+#define PWM_1_CMPA_R            (*((volatile unsigned long *)0x40028098))
+#define PWM_1_CMPB_R            (*((volatile unsigned long *)0x4002809C))
+#define PWM_1_GENA_R            (*((volatile unsigned long *)0x400280A0))
+#define PWM_1_GENB_R            (*((volatile unsigned long *)0x400280A4))
+#define PWM_1_DBCTL_R           (*((volatile unsigned long *)0x400280A8))
+#define PWM_1_DBRISE_R          (*((volatile unsigned long *)0x400280AC))
+#define PWM_1_DBFALL_R          (*((volatile unsigned long *)0x400280B0))
+#define PWM_2_CTL_R             (*((volatile unsigned long *)0x400280C0))
+#define PWM_2_INTEN_R           (*((volatile unsigned long *)0x400280C4))
+#define PWM_2_RIS_R             (*((volatile unsigned long *)0x400280C8))
+#define PWM_2_ISC_R             (*((volatile unsigned long *)0x400280CC))
+#define PWM_2_LOAD_R            (*((volatile unsigned long *)0x400280D0))
+#define PWM_2_COUNT_R           (*((volatile unsigned long *)0x400280D4))
+#define PWM_2_CMPA_R            (*((volatile unsigned long *)0x400280D8))
+#define PWM_2_CMPB_R            (*((volatile unsigned long *)0x400280DC))
+#define PWM_2_GENA_R            (*((volatile unsigned long *)0x400280E0))
+#define PWM_2_GENB_R            (*((volatile unsigned long *)0x400280E4))
+#define PWM_2_DBCTL_R           (*((volatile unsigned long *)0x400280E8))
+#define PWM_2_DBRISE_R          (*((volatile unsigned long *)0x400280EC))
+#define PWM_2_DBFALL_R          (*((volatile unsigned long *)0x400280F0))
+
+//*****************************************************************************
+//
+// Quadrature Encoder Interface (QEI0)
+//
+//*****************************************************************************
+#define QEI0_CTL_R              (*((volatile unsigned long *)0x4002C000))
+#define QEI0_STAT_R             (*((volatile unsigned long *)0x4002C004))
+#define QEI0_POS_R              (*((volatile unsigned long *)0x4002C008))
+#define QEI0_MAXPOS_R           (*((volatile unsigned long *)0x4002C00C))
+#define QEI0_LOAD_R             (*((volatile unsigned long *)0x4002C010))
+#define QEI0_TIME_R             (*((volatile unsigned long *)0x4002C014))
+#define QEI0_COUNT_R            (*((volatile unsigned long *)0x4002C018))
+#define QEI0_SPEED_R            (*((volatile unsigned long *)0x4002C01C))
+#define QEI0_INTEN_R            (*((volatile unsigned long *)0x4002C020))
+#define QEI0_RIS_R              (*((volatile unsigned long *)0x4002C024))
+#define QEI0_ISC_R              (*((volatile unsigned long *)0x4002C028))
+
+//*****************************************************************************
+//
+// Quadrature Encoder Interface (QEI1)
+//
+//*****************************************************************************
+#define QEI1_CTL_R              (*((volatile unsigned long *)0x4002D000))
+#define QEI1_STAT_R             (*((volatile unsigned long *)0x4002D004))
+#define QEI1_POS_R              (*((volatile unsigned long *)0x4002D008))
+#define QEI1_MAXPOS_R           (*((volatile unsigned long *)0x4002D00C))
+#define QEI1_LOAD_R             (*((volatile unsigned long *)0x4002D010))
+#define QEI1_TIME_R             (*((volatile unsigned long *)0x4002D014))
+#define QEI1_COUNT_R            (*((volatile unsigned long *)0x4002D018))
+#define QEI1_SPEED_R            (*((volatile unsigned long *)0x4002D01C))
+#define QEI1_INTEN_R            (*((volatile unsigned long *)0x4002D020))
+#define QEI1_RIS_R              (*((volatile unsigned long *)0x4002D024))
+#define QEI1_ISC_R              (*((volatile unsigned long *)0x4002D028))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER0)
+//
+//*****************************************************************************
+#define TIMER0_CFG_R            (*((volatile unsigned long *)0x40030000))
+#define TIMER0_TAMR_R           (*((volatile unsigned long *)0x40030004))
+#define TIMER0_TBMR_R           (*((volatile unsigned long *)0x40030008))
+#define TIMER0_CTL_R            (*((volatile unsigned long *)0x4003000C))
+#define TIMER0_IMR_R            (*((volatile unsigned long *)0x40030018))
+#define TIMER0_RIS_R            (*((volatile unsigned long *)0x4003001C))
+#define TIMER0_MIS_R            (*((volatile unsigned long *)0x40030020))
+#define TIMER0_ICR_R            (*((volatile unsigned long *)0x40030024))
+#define TIMER0_TAILR_R          (*((volatile unsigned long *)0x40030028))
+#define TIMER0_TBILR_R          (*((volatile unsigned long *)0x4003002C))
+#define TIMER0_TAMATCHR_R       (*((volatile unsigned long *)0x40030030))
+#define TIMER0_TBMATCHR_R       (*((volatile unsigned long *)0x40030034))
+#define TIMER0_TAPR_R           (*((volatile unsigned long *)0x40030038))
+#define TIMER0_TBPR_R           (*((volatile unsigned long *)0x4003003C))
+#define TIMER0_TAPMR_R          (*((volatile unsigned long *)0x40030040))
+#define TIMER0_TBPMR_R          (*((volatile unsigned long *)0x40030044))
+#define TIMER0_TAR_R            (*((volatile unsigned long *)0x40030048))
+#define TIMER0_TBR_R            (*((volatile unsigned long *)0x4003004C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER1)
+//
+//*****************************************************************************
+#define TIMER1_CFG_R            (*((volatile unsigned long *)0x40031000))
+#define TIMER1_TAMR_R           (*((volatile unsigned long *)0x40031004))
+#define TIMER1_TBMR_R           (*((volatile unsigned long *)0x40031008))
+#define TIMER1_CTL_R            (*((volatile unsigned long *)0x4003100C))
+#define TIMER1_IMR_R            (*((volatile unsigned long *)0x40031018))
+#define TIMER1_RIS_R            (*((volatile unsigned long *)0x4003101C))
+#define TIMER1_MIS_R            (*((volatile unsigned long *)0x40031020))
+#define TIMER1_ICR_R            (*((volatile unsigned long *)0x40031024))
+#define TIMER1_TAILR_R          (*((volatile unsigned long *)0x40031028))
+#define TIMER1_TBILR_R          (*((volatile unsigned long *)0x4003102C))
+#define TIMER1_TAMATCHR_R       (*((volatile unsigned long *)0x40031030))
+#define TIMER1_TBMATCHR_R       (*((volatile unsigned long *)0x40031034))
+#define TIMER1_TAPR_R           (*((volatile unsigned long *)0x40031038))
+#define TIMER1_TBPR_R           (*((volatile unsigned long *)0x4003103C))
+#define TIMER1_TAPMR_R          (*((volatile unsigned long *)0x40031040))
+#define TIMER1_TBPMR_R          (*((volatile unsigned long *)0x40031044))
+#define TIMER1_TAR_R            (*((volatile unsigned long *)0x40031048))
+#define TIMER1_TBR_R            (*((volatile unsigned long *)0x4003104C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER2)
+//
+//*****************************************************************************
+#define TIMER2_CFG_R            (*((volatile unsigned long *)0x40032000))
+#define TIMER2_TAMR_R           (*((volatile unsigned long *)0x40032004))
+#define TIMER2_TBMR_R           (*((volatile unsigned long *)0x40032008))
+#define TIMER2_CTL_R            (*((volatile unsigned long *)0x4003200C))
+#define TIMER2_IMR_R            (*((volatile unsigned long *)0x40032018))
+#define TIMER2_RIS_R            (*((volatile unsigned long *)0x4003201C))
+#define TIMER2_MIS_R            (*((volatile unsigned long *)0x40032020))
+#define TIMER2_ICR_R            (*((volatile unsigned long *)0x40032024))
+#define TIMER2_TAILR_R          (*((volatile unsigned long *)0x40032028))
+#define TIMER2_TBILR_R          (*((volatile unsigned long *)0x4003202C))
+#define TIMER2_TAMATCHR_R       (*((volatile unsigned long *)0x40032030))
+#define TIMER2_TBMATCHR_R       (*((volatile unsigned long *)0x40032034))
+#define TIMER2_TAPR_R           (*((volatile unsigned long *)0x40032038))
+#define TIMER2_TBPR_R           (*((volatile unsigned long *)0x4003203C))
+#define TIMER2_TAPMR_R          (*((volatile unsigned long *)0x40032040))
+#define TIMER2_TBPMR_R          (*((volatile unsigned long *)0x40032044))
+#define TIMER2_TAR_R            (*((volatile unsigned long *)0x40032048))
+#define TIMER2_TBR_R            (*((volatile unsigned long *)0x4003204C))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER3)
+//
+//*****************************************************************************
+#define TIMER3_CFG_R            (*((volatile unsigned long *)0x40033000))
+#define TIMER3_TAMR_R           (*((volatile unsigned long *)0x40033004))
+#define TIMER3_TBMR_R           (*((volatile unsigned long *)0x40033008))
+#define TIMER3_CTL_R            (*((volatile unsigned long *)0x4003300C))
+#define TIMER3_IMR_R            (*((volatile unsigned long *)0x40033018))
+#define TIMER3_RIS_R            (*((volatile unsigned long *)0x4003301C))
+#define TIMER3_MIS_R            (*((volatile unsigned long *)0x40033020))
+#define TIMER3_ICR_R            (*((volatile unsigned long *)0x40033024))
+#define TIMER3_TAILR_R          (*((volatile unsigned long *)0x40033028))
+#define TIMER3_TBILR_R          (*((volatile unsigned long *)0x4003302C))
+#define TIMER3_TAMATCHR_R       (*((volatile unsigned long *)0x40033030))
+#define TIMER3_TBMATCHR_R       (*((volatile unsigned long *)0x40033034))
+#define TIMER3_TAPR_R           (*((volatile unsigned long *)0x40033038))
+#define TIMER3_TBPR_R           (*((volatile unsigned long *)0x4003303C))
+#define TIMER3_TAPMR_R          (*((volatile unsigned long *)0x40033040))
+#define TIMER3_TBPMR_R          (*((volatile unsigned long *)0x40033044))
+#define TIMER3_TAR_R            (*((volatile unsigned long *)0x40033048))
+#define TIMER3_TBR_R            (*((volatile unsigned long *)0x4003304C))
+
+//*****************************************************************************
+//
+// Analog-to-Digital Converter (ADC)
+//
+//*****************************************************************************
+#define ADC_ACTSS_R             (*((volatile unsigned long *)0x40038000))
+#define ADC_RIS_R               (*((volatile unsigned long *)0x40038004))
+#define ADC_IM_R                (*((volatile unsigned long *)0x40038008))
+#define ADC_ISC_R               (*((volatile unsigned long *)0x4003800C))
+#define ADC_OSTAT_R             (*((volatile unsigned long *)0x40038010))
+#define ADC_EMUX_R              (*((volatile unsigned long *)0x40038014))
+#define ADC_USTAT_R             (*((volatile unsigned long *)0x40038018))
+#define ADC_SSPRI_R             (*((volatile unsigned long *)0x40038020))
+#define ADC_PSSI_R              (*((volatile unsigned long *)0x40038028))
+#define ADC_SAC_R               (*((volatile unsigned long *)0x40038030))
+#define ADC_SSMUX0_R            (*((volatile unsigned long *)0x40038040))
+#define ADC_SSCTL0_R            (*((volatile unsigned long *)0x40038044))
+#define ADC_SSFIFO0_R           (*((volatile unsigned long *)0x40038048))
+#define ADC_SSFSTAT0_R          (*((volatile unsigned long *)0x4003804C))
+#define ADC_SSMUX1_R            (*((volatile unsigned long *)0x40038060))
+#define ADC_SSCTL1_R            (*((volatile unsigned long *)0x40038064))
+#define ADC_SSFIFO1_R           (*((volatile unsigned long *)0x40038068))
+#define ADC_SSFSTAT1_R          (*((volatile unsigned long *)0x4003806C))
+#define ADC_SSMUX2_R            (*((volatile unsigned long *)0x40038080))
+#define ADC_SSCTL2_R            (*((volatile unsigned long *)0x40038084))
+#define ADC_SSFIFO2_R           (*((volatile unsigned long *)0x40038088))
+#define ADC_SSFSTAT2_R          (*((volatile unsigned long *)0x4003808C))
+#define ADC_SSMUX3_R            (*((volatile unsigned long *)0x400380A0))
+#define ADC_SSCTL3_R            (*((volatile unsigned long *)0x400380A4))
+#define ADC_SSFIFO3_R           (*((volatile unsigned long *)0x400380A8))
+#define ADC_SSFSTAT3_R          (*((volatile unsigned long *)0x400380AC))
+#define ADC_TMLB_R              (*((volatile unsigned long *)0x40038100))
+
+//*****************************************************************************
+//
+// Analog Comparator (COMP)
+//
+//*****************************************************************************
+#define COMP_ACMIS_R            (*((volatile unsigned long *)0x4003C000))
+#define COMP_ACRIS_R            (*((volatile unsigned long *)0x4003C004))
+#define COMP_ACINTEN_R          (*((volatile unsigned long *)0x4003C008))
+#define COMP_ACREFCTL_R         (*((volatile unsigned long *)0x4003C010))
+#define COMP_ACSTAT0_R          (*((volatile unsigned long *)0x4003C020))
+#define COMP_ACCTL0_R           (*((volatile unsigned long *)0x4003C024))
+
+//*****************************************************************************
+//
+// Controller Area Network (CAN0) Module
+//
+//*****************************************************************************
+#define CAN0_CTL_R              (*((volatile unsigned long *)0x40040000))
+#define CAN0_STS_R              (*((volatile unsigned long *)0x40040004))
+#define CAN0_ERR_R              (*((volatile unsigned long *)0x40040008))
+#define CAN0_BIT_R              (*((volatile unsigned long *)0x4004000C))
+#define CAN0_INT_R              (*((volatile unsigned long *)0x40040010))
+#define CAN0_TST_R              (*((volatile unsigned long *)0x40040014))
+#define CAN0_BRPE_R             (*((volatile unsigned long *)0x40040018))
+#define CAN0_IF1CRQ_R           (*((volatile unsigned long *)0x40040020))
+#define CAN0_IF1CMSK_R          (*((volatile unsigned long *)0x40040024))
+#define CAN0_IF1MSK1_R          (*((volatile unsigned long *)0x40040028))
+#define CAN0_IF1MSK2_R          (*((volatile unsigned long *)0x4004002C))
+#define CAN0_IF1ARB1_R          (*((volatile unsigned long *)0x40040030))
+#define CAN0_IF1ARB2_R          (*((volatile unsigned long *)0x40040034))
+#define CAN0_IF1MCTL_R          (*((volatile unsigned long *)0x40040038))
+#define CAN0_IF1DA1_R           (*((volatile unsigned long *)0x4004003C))
+#define CAN0_IF1DA2_R           (*((volatile unsigned long *)0x40040040))
+#define CAN0_IF1DB1_R           (*((volatile unsigned long *)0x40040044))
+#define CAN0_IF1DB2_R           (*((volatile unsigned long *)0x40040048))
+#define CAN0_IF2CRQ_R           (*((volatile unsigned long *)0x40040080))
+#define CAN0_IF2CMSK_R          (*((volatile unsigned long *)0x40040084))
+#define CAN0_IF2MSK1_R          (*((volatile unsigned long *)0x40040088))
+#define CAN0_IF2MSK2_R          (*((volatile unsigned long *)0x4004008C))
+#define CAN0_IF2ARB1_R          (*((volatile unsigned long *)0x40040090))
+#define CAN0_IF2ARB2_R          (*((volatile unsigned long *)0x40040094))
+#define CAN0_IF2MCTL_R          (*((volatile unsigned long *)0x40040098))
+#define CAN0_IF2DA1_R           (*((volatile unsigned long *)0x4004009C))
+#define CAN0_IF2DA2_R           (*((volatile unsigned long *)0x400400A0))
+#define CAN0_IF2DB1_R           (*((volatile unsigned long *)0x400400A4))
+#define CAN0_IF2DB2_R           (*((volatile unsigned long *)0x400400A8))
+#define CAN0_TXRQ1_R            (*((volatile unsigned long *)0x40040100))
+#define CAN0_TXRQ2_R            (*((volatile unsigned long *)0x40040104))
+#define CAN0_NWDA1_R            (*((volatile unsigned long *)0x40040120))
+#define CAN0_NWDA2_R            (*((volatile unsigned long *)0x40040124))
+#define CAN0_MSG1INT_R          (*((volatile unsigned long *)0x40040140))
+#define CAN0_MSG2INT_R          (*((volatile unsigned long *)0x40040144))
+#define CAN0_MSG1VAL_R          (*((volatile unsigned long *)0x40040160))
+#define CAN0_MSG2VAL_R          (*((volatile unsigned long *)0x40040164))
+
+//*****************************************************************************
+//
+// Ethernet Controller (MAC)
+//
+//*****************************************************************************
+#define MAC_MR0_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_RIS_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_IACK_R              (*((volatile unsigned long *)0x40048000))
+#define MAC_MR1_R               (*((volatile unsigned long *)0x40048001))
+#define MAC_MR2_R               (*((volatile unsigned long *)0x40048002))
+#define MAC_MR3_R               (*((volatile unsigned long *)0x40048003))
+#define MAC_IM_R                (*((volatile unsigned long *)0x40048004))
+#define MAC_MR4_R               (*((volatile unsigned long *)0x40048004))
+#define MAC_MR5_R               (*((volatile unsigned long *)0x40048005))
+#define MAC_MR6_R               (*((volatile unsigned long *)0x40048006))
+#define MAC_RCTL_R              (*((volatile unsigned long *)0x40048008))
+#define MAC_TCTL_R              (*((volatile unsigned long *)0x4004800C))
+#define MAC_DATA_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR16_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR17_R              (*((volatile unsigned long *)0x40048011))
+#define MAC_MR18_R              (*((volatile unsigned long *)0x40048012))
+#define MAC_MR19_R              (*((volatile unsigned long *)0x40048013))
+#define MAC_IA0_R               (*((volatile unsigned long *)0x40048014))
+#define MAC_MR23_R              (*((volatile unsigned long *)0x40048017))
+#define MAC_IA1_R               (*((volatile unsigned long *)0x40048018))
+#define MAC_MR24_R              (*((volatile unsigned long *)0x40048018))
+#define MAC_THR_R               (*((volatile unsigned long *)0x4004801C))
+#define MAC_MCTL_R              (*((volatile unsigned long *)0x40048020))
+#define MAC_MDV_R               (*((volatile unsigned long *)0x40048024))
+#define MAC_MTXD_R              (*((volatile unsigned long *)0x4004802C))
+#define MAC_MRXD_R              (*((volatile unsigned long *)0x40048030))
+#define MAC_NP_R                (*((volatile unsigned long *)0x40048034))
+#define MAC_TR_R                (*((volatile unsigned long *)0x40048038))
+#define MAC_TS_R                (*((volatile unsigned long *)0x4004803C))
+
+//*****************************************************************************
+//
+// Hibernation Module (HIB)
+//
+//*****************************************************************************
+#define HIB_RTCC_R              (*((volatile unsigned long *)0x400FC000))
+#define HIB_RTCM0_R             (*((volatile unsigned long *)0x400FC004))
+#define HIB_RTCM1_R             (*((volatile unsigned long *)0x400FC008))
+#define HIB_RTCLD_R             (*((volatile unsigned long *)0x400FC00C))
+#define HIB_CTL_R               (*((volatile unsigned long *)0x400FC010))
+#define HIB_IM_R                (*((volatile unsigned long *)0x400FC014))
+#define HIB_RIS_R               (*((volatile unsigned long *)0x400FC018))
+#define HIB_MIS_R               (*((volatile unsigned long *)0x400FC01C))
+#define HIB_IC_R                (*((volatile unsigned long *)0x400FC020))
+#define HIB_RTCT_R              (*((volatile unsigned long *)0x400FC024))
+#define HIB_DATA_R              (*((volatile unsigned long *)0x400FC030))
+
+//*****************************************************************************
+//
+// Internal Memory (FLASH)
+//
+//*****************************************************************************
+#define FLASH_FMA_R             (*((volatile unsigned long *)0x400FD000))
+#define FLASH_FMD_R             (*((volatile unsigned long *)0x400FD004))
+#define FLASH_FMC_R             (*((volatile unsigned long *)0x400FD008))
+#define FLASH_FCRIS_R           (*((volatile unsigned long *)0x400FD00C))
+#define FLASH_FCIM_R            (*((volatile unsigned long *)0x400FD010))
+#define FLASH_FCMISC_R          (*((volatile unsigned long *)0x400FD014))
+#define FLASH_USECRL_R          (*((volatile unsigned long *)0x400FE140))
+#define FLASH_USERDBG_R         (*((volatile unsigned long *)0x400FE1D0))
+#define FLASH_USERREG0_R        (*((volatile unsigned long *)0x400FE1E0))
+#define FLASH_USERREG1_R        (*((volatile unsigned long *)0x400FE1E4))
+#define FLASH_FMPRE0_R          (*((volatile unsigned long *)0x400FE200))
+#define FLASH_FMPRE1_R          (*((volatile unsigned long *)0x400FE204))
+#define FLASH_FMPRE2_R          (*((volatile unsigned long *)0x400FE208))
+#define FLASH_FMPRE3_R          (*((volatile unsigned long *)0x400FE20C))
+#define FLASH_FMPPE0_R          (*((volatile unsigned long *)0x400FE400))
+#define FLASH_FMPPE1_R          (*((volatile unsigned long *)0x400FE404))
+#define FLASH_FMPPE2_R          (*((volatile unsigned long *)0x400FE408))
+#define FLASH_FMPPE3_R          (*((volatile unsigned long *)0x400FE40C))
+
+//*****************************************************************************
+//
+// System Control (SYSCTL)
+//
+//*****************************************************************************
+#define SYSCTL_DID0_R           (*((volatile unsigned long *)0x400FE000))
+#define SYSCTL_DID1_R           (*((volatile unsigned long *)0x400FE004))
+#define SYSCTL_DC0_R            (*((volatile unsigned long *)0x400FE008))
+#define SYSCTL_DC1_R            (*((volatile unsigned long *)0x400FE010))
+#define SYSCTL_DC2_R            (*((volatile unsigned long *)0x400FE014))
+#define SYSCTL_DC3_R            (*((volatile unsigned long *)0x400FE018))
+#define SYSCTL_DC4_R            (*((volatile unsigned long *)0x400FE01C))
+#define SYSCTL_PBORCTL_R        (*((volatile unsigned long *)0x400FE030))
+#define SYSCTL_LDOPCTL_R        (*((volatile unsigned long *)0x400FE034))
+#define SYSCTL_SRCR0_R          (*((volatile unsigned long *)0x400FE040))
+#define SYSCTL_SRCR1_R          (*((volatile unsigned long *)0x400FE044))
+#define SYSCTL_SRCR2_R          (*((volatile unsigned long *)0x400FE048))
+#define SYSCTL_RIS_R            (*((volatile unsigned long *)0x400FE050))
+#define SYSCTL_IMC_R            (*((volatile unsigned long *)0x400FE054))
+#define SYSCTL_MISC_R           (*((volatile unsigned long *)0x400FE058))
+#define SYSCTL_RESC_R           (*((volatile unsigned long *)0x400FE05C))
+#define SYSCTL_RCC_R            (*((volatile unsigned long *)0x400FE060))
+#define SYSCTL_PLLCFG_R         (*((volatile unsigned long *)0x400FE064))
+#define SYSCTL_RCC2_R           (*((volatile unsigned long *)0x400FE070))
+#define SYSCTL_RCGC0_R          (*((volatile unsigned long *)0x400FE100))
+#define SYSCTL_RCGC1_R          (*((volatile unsigned long *)0x400FE104))
+#define SYSCTL_RCGC2_R          (*((volatile unsigned long *)0x400FE108))
+#define SYSCTL_SCGC0_R          (*((volatile unsigned long *)0x400FE110))
+#define SYSCTL_SCGC1_R          (*((volatile unsigned long *)0x400FE114))
+#define SYSCTL_SCGC2_R          (*((volatile unsigned long *)0x400FE118))
+#define SYSCTL_DCGC0_R          (*((volatile unsigned long *)0x400FE120))
+#define SYSCTL_DCGC1_R          (*((volatile unsigned long *)0x400FE124))
+#define SYSCTL_DCGC2_R          (*((volatile unsigned long *)0x400FE128))
+#define SYSCTL_DSLPCLKCFG_R     (*((volatile unsigned long *)0x400FE144))
+
+//*****************************************************************************
+//
+// Nested Vectored Interrupt Ctrl (NVIC)
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_R         (*((volatile unsigned long *)0xE000E004))
+#define NVIC_ST_CTRL_R          (*((volatile unsigned long *)0xE000E010))
+#define NVIC_ST_RELOAD_R        (*((volatile unsigned long *)0xE000E014))
+#define NVIC_ST_CURRENT_R       (*((volatile unsigned long *)0xE000E018))
+#define NVIC_ST_CAL_R           (*((volatile unsigned long *)0xE000E01C))
+#define NVIC_EN0_R              (*((volatile unsigned long *)0xE000E100))
+#define NVIC_EN1_R              (*((volatile unsigned long *)0xE000E104))
+#define NVIC_DIS0_R             (*((volatile unsigned long *)0xE000E180))
+#define NVIC_DIS1_R             (*((volatile unsigned long *)0xE000E184))
+#define NVIC_PEND0_R            (*((volatile unsigned long *)0xE000E200))
+#define NVIC_PEND1_R            (*((volatile unsigned long *)0xE000E204))
+#define NVIC_UNPEND0_R          (*((volatile unsigned long *)0xE000E280))
+#define NVIC_UNPEND1_R          (*((volatile unsigned long *)0xE000E284))
+#define NVIC_ACTIVE0_R          (*((volatile unsigned long *)0xE000E300))
+#define NVIC_ACTIVE1_R          (*((volatile unsigned long *)0xE000E304))
+#define NVIC_PRI0_R             (*((volatile unsigned long *)0xE000E400))
+#define NVIC_PRI1_R             (*((volatile unsigned long *)0xE000E404))
+#define NVIC_PRI2_R             (*((volatile unsigned long *)0xE000E408))
+#define NVIC_PRI3_R             (*((volatile unsigned long *)0xE000E40C))
+#define NVIC_PRI4_R             (*((volatile unsigned long *)0xE000E410))
+#define NVIC_PRI5_R             (*((volatile unsigned long *)0xE000E414))
+#define NVIC_PRI6_R             (*((volatile unsigned long *)0xE000E418))
+#define NVIC_PRI7_R             (*((volatile unsigned long *)0xE000E41C))
+#define NVIC_PRI8_R             (*((volatile unsigned long *)0xE000E420))
+#define NVIC_PRI9_R             (*((volatile unsigned long *)0xE000E424))
+#define NVIC_PRI10_R            (*((volatile unsigned long *)0xE000E428))
+#define NVIC_CPUID_R            (*((volatile unsigned long *)0xE000ED00))
+#define NVIC_INT_CTRL_R         (*((volatile unsigned long *)0xE000ED04))
+#define NVIC_VTABLE_R           (*((volatile unsigned long *)0xE000ED08))
+#define NVIC_APINT_R            (*((volatile unsigned long *)0xE000ED0C))
+#define NVIC_SYS_CTRL_R         (*((volatile unsigned long *)0xE000ED10))
+#define NVIC_CFG_CTRL_R         (*((volatile unsigned long *)0xE000ED14))
+#define NVIC_SYS_PRI1_R         (*((volatile unsigned long *)0xE000ED18))
+#define NVIC_SYS_PRI2_R         (*((volatile unsigned long *)0xE000ED1C))
+#define NVIC_SYS_PRI3_R         (*((volatile unsigned long *)0xE000ED20))
+#define NVIC_SYS_HND_CTRL_R     (*((volatile unsigned long *)0xE000ED24))
+#define NVIC_FAULT_STAT_R       (*((volatile unsigned long *)0xE000ED28))
+#define NVIC_HFAULT_STAT_R      (*((volatile unsigned long *)0xE000ED2C))
+#define NVIC_DEBUG_STAT_R       (*((volatile unsigned long *)0xE000ED30))
+#define NVIC_MM_ADDR_R          (*((volatile unsigned long *)0xE000ED34))
+#define NVIC_FAULT_ADDR_R       (*((volatile unsigned long *)0xE000ED38))
+#define NVIC_MPU_TYPE_R         (*((volatile unsigned long *)0xE000ED90))
+#define NVIC_MPU_CTRL_R         (*((volatile unsigned long *)0xE000ED94))
+#define NVIC_MPU_NUMBER_R       (*((volatile unsigned long *)0xE000ED98))
+#define NVIC_MPU_R              (*((volatile unsigned long *)0xE000ED9C))
+#define NVIC_MPU_ATTR_R         (*((volatile unsigned long *)0xE000EDA0))
+#define NVIC_DBG_CTRL_R         (*((volatile unsigned long *)0xE000EDF0))
+#define NVIC_DBG_XFER_R         (*((volatile unsigned long *)0xE000EDF4))
+#define NVIC_DBG_DATA_R         (*((volatile unsigned long *)0xE000EDF8))
+#define NVIC_DBG_INT_R          (*((volatile unsigned long *)0xE000EDFC))
+#define NVIC_SW_TRIG_R          (*((volatile unsigned long *)0xE000EF00))
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOAD register.
+//
+//*****************************************************************************
+#define WDT_LOAD_M              0xFFFFFFFF  // Watchdog Load Value.
+#define WDT_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_VALUE register.
+//
+//*****************************************************************************
+#define WDT_VALUE_M             0xFFFFFFFF  // Watchdog Value.
+#define WDT_VALUE_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_CTL register.
+//
+//*****************************************************************************
+#define WDT_CTL_RESEN           0x00000002  // Watchdog Reset Enable.
+#define WDT_CTL_INTEN           0x00000001  // Watchdog Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_ICR register.
+//
+//*****************************************************************************
+#define WDT_ICR_M               0xFFFFFFFF  // Watchdog Interrupt Clear.
+#define WDT_ICR_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_RIS register.
+//
+//*****************************************************************************
+#define WDT_RIS_WDTRIS          0x00000001  // Watchdog Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_MIS register.
+//
+//*****************************************************************************
+#define WDT_MIS_WDTMIS          0x00000001  // Watchdog Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_TEST register.
+//
+//*****************************************************************************
+#define WDT_TEST_STALL          0x00000100  // Watchdog Stall Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOCK register.
+//
+//*****************************************************************************
+#define WDT_LOCK_M              0xFFFFFFFF  // Watchdog Lock.
+#define WDT_LOCK_UNLOCKED       0x00000000  // Unlocked
+#define WDT_LOCK_LOCKED         0x00000001  // Locked
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_O_LOCK register.
+//
+//*****************************************************************************
+#define GPIO_LOCK_M             0xFFFFFFFF  // GPIO Lock.
+#define GPIO_LOCK_UNLOCKED      0x00000000  // unlocked
+#define GPIO_LOCK_LOCKED        0x00000001  // locked
+#define GPIO_LOCK_KEY           0x1ACCE551  // Unlocks the GPIO_CR register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR0 register.
+//
+//*****************************************************************************
+#define SSI_CR0_SCR_M           0x0000FF00  // SSI Serial Clock Rate.
+#define SSI_CR0_SPH             0x00000080  // SSI Serial Clock Phase.
+#define SSI_CR0_SPO             0x00000040  // SSI Serial Clock Polarity.
+#define SSI_CR0_FRF_M           0x00000030  // SSI Frame Format Select.
+#define SSI_CR0_FRF_MOTO        0x00000000  // Freescale SPI Frame Format
+#define SSI_CR0_FRF_TI          0x00000010  // Texas Instruments Synchronous
+                                            // Serial Frame Format
+#define SSI_CR0_FRF_NMW         0x00000020  // MICROWIRE Frame Format
+#define SSI_CR0_DSS_M           0x0000000F  // SSI Data Size Select.
+#define SSI_CR0_DSS_4           0x00000003  // 4-bit data
+#define SSI_CR0_DSS_5           0x00000004  // 5-bit data
+#define SSI_CR0_DSS_6           0x00000005  // 6-bit data
+#define SSI_CR0_DSS_7           0x00000006  // 7-bit data
+#define SSI_CR0_DSS_8           0x00000007  // 8-bit data
+#define SSI_CR0_DSS_9           0x00000008  // 9-bit data
+#define SSI_CR0_DSS_10          0x00000009  // 10-bit data
+#define SSI_CR0_DSS_11          0x0000000A  // 11-bit data
+#define SSI_CR0_DSS_12          0x0000000B  // 12-bit data
+#define SSI_CR0_DSS_13          0x0000000C  // 13-bit data
+#define SSI_CR0_DSS_14          0x0000000D  // 14-bit data
+#define SSI_CR0_DSS_15          0x0000000E  // 15-bit data
+#define SSI_CR0_DSS_16          0x0000000F  // 16-bit data
+#define SSI_CR0_SCR_S           8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR1 register.
+//
+//*****************************************************************************
+#define SSI_CR1_SOD             0x00000008  // SSI Slave Mode Output Disable.
+#define SSI_CR1_MS              0x00000004  // SSI Master/Slave Select.
+#define SSI_CR1_SSE             0x00000002  // SSI Synchronous Serial Port
+                                            // Enable.
+#define SSI_CR1_LBM             0x00000001  // SSI Loopback Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DR register.
+//
+//*****************************************************************************
+#define SSI_DR_DATA_M           0x0000FFFF  // SSI Receive/Transmit Data.
+#define SSI_DR_DATA_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_SR register.
+//
+//*****************************************************************************
+#define SSI_SR_BSY              0x00000010  // SSI Busy Bit.
+#define SSI_SR_RFF              0x00000008  // SSI Receive FIFO Full.
+#define SSI_SR_RNE              0x00000004  // SSI Receive FIFO Not Empty.
+#define SSI_SR_TNF              0x00000002  // SSI Transmit FIFO Not Full.
+#define SSI_SR_TFE              0x00000001  // SSI Transmit FIFO Empty.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CPSR register.
+//
+//*****************************************************************************
+#define SSI_CPSR_CPSDVSR_M      0x000000FF  // SSI Clock Prescale Divisor.
+#define SSI_CPSR_CPSDVSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_IM register.
+//
+//*****************************************************************************
+#define SSI_IM_TXIM             0x00000008  // SSI Transmit FIFO Interrupt
+                                            // Mask.
+#define SSI_IM_RXIM             0x00000004  // SSI Receive FIFO Interrupt Mask.
+#define SSI_IM_RTIM             0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Mask.
+#define SSI_IM_RORIM            0x00000001  // SSI Receive Overrun Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_RIS register.
+//
+//*****************************************************************************
+#define SSI_RIS_TXRIS           0x00000008  // SSI Transmit FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RXRIS           0x00000004  // SSI Receive FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RTRIS           0x00000002  // SSI Receive Time-Out Raw
+                                            // Interrupt Status.
+#define SSI_RIS_RORRIS          0x00000001  // SSI Receive Overrun Raw
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_MIS register.
+//
+//*****************************************************************************
+#define SSI_MIS_TXMIS           0x00000008  // SSI Transmit FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RXMIS           0x00000004  // SSI Receive FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RTMIS           0x00000002  // SSI Receive Time-Out Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RORMIS          0x00000001  // SSI Receive Overrun Masked
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_ICR register.
+//
+//*****************************************************************************
+#define SSI_ICR_RTIC            0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Clear.
+#define SSI_ICR_RORIC           0x00000001  // SSI Receive Overrun Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DR register.
+//
+//*****************************************************************************
+#define UART_DR_OE              0x00000800  // UART Overrun Error.
+#define UART_DR_BE              0x00000400  // UART Break Error.
+#define UART_DR_PE              0x00000200  // UART Parity Error.
+#define UART_DR_FE              0x00000100  // UART Framing Error.
+#define UART_DR_DATA_M          0x000000FF  // Data Transmitted or Received.
+#define UART_DR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RSR register.
+//
+//*****************************************************************************
+#define UART_RSR_OE             0x00000008  // UART Overrun Error.
+#define UART_RSR_BE             0x00000004  // UART Break Error.
+#define UART_RSR_PE             0x00000002  // UART Parity Error.
+#define UART_RSR_FE             0x00000001  // UART Framing Error.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ECR register.
+//
+//*****************************************************************************
+#define UART_ECR_DATA_M         0x000000FF  // Error Clear.
+#define UART_ECR_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FR register.
+//
+//*****************************************************************************
+#define UART_FR_TXFE            0x00000080  // UART Transmit FIFO Empty.
+#define UART_FR_RXFF            0x00000040  // UART Receive FIFO Full.
+#define UART_FR_TXFF            0x00000020  // UART Transmit FIFO Full.
+#define UART_FR_RXFE            0x00000010  // UART Receive FIFO Empty.
+#define UART_FR_BUSY            0x00000008  // UART Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ILPR register.
+//
+//*****************************************************************************
+#define UART_ILPR_ILPDVSR_M     0x000000FF  // IrDA Low-Power Divisor.
+#define UART_ILPR_ILPDVSR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IBRD register.
+//
+//*****************************************************************************
+#define UART_IBRD_DIVINT_M      0x0000FFFF  // Integer Baud-Rate Divisor.
+#define UART_IBRD_DIVINT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FBRD register.
+//
+//*****************************************************************************
+#define UART_FBRD_DIVFRAC_M     0x0000003F  // Fractional Baud-Rate Divisor.
+#define UART_FBRD_DIVFRAC_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCRH register.
+//
+//*****************************************************************************
+#define UART_LCRH_SPS           0x00000080  // UART Stick Parity Select.
+#define UART_LCRH_WLEN_M        0x00000060  // UART Word Length.
+#define UART_LCRH_WLEN_5        0x00000000  // 5 bits (default)
+#define UART_LCRH_WLEN_6        0x00000020  // 6 bits
+#define UART_LCRH_WLEN_7        0x00000040  // 7 bits
+#define UART_LCRH_WLEN_8        0x00000060  // 8 bits
+#define UART_LCRH_FEN           0x00000010  // UART Enable FIFOs.
+#define UART_LCRH_STP2          0x00000008  // UART Two Stop Bits Select.
+#define UART_LCRH_EPS           0x00000004  // UART Even Parity Select.
+#define UART_LCRH_PEN           0x00000002  // UART Parity Enable.
+#define UART_LCRH_BRK           0x00000001  // UART Send Break.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_CTL register.
+//
+//*****************************************************************************
+#define UART_CTL_RXE            0x00000200  // UART Receive Enable.
+#define UART_CTL_TXE            0x00000100  // UART Transmit Enable.
+#define UART_CTL_LBE            0x00000080  // UART Loop Back Enable.
+#define UART_CTL_SIRLP          0x00000004  // UART SIR Low Power Mode.
+#define UART_CTL_SIREN          0x00000002  // UART SIR Enable.
+#define UART_CTL_UARTEN         0x00000001  // UART Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IFLS register.
+//
+//*****************************************************************************
+#define UART_IFLS_RX_M          0x00000038  // UART Receive Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_RX1_8         0x00000000  // RX FIFO &lt;= 1/8 full
+#define UART_IFLS_RX2_8         0x00000008  // RX FIFO &lt;= 1/4 full
+#define UART_IFLS_RX4_8         0x00000010  // RX FIFO &lt;= 1/2 full (default)
+#define UART_IFLS_RX6_8         0x00000018  // RX FIFO &lt;= 3/4 full
+#define UART_IFLS_RX7_8         0x00000020  // RX FIFO &lt;= 7/8 full
+#define UART_IFLS_TX_M          0x00000007  // UART Transmit Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_TX1_8         0x00000000  // TX FIFO &gt;= 1/8 full
+#define UART_IFLS_TX2_8         0x00000001  // TX FIFO &gt;= 1/4 full
+#define UART_IFLS_TX4_8         0x00000002  // TX FIFO &gt;= 1/2 full (default)
+#define UART_IFLS_TX6_8         0x00000003  // TX FIFO &gt;= 3/4 full
+#define UART_IFLS_TX7_8         0x00000004  // TX FIFO &gt;= 7/8 full
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IM register.
+//
+//*****************************************************************************
+#define UART_IM_OEIM            0x00000400  // UART Overrun Error Interrupt
+                                            // Mask.
+#define UART_IM_BEIM            0x00000200  // UART Break Error Interrupt Mask.
+#define UART_IM_PEIM            0x00000100  // UART Parity Error Interrupt
+                                            // Mask.
+#define UART_IM_FEIM            0x00000080  // UART Framing Error Interrupt
+                                            // Mask.
+#define UART_IM_RTIM            0x00000040  // UART Receive Time-Out Interrupt
+                                            // Mask.
+#define UART_IM_TXIM            0x00000020  // UART Transmit Interrupt Mask.
+#define UART_IM_RXIM            0x00000010  // UART Receive Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RIS register.
+//
+//*****************************************************************************
+#define UART_RIS_OERIS          0x00000400  // UART Overrun Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_BERIS          0x00000200  // UART Break Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_PERIS          0x00000100  // UART Parity Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_FERIS          0x00000080  // UART Framing Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_RTRIS          0x00000040  // UART Receive Time-Out Raw
+                                            // Interrupt Status.
+#define UART_RIS_TXRIS          0x00000020  // UART Transmit Raw Interrupt
+                                            // Status.
+#define UART_RIS_RXRIS          0x00000010  // UART Receive Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_MIS register.
+//
+//*****************************************************************************
+#define UART_MIS_OEMIS          0x00000400  // UART Overrun Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_BEMIS          0x00000200  // UART Break Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_PEMIS          0x00000100  // UART Parity Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_FEMIS          0x00000080  // UART Framing Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_RTMIS          0x00000040  // UART Receive Time-Out Masked
+                                            // Interrupt Status.
+#define UART_MIS_TXMIS          0x00000020  // UART Transmit Masked Interrupt
+                                            // Status.
+#define UART_MIS_RXMIS          0x00000010  // UART Receive Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ICR register.
+//
+//*****************************************************************************
+#define UART_ICR_OEIC           0x00000400  // Overrun Error Interrupt Clear.
+#define UART_ICR_BEIC           0x00000200  // Break Error Interrupt Clear.
+#define UART_ICR_PEIC           0x00000100  // Parity Error Interrupt Clear.
+#define UART_ICR_FEIC           0x00000080  // Framing Error Interrupt Clear.
+#define UART_ICR_RTIC           0x00000040  // Receive Time-Out Interrupt
+                                            // Clear.
+#define UART_ICR_TXIC           0x00000020  // Transmit Interrupt Clear.
+#define UART_ICR_RXIC           0x00000010  // Receive Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MSA register.
+//
+//*****************************************************************************
+#define I2C_MSA_SA_M            0x000000FE  // I2C Slave Address.
+#define I2C_MSA_RS              0x00000001  // Receive not send.
+#define I2C_MSA_SA_S            1
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SOAR register.
+//
+//*****************************************************************************
+#define I2C_SOAR_OAR_M          0x0000007F  // I2C Slave Own Address.
+#define I2C_SOAR_OAR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SCSR register.
+//
+//*****************************************************************************
+#define I2C_SCSR_FBR            0x00000004  // First Byte Received.
+#define I2C_SCSR_TREQ           0x00000002  // Transmit Request.
+#define I2C_SCSR_DA             0x00000001  // Device Active.
+#define I2C_SCSR_RREQ           0x00000001  // Receive Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCS register.
+//
+//*****************************************************************************
+#define I2C_MCS_BUSBSY          0x00000040  // Bus Busy.
+#define I2C_MCS_IDLE            0x00000020  // I2C Idle.
+#define I2C_MCS_ARBLST          0x00000010  // Arbitration Lost.
+#define I2C_MCS_ACK             0x00000008  // Data Acknowledge Enable.
+#define I2C_MCS_DATACK          0x00000008  // Acknowledge Data.
+#define I2C_MCS_ADRACK          0x00000004  // Acknowledge Address.
+#define I2C_MCS_STOP            0x00000004  // Generate STOP.
+#define I2C_MCS_START           0x00000002  // Generate START.
+#define I2C_MCS_ERROR           0x00000002  // Error.
+#define I2C_MCS_RUN             0x00000001  // I2C Master Enable.
+#define I2C_MCS_BUSY            0x00000001  // I2C Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SDR register.
+//
+//*****************************************************************************
+#define I2C_SDR_DATA_M          0x000000FF  // Data for Transfer.
+#define I2C_SDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MDR register.
+//
+//*****************************************************************************
+#define I2C_MDR_DATA_M          0x000000FF  // Data Transferred.
+#define I2C_MDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MTPR register.
+//
+//*****************************************************************************
+#define I2C_MTPR_TPR_M          0x000000FF  // SCL Clock Period.
+#define I2C_MTPR_TPR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SIMR register.
+//
+//*****************************************************************************
+#define I2C_SIMR_IM             0x00000001  // Data Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SRIS register.
+//
+//*****************************************************************************
+#define I2C_SRIS_RIS            0x00000001  // Data Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MIMR register.
+//
+//*****************************************************************************
+#define I2C_MIMR_IM             0x00000001  // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MRIS register.
+//
+//*****************************************************************************
+#define I2C_MRIS_RIS            0x00000001  // Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SMIS register.
+//
+//*****************************************************************************
+#define I2C_SMIS_MIS            0x00000001  // Data Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SICR register.
+//
+//*****************************************************************************
+#define I2C_SICR_IC             0x00000001  // Data Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MMIS register.
+//
+//*****************************************************************************
+#define I2C_MMIS_MIS            0x00000001  // Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MICR register.
+//
+//*****************************************************************************
+#define I2C_MICR_IC             0x00000001  // Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCR register.
+//
+//*****************************************************************************
+#define I2C_MCR_SFE             0x00000020  // I2C Slave Function Enable.
+#define I2C_MCR_MFE             0x00000010  // I2C Master Function Enable.
+#define I2C_MCR_LPBK            0x00000001  // I2C Loopback.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_CTL register.
+//
+//*****************************************************************************
+#define PWM_CTL_GLOBALSYNC2     0x00000004  // Update PWM Generator 2.
+#define PWM_CTL_GLOBALSYNC1     0x00000002  // Update PWM Generator 1.
+#define PWM_CTL_GLOBALSYNC0     0x00000001  // Update PWM Generator 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_SYNC register.
+//
+//*****************************************************************************
+#define PWM_SYNC_SYNC2          0x00000004  // Reset Generator 2 Counter.
+#define PWM_SYNC_SYNC1          0x00000002  // Reset Generator 1 Counter.
+#define PWM_SYNC_SYNC0          0x00000001  // Reset Generator 0 Counter.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ENABLE register.
+//
+//*****************************************************************************
+#define PWM_ENABLE_PWM5EN       0x00000020  // PWM5 Output Enable.
+#define PWM_ENABLE_PWM4EN       0x00000010  // PWM4 Output Enable.
+#define PWM_ENABLE_PWM3EN       0x00000008  // PWM3 Output Enable.
+#define PWM_ENABLE_PWM2EN       0x00000004  // PWM2 Output Enable.
+#define PWM_ENABLE_PWM1EN       0x00000002  // PWM1 Output Enable.
+#define PWM_ENABLE_PWM0EN       0x00000001  // PWM0 Output Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INVERT register.
+//
+//*****************************************************************************
+#define PWM_INVERT_PWM5INV      0x00000020  // Invert PWM5 Signal.
+#define PWM_INVERT_PWM4INV      0x00000010  // Invert PWM4 Signal.
+#define PWM_INVERT_PWM3INV      0x00000008  // Invert PWM3 Signal.
+#define PWM_INVERT_PWM2INV      0x00000004  // Invert PWM2 Signal.
+#define PWM_INVERT_PWM1INV      0x00000002  // Invert PWM1 Signal.
+#define PWM_INVERT_PWM0INV      0x00000001  // Invert PWM0 Signal.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_FAULT register.
+//
+//*****************************************************************************
+#define PWM_FAULT_FAULT5        0x00000020  // PWM5 Fault.
+#define PWM_FAULT_FAULT4        0x00000010  // PWM4 Fault.
+#define PWM_FAULT_FAULT3        0x00000008  // PWM3 Fault.
+#define PWM_FAULT_FAULT2        0x00000004  // PWM2 Fault.
+#define PWM_FAULT_FAULT1        0x00000002  // PWM1 Fault.
+#define PWM_FAULT_FAULT0        0x00000001  // PWM0 Fault.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INTEN register.
+//
+//*****************************************************************************
+#define PWM_INTEN_INTFAULT      0x00010000  // Fault Interrupt Enable.
+#define PWM_INTEN_INTPWM2       0x00000004  // PWM2 Interrupt Enable.
+#define PWM_INTEN_INTPWM1       0x00000002  // PWM1 Interrupt Enable.
+#define PWM_INTEN_INTPWM0       0x00000001  // PWM0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_RIS register.
+//
+//*****************************************************************************
+#define PWM_RIS_INTFAULT        0x00010000  // Fault Interrupt Asserted.
+#define PWM_RIS_INTPWM2         0x00000004  // PWM2 Interrupt Asserted.
+#define PWM_RIS_INTPWM1         0x00000002  // PWM1 Interrupt Asserted.
+#define PWM_RIS_INTPWM0         0x00000001  // PWM0 Interrupt Asserted.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ISC register.
+//
+//*****************************************************************************
+#define PWM_ISC_INTFAULT        0x00010000  // Fault Interrupt Asserted.
+#define PWM_ISC_INTPWM2         0x00000004  // PWM2 Interrupt Status.
+#define PWM_ISC_INTPWM1         0x00000002  // PWM1 Interrupt Status.
+#define PWM_ISC_INTPWM0         0x00000001  // PWM0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_STATUS register.
+//
+//*****************************************************************************
+#define PWM_STATUS_FAULT        0x00000001  // Fault Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CTL,
+// PWM_O_1_CTL, and PWM_O_2_CTL registers.
+//
+//*****************************************************************************
+#define PWM_X_CTL_CMPBUPD       0x00000020  // Comparator B Update Mode.
+#define PWM_X_CTL_CMPAUPD       0x00000010  // Comparator A Update Mode.
+#define PWM_X_CTL_LOADUPD       0x00000008  // Load Register Update Mode.
+#define PWM_X_CTL_DEBUG         0x00000004  // Debug Mode.
+#define PWM_X_CTL_MODE          0x00000002  // Counter Mode.
+#define PWM_X_CTL_ENABLE        0x00000001  // PWM Block Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_INTEN,
+// PWM_O_1_INTEN, and PWM_O_2_INTEN registers.
+//
+//*****************************************************************************
+#define PWM_X_INTEN_TRCMPBD     0x00002000  // Trigger for Counter=Comparator B
+                                            // Down.
+#define PWM_X_INTEN_TRCMPBU     0x00001000  // Trigger for Counter=Comparator B
+                                            // Up.
+#define PWM_X_INTEN_TRCMPAD     0x00000800  // Trigger for Counter=Comparator A
+                                            // Down.
+#define PWM_X_INTEN_TRCMPAU     0x00000400  // Trigger for Counter=Comparator A
+                                            // Up.
+#define PWM_X_INTEN_TRCNTLOAD   0x00000200  // Trigger for Counter=Load.
+#define PWM_X_INTEN_TRCNTZERO   0x00000100  // Trigger for Counter=0.
+#define PWM_X_INTEN_INTCMPBD    0x00000020  // Interrupt for Counter=Comparator
+                                            // B Down.
+#define PWM_X_INTEN_INTCMPBU    0x00000010  // Interrupt for Counter=Comparator
+                                            // B Up.
+#define PWM_X_INTEN_INTCMPAD    0x00000008  // Interrupt for Counter=Comparator
+                                            // A Down.
+#define PWM_X_INTEN_INTCMPAU    0x00000004  // Interrupt for Counter=Comparator
+                                            // A Up.
+#define PWM_X_INTEN_INTCNTLOAD  0x00000002  // Interrupt for Counter=Load.
+#define PWM_X_INTEN_INTCNTZERO  0x00000001  // Interrupt for Counter=0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_RIS,
+// PWM_O_1_RIS, and PWM_O_2_RIS registers.
+//
+//*****************************************************************************
+#define PWM_X_RIS_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPBU      0x00000010  // Comparator B Up Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPAU      0x00000004  // Comparator A Up Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCNTLOAD    0x00000002  // Counter=Load Interrupt Status.
+#define PWM_X_RIS_INTCNTZERO    0x00000001  // Counter=0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_ISC,
+// PWM_O_1_ISC, and PWM_O_2_ISC registers.
+//
+//*****************************************************************************
+#define PWM_X_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt.
+#define PWM_X_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt.
+#define PWM_X_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt.
+#define PWM_X_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt.
+#define PWM_X_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt.
+#define PWM_X_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_LOAD,
+// PWM_O_1_LOAD, and PWM_O_2_LOAD registers.
+//
+//*****************************************************************************
+#define PWM_X_LOAD_M            0x0000FFFF  // Counter Load Value.
+#define PWM_X_LOAD_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_COUNT,
+// PWM_O_1_COUNT, and PWM_O_2_COUNT registers.
+//
+//*****************************************************************************
+#define PWM_X_COUNT_M           0x0000FFFF  // Counter Value.
+#define PWM_X_COUNT_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPA,
+// PWM_O_1_CMPA, and PWM_O_2_CMPA registers.
+//
+//*****************************************************************************
+#define PWM_X_CMPA_M            0x0000FFFF  // Comparator A Value.
+#define PWM_X_CMPA_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPB,
+// PWM_O_1_CMPB, and PWM_O_2_CMPB registers.
+//
+//*****************************************************************************
+#define PWM_X_CMPB_M            0x0000FFFF  // Comparator B Value.
+#define PWM_X_CMPB_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENA,
+// PWM_O_1_GENA, and PWM_O_2_GENA registers.
+//
+//*****************************************************************************
+#define PWM_X_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENA_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENA_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENA_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENA_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENA_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENA_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENA_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENA_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENA_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENA_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENA_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENB,
+// PWM_O_1_GENB, and PWM_O_2_GENB registers.
+//
+//*****************************************************************************
+#define PWM_X_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENB_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENB_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENB_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENB_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENB_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENB_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENB_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENB_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENB_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENB_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENB_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBCTL,
+// PWM_O_1_DBCTL, and PWM_O_2_DBCTL registers.
+//
+//*****************************************************************************
+#define PWM_X_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBRISE,
+// PWM_O_1_DBRISE, and PWM_O_2_DBRISE registers.
+//
+//*****************************************************************************
+#define PWM_X_DBRISE_DELAY_M    0x00000FFF  // Dead-Band Rise Delay.
+#define PWM_X_DBRISE_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBFALL,
+// PWM_O_1_DBFALL, and PWM_O_2_DBFALL registers.
+//
+//*****************************************************************************
+#define PWM_X_DBFALL_DELAY_M    0x00000FFF  // Dead-Band Fall Delay.
+#define PWM_X_DBFALL_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_CTL register.
+//
+//*****************************************************************************
+#define QEI_CTL_STALLEN         0x00001000  // Stall QEI.
+#define QEI_CTL_INVI            0x00000800  // Invert Index Pulse.
+#define QEI_CTL_INVB            0x00000400  // Invert PhB.
+#define QEI_CTL_INVA            0x00000200  // Invert PhA.
+#define QEI_CTL_VELDIV_M        0x000001C0  // Predivide Velocity.
+#define QEI_CTL_VELDIV_1        0x00000000  // /1
+#define QEI_CTL_VELDIV_2        0x00000040  // /2
+#define QEI_CTL_VELDIV_4        0x00000080  // /4
+#define QEI_CTL_VELDIV_8        0x000000C0  // /8
+#define QEI_CTL_VELDIV_16       0x00000100  // /16
+#define QEI_CTL_VELDIV_32       0x00000140  // /32
+#define QEI_CTL_VELDIV_64       0x00000180  // /64
+#define QEI_CTL_VELDIV_128      0x000001C0  // /128
+#define QEI_CTL_VELEN           0x00000020  // Capture Velocity.
+#define QEI_CTL_RESMODE         0x00000010  // Reset Mode.
+#define QEI_CTL_CAPMODE         0x00000008  // Capture Mode.
+#define QEI_CTL_SIGMODE         0x00000004  // Signal Mode.
+#define QEI_CTL_SWAP            0x00000002  // Swap Signals.
+#define QEI_CTL_ENABLE          0x00000001  // Enable QEI.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_STAT register.
+//
+//*****************************************************************************
+#define QEI_STAT_DIRECTION      0x00000002  // Direction of Rotation.
+#define QEI_STAT_ERROR          0x00000001  // Error Detected.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_POS register.
+//
+//*****************************************************************************
+#define QEI_POS_M               0xFFFFFFFF  // Current Position Integrator
+                                            // Value.
+#define QEI_POS_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_MAXPOS register.
+//
+//*****************************************************************************
+#define QEI_MAXPOS_M            0xFFFFFFFF  // Maximum Position Integrator
+                                            // Value.
+#define QEI_MAXPOS_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_LOAD register.
+//
+//*****************************************************************************
+#define QEI_LOAD_M              0xFFFFFFFF  // Velocity Timer Load Value.
+#define QEI_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_TIME register.
+//
+//*****************************************************************************
+#define QEI_TIME_M              0xFFFFFFFF  // Velocity Timer Current Value.
+#define QEI_TIME_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_COUNT register.
+//
+//*****************************************************************************
+#define QEI_COUNT_M             0xFFFFFFFF  // Velocity Pulse Count.
+#define QEI_COUNT_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_SPEED register.
+//
+//*****************************************************************************
+#define QEI_SPEED_M             0xFFFFFFFF  // Velocity.
+#define QEI_SPEED_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_INTEN register.
+//
+//*****************************************************************************
+#define QEI_INTEN_ERROR         0x00000008  // Phase Error Interrupt Enable.
+#define QEI_INTEN_DIR           0x00000004  // Direction Change Interrupt
+                                            // Enable.
+#define QEI_INTEN_TIMER         0x00000002  // Timer Expires Interrupt Enable.
+#define QEI_INTEN_INDEX         0x00000001  // Index Pulse Detected Interrupt
+                                            // Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_RIS register.
+//
+//*****************************************************************************
+#define QEI_RIS_ERROR           0x00000008  // Phase Error Detected.
+#define QEI_RIS_DIR             0x00000004  // Direction Change Detected.
+#define QEI_RIS_TIMER           0x00000002  // Velocity Timer Expired.
+#define QEI_RIS_INDEX           0x00000001  // Index Pulse Asserted.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_ISC register.
+//
+//*****************************************************************************
+#define QEI_ISC_ERROR           0x00000008  // Phase Error Interrupt.
+#define QEI_ISC_DIR             0x00000004  // Direction Change Interrupt.
+#define QEI_ISC_TIMER           0x00000002  // Velocity Timer Expired
+                                            // Interrupt.
+#define QEI_ISC_INDEX           0x00000001  // Index Pulse Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CFG register.
+//
+//*****************************************************************************
+#define TIMER_CFG_M             0x00000007  // GPTM Configuration.
+#define TIMER_CFG_32_BIT_TIMER  0x00000000  // 32-bit timer configuration.
+#define TIMER_CFG_32_BIT_RTC    0x00000001  // 32-bit real-time clock (RTC)
+                                            // counter configuration.
+#define TIMER_CFG_16_BIT        0x00000004  // 16-bit timer configuration,
+                                            // function is controlled by bits
+                                            // 1:0 of GPTMTAMR and GPTMTBMR.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMR register.
+//
+//*****************************************************************************
+#define TIMER_TAMR_TAAMS        0x00000008  // GPTM TimerA Alternate Mode
+                                            // Select.
+#define TIMER_TAMR_TACMR        0x00000004  // GPTM TimerA Capture Mode.
+#define TIMER_TAMR_TAMR_M       0x00000003  // GPTM TimerA Mode.
+#define TIMER_TAMR_TAMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TAMR_TAMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TAMR_TAMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMR register.
+//
+//*****************************************************************************
+#define TIMER_TBMR_TBAMS        0x00000008  // GPTM TimerB Alternate Mode
+                                            // Select.
+#define TIMER_TBMR_TBCMR        0x00000004  // GPTM TimerB Capture Mode.
+#define TIMER_TBMR_TBMR_M       0x00000003  // GPTM TimerB Mode.
+#define TIMER_TBMR_TBMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TBMR_TBMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TBMR_TBMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CTL register.
+//
+//*****************************************************************************
+#define TIMER_CTL_TBPWML        0x00004000  // GPTM TimerB PWM Output Level.
+#define TIMER_CTL_TBOTE         0x00002000  // GPTM TimerB Output Trigger
+                                            // Enable.
+#define TIMER_CTL_TBEVENT_M     0x00000C00  // GPTM TimerB Event Mode.
+#define TIMER_CTL_TBEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TBEVENT_NEG   0x00000400  // Negative edge
+#define TIMER_CTL_TBEVENT_BOTH  0x00000C00  // Both edges
+#define TIMER_CTL_TBSTALL       0x00000200  // GPTM TimerB Stall Enable.
+#define TIMER_CTL_TBEN          0x00000100  // GPTM TimerB Enable.
+#define TIMER_CTL_TAPWML        0x00000040  // GPTM TimerA PWM Output Level.
+#define TIMER_CTL_TAOTE         0x00000020  // GPTM TimerA Output Trigger
+                                            // Enable.
+#define TIMER_CTL_RTCEN         0x00000010  // GPTM RTC Enable.
+#define TIMER_CTL_TAEVENT_M     0x0000000C  // GPTM TimerA Event Mode.
+#define TIMER_CTL_TAEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TAEVENT_NEG   0x00000004  // Negative edge
+#define TIMER_CTL_TAEVENT_BOTH  0x0000000C  // Both edges
+#define TIMER_CTL_TASTALL       0x00000002  // GPTM TimerA Stall Enable.
+#define TIMER_CTL_TAEN          0x00000001  // GPTM TimerA Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_IMR register.
+//
+//*****************************************************************************
+#define TIMER_IMR_CBEIM         0x00000400  // GPTM CaptureB Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CBMIM         0x00000200  // GPTM CaptureB Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TBTOIM        0x00000100  // GPTM TimerB Time-Out Interrupt
+                                            // Mask.
+#define TIMER_IMR_RTCIM         0x00000008  // GPTM RTC Interrupt Mask.
+#define TIMER_IMR_CAEIM         0x00000004  // GPTM CaptureA Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CAMIM         0x00000002  // GPTM CaptureA Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TATOIM        0x00000001  // GPTM TimerA Time-Out Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_RIS register.
+//
+//*****************************************************************************
+#define TIMER_RIS_CBERIS        0x00000400  // GPTM CaptureB Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CBMRIS        0x00000200  // GPTM CaptureB Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TBTORIS       0x00000100  // GPTM TimerB Time-Out Raw
+                                            // Interrupt.
+#define TIMER_RIS_RTCRIS        0x00000008  // GPTM RTC Raw Interrupt.
+#define TIMER_RIS_CAERIS        0x00000004  // GPTM CaptureA Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CAMRIS        0x00000002  // GPTM CaptureA Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TATORIS       0x00000001  // GPTM TimerA Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_MIS register.
+//
+//*****************************************************************************
+#define TIMER_MIS_CBEMIS        0x00000400  // GPTM CaptureB Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CBMMIS        0x00000200  // GPTM CaptureB Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TBTOMIS       0x00000100  // GPTM TimerB Time-Out Masked
+                                            // Interrupt.
+#define TIMER_MIS_RTCMIS        0x00000008  // GPTM RTC Masked Interrupt.
+#define TIMER_MIS_CAEMIS        0x00000004  // GPTM CaptureA Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CAMMIS        0x00000002  // GPTM CaptureA Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TATOMIS       0x00000001  // GPTM TimerA Time-Out Masked
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_ICR register.
+//
+//*****************************************************************************
+#define TIMER_ICR_CBECINT       0x00000400  // GPTM CaptureB Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CBMCINT       0x00000200  // GPTM CaptureB Match Interrupt
+                                            // Clear.
+#define TIMER_ICR_TBTOCINT      0x00000100  // GPTM TimerB Time-Out Interrupt
+                                            // Clear.
+#define TIMER_ICR_RTCCINT       0x00000008  // GPTM RTC Interrupt Clear.
+#define TIMER_ICR_CAECINT       0x00000004  // GPTM CaptureA Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CAMCINT       0x00000002  // GPTM CaptureA Match Raw
+                                            // Interrupt.
+#define TIMER_ICR_TATOCINT      0x00000001  // GPTM TimerA Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAILR register.
+//
+//*****************************************************************************
+#define TIMER_TAILR_TAILRH_M    0xFFFF0000  // GPTM TimerA Interval Load
+                                            // Register High.
+#define TIMER_TAILR_TAILRL_M    0x0000FFFF  // GPTM TimerA Interval Load
+                                            // Register Low.
+#define TIMER_TAILR_TAILRH_S    16
+#define TIMER_TAILR_TAILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBILR register.
+//
+//*****************************************************************************
+#define TIMER_TBILR_TBILRL_M    0x0000FFFF  // GPTM TimerB Interval Load
+                                            // Register.
+#define TIMER_TBILR_TBILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TAMATCHR_TAMRH_M  0xFFFF0000  // GPTM TimerA Match Register High.
+#define TIMER_TAMATCHR_TAMRL_M  0x0000FFFF  // GPTM TimerA Match Register Low.
+#define TIMER_TAMATCHR_TAMRH_S  16
+#define TIMER_TAMATCHR_TAMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TBMATCHR_TBMRL_M  0x0000FFFF  // GPTM TimerB Match Register Low.
+#define TIMER_TBMATCHR_TBMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPR register.
+//
+//*****************************************************************************
+#define TIMER_TAPR_TAPSR_M      0x000000FF  // GPTM TimerA Prescale.
+#define TIMER_TAPR_TAPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPR register.
+//
+//*****************************************************************************
+#define TIMER_TBPR_TBPSR_M      0x000000FF  // GPTM TimerB Prescale.
+#define TIMER_TBPR_TBPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPMR register.
+//
+//*****************************************************************************
+#define TIMER_TAPMR_TAPSMR_M    0x000000FF  // GPTM TimerA Prescale Match.
+#define TIMER_TAPMR_TAPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPMR register.
+//
+//*****************************************************************************
+#define TIMER_TBPMR_TBPSMR_M    0x000000FF  // GPTM TimerB Prescale Match.
+#define TIMER_TBPMR_TBPSMR_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAR register.
+//
+//*****************************************************************************
+#define TIMER_TAR_TARH_M        0xFFFF0000  // GPTM TimerA Register High.
+#define TIMER_TAR_TARL_M        0x0000FFFF  // GPTM TimerA Register Low.
+#define TIMER_TAR_TARH_S        16
+#define TIMER_TAR_TARL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBR register.
+//
+//*****************************************************************************
+#define TIMER_TBR_TBRL_M        0x0000FFFF  // GPTM TimerB.
+#define TIMER_TBR_TBRL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ACTSS register.
+//
+//*****************************************************************************
+#define ADC_ACTSS_ASEN3         0x00000008  // ADC SS3 Enable.
+#define ADC_ACTSS_ASEN2         0x00000004  // ADC SS2 Enable.
+#define ADC_ACTSS_ASEN1         0x00000002  // ADC SS1 Enable.
+#define ADC_ACTSS_ASEN0         0x00000001  // ADC SS0 Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_RIS register.
+//
+//*****************************************************************************
+#define ADC_RIS_INR3            0x00000008  // SS3 Raw Interrupt Status.
+#define ADC_RIS_INR2            0x00000004  // SS2 Raw Interrupt Status.
+#define ADC_RIS_INR1            0x00000002  // SS1 Raw Interrupt Status.
+#define ADC_RIS_INR0            0x00000001  // SS0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_IM register.
+//
+//*****************************************************************************
+#define ADC_IM_MASK3            0x00000008  // SS3 Interrupt Mask.
+#define ADC_IM_MASK2            0x00000004  // SS2 Interrupt Mask.
+#define ADC_IM_MASK1            0x00000002  // SS1 Interrupt Mask.
+#define ADC_IM_MASK0            0x00000001  // SS0 Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ISC register.
+//
+//*****************************************************************************
+#define ADC_ISC_IN3             0x00000008  // SS3 Interrupt Status and Clear.
+#define ADC_ISC_IN2             0x00000004  // SS2 Interrupt Status and Clear.
+#define ADC_ISC_IN1             0x00000002  // SS1 Interrupt Status and Clear.
+#define ADC_ISC_IN0             0x00000001  // SS0 Interrupt Status and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_OSTAT register.
+//
+//*****************************************************************************
+#define ADC_OSTAT_OV3           0x00000008  // SS3 FIFO Overflow.
+#define ADC_OSTAT_OV2           0x00000004  // SS2 FIFO Overflow.
+#define ADC_OSTAT_OV1           0x00000002  // SS1 FIFO Overflow.
+#define ADC_OSTAT_OV0           0x00000001  // SS0 FIFO Overflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_EMUX register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_M          0x0000F000  // SS3 Trigger Select.
+#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog Comparator 0
+#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External (GPIO PB4)
+#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer
+#define ADC_EMUX_EM3_PWM0       0x00006000  // PWM0
+#define ADC_EMUX_EM3_PWM1       0x00007000  // PWM1
+#define ADC_EMUX_EM3_PWM2       0x00008000  // PWM2
+#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always (continuously sample)
+#define ADC_EMUX_EM2_M          0x00000F00  // SS2 Trigger Select.
+#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog Comparator 0
+#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External (GPIO PB4)
+#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer
+#define ADC_EMUX_EM2_PWM0       0x00000600  // PWM0
+#define ADC_EMUX_EM2_PWM1       0x00000700  // PWM1
+#define ADC_EMUX_EM2_PWM2       0x00000800  // PWM2
+#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always (continuously sample)
+#define ADC_EMUX_EM1_M          0x000000F0  // SS1 Trigger Select.
+#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog Comparator 0
+#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External (GPIO PB4)
+#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer
+#define ADC_EMUX_EM1_PWM0       0x00000060  // PWM0
+#define ADC_EMUX_EM1_PWM1       0x00000070  // PWM1
+#define ADC_EMUX_EM1_PWM2       0x00000080  // PWM2
+#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always (continuously sample)
+#define ADC_EMUX_EM0_M          0x0000000F  // SS0 Trigger Select.
+#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Controller (default)
+#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog Comparator 0
+#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External (GPIO PB4)
+#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer
+#define ADC_EMUX_EM0_PWM0       0x00000006  // PWM0
+#define ADC_EMUX_EM0_PWM1       0x00000007  // PWM1
+#define ADC_EMUX_EM0_PWM2       0x00000008  // PWM2
+#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always (continuously sample)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_USTAT register.
+//
+//*****************************************************************************
+#define ADC_USTAT_UV3           0x00000008  // SS3 FIFO Underflow.
+#define ADC_USTAT_UV2           0x00000004  // SS2 FIFO Underflow.
+#define ADC_USTAT_UV1           0x00000002  // SS1 FIFO Underflow.
+#define ADC_USTAT_UV0           0x00000001  // SS0 FIFO Underflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSPRI register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_M         0x00003000  // SS3 Priority.
+#define ADC_SSPRI_SS3_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS3_2ND       0x00001000  // Second priority
+#define ADC_SSPRI_SS3_3RD       0x00002000  // Third priority
+#define ADC_SSPRI_SS3_4TH       0x00003000  // Fourth priority
+#define ADC_SSPRI_SS2_M         0x00000300  // SS2 Priority.
+#define ADC_SSPRI_SS2_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS2_2ND       0x00000100  // Second priority
+#define ADC_SSPRI_SS2_3RD       0x00000200  // Third priority
+#define ADC_SSPRI_SS2_4TH       0x00000300  // Fourth priority
+#define ADC_SSPRI_SS1_M         0x00000030  // SS1 Priority.
+#define ADC_SSPRI_SS1_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS1_2ND       0x00000010  // Second priority
+#define ADC_SSPRI_SS1_3RD       0x00000020  // Third priority
+#define ADC_SSPRI_SS1_4TH       0x00000030  // Fourth priority
+#define ADC_SSPRI_SS0_M         0x00000003  // SS0 Priority.
+#define ADC_SSPRI_SS0_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS0_2ND       0x00000001  // Second priority
+#define ADC_SSPRI_SS0_3RD       0x00000002  // Third priority
+#define ADC_SSPRI_SS0_4TH       0x00000003  // Fourth priority
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_PSSI register.
+//
+//*****************************************************************************
+#define ADC_PSSI_SS3            0x00000008  // SS3 Initiate.
+#define ADC_PSSI_SS2            0x00000004  // SS2 Initiate.
+#define ADC_PSSI_SS1            0x00000002  // SS1 Initiate.
+#define ADC_PSSI_SS0            0x00000001  // SS0 Initiate.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SAC register.
+//
+//*****************************************************************************
+#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control.
+#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
+#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
+#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
+#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
+#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
+#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
+#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX0_MUX7_M       0x30000000  // 8th Sample Input Select.
+#define ADC_SSMUX0_MUX6_M       0x03000000  // 7th Sample Input Select.
+#define ADC_SSMUX0_MUX5_M       0x00300000  // 6th Sample Input Select.
+#define ADC_SSMUX0_MUX4_M       0x00030000  // 5th Sample Input Select.
+#define ADC_SSMUX0_MUX3_M       0x00003000  // 4th Sample Input Select.
+#define ADC_SSMUX0_MUX2_M       0x00000300  // 3rd Sample Input Select.
+#define ADC_SSMUX0_MUX1_M       0x00000030  // 2nd Sample Input Select.
+#define ADC_SSMUX0_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX0_MUX7_S       28
+#define ADC_SSMUX0_MUX6_S       24
+#define ADC_SSMUX0_MUX5_S       20
+#define ADC_SSMUX0_MUX4_S       16
+#define ADC_SSMUX0_MUX3_S       12
+#define ADC_SSMUX0_MUX2_S       8
+#define ADC_SSMUX0_MUX1_S       4
+#define ADC_SSMUX0_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable.
+#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence.
+#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Diff Input Select.
+#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable.
+#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence.
+#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Diff Input Select.
+#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable.
+#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence.
+#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Diff Input Select.
+#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable.
+#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence.
+#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Diff Input Select.
+#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO0_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT0_HPTR_S     4
+#define ADC_SSFSTAT0_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX1_MUX3_M       0x00003000  // 4th Sample Input Select.
+#define ADC_SSMUX1_MUX2_M       0x00000300  // 3rd Sample Input Select.
+#define ADC_SSMUX1_MUX1_M       0x00000030  // 2nd Sample Input Select.
+#define ADC_SSMUX1_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX1_MUX3_S       12
+#define ADC_SSMUX1_MUX2_S       8
+#define ADC_SSMUX1_MUX1_S       4
+#define ADC_SSMUX1_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO1_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT1_HPTR_S     4
+#define ADC_SSFSTAT1_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX2_MUX3_M       0x00003000  // 4th Sample Input Select.
+#define ADC_SSMUX2_MUX2_M       0x00000300  // 3rd Sample Input Select.
+#define ADC_SSMUX2_MUX1_M       0x00000030  // 2nd Sample Input Select.
+#define ADC_SSMUX2_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX2_MUX3_S       12
+#define ADC_SSMUX2_MUX2_S       8
+#define ADC_SSMUX2_MUX1_S       4
+#define ADC_SSMUX2_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO2_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT2_HPTR_S     4
+#define ADC_SSFSTAT2_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX3_MUX0_M       0x00000003  // 1st Sample Input Select.
+#define ADC_SSMUX3_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL3_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL3_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL3_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO3_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT3_HPTR_S     4
+#define ADC_SSFSTAT3_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_TMLB register.
+//
+//*****************************************************************************
+#define ADC_TMLB_LB             0x00000001  // Loopback Mode Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_TMLB_CNT_M   0x000003C0  // Continuous Sample Counter.
+#define ADC_SSFIFO_TMLB_CONT    0x00000020  // Continuation Sample Indicator.
+#define ADC_SSFIFO_TMLB_DIFF    0x00000010  // Differential Sample Indicator.
+#define ADC_SSFIFO_TMLB_TS      0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_SSFIFO_TMLB_MUX_M   0x00000007  // Analog Input Indicator.
+#define ADC_SSFIFO_TMLB_CNT_S   6           // Sample counter shift
+#define ADC_SSFIFO_TMLB_MUX_S   0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_TMLB_CNT_M          0x000003C0  // Continuous Sample Counter.
+#define ADC_TMLB_CONT           0x00000020  // Continuation Sample Indicator.
+#define ADC_TMLB_DIFF           0x00000010  // Differential Sample Indicator.
+#define ADC_TMLB_TS             0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_TMLB_MUX_M          0x00000007  // Analog Input Indicator.
+#define ADC_TMLB_CNT_S          6           // Sample counter shift
+#define ADC_TMLB_MUX_S          0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACMIS register.
+//
+//*****************************************************************************
+#define COMP_ACMIS_IN0          0x00000001  // Comparator 0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACRIS register.
+//
+//*****************************************************************************
+#define COMP_ACRIS_IN0          0x00000001  // Comparator 0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACINTEN register.
+//
+//*****************************************************************************
+#define COMP_ACINTEN_IN0        0x00000001  // Comparator 0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACREFCTL
+// register.
+//
+//*****************************************************************************
+#define COMP_ACREFCTL_EN        0x00000200  // Resistor Ladder Enable.
+#define COMP_ACREFCTL_RNG       0x00000100  // Resistor Ladder Range.
+#define COMP_ACREFCTL_VREF_M    0x0000000F  // Resistor Ladder Voltage Ref.
+#define COMP_ACREFCTL_VREF_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT0 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT0_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL0 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL0_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL0_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL0_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL0_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL0_ASRCP_REF   0x00000400  // Internal voltage reference
+#define COMP_ACCTL0_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL0_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL0_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL0_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL0_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL0_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL0_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL0_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL0_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL0_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL0_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL0_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL0_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_CTL register.
+//
+//*****************************************************************************
+#define CAN_CTL_TEST            0x00000080  // Test Mode Enable.
+#define CAN_CTL_CCE             0x00000040  // Configuration Change Enable.
+#define CAN_CTL_DAR             0x00000020  // Disable
+                                            // Automatic-Retransmission.
+#define CAN_CTL_EIE             0x00000008  // Error Interrupt Enable.
+#define CAN_CTL_SIE             0x00000004  // Status Interrupt Enable.
+#define CAN_CTL_IE              0x00000002  // CAN Interrupt Enable.
+#define CAN_CTL_INIT            0x00000001  // Initialization.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_STS register.
+//
+//*****************************************************************************
+#define CAN_STS_BOFF            0x00000080  // Bus-Off Status.
+#define CAN_STS_EWARN           0x00000040  // Warning Status.
+#define CAN_STS_EPASS           0x00000020  // Error Passive.
+#define CAN_STS_RXOK            0x00000010  // Received a Message Successfully.
+#define CAN_STS_TXOK            0x00000008  // Transmitted a Message
+                                            // Successfully.
+#define CAN_STS_LEC_M           0x00000007  // Last Error Code.
+#define CAN_STS_LEC_NONE        0x00000000  // No Error
+#define CAN_STS_LEC_STUFF       0x00000001  // Stuff Error
+#define CAN_STS_LEC_FORM        0x00000002  // Format Error
+#define CAN_STS_LEC_ACK         0x00000003  // ACK Error
+#define CAN_STS_LEC_BIT1        0x00000004  // Bit 1 Error
+#define CAN_STS_LEC_BIT0        0x00000005  // Bit 0 Error
+#define CAN_STS_LEC_CRC         0x00000006  // CRC Error
+#define CAN_STS_LEC_NOEVENT     0x00000007  // Unused
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_ERR register.
+//
+//*****************************************************************************
+#define CAN_ERR_RP              0x00008000  // Received Error Passive.
+#define CAN_ERR_REC_M           0x00007F00  // Receive Error Counter.
+#define CAN_ERR_TEC_M           0x000000FF  // Transmit Error Counter.
+#define CAN_ERR_REC_S           8
+#define CAN_ERR_TEC_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_BIT register.
+//
+//*****************************************************************************
+#define CAN_BIT_TSEG2_M         0x00007000  // Time Segment after Sample Point.
+#define CAN_BIT_TSEG1_M         0x00000F00  // Time Segment Before Sample
+                                            // Point.
+#define CAN_BIT_SJW_M           0x000000C0  // (Re)Synchronization Jump Width.
+#define CAN_BIT_BRP_M           0x0000003F  // Baud Rate Prescaler.
+#define CAN_BIT_TSEG2_S         12
+#define CAN_BIT_TSEG1_S         8
+#define CAN_BIT_SJW_S           6
+#define CAN_BIT_BRP_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_INT register.
+//
+//*****************************************************************************
+#define CAN_INT_INTID_M         0x0000FFFF  // Interrupt Identifier.
+#define CAN_INT_INTID_NONE      0x00000000  // No interrupt pending
+#define CAN_INT_INTID_STATUS    0x00008000  // Status Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TST register.
+//
+//*****************************************************************************
+#define CAN_TST_RX              0x00000080  // Receive Observation.
+#define CAN_TST_TX_M            0x00000060  // Transmit Control.
+#define CAN_TST_TX_CANCTL       0x00000000  // CANnTx is controlled by the CAN
+                                            // module; default operation
+#define CAN_TST_TX_SAMPLE       0x00000020  // The sample point is driven on
+                                            // the CANnTx signal. This mode is
+                                            // useful to monitor bit timing.
+#define CAN_TST_TX_DOMINANT     0x00000040  // CANnTx drives a low value. This
+                                            // mode is useful for checking the
+                                            // physical layer of the CAN bus.
+#define CAN_TST_TX_RECESSIVE    0x00000060  // CANnTx drives a high value. This
+                                            // mode is useful for checking the
+                                            // physical layer of the CAN bus.
+#define CAN_TST_LBACK           0x00000010  // Loopback Mode.
+#define CAN_TST_SILENT          0x00000008  // Silent Mode.
+#define CAN_TST_BASIC           0x00000004  // Basic Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_BRPE register.
+//
+//*****************************************************************************
+#define CAN_BRPE_BRPE_M         0x0000000F  // Baud Rate Prescaler Extension.
+#define CAN_BRPE_BRPE_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF1CRQ_BUSY         0x00008000  // Busy Flag.
+#define CAN_IF1CRQ_MNUM_M       0x0000003F  // Message Number.
+#define CAN_IF1CRQ_MNUM_RSVD    0x00000000  // 0 is not a valid message number;
+                                            // it is interpreted as 0x20, or
+                                            // object 32.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF1CMSK_WRNRD       0x00000080  // Write, Not Read.
+#define CAN_IF1CMSK_MASK        0x00000040  // Access Mask Bits.
+#define CAN_IF1CMSK_ARB         0x00000020  // Access Arbitration Bits.
+#define CAN_IF1CMSK_CONTROL     0x00000010  // Access Control Bits.
+#define CAN_IF1CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit.
+#define CAN_IF1CMSK_NEWDAT      0x00000004  // NEWDAT 
+#define CAN_IF1CMSK_TXRQST      0x00000004  //  TXRQST Bit.
+#define CAN_IF1CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3.
+#define CAN_IF1CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask.
+#define CAN_IF1MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK2_MXTD        0x00008000  // Mask Extended Identifier.
+#define CAN_IF1MSK2_MDIR        0x00004000  // Mask Message Direction.
+#define CAN_IF1MSK2_IDMSK_M     0x00001FFF  // Identifier Mask.
+#define CAN_IF1MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB1_ID_M        0x0000FFFF  // Message Identifier.
+#define CAN_IF1ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB2_MSGVAL      0x00008000  // Message Valid.
+#define CAN_IF1ARB2_XTD         0x00004000  // Extended Identifier.
+#define CAN_IF1ARB2_DIR         0x00002000  // Message Direction.
+#define CAN_IF1ARB2_ID_M        0x00001FFF  // Message Identifier.
+#define CAN_IF1ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF1MCTL_NEWDAT      0x00008000  // New Data.
+#define CAN_IF1MCTL_MSGLST      0x00004000  // Message Lost.
+#define CAN_IF1MCTL_INTPND      0x00002000  // Interrupt Pending.
+#define CAN_IF1MCTL_UMASK       0x00001000  // Use Acceptance Mask.
+#define CAN_IF1MCTL_TXIE        0x00000800  // Transmit Interrupt Enable.
+#define CAN_IF1MCTL_RXIE        0x00000400  // Receive Interrupt Enable.
+#define CAN_IF1MCTL_RMTEN       0x00000200  // Remote Enable.
+#define CAN_IF1MCTL_TXRQST      0x00000100  // Transmit Request.
+#define CAN_IF1MCTL_EOB         0x00000080  // End of Buffer.
+#define CAN_IF1MCTL_DLC_M       0x0000000F  // Data Length Code.
+#define CAN_IF1MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF2CRQ_BUSY         0x00008000  // Busy Flag.
+#define CAN_IF2CRQ_MNUM_M       0x0000003F  // Message Number.
+#define CAN_IF2CRQ_MNUM_RSVD    0x00000000  // 0 is not a valid message number;
+                                            // it is interpreted as 0x20, or
+                                            // object 32.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF2CMSK_WRNRD       0x00000080  // Write, Not Read.
+#define CAN_IF2CMSK_MASK        0x00000040  // Access Mask Bits.
+#define CAN_IF2CMSK_ARB         0x00000020  // Access Arbitration Bits.
+#define CAN_IF2CMSK_CONTROL     0x00000010  // Access Control Bits.
+#define CAN_IF2CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit.
+#define CAN_IF2CMSK_NEWDAT      0x00000004  // NEWDAT 
+#define CAN_IF2CMSK_TXRQST      0x00000004  //  TXRQST Bit.
+#define CAN_IF2CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3.
+#define CAN_IF2CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask.
+#define CAN_IF2MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK2_MXTD        0x00008000  // Mask Extended Identifier.
+#define CAN_IF2MSK2_MDIR        0x00004000  // Mask Message Direction.
+#define CAN_IF2MSK2_IDMSK_M     0x00001FFF  // Identifier Mask.
+#define CAN_IF2MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB1_ID_M        0x0000FFFF  // Message Identifier.
+#define CAN_IF2ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB2_MSGVAL      0x00008000  // Message Valid.
+#define CAN_IF2ARB2_XTD         0x00004000  // Extended Identifier.
+#define CAN_IF2ARB2_DIR         0x00002000  // Message Direction.
+#define CAN_IF2ARB2_ID_M        0x00001FFF  // Message Identifier.
+#define CAN_IF2ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF2MCTL_NEWDAT      0x00008000  // New Data.
+#define CAN_IF2MCTL_MSGLST      0x00004000  // Message Lost.
+#define CAN_IF2MCTL_INTPND      0x00002000  // Interrupt Pending.
+#define CAN_IF2MCTL_UMASK       0x00001000  // Use Acceptance Mask.
+#define CAN_IF2MCTL_TXIE        0x00000800  // Transmit Interrupt Enable.
+#define CAN_IF2MCTL_RXIE        0x00000400  // Receive Interrupt Enable.
+#define CAN_IF2MCTL_RMTEN       0x00000200  // Remote Enable.
+#define CAN_IF2MCTL_TXRQST      0x00000100  // Transmit Request.
+#define CAN_IF2MCTL_EOB         0x00000080  // End of Buffer.
+#define CAN_IF2MCTL_DLC_M       0x0000000F  // Data Length Code.
+#define CAN_IF2MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TXRQ1 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ1_TXRQST_M      0x0000FFFF  // Transmission Request Bits.
+#define CAN_TXRQ1_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TXRQ2 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ2_TXRQST_M      0x0000FFFF  // Transmission Request Bits.
+#define CAN_TXRQ2_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_NWDA1 register.
+//
+//*****************************************************************************
+#define CAN_NWDA1_NEWDAT_M      0x0000FFFF  // New Data Bits.
+#define CAN_NWDA1_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_NWDA2 register.
+//
+//*****************************************************************************
+#define CAN_NWDA2_NEWDAT_M      0x0000FFFF  // New Data Bits.
+#define CAN_NWDA2_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1INT register.
+//
+//*****************************************************************************
+#define CAN_MSG1INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits.
+#define CAN_MSG1INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2INT register.
+//
+//*****************************************************************************
+#define CAN_MSG2INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits.
+#define CAN_MSG2INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG1VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits.
+#define CAN_MSG1VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG2VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits.
+#define CAN_MSG2VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR0 register.
+//
+//*****************************************************************************
+#define PHY_MR0_RESET           0x00008000  // Reset Registers.
+#define PHY_MR0_LOOPBK          0x00004000  // Loopback Mode.
+#define PHY_MR0_SPEEDSL         0x00002000  // Speed Select.
+#define PHY_MR0_ANEGEN          0x00001000  // Auto-Negotiation Enable.
+#define PHY_MR0_PWRDN           0x00000800  // Power Down.
+#define PHY_MR0_ISO             0x00000400  // Isolate.
+#define PHY_MR0_RANEG           0x00000200  // Restart Auto-Negotiation.
+#define PHY_MR0_DUPLEX          0x00000100  // Set Duplex Mode.
+#define PHY_MR0_COLT            0x00000080  // Collision Test.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RIS register.
+//
+//*****************************************************************************
+#define MAC_RIS_PHYINT          0x00000040  // PHY Interrupt.
+#define MAC_RIS_MDINT           0x00000020  // MII Transaction Complete.
+#define MAC_RIS_RXER            0x00000010  // Receive Error.
+#define MAC_RIS_FOV             0x00000008  // FIFO Overrun.
+#define MAC_RIS_TXEMP           0x00000004  // Transmit FIFO Empty.
+#define MAC_RIS_TXER            0x00000002  // Transmit Error.
+#define MAC_RIS_RXINT           0x00000001  // Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IACK register.
+//
+//*****************************************************************************
+#define MAC_IACK_PHYINT         0x00000040  // Clear PHY Interrupt.
+#define MAC_IACK_MDINT          0x00000020  // Clear MII Transaction Complete.
+#define MAC_IACK_RXER           0x00000010  // Clear Receive Error.
+#define MAC_IACK_FOV            0x00000008  // Clear FIFO Overrun.
+#define MAC_IACK_TXEMP          0x00000004  // Clear Transmit FIFO Empty.
+#define MAC_IACK_TXER           0x00000002  // Clear Transmit Error.
+#define MAC_IACK_RXINT          0x00000001  // Clear Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR1 register.
+//
+//*****************************************************************************
+#define PHY_MR1_100X_F          0x00004000  // 100BASE-TX Full-Duplex Mode.
+#define PHY_MR1_100X_H          0x00002000  // 100BASE-TX Half-Duplex Mode.
+#define PHY_MR1_10T_F           0x00001000  // 10BASE-T Full-Duplex Mode.
+#define PHY_MR1_10T_H           0x00000800  // 10BASE-T Half-Duplex Mode.
+#define PHY_MR1_MFPS            0x00000040  // Management Frames with Preamble
+                                            // Suppressed.
+#define PHY_MR1_ANEGC           0x00000020  // Auto-Negotiation Complete.
+#define PHY_MR1_RFAULT          0x00000010  // Remote Fault.
+#define PHY_MR1_ANEGA           0x00000008  // Auto-Negotiation.
+#define PHY_MR1_LINK            0x00000004  // Link Made.
+#define PHY_MR1_JAB             0x00000002  // Jabber Condition.
+#define PHY_MR1_EXTD            0x00000001  // Extended Capabilities.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR2 register.
+//
+//*****************************************************************************
+#define PHY_MR2_OUI_M           0x0000FFFF  // Organizationally Unique
+                                            // Identifier[21:6].
+#define PHY_MR2_OUI_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR3 register.
+//
+//*****************************************************************************
+#define PHY_MR3_OUI_M           0x0000FC00  // Organizationally Unique
+                                            // Identifier[5:0].
+#define PHY_MR3_MN_M            0x000003F0  // Model Number.
+#define PHY_MR3_RN_M            0x0000000F  // Revision Number.
+#define PHY_MR3_OUI_S           10
+#define PHY_MR3_MN_S            4
+#define PHY_MR3_RN_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IM register.
+//
+//*****************************************************************************
+#define MAC_IM_PHYINTM          0x00000040  // Mask PHY Interrupt.
+#define MAC_IM_MDINTM           0x00000020  // Mask MII Transaction Complete.
+#define MAC_IM_RXERM            0x00000010  // Mask Receive Error.
+#define MAC_IM_FOVM             0x00000008  // Mask FIFO Overrun.
+#define MAC_IM_TXEMPM           0x00000004  // Mask Transmit FIFO Empty.
+#define MAC_IM_TXERM            0x00000002  // Mask Transmit Error.
+#define MAC_IM_RXINTM           0x00000001  // Mask Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR4 register.
+//
+//*****************************************************************************
+#define PHY_MR4_NP              0x00008000  // Next Page.
+#define PHY_MR4_RF              0x00002000  // Remote Fault.
+#define PHY_MR4_A3              0x00000100  // Technology Ability Field[3].
+#define PHY_MR4_A2              0x00000080  // Technology Ability Field[2].
+#define PHY_MR4_A1              0x00000040  // Technology Ability Field[1].
+#define PHY_MR4_A0              0x00000020  // Technology Ability Field[0].
+#define PHY_MR4_S_M             0x0000001F  // Selector Field.
+#define PHY_MR4_S_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR5 register.
+//
+//*****************************************************************************
+#define PHY_MR5_NP              0x00008000  // Next Page.
+#define PHY_MR5_ACK             0x00004000  // Acknowledge.
+#define PHY_MR5_RF              0x00002000  // Remote Fault.
+#define PHY_MR5_A_M             0x00001FE0  // Technology Ability Field.
+#define PHY_MR5_S_M             0x0000001F  // Selector Field.
+#define PHY_MR5_S_8023          0x00000001  // IEEE Std 802.3
+#define PHY_MR5_S_8029          0x00000002  // IEEE Std 802.9 ISLAN-16T
+#define PHY_MR5_S_8025          0x00000003  // IEEE Std 802.5
+#define PHY_MR5_S_1394          0x00000004  // IEEE Std 1394
+#define PHY_MR5_A_S             5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR6 register.
+//
+//*****************************************************************************
+#define PHY_MR6_PDF             0x00000010  // Parallel Detection Fault.
+#define PHY_MR6_LPNPA           0x00000008  // Link Partner is Next Page Able.
+#define PHY_MR6_PRX             0x00000002  // New Page Received.
+#define PHY_MR6_LPANEGA         0x00000001  // Link Partner is Auto-Negotiation
+                                            // Able.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RCTL register.
+//
+//*****************************************************************************
+#define MAC_RCTL_RSTFIFO        0x00000010  // Clear Receive FIFO.
+#define MAC_RCTL_BADCRC         0x00000008  // Enable Reject Bad CRC.
+#define MAC_RCTL_PRMS           0x00000004  // Enable Promiscuous Mode.
+#define MAC_RCTL_AMUL           0x00000002  // Enable Multicast Frames.
+#define MAC_RCTL_RXEN           0x00000001  // Enable Receiver.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TCTL register.
+//
+//*****************************************************************************
+#define MAC_TCTL_DUPLEX         0x00000010  // Enable Duplex Mode.
+#define MAC_TCTL_CRC            0x00000004  // Enable CRC Generation.
+#define MAC_TCTL_PADEN          0x00000002  // Enable Packet Padding.
+#define MAC_TCTL_TXEN           0x00000001  // Enable Transmitter.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_DATA register.
+//
+//*****************************************************************************
+#define MAC_DATA_TXDATA_M       0xFFFFFFFF  // Transmit FIFO Data.
+#define MAC_DATA_RXDATA_M       0xFFFFFFFF  // Receive FIFO Data.
+#define MAC_DATA_RXDATA_S       0
+#define MAC_DATA_TXDATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR16 register.
+//
+//*****************************************************************************
+#define PHY_MR16_RPTR           0x00008000  // Repeater Mode.
+#define PHY_MR16_INPOL          0x00004000  // Interrupt Polarity.
+#define PHY_MR16_TXHIM          0x00001000  // Transmit High Impedance Mode.
+#define PHY_MR16_SQEI           0x00000800  // SQE Inhibit Testing.
+#define PHY_MR16_NL10           0x00000400  // Natural Loopback Mode.
+#define PHY_MR16_APOL           0x00000020  // Auto-Polarity Disable.
+#define PHY_MR16_RVSPOL         0x00000010  // Receive Data Polarity.
+#define PHY_MR16_PCSBP          0x00000002  // PCS Bypass.
+#define PHY_MR16_RXCC           0x00000001  // Receive Clock Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR17 register.
+//
+//*****************************************************************************
+#define PHY_MR17_JABBER_IE      0x00008000  // Jabber Interrupt Enable.
+#define PHY_MR17_RXER_IE        0x00004000  // Receive Error Interrupt Enable.
+#define PHY_MR17_PRX_IE         0x00002000  // Page Received Interrupt Enable.
+#define PHY_MR17_PDF_IE         0x00001000  // Parallel Detection Fault
+                                            // Interrupt Enable.
+#define PHY_MR17_LPACK_IE       0x00000800  // LP Acknowledge Interrupt Enable.
+#define PHY_MR17_LSCHG_IE       0x00000400  // Link Status Change Interrupt
+                                            // Enable.
+#define PHY_MR17_RFAULT_IE      0x00000200  // Remote Fault Interrupt Enable.
+#define PHY_MR17_ANEGCOMP_IE    0x00000100  // Auto-Negotiation Complete
+                                            // Interrupt Enable.
+#define PHY_MR17_JABBER_INT     0x00000080  // Jabber Event Interrupt.
+#define PHY_MR17_RXER_INT       0x00000040  // Receive Error Interrupt.
+#define PHY_MR17_PRX_INT        0x00000020  // Page Receive Interrupt.
+#define PHY_MR17_PDF_INT        0x00000010  // Parallel Detection Fault
+                                            // Interrupt.
+#define PHY_MR17_LPACK_INT      0x00000008  // LP Acknowledge Interrupt.
+#define PHY_MR17_LSCHG_INT      0x00000004  // Link Status Change Interrupt.
+#define PHY_MR17_RFAULT_INT     0x00000002  // Remote Fault Interrupt.
+#define PHY_MR17_ANEGCOMP_INT   0x00000001  // Auto-Negotiation Complete
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR18 register.
+//
+//*****************************************************************************
+#define PHY_MR18_ANEGF          0x00001000  // Auto-Negotiation Failure.
+#define PHY_MR18_DPLX           0x00000800  // Duplex Mode.
+#define PHY_MR18_RATE           0x00000400  // Rate.
+#define PHY_MR18_RXSD           0x00000200  // Receive Detection.
+#define PHY_MR18_RX_LOCK        0x00000100  // Receive PLL Lock.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR19 register.
+//
+//*****************************************************************************
+#define PHY_MR19_TXO_M          0x0000C000  // Transmit Amplitude Selection.
+#define PHY_MR19_TXO_00DB       0x00000000  // Gain set for 0.0dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_04DB       0x00004000  // Gain set for 0.4dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_08DB       0x00008000  // Gain set for 0.8dB of insertion
+                                            // loss
+#define PHY_MR19_TXO_12DB       0x0000C000  // Gain set for 1.2dB of insertion
+                                            // loss
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA0 register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4_M       0xFF000000  // MAC Address Octet 4.
+#define MAC_IA0_MACOCT3_M       0x00FF0000  // MAC Address Octet 3.
+#define MAC_IA0_MACOCT2_M       0x0000FF00  // MAC Address Octet 2.
+#define MAC_IA0_MACOCT1_M       0x000000FF  // MAC Address Octet 1.
+#define MAC_IA0_MACOCT4_S       24
+#define MAC_IA0_MACOCT3_S       16
+#define MAC_IA0_MACOCT2_S       8
+#define MAC_IA0_MACOCT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR23 register.
+//
+//*****************************************************************************
+#define PHY_MR23_LED1_M         0x000000F0  // LED1 Source.
+#define PHY_MR23_LED1_LINK      0x00000000  // Link OK
+#define PHY_MR23_LED1_RXTX      0x00000010  // RX or TX Activity (Default LED1)
+#define PHY_MR23_LED1_100       0x00000050  // 100BASE-TX mode
+#define PHY_MR23_LED1_10        0x00000060  // 10BASE-T mode
+#define PHY_MR23_LED1_DUPLEX    0x00000070  // Full-Duplex
+#define PHY_MR23_LED1_LINKACT   0x00000080  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+#define PHY_MR23_LED0_M         0x0000000F  // LED0 Source.
+#define PHY_MR23_LED0_LINK      0x00000000  // Link OK (Default LED0)
+#define PHY_MR23_LED0_RXTX      0x00000001  // RX or TX Activity
+#define PHY_MR23_LED0_100       0x00000005  // 100BASE-TX mode
+#define PHY_MR23_LED0_10        0x00000006  // 10BASE-T mode
+#define PHY_MR23_LED0_DUPLEX    0x00000007  // Full-Duplex
+#define PHY_MR23_LED0_LINKACT   0x00000008  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA1 register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6_M       0x0000FF00  // MAC Address Octet 6.
+#define MAC_IA1_MACOCT5_M       0x000000FF  // MAC Address Octet 5.
+#define MAC_IA1_MACOCT6_S       8
+#define MAC_IA1_MACOCT5_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR24 register.
+//
+//*****************************************************************************
+#define PHY_MR24_PD_MODE        0x00000080  // Parallel Detection Mode.
+#define PHY_MR24_AUTO_SW        0x00000040  // Auto-Switching Enable.
+#define PHY_MR24_MDIX           0x00000020  // Auto-Switching Configuration.
+#define PHY_MR24_MDIX_CM        0x00000010  // Auto-Switching Complete.
+#define PHY_MR24_MDIX_SD_M      0x0000000F  // Auto-Switching Seed.
+#define PHY_MR24_MDIX_SD_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_THR register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH_M        0x0000003F  // Threshold Value.
+#define MAC_THR_THRESH_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MCTL register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR_M       0x000000F8  // MII Register Address.
+#define MAC_MCTL_WRITE          0x00000002  // MII Register Transaction Type.
+#define MAC_MCTL_START          0x00000001  // MII Register Transaction Enable.
+#define MAC_MCTL_REGADR_S       3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MDV register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV_M           0x000000FF  // Clock Divider.
+#define MAC_MDV_DIV_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MTXD register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX_M         0x0000FFFF  // MII Register Transmit Data.
+#define MAC_MTXD_MDTX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MRXD register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX_M         0x0000FFFF  // MII Register Receive Data.
+#define MAC_MRXD_MDRX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_NP register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR_M            0x0000003F  // Number of Packets in Receive
+                                            // FIFO.
+#define MAC_NP_NPR_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TR register.
+//
+//*****************************************************************************
+#define MAC_TR_NEWTX            0x00000001  // New Transmission.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TS register.
+//
+//*****************************************************************************
+#define MAC_TS_TSEN             0x00000001  // Time Stamp Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCC register.
+//
+//*****************************************************************************
+#define HIB_RTCC_M              0xFFFFFFFF  // RTC Counter.
+#define HIB_RTCC_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCM0 register.
+//
+//*****************************************************************************
+#define HIB_RTCM0_M             0xFFFFFFFF  // RTC Match 0.
+#define HIB_RTCM0_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCM1 register.
+//
+//*****************************************************************************
+#define HIB_RTCM1_M             0xFFFFFFFF  // RTC Match 1.
+#define HIB_RTCM1_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCLD register.
+//
+//*****************************************************************************
+#define HIB_RTCLD_M             0xFFFFFFFF  // RTC Load.
+#define HIB_RTCLD_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_CTL register.
+//
+//*****************************************************************************
+#define HIB_CTL_VABORT          0x00000080  // Power Cut Abort Enable.
+#define HIB_CTL_CLK32EN         0x00000040  // Clocking Enable.
+#define HIB_CTL_LOWBATEN        0x00000020  // Low Battery Monitoring Enable.
+#define HIB_CTL_PINWEN          0x00000010  // External WAKE Pin Enable.
+#define HIB_CTL_RTCWEN          0x00000008  // RTC Wake-up Enable.
+#define HIB_CTL_CLKSEL          0x00000004  // Hibernation Module Clock Select.
+#define HIB_CTL_HIBREQ          0x00000002  // Hibernation Request.
+#define HIB_CTL_RTCEN           0x00000001  // RTC Timer Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IM register.
+//
+//*****************************************************************************
+#define HIB_IM_EXTW             0x00000008  // External Wake-Up Interrupt Mask.
+#define HIB_IM_LOWBAT           0x00000004  // Low Battery Voltage Interrupt
+                                            // Mask.
+#define HIB_IM_RTCALT1          0x00000002  // RTC Alert1 Interrupt Mask.
+#define HIB_IM_RTCALT0          0x00000001  // RTC Alert0 Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RIS register.
+//
+//*****************************************************************************
+#define HIB_RIS_EXTW            0x00000008  // External Wake-Up Raw Interrupt
+                                            // Status.
+#define HIB_RIS_LOWBAT          0x00000004  // Low Battery Voltage Raw
+                                            // Interrupt Status.
+#define HIB_RIS_RTCALT1         0x00000002  // RTC Alert1 Raw Interrupt Status.
+#define HIB_RIS_RTCALT0         0x00000001  // RTC Alert0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_MIS register.
+//
+//*****************************************************************************
+#define HIB_MIS_EXTW            0x00000008  // External Wake-Up Masked
+                                            // Interrupt Status.
+#define HIB_MIS_LOWBAT          0x00000004  // Low Battery Voltage Masked
+                                            // Interrupt Status.
+#define HIB_MIS_RTCALT1         0x00000002  // RTC Alert1 Masked Interrupt
+                                            // Status.
+#define HIB_MIS_RTCALT0         0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_IC register.
+//
+//*****************************************************************************
+#define HIB_IC_EXTW             0x00000008  // External Wake-Up Masked
+                                            // Interrupt Clear.
+#define HIB_IC_LOWBAT           0x00000004  // Low Battery Voltage Masked
+                                            // Interrupt Clear.
+#define HIB_IC_RTCALT1          0x00000002  // RTC Alert1 Masked Interrupt
+                                            // Clear.
+#define HIB_IC_RTCALT0          0x00000001  // RTC Alert0 Masked Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_RTCT register.
+//
+//*****************************************************************************
+#define HIB_RTCT_TRIM_M         0x0000FFFF  // RTC Trim Value.
+#define HIB_RTCT_TRIM_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the HIB_DATA register.
+//
+//*****************************************************************************
+#define HIB_DATA_RTD_M          0xFFFFFFFF  // Hibernation Module NV
+                                            // Registers[63:0].
+#define HIB_DATA_RTD_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMA register.
+//
+//*****************************************************************************
+#define FLASH_FMA_OFFSET_M      0x0003FFFF  // Address Offset.
+#define FLASH_FMA_OFFSET_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMD register.
+//
+//*****************************************************************************
+#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value.
+#define FLASH_FMD_DATA_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_M       0xFFFF0000  // Flash Write Key.
+#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
+#define FLASH_FMC_COMT          0x00000008  // Commit Register Value.
+#define FLASH_FMC_MERASE        0x00000004  // Mass Erase Flash Memory.
+#define FLASH_FMC_ERASE         0x00000002  // Erase a Page of Flash Memory.
+#define FLASH_FMC_WRITE         0x00000001  // Write a Word into Flash Memory.
+#define FLASH_FMC_WRKEY_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCRIS register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt
+                                            // Status.
+#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCIM register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask.
+#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCMISC register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
+                                            // Status and Clear.
+#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USECRL register.
+//
+//*****************************************************************************
+#define FLASH_USECRL_M          0x000000FF  // Microsecond Reload Value.
+#define FLASH_USECRL_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERDBG register.
+//
+//*****************************************************************************
+#define FLASH_USERDBG_NW        0x80000000  // User Debug Not Written.
+#define FLASH_USERDBG_DATA_M    0x7FFFFFFC  // User Data.
+#define FLASH_USERDBG_DBG1      0x00000002  // Debug Control 1.
+#define FLASH_USERDBG_DBG0      0x00000001  // Debug Control 0.
+#define FLASH_USERDBG_DATA_S    2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG0 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG0_NW       0x80000000  // Not Written.
+#define FLASH_USERREG0_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG0_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG1 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG1_NW       0x80000000  // Not Written.
+#define FLASH_USERREG1_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG1_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the erase size of the FLASH block that is
+// erased by an erase operation, and the protect size is the size of the FLASH
+// block that is protected by each protection register.
+//
+//*****************************************************************************
+#define FLASH_PROTECT_SIZE      0x00000800
+#define FLASH_ERASE_SIZE        0x00000400
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID0_VER_M       0x70000000  // DID0 Version.
+#define SYSCTL_DID0_VER_1       0x10000000  // Second version of the DID0
+                                            // register format.
+#define SYSCTL_DID0_CLASS_M     0x00FF0000  // Device Class.
+#define SYSCTL_DID0_CLASS_FURY  0x00010000  // Stellaris(r) Fury-class devices.
+#define SYSCTL_DID0_MAJ_M       0x0000FF00  // Major Revision.
+#define SYSCTL_DID0_MAJ_REVA    0x00000000  // Revision A (initial device)
+#define SYSCTL_DID0_MAJ_REVB    0x00000100  // Revision B (first base layer
+                                            // revision)
+#define SYSCTL_DID0_MAJ_REVC    0x00000200  // Revision C (second base layer
+                                            // revision)
+#define SYSCTL_DID0_MIN_M       0x000000FF  // Minor Revision.
+#define SYSCTL_DID0_MIN_0       0x00000000  // Initial device, or a major
+                                            // revision update.
+#define SYSCTL_DID0_MIN_1       0x00000001  // First metal layer change.
+#define SYSCTL_DID0_MIN_2       0x00000002  // Second metal layer change.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID1_VER_M       0xF0000000  // DID1 Version.
+#define SYSCTL_DID1_VER_1       0x10000000  // Second version of the DID1
+                                            // register format.
+#define SYSCTL_DID1_FAM_M       0x0F000000  // Family.
+#define SYSCTL_DID1_FAM_STELLARIS \
+                                0x00000000  // Stellaris family of
+                                            // microcontollers, that is, all
+                                            // devices with external part
+                                            // numbers starting with LM3S.
+#define SYSCTL_DID1_PRTNO_M     0x00FF0000  // Part Number.
+#define SYSCTL_DID1_PRTNO_8962  0x00A60000  // LM3S8962
+#define SYSCTL_DID1_PINCNT_M    0x0000E000  // Package Pin Count.
+#define SYSCTL_DID1_PINCNT_100  0x00004000  // 100-pin or 108-ball package
+#define SYSCTL_DID1_TEMP_M      0x000000E0  // Temperature Range.
+#define SYSCTL_DID1_TEMP_C      0x00000000  // Commercial temperature range (0C
+                                            // to 70C)
+#define SYSCTL_DID1_TEMP_I      0x00000020  // Industrial temperature range
+                                            // (-40C to 85C)
+#define SYSCTL_DID1_TEMP_E      0x00000040  // Extended temperature range (-40C
+                                            // to 105C)
+#define SYSCTL_DID1_PKG_M       0x00000018  // Package Type.
+#define SYSCTL_DID1_PKG_28SOIC  0x00000000  // SOIC package
+#define SYSCTL_DID1_PKG_48QFP   0x00000008  // LQFP package
+#define SYSCTL_DID1_PKG_BGA     0x00000010  // BGA package
+#define SYSCTL_DID1_ROHS        0x00000004  // RoHS-Compliance.
+#define SYSCTL_DID1_QUAL_M      0x00000003  // Qualification Status.
+#define SYSCTL_DID1_QUAL_ES     0x00000000  // Engineering Sample (unqualified)
+#define SYSCTL_DID1_QUAL_PP     0x00000001  // Pilot Production (unqualified)
+#define SYSCTL_DID1_QUAL_FQ     0x00000002  // Fully Qualified
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC0_SRAMSZ_M     0xFFFF0000  // SRAM Size.
+#define SYSCTL_DC0_SRAMSZ_64KB  0x00FF0000  // 64 KB of SRAM
+#define SYSCTL_DC0_FLASHSZ_M    0x0000FFFF  // Flash Size.
+#define SYSCTL_DC0_FLASHSZ_256K 0x0000007F  // 256 KB of Flash
+#define SYSCTL_DC0_SRAMSZ_S     16          // SRAM size shift
+#define SYSCTL_DC0_FLASHSZ_S    0           // Flash size shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC1_CAN0         0x01000000  // CAN Module 0 Present.
+#define SYSCTL_DC1_PWM          0x00100000  // PWM Module Present.
+#define SYSCTL_DC1_ADC          0x00010000  // ADC Module Present.
+#define SYSCTL_DC1_MINSYSDIV_M  0x0000F000  // System Clock Divider.
+#define SYSCTL_DC1_MINSYSDIV_50 0x00003000  // Specifies a 50-MHz CPU clock
+                                            // with a PLL divider of 4.
+#define SYSCTL_DC1_ADCSPD_M     0x00000300  // Max ADC Speed.
+#define SYSCTL_DC1_ADCSPD_500K  0x00000200  // 500K samples/second
+#define SYSCTL_DC1_MPU          0x00000080  // MPU Present.
+#define SYSCTL_DC1_HIB          0x00000040  // Hibernation Module Present.
+#define SYSCTL_DC1_TEMP         0x00000020  // Temp Sensor Present.
+#define SYSCTL_DC1_PLL          0x00000010  // PLL Present.
+#define SYSCTL_DC1_WDT          0x00000008  // Watchdog Timer Present.
+#define SYSCTL_DC1_SWO          0x00000004  // SWO Trace Port Present.
+#define SYSCTL_DC1_SWD          0x00000002  // SWD Present.
+#define SYSCTL_DC1_JTAG         0x00000001  // JTAG Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC2_COMP0        0x01000000  // Analog Comparator 0 Present.
+#define SYSCTL_DC2_TIMER3       0x00080000  // Timer 3 Present.
+#define SYSCTL_DC2_TIMER2       0x00040000  // Timer 2 Present.
+#define SYSCTL_DC2_TIMER1       0x00020000  // Timer 1 Present.
+#define SYSCTL_DC2_TIMER0       0x00010000  // Timer 0 Present.
+#define SYSCTL_DC2_I2C0         0x00001000  // I2C Module 0 Present.
+#define SYSCTL_DC2_QEI1         0x00000200  // QEI1 Present.
+#define SYSCTL_DC2_QEI0         0x00000100  // QEI0 Present.
+#define SYSCTL_DC2_SSI0         0x00000010  // SSI0 Present.
+#define SYSCTL_DC2_UART1        0x00000002  // UART1 Present.
+#define SYSCTL_DC2_UART0        0x00000001  // UART0 Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC3 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC3_32KHZ        0x80000000  // 32KHz Input Clock Available.
+#define SYSCTL_DC3_CCP1         0x02000000  // CCP1 Pin Present.
+#define SYSCTL_DC3_CCP0         0x01000000  // CCP0 Pin Present.
+#define SYSCTL_DC3_ADC3         0x00080000  // ADC3 Pin Present.
+#define SYSCTL_DC3_ADC2         0x00040000  // ADC2 Pin Present.
+#define SYSCTL_DC3_ADC1         0x00020000  // ADC1 Pin Present.
+#define SYSCTL_DC3_ADC0         0x00010000  // ADC0 Pin Present.
+#define SYSCTL_DC3_PWMFAULT     0x00008000  // PWM Fault Pin Present.
+#define SYSCTL_DC3_C0O          0x00000100  // C0o Pin Present.
+#define SYSCTL_DC3_C0PLUS       0x00000080  // C0+ Pin Present.
+#define SYSCTL_DC3_C0MINUS      0x00000040  // C0- Pin Present.
+#define SYSCTL_DC3_PWM5         0x00000020  // PWM5 Pin Present.
+#define SYSCTL_DC3_PWM4         0x00000010  // PWM4 Pin Present.
+#define SYSCTL_DC3_PWM3         0x00000008  // PWM3 Pin Present.
+#define SYSCTL_DC3_PWM2         0x00000004  // PWM2 Pin Present.
+#define SYSCTL_DC3_PWM1         0x00000002  // PWM1 Pin Present.
+#define SYSCTL_DC3_PWM0         0x00000001  // PWM0 Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC4 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC4_EPHY0        0x40000000  // Ethernet PHY0 Present.
+#define SYSCTL_DC4_EMAC0        0x10000000  // Ethernet MAC0 Present.
+#define SYSCTL_DC4_E1588        0x01000000  // 1588 Capable.
+#define SYSCTL_DC4_GPIOG        0x00000040  // GPIO Port G Present.
+#define SYSCTL_DC4_GPIOF        0x00000020  // GPIO Port F Present.
+#define SYSCTL_DC4_GPIOE        0x00000010  // GPIO Port E Present.
+#define SYSCTL_DC4_GPIOD        0x00000008  // GPIO Port D Present.
+#define SYSCTL_DC4_GPIOC        0x00000004  // GPIO Port C Present.
+#define SYSCTL_DC4_GPIOB        0x00000002  // GPIO Port B Present.
+#define SYSCTL_DC4_GPIOA        0x00000001  // GPIO Port A Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PBORCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_PBORCTL_BORIOR   0x00000002  // BOR Interrupt or Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_LDOPCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_LDOPCTL_M        0x0000003F  // LDO Output Voltage.
+#define SYSCTL_LDOPCTL_2_50V    0x00000000  // 2.50
+#define SYSCTL_LDOPCTL_2_45V    0x00000001  // 2.45
+#define SYSCTL_LDOPCTL_2_40V    0x00000002  // 2.40
+#define SYSCTL_LDOPCTL_2_35V    0x00000003  // 2.35
+#define SYSCTL_LDOPCTL_2_30V    0x00000004  // 2.30
+#define SYSCTL_LDOPCTL_2_25V    0x00000005  // 2.25
+#define SYSCTL_LDOPCTL_2_75V    0x0000001B  // 2.75
+#define SYSCTL_LDOPCTL_2_70V    0x0000001C  // 2.70
+#define SYSCTL_LDOPCTL_2_65V    0x0000001D  // 2.65
+#define SYSCTL_LDOPCTL_2_60V    0x0000001E  // 2.60
+#define SYSCTL_LDOPCTL_2_55V    0x0000001F  // 2.55
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR0_CAN0       0x01000000  // CAN0 Reset Control.
+#define SYSCTL_SRCR0_PWM        0x00100000  // PWM Reset Control.
+#define SYSCTL_SRCR0_ADC        0x00010000  // ADC0 Reset Control.
+#define SYSCTL_SRCR0_HIB        0x00000040  // HIB Reset Control.
+#define SYSCTL_SRCR0_WDT        0x00000008  // WDT Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR1_COMP0      0x01000000  // Analog Comp 0 Reset Control.
+#define SYSCTL_SRCR1_TIMER3     0x00080000  // Timer 3 Reset Control.
+#define SYSCTL_SRCR1_TIMER2     0x00040000  // Timer 2 Reset Control.
+#define SYSCTL_SRCR1_TIMER1     0x00020000  // Timer 1 Reset Control.
+#define SYSCTL_SRCR1_TIMER0     0x00010000  // Timer 0 Reset Control.
+#define SYSCTL_SRCR1_I2C0       0x00001000  // I2C0 Reset Control.
+#define SYSCTL_SRCR1_QEI1       0x00000200  // QEI1 Reset Control.
+#define SYSCTL_SRCR1_QEI0       0x00000100  // QEI0 Reset Control.
+#define SYSCTL_SRCR1_SSI0       0x00000010  // SSI0 Reset Control.
+#define SYSCTL_SRCR1_UART1      0x00000002  // UART1 Reset Control.
+#define SYSCTL_SRCR1_UART0      0x00000001  // UART0 Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR2_EPHY0      0x40000000  // PHY0 Reset Control.
+#define SYSCTL_SRCR2_EMAC0      0x10000000  // MAC0 Reset Control.
+#define SYSCTL_SRCR2_GPIOG      0x00000040  // Port G Reset Control.
+#define SYSCTL_SRCR2_GPIOF      0x00000020  // Port F Reset Control.
+#define SYSCTL_SRCR2_GPIOE      0x00000010  // Port E Reset Control.
+#define SYSCTL_SRCR2_GPIOD      0x00000008  // Port D Reset Control.
+#define SYSCTL_SRCR2_GPIOC      0x00000004  // Port C Reset Control.
+#define SYSCTL_SRCR2_GPIOB      0x00000002  // Port B Reset Control.
+#define SYSCTL_SRCR2_GPIOA      0x00000001  // Port A Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RIS register.
+//
+//*****************************************************************************
+#define SYSCTL_RIS_PLLLRIS      0x00000040  // PLL Lock Raw Interrupt Status.
+#define SYSCTL_RIS_BORRIS       0x00000002  // Brown-Out Reset Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_IMC register.
+//
+//*****************************************************************************
+#define SYSCTL_IMC_PLLLIM       0x00000040  // PLL Lock Interrupt Mask.
+#define SYSCTL_IMC_BORIM        0x00000002  // Brown-Out Reset Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MISC register.
+//
+//*****************************************************************************
+#define SYSCTL_MISC_PLLLMIS     0x00000040  // PLL Lock Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_BORMIS      0x00000002  // BOR Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RESC register.
+//
+//*****************************************************************************
+#define SYSCTL_RESC_LDO         0x00000020  // LDO Reset.
+#define SYSCTL_RESC_SW          0x00000010  // Software Reset.
+#define SYSCTL_RESC_WDT         0x00000008  // Watchdog Timer Reset.
+#define SYSCTL_RESC_BOR         0x00000004  // Brown-Out Reset.
+#define SYSCTL_RESC_POR         0x00000002  // Power-On Reset.
+#define SYSCTL_RESC_EXT         0x00000001  // External Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC_ACG          0x08000000  // Auto Clock Gating.
+#define SYSCTL_RCC_SYSDIV_M     0x07800000  // System Clock Divisor.
+#define SYSCTL_RCC_SYSDIV_2     0x00800000  // /2
+#define SYSCTL_RCC_SYSDIV_3     0x01000000  // /3
+#define SYSCTL_RCC_SYSDIV_4     0x01800000  // /4
+#define SYSCTL_RCC_SYSDIV_5     0x02000000  // /5
+#define SYSCTL_RCC_SYSDIV_6     0x02800000  // /6
+#define SYSCTL_RCC_SYSDIV_7     0x03000000  // /7
+#define SYSCTL_RCC_SYSDIV_8     0x03800000  // /8
+#define SYSCTL_RCC_SYSDIV_9     0x04000000  // /9
+#define SYSCTL_RCC_SYSDIV_10    0x04800000  // /10
+#define SYSCTL_RCC_SYSDIV_11    0x05000000  // /11
+#define SYSCTL_RCC_SYSDIV_12    0x05800000  // /12
+#define SYSCTL_RCC_SYSDIV_13    0x06000000  // /13
+#define SYSCTL_RCC_SYSDIV_14    0x06800000  // /14
+#define SYSCTL_RCC_SYSDIV_15    0x07000000  // /15
+#define SYSCTL_RCC_SYSDIV_16    0x07800000  // /16
+#define SYSCTL_RCC_USESYSDIV    0x00400000  // Enable System Clock Divider.
+#define SYSCTL_RCC_USEPWMDIV    0x00100000  // Enable PWM Clock Divisor.
+#define SYSCTL_RCC_PWMDIV_M     0x000E0000  // PWM Unit Clock Divisor.
+#define SYSCTL_RCC_PWMDIV_2     0x00000000  // /2
+#define SYSCTL_RCC_PWMDIV_4     0x00020000  // /4
+#define SYSCTL_RCC_PWMDIV_8     0x00040000  // /8
+#define SYSCTL_RCC_PWMDIV_16    0x00060000  // /16
+#define SYSCTL_RCC_PWMDIV_32    0x00080000  // /32
+#define SYSCTL_RCC_PWMDIV_64    0x000A0000  // /64
+#define SYSCTL_RCC_PWRDN        0x00002000  // PLL Power Down.
+#define SYSCTL_RCC_BYPASS       0x00000800  // PLL Bypass.
+#define SYSCTL_RCC_XTAL_M       0x000003C0  // Crystal Value.
+#define SYSCTL_RCC_XTAL_1MHZ    0x00000000  // 1.000
+#define SYSCTL_RCC_XTAL_1_84MHZ 0x00000040  // 1.8432
+#define SYSCTL_RCC_XTAL_2MHZ    0x00000080  // 2.000
+#define SYSCTL_RCC_XTAL_2_45MHZ 0x000000C0  // 2.4576
+#define SYSCTL_RCC_XTAL_3_57MHZ 0x00000100  // 3.579545 MHz
+#define SYSCTL_RCC_XTAL_3_68MHZ 0x00000140  // 3.6864 MHz
+#define SYSCTL_RCC_XTAL_4MHZ    0x00000180  // 4 MHz
+#define SYSCTL_RCC_XTAL_4_09MHZ 0x000001C0  // 4.096 MHz
+#define SYSCTL_RCC_XTAL_4_91MHZ 0x00000200  // 4.9152 MHz
+#define SYSCTL_RCC_XTAL_5MHZ    0x00000240  // 5 MHz
+#define SYSCTL_RCC_XTAL_5_12MHZ 0x00000280  // 5.12 MHz
+#define SYSCTL_RCC_XTAL_6MHZ    0x000002C0  // 6 MHz (reset value)
+#define SYSCTL_RCC_XTAL_6_14MHZ 0x00000300  // 6.144 MHz
+#define SYSCTL_RCC_XTAL_7_37MHZ 0x00000340  // 7.3728 MHz
+#define SYSCTL_RCC_XTAL_8MHZ    0x00000380  // 8 MHz
+#define SYSCTL_RCC_XTAL_8_19MHZ 0x000003C0  // 8.192 MHz
+#define SYSCTL_RCC_OSCSRC_M     0x00000030  // Oscillator Source.
+#define SYSCTL_RCC_OSCSRC_MAIN  0x00000000  // MOSC
+#define SYSCTL_RCC_OSCSRC_INT   0x00000010  // IOSC
+#define SYSCTL_RCC_OSCSRC_INT4  0x00000020  // IOSC/4
+#define SYSCTL_RCC_OSCSRC_30    0x00000030  // 30 kHz
+#define SYSCTL_RCC_IOSCDIS      0x00000002  // Internal Oscillator Disable.
+#define SYSCTL_RCC_MOSCDIS      0x00000001  // Main Oscillator Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLCFG register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLCFG_F_M       0x00003FE0  // PLL F Value.
+#define SYSCTL_PLLCFG_R_M       0x0000001F  // PLL R Value.
+#define SYSCTL_PLLCFG_F_S       5
+#define SYSCTL_PLLCFG_R_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC2_USERCC2     0x80000000  // Use RCC2.
+#define SYSCTL_RCC2_SYSDIV2_M   0x1F800000  // System Clock Divisor.
+#define SYSCTL_RCC2_SYSDIV2_2   0x00800000  // System clock /2
+#define SYSCTL_RCC2_SYSDIV2_3   0x01000000  // System clock /3
+#define SYSCTL_RCC2_SYSDIV2_4   0x01800000  // System clock /4
+#define SYSCTL_RCC2_SYSDIV2_5   0x02000000  // System clock /5
+#define SYSCTL_RCC2_SYSDIV2_6   0x02800000  // System clock /6
+#define SYSCTL_RCC2_SYSDIV2_7   0x03000000  // System clock /7
+#define SYSCTL_RCC2_SYSDIV2_8   0x03800000  // System clock /8
+#define SYSCTL_RCC2_SYSDIV2_9   0x04000000  // System clock /9
+#define SYSCTL_RCC2_SYSDIV2_10  0x04800000  // System clock /10
+#define SYSCTL_RCC2_SYSDIV2_11  0x05000000  // System clock /11
+#define SYSCTL_RCC2_SYSDIV2_12  0x05800000  // System clock /12
+#define SYSCTL_RCC2_SYSDIV2_13  0x06000000  // System clock /13
+#define SYSCTL_RCC2_SYSDIV2_14  0x06800000  // System clock /14
+#define SYSCTL_RCC2_SYSDIV2_15  0x07000000  // System clock /15
+#define SYSCTL_RCC2_SYSDIV2_16  0x07800000  // System clock /16
+#define SYSCTL_RCC2_SYSDIV2_17  0x08000000  // System clock /17
+#define SYSCTL_RCC2_SYSDIV2_18  0x08800000  // System clock /18
+#define SYSCTL_RCC2_SYSDIV2_19  0x09000000  // System clock /19
+#define SYSCTL_RCC2_SYSDIV2_20  0x09800000  // System clock /20
+#define SYSCTL_RCC2_SYSDIV2_21  0x0A000000  // System clock /21
+#define SYSCTL_RCC2_SYSDIV2_22  0x0A800000  // System clock /22
+#define SYSCTL_RCC2_SYSDIV2_23  0x0B000000  // System clock /23
+#define SYSCTL_RCC2_SYSDIV2_24  0x0B800000  // System clock /24
+#define SYSCTL_RCC2_SYSDIV2_25  0x0C000000  // System clock /25
+#define SYSCTL_RCC2_SYSDIV2_26  0x0C800000  // System clock /26
+#define SYSCTL_RCC2_SYSDIV2_27  0x0D000000  // System clock /27
+#define SYSCTL_RCC2_SYSDIV2_28  0x0D800000  // System clock /28
+#define SYSCTL_RCC2_SYSDIV2_29  0x0E000000  // System clock /29
+#define SYSCTL_RCC2_SYSDIV2_30  0x0E800000  // System clock /30
+#define SYSCTL_RCC2_SYSDIV2_31  0x0F000000  // System clock /31
+#define SYSCTL_RCC2_SYSDIV2_32  0x0F800000  // System clock /32
+#define SYSCTL_RCC2_SYSDIV2_33  0x10000000  // System clock /33
+#define SYSCTL_RCC2_SYSDIV2_34  0x10800000  // System clock /34
+#define SYSCTL_RCC2_SYSDIV2_35  0x11000000  // System clock /35
+#define SYSCTL_RCC2_SYSDIV2_36  0x11800000  // System clock /36
+#define SYSCTL_RCC2_SYSDIV2_37  0x12000000  // System clock /37
+#define SYSCTL_RCC2_SYSDIV2_38  0x12800000  // System clock /38
+#define SYSCTL_RCC2_SYSDIV2_39  0x13000000  // System clock /39
+#define SYSCTL_RCC2_SYSDIV2_40  0x13800000  // System clock /40
+#define SYSCTL_RCC2_SYSDIV2_41  0x14000000  // System clock /41
+#define SYSCTL_RCC2_SYSDIV2_42  0x14800000  // System clock /42
+#define SYSCTL_RCC2_SYSDIV2_43  0x15000000  // System clock /43
+#define SYSCTL_RCC2_SYSDIV2_44  0x15800000  // System clock /44
+#define SYSCTL_RCC2_SYSDIV2_45  0x16000000  // System clock /45
+#define SYSCTL_RCC2_SYSDIV2_46  0x16800000  // System clock /46
+#define SYSCTL_RCC2_SYSDIV2_47  0x17000000  // System clock /47
+#define SYSCTL_RCC2_SYSDIV2_48  0x17800000  // System clock /48
+#define SYSCTL_RCC2_SYSDIV2_49  0x18000000  // System clock /49
+#define SYSCTL_RCC2_SYSDIV2_50  0x18800000  // System clock /50
+#define SYSCTL_RCC2_SYSDIV2_51  0x19000000  // System clock /51
+#define SYSCTL_RCC2_SYSDIV2_52  0x19800000  // System clock /52
+#define SYSCTL_RCC2_SYSDIV2_53  0x1A000000  // System clock /53
+#define SYSCTL_RCC2_SYSDIV2_54  0x1A800000  // System clock /54
+#define SYSCTL_RCC2_SYSDIV2_55  0x1B000000  // System clock /55
+#define SYSCTL_RCC2_SYSDIV2_56  0x1B800000  // System clock /56
+#define SYSCTL_RCC2_SYSDIV2_57  0x1C000000  // System clock /57
+#define SYSCTL_RCC2_SYSDIV2_58  0x1C800000  // System clock /58
+#define SYSCTL_RCC2_SYSDIV2_59  0x1D000000  // System clock /59
+#define SYSCTL_RCC2_SYSDIV2_60  0x1D800000  // System clock /60
+#define SYSCTL_RCC2_SYSDIV2_61  0x1E000000  // System clock /61
+#define SYSCTL_RCC2_SYSDIV2_62  0x1E800000  // System clock /62
+#define SYSCTL_RCC2_SYSDIV2_63  0x1F000000  // System clock /63
+#define SYSCTL_RCC2_SYSDIV2_64  0x1F800000  // System clock /64
+#define SYSCTL_RCC2_PWRDN2      0x00002000  // Power-Down PLL.
+#define SYSCTL_RCC2_BYPASS2     0x00000800  // Bypass PLL.
+#define SYSCTL_RCC2_OSCSRC2_M   0x00000070  // Oscillator Source.
+#define SYSCTL_RCC2_OSCSRC2_MO  0x00000000  // MOSC
+#define SYSCTL_RCC2_OSCSRC2_IO  0x00000010  // IOSC
+#define SYSCTL_RCC2_OSCSRC2_IO4 0x00000020  // IOSC/4
+#define SYSCTL_RCC2_OSCSRC2_30  0x00000030  // 30 kHz
+#define SYSCTL_RCC2_OSCSRC2_32  0x00000070  // 32 kHz
+#define SYSCTL_RCC2_SYSDIV2_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_RCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_RCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_RCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_RCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_RCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_RCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_RCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_RCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_RCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_RCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_RCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_SCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_SCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_SCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_SCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_SCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_SCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_SCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_SCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_SCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_SCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_SCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_DCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_DCGC0_ADC        0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_DCGC0_ADCSPD_M   0x00000300  // ADC Sample Speed.
+#define SYSCTL_DCGC0_ADCSPD125K 0x00000000  // 125K samples/second
+#define SYSCTL_DCGC0_ADCSPD250K 0x00000100  // 250K samples/second
+#define SYSCTL_DCGC0_ADCSPD500K 0x00000200  // 500K samples/second
+#define SYSCTL_DCGC0_HIB        0x00000040  // HIB Clock Gating Control.
+#define SYSCTL_DCGC0_WDT        0x00000008  // WDT Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_DCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_DCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_DCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSLPCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSLPCLKCFG_D_M   0x1F800000  // Divider Field Override.
+#define SYSCTL_DSLPCLKCFG_O_M   0x00000070  // Clock Source.
+#define SYSCTL_DSLPCLKCFG_O_IGN 0x00000000  // MOSC
+#define SYSCTL_DSLPCLKCFG_O_IO  0x00000010  // IOSC
+#define SYSCTL_DSLPCLKCFG_O_30  0x00000030  // 30 kHz
+#define SYSCTL_DSLPCLKCFG_O_32  0x00000070  // 32 kHz
+#define SYSCTL_DSLPCLKCFG_D_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_LINES_M   0x0000001F  // Number of interrupt lines (x32)
+#define NVIC_INT_TYPE_LINES_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CTRL_COUNT      0x00010000  // Count flag
+#define NVIC_ST_CTRL_CLK_SRC    0x00000004  // Clock Source
+#define NVIC_ST_CTRL_INTEN      0x00000002  // Interrupt enable
+#define NVIC_ST_CTRL_ENABLE     0x00000001  // Counter mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_RELOAD register.
+//
+//*****************************************************************************
+#define NVIC_ST_RELOAD_M        0x00FFFFFF  // Counter load value
+#define NVIC_ST_RELOAD_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CURRENT
+// register.
+//
+//*****************************************************************************
+#define NVIC_ST_CURRENT_M       0x00FFFFFF  // Counter current value
+#define NVIC_ST_CURRENT_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CAL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CAL_NOREF       0x80000000  // No reference clock
+#define NVIC_ST_CAL_SKEW        0x40000000  // Clock skew
+#define NVIC_ST_CAL_ONEMS_M     0x00FFFFFF  // 1ms reference value
+#define NVIC_ST_CAL_ONEMS_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN0 register.
+//
+//*****************************************************************************
+#define NVIC_EN0_INT31          0x80000000  // Interrupt 31 enable
+#define NVIC_EN0_INT30          0x40000000  // Interrupt 30 enable
+#define NVIC_EN0_INT29          0x20000000  // Interrupt 29 enable
+#define NVIC_EN0_INT28          0x10000000  // Interrupt 28 enable
+#define NVIC_EN0_INT27          0x08000000  // Interrupt 27 enable
+#define NVIC_EN0_INT26          0x04000000  // Interrupt 26 enable
+#define NVIC_EN0_INT25          0x02000000  // Interrupt 25 enable
+#define NVIC_EN0_INT24          0x01000000  // Interrupt 24 enable
+#define NVIC_EN0_INT23          0x00800000  // Interrupt 23 enable
+#define NVIC_EN0_INT22          0x00400000  // Interrupt 22 enable
+#define NVIC_EN0_INT21          0x00200000  // Interrupt 21 enable
+#define NVIC_EN0_INT20          0x00100000  // Interrupt 20 enable
+#define NVIC_EN0_INT19          0x00080000  // Interrupt 19 enable
+#define NVIC_EN0_INT18          0x00040000  // Interrupt 18 enable
+#define NVIC_EN0_INT17          0x00020000  // Interrupt 17 enable
+#define NVIC_EN0_INT16          0x00010000  // Interrupt 16 enable
+#define NVIC_EN0_INT15          0x00008000  // Interrupt 15 enable
+#define NVIC_EN0_INT14          0x00004000  // Interrupt 14 enable
+#define NVIC_EN0_INT13          0x00002000  // Interrupt 13 enable
+#define NVIC_EN0_INT12          0x00001000  // Interrupt 12 enable
+#define NVIC_EN0_INT11          0x00000800  // Interrupt 11 enable
+#define NVIC_EN0_INT10          0x00000400  // Interrupt 10 enable
+#define NVIC_EN0_INT9           0x00000200  // Interrupt 9 enable
+#define NVIC_EN0_INT8           0x00000100  // Interrupt 8 enable
+#define NVIC_EN0_INT7           0x00000080  // Interrupt 7 enable
+#define NVIC_EN0_INT6           0x00000040  // Interrupt 6 enable
+#define NVIC_EN0_INT5           0x00000020  // Interrupt 5 enable
+#define NVIC_EN0_INT4           0x00000010  // Interrupt 4 enable
+#define NVIC_EN0_INT3           0x00000008  // Interrupt 3 enable
+#define NVIC_EN0_INT2           0x00000004  // Interrupt 2 enable
+#define NVIC_EN0_INT1           0x00000002  // Interrupt 1 enable
+#define NVIC_EN0_INT0           0x00000001  // Interrupt 0 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN1 register.
+//
+//*****************************************************************************
+#define NVIC_EN1_INT59          0x08000000  // Interrupt 59 enable
+#define NVIC_EN1_INT58          0x04000000  // Interrupt 58 enable
+#define NVIC_EN1_INT57          0x02000000  // Interrupt 57 enable
+#define NVIC_EN1_INT56          0x01000000  // Interrupt 56 enable
+#define NVIC_EN1_INT55          0x00800000  // Interrupt 55 enable
+#define NVIC_EN1_INT54          0x00400000  // Interrupt 54 enable
+#define NVIC_EN1_INT53          0x00200000  // Interrupt 53 enable
+#define NVIC_EN1_INT52          0x00100000  // Interrupt 52 enable
+#define NVIC_EN1_INT51          0x00080000  // Interrupt 51 enable
+#define NVIC_EN1_INT50          0x00040000  // Interrupt 50 enable
+#define NVIC_EN1_INT49          0x00020000  // Interrupt 49 enable
+#define NVIC_EN1_INT48          0x00010000  // Interrupt 48 enable
+#define NVIC_EN1_INT47          0x00008000  // Interrupt 47 enable
+#define NVIC_EN1_INT46          0x00004000  // Interrupt 46 enable
+#define NVIC_EN1_INT45          0x00002000  // Interrupt 45 enable
+#define NVIC_EN1_INT44          0x00001000  // Interrupt 44 enable
+#define NVIC_EN1_INT43          0x00000800  // Interrupt 43 enable
+#define NVIC_EN1_INT42          0x00000400  // Interrupt 42 enable
+#define NVIC_EN1_INT41          0x00000200  // Interrupt 41 enable
+#define NVIC_EN1_INT40          0x00000100  // Interrupt 40 enable
+#define NVIC_EN1_INT39          0x00000080  // Interrupt 39 enable
+#define NVIC_EN1_INT38          0x00000040  // Interrupt 38 enable
+#define NVIC_EN1_INT37          0x00000020  // Interrupt 37 enable
+#define NVIC_EN1_INT36          0x00000010  // Interrupt 36 enable
+#define NVIC_EN1_INT35          0x00000008  // Interrupt 35 enable
+#define NVIC_EN1_INT34          0x00000004  // Interrupt 34 enable
+#define NVIC_EN1_INT33          0x00000002  // Interrupt 33 enable
+#define NVIC_EN1_INT32          0x00000001  // Interrupt 32 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS0 register.
+//
+//*****************************************************************************
+#define NVIC_DIS0_INT31         0x80000000  // Interrupt 31 disable
+#define NVIC_DIS0_INT30         0x40000000  // Interrupt 30 disable
+#define NVIC_DIS0_INT29         0x20000000  // Interrupt 29 disable
+#define NVIC_DIS0_INT28         0x10000000  // Interrupt 28 disable
+#define NVIC_DIS0_INT27         0x08000000  // Interrupt 27 disable
+#define NVIC_DIS0_INT26         0x04000000  // Interrupt 26 disable
+#define NVIC_DIS0_INT25         0x02000000  // Interrupt 25 disable
+#define NVIC_DIS0_INT24         0x01000000  // Interrupt 24 disable
+#define NVIC_DIS0_INT23         0x00800000  // Interrupt 23 disable
+#define NVIC_DIS0_INT22         0x00400000  // Interrupt 22 disable
+#define NVIC_DIS0_INT21         0x00200000  // Interrupt 21 disable
+#define NVIC_DIS0_INT20         0x00100000  // Interrupt 20 disable
+#define NVIC_DIS0_INT19         0x00080000  // Interrupt 19 disable
+#define NVIC_DIS0_INT18         0x00040000  // Interrupt 18 disable
+#define NVIC_DIS0_INT17         0x00020000  // Interrupt 17 disable
+#define NVIC_DIS0_INT16         0x00010000  // Interrupt 16 disable
+#define NVIC_DIS0_INT15         0x00008000  // Interrupt 15 disable
+#define NVIC_DIS0_INT14         0x00004000  // Interrupt 14 disable
+#define NVIC_DIS0_INT13         0x00002000  // Interrupt 13 disable
+#define NVIC_DIS0_INT12         0x00001000  // Interrupt 12 disable
+#define NVIC_DIS0_INT11         0x00000800  // Interrupt 11 disable
+#define NVIC_DIS0_INT10         0x00000400  // Interrupt 10 disable
+#define NVIC_DIS0_INT9          0x00000200  // Interrupt 9 disable
+#define NVIC_DIS0_INT8          0x00000100  // Interrupt 8 disable
+#define NVIC_DIS0_INT7          0x00000080  // Interrupt 7 disable
+#define NVIC_DIS0_INT6          0x00000040  // Interrupt 6 disable
+#define NVIC_DIS0_INT5          0x00000020  // Interrupt 5 disable
+#define NVIC_DIS0_INT4          0x00000010  // Interrupt 4 disable
+#define NVIC_DIS0_INT3          0x00000008  // Interrupt 3 disable
+#define NVIC_DIS0_INT2          0x00000004  // Interrupt 2 disable
+#define NVIC_DIS0_INT1          0x00000002  // Interrupt 1 disable
+#define NVIC_DIS0_INT0          0x00000001  // Interrupt 0 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS1 register.
+//
+//*****************************************************************************
+#define NVIC_DIS1_INT59         0x08000000  // Interrupt 59 disable
+#define NVIC_DIS1_INT58         0x04000000  // Interrupt 58 disable
+#define NVIC_DIS1_INT57         0x02000000  // Interrupt 57 disable
+#define NVIC_DIS1_INT56         0x01000000  // Interrupt 56 disable
+#define NVIC_DIS1_INT55         0x00800000  // Interrupt 55 disable
+#define NVIC_DIS1_INT54         0x00400000  // Interrupt 54 disable
+#define NVIC_DIS1_INT53         0x00200000  // Interrupt 53 disable
+#define NVIC_DIS1_INT52         0x00100000  // Interrupt 52 disable
+#define NVIC_DIS1_INT51         0x00080000  // Interrupt 51 disable
+#define NVIC_DIS1_INT50         0x00040000  // Interrupt 50 disable
+#define NVIC_DIS1_INT49         0x00020000  // Interrupt 49 disable
+#define NVIC_DIS1_INT48         0x00010000  // Interrupt 48 disable
+#define NVIC_DIS1_INT47         0x00008000  // Interrupt 47 disable
+#define NVIC_DIS1_INT46         0x00004000  // Interrupt 46 disable
+#define NVIC_DIS1_INT45         0x00002000  // Interrupt 45 disable
+#define NVIC_DIS1_INT44         0x00001000  // Interrupt 44 disable
+#define NVIC_DIS1_INT43         0x00000800  // Interrupt 43 disable
+#define NVIC_DIS1_INT42         0x00000400  // Interrupt 42 disable
+#define NVIC_DIS1_INT41         0x00000200  // Interrupt 41 disable
+#define NVIC_DIS1_INT40         0x00000100  // Interrupt 40 disable
+#define NVIC_DIS1_INT39         0x00000080  // Interrupt 39 disable
+#define NVIC_DIS1_INT38         0x00000040  // Interrupt 38 disable
+#define NVIC_DIS1_INT37         0x00000020  // Interrupt 37 disable
+#define NVIC_DIS1_INT36         0x00000010  // Interrupt 36 disable
+#define NVIC_DIS1_INT35         0x00000008  // Interrupt 35 disable
+#define NVIC_DIS1_INT34         0x00000004  // Interrupt 34 disable
+#define NVIC_DIS1_INT33         0x00000002  // Interrupt 33 disable
+#define NVIC_DIS1_INT32         0x00000001  // Interrupt 32 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND0 register.
+//
+//*****************************************************************************
+#define NVIC_PEND0_INT31        0x80000000  // Interrupt 31 pend
+#define NVIC_PEND0_INT30        0x40000000  // Interrupt 30 pend
+#define NVIC_PEND0_INT29        0x20000000  // Interrupt 29 pend
+#define NVIC_PEND0_INT28        0x10000000  // Interrupt 28 pend
+#define NVIC_PEND0_INT27        0x08000000  // Interrupt 27 pend
+#define NVIC_PEND0_INT26        0x04000000  // Interrupt 26 pend
+#define NVIC_PEND0_INT25        0x02000000  // Interrupt 25 pend
+#define NVIC_PEND0_INT24        0x01000000  // Interrupt 24 pend
+#define NVIC_PEND0_INT23        0x00800000  // Interrupt 23 pend
+#define NVIC_PEND0_INT22        0x00400000  // Interrupt 22 pend
+#define NVIC_PEND0_INT21        0x00200000  // Interrupt 21 pend
+#define NVIC_PEND0_INT20        0x00100000  // Interrupt 20 pend
+#define NVIC_PEND0_INT19        0x00080000  // Interrupt 19 pend
+#define NVIC_PEND0_INT18        0x00040000  // Interrupt 18 pend
+#define NVIC_PEND0_INT17        0x00020000  // Interrupt 17 pend
+#define NVIC_PEND0_INT16        0x00010000  // Interrupt 16 pend
+#define NVIC_PEND0_INT15        0x00008000  // Interrupt 15 pend
+#define NVIC_PEND0_INT14        0x00004000  // Interrupt 14 pend
+#define NVIC_PEND0_INT13        0x00002000  // Interrupt 13 pend
+#define NVIC_PEND0_INT12        0x00001000  // Interrupt 12 pend
+#define NVIC_PEND0_INT11        0x00000800  // Interrupt 11 pend
+#define NVIC_PEND0_INT10        0x00000400  // Interrupt 10 pend
+#define NVIC_PEND0_INT9         0x00000200  // Interrupt 9 pend
+#define NVIC_PEND0_INT8         0x00000100  // Interrupt 8 pend
+#define NVIC_PEND0_INT7         0x00000080  // Interrupt 7 pend
+#define NVIC_PEND0_INT6         0x00000040  // Interrupt 6 pend
+#define NVIC_PEND0_INT5         0x00000020  // Interrupt 5 pend
+#define NVIC_PEND0_INT4         0x00000010  // Interrupt 4 pend
+#define NVIC_PEND0_INT3         0x00000008  // Interrupt 3 pend
+#define NVIC_PEND0_INT2         0x00000004  // Interrupt 2 pend
+#define NVIC_PEND0_INT1         0x00000002  // Interrupt 1 pend
+#define NVIC_PEND0_INT0         0x00000001  // Interrupt 0 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND1 register.
+//
+//*****************************************************************************
+#define NVIC_PEND1_INT59        0x08000000  // Interrupt 59 pend
+#define NVIC_PEND1_INT58        0x04000000  // Interrupt 58 pend
+#define NVIC_PEND1_INT57        0x02000000  // Interrupt 57 pend
+#define NVIC_PEND1_INT56        0x01000000  // Interrupt 56 pend
+#define NVIC_PEND1_INT55        0x00800000  // Interrupt 55 pend
+#define NVIC_PEND1_INT54        0x00400000  // Interrupt 54 pend
+#define NVIC_PEND1_INT53        0x00200000  // Interrupt 53 pend
+#define NVIC_PEND1_INT52        0x00100000  // Interrupt 52 pend
+#define NVIC_PEND1_INT51        0x00080000  // Interrupt 51 pend
+#define NVIC_PEND1_INT50        0x00040000  // Interrupt 50 pend
+#define NVIC_PEND1_INT49        0x00020000  // Interrupt 49 pend
+#define NVIC_PEND1_INT48        0x00010000  // Interrupt 48 pend
+#define NVIC_PEND1_INT47        0x00008000  // Interrupt 47 pend
+#define NVIC_PEND1_INT46        0x00004000  // Interrupt 46 pend
+#define NVIC_PEND1_INT45        0x00002000  // Interrupt 45 pend
+#define NVIC_PEND1_INT44        0x00001000  // Interrupt 44 pend
+#define NVIC_PEND1_INT43        0x00000800  // Interrupt 43 pend
+#define NVIC_PEND1_INT42        0x00000400  // Interrupt 42 pend
+#define NVIC_PEND1_INT41        0x00000200  // Interrupt 41 pend
+#define NVIC_PEND1_INT40        0x00000100  // Interrupt 40 pend
+#define NVIC_PEND1_INT39        0x00000080  // Interrupt 39 pend
+#define NVIC_PEND1_INT38        0x00000040  // Interrupt 38 pend
+#define NVIC_PEND1_INT37        0x00000020  // Interrupt 37 pend
+#define NVIC_PEND1_INT36        0x00000010  // Interrupt 36 pend
+#define NVIC_PEND1_INT35        0x00000008  // Interrupt 35 pend
+#define NVIC_PEND1_INT34        0x00000004  // Interrupt 34 pend
+#define NVIC_PEND1_INT33        0x00000002  // Interrupt 33 pend
+#define NVIC_PEND1_INT32        0x00000001  // Interrupt 32 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND0 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND0_INT31      0x80000000  // Interrupt 31 unpend
+#define NVIC_UNPEND0_INT30      0x40000000  // Interrupt 30 unpend
+#define NVIC_UNPEND0_INT29      0x20000000  // Interrupt 29 unpend
+#define NVIC_UNPEND0_INT28      0x10000000  // Interrupt 28 unpend
+#define NVIC_UNPEND0_INT27      0x08000000  // Interrupt 27 unpend
+#define NVIC_UNPEND0_INT26      0x04000000  // Interrupt 26 unpend
+#define NVIC_UNPEND0_INT25      0x02000000  // Interrupt 25 unpend
+#define NVIC_UNPEND0_INT24      0x01000000  // Interrupt 24 unpend
+#define NVIC_UNPEND0_INT23      0x00800000  // Interrupt 23 unpend
+#define NVIC_UNPEND0_INT22      0x00400000  // Interrupt 22 unpend
+#define NVIC_UNPEND0_INT21      0x00200000  // Interrupt 21 unpend
+#define NVIC_UNPEND0_INT20      0x00100000  // Interrupt 20 unpend
+#define NVIC_UNPEND0_INT19      0x00080000  // Interrupt 19 unpend
+#define NVIC_UNPEND0_INT18      0x00040000  // Interrupt 18 unpend
+#define NVIC_UNPEND0_INT17      0x00020000  // Interrupt 17 unpend
+#define NVIC_UNPEND0_INT16      0x00010000  // Interrupt 16 unpend
+#define NVIC_UNPEND0_INT15      0x00008000  // Interrupt 15 unpend
+#define NVIC_UNPEND0_INT14      0x00004000  // Interrupt 14 unpend
+#define NVIC_UNPEND0_INT13      0x00002000  // Interrupt 13 unpend
+#define NVIC_UNPEND0_INT12      0x00001000  // Interrupt 12 unpend
+#define NVIC_UNPEND0_INT11      0x00000800  // Interrupt 11 unpend
+#define NVIC_UNPEND0_INT10      0x00000400  // Interrupt 10 unpend
+#define NVIC_UNPEND0_INT9       0x00000200  // Interrupt 9 unpend
+#define NVIC_UNPEND0_INT8       0x00000100  // Interrupt 8 unpend
+#define NVIC_UNPEND0_INT7       0x00000080  // Interrupt 7 unpend
+#define NVIC_UNPEND0_INT6       0x00000040  // Interrupt 6 unpend
+#define NVIC_UNPEND0_INT5       0x00000020  // Interrupt 5 unpend
+#define NVIC_UNPEND0_INT4       0x00000010  // Interrupt 4 unpend
+#define NVIC_UNPEND0_INT3       0x00000008  // Interrupt 3 unpend
+#define NVIC_UNPEND0_INT2       0x00000004  // Interrupt 2 unpend
+#define NVIC_UNPEND0_INT1       0x00000002  // Interrupt 1 unpend
+#define NVIC_UNPEND0_INT0       0x00000001  // Interrupt 0 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND1 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND1_INT59      0x08000000  // Interrupt 59 unpend
+#define NVIC_UNPEND1_INT58      0x04000000  // Interrupt 58 unpend
+#define NVIC_UNPEND1_INT57      0x02000000  // Interrupt 57 unpend
+#define NVIC_UNPEND1_INT56      0x01000000  // Interrupt 56 unpend
+#define NVIC_UNPEND1_INT55      0x00800000  // Interrupt 55 unpend
+#define NVIC_UNPEND1_INT54      0x00400000  // Interrupt 54 unpend
+#define NVIC_UNPEND1_INT53      0x00200000  // Interrupt 53 unpend
+#define NVIC_UNPEND1_INT52      0x00100000  // Interrupt 52 unpend
+#define NVIC_UNPEND1_INT51      0x00080000  // Interrupt 51 unpend
+#define NVIC_UNPEND1_INT50      0x00040000  // Interrupt 50 unpend
+#define NVIC_UNPEND1_INT49      0x00020000  // Interrupt 49 unpend
+#define NVIC_UNPEND1_INT48      0x00010000  // Interrupt 48 unpend
+#define NVIC_UNPEND1_INT47      0x00008000  // Interrupt 47 unpend
+#define NVIC_UNPEND1_INT46      0x00004000  // Interrupt 46 unpend
+#define NVIC_UNPEND1_INT45      0x00002000  // Interrupt 45 unpend
+#define NVIC_UNPEND1_INT44      0x00001000  // Interrupt 44 unpend
+#define NVIC_UNPEND1_INT43      0x00000800  // Interrupt 43 unpend
+#define NVIC_UNPEND1_INT42      0x00000400  // Interrupt 42 unpend
+#define NVIC_UNPEND1_INT41      0x00000200  // Interrupt 41 unpend
+#define NVIC_UNPEND1_INT40      0x00000100  // Interrupt 40 unpend
+#define NVIC_UNPEND1_INT39      0x00000080  // Interrupt 39 unpend
+#define NVIC_UNPEND1_INT38      0x00000040  // Interrupt 38 unpend
+#define NVIC_UNPEND1_INT37      0x00000020  // Interrupt 37 unpend
+#define NVIC_UNPEND1_INT36      0x00000010  // Interrupt 36 unpend
+#define NVIC_UNPEND1_INT35      0x00000008  // Interrupt 35 unpend
+#define NVIC_UNPEND1_INT34      0x00000004  // Interrupt 34 unpend
+#define NVIC_UNPEND1_INT33      0x00000002  // Interrupt 33 unpend
+#define NVIC_UNPEND1_INT32      0x00000001  // Interrupt 32 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE0 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE0_INT31      0x80000000  // Interrupt 31 active
+#define NVIC_ACTIVE0_INT30      0x40000000  // Interrupt 30 active
+#define NVIC_ACTIVE0_INT29      0x20000000  // Interrupt 29 active
+#define NVIC_ACTIVE0_INT28      0x10000000  // Interrupt 28 active
+#define NVIC_ACTIVE0_INT27      0x08000000  // Interrupt 27 active
+#define NVIC_ACTIVE0_INT26      0x04000000  // Interrupt 26 active
+#define NVIC_ACTIVE0_INT25      0x02000000  // Interrupt 25 active
+#define NVIC_ACTIVE0_INT24      0x01000000  // Interrupt 24 active
+#define NVIC_ACTIVE0_INT23      0x00800000  // Interrupt 23 active
+#define NVIC_ACTIVE0_INT22      0x00400000  // Interrupt 22 active
+#define NVIC_ACTIVE0_INT21      0x00200000  // Interrupt 21 active
+#define NVIC_ACTIVE0_INT20      0x00100000  // Interrupt 20 active
+#define NVIC_ACTIVE0_INT19      0x00080000  // Interrupt 19 active
+#define NVIC_ACTIVE0_INT18      0x00040000  // Interrupt 18 active
+#define NVIC_ACTIVE0_INT17      0x00020000  // Interrupt 17 active
+#define NVIC_ACTIVE0_INT16      0x00010000  // Interrupt 16 active
+#define NVIC_ACTIVE0_INT15      0x00008000  // Interrupt 15 active
+#define NVIC_ACTIVE0_INT14      0x00004000  // Interrupt 14 active
+#define NVIC_ACTIVE0_INT13      0x00002000  // Interrupt 13 active
+#define NVIC_ACTIVE0_INT12      0x00001000  // Interrupt 12 active
+#define NVIC_ACTIVE0_INT11      0x00000800  // Interrupt 11 active
+#define NVIC_ACTIVE0_INT10      0x00000400  // Interrupt 10 active
+#define NVIC_ACTIVE0_INT9       0x00000200  // Interrupt 9 active
+#define NVIC_ACTIVE0_INT8       0x00000100  // Interrupt 8 active
+#define NVIC_ACTIVE0_INT7       0x00000080  // Interrupt 7 active
+#define NVIC_ACTIVE0_INT6       0x00000040  // Interrupt 6 active
+#define NVIC_ACTIVE0_INT5       0x00000020  // Interrupt 5 active
+#define NVIC_ACTIVE0_INT4       0x00000010  // Interrupt 4 active
+#define NVIC_ACTIVE0_INT3       0x00000008  // Interrupt 3 active
+#define NVIC_ACTIVE0_INT2       0x00000004  // Interrupt 2 active
+#define NVIC_ACTIVE0_INT1       0x00000002  // Interrupt 1 active
+#define NVIC_ACTIVE0_INT0       0x00000001  // Interrupt 0 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE1 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE1_INT59      0x08000000  // Interrupt 59 active
+#define NVIC_ACTIVE1_INT58      0x04000000  // Interrupt 58 active
+#define NVIC_ACTIVE1_INT57      0x02000000  // Interrupt 57 active
+#define NVIC_ACTIVE1_INT56      0x01000000  // Interrupt 56 active
+#define NVIC_ACTIVE1_INT55      0x00800000  // Interrupt 55 active
+#define NVIC_ACTIVE1_INT54      0x00400000  // Interrupt 54 active
+#define NVIC_ACTIVE1_INT53      0x00200000  // Interrupt 53 active
+#define NVIC_ACTIVE1_INT52      0x00100000  // Interrupt 52 active
+#define NVIC_ACTIVE1_INT51      0x00080000  // Interrupt 51 active
+#define NVIC_ACTIVE1_INT50      0x00040000  // Interrupt 50 active
+#define NVIC_ACTIVE1_INT49      0x00020000  // Interrupt 49 active
+#define NVIC_ACTIVE1_INT48      0x00010000  // Interrupt 48 active
+#define NVIC_ACTIVE1_INT47      0x00008000  // Interrupt 47 active
+#define NVIC_ACTIVE1_INT46      0x00004000  // Interrupt 46 active
+#define NVIC_ACTIVE1_INT45      0x00002000  // Interrupt 45 active
+#define NVIC_ACTIVE1_INT44      0x00001000  // Interrupt 44 active
+#define NVIC_ACTIVE1_INT43      0x00000800  // Interrupt 43 active
+#define NVIC_ACTIVE1_INT42      0x00000400  // Interrupt 42 active
+#define NVIC_ACTIVE1_INT41      0x00000200  // Interrupt 41 active
+#define NVIC_ACTIVE1_INT40      0x00000100  // Interrupt 40 active
+#define NVIC_ACTIVE1_INT39      0x00000080  // Interrupt 39 active
+#define NVIC_ACTIVE1_INT38      0x00000040  // Interrupt 38 active
+#define NVIC_ACTIVE1_INT37      0x00000020  // Interrupt 37 active
+#define NVIC_ACTIVE1_INT36      0x00000010  // Interrupt 36 active
+#define NVIC_ACTIVE1_INT35      0x00000008  // Interrupt 35 active
+#define NVIC_ACTIVE1_INT34      0x00000004  // Interrupt 34 active
+#define NVIC_ACTIVE1_INT33      0x00000002  // Interrupt 33 active
+#define NVIC_ACTIVE1_INT32      0x00000001  // Interrupt 32 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI0 register.
+//
+//*****************************************************************************
+#define NVIC_PRI0_INT3_M        0xFF000000  // Interrupt 3 priority mask
+#define NVIC_PRI0_INT2_M        0x00FF0000  // Interrupt 2 priority mask
+#define NVIC_PRI0_INT1_M        0x0000FF00  // Interrupt 1 priority mask
+#define NVIC_PRI0_INT0_M        0x000000FF  // Interrupt 0 priority mask
+#define NVIC_PRI0_INT3_S        24
+#define NVIC_PRI0_INT2_S        16
+#define NVIC_PRI0_INT1_S        8
+#define NVIC_PRI0_INT0_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_PRI1_INT7_M        0xFF000000  // Interrupt 7 priority mask
+#define NVIC_PRI1_INT6_M        0x00FF0000  // Interrupt 6 priority mask
+#define NVIC_PRI1_INT5_M        0x0000FF00  // Interrupt 5 priority mask
+#define NVIC_PRI1_INT4_M        0x000000FF  // Interrupt 4 priority mask
+#define NVIC_PRI1_INT7_S        24
+#define NVIC_PRI1_INT6_S        16
+#define NVIC_PRI1_INT5_S        8
+#define NVIC_PRI1_INT4_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_PRI2_INT11_M       0xFF000000  // Interrupt 11 priority mask
+#define NVIC_PRI2_INT10_M       0x00FF0000  // Interrupt 10 priority mask
+#define NVIC_PRI2_INT9_M        0x0000FF00  // Interrupt 9 priority mask
+#define NVIC_PRI2_INT8_M        0x000000FF  // Interrupt 8 priority mask
+#define NVIC_PRI2_INT11_S       24
+#define NVIC_PRI2_INT10_S       16
+#define NVIC_PRI2_INT9_S        8
+#define NVIC_PRI2_INT8_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_PRI3_INT15_M       0xFF000000  // Interrupt 15 priority mask
+#define NVIC_PRI3_INT14_M       0x00FF0000  // Interrupt 14 priority mask
+#define NVIC_PRI3_INT13_M       0x0000FF00  // Interrupt 13 priority mask
+#define NVIC_PRI3_INT12_M       0x000000FF  // Interrupt 12 priority mask
+#define NVIC_PRI3_INT15_S       24
+#define NVIC_PRI3_INT14_S       16
+#define NVIC_PRI3_INT13_S       8
+#define NVIC_PRI3_INT12_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI4 register.
+//
+//*****************************************************************************
+#define NVIC_PRI4_INT19_M       0xFF000000  // Interrupt 19 priority mask
+#define NVIC_PRI4_INT18_M       0x00FF0000  // Interrupt 18 priority mask
+#define NVIC_PRI4_INT17_M       0x0000FF00  // Interrupt 17 priority mask
+#define NVIC_PRI4_INT16_M       0x000000FF  // Interrupt 16 priority mask
+#define NVIC_PRI4_INT19_S       24
+#define NVIC_PRI4_INT18_S       16
+#define NVIC_PRI4_INT17_S       8
+#define NVIC_PRI4_INT16_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI5 register.
+//
+//*****************************************************************************
+#define NVIC_PRI5_INT23_M       0xFF000000  // Interrupt 23 priority mask
+#define NVIC_PRI5_INT22_M       0x00FF0000  // Interrupt 22 priority mask
+#define NVIC_PRI5_INT21_M       0x0000FF00  // Interrupt 21 priority mask
+#define NVIC_PRI5_INT20_M       0x000000FF  // Interrupt 20 priority mask
+#define NVIC_PRI5_INT23_S       24
+#define NVIC_PRI5_INT22_S       16
+#define NVIC_PRI5_INT21_S       8
+#define NVIC_PRI5_INT20_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI6 register.
+//
+//*****************************************************************************
+#define NVIC_PRI6_INT27_M       0xFF000000  // Interrupt 27 priority mask
+#define NVIC_PRI6_INT26_M       0x00FF0000  // Interrupt 26 priority mask
+#define NVIC_PRI6_INT25_M       0x0000FF00  // Interrupt 25 priority mask
+#define NVIC_PRI6_INT24_M       0x000000FF  // Interrupt 24 priority mask
+#define NVIC_PRI6_INT27_S       24
+#define NVIC_PRI6_INT26_S       16
+#define NVIC_PRI6_INT25_S       8
+#define NVIC_PRI6_INT24_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI7 register.
+//
+//*****************************************************************************
+#define NVIC_PRI7_INT31_M       0xFF000000  // Interrupt 31 priority mask
+#define NVIC_PRI7_INT30_M       0x00FF0000  // Interrupt 30 priority mask
+#define NVIC_PRI7_INT29_M       0x0000FF00  // Interrupt 29 priority mask
+#define NVIC_PRI7_INT28_M       0x000000FF  // Interrupt 28 priority mask
+#define NVIC_PRI7_INT31_S       24
+#define NVIC_PRI7_INT30_S       16
+#define NVIC_PRI7_INT29_S       8
+#define NVIC_PRI7_INT28_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI8 register.
+//
+//*****************************************************************************
+#define NVIC_PRI8_INT35_M       0xFF000000  // Interrupt 35 priority mask
+#define NVIC_PRI8_INT34_M       0x00FF0000  // Interrupt 34 priority mask
+#define NVIC_PRI8_INT33_M       0x0000FF00  // Interrupt 33 priority mask
+#define NVIC_PRI8_INT32_M       0x000000FF  // Interrupt 32 priority mask
+#define NVIC_PRI8_INT35_S       24
+#define NVIC_PRI8_INT34_S       16
+#define NVIC_PRI8_INT33_S       8
+#define NVIC_PRI8_INT32_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI9 register.
+//
+//*****************************************************************************
+#define NVIC_PRI9_INT39_M       0xFF000000  // Interrupt 39 priority mask
+#define NVIC_PRI9_INT38_M       0x00FF0000  // Interrupt 38 priority mask
+#define NVIC_PRI9_INT37_M       0x0000FF00  // Interrupt 37 priority mask
+#define NVIC_PRI9_INT36_M       0x000000FF  // Interrupt 36 priority mask
+#define NVIC_PRI9_INT39_S       24
+#define NVIC_PRI9_INT38_S       16
+#define NVIC_PRI9_INT37_S       8
+#define NVIC_PRI9_INT36_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI10 register.
+//
+//*****************************************************************************
+#define NVIC_PRI10_INT43_M      0xFF000000  // Interrupt 43 priority mask
+#define NVIC_PRI10_INT42_M      0x00FF0000  // Interrupt 42 priority mask
+#define NVIC_PRI10_INT41_M      0x0000FF00  // Interrupt 41 priority mask
+#define NVIC_PRI10_INT40_M      0x000000FF  // Interrupt 40 priority mask
+#define NVIC_PRI10_INT43_S      24
+#define NVIC_PRI10_INT42_S      16
+#define NVIC_PRI10_INT41_S      8
+#define NVIC_PRI10_INT40_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CPUID register.
+//
+//*****************************************************************************
+#define NVIC_CPUID_IMP_M        0xFF000000  // Implementer
+#define NVIC_CPUID_VAR_M        0x00F00000  // Variant
+#define NVIC_CPUID_PARTNO_M     0x0000FFF0  // Processor part number
+#define NVIC_CPUID_REV_M        0x0000000F  // Revision
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_INT_CTRL_NMI_SET   0x80000000  // Pend a NMI
+#define NVIC_INT_CTRL_PEND_SV   0x10000000  // Pend a PendSV
+#define NVIC_INT_CTRL_UNPEND_SV 0x08000000  // Unpend a PendSV
+#define NVIC_INT_CTRL_ISR_PRE   0x00800000  // Debug interrupt handling
+#define NVIC_INT_CTRL_ISR_PEND  0x00400000  // Debug interrupt pending
+#define NVIC_INT_CTRL_VEC_PEN_M 0x003FF000  // Highest pending exception
+#define NVIC_INT_CTRL_RET_BASE  0x00000800  // Return to base
+#define NVIC_INT_CTRL_VEC_ACT_M 0x000003FF  // Current active exception
+#define NVIC_INT_CTRL_VEC_PEN_S 12
+#define NVIC_INT_CTRL_VEC_ACT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_VTABLE register.
+//
+//*****************************************************************************
+#define NVIC_VTABLE_BASE        0x20000000  // Vector table base
+#define NVIC_VTABLE_OFFSET_M    0x1FFFFF00  // Vector table offset
+#define NVIC_VTABLE_OFFSET_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_APINT register.
+//
+//*****************************************************************************
+#define NVIC_APINT_VECTKEY_M    0xFFFF0000  // Vector key mask
+#define NVIC_APINT_VECTKEY      0x05FA0000  // Vector key
+#define NVIC_APINT_ENDIANESS    0x00008000  // Data endianess
+#define NVIC_APINT_PRIGROUP_M   0x00000700  // Priority group
+#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
+#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
+#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
+#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
+#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
+#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
+#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
+#define NVIC_APINT_SYSRESETREQ  0x00000004  // System reset request
+#define NVIC_APINT_VECT_CLR_ACT 0x00000002  // Clear active NMI/fault info
+#define NVIC_APINT_VECT_RESET   0x00000001  // System reset
+#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_SYS_CTRL_SEVONPEND 0x00000010  // Wakeup on pend
+#define NVIC_SYS_CTRL_SLEEPDEEP 0x00000004  // Deep sleep enable
+#define NVIC_SYS_CTRL_SLEEPEXIT 0x00000002  // Sleep on ISR exit
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CFG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_CFG_CTRL_BFHFNMIGN 0x00000100  // Ignore bus fault in NMI/fault
+#define NVIC_CFG_CTRL_DIV0      0x00000010  // Trap on divide by 0
+#define NVIC_CFG_CTRL_UNALIGNED 0x00000008  // Trap on unaligned access
+#define NVIC_CFG_CTRL_DEEP_PEND 0x00000004  // Allow deep interrupt trigger
+#define NVIC_CFG_CTRL_MAIN_PEND 0x00000002  // Allow main interrupt trigger
+#define NVIC_CFG_CTRL_BASE_THR  0x00000001  // Thread state control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI1_RES_M     0xFF000000  // Priority of reserved handler
+#define NVIC_SYS_PRI1_USAGE_M   0x00FF0000  // Priority of usage fault handler
+#define NVIC_SYS_PRI1_BUS_M     0x0000FF00  // Priority of bus fault handler
+#define NVIC_SYS_PRI1_MEM_M     0x000000FF  // Priority of mem manage handler
+#define NVIC_SYS_PRI1_USAGE_S   16
+#define NVIC_SYS_PRI1_BUS_S     8
+#define NVIC_SYS_PRI1_MEM_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI2_SVC_M     0xFF000000  // Priority of SVCall handler
+#define NVIC_SYS_PRI2_RES_M     0x00FFFFFF  // Priority of reserved handlers
+#define NVIC_SYS_PRI2_SVC_S     24
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI3_TICK_M    0xFF000000  // Priority of Sys Tick handler
+#define NVIC_SYS_PRI3_PENDSV_M  0x00FF0000  // Priority of PendSV handler
+#define NVIC_SYS_PRI3_RES_M     0x0000FF00  // Priority of reserved handler
+#define NVIC_SYS_PRI3_DEBUG_M   0x000000FF  // Priority of debug handler
+#define NVIC_SYS_PRI3_TICK_S    24
+#define NVIC_SYS_PRI3_PENDSV_S  16
+#define NVIC_SYS_PRI3_DEBUG_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_HND_CTRL
+// register.
+//
+//*****************************************************************************
+#define NVIC_SYS_HND_CTRL_USAGE 0x00040000  // Usage fault enable
+#define NVIC_SYS_HND_CTRL_BUS   0x00020000  // Bus fault enable
+#define NVIC_SYS_HND_CTRL_MEM   0x00010000  // Mem manage fault enable
+#define NVIC_SYS_HND_CTRL_SVC   0x00008000  // SVCall is pended
+#define NVIC_SYS_HND_CTRL_BUSP  0x00004000  // Bus fault is pended
+#define NVIC_SYS_HND_CTRL_TICK  0x00000800  // Sys tick is active
+#define NVIC_SYS_HND_CTRL_PNDSV 0x00000400  // PendSV is active
+#define NVIC_SYS_HND_CTRL_MON   0x00000100  // Monitor is active
+#define NVIC_SYS_HND_CTRL_SVCA  0x00000080  // SVCall is active
+#define NVIC_SYS_HND_CTRL_USGA  0x00000008  // Usage fault is active
+#define NVIC_SYS_HND_CTRL_BUSA  0x00000002  // Bus fault is active
+#define NVIC_SYS_HND_CTRL_MEMA  0x00000001  // Mem manage is active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_STAT_DIV0    0x02000000  // Divide by zero fault
+#define NVIC_FAULT_STAT_UNALIGN 0x01000000  // Unaligned access fault
+#define NVIC_FAULT_STAT_NOCP    0x00080000  // No coprocessor fault
+#define NVIC_FAULT_STAT_INVPC   0x00040000  // Invalid PC fault
+#define NVIC_FAULT_STAT_INVSTAT 0x00020000  // Invalid state fault
+#define NVIC_FAULT_STAT_UNDEF   0x00010000  // Undefined instruction fault
+#define NVIC_FAULT_STAT_BFARV   0x00008000  // BFAR is valid
+#define NVIC_FAULT_STAT_BSTKE   0x00001000  // Stack bus fault
+#define NVIC_FAULT_STAT_BUSTKE  0x00000800  // Unstack bus fault
+#define NVIC_FAULT_STAT_IMPRE   0x00000400  // Imprecise data bus error
+#define NVIC_FAULT_STAT_PRECISE 0x00000200  // Precise data bus error
+#define NVIC_FAULT_STAT_IBUS    0x00000100  // Instruction bus fault
+#define NVIC_FAULT_STAT_MMARV   0x00000080  // MMAR is valid
+#define NVIC_FAULT_STAT_MSTKE   0x00000010  // Stack access violation
+#define NVIC_FAULT_STAT_MUSTKE  0x00000008  // Unstack access violation
+#define NVIC_FAULT_STAT_DERR    0x00000002  // Data access violation
+#define NVIC_FAULT_STAT_IERR    0x00000001  // Instruction access violation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_HFAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_HFAULT_STAT_DBG    0x80000000  // Debug event
+#define NVIC_HFAULT_STAT_FORCED 0x40000000  // Cannot execute fault handler
+#define NVIC_HFAULT_STAT_VECT   0x00000002  // Vector table read fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DEBUG_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_DEBUG_STAT_EXTRNL  0x00000010  // EDBGRQ asserted
+#define NVIC_DEBUG_STAT_VCATCH  0x00000008  // Vector catch
+#define NVIC_DEBUG_STAT_DWTTRAP 0x00000004  // DWT match
+#define NVIC_DEBUG_STAT_BKPT    0x00000002  // Breakpoint instruction
+#define NVIC_DEBUG_STAT_HALTED  0x00000001  // Halt request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MM_ADDR register.
+//
+//*****************************************************************************
+#define NVIC_MM_ADDR_M          0xFFFFFFFF  // Data fault address
+#define NVIC_MM_ADDR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_ADDR
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_ADDR_M       0xFFFFFFFF  // Data bus fault address
+#define NVIC_FAULT_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_TYPE_IREGION_M 0x00FF0000  // Number of I regions
+#define NVIC_MPU_TYPE_DREGION_M 0x0000FF00  // Number of D regions
+#define NVIC_MPU_TYPE_SEPARATE  0x00000001  // Separate or unified MPU
+#define NVIC_MPU_TYPE_IREGION_S 16
+#define NVIC_MPU_TYPE_DREGION_S 8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_MPU_CTRL_PRIVDEFEN 0x00000004  // MPU default region in priv mode
+#define NVIC_MPU_CTRL_HFNMIENA  0x00000002  // MPU enabled during faults
+#define NVIC_MPU_CTRL_ENABLE    0x00000001  // MPU enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_NUMBER
+// register.
+//
+//*****************************************************************************
+#define NVIC_MPU_NUMBER_M       0x000000FF  // MPU region to access
+#define NVIC_MPU_NUMBER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE_ADDR_M    0xFFFFFFE0  // Base address mask
+#define NVIC_MPU_BASE_VALID     0x00000010  // Region number valid
+#define NVIC_MPU_BASE_REGION_M  0x0000000F  // Region number
+#define NVIC_MPU_BASE_ADDR_S    8
+#define NVIC_MPU_BASE_REGION_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR_M         0xFFFF0000  // Attributes
+#define NVIC_MPU_ATTR_AP_NO_NO  0x00000000  // prv: no access, usr: no access
+#define NVIC_MPU_ATTR_BUFFRABLE 0x00010000  // Bufferable
+#define NVIC_MPU_ATTR_CACHEABLE 0x00020000  // Cacheable
+#define NVIC_MPU_ATTR_SHAREABLE 0x00040000  // Shareable
+#define NVIC_MPU_ATTR_TEX_M     0x00380000  // Type extension mask
+#define NVIC_MPU_ATTR_AP_RW_NO  0x01000000  // prv: rw, usr: none
+#define NVIC_MPU_ATTR_AP_RW_RO  0x02000000  // prv: rw, usr: read-only
+#define NVIC_MPU_ATTR_AP_RW_RW  0x03000000  // prv: rw, usr: rw
+#define NVIC_MPU_ATTR_AP_RO_NO  0x05000000  // prv: ro, usr: none
+#define NVIC_MPU_ATTR_AP_RO_RO  0x06000000  // prv: ro, usr: ro
+#define NVIC_MPU_ATTR_AP_M      0x07000000  // Access permissions mask
+#define NVIC_MPU_ATTR_XN        0x10000000  // Execute disable
+#define NVIC_MPU_ATTR_SRD_M     0x0000FF00  // Sub-region disable mask
+#define NVIC_MPU_ATTR_SRD_0     0x00000100  // Sub-region 0 disable
+#define NVIC_MPU_ATTR_SRD_1     0x00000200  // Sub-region 1 disable
+#define NVIC_MPU_ATTR_SRD_2     0x00000400  // Sub-region 2 disable
+#define NVIC_MPU_ATTR_SRD_3     0x00000800  // Sub-region 3 disable
+#define NVIC_MPU_ATTR_SRD_4     0x00001000  // Sub-region 4 disable
+#define NVIC_MPU_ATTR_SRD_5     0x00002000  // Sub-region 5 disable
+#define NVIC_MPU_ATTR_SRD_6     0x00004000  // Sub-region 6 disable
+#define NVIC_MPU_ATTR_SRD_7     0x00008000  // Sub-region 7 disable
+#define NVIC_MPU_ATTR_SIZE_M    0x0000003E  // Region size mask
+#define NVIC_MPU_ATTR_SIZE_32B  0x00000008  // Region size 32 bytes
+#define NVIC_MPU_ATTR_SIZE_64B  0x0000000A  // Region size 64 bytes
+#define NVIC_MPU_ATTR_SIZE_128B 0x0000000C  // Region size 128 bytes
+#define NVIC_MPU_ATTR_SIZE_256B 0x0000000E  // Region size 256 bytes
+#define NVIC_MPU_ATTR_SIZE_512B 0x00000010  // Region size 512 bytes
+#define NVIC_MPU_ATTR_SIZE_1K   0x00000012  // Region size 1 Kbytes
+#define NVIC_MPU_ATTR_SIZE_2K   0x00000014  // Region size 2 Kbytes
+#define NVIC_MPU_ATTR_SIZE_4K   0x00000016  // Region size 4 Kbytes
+#define NVIC_MPU_ATTR_SIZE_8K   0x00000018  // Region size 8 Kbytes
+#define NVIC_MPU_ATTR_SIZE_16K  0x0000001A  // Region size 16 Kbytes
+#define NVIC_MPU_ATTR_SIZE_32K  0x0000001C  // Region size 32 Kbytes
+#define NVIC_MPU_ATTR_SIZE_64K  0x0000001E  // Region size 64 Kbytes
+#define NVIC_MPU_ATTR_SIZE_128K 0x00000020  // Region size 128 Kbytes
+#define NVIC_MPU_ATTR_SIZE_256K 0x00000022  // Region size 256 Kbytes
+#define NVIC_MPU_ATTR_SIZE_512K 0x00000024  // Region size 512 Kbytes
+#define NVIC_MPU_ATTR_SIZE_1M   0x00000026  // Region size 1 Mbytes
+#define NVIC_MPU_ATTR_SIZE_2M   0x00000028  // Region size 2 Mbytes
+#define NVIC_MPU_ATTR_SIZE_4M   0x0000002A  // Region size 4 Mbytes
+#define NVIC_MPU_ATTR_SIZE_8M   0x0000002C  // Region size 8 Mbytes
+#define NVIC_MPU_ATTR_SIZE_16M  0x0000002E  // Region size 16 Mbytes
+#define NVIC_MPU_ATTR_SIZE_32M  0x00000030  // Region size 32 Mbytes
+#define NVIC_MPU_ATTR_SIZE_64M  0x00000032  // Region size 64 Mbytes
+#define NVIC_MPU_ATTR_SIZE_128M 0x00000034  // Region size 128 Mbytes
+#define NVIC_MPU_ATTR_SIZE_256M 0x00000036  // Region size 256 Mbytes
+#define NVIC_MPU_ATTR_SIZE_512M 0x00000038  // Region size 512 Mbytes
+#define NVIC_MPU_ATTR_SIZE_1G   0x0000003A  // Region size 1 Gbytes
+#define NVIC_MPU_ATTR_SIZE_2G   0x0000003C  // Region size 2 Gbytes
+#define NVIC_MPU_ATTR_SIZE_4G   0x0000003E  // Region size 4 Gbytes
+#define NVIC_MPU_ATTR_ENABLE    0x00000001  // Region enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_DBG_CTRL_DBGKEY_M  0xFFFF0000  // Debug key mask
+#define NVIC_DBG_CTRL_DBGKEY    0xA05F0000  // Debug key
+#define NVIC_DBG_CTRL_S_RESET_ST \
+                                0x02000000  // Core has reset since last read
+#define NVIC_DBG_CTRL_S_RETIRE_ST \
+                                0x01000000  // Core has executed insruction
+                                            // since last read
+#define NVIC_DBG_CTRL_S_LOCKUP  0x00080000  // Core is locked up
+#define NVIC_DBG_CTRL_S_SLEEP   0x00040000  // Core is sleeping
+#define NVIC_DBG_CTRL_S_HALT    0x00020000  // Core status on halt
+#define NVIC_DBG_CTRL_S_REGRDY  0x00010000  // Register read/write available
+#define NVIC_DBG_CTRL_C_SNAPSTALL \
+                                0x00000020  // Breaks a stalled load/store
+#define NVIC_DBG_CTRL_C_MASKINT 0x00000008  // Mask interrupts when stepping
+#define NVIC_DBG_CTRL_C_STEP    0x00000004  // Step the core
+#define NVIC_DBG_CTRL_C_HALT    0x00000002  // Halt the core
+#define NVIC_DBG_CTRL_C_DEBUGEN 0x00000001  // Enable debug
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_XFER register.
+//
+//*****************************************************************************
+#define NVIC_DBG_XFER_REG_WNR   0x00010000  // Write or not read
+#define NVIC_DBG_XFER_REG_SEL_M 0x0000001F  // Register
+#define NVIC_DBG_XFER_REG_CFBP  0x00000014  // Control/Fault/BasePri/PriMask
+#define NVIC_DBG_XFER_REG_DSP   0x00000013  // Deep SP
+#define NVIC_DBG_XFER_REG_PSP   0x00000012  // Process SP
+#define NVIC_DBG_XFER_REG_MSP   0x00000011  // Main SP
+#define NVIC_DBG_XFER_REG_FLAGS 0x00000010  // xPSR/Flags register
+#define NVIC_DBG_XFER_REG_R15   0x0000000F  // Register R15
+#define NVIC_DBG_XFER_REG_R14   0x0000000E  // Register R14
+#define NVIC_DBG_XFER_REG_R13   0x0000000D  // Register R13
+#define NVIC_DBG_XFER_REG_R12   0x0000000C  // Register R12
+#define NVIC_DBG_XFER_REG_R11   0x0000000B  // Register R11
+#define NVIC_DBG_XFER_REG_R10   0x0000000A  // Register R10
+#define NVIC_DBG_XFER_REG_R9    0x00000009  // Register R9
+#define NVIC_DBG_XFER_REG_R8    0x00000008  // Register R8
+#define NVIC_DBG_XFER_REG_R7    0x00000007  // Register R7
+#define NVIC_DBG_XFER_REG_R6    0x00000006  // Register R6
+#define NVIC_DBG_XFER_REG_R5    0x00000005  // Register R5
+#define NVIC_DBG_XFER_REG_R4    0x00000004  // Register R4
+#define NVIC_DBG_XFER_REG_R3    0x00000003  // Register R3
+#define NVIC_DBG_XFER_REG_R2    0x00000002  // Register R2
+#define NVIC_DBG_XFER_REG_R1    0x00000001  // Register R1
+#define NVIC_DBG_XFER_REG_R0    0x00000000  // Register R0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_DATA register.
+//
+//*****************************************************************************
+#define NVIC_DBG_DATA_M         0xFFFFFFFF  // Data temporary cache
+#define NVIC_DBG_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_INT register.
+//
+//*****************************************************************************
+#define NVIC_DBG_INT_HARDERR    0x00000400  // Debug trap on hard fault
+#define NVIC_DBG_INT_INTERR     0x00000200  // Debug trap on interrupt errors
+#define NVIC_DBG_INT_BUSERR     0x00000100  // Debug trap on bus error
+#define NVIC_DBG_INT_STATERR    0x00000080  // Debug trap on usage fault state
+#define NVIC_DBG_INT_CHKERR     0x00000040  // Debug trap on usage fault check
+#define NVIC_DBG_INT_NOCPERR    0x00000020  // Debug trap on coprocessor error
+#define NVIC_DBG_INT_MMERR      0x00000010  // Debug trap on mem manage fault
+#define NVIC_DBG_INT_RESET      0x00000008  // Core reset status
+#define NVIC_DBG_INT_RSTPENDCLR 0x00000004  // Clear pending core reset
+#define NVIC_DBG_INT_RSTPENDING 0x00000002  // Core reset is pending
+#define NVIC_DBG_INT_RSTVCATCH  0x00000001  // Reset vector catch
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SW_TRIG register.
+//
+//*****************************************************************************
+#define NVIC_SW_TRIG_INTID_M    0x000003FF  // Interrupt to trigger
+#define NVIC_SW_TRIG_INTID_S    0
+
+#endif // __LM3S8962_H__


Property changes on: trunk/src/platform/lm3s/lm3s8962.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/lm3s9b92.h
===================================================================
--- trunk/src/platform/lm3s/lm3s9b92.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/lm3s9b92.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,11836 @@
+//*****************************************************************************
+//
+// lm3s9b92.h - LM3S9B92 Register Definitions
+//
+// Copyright (c) 2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __LM3S9B92_H__
+#define __LM3S9B92_H__
+
+//*****************************************************************************
+//
+// Watchdog Timers (WATCHDOG0)
+//
+//*****************************************************************************
+#define WATCHDOG0_LOAD_R        (*((volatile unsigned long *)0x40000000))
+#define WATCHDOG0_VALUE_R       (*((volatile unsigned long *)0x40000004))
+#define WATCHDOG0_CTL_R         (*((volatile unsigned long *)0x40000008))
+#define WATCHDOG0_ICR_R         (*((volatile unsigned long *)0x4000000C))
+#define WATCHDOG0_RIS_R         (*((volatile unsigned long *)0x40000010))
+#define WATCHDOG0_MIS_R         (*((volatile unsigned long *)0x40000014))
+#define WATCHDOG0_TEST_R        (*((volatile unsigned long *)0x40000418))
+#define WATCHDOG0_LOCK_R        (*((volatile unsigned long *)0x40000C00))
+
+//*****************************************************************************
+//
+// Watchdog Timers (WATCHDOG1)
+//
+//*****************************************************************************
+#define WATCHDOG1_LOAD_R        (*((volatile unsigned long *)0x40001000))
+#define WATCHDOG1_VALUE_R       (*((volatile unsigned long *)0x40001004))
+#define WATCHDOG1_CTL_R         (*((volatile unsigned long *)0x40001008))
+#define WATCHDOG1_ICR_R         (*((volatile unsigned long *)0x4000100C))
+#define WATCHDOG1_RIS_R         (*((volatile unsigned long *)0x40001010))
+#define WATCHDOG1_MIS_R         (*((volatile unsigned long *)0x40001014))
+#define WATCHDOG1_TEST_R        (*((volatile unsigned long *)0x40001418))
+#define WATCHDOG1_LOCK_R        (*((volatile unsigned long *)0x40001C00))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTA)
+//
+//*****************************************************************************
+#define GPIO_PORTA_DATA_BITS_R  ((volatile unsigned long *)0x40004000)
+#define GPIO_PORTA_DATA_R       (*((volatile unsigned long *)0x400043FC))
+#define GPIO_PORTA_DIR_R        (*((volatile unsigned long *)0x40004400))
+#define GPIO_PORTA_IS_R         (*((volatile unsigned long *)0x40004404))
+#define GPIO_PORTA_IBE_R        (*((volatile unsigned long *)0x40004408))
+#define GPIO_PORTA_IEV_R        (*((volatile unsigned long *)0x4000440C))
+#define GPIO_PORTA_IM_R         (*((volatile unsigned long *)0x40004410))
+#define GPIO_PORTA_RIS_R        (*((volatile unsigned long *)0x40004414))
+#define GPIO_PORTA_MIS_R        (*((volatile unsigned long *)0x40004418))
+#define GPIO_PORTA_ICR_R        (*((volatile unsigned long *)0x4000441C))
+#define GPIO_PORTA_AFSEL_R      (*((volatile unsigned long *)0x40004420))
+#define GPIO_PORTA_DR2R_R       (*((volatile unsigned long *)0x40004500))
+#define GPIO_PORTA_DR4R_R       (*((volatile unsigned long *)0x40004504))
+#define GPIO_PORTA_DR8R_R       (*((volatile unsigned long *)0x40004508))
+#define GPIO_PORTA_ODR_R        (*((volatile unsigned long *)0x4000450C))
+#define GPIO_PORTA_PUR_R        (*((volatile unsigned long *)0x40004510))
+#define GPIO_PORTA_PDR_R        (*((volatile unsigned long *)0x40004514))
+#define GPIO_PORTA_SLR_R        (*((volatile unsigned long *)0x40004518))
+#define GPIO_PORTA_DEN_R        (*((volatile unsigned long *)0x4000451C))
+#define GPIO_PORTA_LOCK_R       (*((volatile unsigned long *)0x40004520))
+#define GPIO_PORTA_CR_R         (*((volatile unsigned long *)0x40004524))
+#define GPIO_PORTA_AMSEL_R      (*((volatile unsigned long *)0x40004528))
+#define GPIO_PORTA_PCTL_R       (*((volatile unsigned long *)0x4000452C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTB)
+//
+//*****************************************************************************
+#define GPIO_PORTB_DATA_BITS_R  ((volatile unsigned long *)0x40005000)
+#define GPIO_PORTB_DATA_R       (*((volatile unsigned long *)0x400053FC))
+#define GPIO_PORTB_DIR_R        (*((volatile unsigned long *)0x40005400))
+#define GPIO_PORTB_IS_R         (*((volatile unsigned long *)0x40005404))
+#define GPIO_PORTB_IBE_R        (*((volatile unsigned long *)0x40005408))
+#define GPIO_PORTB_IEV_R        (*((volatile unsigned long *)0x4000540C))
+#define GPIO_PORTB_IM_R         (*((volatile unsigned long *)0x40005410))
+#define GPIO_PORTB_RIS_R        (*((volatile unsigned long *)0x40005414))
+#define GPIO_PORTB_MIS_R        (*((volatile unsigned long *)0x40005418))
+#define GPIO_PORTB_ICR_R        (*((volatile unsigned long *)0x4000541C))
+#define GPIO_PORTB_AFSEL_R      (*((volatile unsigned long *)0x40005420))
+#define GPIO_PORTB_DR2R_R       (*((volatile unsigned long *)0x40005500))
+#define GPIO_PORTB_DR4R_R       (*((volatile unsigned long *)0x40005504))
+#define GPIO_PORTB_DR8R_R       (*((volatile unsigned long *)0x40005508))
+#define GPIO_PORTB_ODR_R        (*((volatile unsigned long *)0x4000550C))
+#define GPIO_PORTB_PUR_R        (*((volatile unsigned long *)0x40005510))
+#define GPIO_PORTB_PDR_R        (*((volatile unsigned long *)0x40005514))
+#define GPIO_PORTB_SLR_R        (*((volatile unsigned long *)0x40005518))
+#define GPIO_PORTB_DEN_R        (*((volatile unsigned long *)0x4000551C))
+#define GPIO_PORTB_LOCK_R       (*((volatile unsigned long *)0x40005520))
+#define GPIO_PORTB_CR_R         (*((volatile unsigned long *)0x40005524))
+#define GPIO_PORTB_AMSEL_R      (*((volatile unsigned long *)0x40005528))
+#define GPIO_PORTB_PCTL_R       (*((volatile unsigned long *)0x4000552C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTC)
+//
+//*****************************************************************************
+#define GPIO_PORTC_DATA_BITS_R  ((volatile unsigned long *)0x40006000)
+#define GPIO_PORTC_DATA_R       (*((volatile unsigned long *)0x400063FC))
+#define GPIO_PORTC_DIR_R        (*((volatile unsigned long *)0x40006400))
+#define GPIO_PORTC_IS_R         (*((volatile unsigned long *)0x40006404))
+#define GPIO_PORTC_IBE_R        (*((volatile unsigned long *)0x40006408))
+#define GPIO_PORTC_IEV_R        (*((volatile unsigned long *)0x4000640C))
+#define GPIO_PORTC_IM_R         (*((volatile unsigned long *)0x40006410))
+#define GPIO_PORTC_RIS_R        (*((volatile unsigned long *)0x40006414))
+#define GPIO_PORTC_MIS_R        (*((volatile unsigned long *)0x40006418))
+#define GPIO_PORTC_ICR_R        (*((volatile unsigned long *)0x4000641C))
+#define GPIO_PORTC_AFSEL_R      (*((volatile unsigned long *)0x40006420))
+#define GPIO_PORTC_DR2R_R       (*((volatile unsigned long *)0x40006500))
+#define GPIO_PORTC_DR4R_R       (*((volatile unsigned long *)0x40006504))
+#define GPIO_PORTC_DR8R_R       (*((volatile unsigned long *)0x40006508))
+#define GPIO_PORTC_ODR_R        (*((volatile unsigned long *)0x4000650C))
+#define GPIO_PORTC_PUR_R        (*((volatile unsigned long *)0x40006510))
+#define GPIO_PORTC_PDR_R        (*((volatile unsigned long *)0x40006514))
+#define GPIO_PORTC_SLR_R        (*((volatile unsigned long *)0x40006518))
+#define GPIO_PORTC_DEN_R        (*((volatile unsigned long *)0x4000651C))
+#define GPIO_PORTC_LOCK_R       (*((volatile unsigned long *)0x40006520))
+#define GPIO_PORTC_CR_R         (*((volatile unsigned long *)0x40006524))
+#define GPIO_PORTC_AMSEL_R      (*((volatile unsigned long *)0x40006528))
+#define GPIO_PORTC_PCTL_R       (*((volatile unsigned long *)0x4000652C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTD)
+//
+//*****************************************************************************
+#define GPIO_PORTD_DATA_BITS_R  ((volatile unsigned long *)0x40007000)
+#define GPIO_PORTD_DATA_R       (*((volatile unsigned long *)0x400073FC))
+#define GPIO_PORTD_DIR_R        (*((volatile unsigned long *)0x40007400))
+#define GPIO_PORTD_IS_R         (*((volatile unsigned long *)0x40007404))
+#define GPIO_PORTD_IBE_R        (*((volatile unsigned long *)0x40007408))
+#define GPIO_PORTD_IEV_R        (*((volatile unsigned long *)0x4000740C))
+#define GPIO_PORTD_IM_R         (*((volatile unsigned long *)0x40007410))
+#define GPIO_PORTD_RIS_R        (*((volatile unsigned long *)0x40007414))
+#define GPIO_PORTD_MIS_R        (*((volatile unsigned long *)0x40007418))
+#define GPIO_PORTD_ICR_R        (*((volatile unsigned long *)0x4000741C))
+#define GPIO_PORTD_AFSEL_R      (*((volatile unsigned long *)0x40007420))
+#define GPIO_PORTD_DR2R_R       (*((volatile unsigned long *)0x40007500))
+#define GPIO_PORTD_DR4R_R       (*((volatile unsigned long *)0x40007504))
+#define GPIO_PORTD_DR8R_R       (*((volatile unsigned long *)0x40007508))
+#define GPIO_PORTD_ODR_R        (*((volatile unsigned long *)0x4000750C))
+#define GPIO_PORTD_PUR_R        (*((volatile unsigned long *)0x40007510))
+#define GPIO_PORTD_PDR_R        (*((volatile unsigned long *)0x40007514))
+#define GPIO_PORTD_SLR_R        (*((volatile unsigned long *)0x40007518))
+#define GPIO_PORTD_DEN_R        (*((volatile unsigned long *)0x4000751C))
+#define GPIO_PORTD_LOCK_R       (*((volatile unsigned long *)0x40007520))
+#define GPIO_PORTD_CR_R         (*((volatile unsigned long *)0x40007524))
+#define GPIO_PORTD_AMSEL_R      (*((volatile unsigned long *)0x40007528))
+#define GPIO_PORTD_PCTL_R       (*((volatile unsigned long *)0x4000752C))
+
+//*****************************************************************************
+//
+// Synchronous Serial Interface (SSI0)
+//
+//*****************************************************************************
+#define SSI0_CR0_R              (*((volatile unsigned long *)0x40008000))
+#define SSI0_CR1_R              (*((volatile unsigned long *)0x40008004))
+#define SSI0_DR_R               (*((volatile unsigned long *)0x40008008))
+#define SSI0_SR_R               (*((volatile unsigned long *)0x4000800C))
+#define SSI0_CPSR_R             (*((volatile unsigned long *)0x40008010))
+#define SSI0_IM_R               (*((volatile unsigned long *)0x40008014))
+#define SSI0_RIS_R              (*((volatile unsigned long *)0x40008018))
+#define SSI0_MIS_R              (*((volatile unsigned long *)0x4000801C))
+#define SSI0_ICR_R              (*((volatile unsigned long *)0x40008020))
+#define SSI0_DMACTL_R           (*((volatile unsigned long *)0x40008024))
+
+//*****************************************************************************
+//
+// Synchronous Serial Interface (SSI1)
+//
+//*****************************************************************************
+#define SSI1_CR0_R              (*((volatile unsigned long *)0x40009000))
+#define SSI1_CR1_R              (*((volatile unsigned long *)0x40009004))
+#define SSI1_DR_R               (*((volatile unsigned long *)0x40009008))
+#define SSI1_SR_R               (*((volatile unsigned long *)0x4000900C))
+#define SSI1_CPSR_R             (*((volatile unsigned long *)0x40009010))
+#define SSI1_IM_R               (*((volatile unsigned long *)0x40009014))
+#define SSI1_RIS_R              (*((volatile unsigned long *)0x40009018))
+#define SSI1_MIS_R              (*((volatile unsigned long *)0x4000901C))
+#define SSI1_ICR_R              (*((volatile unsigned long *)0x40009020))
+#define SSI1_DMACTL_R           (*((volatile unsigned long *)0x40009024))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART0)
+//
+//*****************************************************************************
+#define UART0_DR_R              (*((volatile unsigned long *)0x4000C000))
+#define UART0_RSR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_ECR_R             (*((volatile unsigned long *)0x4000C004))
+#define UART0_FR_R              (*((volatile unsigned long *)0x4000C018))
+#define UART0_ILPR_R            (*((volatile unsigned long *)0x4000C020))
+#define UART0_IBRD_R            (*((volatile unsigned long *)0x4000C024))
+#define UART0_FBRD_R            (*((volatile unsigned long *)0x4000C028))
+#define UART0_LCRH_R            (*((volatile unsigned long *)0x4000C02C))
+#define UART0_CTL_R             (*((volatile unsigned long *)0x4000C030))
+#define UART0_IFLS_R            (*((volatile unsigned long *)0x4000C034))
+#define UART0_IM_R              (*((volatile unsigned long *)0x4000C038))
+#define UART0_RIS_R             (*((volatile unsigned long *)0x4000C03C))
+#define UART0_MIS_R             (*((volatile unsigned long *)0x4000C040))
+#define UART0_ICR_R             (*((volatile unsigned long *)0x4000C044))
+#define UART0_DMACTL_R          (*((volatile unsigned long *)0x4000C048))
+#define UART0_LCTL_R            (*((volatile unsigned long *)0x4000C090))
+#define UART0_LSS_R             (*((volatile unsigned long *)0x4000C094))
+#define UART0_LTIM_R            (*((volatile unsigned long *)0x4000C098))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART1)
+//
+//*****************************************************************************
+#define UART1_DR_R              (*((volatile unsigned long *)0x4000D000))
+#define UART1_RSR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_ECR_R             (*((volatile unsigned long *)0x4000D004))
+#define UART1_FR_R              (*((volatile unsigned long *)0x4000D018))
+#define UART1_ILPR_R            (*((volatile unsigned long *)0x4000D020))
+#define UART1_IBRD_R            (*((volatile unsigned long *)0x4000D024))
+#define UART1_FBRD_R            (*((volatile unsigned long *)0x4000D028))
+#define UART1_LCRH_R            (*((volatile unsigned long *)0x4000D02C))
+#define UART1_CTL_R             (*((volatile unsigned long *)0x4000D030))
+#define UART1_IFLS_R            (*((volatile unsigned long *)0x4000D034))
+#define UART1_IM_R              (*((volatile unsigned long *)0x4000D038))
+#define UART1_RIS_R             (*((volatile unsigned long *)0x4000D03C))
+#define UART1_MIS_R             (*((volatile unsigned long *)0x4000D040))
+#define UART1_ICR_R             (*((volatile unsigned long *)0x4000D044))
+#define UART1_DMACTL_R          (*((volatile unsigned long *)0x4000D048))
+#define UART1_LCTL_R            (*((volatile unsigned long *)0x4000D090))
+#define UART1_LSS_R             (*((volatile unsigned long *)0x4000D094))
+#define UART1_LTIM_R            (*((volatile unsigned long *)0x4000D098))
+
+//*****************************************************************************
+//
+// Universal Asynchronous Receivers/Transmitters (UART2)
+//
+//*****************************************************************************
+#define UART2_DR_R              (*((volatile unsigned long *)0x4000E000))
+#define UART2_RSR_R             (*((volatile unsigned long *)0x4000E004))
+#define UART2_ECR_R             (*((volatile unsigned long *)0x4000E004))
+#define UART2_FR_R              (*((volatile unsigned long *)0x4000E018))
+#define UART2_ILPR_R            (*((volatile unsigned long *)0x4000E020))
+#define UART2_IBRD_R            (*((volatile unsigned long *)0x4000E024))
+#define UART2_FBRD_R            (*((volatile unsigned long *)0x4000E028))
+#define UART2_LCRH_R            (*((volatile unsigned long *)0x4000E02C))
+#define UART2_CTL_R             (*((volatile unsigned long *)0x4000E030))
+#define UART2_IFLS_R            (*((volatile unsigned long *)0x4000E034))
+#define UART2_IM_R              (*((volatile unsigned long *)0x4000E038))
+#define UART2_RIS_R             (*((volatile unsigned long *)0x4000E03C))
+#define UART2_MIS_R             (*((volatile unsigned long *)0x4000E040))
+#define UART2_ICR_R             (*((volatile unsigned long *)0x4000E044))
+#define UART2_DMACTL_R          (*((volatile unsigned long *)0x4000E048))
+#define UART2_LCTL_R            (*((volatile unsigned long *)0x4000E090))
+#define UART2_LSS_R             (*((volatile unsigned long *)0x4000E094))
+#define UART2_LTIM_R            (*((volatile unsigned long *)0x4000E098))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (MASTER) Interface
+//
+//*****************************************************************************
+#define I2C0_MASTER_MSA_R       (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SOAR_R      (*((volatile unsigned long *)0x40020000))
+#define I2C0_MASTER_SCSR_R      (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_MCS_R       (*((volatile unsigned long *)0x40020004))
+#define I2C0_MASTER_SDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MDR_R       (*((volatile unsigned long *)0x40020008))
+#define I2C0_MASTER_MTPR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SIMR_R      (*((volatile unsigned long *)0x4002000C))
+#define I2C0_MASTER_SRIS_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MIMR_R      (*((volatile unsigned long *)0x40020010))
+#define I2C0_MASTER_MRIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SMIS_R      (*((volatile unsigned long *)0x40020014))
+#define I2C0_MASTER_SICR_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MMIS_R      (*((volatile unsigned long *)0x40020018))
+#define I2C0_MASTER_MICR_R      (*((volatile unsigned long *)0x4002001C))
+#define I2C0_MASTER_MCR_R       (*((volatile unsigned long *)0x40020020))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (SLAVE) Interface
+//
+//*****************************************************************************
+#define I2C0_SLAVE_MSA_R        (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SOAR_R       (*((volatile unsigned long *)0x40020800))
+#define I2C0_SLAVE_SCSR_R       (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_MCS_R        (*((volatile unsigned long *)0x40020804))
+#define I2C0_SLAVE_SDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MDR_R        (*((volatile unsigned long *)0x40020808))
+#define I2C0_SLAVE_MTPR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SIMR_R       (*((volatile unsigned long *)0x4002080C))
+#define I2C0_SLAVE_SRIS_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MIMR_R       (*((volatile unsigned long *)0x40020810))
+#define I2C0_SLAVE_MRIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SMIS_R       (*((volatile unsigned long *)0x40020814))
+#define I2C0_SLAVE_SICR_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MMIS_R       (*((volatile unsigned long *)0x40020818))
+#define I2C0_SLAVE_MICR_R       (*((volatile unsigned long *)0x4002081C))
+#define I2C0_SLAVE_MCR_R        (*((volatile unsigned long *)0x40020820))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (MASTER) Interface
+//
+//*****************************************************************************
+#define I2C1_MASTER_MSA_R       (*((volatile unsigned long *)0x40021000))
+#define I2C1_MASTER_SOAR_R      (*((volatile unsigned long *)0x40021000))
+#define I2C1_MASTER_SCSR_R      (*((volatile unsigned long *)0x40021004))
+#define I2C1_MASTER_MCS_R       (*((volatile unsigned long *)0x40021004))
+#define I2C1_MASTER_SDR_R       (*((volatile unsigned long *)0x40021008))
+#define I2C1_MASTER_MDR_R       (*((volatile unsigned long *)0x40021008))
+#define I2C1_MASTER_MTPR_R      (*((volatile unsigned long *)0x4002100C))
+#define I2C1_MASTER_SIMR_R      (*((volatile unsigned long *)0x4002100C))
+#define I2C1_MASTER_SRIS_R      (*((volatile unsigned long *)0x40021010))
+#define I2C1_MASTER_MIMR_R      (*((volatile unsigned long *)0x40021010))
+#define I2C1_MASTER_MRIS_R      (*((volatile unsigned long *)0x40021014))
+#define I2C1_MASTER_SMIS_R      (*((volatile unsigned long *)0x40021014))
+#define I2C1_MASTER_SICR_R      (*((volatile unsigned long *)0x40021018))
+#define I2C1_MASTER_MMIS_R      (*((volatile unsigned long *)0x40021018))
+#define I2C1_MASTER_MICR_R      (*((volatile unsigned long *)0x4002101C))
+#define I2C1_MASTER_MCR_R       (*((volatile unsigned long *)0x40021020))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit (SLAVE) Interface
+//
+//*****************************************************************************
+#define I2C1_SLAVE_MSA_R        (*((volatile unsigned long *)0x40021800))
+#define I2C1_SLAVE_SOAR_R       (*((volatile unsigned long *)0x40021800))
+#define I2C1_SLAVE_SCSR_R       (*((volatile unsigned long *)0x40021804))
+#define I2C1_SLAVE_MCS_R        (*((volatile unsigned long *)0x40021804))
+#define I2C1_SLAVE_SDR_R        (*((volatile unsigned long *)0x40021808))
+#define I2C1_SLAVE_MDR_R        (*((volatile unsigned long *)0x40021808))
+#define I2C1_SLAVE_MTPR_R       (*((volatile unsigned long *)0x4002180C))
+#define I2C1_SLAVE_SIMR_R       (*((volatile unsigned long *)0x4002180C))
+#define I2C1_SLAVE_SRIS_R       (*((volatile unsigned long *)0x40021810))
+#define I2C1_SLAVE_MIMR_R       (*((volatile unsigned long *)0x40021810))
+#define I2C1_SLAVE_MRIS_R       (*((volatile unsigned long *)0x40021814))
+#define I2C1_SLAVE_SMIS_R       (*((volatile unsigned long *)0x40021814))
+#define I2C1_SLAVE_SICR_R       (*((volatile unsigned long *)0x40021818))
+#define I2C1_SLAVE_MMIS_R       (*((volatile unsigned long *)0x40021818))
+#define I2C1_SLAVE_MICR_R       (*((volatile unsigned long *)0x4002181C))
+#define I2C1_SLAVE_MCR_R        (*((volatile unsigned long *)0x40021820))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTE)
+//
+//*****************************************************************************
+#define GPIO_PORTE_DATA_BITS_R  ((volatile unsigned long *)0x40024000)
+#define GPIO_PORTE_DATA_R       (*((volatile unsigned long *)0x400243FC))
+#define GPIO_PORTE_DIR_R        (*((volatile unsigned long *)0x40024400))
+#define GPIO_PORTE_IS_R         (*((volatile unsigned long *)0x40024404))
+#define GPIO_PORTE_IBE_R        (*((volatile unsigned long *)0x40024408))
+#define GPIO_PORTE_IEV_R        (*((volatile unsigned long *)0x4002440C))
+#define GPIO_PORTE_IM_R         (*((volatile unsigned long *)0x40024410))
+#define GPIO_PORTE_RIS_R        (*((volatile unsigned long *)0x40024414))
+#define GPIO_PORTE_MIS_R        (*((volatile unsigned long *)0x40024418))
+#define GPIO_PORTE_ICR_R        (*((volatile unsigned long *)0x4002441C))
+#define GPIO_PORTE_AFSEL_R      (*((volatile unsigned long *)0x40024420))
+#define GPIO_PORTE_DR2R_R       (*((volatile unsigned long *)0x40024500))
+#define GPIO_PORTE_DR4R_R       (*((volatile unsigned long *)0x40024504))
+#define GPIO_PORTE_DR8R_R       (*((volatile unsigned long *)0x40024508))
+#define GPIO_PORTE_ODR_R        (*((volatile unsigned long *)0x4002450C))
+#define GPIO_PORTE_PUR_R        (*((volatile unsigned long *)0x40024510))
+#define GPIO_PORTE_PDR_R        (*((volatile unsigned long *)0x40024514))
+#define GPIO_PORTE_SLR_R        (*((volatile unsigned long *)0x40024518))
+#define GPIO_PORTE_DEN_R        (*((volatile unsigned long *)0x4002451C))
+#define GPIO_PORTE_LOCK_R       (*((volatile unsigned long *)0x40024520))
+#define GPIO_PORTE_CR_R         (*((volatile unsigned long *)0x40024524))
+#define GPIO_PORTE_AMSEL_R      (*((volatile unsigned long *)0x40024528))
+#define GPIO_PORTE_PCTL_R       (*((volatile unsigned long *)0x4002452C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTF)
+//
+//*****************************************************************************
+#define GPIO_PORTF_DATA_BITS_R  ((volatile unsigned long *)0x40025000)
+#define GPIO_PORTF_DATA_R       (*((volatile unsigned long *)0x400253FC))
+#define GPIO_PORTF_DIR_R        (*((volatile unsigned long *)0x40025400))
+#define GPIO_PORTF_IS_R         (*((volatile unsigned long *)0x40025404))
+#define GPIO_PORTF_IBE_R        (*((volatile unsigned long *)0x40025408))
+#define GPIO_PORTF_IEV_R        (*((volatile unsigned long *)0x4002540C))
+#define GPIO_PORTF_IM_R         (*((volatile unsigned long *)0x40025410))
+#define GPIO_PORTF_RIS_R        (*((volatile unsigned long *)0x40025414))
+#define GPIO_PORTF_MIS_R        (*((volatile unsigned long *)0x40025418))
+#define GPIO_PORTF_ICR_R        (*((volatile unsigned long *)0x4002541C))
+#define GPIO_PORTF_AFSEL_R      (*((volatile unsigned long *)0x40025420))
+#define GPIO_PORTF_DR2R_R       (*((volatile unsigned long *)0x40025500))
+#define GPIO_PORTF_DR4R_R       (*((volatile unsigned long *)0x40025504))
+#define GPIO_PORTF_DR8R_R       (*((volatile unsigned long *)0x40025508))
+#define GPIO_PORTF_ODR_R        (*((volatile unsigned long *)0x4002550C))
+#define GPIO_PORTF_PUR_R        (*((volatile unsigned long *)0x40025510))
+#define GPIO_PORTF_PDR_R        (*((volatile unsigned long *)0x40025514))
+#define GPIO_PORTF_SLR_R        (*((volatile unsigned long *)0x40025518))
+#define GPIO_PORTF_DEN_R        (*((volatile unsigned long *)0x4002551C))
+#define GPIO_PORTF_LOCK_R       (*((volatile unsigned long *)0x40025520))
+#define GPIO_PORTF_CR_R         (*((volatile unsigned long *)0x40025524))
+#define GPIO_PORTF_AMSEL_R      (*((volatile unsigned long *)0x40025528))
+#define GPIO_PORTF_PCTL_R       (*((volatile unsigned long *)0x4002552C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTG)
+//
+//*****************************************************************************
+#define GPIO_PORTG_DATA_BITS_R  ((volatile unsigned long *)0x40026000)
+#define GPIO_PORTG_DATA_R       (*((volatile unsigned long *)0x400263FC))
+#define GPIO_PORTG_DIR_R        (*((volatile unsigned long *)0x40026400))
+#define GPIO_PORTG_IS_R         (*((volatile unsigned long *)0x40026404))
+#define GPIO_PORTG_IBE_R        (*((volatile unsigned long *)0x40026408))
+#define GPIO_PORTG_IEV_R        (*((volatile unsigned long *)0x4002640C))
+#define GPIO_PORTG_IM_R         (*((volatile unsigned long *)0x40026410))
+#define GPIO_PORTG_RIS_R        (*((volatile unsigned long *)0x40026414))
+#define GPIO_PORTG_MIS_R        (*((volatile unsigned long *)0x40026418))
+#define GPIO_PORTG_ICR_R        (*((volatile unsigned long *)0x4002641C))
+#define GPIO_PORTG_AFSEL_R      (*((volatile unsigned long *)0x40026420))
+#define GPIO_PORTG_DR2R_R       (*((volatile unsigned long *)0x40026500))
+#define GPIO_PORTG_DR4R_R       (*((volatile unsigned long *)0x40026504))
+#define GPIO_PORTG_DR8R_R       (*((volatile unsigned long *)0x40026508))
+#define GPIO_PORTG_ODR_R        (*((volatile unsigned long *)0x4002650C))
+#define GPIO_PORTG_PUR_R        (*((volatile unsigned long *)0x40026510))
+#define GPIO_PORTG_PDR_R        (*((volatile unsigned long *)0x40026514))
+#define GPIO_PORTG_SLR_R        (*((volatile unsigned long *)0x40026518))
+#define GPIO_PORTG_DEN_R        (*((volatile unsigned long *)0x4002651C))
+#define GPIO_PORTG_LOCK_R       (*((volatile unsigned long *)0x40026520))
+#define GPIO_PORTG_CR_R         (*((volatile unsigned long *)0x40026524))
+#define GPIO_PORTG_AMSEL_R      (*((volatile unsigned long *)0x40026528))
+#define GPIO_PORTG_PCTL_R       (*((volatile unsigned long *)0x4002652C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTH)
+//
+//*****************************************************************************
+#define GPIO_PORTH_DATA_BITS_R  ((volatile unsigned long *)0x40027000)
+#define GPIO_PORTH_DATA_R       (*((volatile unsigned long *)0x400273FC))
+#define GPIO_PORTH_DIR_R        (*((volatile unsigned long *)0x40027400))
+#define GPIO_PORTH_IS_R         (*((volatile unsigned long *)0x40027404))
+#define GPIO_PORTH_IBE_R        (*((volatile unsigned long *)0x40027408))
+#define GPIO_PORTH_IEV_R        (*((volatile unsigned long *)0x4002740C))
+#define GPIO_PORTH_IM_R         (*((volatile unsigned long *)0x40027410))
+#define GPIO_PORTH_RIS_R        (*((volatile unsigned long *)0x40027414))
+#define GPIO_PORTH_MIS_R        (*((volatile unsigned long *)0x40027418))
+#define GPIO_PORTH_ICR_R        (*((volatile unsigned long *)0x4002741C))
+#define GPIO_PORTH_AFSEL_R      (*((volatile unsigned long *)0x40027420))
+#define GPIO_PORTH_DR2R_R       (*((volatile unsigned long *)0x40027500))
+#define GPIO_PORTH_DR4R_R       (*((volatile unsigned long *)0x40027504))
+#define GPIO_PORTH_DR8R_R       (*((volatile unsigned long *)0x40027508))
+#define GPIO_PORTH_ODR_R        (*((volatile unsigned long *)0x4002750C))
+#define GPIO_PORTH_PUR_R        (*((volatile unsigned long *)0x40027510))
+#define GPIO_PORTH_PDR_R        (*((volatile unsigned long *)0x40027514))
+#define GPIO_PORTH_SLR_R        (*((volatile unsigned long *)0x40027518))
+#define GPIO_PORTH_DEN_R        (*((volatile unsigned long *)0x4002751C))
+#define GPIO_PORTH_LOCK_R       (*((volatile unsigned long *)0x40027520))
+#define GPIO_PORTH_CR_R         (*((volatile unsigned long *)0x40027524))
+#define GPIO_PORTH_AMSEL_R      (*((volatile unsigned long *)0x40027528))
+#define GPIO_PORTH_PCTL_R       (*((volatile unsigned long *)0x4002752C))
+
+//*****************************************************************************
+//
+// Pulse Width Modulator (PWM)
+//
+//*****************************************************************************
+#define PWM_CTL_R               (*((volatile unsigned long *)0x40028000))
+#define PWM_SYNC_R              (*((volatile unsigned long *)0x40028004))
+#define PWM_ENABLE_R            (*((volatile unsigned long *)0x40028008))
+#define PWM_INVERT_R            (*((volatile unsigned long *)0x4002800C))
+#define PWM_FAULT_R             (*((volatile unsigned long *)0x40028010))
+#define PWM_INTEN_R             (*((volatile unsigned long *)0x40028014))
+#define PWM_RIS_R               (*((volatile unsigned long *)0x40028018))
+#define PWM_ISC_R               (*((volatile unsigned long *)0x4002801C))
+#define PWM_STATUS_R            (*((volatile unsigned long *)0x40028020))
+#define PWM_FAULTVAL_R          (*((volatile unsigned long *)0x40028024))
+#define PWM_0_CTL_R             (*((volatile unsigned long *)0x40028040))
+#define PWM_0_INTEN_R           (*((volatile unsigned long *)0x40028044))
+#define PWM_0_RIS_R             (*((volatile unsigned long *)0x40028048))
+#define PWM_0_ISC_R             (*((volatile unsigned long *)0x4002804C))
+#define PWM_0_LOAD_R            (*((volatile unsigned long *)0x40028050))
+#define PWM_0_COUNT_R           (*((volatile unsigned long *)0x40028054))
+#define PWM_0_CMPA_R            (*((volatile unsigned long *)0x40028058))
+#define PWM_0_CMPB_R            (*((volatile unsigned long *)0x4002805C))
+#define PWM_0_GENA_R            (*((volatile unsigned long *)0x40028060))
+#define PWM_0_GENB_R            (*((volatile unsigned long *)0x40028064))
+#define PWM_0_DBCTL_R           (*((volatile unsigned long *)0x40028068))
+#define PWM_0_DBRISE_R          (*((volatile unsigned long *)0x4002806C))
+#define PWM_0_DBFALL_R          (*((volatile unsigned long *)0x40028070))
+#define PWM_0_FLTSRC0_R         (*((volatile unsigned long *)0x40028074))
+#define PWM_0_FLTSRC1_R         (*((volatile unsigned long *)0x40028078))
+#define PWM_0_MINFLTPER_R       (*((volatile unsigned long *)0x4002807C))
+#define PWM_1_CTL_R             (*((volatile unsigned long *)0x40028080))
+#define PWM_1_INTEN_R           (*((volatile unsigned long *)0x40028084))
+#define PWM_1_RIS_R             (*((volatile unsigned long *)0x40028088))
+#define PWM_1_ISC_R             (*((volatile unsigned long *)0x4002808C))
+#define PWM_1_LOAD_R            (*((volatile unsigned long *)0x40028090))
+#define PWM_1_COUNT_R           (*((volatile unsigned long *)0x40028094))
+#define PWM_1_CMPA_R            (*((volatile unsigned long *)0x40028098))
+#define PWM_1_CMPB_R            (*((volatile unsigned long *)0x4002809C))
+#define PWM_1_GENA_R            (*((volatile unsigned long *)0x400280A0))
+#define PWM_1_GENB_R            (*((volatile unsigned long *)0x400280A4))
+#define PWM_1_DBCTL_R           (*((volatile unsigned long *)0x400280A8))
+#define PWM_1_DBRISE_R          (*((volatile unsigned long *)0x400280AC))
+#define PWM_1_DBFALL_R          (*((volatile unsigned long *)0x400280B0))
+#define PWM_1_FLTSRC0_R         (*((volatile unsigned long *)0x400280B4))
+#define PWM_1_FLTSRC1_R         (*((volatile unsigned long *)0x400280B8))
+#define PWM_1_MINFLTPER_R       (*((volatile unsigned long *)0x400280BC))
+#define PWM_2_CTL_R             (*((volatile unsigned long *)0x400280C0))
+#define PWM_2_INTEN_R           (*((volatile unsigned long *)0x400280C4))
+#define PWM_2_RIS_R             (*((volatile unsigned long *)0x400280C8))
+#define PWM_2_ISC_R             (*((volatile unsigned long *)0x400280CC))
+#define PWM_2_LOAD_R            (*((volatile unsigned long *)0x400280D0))
+#define PWM_2_COUNT_R           (*((volatile unsigned long *)0x400280D4))
+#define PWM_2_CMPA_R            (*((volatile unsigned long *)0x400280D8))
+#define PWM_2_CMPB_R            (*((volatile unsigned long *)0x400280DC))
+#define PWM_2_GENA_R            (*((volatile unsigned long *)0x400280E0))
+#define PWM_2_GENB_R            (*((volatile unsigned long *)0x400280E4))
+#define PWM_2_DBCTL_R           (*((volatile unsigned long *)0x400280E8))
+#define PWM_2_DBRISE_R          (*((volatile unsigned long *)0x400280EC))
+#define PWM_2_DBFALL_R          (*((volatile unsigned long *)0x400280F0))
+#define PWM_2_FLTSRC0_R         (*((volatile unsigned long *)0x400280F4))
+#define PWM_2_FLTSRC1_R         (*((volatile unsigned long *)0x400280F8))
+#define PWM_2_MINFLTPER_R       (*((volatile unsigned long *)0x400280FC))
+#define PWM_3_CTL_R             (*((volatile unsigned long *)0x40028100))
+#define PWM_3_INTEN_R           (*((volatile unsigned long *)0x40028104))
+#define PWM_3_RIS_R             (*((volatile unsigned long *)0x40028108))
+#define PWM_3_ISC_R             (*((volatile unsigned long *)0x4002810C))
+#define PWM_3_LOAD_R            (*((volatile unsigned long *)0x40028110))
+#define PWM_3_COUNT_R           (*((volatile unsigned long *)0x40028114))
+#define PWM_3_CMPA_R            (*((volatile unsigned long *)0x40028118))
+#define PWM_3_CMPB_R            (*((volatile unsigned long *)0x4002811C))
+#define PWM_3_GENA_R            (*((volatile unsigned long *)0x40028120))
+#define PWM_3_GENB_R            (*((volatile unsigned long *)0x40028124))
+#define PWM_3_DBCTL_R           (*((volatile unsigned long *)0x40028128))
+#define PWM_3_DBRISE_R          (*((volatile unsigned long *)0x4002812C))
+#define PWM_3_DBFALL_R          (*((volatile unsigned long *)0x40028130))
+#define PWM_3_FLTSRC0_R         (*((volatile unsigned long *)0x40028134))
+#define PWM_3_FLTSRC1_R         (*((volatile unsigned long *)0x40028138))
+#define PWM_3_MINFLTPER_R       (*((volatile unsigned long *)0x4002813C))
+#define PWM_0_FLTSEN_R          (*((volatile unsigned long *)0x40028800))
+#define PWM_0_FLTSTAT0_R        (*((volatile unsigned long *)0x40028804))
+#define PWM_0_FLTSTAT1_R        (*((volatile unsigned long *)0x40028808))
+#define PWM_1_FLTSEN_R          (*((volatile unsigned long *)0x40028880))
+#define PWM_1_FLTSTAT0_R        (*((volatile unsigned long *)0x40028884))
+#define PWM_1_FLTSTAT1_R        (*((volatile unsigned long *)0x40028888))
+#define PWM_2_FLTSEN_R          (*((volatile unsigned long *)0x40028900))
+#define PWM_2_FLTSTAT0_R        (*((volatile unsigned long *)0x40028904))
+#define PWM_2_FLTSTAT1_R        (*((volatile unsigned long *)0x40028908))
+#define PWM_3_FLTSEN_R          (*((volatile unsigned long *)0x40028980))
+#define PWM_3_FLTSTAT0_R        (*((volatile unsigned long *)0x40028984))
+#define PWM_3_FLTSTAT1_R        (*((volatile unsigned long *)0x40028988))
+
+//*****************************************************************************
+//
+// Quadrature Encoder Interface (QEI0)
+//
+//*****************************************************************************
+#define QEI0_CTL_R              (*((volatile unsigned long *)0x4002C000))
+#define QEI0_STAT_R             (*((volatile unsigned long *)0x4002C004))
+#define QEI0_POS_R              (*((volatile unsigned long *)0x4002C008))
+#define QEI0_MAXPOS_R           (*((volatile unsigned long *)0x4002C00C))
+#define QEI0_LOAD_R             (*((volatile unsigned long *)0x4002C010))
+#define QEI0_TIME_R             (*((volatile unsigned long *)0x4002C014))
+#define QEI0_COUNT_R            (*((volatile unsigned long *)0x4002C018))
+#define QEI0_SPEED_R            (*((volatile unsigned long *)0x4002C01C))
+#define QEI0_INTEN_R            (*((volatile unsigned long *)0x4002C020))
+#define QEI0_RIS_R              (*((volatile unsigned long *)0x4002C024))
+#define QEI0_ISC_R              (*((volatile unsigned long *)0x4002C028))
+
+//*****************************************************************************
+//
+// Quadrature Encoder Interface (QEI1)
+//
+//*****************************************************************************
+#define QEI1_CTL_R              (*((volatile unsigned long *)0x4002D000))
+#define QEI1_STAT_R             (*((volatile unsigned long *)0x4002D004))
+#define QEI1_POS_R              (*((volatile unsigned long *)0x4002D008))
+#define QEI1_MAXPOS_R           (*((volatile unsigned long *)0x4002D00C))
+#define QEI1_LOAD_R             (*((volatile unsigned long *)0x4002D010))
+#define QEI1_TIME_R             (*((volatile unsigned long *)0x4002D014))
+#define QEI1_COUNT_R            (*((volatile unsigned long *)0x4002D018))
+#define QEI1_SPEED_R            (*((volatile unsigned long *)0x4002D01C))
+#define QEI1_INTEN_R            (*((volatile unsigned long *)0x4002D020))
+#define QEI1_RIS_R              (*((volatile unsigned long *)0x4002D024))
+#define QEI1_ISC_R              (*((volatile unsigned long *)0x4002D028))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER0)
+//
+//*****************************************************************************
+#define TIMER0_CFG_R            (*((volatile unsigned long *)0x40030000))
+#define TIMER0_TAMR_R           (*((volatile unsigned long *)0x40030004))
+#define TIMER0_TBMR_R           (*((volatile unsigned long *)0x40030008))
+#define TIMER0_CTL_R            (*((volatile unsigned long *)0x4003000C))
+#define TIMER0_IMR_R            (*((volatile unsigned long *)0x40030018))
+#define TIMER0_RIS_R            (*((volatile unsigned long *)0x4003001C))
+#define TIMER0_MIS_R            (*((volatile unsigned long *)0x40030020))
+#define TIMER0_ICR_R            (*((volatile unsigned long *)0x40030024))
+#define TIMER0_TAILR_R          (*((volatile unsigned long *)0x40030028))
+#define TIMER0_TBILR_R          (*((volatile unsigned long *)0x4003002C))
+#define TIMER0_TAMATCHR_R       (*((volatile unsigned long *)0x40030030))
+#define TIMER0_TBMATCHR_R       (*((volatile unsigned long *)0x40030034))
+#define TIMER0_TAPR_R           (*((volatile unsigned long *)0x40030038))
+#define TIMER0_TBPR_R           (*((volatile unsigned long *)0x4003003C))
+#define TIMER0_TAR_R            (*((volatile unsigned long *)0x40030048))
+#define TIMER0_TBR_R            (*((volatile unsigned long *)0x4003004C))
+#define TIMER0_TAV_R            (*((volatile unsigned long *)0x40030050))
+#define TIMER0_TBV_R            (*((volatile unsigned long *)0x40030054))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER1)
+//
+//*****************************************************************************
+#define TIMER1_CFG_R            (*((volatile unsigned long *)0x40031000))
+#define TIMER1_TAMR_R           (*((volatile unsigned long *)0x40031004))
+#define TIMER1_TBMR_R           (*((volatile unsigned long *)0x40031008))
+#define TIMER1_CTL_R            (*((volatile unsigned long *)0x4003100C))
+#define TIMER1_IMR_R            (*((volatile unsigned long *)0x40031018))
+#define TIMER1_RIS_R            (*((volatile unsigned long *)0x4003101C))
+#define TIMER1_MIS_R            (*((volatile unsigned long *)0x40031020))
+#define TIMER1_ICR_R            (*((volatile unsigned long *)0x40031024))
+#define TIMER1_TAILR_R          (*((volatile unsigned long *)0x40031028))
+#define TIMER1_TBILR_R          (*((volatile unsigned long *)0x4003102C))
+#define TIMER1_TAMATCHR_R       (*((volatile unsigned long *)0x40031030))
+#define TIMER1_TBMATCHR_R       (*((volatile unsigned long *)0x40031034))
+#define TIMER1_TAPR_R           (*((volatile unsigned long *)0x40031038))
+#define TIMER1_TBPR_R           (*((volatile unsigned long *)0x4003103C))
+#define TIMER1_TAR_R            (*((volatile unsigned long *)0x40031048))
+#define TIMER1_TBR_R            (*((volatile unsigned long *)0x4003104C))
+#define TIMER1_TAV_R            (*((volatile unsigned long *)0x40031050))
+#define TIMER1_TBV_R            (*((volatile unsigned long *)0x40031054))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER2)
+//
+//*****************************************************************************
+#define TIMER2_CFG_R            (*((volatile unsigned long *)0x40032000))
+#define TIMER2_TAMR_R           (*((volatile unsigned long *)0x40032004))
+#define TIMER2_TBMR_R           (*((volatile unsigned long *)0x40032008))
+#define TIMER2_CTL_R            (*((volatile unsigned long *)0x4003200C))
+#define TIMER2_IMR_R            (*((volatile unsigned long *)0x40032018))
+#define TIMER2_RIS_R            (*((volatile unsigned long *)0x4003201C))
+#define TIMER2_MIS_R            (*((volatile unsigned long *)0x40032020))
+#define TIMER2_ICR_R            (*((volatile unsigned long *)0x40032024))
+#define TIMER2_TAILR_R          (*((volatile unsigned long *)0x40032028))
+#define TIMER2_TBILR_R          (*((volatile unsigned long *)0x4003202C))
+#define TIMER2_TAMATCHR_R       (*((volatile unsigned long *)0x40032030))
+#define TIMER2_TBMATCHR_R       (*((volatile unsigned long *)0x40032034))
+#define TIMER2_TAPR_R           (*((volatile unsigned long *)0x40032038))
+#define TIMER2_TBPR_R           (*((volatile unsigned long *)0x4003203C))
+#define TIMER2_TAR_R            (*((volatile unsigned long *)0x40032048))
+#define TIMER2_TBR_R            (*((volatile unsigned long *)0x4003204C))
+#define TIMER2_TAV_R            (*((volatile unsigned long *)0x40032050))
+#define TIMER2_TBV_R            (*((volatile unsigned long *)0x40032054))
+
+//*****************************************************************************
+//
+// General-Purpose Timers (TIMER3)
+//
+//*****************************************************************************
+#define TIMER3_CFG_R            (*((volatile unsigned long *)0x40033000))
+#define TIMER3_TAMR_R           (*((volatile unsigned long *)0x40033004))
+#define TIMER3_TBMR_R           (*((volatile unsigned long *)0x40033008))
+#define TIMER3_CTL_R            (*((volatile unsigned long *)0x4003300C))
+#define TIMER3_IMR_R            (*((volatile unsigned long *)0x40033018))
+#define TIMER3_RIS_R            (*((volatile unsigned long *)0x4003301C))
+#define TIMER3_MIS_R            (*((volatile unsigned long *)0x40033020))
+#define TIMER3_ICR_R            (*((volatile unsigned long *)0x40033024))
+#define TIMER3_TAILR_R          (*((volatile unsigned long *)0x40033028))
+#define TIMER3_TBILR_R          (*((volatile unsigned long *)0x4003302C))
+#define TIMER3_TAMATCHR_R       (*((volatile unsigned long *)0x40033030))
+#define TIMER3_TBMATCHR_R       (*((volatile unsigned long *)0x40033034))
+#define TIMER3_TAPR_R           (*((volatile unsigned long *)0x40033038))
+#define TIMER3_TBPR_R           (*((volatile unsigned long *)0x4003303C))
+#define TIMER3_TAR_R            (*((volatile unsigned long *)0x40033048))
+#define TIMER3_TBR_R            (*((volatile unsigned long *)0x4003304C))
+#define TIMER3_TAV_R            (*((volatile unsigned long *)0x40033050))
+#define TIMER3_TBV_R            (*((volatile unsigned long *)0x40033054))
+
+//*****************************************************************************
+//
+// Analog-to-Digital Converter (ADC0)
+//
+//*****************************************************************************
+#define ADC0_ACTSS_R            (*((volatile unsigned long *)0x40038000))
+#define ADC0_RIS_R              (*((volatile unsigned long *)0x40038004))
+#define ADC0_IM_R               (*((volatile unsigned long *)0x40038008))
+#define ADC0_ISC_R              (*((volatile unsigned long *)0x4003800C))
+#define ADC0_OSTAT_R            (*((volatile unsigned long *)0x40038010))
+#define ADC0_EMUX_R             (*((volatile unsigned long *)0x40038014))
+#define ADC0_USTAT_R            (*((volatile unsigned long *)0x40038018))
+#define ADC0_SSPRI_R            (*((volatile unsigned long *)0x40038020))
+#define ADC0_PSSI_R             (*((volatile unsigned long *)0x40038028))
+#define ADC0_SAC_R              (*((volatile unsigned long *)0x40038030))
+#define ADC0_DCISC_R            (*((volatile unsigned long *)0x40038034))
+#define ADC0_CTL_R              (*((volatile unsigned long *)0x40038038))
+#define ADC0_SSMUX0_R           (*((volatile unsigned long *)0x40038040))
+#define ADC0_SSCTL0_R           (*((volatile unsigned long *)0x40038044))
+#define ADC0_SSFIFO0_R          (*((volatile unsigned long *)0x40038048))
+#define ADC0_SSFSTAT0_R         (*((volatile unsigned long *)0x4003804C))
+#define ADC0_SSOP0_R            (*((volatile unsigned long *)0x40038050))
+#define ADC0_SSDC0_R            (*((volatile unsigned long *)0x40038054))
+#define ADC0_SSMUX1_R           (*((volatile unsigned long *)0x40038060))
+#define ADC0_SSCTL1_R           (*((volatile unsigned long *)0x40038064))
+#define ADC0_SSFIFO1_R          (*((volatile unsigned long *)0x40038068))
+#define ADC0_SSFSTAT1_R         (*((volatile unsigned long *)0x4003806C))
+#define ADC0_SSOP1_R            (*((volatile unsigned long *)0x40038070))
+#define ADC0_SSDC1_R            (*((volatile unsigned long *)0x40038074))
+#define ADC0_SSMUX2_R           (*((volatile unsigned long *)0x40038080))
+#define ADC0_SSCTL2_R           (*((volatile unsigned long *)0x40038084))
+#define ADC0_SSFIFO2_R          (*((volatile unsigned long *)0x40038088))
+#define ADC0_SSFSTAT2_R         (*((volatile unsigned long *)0x4003808C))
+#define ADC0_SSOP2_R            (*((volatile unsigned long *)0x40038090))
+#define ADC0_SSDC2_R            (*((volatile unsigned long *)0x40038094))
+#define ADC0_SSMUX3_R           (*((volatile unsigned long *)0x400380A0))
+#define ADC0_SSCTL3_R           (*((volatile unsigned long *)0x400380A4))
+#define ADC0_SSFIFO3_R          (*((volatile unsigned long *)0x400380A8))
+#define ADC0_SSFSTAT3_R         (*((volatile unsigned long *)0x400380AC))
+#define ADC0_SSOP3_R            (*((volatile unsigned long *)0x400380B0))
+#define ADC0_SSDC3_R            (*((volatile unsigned long *)0x400380B4))
+#define ADC0_DCRIC_R            (*((volatile unsigned long *)0x40038D00))
+#define ADC0_DCCTL0_R           (*((volatile unsigned long *)0x40038E00))
+#define ADC0_DCCTL1_R           (*((volatile unsigned long *)0x40038E04))
+#define ADC0_DCCTL2_R           (*((volatile unsigned long *)0x40038E08))
+#define ADC0_DCCTL3_R           (*((volatile unsigned long *)0x40038E0C))
+#define ADC0_DCCTL4_R           (*((volatile unsigned long *)0x40038E10))
+#define ADC0_DCCTL5_R           (*((volatile unsigned long *)0x40038E14))
+#define ADC0_DCCTL6_R           (*((volatile unsigned long *)0x40038E18))
+#define ADC0_DCCTL7_R           (*((volatile unsigned long *)0x40038E1C))
+#define ADC0_DCCMP0_R           (*((volatile unsigned long *)0x40038E40))
+#define ADC0_DCCMP1_R           (*((volatile unsigned long *)0x40038E44))
+#define ADC0_DCCMP2_R           (*((volatile unsigned long *)0x40038E48))
+#define ADC0_DCCMP3_R           (*((volatile unsigned long *)0x40038E4C))
+#define ADC0_DCCMP4_R           (*((volatile unsigned long *)0x40038E50))
+#define ADC0_DCCMP5_R           (*((volatile unsigned long *)0x40038E54))
+#define ADC0_DCCMP6_R           (*((volatile unsigned long *)0x40038E58))
+#define ADC0_DCCMP7_R           (*((volatile unsigned long *)0x40038E5C))
+
+//*****************************************************************************
+//
+// Analog-to-Digital Converter (ADC1)
+//
+//*****************************************************************************
+#define ADC1_ACTSS_R            (*((volatile unsigned long *)0x40039000))
+#define ADC1_RIS_R              (*((volatile unsigned long *)0x40039004))
+#define ADC1_IM_R               (*((volatile unsigned long *)0x40039008))
+#define ADC1_ISC_R              (*((volatile unsigned long *)0x4003900C))
+#define ADC1_OSTAT_R            (*((volatile unsigned long *)0x40039010))
+#define ADC1_EMUX_R             (*((volatile unsigned long *)0x40039014))
+#define ADC1_USTAT_R            (*((volatile unsigned long *)0x40039018))
+#define ADC1_SSPRI_R            (*((volatile unsigned long *)0x40039020))
+#define ADC1_PSSI_R             (*((volatile unsigned long *)0x40039028))
+#define ADC1_SAC_R              (*((volatile unsigned long *)0x40039030))
+#define ADC1_DCISC_R            (*((volatile unsigned long *)0x40039034))
+#define ADC1_CTL_R              (*((volatile unsigned long *)0x40039038))
+#define ADC1_SSMUX0_R           (*((volatile unsigned long *)0x40039040))
+#define ADC1_SSCTL0_R           (*((volatile unsigned long *)0x40039044))
+#define ADC1_SSFIFO0_R          (*((volatile unsigned long *)0x40039048))
+#define ADC1_SSFSTAT0_R         (*((volatile unsigned long *)0x4003904C))
+#define ADC1_SSOP0_R            (*((volatile unsigned long *)0x40039050))
+#define ADC1_SSDC0_R            (*((volatile unsigned long *)0x40039054))
+#define ADC1_SSMUX1_R           (*((volatile unsigned long *)0x40039060))
+#define ADC1_SSCTL1_R           (*((volatile unsigned long *)0x40039064))
+#define ADC1_SSFIFO1_R          (*((volatile unsigned long *)0x40039068))
+#define ADC1_SSFSTAT1_R         (*((volatile unsigned long *)0x4003906C))
+#define ADC1_SSOP1_R            (*((volatile unsigned long *)0x40039070))
+#define ADC1_SSDC1_R            (*((volatile unsigned long *)0x40039074))
+#define ADC1_SSMUX2_R           (*((volatile unsigned long *)0x40039080))
+#define ADC1_SSCTL2_R           (*((volatile unsigned long *)0x40039084))
+#define ADC1_SSFIFO2_R          (*((volatile unsigned long *)0x40039088))
+#define ADC1_SSFSTAT2_R         (*((volatile unsigned long *)0x4003908C))
+#define ADC1_SSOP2_R            (*((volatile unsigned long *)0x40039090))
+#define ADC1_SSDC2_R            (*((volatile unsigned long *)0x40039094))
+#define ADC1_SSMUX3_R           (*((volatile unsigned long *)0x400390A0))
+#define ADC1_SSCTL3_R           (*((volatile unsigned long *)0x400390A4))
+#define ADC1_SSFIFO3_R          (*((volatile unsigned long *)0x400390A8))
+#define ADC1_SSFSTAT3_R         (*((volatile unsigned long *)0x400390AC))
+#define ADC1_SSOP3_R            (*((volatile unsigned long *)0x400390B0))
+#define ADC1_SSDC3_R            (*((volatile unsigned long *)0x400390B4))
+#define ADC1_DCRIC_R            (*((volatile unsigned long *)0x40039D00))
+#define ADC1_DCCTL0_R           (*((volatile unsigned long *)0x40039E00))
+#define ADC1_DCCTL1_R           (*((volatile unsigned long *)0x40039E04))
+#define ADC1_DCCTL2_R           (*((volatile unsigned long *)0x40039E08))
+#define ADC1_DCCTL3_R           (*((volatile unsigned long *)0x40039E0C))
+#define ADC1_DCCTL4_R           (*((volatile unsigned long *)0x40039E10))
+#define ADC1_DCCTL5_R           (*((volatile unsigned long *)0x40039E14))
+#define ADC1_DCCTL6_R           (*((volatile unsigned long *)0x40039E18))
+#define ADC1_DCCTL7_R           (*((volatile unsigned long *)0x40039E1C))
+#define ADC1_DCCMP0_R           (*((volatile unsigned long *)0x40039E40))
+#define ADC1_DCCMP1_R           (*((volatile unsigned long *)0x40039E44))
+#define ADC1_DCCMP2_R           (*((volatile unsigned long *)0x40039E48))
+#define ADC1_DCCMP3_R           (*((volatile unsigned long *)0x40039E4C))
+#define ADC1_DCCMP4_R           (*((volatile unsigned long *)0x40039E50))
+#define ADC1_DCCMP5_R           (*((volatile unsigned long *)0x40039E54))
+#define ADC1_DCCMP6_R           (*((volatile unsigned long *)0x40039E58))
+#define ADC1_DCCMP7_R           (*((volatile unsigned long *)0x40039E5C))
+
+//*****************************************************************************
+//
+// Analog Comparators (COMP)
+//
+//*****************************************************************************
+#define COMP_ACMIS_R            (*((volatile unsigned long *)0x4003C000))
+#define COMP_ACRIS_R            (*((volatile unsigned long *)0x4003C004))
+#define COMP_ACINTEN_R          (*((volatile unsigned long *)0x4003C008))
+#define COMP_ACREFCTL_R         (*((volatile unsigned long *)0x4003C010))
+#define COMP_ACSTAT0_R          (*((volatile unsigned long *)0x4003C020))
+#define COMP_ACCTL0_R           (*((volatile unsigned long *)0x4003C024))
+#define COMP_ACSTAT1_R          (*((volatile unsigned long *)0x4003C040))
+#define COMP_ACCTL1_R           (*((volatile unsigned long *)0x4003C044))
+#define COMP_ACSTAT2_R          (*((volatile unsigned long *)0x4003C060))
+#define COMP_ACCTL2_R           (*((volatile unsigned long *)0x4003C064))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (PORTJ)
+//
+//*****************************************************************************
+#define GPIO_PORTJ_DATA_BITS_R  ((volatile unsigned long *)0x4003D000)
+#define GPIO_PORTJ_DATA_R       (*((volatile unsigned long *)0x4003D3FC))
+#define GPIO_PORTJ_DIR_R        (*((volatile unsigned long *)0x4003D400))
+#define GPIO_PORTJ_IS_R         (*((volatile unsigned long *)0x4003D404))
+#define GPIO_PORTJ_IBE_R        (*((volatile unsigned long *)0x4003D408))
+#define GPIO_PORTJ_IEV_R        (*((volatile unsigned long *)0x4003D40C))
+#define GPIO_PORTJ_IM_R         (*((volatile unsigned long *)0x4003D410))
+#define GPIO_PORTJ_RIS_R        (*((volatile unsigned long *)0x4003D414))
+#define GPIO_PORTJ_MIS_R        (*((volatile unsigned long *)0x4003D418))
+#define GPIO_PORTJ_ICR_R        (*((volatile unsigned long *)0x4003D41C))
+#define GPIO_PORTJ_AFSEL_R      (*((volatile unsigned long *)0x4003D420))
+#define GPIO_PORTJ_DR2R_R       (*((volatile unsigned long *)0x4003D500))
+#define GPIO_PORTJ_DR4R_R       (*((volatile unsigned long *)0x4003D504))
+#define GPIO_PORTJ_DR8R_R       (*((volatile unsigned long *)0x4003D508))
+#define GPIO_PORTJ_ODR_R        (*((volatile unsigned long *)0x4003D50C))
+#define GPIO_PORTJ_PUR_R        (*((volatile unsigned long *)0x4003D510))
+#define GPIO_PORTJ_PDR_R        (*((volatile unsigned long *)0x4003D514))
+#define GPIO_PORTJ_SLR_R        (*((volatile unsigned long *)0x4003D518))
+#define GPIO_PORTJ_DEN_R        (*((volatile unsigned long *)0x4003D51C))
+#define GPIO_PORTJ_LOCK_R       (*((volatile unsigned long *)0x4003D520))
+#define GPIO_PORTJ_CR_R         (*((volatile unsigned long *)0x4003D524))
+#define GPIO_PORTJ_AMSEL_R      (*((volatile unsigned long *)0x4003D528))
+#define GPIO_PORTJ_PCTL_R       (*((volatile unsigned long *)0x4003D52C))
+
+//*****************************************************************************
+//
+// Controller Area Network (CAN0) Module
+//
+//*****************************************************************************
+#define CAN0_CTL_R              (*((volatile unsigned long *)0x40040000))
+#define CAN0_STS_R              (*((volatile unsigned long *)0x40040004))
+#define CAN0_ERR_R              (*((volatile unsigned long *)0x40040008))
+#define CAN0_BIT_R              (*((volatile unsigned long *)0x4004000C))
+#define CAN0_INT_R              (*((volatile unsigned long *)0x40040010))
+#define CAN0_TST_R              (*((volatile unsigned long *)0x40040014))
+#define CAN0_BRPE_R             (*((volatile unsigned long *)0x40040018))
+#define CAN0_IF1CRQ_R           (*((volatile unsigned long *)0x40040020))
+#define CAN0_IF1CMSK_R          (*((volatile unsigned long *)0x40040024))
+#define CAN0_IF1MSK1_R          (*((volatile unsigned long *)0x40040028))
+#define CAN0_IF1MSK2_R          (*((volatile unsigned long *)0x4004002C))
+#define CAN0_IF1ARB1_R          (*((volatile unsigned long *)0x40040030))
+#define CAN0_IF1ARB2_R          (*((volatile unsigned long *)0x40040034))
+#define CAN0_IF1MCTL_R          (*((volatile unsigned long *)0x40040038))
+#define CAN0_IF1DA1_R           (*((volatile unsigned long *)0x4004003C))
+#define CAN0_IF1DA2_R           (*((volatile unsigned long *)0x40040040))
+#define CAN0_IF1DB1_R           (*((volatile unsigned long *)0x40040044))
+#define CAN0_IF1DB2_R           (*((volatile unsigned long *)0x40040048))
+#define CAN0_IF2CRQ_R           (*((volatile unsigned long *)0x40040080))
+#define CAN0_IF2CMSK_R          (*((volatile unsigned long *)0x40040084))
+#define CAN0_IF2MSK1_R          (*((volatile unsigned long *)0x40040088))
+#define CAN0_IF2MSK2_R          (*((volatile unsigned long *)0x4004008C))
+#define CAN0_IF2ARB1_R          (*((volatile unsigned long *)0x40040090))
+#define CAN0_IF2ARB2_R          (*((volatile unsigned long *)0x40040094))
+#define CAN0_IF2MCTL_R          (*((volatile unsigned long *)0x40040098))
+#define CAN0_IF2DA1_R           (*((volatile unsigned long *)0x4004009C))
+#define CAN0_IF2DA2_R           (*((volatile unsigned long *)0x400400A0))
+#define CAN0_IF2DB1_R           (*((volatile unsigned long *)0x400400A4))
+#define CAN0_IF2DB2_R           (*((volatile unsigned long *)0x400400A8))
+#define CAN0_TXRQ1_R            (*((volatile unsigned long *)0x40040100))
+#define CAN0_TXRQ2_R            (*((volatile unsigned long *)0x40040104))
+#define CAN0_NWDA1_R            (*((volatile unsigned long *)0x40040120))
+#define CAN0_NWDA2_R            (*((volatile unsigned long *)0x40040124))
+#define CAN0_MSG1INT_R          (*((volatile unsigned long *)0x40040140))
+#define CAN0_MSG2INT_R          (*((volatile unsigned long *)0x40040144))
+#define CAN0_MSG1VAL_R          (*((volatile unsigned long *)0x40040160))
+#define CAN0_MSG2VAL_R          (*((volatile unsigned long *)0x40040164))
+
+//*****************************************************************************
+//
+// Controller Area Network (CAN1) Module
+//
+//*****************************************************************************
+#define CAN1_CTL_R              (*((volatile unsigned long *)0x40041000))
+#define CAN1_STS_R              (*((volatile unsigned long *)0x40041004))
+#define CAN1_ERR_R              (*((volatile unsigned long *)0x40041008))
+#define CAN1_BIT_R              (*((volatile unsigned long *)0x4004100C))
+#define CAN1_INT_R              (*((volatile unsigned long *)0x40041010))
+#define CAN1_TST_R              (*((volatile unsigned long *)0x40041014))
+#define CAN1_BRPE_R             (*((volatile unsigned long *)0x40041018))
+#define CAN1_IF1CRQ_R           (*((volatile unsigned long *)0x40041020))
+#define CAN1_IF1CMSK_R          (*((volatile unsigned long *)0x40041024))
+#define CAN1_IF1MSK1_R          (*((volatile unsigned long *)0x40041028))
+#define CAN1_IF1MSK2_R          (*((volatile unsigned long *)0x4004102C))
+#define CAN1_IF1ARB1_R          (*((volatile unsigned long *)0x40041030))
+#define CAN1_IF1ARB2_R          (*((volatile unsigned long *)0x40041034))
+#define CAN1_IF1MCTL_R          (*((volatile unsigned long *)0x40041038))
+#define CAN1_IF1DA1_R           (*((volatile unsigned long *)0x4004103C))
+#define CAN1_IF1DA2_R           (*((volatile unsigned long *)0x40041040))
+#define CAN1_IF1DB1_R           (*((volatile unsigned long *)0x40041044))
+#define CAN1_IF1DB2_R           (*((volatile unsigned long *)0x40041048))
+#define CAN1_IF2CRQ_R           (*((volatile unsigned long *)0x40041080))
+#define CAN1_IF2CMSK_R          (*((volatile unsigned long *)0x40041084))
+#define CAN1_IF2MSK1_R          (*((volatile unsigned long *)0x40041088))
+#define CAN1_IF2MSK2_R          (*((volatile unsigned long *)0x4004108C))
+#define CAN1_IF2ARB1_R          (*((volatile unsigned long *)0x40041090))
+#define CAN1_IF2ARB2_R          (*((volatile unsigned long *)0x40041094))
+#define CAN1_IF2MCTL_R          (*((volatile unsigned long *)0x40041098))
+#define CAN1_IF2DA1_R           (*((volatile unsigned long *)0x4004109C))
+#define CAN1_IF2DA2_R           (*((volatile unsigned long *)0x400410A0))
+#define CAN1_IF2DB1_R           (*((volatile unsigned long *)0x400410A4))
+#define CAN1_IF2DB2_R           (*((volatile unsigned long *)0x400410A8))
+#define CAN1_TXRQ1_R            (*((volatile unsigned long *)0x40041100))
+#define CAN1_TXRQ2_R            (*((volatile unsigned long *)0x40041104))
+#define CAN1_NWDA1_R            (*((volatile unsigned long *)0x40041120))
+#define CAN1_NWDA2_R            (*((volatile unsigned long *)0x40041124))
+#define CAN1_MSG1INT_R          (*((volatile unsigned long *)0x40041140))
+#define CAN1_MSG2INT_R          (*((volatile unsigned long *)0x40041144))
+#define CAN1_MSG1VAL_R          (*((volatile unsigned long *)0x40041160))
+#define CAN1_MSG2VAL_R          (*((volatile unsigned long *)0x40041164))
+
+//*****************************************************************************
+//
+// Ethernet Controller (MAC)
+//
+//*****************************************************************************
+#define MAC_MR0_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_RIS_R               (*((volatile unsigned long *)0x40048000))
+#define MAC_IACK_R              (*((volatile unsigned long *)0x40048000))
+#define MAC_MR1_R               (*((volatile unsigned long *)0x40048001))
+#define MAC_MR2_R               (*((volatile unsigned long *)0x40048002))
+#define MAC_MR3_R               (*((volatile unsigned long *)0x40048003))
+#define MAC_IM_R                (*((volatile unsigned long *)0x40048004))
+#define MAC_MR4_R               (*((volatile unsigned long *)0x40048004))
+#define MAC_MR5_R               (*((volatile unsigned long *)0x40048005))
+#define MAC_MR6_R               (*((volatile unsigned long *)0x40048006))
+#define MAC_RCTL_R              (*((volatile unsigned long *)0x40048008))
+#define MAC_TCTL_R              (*((volatile unsigned long *)0x4004800C))
+#define MAC_DATA_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR16_R              (*((volatile unsigned long *)0x40048010))
+#define MAC_MR17_R              (*((volatile unsigned long *)0x40048011))
+#define MAC_IA0_R               (*((volatile unsigned long *)0x40048014))
+#define MAC_IA1_R               (*((volatile unsigned long *)0x40048018))
+#define MAC_MR27_R              (*((volatile unsigned long *)0x4004801B))
+#define MAC_THR_R               (*((volatile unsigned long *)0x4004801C))
+#define MAC_MR29_R              (*((volatile unsigned long *)0x4004801D))
+#define MAC_MR30_R              (*((volatile unsigned long *)0x4004801E))
+#define MAC_MR31_R              (*((volatile unsigned long *)0x4004801F))
+#define MAC_MCTL_R              (*((volatile unsigned long *)0x40048020))
+#define MAC_MDV_R               (*((volatile unsigned long *)0x40048024))
+#define MAC_MTXD_R              (*((volatile unsigned long *)0x4004802C))
+#define MAC_MRXD_R              (*((volatile unsigned long *)0x40048030))
+#define MAC_NP_R                (*((volatile unsigned long *)0x40048034))
+#define MAC_TR_R                (*((volatile unsigned long *)0x40048038))
+#define MAC_LED_R               (*((volatile unsigned long *)0x40048040))
+#define MAC_MDIX_R              (*((volatile unsigned long *)0x40048044))
+
+//*****************************************************************************
+//
+// Universal Serial Bus (USB0) Controller
+//
+//*****************************************************************************
+#define USB0_FADDR_R            (*((volatile unsigned long *)0x40050000))
+#define USB0_POWER_R            (*((volatile unsigned long *)0x40050001))
+#define USB0_TXIS_R             (*((volatile unsigned long *)0x40050002))
+#define USB0_RXIS_R             (*((volatile unsigned long *)0x40050004))
+#define USB0_TXIE_R             (*((volatile unsigned long *)0x40050006))
+#define USB0_RXIE_R             (*((volatile unsigned long *)0x40050008))
+#define USB0_IS_R               (*((volatile unsigned long *)0x4005000A))
+#define USB0_IE_R               (*((volatile unsigned long *)0x4005000B))
+#define USB0_FRAME_R            (*((volatile unsigned long *)0x4005000C))
+#define USB0_EPIDX_R            (*((volatile unsigned long *)0x4005000E))
+#define USB0_TEST_R             (*((volatile unsigned long *)0x4005000F))
+#define USB0_FIFO0_R            (*((volatile unsigned long *)0x40050020))
+#define USB0_FIFO1_R            (*((volatile unsigned long *)0x40050024))
+#define USB0_FIFO2_R            (*((volatile unsigned long *)0x40050028))
+#define USB0_FIFO3_R            (*((volatile unsigned long *)0x4005002C))
+#define USB0_FIFO4_R            (*((volatile unsigned long *)0x40050030))
+#define USB0_FIFO5_R            (*((volatile unsigned long *)0x40050034))
+#define USB0_FIFO6_R            (*((volatile unsigned long *)0x40050038))
+#define USB0_FIFO7_R            (*((volatile unsigned long *)0x4005003C))
+#define USB0_FIFO8_R            (*((volatile unsigned long *)0x40050040))
+#define USB0_FIFO9_R            (*((volatile unsigned long *)0x40050044))
+#define USB0_FIFO10_R           (*((volatile unsigned long *)0x40050048))
+#define USB0_FIFO11_R           (*((volatile unsigned long *)0x4005004C))
+#define USB0_FIFO12_R           (*((volatile unsigned long *)0x40050050))
+#define USB0_FIFO13_R           (*((volatile unsigned long *)0x40050054))
+#define USB0_FIFO14_R           (*((volatile unsigned long *)0x40050058))
+#define USB0_FIFO15_R           (*((volatile unsigned long *)0x4005005C))
+#define USB0_DEVCTL_R           (*((volatile unsigned long *)0x40050060))
+#define USB0_TXFIFOSZ_R         (*((volatile unsigned long *)0x40050062))
+#define USB0_RXFIFOSZ_R         (*((volatile unsigned long *)0x40050063))
+#define USB0_TXFIFOADD_R        (*((volatile unsigned long *)0x40050064))
+#define USB0_RXFIFOADD_R        (*((volatile unsigned long *)0x40050066))
+#define USB0_CONTIM_R           (*((volatile unsigned long *)0x4005007A))
+#define USB0_VPLEN_R            (*((volatile unsigned long *)0x4005007B))
+#define USB0_FSEOF_R            (*((volatile unsigned long *)0x4005007D))
+#define USB0_LSEOF_R            (*((volatile unsigned long *)0x4005007E))
+#define USB0_TXFUNCADDR0_R      (*((volatile unsigned long *)0x40050080))
+#define USB0_TXHUBADDR0_R       (*((volatile unsigned long *)0x40050082))
+#define USB0_TXHUBPORT0_R       (*((volatile unsigned long *)0x40050083))
+#define USB0_TXFUNCADDR1_R      (*((volatile unsigned long *)0x40050088))
+#define USB0_TXHUBADDR1_R       (*((volatile unsigned long *)0x4005008A))
+#define USB0_TXHUBPORT1_R       (*((volatile unsigned long *)0x4005008B))
+#define USB0_RXFUNCADDR1_R      (*((volatile unsigned long *)0x4005008C))
+#define USB0_RXHUBADDR1_R       (*((volatile unsigned long *)0x4005008E))
+#define USB0_RXHUBPORT1_R       (*((volatile unsigned long *)0x4005008F))
+#define USB0_TXFUNCADDR2_R      (*((volatile unsigned long *)0x40050090))
+#define USB0_TXHUBADDR2_R       (*((volatile unsigned long *)0x40050092))
+#define USB0_TXHUBPORT2_R       (*((volatile unsigned long *)0x40050093))
+#define USB0_RXFUNCADDR2_R      (*((volatile unsigned long *)0x40050094))
+#define USB0_RXHUBADDR2_R       (*((volatile unsigned long *)0x40050096))
+#define USB0_RXHUBPORT2_R       (*((volatile unsigned long *)0x40050097))
+#define USB0_TXFUNCADDR3_R      (*((volatile unsigned long *)0x40050098))
+#define USB0_TXHUBADDR3_R       (*((volatile unsigned long *)0x4005009A))
+#define USB0_TXHUBPORT3_R       (*((volatile unsigned long *)0x4005009B))
+#define USB0_RXFUNCADDR3_R      (*((volatile unsigned long *)0x4005009C))
+#define USB0_RXHUBADDR3_R       (*((volatile unsigned long *)0x4005009E))
+#define USB0_RXHUBPORT3_R       (*((volatile unsigned long *)0x4005009F))
+#define USB0_TXFUNCADDR4_R      (*((volatile unsigned long *)0x400500A0))
+#define USB0_TXHUBADDR4_R       (*((volatile unsigned long *)0x400500A2))
+#define USB0_TXHUBPORT4_R       (*((volatile unsigned long *)0x400500A3))
+#define USB0_RXFUNCADDR4_R      (*((volatile unsigned long *)0x400500A4))
+#define USB0_RXHUBADDR4_R       (*((volatile unsigned long *)0x400500A6))
+#define USB0_RXHUBPORT4_R       (*((volatile unsigned long *)0x400500A7))
+#define USB0_TXFUNCADDR5_R      (*((volatile unsigned long *)0x400500A8))
+#define USB0_TXHUBADDR5_R       (*((volatile unsigned long *)0x400500AA))
+#define USB0_TXHUBPORT5_R       (*((volatile unsigned long *)0x400500AB))
+#define USB0_RXFUNCADDR5_R      (*((volatile unsigned long *)0x400500AC))
+#define USB0_RXHUBADDR5_R       (*((volatile unsigned long *)0x400500AE))
+#define USB0_RXHUBPORT5_R       (*((volatile unsigned long *)0x400500AF))
+#define USB0_TXFUNCADDR6_R      (*((volatile unsigned long *)0x400500B0))
+#define USB0_TXHUBADDR6_R       (*((volatile unsigned long *)0x400500B2))
+#define USB0_TXHUBPORT6_R       (*((volatile unsigned long *)0x400500B3))
+#define USB0_RXFUNCADDR6_R      (*((volatile unsigned long *)0x400500B4))
+#define USB0_RXHUBADDR6_R       (*((volatile unsigned long *)0x400500B6))
+#define USB0_RXHUBPORT6_R       (*((volatile unsigned long *)0x400500B7))
+#define USB0_TXFUNCADDR7_R      (*((volatile unsigned long *)0x400500B8))
+#define USB0_TXHUBADDR7_R       (*((volatile unsigned long *)0x400500BA))
+#define USB0_TXHUBPORT7_R       (*((volatile unsigned long *)0x400500BB))
+#define USB0_RXFUNCADDR7_R      (*((volatile unsigned long *)0x400500BC))
+#define USB0_RXHUBADDR7_R       (*((volatile unsigned long *)0x400500BE))
+#define USB0_RXHUBPORT7_R       (*((volatile unsigned long *)0x400500BF))
+#define USB0_TXFUNCADDR8_R      (*((volatile unsigned long *)0x400500C0))
+#define USB0_TXHUBADDR8_R       (*((volatile unsigned long *)0x400500C2))
+#define USB0_TXHUBPORT8_R       (*((volatile unsigned long *)0x400500C3))
+#define USB0_RXFUNCADDR8_R      (*((volatile unsigned long *)0x400500C4))
+#define USB0_RXHUBADDR8_R       (*((volatile unsigned long *)0x400500C6))
+#define USB0_RXHUBPORT8_R       (*((volatile unsigned long *)0x400500C7))
+#define USB0_TXFUNCADDR9_R      (*((volatile unsigned long *)0x400500C8))
+#define USB0_TXHUBADDR9_R       (*((volatile unsigned long *)0x400500CA))
+#define USB0_TXHUBPORT9_R       (*((volatile unsigned long *)0x400500CB))
+#define USB0_RXFUNCADDR9_R      (*((volatile unsigned long *)0x400500CC))
+#define USB0_RXHUBADDR9_R       (*((volatile unsigned long *)0x400500CE))
+#define USB0_RXHUBPORT9_R       (*((volatile unsigned long *)0x400500CF))
+#define USB0_TXFUNCADDR10_R     (*((volatile unsigned long *)0x400500D0))
+#define USB0_TXHUBADDR10_R      (*((volatile unsigned long *)0x400500D2))
+#define USB0_TXHUBPORT10_R      (*((volatile unsigned long *)0x400500D3))
+#define USB0_RXFUNCADDR10_R     (*((volatile unsigned long *)0x400500D4))
+#define USB0_RXHUBADDR10_R      (*((volatile unsigned long *)0x400500D6))
+#define USB0_RXHUBPORT10_R      (*((volatile unsigned long *)0x400500D7))
+#define USB0_TXFUNCADDR11_R     (*((volatile unsigned long *)0x400500D8))
+#define USB0_TXHUBADDR11_R      (*((volatile unsigned long *)0x400500DA))
+#define USB0_TXHUBPORT11_R      (*((volatile unsigned long *)0x400500DB))
+#define USB0_RXFUNCADDR11_R     (*((volatile unsigned long *)0x400500DC))
+#define USB0_RXHUBADDR11_R      (*((volatile unsigned long *)0x400500DE))
+#define USB0_RXHUBPORT11_R      (*((volatile unsigned long *)0x400500DF))
+#define USB0_TXFUNCADDR12_R     (*((volatile unsigned long *)0x400500E0))
+#define USB0_TXHUBADDR12_R      (*((volatile unsigned long *)0x400500E2))
+#define USB0_TXHUBPORT12_R      (*((volatile unsigned long *)0x400500E3))
+#define USB0_RXFUNCADDR12_R     (*((volatile unsigned long *)0x400500E4))
+#define USB0_RXHUBADDR12_R      (*((volatile unsigned long *)0x400500E6))
+#define USB0_RXHUBPORT12_R      (*((volatile unsigned long *)0x400500E7))
+#define USB0_TXFUNCADDR13_R     (*((volatile unsigned long *)0x400500E8))
+#define USB0_TXHUBADDR13_R      (*((volatile unsigned long *)0x400500EA))
+#define USB0_TXHUBPORT13_R      (*((volatile unsigned long *)0x400500EB))
+#define USB0_RXFUNCADDR13_R     (*((volatile unsigned long *)0x400500EC))
+#define USB0_RXHUBADDR13_R      (*((volatile unsigned long *)0x400500EE))
+#define USB0_RXHUBPORT13_R      (*((volatile unsigned long *)0x400500EF))
+#define USB0_TXFUNCADDR14_R     (*((volatile unsigned long *)0x400500F0))
+#define USB0_TXHUBADDR14_R      (*((volatile unsigned long *)0x400500F2))
+#define USB0_TXHUBPORT14_R      (*((volatile unsigned long *)0x400500F3))
+#define USB0_RXFUNCADDR14_R     (*((volatile unsigned long *)0x400500F4))
+#define USB0_RXHUBADDR14_R      (*((volatile unsigned long *)0x400500F6))
+#define USB0_RXHUBPORT14_R      (*((volatile unsigned long *)0x400500F7))
+#define USB0_TXFUNCADDR15_R     (*((volatile unsigned long *)0x400500F8))
+#define USB0_TXHUBADDR15_R      (*((volatile unsigned long *)0x400500FA))
+#define USB0_TXHUBPORT15_R      (*((volatile unsigned long *)0x400500FB))
+#define USB0_RXFUNCADDR15_R     (*((volatile unsigned long *)0x400500FC))
+#define USB0_RXHUBADDR15_R      (*((volatile unsigned long *)0x400500FE))
+#define USB0_RXHUBPORT15_R      (*((volatile unsigned long *)0x400500FF))
+#define USB0_CSRL0_R            (*((volatile unsigned long *)0x40050102))
+#define USB0_CSRH0_R            (*((volatile unsigned long *)0x40050103))
+#define USB0_COUNT0_R           (*((volatile unsigned long *)0x40050108))
+#define USB0_TYPE0_R            (*((volatile unsigned long *)0x4005010A))
+#define USB0_NAKLMT_R           (*((volatile unsigned long *)0x4005010B))
+#define USB0_TXMAXP1_R          (*((volatile unsigned long *)0x40050110))
+#define USB0_TXCSRL1_R          (*((volatile unsigned long *)0x40050112))
+#define USB0_TXCSRH1_R          (*((volatile unsigned long *)0x40050113))
+#define USB0_RXMAXP1_R          (*((volatile unsigned long *)0x40050114))
+#define USB0_RXCSRL1_R          (*((volatile unsigned long *)0x40050116))
+#define USB0_RXCSRH1_R          (*((volatile unsigned long *)0x40050117))
+#define USB0_RXCOUNT1_R         (*((volatile unsigned long *)0x40050118))
+#define USB0_TXTYPE1_R          (*((volatile unsigned long *)0x4005011A))
+#define USB0_TXINTERVAL1_R      (*((volatile unsigned long *)0x4005011B))
+#define USB0_RXTYPE1_R          (*((volatile unsigned long *)0x4005011C))
+#define USB0_RXINTERVAL1_R      (*((volatile unsigned long *)0x4005011D))
+#define USB0_TXMAXP2_R          (*((volatile unsigned long *)0x40050120))
+#define USB0_TXCSRL2_R          (*((volatile unsigned long *)0x40050122))
+#define USB0_TXCSRH2_R          (*((volatile unsigned long *)0x40050123))
+#define USB0_RXMAXP2_R          (*((volatile unsigned long *)0x40050124))
+#define USB0_RXCSRL2_R          (*((volatile unsigned long *)0x40050126))
+#define USB0_RXCSRH2_R          (*((volatile unsigned long *)0x40050127))
+#define USB0_RXCOUNT2_R         (*((volatile unsigned long *)0x40050128))
+#define USB0_TXTYPE2_R          (*((volatile unsigned long *)0x4005012A))
+#define USB0_TXINTERVAL2_R      (*((volatile unsigned long *)0x4005012B))
+#define USB0_RXTYPE2_R          (*((volatile unsigned long *)0x4005012C))
+#define USB0_RXINTERVAL2_R      (*((volatile unsigned long *)0x4005012D))
+#define USB0_TXMAXP3_R          (*((volatile unsigned long *)0x40050130))
+#define USB0_TXCSRL3_R          (*((volatile unsigned long *)0x40050132))
+#define USB0_TXCSRH3_R          (*((volatile unsigned long *)0x40050133))
+#define USB0_RXMAXP3_R          (*((volatile unsigned long *)0x40050134))
+#define USB0_RXCSRL3_R          (*((volatile unsigned long *)0x40050136))
+#define USB0_RXCSRH3_R          (*((volatile unsigned long *)0x40050137))
+#define USB0_RXCOUNT3_R         (*((volatile unsigned long *)0x40050138))
+#define USB0_TXTYPE3_R          (*((volatile unsigned long *)0x4005013A))
+#define USB0_TXINTERVAL3_R      (*((volatile unsigned long *)0x4005013B))
+#define USB0_RXTYPE3_R          (*((volatile unsigned long *)0x4005013C))
+#define USB0_RXINTERVAL3_R      (*((volatile unsigned long *)0x4005013D))
+#define USB0_TXMAXP4_R          (*((volatile unsigned long *)0x40050140))
+#define USB0_TXCSRL4_R          (*((volatile unsigned long *)0x40050142))
+#define USB0_TXCSRH4_R          (*((volatile unsigned long *)0x40050143))
+#define USB0_RXMAXP4_R          (*((volatile unsigned long *)0x40050144))
+#define USB0_RXCSRL4_R          (*((volatile unsigned long *)0x40050146))
+#define USB0_RXCSRH4_R          (*((volatile unsigned long *)0x40050147))
+#define USB0_RXCOUNT4_R         (*((volatile unsigned long *)0x40050148))
+#define USB0_TXTYPE4_R          (*((volatile unsigned long *)0x4005014A))
+#define USB0_TXINTERVAL4_R      (*((volatile unsigned long *)0x4005014B))
+#define USB0_RXTYPE4_R          (*((volatile unsigned long *)0x4005014C))
+#define USB0_RXINTERVAL4_R      (*((volatile unsigned long *)0x4005014D))
+#define USB0_TXMAXP5_R          (*((volatile unsigned long *)0x40050150))
+#define USB0_TXCSRL5_R          (*((volatile unsigned long *)0x40050152))
+#define USB0_TXCSRH5_R          (*((volatile unsigned long *)0x40050153))
+#define USB0_RXMAXP5_R          (*((volatile unsigned long *)0x40050154))
+#define USB0_RXCSRL5_R          (*((volatile unsigned long *)0x40050156))
+#define USB0_RXCSRH5_R          (*((volatile unsigned long *)0x40050157))
+#define USB0_RXCOUNT5_R         (*((volatile unsigned long *)0x40050158))
+#define USB0_TXTYPE5_R          (*((volatile unsigned long *)0x4005015A))
+#define USB0_TXINTERVAL5_R      (*((volatile unsigned long *)0x4005015B))
+#define USB0_RXTYPE5_R          (*((volatile unsigned long *)0x4005015C))
+#define USB0_RXINTERVAL5_R      (*((volatile unsigned long *)0x4005015D))
+#define USB0_TXMAXP6_R          (*((volatile unsigned long *)0x40050160))
+#define USB0_TXCSRL6_R          (*((volatile unsigned long *)0x40050162))
+#define USB0_TXCSRH6_R          (*((volatile unsigned long *)0x40050163))
+#define USB0_RXMAXP6_R          (*((volatile unsigned long *)0x40050164))
+#define USB0_RXCSRL6_R          (*((volatile unsigned long *)0x40050166))
+#define USB0_RXCSRH6_R          (*((volatile unsigned long *)0x40050167))
+#define USB0_RXCOUNT6_R         (*((volatile unsigned long *)0x40050168))
+#define USB0_TXTYPE6_R          (*((volatile unsigned long *)0x4005016A))
+#define USB0_TXINTERVAL6_R      (*((volatile unsigned long *)0x4005016B))
+#define USB0_RXTYPE6_R          (*((volatile unsigned long *)0x4005016C))
+#define USB0_RXINTERVAL6_R      (*((volatile unsigned long *)0x4005016D))
+#define USB0_TXMAXP7_R          (*((volatile unsigned long *)0x40050170))
+#define USB0_TXCSRL7_R          (*((volatile unsigned long *)0x40050172))
+#define USB0_TXCSRH7_R          (*((volatile unsigned long *)0x40050173))
+#define USB0_RXMAXP7_R          (*((volatile unsigned long *)0x40050174))
+#define USB0_RXCSRL7_R          (*((volatile unsigned long *)0x40050176))
+#define USB0_RXCSRH7_R          (*((volatile unsigned long *)0x40050177))
+#define USB0_RXCOUNT7_R         (*((volatile unsigned long *)0x40050178))
+#define USB0_TXTYPE7_R          (*((volatile unsigned long *)0x4005017A))
+#define USB0_TXINTERVAL7_R      (*((volatile unsigned long *)0x4005017B))
+#define USB0_RXTYPE7_R          (*((volatile unsigned long *)0x4005017C))
+#define USB0_RXINTERVAL7_R      (*((volatile unsigned long *)0x4005017D))
+#define USB0_TXMAXP8_R          (*((volatile unsigned long *)0x40050180))
+#define USB0_TXCSRL8_R          (*((volatile unsigned long *)0x40050182))
+#define USB0_TXCSRH8_R          (*((volatile unsigned long *)0x40050183))
+#define USB0_RXMAXP8_R          (*((volatile unsigned long *)0x40050184))
+#define USB0_RXCSRL8_R          (*((volatile unsigned long *)0x40050186))
+#define USB0_RXCSRH8_R          (*((volatile unsigned long *)0x40050187))
+#define USB0_RXCOUNT8_R         (*((volatile unsigned long *)0x40050188))
+#define USB0_TXTYPE8_R          (*((volatile unsigned long *)0x4005018A))
+#define USB0_TXINTERVAL8_R      (*((volatile unsigned long *)0x4005018B))
+#define USB0_RXTYPE8_R          (*((volatile unsigned long *)0x4005018C))
+#define USB0_RXINTERVAL8_R      (*((volatile unsigned long *)0x4005018D))
+#define USB0_TXMAXP9_R          (*((volatile unsigned long *)0x40050190))
+#define USB0_TXCSRL9_R          (*((volatile unsigned long *)0x40050192))
+#define USB0_TXCSRH9_R          (*((volatile unsigned long *)0x40050193))
+#define USB0_RXMAXP9_R          (*((volatile unsigned long *)0x40050194))
+#define USB0_RXCSRL9_R          (*((volatile unsigned long *)0x40050196))
+#define USB0_RXCSRH9_R          (*((volatile unsigned long *)0x40050197))
+#define USB0_RXCOUNT9_R         (*((volatile unsigned long *)0x40050198))
+#define USB0_TXTYPE9_R          (*((volatile unsigned long *)0x4005019A))
+#define USB0_TXINTERVAL9_R      (*((volatile unsigned long *)0x4005019B))
+#define USB0_RXTYPE9_R          (*((volatile unsigned long *)0x4005019C))
+#define USB0_RXINTERVAL9_R      (*((volatile unsigned long *)0x4005019D))
+#define USB0_TXMAXP10_R         (*((volatile unsigned long *)0x400501A0))
+#define USB0_TXCSRL10_R         (*((volatile unsigned long *)0x400501A2))
+#define USB0_TXCSRH10_R         (*((volatile unsigned long *)0x400501A3))
+#define USB0_RXMAXP10_R         (*((volatile unsigned long *)0x400501A4))
+#define USB0_RXCSRL10_R         (*((volatile unsigned long *)0x400501A6))
+#define USB0_RXCSRH10_R         (*((volatile unsigned long *)0x400501A7))
+#define USB0_RXCOUNT10_R        (*((volatile unsigned long *)0x400501A8))
+#define USB0_TXTYPE10_R         (*((volatile unsigned long *)0x400501AA))
+#define USB0_TXINTERVAL10_R     (*((volatile unsigned long *)0x400501AB))
+#define USB0_RXTYPE10_R         (*((volatile unsigned long *)0x400501AC))
+#define USB0_RXINTERVAL10_R     (*((volatile unsigned long *)0x400501AD))
+#define USB0_TXMAXP11_R         (*((volatile unsigned long *)0x400501B0))
+#define USB0_TXCSRL11_R         (*((volatile unsigned long *)0x400501B2))
+#define USB0_TXCSRH11_R         (*((volatile unsigned long *)0x400501B3))
+#define USB0_RXMAXP11_R         (*((volatile unsigned long *)0x400501B4))
+#define USB0_RXCSRL11_R         (*((volatile unsigned long *)0x400501B6))
+#define USB0_RXCSRH11_R         (*((volatile unsigned long *)0x400501B7))
+#define USB0_RXCOUNT11_R        (*((volatile unsigned long *)0x400501B8))
+#define USB0_TXTYPE11_R         (*((volatile unsigned long *)0x400501BA))
+#define USB0_TXINTERVAL11_R     (*((volatile unsigned long *)0x400501BB))
+#define USB0_RXTYPE11_R         (*((volatile unsigned long *)0x400501BC))
+#define USB0_RXINTERVAL11_R     (*((volatile unsigned long *)0x400501BD))
+#define USB0_TXMAXP12_R         (*((volatile unsigned long *)0x400501C0))
+#define USB0_TXCSRL12_R         (*((volatile unsigned long *)0x400501C2))
+#define USB0_TXCSRH12_R         (*((volatile unsigned long *)0x400501C3))
+#define USB0_RXMAXP12_R         (*((volatile unsigned long *)0x400501C4))
+#define USB0_RXCSRL12_R         (*((volatile unsigned long *)0x400501C6))
+#define USB0_RXCSRH12_R         (*((volatile unsigned long *)0x400501C7))
+#define USB0_RXCOUNT12_R        (*((volatile unsigned long *)0x400501C8))
+#define USB0_TXTYPE12_R         (*((volatile unsigned long *)0x400501CA))
+#define USB0_TXINTERVAL12_R     (*((volatile unsigned long *)0x400501CB))
+#define USB0_RXTYPE12_R         (*((volatile unsigned long *)0x400501CC))
+#define USB0_RXINTERVAL12_R     (*((volatile unsigned long *)0x400501CD))
+#define USB0_TXMAXP13_R         (*((volatile unsigned long *)0x400501D0))
+#define USB0_TXCSRL13_R         (*((volatile unsigned long *)0x400501D2))
+#define USB0_TXCSRH13_R         (*((volatile unsigned long *)0x400501D3))
+#define USB0_RXMAXP13_R         (*((volatile unsigned long *)0x400501D4))
+#define USB0_RXCSRL13_R         (*((volatile unsigned long *)0x400501D6))
+#define USB0_RXCSRH13_R         (*((volatile unsigned long *)0x400501D7))
+#define USB0_RXCOUNT13_R        (*((volatile unsigned long *)0x400501D8))
+#define USB0_TXTYPE13_R         (*((volatile unsigned long *)0x400501DA))
+#define USB0_TXINTERVAL13_R     (*((volatile unsigned long *)0x400501DB))
+#define USB0_RXTYPE13_R         (*((volatile unsigned long *)0x400501DC))
+#define USB0_RXINTERVAL13_R     (*((volatile unsigned long *)0x400501DD))
+#define USB0_TXMAXP14_R         (*((volatile unsigned long *)0x400501E0))
+#define USB0_TXCSRL14_R         (*((volatile unsigned long *)0x400501E2))
+#define USB0_TXCSRH14_R         (*((volatile unsigned long *)0x400501E3))
+#define USB0_RXMAXP14_R         (*((volatile unsigned long *)0x400501E4))
+#define USB0_RXCSRL14_R         (*((volatile unsigned long *)0x400501E6))
+#define USB0_RXCSRH14_R         (*((volatile unsigned long *)0x400501E7))
+#define USB0_RXCOUNT14_R        (*((volatile unsigned long *)0x400501E8))
+#define USB0_TXTYPE14_R         (*((volatile unsigned long *)0x400501EA))
+#define USB0_TXINTERVAL14_R     (*((volatile unsigned long *)0x400501EB))
+#define USB0_RXTYPE14_R         (*((volatile unsigned long *)0x400501EC))
+#define USB0_RXINTERVAL14_R     (*((volatile unsigned long *)0x400501ED))
+#define USB0_TXMAXP15_R         (*((volatile unsigned long *)0x400501F0))
+#define USB0_TXCSRL15_R         (*((volatile unsigned long *)0x400501F2))
+#define USB0_TXCSRH15_R         (*((volatile unsigned long *)0x400501F3))
+#define USB0_RXMAXP15_R         (*((volatile unsigned long *)0x400501F4))
+#define USB0_RXCSRL15_R         (*((volatile unsigned long *)0x400501F6))
+#define USB0_RXCSRH15_R         (*((volatile unsigned long *)0x400501F7))
+#define USB0_RXCOUNT15_R        (*((volatile unsigned long *)0x400501F8))
+#define USB0_TXTYPE15_R         (*((volatile unsigned long *)0x400501FA))
+#define USB0_TXINTERVAL15_R     (*((volatile unsigned long *)0x400501FB))
+#define USB0_RXTYPE15_R         (*((volatile unsigned long *)0x400501FC))
+#define USB0_RXINTERVAL15_R     (*((volatile unsigned long *)0x400501FD))
+#define USB0_RQPKTCOUNT1_R      (*((volatile unsigned long *)0x40050304))
+#define USB0_RQPKTCOUNT2_R      (*((volatile unsigned long *)0x40050308))
+#define USB0_RQPKTCOUNT3_R      (*((volatile unsigned long *)0x4005030C))
+#define USB0_RQPKTCOUNT4_R      (*((volatile unsigned long *)0x40050310))
+#define USB0_RQPKTCOUNT5_R      (*((volatile unsigned long *)0x40050314))
+#define USB0_RQPKTCOUNT6_R      (*((volatile unsigned long *)0x40050318))
+#define USB0_RQPKTCOUNT7_R      (*((volatile unsigned long *)0x4005031C))
+#define USB0_RQPKTCOUNT8_R      (*((volatile unsigned long *)0x40050320))
+#define USB0_RQPKTCOUNT9_R      (*((volatile unsigned long *)0x40050324))
+#define USB0_RQPKTCOUNT10_R     (*((volatile unsigned long *)0x40050328))
+#define USB0_RQPKTCOUNT11_R     (*((volatile unsigned long *)0x4005032C))
+#define USB0_RQPKTCOUNT12_R     (*((volatile unsigned long *)0x40050330))
+#define USB0_RQPKTCOUNT13_R     (*((volatile unsigned long *)0x40050334))
+#define USB0_RQPKTCOUNT14_R     (*((volatile unsigned long *)0x40050338))
+#define USB0_RQPKTCOUNT15_R     (*((volatile unsigned long *)0x4005033C))
+#define USB0_RXDPKTBUFDIS_R     (*((volatile unsigned long *)0x40050340))
+#define USB0_TXDPKTBUFDIS_R     (*((volatile unsigned long *)0x40050342))
+#define USB0_EPC_R              (*((volatile unsigned long *)0x40050400))
+#define USB0_EPCRIS_R           (*((volatile unsigned long *)0x40050404))
+#define USB0_EPCIM_R            (*((volatile unsigned long *)0x40050408))
+#define USB0_EPCISC_R           (*((volatile unsigned long *)0x4005040C))
+#define USB0_DRRIS_R            (*((volatile unsigned long *)0x40050410))
+#define USB0_DRIM_R             (*((volatile unsigned long *)0x40050414))
+#define USB0_DRISC_R            (*((volatile unsigned long *)0x40050418))
+#define USB0_VDC_R              (*((volatile unsigned long *)0x40050430))
+#define USB0_VDCRIS_R           (*((volatile unsigned long *)0x40050434))
+#define USB0_VDCIM_R            (*((volatile unsigned long *)0x40050438))
+#define USB0_VDCISC_R           (*((volatile unsigned long *)0x4005043C))
+#define USB0_IDVRIS_R           (*((volatile unsigned long *)0x40050444))
+#define USB0_IDVIM_R            (*((volatile unsigned long *)0x40050448))
+#define USB0_IDVISC_R           (*((volatile unsigned long *)0x4005044C))
+#define USB0_EPS_R              (*((volatile unsigned long *)0x40050450))
+
+//*****************************************************************************
+//
+// Inter-Integrated Circuit Sound (I2S0) Interface
+//
+//*****************************************************************************
+#define I2S0_TXFIFO_R           (*((volatile unsigned long *)0x40054000))
+#define I2S0_TXFIFOCFG_R        (*((volatile unsigned long *)0x40054004))
+#define I2S0_TXCFG_R            (*((volatile unsigned long *)0x40054008))
+#define I2S0_TXLIMIT_R          (*((volatile unsigned long *)0x4005400C))
+#define I2S0_TXISM_R            (*((volatile unsigned long *)0x40054010))
+#define I2S0_TXLEV_R            (*((volatile unsigned long *)0x40054018))
+#define I2S0_RXFIFO_R           (*((volatile unsigned long *)0x40054800))
+#define I2S0_RXFIFOCFG_R        (*((volatile unsigned long *)0x40054804))
+#define I2S0_RXCFG_R            (*((volatile unsigned long *)0x40054808))
+#define I2S0_RXLIMIT_R          (*((volatile unsigned long *)0x4005480C))
+#define I2S0_RXISM_R            (*((volatile unsigned long *)0x40054810))
+#define I2S0_RXLEV_R            (*((volatile unsigned long *)0x40054818))
+#define I2S0_CFG_R              (*((volatile unsigned long *)0x40054C00))
+#define I2S0_IM_R               (*((volatile unsigned long *)0x40054C10))
+#define I2S0_RIS_R              (*((volatile unsigned long *)0x40054C14))
+#define I2S0_MIS_R              (*((volatile unsigned long *)0x40054C18))
+#define I2S0_IC_R               (*((volatile unsigned long *)0x40054C1C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTA_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x40058000)
+#define GPIO_PORTA_AHB_DATA_R   (*((volatile unsigned long *)0x400583FC))
+#define GPIO_PORTA_AHB_DIR_R    (*((volatile unsigned long *)0x40058400))
+#define GPIO_PORTA_AHB_IS_R     (*((volatile unsigned long *)0x40058404))
+#define GPIO_PORTA_AHB_IBE_R    (*((volatile unsigned long *)0x40058408))
+#define GPIO_PORTA_AHB_IEV_R    (*((volatile unsigned long *)0x4005840C))
+#define GPIO_PORTA_AHB_IM_R     (*((volatile unsigned long *)0x40058410))
+#define GPIO_PORTA_AHB_RIS_R    (*((volatile unsigned long *)0x40058414))
+#define GPIO_PORTA_AHB_MIS_R    (*((volatile unsigned long *)0x40058418))
+#define GPIO_PORTA_AHB_ICR_R    (*((volatile unsigned long *)0x4005841C))
+#define GPIO_PORTA_AHB_AFSEL_R  (*((volatile unsigned long *)0x40058420))
+#define GPIO_PORTA_AHB_DR2R_R   (*((volatile unsigned long *)0x40058500))
+#define GPIO_PORTA_AHB_DR4R_R   (*((volatile unsigned long *)0x40058504))
+#define GPIO_PORTA_AHB_DR8R_R   (*((volatile unsigned long *)0x40058508))
+#define GPIO_PORTA_AHB_ODR_R    (*((volatile unsigned long *)0x4005850C))
+#define GPIO_PORTA_AHB_PUR_R    (*((volatile unsigned long *)0x40058510))
+#define GPIO_PORTA_AHB_PDR_R    (*((volatile unsigned long *)0x40058514))
+#define GPIO_PORTA_AHB_SLR_R    (*((volatile unsigned long *)0x40058518))
+#define GPIO_PORTA_AHB_DEN_R    (*((volatile unsigned long *)0x4005851C))
+#define GPIO_PORTA_AHB_LOCK_R   (*((volatile unsigned long *)0x40058520))
+#define GPIO_PORTA_AHB_CR_R     (*((volatile unsigned long *)0x40058524))
+#define GPIO_PORTA_AHB_AMSEL_R  (*((volatile unsigned long *)0x40058528))
+#define GPIO_PORTA_AHB_PCTL_R   (*((volatile unsigned long *)0x4005852C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTB_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x40059000)
+#define GPIO_PORTB_AHB_DATA_R   (*((volatile unsigned long *)0x400593FC))
+#define GPIO_PORTB_AHB_DIR_R    (*((volatile unsigned long *)0x40059400))
+#define GPIO_PORTB_AHB_IS_R     (*((volatile unsigned long *)0x40059404))
+#define GPIO_PORTB_AHB_IBE_R    (*((volatile unsigned long *)0x40059408))
+#define GPIO_PORTB_AHB_IEV_R    (*((volatile unsigned long *)0x4005940C))
+#define GPIO_PORTB_AHB_IM_R     (*((volatile unsigned long *)0x40059410))
+#define GPIO_PORTB_AHB_RIS_R    (*((volatile unsigned long *)0x40059414))
+#define GPIO_PORTB_AHB_MIS_R    (*((volatile unsigned long *)0x40059418))
+#define GPIO_PORTB_AHB_ICR_R    (*((volatile unsigned long *)0x4005941C))
+#define GPIO_PORTB_AHB_AFSEL_R  (*((volatile unsigned long *)0x40059420))
+#define GPIO_PORTB_AHB_DR2R_R   (*((volatile unsigned long *)0x40059500))
+#define GPIO_PORTB_AHB_DR4R_R   (*((volatile unsigned long *)0x40059504))
+#define GPIO_PORTB_AHB_DR8R_R   (*((volatile unsigned long *)0x40059508))
+#define GPIO_PORTB_AHB_ODR_R    (*((volatile unsigned long *)0x4005950C))
+#define GPIO_PORTB_AHB_PUR_R    (*((volatile unsigned long *)0x40059510))
+#define GPIO_PORTB_AHB_PDR_R    (*((volatile unsigned long *)0x40059514))
+#define GPIO_PORTB_AHB_SLR_R    (*((volatile unsigned long *)0x40059518))
+#define GPIO_PORTB_AHB_DEN_R    (*((volatile unsigned long *)0x4005951C))
+#define GPIO_PORTB_AHB_LOCK_R   (*((volatile unsigned long *)0x40059520))
+#define GPIO_PORTB_AHB_CR_R     (*((volatile unsigned long *)0x40059524))
+#define GPIO_PORTB_AHB_AMSEL_R  (*((volatile unsigned long *)0x40059528))
+#define GPIO_PORTB_AHB_PCTL_R   (*((volatile unsigned long *)0x4005952C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTC_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x4005A000)
+#define GPIO_PORTC_AHB_DATA_R   (*((volatile unsigned long *)0x4005A3FC))
+#define GPIO_PORTC_AHB_DIR_R    (*((volatile unsigned long *)0x4005A400))
+#define GPIO_PORTC_AHB_IS_R     (*((volatile unsigned long *)0x4005A404))
+#define GPIO_PORTC_AHB_IBE_R    (*((volatile unsigned long *)0x4005A408))
+#define GPIO_PORTC_AHB_IEV_R    (*((volatile unsigned long *)0x4005A40C))
+#define GPIO_PORTC_AHB_IM_R     (*((volatile unsigned long *)0x4005A410))
+#define GPIO_PORTC_AHB_RIS_R    (*((volatile unsigned long *)0x4005A414))
+#define GPIO_PORTC_AHB_MIS_R    (*((volatile unsigned long *)0x4005A418))
+#define GPIO_PORTC_AHB_ICR_R    (*((volatile unsigned long *)0x4005A41C))
+#define GPIO_PORTC_AHB_AFSEL_R  (*((volatile unsigned long *)0x4005A420))
+#define GPIO_PORTC_AHB_DR2R_R   (*((volatile unsigned long *)0x4005A500))
+#define GPIO_PORTC_AHB_DR4R_R   (*((volatile unsigned long *)0x4005A504))
+#define GPIO_PORTC_AHB_DR8R_R   (*((volatile unsigned long *)0x4005A508))
+#define GPIO_PORTC_AHB_ODR_R    (*((volatile unsigned long *)0x4005A50C))
+#define GPIO_PORTC_AHB_PUR_R    (*((volatile unsigned long *)0x4005A510))
+#define GPIO_PORTC_AHB_PDR_R    (*((volatile unsigned long *)0x4005A514))
+#define GPIO_PORTC_AHB_SLR_R    (*((volatile unsigned long *)0x4005A518))
+#define GPIO_PORTC_AHB_DEN_R    (*((volatile unsigned long *)0x4005A51C))
+#define GPIO_PORTC_AHB_LOCK_R   (*((volatile unsigned long *)0x4005A520))
+#define GPIO_PORTC_AHB_CR_R     (*((volatile unsigned long *)0x4005A524))
+#define GPIO_PORTC_AHB_AMSEL_R  (*((volatile unsigned long *)0x4005A528))
+#define GPIO_PORTC_AHB_PCTL_R   (*((volatile unsigned long *)0x4005A52C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTD_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x4005B000)
+#define GPIO_PORTD_AHB_DATA_R   (*((volatile unsigned long *)0x4005B3FC))
+#define GPIO_PORTD_AHB_DIR_R    (*((volatile unsigned long *)0x4005B400))
+#define GPIO_PORTD_AHB_IS_R     (*((volatile unsigned long *)0x4005B404))
+#define GPIO_PORTD_AHB_IBE_R    (*((volatile unsigned long *)0x4005B408))
+#define GPIO_PORTD_AHB_IEV_R    (*((volatile unsigned long *)0x4005B40C))
+#define GPIO_PORTD_AHB_IM_R     (*((volatile unsigned long *)0x4005B410))
+#define GPIO_PORTD_AHB_RIS_R    (*((volatile unsigned long *)0x4005B414))
+#define GPIO_PORTD_AHB_MIS_R    (*((volatile unsigned long *)0x4005B418))
+#define GPIO_PORTD_AHB_ICR_R    (*((volatile unsigned long *)0x4005B41C))
+#define GPIO_PORTD_AHB_AFSEL_R  (*((volatile unsigned long *)0x4005B420))
+#define GPIO_PORTD_AHB_DR2R_R   (*((volatile unsigned long *)0x4005B500))
+#define GPIO_PORTD_AHB_DR4R_R   (*((volatile unsigned long *)0x4005B504))
+#define GPIO_PORTD_AHB_DR8R_R   (*((volatile unsigned long *)0x4005B508))
+#define GPIO_PORTD_AHB_ODR_R    (*((volatile unsigned long *)0x4005B50C))
+#define GPIO_PORTD_AHB_PUR_R    (*((volatile unsigned long *)0x4005B510))
+#define GPIO_PORTD_AHB_PDR_R    (*((volatile unsigned long *)0x4005B514))
+#define GPIO_PORTD_AHB_SLR_R    (*((volatile unsigned long *)0x4005B518))
+#define GPIO_PORTD_AHB_DEN_R    (*((volatile unsigned long *)0x4005B51C))
+#define GPIO_PORTD_AHB_LOCK_R   (*((volatile unsigned long *)0x4005B520))
+#define GPIO_PORTD_AHB_CR_R     (*((volatile unsigned long *)0x4005B524))
+#define GPIO_PORTD_AHB_AMSEL_R  (*((volatile unsigned long *)0x4005B528))
+#define GPIO_PORTD_AHB_PCTL_R   (*((volatile unsigned long *)0x4005B52C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTE_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x4005C000)
+#define GPIO_PORTE_AHB_DATA_R   (*((volatile unsigned long *)0x4005C3FC))
+#define GPIO_PORTE_AHB_DIR_R    (*((volatile unsigned long *)0x4005C400))
+#define GPIO_PORTE_AHB_IS_R     (*((volatile unsigned long *)0x4005C404))
+#define GPIO_PORTE_AHB_IBE_R    (*((volatile unsigned long *)0x4005C408))
+#define GPIO_PORTE_AHB_IEV_R    (*((volatile unsigned long *)0x4005C40C))
+#define GPIO_PORTE_AHB_IM_R     (*((volatile unsigned long *)0x4005C410))
+#define GPIO_PORTE_AHB_RIS_R    (*((volatile unsigned long *)0x4005C414))
+#define GPIO_PORTE_AHB_MIS_R    (*((volatile unsigned long *)0x4005C418))
+#define GPIO_PORTE_AHB_ICR_R    (*((volatile unsigned long *)0x4005C41C))
+#define GPIO_PORTE_AHB_AFSEL_R  (*((volatile unsigned long *)0x4005C420))
+#define GPIO_PORTE_AHB_DR2R_R   (*((volatile unsigned long *)0x4005C500))
+#define GPIO_PORTE_AHB_DR4R_R   (*((volatile unsigned long *)0x4005C504))
+#define GPIO_PORTE_AHB_DR8R_R   (*((volatile unsigned long *)0x4005C508))
+#define GPIO_PORTE_AHB_ODR_R    (*((volatile unsigned long *)0x4005C50C))
+#define GPIO_PORTE_AHB_PUR_R    (*((volatile unsigned long *)0x4005C510))
+#define GPIO_PORTE_AHB_PDR_R    (*((volatile unsigned long *)0x4005C514))
+#define GPIO_PORTE_AHB_SLR_R    (*((volatile unsigned long *)0x4005C518))
+#define GPIO_PORTE_AHB_DEN_R    (*((volatile unsigned long *)0x4005C51C))
+#define GPIO_PORTE_AHB_LOCK_R   (*((volatile unsigned long *)0x4005C520))
+#define GPIO_PORTE_AHB_CR_R     (*((volatile unsigned long *)0x4005C524))
+#define GPIO_PORTE_AHB_AMSEL_R  (*((volatile unsigned long *)0x4005C528))
+#define GPIO_PORTE_AHB_PCTL_R   (*((volatile unsigned long *)0x4005C52C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTF_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x4005D000)
+#define GPIO_PORTF_AHB_DATA_R   (*((volatile unsigned long *)0x4005D3FC))
+#define GPIO_PORTF_AHB_DIR_R    (*((volatile unsigned long *)0x4005D400))
+#define GPIO_PORTF_AHB_IS_R     (*((volatile unsigned long *)0x4005D404))
+#define GPIO_PORTF_AHB_IBE_R    (*((volatile unsigned long *)0x4005D408))
+#define GPIO_PORTF_AHB_IEV_R    (*((volatile unsigned long *)0x4005D40C))
+#define GPIO_PORTF_AHB_IM_R     (*((volatile unsigned long *)0x4005D410))
+#define GPIO_PORTF_AHB_RIS_R    (*((volatile unsigned long *)0x4005D414))
+#define GPIO_PORTF_AHB_MIS_R    (*((volatile unsigned long *)0x4005D418))
+#define GPIO_PORTF_AHB_ICR_R    (*((volatile unsigned long *)0x4005D41C))
+#define GPIO_PORTF_AHB_AFSEL_R  (*((volatile unsigned long *)0x4005D420))
+#define GPIO_PORTF_AHB_DR2R_R   (*((volatile unsigned long *)0x4005D500))
+#define GPIO_PORTF_AHB_DR4R_R   (*((volatile unsigned long *)0x4005D504))
+#define GPIO_PORTF_AHB_DR8R_R   (*((volatile unsigned long *)0x4005D508))
+#define GPIO_PORTF_AHB_ODR_R    (*((volatile unsigned long *)0x4005D50C))
+#define GPIO_PORTF_AHB_PUR_R    (*((volatile unsigned long *)0x4005D510))
+#define GPIO_PORTF_AHB_PDR_R    (*((volatile unsigned long *)0x4005D514))
+#define GPIO_PORTF_AHB_SLR_R    (*((volatile unsigned long *)0x4005D518))
+#define GPIO_PORTF_AHB_DEN_R    (*((volatile unsigned long *)0x4005D51C))
+#define GPIO_PORTF_AHB_LOCK_R   (*((volatile unsigned long *)0x4005D520))
+#define GPIO_PORTF_AHB_CR_R     (*((volatile unsigned long *)0x4005D524))
+#define GPIO_PORTF_AHB_AMSEL_R  (*((volatile unsigned long *)0x4005D528))
+#define GPIO_PORTF_AHB_PCTL_R   (*((volatile unsigned long *)0x4005D52C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTG_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x4005E000)
+#define GPIO_PORTG_AHB_DATA_R   (*((volatile unsigned long *)0x4005E3FC))
+#define GPIO_PORTG_AHB_DIR_R    (*((volatile unsigned long *)0x4005E400))
+#define GPIO_PORTG_AHB_IS_R     (*((volatile unsigned long *)0x4005E404))
+#define GPIO_PORTG_AHB_IBE_R    (*((volatile unsigned long *)0x4005E408))
+#define GPIO_PORTG_AHB_IEV_R    (*((volatile unsigned long *)0x4005E40C))
+#define GPIO_PORTG_AHB_IM_R     (*((volatile unsigned long *)0x4005E410))
+#define GPIO_PORTG_AHB_RIS_R    (*((volatile unsigned long *)0x4005E414))
+#define GPIO_PORTG_AHB_MIS_R    (*((volatile unsigned long *)0x4005E418))
+#define GPIO_PORTG_AHB_ICR_R    (*((volatile unsigned long *)0x4005E41C))
+#define GPIO_PORTG_AHB_AFSEL_R  (*((volatile unsigned long *)0x4005E420))
+#define GPIO_PORTG_AHB_DR2R_R   (*((volatile unsigned long *)0x4005E500))
+#define GPIO_PORTG_AHB_DR4R_R   (*((volatile unsigned long *)0x4005E504))
+#define GPIO_PORTG_AHB_DR8R_R   (*((volatile unsigned long *)0x4005E508))
+#define GPIO_PORTG_AHB_ODR_R    (*((volatile unsigned long *)0x4005E50C))
+#define GPIO_PORTG_AHB_PUR_R    (*((volatile unsigned long *)0x4005E510))
+#define GPIO_PORTG_AHB_PDR_R    (*((volatile unsigned long *)0x4005E514))
+#define GPIO_PORTG_AHB_SLR_R    (*((volatile unsigned long *)0x4005E518))
+#define GPIO_PORTG_AHB_DEN_R    (*((volatile unsigned long *)0x4005E51C))
+#define GPIO_PORTG_AHB_LOCK_R   (*((volatile unsigned long *)0x4005E520))
+#define GPIO_PORTG_AHB_CR_R     (*((volatile unsigned long *)0x4005E524))
+#define GPIO_PORTG_AHB_AMSEL_R  (*((volatile unsigned long *)0x4005E528))
+#define GPIO_PORTG_AHB_PCTL_R   (*((volatile unsigned long *)0x4005E52C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTH_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x4005F000)
+#define GPIO_PORTH_AHB_DATA_R   (*((volatile unsigned long *)0x4005F3FC))
+#define GPIO_PORTH_AHB_DIR_R    (*((volatile unsigned long *)0x4005F400))
+#define GPIO_PORTH_AHB_IS_R     (*((volatile unsigned long *)0x4005F404))
+#define GPIO_PORTH_AHB_IBE_R    (*((volatile unsigned long *)0x4005F408))
+#define GPIO_PORTH_AHB_IEV_R    (*((volatile unsigned long *)0x4005F40C))
+#define GPIO_PORTH_AHB_IM_R     (*((volatile unsigned long *)0x4005F410))
+#define GPIO_PORTH_AHB_RIS_R    (*((volatile unsigned long *)0x4005F414))
+#define GPIO_PORTH_AHB_MIS_R    (*((volatile unsigned long *)0x4005F418))
+#define GPIO_PORTH_AHB_ICR_R    (*((volatile unsigned long *)0x4005F41C))
+#define GPIO_PORTH_AHB_AFSEL_R  (*((volatile unsigned long *)0x4005F420))
+#define GPIO_PORTH_AHB_DR2R_R   (*((volatile unsigned long *)0x4005F500))
+#define GPIO_PORTH_AHB_DR4R_R   (*((volatile unsigned long *)0x4005F504))
+#define GPIO_PORTH_AHB_DR8R_R   (*((volatile unsigned long *)0x4005F508))
+#define GPIO_PORTH_AHB_ODR_R    (*((volatile unsigned long *)0x4005F50C))
+#define GPIO_PORTH_AHB_PUR_R    (*((volatile unsigned long *)0x4005F510))
+#define GPIO_PORTH_AHB_PDR_R    (*((volatile unsigned long *)0x4005F514))
+#define GPIO_PORTH_AHB_SLR_R    (*((volatile unsigned long *)0x4005F518))
+#define GPIO_PORTH_AHB_DEN_R    (*((volatile unsigned long *)0x4005F51C))
+#define GPIO_PORTH_AHB_LOCK_R   (*((volatile unsigned long *)0x4005F520))
+#define GPIO_PORTH_AHB_CR_R     (*((volatile unsigned long *)0x4005F524))
+#define GPIO_PORTH_AHB_AMSEL_R  (*((volatile unsigned long *)0x4005F528))
+#define GPIO_PORTH_AHB_PCTL_R   (*((volatile unsigned long *)0x4005F52C))
+
+//*****************************************************************************
+//
+// General-Purpose Input/Outputs (AHB)
+//
+//*****************************************************************************
+#define GPIO_PORTJ_AHB_DATA_BITS_R \
+                                ((volatile unsigned long *)0x40060000)
+#define GPIO_PORTJ_AHB_DATA_R   (*((volatile unsigned long *)0x400603FC))
+#define GPIO_PORTJ_AHB_DIR_R    (*((volatile unsigned long *)0x40060400))
+#define GPIO_PORTJ_AHB_IS_R     (*((volatile unsigned long *)0x40060404))
+#define GPIO_PORTJ_AHB_IBE_R    (*((volatile unsigned long *)0x40060408))
+#define GPIO_PORTJ_AHB_IEV_R    (*((volatile unsigned long *)0x4006040C))
+#define GPIO_PORTJ_AHB_IM_R     (*((volatile unsigned long *)0x40060410))
+#define GPIO_PORTJ_AHB_RIS_R    (*((volatile unsigned long *)0x40060414))
+#define GPIO_PORTJ_AHB_MIS_R    (*((volatile unsigned long *)0x40060418))
+#define GPIO_PORTJ_AHB_ICR_R    (*((volatile unsigned long *)0x4006041C))
+#define GPIO_PORTJ_AHB_AFSEL_R  (*((volatile unsigned long *)0x40060420))
+#define GPIO_PORTJ_AHB_DR2R_R   (*((volatile unsigned long *)0x40060500))
+#define GPIO_PORTJ_AHB_DR4R_R   (*((volatile unsigned long *)0x40060504))
+#define GPIO_PORTJ_AHB_DR8R_R   (*((volatile unsigned long *)0x40060508))
+#define GPIO_PORTJ_AHB_ODR_R    (*((volatile unsigned long *)0x4006050C))
+#define GPIO_PORTJ_AHB_PUR_R    (*((volatile unsigned long *)0x40060510))
+#define GPIO_PORTJ_AHB_PDR_R    (*((volatile unsigned long *)0x40060514))
+#define GPIO_PORTJ_AHB_SLR_R    (*((volatile unsigned long *)0x40060518))
+#define GPIO_PORTJ_AHB_DEN_R    (*((volatile unsigned long *)0x4006051C))
+#define GPIO_PORTJ_AHB_LOCK_R   (*((volatile unsigned long *)0x40060520))
+#define GPIO_PORTJ_AHB_CR_R     (*((volatile unsigned long *)0x40060524))
+#define GPIO_PORTJ_AHB_AMSEL_R  (*((volatile unsigned long *)0x40060528))
+#define GPIO_PORTJ_AHB_PCTL_R   (*((volatile unsigned long *)0x4006052C))
+
+//*****************************************************************************
+//
+// External Peripheral Interface (EPI0)
+//
+//*****************************************************************************
+#define EPI0_CFG_R              (*((volatile unsigned long *)0x400D0000))
+#define EPI0_BAUD_R             (*((volatile unsigned long *)0x400D0004))
+#define EPI0_SDRAMCFG_R         (*((volatile unsigned long *)0x400D0010))
+#define EPI0_GPCFG_R            (*((volatile unsigned long *)0x400D0010))
+#define EPI0_HB8CFG_R           (*((volatile unsigned long *)0x400D0010))
+#define EPI0_SDRAMCFG2_R        (*((volatile unsigned long *)0x400D0014))
+#define EPI0_HB8CFG2_R          (*((volatile unsigned long *)0x400D0014))
+#define EPI0_GPCFG2_R           (*((volatile unsigned long *)0x400D0014))
+#define EPI0_ADDRMAP_R          (*((volatile unsigned long *)0x400D001C))
+#define EPI0_RSIZE0_R           (*((volatile unsigned long *)0x400D0020))
+#define EPI0_RADDR0_R           (*((volatile unsigned long *)0x400D0024))
+#define EPI0_RPSTD0_R           (*((volatile unsigned long *)0x400D0028))
+#define EPI0_RSIZE1_R           (*((volatile unsigned long *)0x400D0030))
+#define EPI0_RADDR1_R           (*((volatile unsigned long *)0x400D0034))
+#define EPI0_RPSTD1_R           (*((volatile unsigned long *)0x400D0038))
+#define EPI0_STAT_R             (*((volatile unsigned long *)0x400D0060))
+#define EPI0_RFIFOCNT_R         (*((volatile unsigned long *)0x400D006C))
+#define EPI0_READFIFO_R         (*((volatile unsigned long *)0x400D0070))
+#define EPI0_READFIFO1_R        (*((volatile unsigned long *)0x400D0074))
+#define EPI0_READFIFO2_R        (*((volatile unsigned long *)0x400D0078))
+#define EPI0_READFIFO3_R        (*((volatile unsigned long *)0x400D007C))
+#define EPI0_READFIFO4_R        (*((volatile unsigned long *)0x400D0080))
+#define EPI0_READFIFO5_R        (*((volatile unsigned long *)0x400D0084))
+#define EPI0_READFIFO6_R        (*((volatile unsigned long *)0x400D0088))
+#define EPI0_READFIFO7_R        (*((volatile unsigned long *)0x400D008C))
+#define EPI0_FIFOLVL_R          (*((volatile unsigned long *)0x400D0200))
+#define EPI0_WFIFOCNT_R         (*((volatile unsigned long *)0x400D0204))
+#define EPI0_IM_R               (*((volatile unsigned long *)0x400D0210))
+#define EPI0_RIS_R              (*((volatile unsigned long *)0x400D0214))
+#define EPI0_MIS_R              (*((volatile unsigned long *)0x400D0218))
+#define EPI0_EISC_R             (*((volatile unsigned long *)0x400D021C))
+
+//*****************************************************************************
+//
+// Internal Memory (FLASH)
+//
+//*****************************************************************************
+#define FLASH_FMA_R             (*((volatile unsigned long *)0x400FD000))
+#define FLASH_FMD_R             (*((volatile unsigned long *)0x400FD004))
+#define FLASH_FMC_R             (*((volatile unsigned long *)0x400FD008))
+#define FLASH_FCRIS_R           (*((volatile unsigned long *)0x400FD00C))
+#define FLASH_FCIM_R            (*((volatile unsigned long *)0x400FD010))
+#define FLASH_FCMISC_R          (*((volatile unsigned long *)0x400FD014))
+#define FLASH_FMC2_R            (*((volatile unsigned long *)0x400FD020))
+#define FLASH_FWBVAL_R          (*((volatile unsigned long *)0x400FD030))
+#define FLASH_FWBN_R            (*((volatile unsigned long *)0x400FD100))
+#define FLASH_RMCTL_R           (*((volatile unsigned long *)0x400FE0F0))
+#define FLASH_RMVER_R           (*((volatile unsigned long *)0x400FE0F4))
+#define FLASH_USERDBG_R         (*((volatile unsigned long *)0x400FE1D0))
+#define FLASH_USERREG0_R        (*((volatile unsigned long *)0x400FE1E0))
+#define FLASH_USERREG1_R        (*((volatile unsigned long *)0x400FE1E4))
+#define FLASH_USERREG2_R        (*((volatile unsigned long *)0x400FE1E8))
+#define FLASH_USERREG3_R        (*((volatile unsigned long *)0x400FE1EC))
+#define FLASH_FMPRE0_R          (*((volatile unsigned long *)0x400FE200))
+#define FLASH_FMPRE1_R          (*((volatile unsigned long *)0x400FE204))
+#define FLASH_FMPRE2_R          (*((volatile unsigned long *)0x400FE208))
+#define FLASH_FMPRE3_R          (*((volatile unsigned long *)0x400FE20C))
+#define FLASH_FMPPE0_R          (*((volatile unsigned long *)0x400FE400))
+#define FLASH_FMPPE1_R          (*((volatile unsigned long *)0x400FE404))
+#define FLASH_FMPPE2_R          (*((volatile unsigned long *)0x400FE408))
+#define FLASH_FMPPE3_R          (*((volatile unsigned long *)0x400FE40C))
+
+//*****************************************************************************
+//
+// System Control (SYSCTL)
+//
+//*****************************************************************************
+#define SYSCTL_DID0_R           (*((volatile unsigned long *)0x400FE000))
+#define SYSCTL_DID1_R           (*((volatile unsigned long *)0x400FE004))
+#define SYSCTL_DC0_R            (*((volatile unsigned long *)0x400FE008))
+#define SYSCTL_DC1_R            (*((volatile unsigned long *)0x400FE010))
+#define SYSCTL_DC2_R            (*((volatile unsigned long *)0x400FE014))
+#define SYSCTL_DC3_R            (*((volatile unsigned long *)0x400FE018))
+#define SYSCTL_DC4_R            (*((volatile unsigned long *)0x400FE01C))
+#define SYSCTL_DC5_R            (*((volatile unsigned long *)0x400FE020))
+#define SYSCTL_DC6_R            (*((volatile unsigned long *)0x400FE024))
+#define SYSCTL_DC7_R            (*((volatile unsigned long *)0x400FE028))
+#define SYSCTL_DC8_R            (*((volatile unsigned long *)0x400FE02C))
+#define SYSCTL_PBORCTL_R        (*((volatile unsigned long *)0x400FE030))
+#define SYSCTL_SRCR0_R          (*((volatile unsigned long *)0x400FE040))
+#define SYSCTL_SRCR1_R          (*((volatile unsigned long *)0x400FE044))
+#define SYSCTL_SRCR2_R          (*((volatile unsigned long *)0x400FE048))
+#define SYSCTL_RIS_R            (*((volatile unsigned long *)0x400FE050))
+#define SYSCTL_IMC_R            (*((volatile unsigned long *)0x400FE054))
+#define SYSCTL_MISC_R           (*((volatile unsigned long *)0x400FE058))
+#define SYSCTL_RESC_R           (*((volatile unsigned long *)0x400FE05C))
+#define SYSCTL_RCC_R            (*((volatile unsigned long *)0x400FE060))
+#define SYSCTL_PLLCFG_R         (*((volatile unsigned long *)0x400FE064))
+#define SYSCTL_GPIOHBCTL_R      (*((volatile unsigned long *)0x400FE06C))
+#define SYSCTL_RCC2_R           (*((volatile unsigned long *)0x400FE070))
+#define SYSCTL_MOSCCTL_R        (*((volatile unsigned long *)0x400FE07C))
+#define SYSCTL_RCGC0_R          (*((volatile unsigned long *)0x400FE100))
+#define SYSCTL_RCGC1_R          (*((volatile unsigned long *)0x400FE104))
+#define SYSCTL_RCGC2_R          (*((volatile unsigned long *)0x400FE108))
+#define SYSCTL_SCGC0_R          (*((volatile unsigned long *)0x400FE110))
+#define SYSCTL_SCGC1_R          (*((volatile unsigned long *)0x400FE114))
+#define SYSCTL_SCGC2_R          (*((volatile unsigned long *)0x400FE118))
+#define SYSCTL_DCGC0_R          (*((volatile unsigned long *)0x400FE120))
+#define SYSCTL_DCGC1_R          (*((volatile unsigned long *)0x400FE124))
+#define SYSCTL_DCGC2_R          (*((volatile unsigned long *)0x400FE128))
+#define SYSCTL_DSLPCLKCFG_R     (*((volatile unsigned long *)0x400FE144))
+#define SYSCTL_DSFLASHCFG_R     (*((volatile unsigned long *)0x400FE14C))
+#define SYSCTL_PIOSCCAL_R       (*((volatile unsigned long *)0x400FE150))
+#define SYSCTL_I2SMCLKCFG_R     (*((volatile unsigned long *)0x400FE170))
+#define SYSCTL_DC9_R            (*((volatile unsigned long *)0x400FE190))
+#define SYSCTL_NVMSTAT_R        (*((volatile unsigned long *)0x400FE1A0))
+
+//*****************************************************************************
+//
+// Micro Direct Memory Access (UDMA)
+//
+//*****************************************************************************
+#define UDMA_STAT_R             (*((volatile unsigned long *)0x400FF000))
+#define UDMA_CFG_R              (*((volatile unsigned long *)0x400FF004))
+#define UDMA_CTLBASE_R          (*((volatile unsigned long *)0x400FF008))
+#define UDMA_ALTBASE_R          (*((volatile unsigned long *)0x400FF00C))
+#define UDMA_WAITSTAT_R         (*((volatile unsigned long *)0x400FF010))
+#define UDMA_SWREQ_R            (*((volatile unsigned long *)0x400FF014))
+#define UDMA_USEBURSTSET_R      (*((volatile unsigned long *)0x400FF018))
+#define UDMA_USEBURSTCLR_R      (*((volatile unsigned long *)0x400FF01C))
+#define UDMA_REQMASKSET_R       (*((volatile unsigned long *)0x400FF020))
+#define UDMA_REQMASKCLR_R       (*((volatile unsigned long *)0x400FF024))
+#define UDMA_ENASET_R           (*((volatile unsigned long *)0x400FF028))
+#define UDMA_ENACLR_R           (*((volatile unsigned long *)0x400FF02C))
+#define UDMA_ALTSET_R           (*((volatile unsigned long *)0x400FF030))
+#define UDMA_ALTCLR_R           (*((volatile unsigned long *)0x400FF034))
+#define UDMA_PRIOSET_R          (*((volatile unsigned long *)0x400FF038))
+#define UDMA_PRIOCLR_R          (*((volatile unsigned long *)0x400FF03C))
+#define UDMA_ERRCLR_R           (*((volatile unsigned long *)0x400FF04C))
+#define UDMA_CHALT_R            (*((volatile unsigned long *)0x400FF500))
+#define UDMA_CHIS_R             (*((volatile unsigned long *)0x400FF504))
+
+//*****************************************************************************
+//
+// Micro Direct Memory Access (UDMA) Offsets
+//
+//*****************************************************************************
+#define UDMA_SRCENDP            0x0x00000000
+#define UDMA_DSTENDP            0x0x00000004
+#define UDMA_CHCTL              0x0x00000008
+
+//*****************************************************************************
+//
+// Nested Vectored Interrupt Ctrl (NVIC)
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_R         (*((volatile unsigned long *)0xE000E004))
+#define NVIC_ST_CTRL_R          (*((volatile unsigned long *)0xE000E010))
+#define NVIC_ST_RELOAD_R        (*((volatile unsigned long *)0xE000E014))
+#define NVIC_ST_CURRENT_R       (*((volatile unsigned long *)0xE000E018))
+#define NVIC_ST_CAL_R           (*((volatile unsigned long *)0xE000E01C))
+#define NVIC_EN0_R              (*((volatile unsigned long *)0xE000E100))
+#define NVIC_EN1_R              (*((volatile unsigned long *)0xE000E104))
+#define NVIC_DIS0_R             (*((volatile unsigned long *)0xE000E180))
+#define NVIC_DIS1_R             (*((volatile unsigned long *)0xE000E184))
+#define NVIC_PEND0_R            (*((volatile unsigned long *)0xE000E200))
+#define NVIC_PEND1_R            (*((volatile unsigned long *)0xE000E204))
+#define NVIC_UNPEND0_R          (*((volatile unsigned long *)0xE000E280))
+#define NVIC_UNPEND1_R          (*((volatile unsigned long *)0xE000E284))
+#define NVIC_ACTIVE0_R          (*((volatile unsigned long *)0xE000E300))
+#define NVIC_ACTIVE1_R          (*((volatile unsigned long *)0xE000E304))
+#define NVIC_PRI0_R             (*((volatile unsigned long *)0xE000E400))
+#define NVIC_PRI1_R             (*((volatile unsigned long *)0xE000E404))
+#define NVIC_PRI2_R             (*((volatile unsigned long *)0xE000E408))
+#define NVIC_PRI3_R             (*((volatile unsigned long *)0xE000E40C))
+#define NVIC_PRI4_R             (*((volatile unsigned long *)0xE000E410))
+#define NVIC_PRI5_R             (*((volatile unsigned long *)0xE000E414))
+#define NVIC_PRI6_R             (*((volatile unsigned long *)0xE000E418))
+#define NVIC_PRI7_R             (*((volatile unsigned long *)0xE000E41C))
+#define NVIC_PRI8_R             (*((volatile unsigned long *)0xE000E420))
+#define NVIC_PRI9_R             (*((volatile unsigned long *)0xE000E424))
+#define NVIC_PRI10_R            (*((volatile unsigned long *)0xE000E428))
+#define NVIC_PRI11_R            (*((volatile unsigned long *)0xE000E42C))
+#define NVIC_PRI12_R            (*((volatile unsigned long *)0xE000E430))
+#define NVIC_PRI13_R            (*((volatile unsigned long *)0xE000E434))
+#define NVIC_CPUID_R            (*((volatile unsigned long *)0xE000ED00))
+#define NVIC_INT_CTRL_R         (*((volatile unsigned long *)0xE000ED04))
+#define NVIC_VTABLE_R           (*((volatile unsigned long *)0xE000ED08))
+#define NVIC_APINT_R            (*((volatile unsigned long *)0xE000ED0C))
+#define NVIC_SYS_CTRL_R         (*((volatile unsigned long *)0xE000ED10))
+#define NVIC_CFG_CTRL_R         (*((volatile unsigned long *)0xE000ED14))
+#define NVIC_SYS_PRI1_R         (*((volatile unsigned long *)0xE000ED18))
+#define NVIC_SYS_PRI2_R         (*((volatile unsigned long *)0xE000ED1C))
+#define NVIC_SYS_PRI3_R         (*((volatile unsigned long *)0xE000ED20))
+#define NVIC_SYS_HND_CTRL_R     (*((volatile unsigned long *)0xE000ED24))
+#define NVIC_FAULT_STAT_R       (*((volatile unsigned long *)0xE000ED28))
+#define NVIC_HFAULT_STAT_R      (*((volatile unsigned long *)0xE000ED2C))
+#define NVIC_DEBUG_STAT_R       (*((volatile unsigned long *)0xE000ED30))
+#define NVIC_MM_ADDR_R          (*((volatile unsigned long *)0xE000ED34))
+#define NVIC_FAULT_ADDR_R       (*((volatile unsigned long *)0xE000ED38))
+#define NVIC_MPU_TYPE_R         (*((volatile unsigned long *)0xE000ED90))
+#define NVIC_MPU_CTRL_R         (*((volatile unsigned long *)0xE000ED94))
+#define NVIC_MPU_NUMBER_R       (*((volatile unsigned long *)0xE000ED98))
+#define NVIC_MPU_R              (*((volatile unsigned long *)0xE000ED9C))
+#define NVIC_MPU_ATTR_R         (*((volatile unsigned long *)0xE000EDA0))
+#define NVIC_DBG_CTRL_R         (*((volatile unsigned long *)0xE000EDF0))
+#define NVIC_DBG_XFER_R         (*((volatile unsigned long *)0xE000EDF4))
+#define NVIC_DBG_DATA_R         (*((volatile unsigned long *)0xE000EDF8))
+#define NVIC_DBG_INT_R          (*((volatile unsigned long *)0xE000EDFC))
+#define NVIC_SW_TRIG_R          (*((volatile unsigned long *)0xE000EF00))
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOAD register.
+//
+//*****************************************************************************
+#define WDT_LOAD_M              0xFFFFFFFF  // Watchdog Load Value.
+#define WDT_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_VALUE register.
+//
+//*****************************************************************************
+#define WDT_VALUE_M             0xFFFFFFFF  // Watchdog Value.
+#define WDT_VALUE_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_CTL register.
+//
+//*****************************************************************************
+#define WDT_CTL_WRC             0x80000000  // Write Complete.
+#define WDT_CTL_RESEN           0x00000002  // Watchdog Reset Enable.
+#define WDT_CTL_INTEN           0x00000001  // Watchdog Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_ICR register.
+//
+//*****************************************************************************
+#define WDT_ICR_M               0xFFFFFFFF  // Watchdog Interrupt Clear.
+#define WDT_ICR_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_RIS register.
+//
+//*****************************************************************************
+#define WDT_RIS_WDTRIS          0x00000001  // Watchdog Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_MIS register.
+//
+//*****************************************************************************
+#define WDT_MIS_WDTMIS          0x00000001  // Watchdog Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_TEST register.
+//
+//*****************************************************************************
+#define WDT_TEST_STALL          0x00000100  // Watchdog Stall Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the WDT_O_LOCK register.
+//
+//*****************************************************************************
+#define WDT_LOCK_M              0xFFFFFFFF  // Watchdog Lock.
+#define WDT_LOCK_UNLOCKED       0x00000000  // Unlocked
+#define WDT_LOCK_LOCKED         0x00000001  // Locked
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the GPIO_O_LOCK register.
+//
+//*****************************************************************************
+#define GPIO_LOCK_M             0xFFFFFFFF  // GPIO Lock.
+#define GPIO_LOCK_UNLOCKED      0x00000000  // The GPIOCR register is unlocked
+                                            // and may be modified.
+#define GPIO_LOCK_LOCKED        0x00000001  // The GPIOCR register is locked
+                                            // and may not be modified.
+#define GPIO_LOCK_KEY           0x4C4F434B  // Unlocks the GPIO_CR register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR0 register.
+//
+//*****************************************************************************
+#define SSI_CR0_SCR_M           0x0000FF00  // SSI Serial Clock Rate.
+#define SSI_CR0_SPH             0x00000080  // SSI Serial Clock Phase.
+#define SSI_CR0_SPO             0x00000040  // SSI Serial Clock Polarity.
+#define SSI_CR0_FRF_M           0x00000030  // SSI Frame Format Select.
+#define SSI_CR0_FRF_MOTO        0x00000000  // Freescale SPI Frame Format
+#define SSI_CR0_FRF_TI          0x00000010  // Texas Instruments Synchronous
+                                            // Serial Frame Format
+#define SSI_CR0_FRF_NMW         0x00000020  // MICROWIRE Frame Format
+#define SSI_CR0_DSS_M           0x0000000F  // SSI Data Size Select.
+#define SSI_CR0_DSS_4           0x00000003  // 4-bit data
+#define SSI_CR0_DSS_5           0x00000004  // 5-bit data
+#define SSI_CR0_DSS_6           0x00000005  // 6-bit data
+#define SSI_CR0_DSS_7           0x00000006  // 7-bit data
+#define SSI_CR0_DSS_8           0x00000007  // 8-bit data
+#define SSI_CR0_DSS_9           0x00000008  // 9-bit data
+#define SSI_CR0_DSS_10          0x00000009  // 10-bit data
+#define SSI_CR0_DSS_11          0x0000000A  // 11-bit data
+#define SSI_CR0_DSS_12          0x0000000B  // 12-bit data
+#define SSI_CR0_DSS_13          0x0000000C  // 13-bit data
+#define SSI_CR0_DSS_14          0x0000000D  // 14-bit data
+#define SSI_CR0_DSS_15          0x0000000E  // 15-bit data
+#define SSI_CR0_DSS_16          0x0000000F  // 16-bit data
+#define SSI_CR0_SCR_S           8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CR1 register.
+//
+//*****************************************************************************
+#define SSI_CR1_EOT             0x00000010  // End of Transmission.
+#define SSI_CR1_SOD             0x00000008  // SSI Slave Mode Output Disable.
+#define SSI_CR1_MS              0x00000004  // SSI Master/Slave Select.
+#define SSI_CR1_SSE             0x00000002  // SSI Synchronous Serial Port
+                                            // Enable.
+#define SSI_CR1_LBM             0x00000001  // SSI Loopback Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DR register.
+//
+//*****************************************************************************
+#define SSI_DR_DATA_M           0x0000FFFF  // SSI Receive/Transmit Data.
+#define SSI_DR_DATA_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_SR register.
+//
+//*****************************************************************************
+#define SSI_SR_BSY              0x00000010  // SSI Busy Bit.
+#define SSI_SR_RFF              0x00000008  // SSI Receive FIFO Full.
+#define SSI_SR_RNE              0x00000004  // SSI Receive FIFO Not Empty.
+#define SSI_SR_TNF              0x00000002  // SSI Transmit FIFO Not Full.
+#define SSI_SR_TFE              0x00000001  // SSI Transmit FIFO Empty.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_CPSR register.
+//
+//*****************************************************************************
+#define SSI_CPSR_CPSDVSR_M      0x000000FF  // SSI Clock Prescale Divisor.
+#define SSI_CPSR_CPSDVSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_IM register.
+//
+//*****************************************************************************
+#define SSI_IM_TXIM             0x00000008  // SSI Transmit FIFO Interrupt
+                                            // Mask.
+#define SSI_IM_RXIM             0x00000004  // SSI Receive FIFO Interrupt Mask.
+#define SSI_IM_RTIM             0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Mask.
+#define SSI_IM_RORIM            0x00000001  // SSI Receive Overrun Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_RIS register.
+//
+//*****************************************************************************
+#define SSI_RIS_TXRIS           0x00000008  // SSI Transmit FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RXRIS           0x00000004  // SSI Receive FIFO Raw Interrupt
+                                            // Status.
+#define SSI_RIS_RTRIS           0x00000002  // SSI Receive Time-Out Raw
+                                            // Interrupt Status.
+#define SSI_RIS_RORRIS          0x00000001  // SSI Receive Overrun Raw
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_MIS register.
+//
+//*****************************************************************************
+#define SSI_MIS_TXMIS           0x00000008  // SSI Transmit FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RXMIS           0x00000004  // SSI Receive FIFO Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RTMIS           0x00000002  // SSI Receive Time-Out Masked
+                                            // Interrupt Status.
+#define SSI_MIS_RORMIS          0x00000001  // SSI Receive Overrun Masked
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_ICR register.
+//
+//*****************************************************************************
+#define SSI_ICR_RTIC            0x00000002  // SSI Receive Time-Out Interrupt
+                                            // Clear.
+#define SSI_ICR_RORIC           0x00000001  // SSI Receive Overrun Interrupt
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SSI_O_DMACTL register.
+//
+//*****************************************************************************
+#define SSI_DMACTL_TXDMAE       0x00000002  // Transmit DMA Enable.
+#define SSI_DMACTL_RXDMAE       0x00000001  // Receive DMA Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DR register.
+//
+//*****************************************************************************
+#define UART_DR_OE              0x00000800  // UART Overrun Error.
+#define UART_DR_BE              0x00000400  // UART Break Error.
+#define UART_DR_PE              0x00000200  // UART Parity Error.
+#define UART_DR_FE              0x00000100  // UART Framing Error.
+#define UART_DR_DATA_M          0x000000FF  // Data Transmitted or Received.
+#define UART_DR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RSR register.
+//
+//*****************************************************************************
+#define UART_RSR_OE             0x00000008  // UART Overrun Error.
+#define UART_RSR_BE             0x00000004  // UART Break Error.
+#define UART_RSR_PE             0x00000002  // UART Parity Error.
+#define UART_RSR_FE             0x00000001  // UART Framing Error.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ECR register.
+//
+//*****************************************************************************
+#define UART_ECR_DATA_M         0x000000FF  // Error Clear.
+#define UART_ECR_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FR register.
+//
+//*****************************************************************************
+#define UART_FR_RI              0x00000100  // Ring Indicator.
+#define UART_FR_TXFE            0x00000080  // UART Transmit FIFO Empty.
+#define UART_FR_RXFF            0x00000040  // UART Receive FIFO Full.
+#define UART_FR_TXFF            0x00000020  // UART Transmit FIFO Full.
+#define UART_FR_RXFE            0x00000010  // UART Receive FIFO Empty.
+#define UART_FR_BUSY            0x00000008  // UART Busy.
+#define UART_FR_DCD             0x00000004  // Data Carrier Detect.
+#define UART_FR_DSR             0x00000002  // Data Set Ready.
+#define UART_FR_CTS             0x00000001  // Clear To Send.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ILPR register.
+//
+//*****************************************************************************
+#define UART_ILPR_ILPDVSR_M     0x000000FF  // IrDA Low-Power Divisor.
+#define UART_ILPR_ILPDVSR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IBRD register.
+//
+//*****************************************************************************
+#define UART_IBRD_DIVINT_M      0x0000FFFF  // Integer Baud-Rate Divisor.
+#define UART_IBRD_DIVINT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_FBRD register.
+//
+//*****************************************************************************
+#define UART_FBRD_DIVFRAC_M     0x0000003F  // Fractional Baud-Rate Divisor.
+#define UART_FBRD_DIVFRAC_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCRH register.
+//
+//*****************************************************************************
+#define UART_LCRH_SPS           0x00000080  // UART Stick Parity Select.
+#define UART_LCRH_WLEN_M        0x00000060  // UART Word Length.
+#define UART_LCRH_WLEN_5        0x00000000  // 5 bits (default)
+#define UART_LCRH_WLEN_6        0x00000020  // 6 bits
+#define UART_LCRH_WLEN_7        0x00000040  // 7 bits
+#define UART_LCRH_WLEN_8        0x00000060  // 8 bits
+#define UART_LCRH_FEN           0x00000010  // UART Enable FIFOs.
+#define UART_LCRH_STP2          0x00000008  // UART Two Stop Bits Select.
+#define UART_LCRH_EPS           0x00000004  // UART Even Parity Select.
+#define UART_LCRH_PEN           0x00000002  // UART Parity Enable.
+#define UART_LCRH_BRK           0x00000001  // UART Send Break.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_CTL register.
+//
+//*****************************************************************************
+#define UART_CTL_CTSEN          0x00008000  // Enable Clear To Send.
+#define UART_CTL_RTSEN          0x00004000  // Enable Request to Send.
+#define UART_CTL_RTS            0x00000800  // Request to Send.
+#define UART_CTL_DTR            0x00000400  // Data Terminal Ready.
+#define UART_CTL_RXE            0x00000200  // UART Receive Enable.
+#define UART_CTL_TXE            0x00000100  // UART Transmit Enable.
+#define UART_CTL_LBE            0x00000080  // UART Loop Back Enable.
+#define UART_CTL_LIN            0x00000040  // LIN Mode Enable.
+#define UART_CTL_HSE            0x00000020  // High-Speed Enable.
+#define UART_CTL_EOT            0x00000010  // End of Transmission.
+#define UART_CTL_SMART          0x00000008  // ISO 7816 Smart Card Support.
+#define UART_CTL_SIRLP          0x00000004  // UART SIR Low Power Mode.
+#define UART_CTL_SIREN          0x00000002  // UART SIR Enable.
+#define UART_CTL_UARTEN         0x00000001  // UART Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IFLS register.
+//
+//*****************************************************************************
+#define UART_IFLS_RX_M          0x00000038  // UART Receive Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_RX1_8         0x00000000  // RX FIFO &lt;= 1/8 full
+#define UART_IFLS_RX2_8         0x00000008  // RX FIFO &lt;= 1/4 full
+#define UART_IFLS_RX4_8         0x00000010  // RX FIFO &lt;= 1/2 full (default)
+#define UART_IFLS_RX6_8         0x00000018  // RX FIFO &lt;= 3/4 full
+#define UART_IFLS_RX7_8         0x00000020  // RX FIFO &lt;= 7/8 full
+#define UART_IFLS_TX_M          0x00000007  // UART Transmit Interrupt FIFO
+                                            // Level Select.
+#define UART_IFLS_TX1_8         0x00000000  // TX FIFO &gt;= 1/8 full
+#define UART_IFLS_TX2_8         0x00000001  // TX FIFO &gt;= 1/4 full
+#define UART_IFLS_TX4_8         0x00000002  // TX FIFO &gt;= 1/2 full (default)
+#define UART_IFLS_TX6_8         0x00000003  // TX FIFO &gt;= 3/4 full
+#define UART_IFLS_TX7_8         0x00000004  // TX FIFO &gt;= 7/8 full
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_IM register.
+//
+//*****************************************************************************
+#define UART_IM_LME5IM          0x00008000  // LIN Mode Edge 5 Interrupt Mask.
+#define UART_IM_LME1IM          0x00004000  // LIN Mode Edge 1 Interrupt Mask.
+#define UART_IM_LMSBIM          0x00002000  // LIN Mode Sync Break Interrupt
+                                            // Mask.
+#define UART_IM_OEIM            0x00000400  // UART Overrun Error Interrupt
+                                            // Mask.
+#define UART_IM_BEIM            0x00000200  // UART Break Error Interrupt Mask.
+#define UART_IM_PEIM            0x00000100  // UART Parity Error Interrupt
+                                            // Mask.
+#define UART_IM_FEIM            0x00000080  // UART Framing Error Interrupt
+                                            // Mask.
+#define UART_IM_RTIM            0x00000040  // UART Receive Time-Out Interrupt
+                                            // Mask.
+#define UART_IM_TXIM            0x00000020  // UART Transmit Interrupt Mask.
+#define UART_IM_RXIM            0x00000010  // UART Receive Interrupt Mask.
+#define UART_IM_DSRMIM          0x00000008  // UART Data Set Ready Modem
+                                            // Interrupt Mask.
+#define UART_IM_DCDMIM          0x00000004  // UART Data Carrier Detect Modem
+                                            // Interrupt Mask.
+#define UART_IM_CTSMIM          0x00000002  // UART Clear to Send Modem
+                                            // Interrupt Mask.
+#define UART_IM_RIMIM           0x00000001  // UART Ring Indicator Modem
+                                            // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_RIS register.
+//
+//*****************************************************************************
+#define UART_RIS_LME5RIS        0x00008000  // LIN Mode Edge 5 Raw Interrupt
+                                            // Status.
+#define UART_RIS_LME1RIS        0x00004000  // LIN Mode Edge 1 Raw Interrupt
+                                            // Status.
+#define UART_RIS_LMSBRIS        0x00002000  // LIN Mode Sync Break Raw
+                                            // Interrupt Status.
+#define UART_RIS_OERIS          0x00000400  // UART Overrun Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_BERIS          0x00000200  // UART Break Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_PERIS          0x00000100  // UART Parity Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_FERIS          0x00000080  // UART Framing Error Raw Interrupt
+                                            // Status.
+#define UART_RIS_RTRIS          0x00000040  // UART Receive Time-Out Raw
+                                            // Interrupt Status.
+#define UART_RIS_TXRIS          0x00000020  // UART Transmit Raw Interrupt
+                                            // Status.
+#define UART_RIS_RXRIS          0x00000010  // UART Receive Raw Interrupt
+                                            // Status.
+#define UART_RIS_DSRRIS         0x00000008  // UART Data Set Ready Modem Raw
+                                            // Interrupt Status.
+#define UART_RIS_DCDRIS         0x00000004  // UART Data Carrier Detect odem
+                                            // Raw Interrupt Status.
+#define UART_RIS_CTSRIS         0x00000002  // UART Clear to Send Modem Raw
+                                            // Interrupt Status.
+#define UART_RIS_RIRIS          0x00000001  // UART Ring Indicator Modem Raw
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_MIS register.
+//
+//*****************************************************************************
+#define UART_MIS_LME5MIS        0x00008000  // LIN Mode Edge 5 Masked Interrupt
+                                            // Status.
+#define UART_MIS_LME1MIS        0x00004000  // LIN Mode Edge 1 Masked Interrupt
+                                            // Status.
+#define UART_MIS_LMSBMIS        0x00002000  // LIN Mode Sync Break Masked
+                                            // Interrupt Status.
+#define UART_MIS_OEMIS          0x00000400  // UART Overrun Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_BEMIS          0x00000200  // UART Break Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_PEMIS          0x00000100  // UART Parity Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_FEMIS          0x00000080  // UART Framing Error Masked
+                                            // Interrupt Status.
+#define UART_MIS_RTMIS          0x00000040  // UART Receive Time-Out Masked
+                                            // Interrupt Status.
+#define UART_MIS_TXMIS          0x00000020  // UART Transmit Masked Interrupt
+                                            // Status.
+#define UART_MIS_RXMIS          0x00000010  // UART Receive Masked Interrupt
+                                            // Status.
+#define UART_MIS_DSRMIS         0x00000008  // UART Data Set Ready Modem Masked
+                                            // Interrupt Status.
+#define UART_MIS_DCDMIS         0x00000004  // UART Data Carrier Detect odem
+                                            // Masked Interrupt Status.
+#define UART_MIS_CTSMIS         0x00000002  // UART Clear to Send Modem Masked
+                                            // Interrupt Status.
+#define UART_MIS_RIMIS          0x00000001  // UART Ring Indicator Modem Masked
+                                            // Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_ICR register.
+//
+//*****************************************************************************
+#define UART_ICR_LME5MIC        0x00008000  // LIN Mode Edge 5 Interrupt Clear.
+#define UART_ICR_LME1MIC        0x00004000  // LIN Mode Edge 1 Interrupt Clear.
+#define UART_ICR_LMSBMIC        0x00002000  // LIN Mode Sync Break Interrupt
+                                            // Clear.
+#define UART_ICR_OEIC           0x00000400  // Overrun Error Interrupt Clear.
+#define UART_ICR_BEIC           0x00000200  // Break Error Interrupt Clear.
+#define UART_ICR_PEIC           0x00000100  // Parity Error Interrupt Clear.
+#define UART_ICR_FEIC           0x00000080  // Framing Error Interrupt Clear.
+#define UART_ICR_RTIC           0x00000040  // Receive Time-Out Interrupt
+                                            // Clear.
+#define UART_ICR_TXIC           0x00000020  // Transmit Interrupt Clear.
+#define UART_ICR_RXIC           0x00000010  // Receive Interrupt Clear.
+#define UART_ICR_DSRMIC         0x00000008  // UART Data Set Ready Modem
+                                            // Interrupt Clear.
+#define UART_ICR_DCDMIC         0x00000004  // UART Data Carrier Detect odem
+                                            // Interrupt Clear.
+#define UART_ICR_CTSMIC         0x00000002  // UART Clear to Send Modem
+                                            // Interrupt Clear.
+#define UART_ICR_RIMIC          0x00000001  // UART Ring Indicator Modem
+                                            // Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_DMACTL register.
+//
+//*****************************************************************************
+#define UART_DMACTL_DMAERR      0x00000004  // DMA on Error.
+#define UART_DMACTL_TXDMAE      0x00000002  // Transmit DMA Enable.
+#define UART_DMACTL_RXDMAE      0x00000001  // Receive DMA Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LCTL register.
+//
+//*****************************************************************************
+#define UART_LCTL_BLEN_M        0x00000030  // Sync Break Length.
+#define UART_LCTL_BLEN_13T      0x00000000  // Sync break length is 13T bits
+                                            // (default)
+#define UART_LCTL_BLEN_14T      0x00000010  // Sync break length is 14T bits
+#define UART_LCTL_BLEN_15T      0x00000020  // Sync break length is 15T bits
+#define UART_LCTL_BLEN_16T      0x00000030  // Sync break length is 16T bits
+#define UART_LCTL_MASTER        0x00000001  // LIN Master Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LSS register.
+//
+//*****************************************************************************
+#define UART_LSS_TSS_M          0x0000FFFF  // Timer Snap Shot.
+#define UART_LSS_TSS_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UART_O_LTIM register.
+//
+//*****************************************************************************
+#define UART_LTIM_TIMER_M       0x0000FFFF  // Timer Value.
+#define UART_LTIM_TIMER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MSA register.
+//
+//*****************************************************************************
+#define I2C_MSA_SA_M            0x000000FE  // I2C Slave Address.
+#define I2C_MSA_RS              0x00000001  // Receive not send.
+#define I2C_MSA_SA_S            1
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SOAR register.
+//
+//*****************************************************************************
+#define I2C_SOAR_OAR_M          0x0000007F  // I2C Slave Own Address.
+#define I2C_SOAR_OAR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SCSR register.
+//
+//*****************************************************************************
+#define I2C_SCSR_FBR            0x00000004  // First Byte Received.
+#define I2C_SCSR_TREQ           0x00000002  // Transmit Request.
+#define I2C_SCSR_DA             0x00000001  // Device Active.
+#define I2C_SCSR_RREQ           0x00000001  // Receive Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCS register.
+//
+//*****************************************************************************
+#define I2C_MCS_BUSBSY          0x00000040  // Bus Busy.
+#define I2C_MCS_IDLE            0x00000020  // I2C Idle.
+#define I2C_MCS_ARBLST          0x00000010  // Arbitration Lost.
+#define I2C_MCS_ACK             0x00000008  // Data Acknowledge Enable.
+#define I2C_MCS_DATACK          0x00000008  // Acknowledge Data.
+#define I2C_MCS_ADRACK          0x00000004  // Acknowledge Address.
+#define I2C_MCS_STOP            0x00000004  // Generate STOP.
+#define I2C_MCS_START           0x00000002  // Generate START.
+#define I2C_MCS_ERROR           0x00000002  // Error.
+#define I2C_MCS_RUN             0x00000001  // I2C Master Enable.
+#define I2C_MCS_BUSY            0x00000001  // I2C Busy.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SDR register.
+//
+//*****************************************************************************
+#define I2C_SDR_DATA_M          0x000000FF  // Data for Transfer.
+#define I2C_SDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MDR register.
+//
+//*****************************************************************************
+#define I2C_MDR_DATA_M          0x000000FF  // Data Transferred.
+#define I2C_MDR_DATA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MTPR register.
+//
+//*****************************************************************************
+#define I2C_MTPR_TPR_M          0x000000FF  // SCL Clock Period.
+#define I2C_MTPR_TPR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SIMR register.
+//
+//*****************************************************************************
+#define I2C_SIMR_STOPIM         0x00000004  // Stop Condition Interrupt Mask.
+#define I2C_SIMR_STARTIM        0x00000002  // Start Condition Interrupt Mask.
+#define I2C_SIMR_DATAIM         0x00000001  // Data Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SRIS register.
+//
+//*****************************************************************************
+#define I2C_SRIS_STOPRIS        0x00000004  // Stop Condition Raw Interrupt
+                                            // Status.
+#define I2C_SRIS_STARTRIS       0x00000002  // Start Condition Raw Interrupt
+                                            // Status.
+#define I2C_SRIS_DATARIS        0x00000001  // Data Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MIMR register.
+//
+//*****************************************************************************
+#define I2C_MIMR_IM             0x00000001  // Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MRIS register.
+//
+//*****************************************************************************
+#define I2C_MRIS_RIS            0x00000001  // Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SMIS register.
+//
+//*****************************************************************************
+#define I2C_SMIS_STOPMIS        0x00000004  // Stop Condition Masked Interrupt
+                                            // Status.
+#define I2C_SMIS_STARTMIS       0x00000002  // Start Condition Masked Interrupt
+                                            // Status.
+#define I2C_SMIS_DATAMIS        0x00000001  // Data Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_SICR register.
+//
+//*****************************************************************************
+#define I2C_SICR_STOPIC         0x00000004  // Stop Condition Interrupt Clear.
+#define I2C_SICR_STARTIC        0x00000002  // Start Condition Interrupt Clear.
+#define I2C_SICR_DATAIC         0x00000001  // Data Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MMIS register.
+//
+//*****************************************************************************
+#define I2C_MMIS_MIS            0x00000001  // Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MICR register.
+//
+//*****************************************************************************
+#define I2C_MICR_IC             0x00000001  // Interrupt Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2C_O_MCR register.
+//
+//*****************************************************************************
+#define I2C_MCR_SFE             0x00000020  // I2C Slave Function Enable.
+#define I2C_MCR_MFE             0x00000010  // I2C Master Function Enable.
+#define I2C_MCR_LPBK            0x00000001  // I2C Loopback.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_CTL register.
+//
+//*****************************************************************************
+#define PWM_CTL_GLOBALSYNC3     0x00000008  // Update PWM Generator 3.
+#define PWM_CTL_GLOBALSYNC2     0x00000004  // Update PWM Generator 2.
+#define PWM_CTL_GLOBALSYNC1     0x00000002  // Update PWM Generator 1.
+#define PWM_CTL_GLOBALSYNC0     0x00000001  // Update PWM Generator 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_SYNC register.
+//
+//*****************************************************************************
+#define PWM_SYNC_SYNC3          0x00000008  // Reset Generator 3 Counter.
+#define PWM_SYNC_SYNC2          0x00000004  // Reset Generator 2 Counter.
+#define PWM_SYNC_SYNC1          0x00000002  // Reset Generator 1 Counter.
+#define PWM_SYNC_SYNC0          0x00000001  // Reset Generator 0 Counter.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ENABLE register.
+//
+//*****************************************************************************
+#define PWM_ENABLE_PWM7EN       0x00000080  // PWM7 Output Enable.
+#define PWM_ENABLE_PWM6EN       0x00000040  // PWM6 Output Enable.
+#define PWM_ENABLE_PWM5EN       0x00000020  // PWM5 Output Enable.
+#define PWM_ENABLE_PWM4EN       0x00000010  // PWM4 Output Enable.
+#define PWM_ENABLE_PWM3EN       0x00000008  // PWM3 Output Enable.
+#define PWM_ENABLE_PWM2EN       0x00000004  // PWM2 Output Enable.
+#define PWM_ENABLE_PWM1EN       0x00000002  // PWM1 Output Enable.
+#define PWM_ENABLE_PWM0EN       0x00000001  // PWM0 Output Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INVERT register.
+//
+//*****************************************************************************
+#define PWM_INVERT_PWM7INV      0x00000080  // Invert PWM7 Signal.
+#define PWM_INVERT_PWM6INV      0x00000040  // Invert PWM6 Signal.
+#define PWM_INVERT_PWM5INV      0x00000020  // Invert PWM5 Signal.
+#define PWM_INVERT_PWM4INV      0x00000010  // Invert PWM4 Signal.
+#define PWM_INVERT_PWM3INV      0x00000008  // Invert PWM3 Signal.
+#define PWM_INVERT_PWM2INV      0x00000004  // Invert PWM2 Signal.
+#define PWM_INVERT_PWM1INV      0x00000002  // Invert PWM1 Signal.
+#define PWM_INVERT_PWM0INV      0x00000001  // Invert PWM0 Signal.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_FAULT register.
+//
+//*****************************************************************************
+#define PWM_FAULT_FAULT7        0x00000080  // PWM7 Fault.
+#define PWM_FAULT_FAULT6        0x00000040  // PWM6 Fault.
+#define PWM_FAULT_FAULT5        0x00000020  // PWM5 Fault.
+#define PWM_FAULT_FAULT4        0x00000010  // PWM4 Fault.
+#define PWM_FAULT_FAULT3        0x00000008  // PWM3 Fault.
+#define PWM_FAULT_FAULT2        0x00000004  // PWM2 Fault.
+#define PWM_FAULT_FAULT1        0x00000002  // PWM1 Fault.
+#define PWM_FAULT_FAULT0        0x00000001  // PWM0 Fault.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_INTEN register.
+//
+//*****************************************************************************
+#define PWM_INTEN_INTFAULT3     0x00080000  // Interrupt Fault 3.
+#define PWM_INTEN_INTFAULT2     0x00040000  // Interrupt Fault 2.
+#define PWM_INTEN_INTFAULT1     0x00020000  // Interrupt Fault 1.
+#define PWM_INTEN_INTFAULT0     0x00010000  // Interrupt Fault 0.
+#define PWM_INTEN_INTPWM3       0x00000008  // PWM3 Interrupt Enable.
+#define PWM_INTEN_INTPWM2       0x00000004  // PWM2 Interrupt Enable.
+#define PWM_INTEN_INTPWM1       0x00000002  // PWM1 Interrupt Enable.
+#define PWM_INTEN_INTPWM0       0x00000001  // PWM0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_RIS register.
+//
+//*****************************************************************************
+#define PWM_RIS_INTFAULT3       0x00080000  // Interrupt Fault PWM 3.
+#define PWM_RIS_INTFAULT2       0x00040000  // Interrupt Fault PWM 2.
+#define PWM_RIS_INTFAULT1       0x00020000  // Interrupt Fault PWM 1.
+#define PWM_RIS_INTFAULT0       0x00010000  // Interrupt Fault PWM 0.
+#define PWM_RIS_INTPWM3         0x00000008  // PWM3 Interrupt Asserted.
+#define PWM_RIS_INTPWM2         0x00000004  // PWM2 Interrupt Asserted.
+#define PWM_RIS_INTPWM1         0x00000002  // PWM1 Interrupt Asserted.
+#define PWM_RIS_INTPWM0         0x00000001  // PWM0 Interrupt Asserted.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_ISC register.
+//
+//*****************************************************************************
+#define PWM_ISC_INTFAULT3       0x00080000  // FAULT3 Interrupt Asserted.
+#define PWM_ISC_INTFAULT2       0x00040000  // FAULT2 Interrupt Asserted.
+#define PWM_ISC_INTFAULT1       0x00020000  // FAULT1 Interrupt Asserted.
+#define PWM_ISC_INTFAULT0       0x00010000  // FAULT0 Interrupt Asserted.
+#define PWM_ISC_INTPWM3         0x00000008  // PWM3 Interrupt Status.
+#define PWM_ISC_INTPWM2         0x00000004  // PWM2 Interrupt Status.
+#define PWM_ISC_INTPWM1         0x00000002  // PWM1 Interrupt Status.
+#define PWM_ISC_INTPWM0         0x00000001  // PWM0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_STATUS register.
+//
+//*****************************************************************************
+#define PWM_STATUS_FAULT3       0x00000008  // Fault3 Interrupt Status.
+#define PWM_STATUS_FAULT2       0x00000004  // Fault2 Interrupt Status.
+#define PWM_STATUS_FAULT1       0x00000002  // Fault1 Interrupt Status.
+#define PWM_STATUS_FAULT0       0x00000001  // Fault0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_FAULTVAL register.
+//
+//*****************************************************************************
+#define PWM_FAULTVAL_PWM7       0x00000080  // PWM7 Fault Value.
+#define PWM_FAULTVAL_PWM6       0x00000040  // PWM6 Fault Value.
+#define PWM_FAULTVAL_PWM5       0x00000020  // PWM5 Fault Value.
+#define PWM_FAULTVAL_PWM4       0x00000010  // PWM4 Fault Value.
+#define PWM_FAULTVAL_PWM3       0x00000008  // PWM3 Fault Value.
+#define PWM_FAULTVAL_PWM2       0x00000004  // PWM2 Fault Value.
+#define PWM_FAULTVAL_PWM1       0x00000002  // PWM1 Fault Value.
+#define PWM_FAULTVAL_PWM0       0x00000001  // PWM0 Fault Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CTL,
+// PWM_O_1_CTL, PWM_O_2_CTL, and PWM_O_3_CTL registers.
+//
+//*****************************************************************************
+#define PWM_X_CTL_LATCH         0x00040000  // Latch Fault Input.
+#define PWM_X_CTL_MINFLTPER     0x00020000  // Minimum Fault Period.
+#define PWM_X_CTL_FLTSRC        0x00010000  // Fault Condition Source.
+#define PWM_X_CTL_DBFALLUPD_M   0x0000C000  // Specifies the update mode for
+                                            // the PWMnDBFALL register.
+#define PWM_X_CTL_DBFALLUPD_I   0x00000000  // Immediate
+#define PWM_X_CTL_DBFALLUPD_LS  0x00008000  // Locally Synchronized
+#define PWM_X_CTL_DBFALLUPD_GS  0x0000C000  // Globally Synchronized
+#define PWM_X_CTL_DBRISEUPD_M   0x00003000  // PWMnDBRISE Update Mode.
+#define PWM_X_CTL_DBRISEUPD_I   0x00000000  // Immediate
+#define PWM_X_CTL_DBRISEUPD_LS  0x00002000  // Locally Synchronized
+#define PWM_X_CTL_DBRISEUPD_GS  0x00003000  // Globally Synchronized
+#define PWM_X_CTL_DBCTLUPD_M    0x00000C00  // PWMnDBCTL Update Mode.
+#define PWM_X_CTL_DBCTLUPD_I    0x00000000  // Immediate
+#define PWM_X_CTL_DBCTLUPD_LS   0x00000800  // Locally Synchronized
+#define PWM_X_CTL_DBCTLUPD_GS   0x00000C00  // Globally Synchronized
+#define PWM_X_CTL_GENBUPD_M     0x00000300  // PWMnGENB Update Mode.
+#define PWM_X_CTL_GENBUPD_I     0x00000000  // Immediate
+#define PWM_X_CTL_GENBUPD_LS    0x00000200  // Locally Synchronized
+#define PWM_X_CTL_GENBUPD_GS    0x00000300  // Globally Synchronized
+#define PWM_X_CTL_GENAUPD_M     0x000000C0  // PWMnGENA Update Mode.
+#define PWM_X_CTL_GENAUPD_I     0x00000000  // Immediate
+#define PWM_X_CTL_GENAUPD_LS    0x00000080  // Locally Synchronized
+#define PWM_X_CTL_GENAUPD_GS    0x000000C0  // Globally Synchronized
+#define PWM_X_CTL_CMPBUPD       0x00000020  // Comparator B Update Mode.
+#define PWM_X_CTL_CMPAUPD       0x00000010  // Comparator A Update Mode.
+#define PWM_X_CTL_LOADUPD       0x00000008  // Load Register Update Mode.
+#define PWM_X_CTL_DEBUG         0x00000004  // Debug Mode.
+#define PWM_X_CTL_MODE          0x00000002  // Counter Mode.
+#define PWM_X_CTL_ENABLE        0x00000001  // PWM Block Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_INTEN,
+// PWM_O_1_INTEN, PWM_O_2_INTEN, and PWM_O_3_INTEN registers.
+//
+//*****************************************************************************
+#define PWM_X_INTEN_TRCMPBD     0x00002000  // Trigger for Counter=Comparator B
+                                            // Down.
+#define PWM_X_INTEN_TRCMPBU     0x00001000  // Trigger for Counter=Comparator B
+                                            // Up.
+#define PWM_X_INTEN_TRCMPAD     0x00000800  // Trigger for Counter=Comparator A
+                                            // Down.
+#define PWM_X_INTEN_TRCMPAU     0x00000400  // Trigger for Counter=Comparator A
+                                            // Up.
+#define PWM_X_INTEN_TRCNTLOAD   0x00000200  // Trigger for Counter=Load.
+#define PWM_X_INTEN_TRCNTZERO   0x00000100  // Trigger for Counter=0.
+#define PWM_X_INTEN_INTCMPBD    0x00000020  // Interrupt for Counter=Comparator
+                                            // B Down.
+#define PWM_X_INTEN_INTCMPBU    0x00000010  // Interrupt for Counter=Comparator
+                                            // B Up.
+#define PWM_X_INTEN_INTCMPAD    0x00000008  // Interrupt for Counter=Comparator
+                                            // A Down.
+#define PWM_X_INTEN_INTCMPAU    0x00000004  // Interrupt for Counter=Comparator
+                                            // A Up.
+#define PWM_X_INTEN_INTCNTLOAD  0x00000002  // Interrupt for Counter=Load.
+#define PWM_X_INTEN_INTCNTZERO  0x00000001  // Interrupt for Counter=0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_RIS,
+// PWM_O_1_RIS, PWM_O_2_RIS, and PWM_O_3_RIS registers.
+//
+//*****************************************************************************
+#define PWM_X_RIS_INTCMPBD      0x00000020  // Comparator B Down Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPBU      0x00000010  // Comparator B Up Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPAD      0x00000008  // Comparator A Down Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCMPAU      0x00000004  // Comparator A Up Interrupt
+                                            // Status.
+#define PWM_X_RIS_INTCNTLOAD    0x00000002  // Counter=Load Interrupt Status.
+#define PWM_X_RIS_INTCNTZERO    0x00000001  // Counter=0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_ISC,
+// PWM_O_1_ISC, PWM_O_2_ISC, and PWM_O_3_ISC registers.
+//
+//*****************************************************************************
+#define PWM_X_ISC_INTCMPBD      0x00000020  // Comparator B Down Interrupt.
+#define PWM_X_ISC_INTCMPBU      0x00000010  // Comparator B Up Interrupt.
+#define PWM_X_ISC_INTCMPAD      0x00000008  // Comparator A Down Interrupt.
+#define PWM_X_ISC_INTCMPAU      0x00000004  // Comparator A Up Interrupt.
+#define PWM_X_ISC_INTCNTLOAD    0x00000002  // Counter=Load Interrupt.
+#define PWM_X_ISC_INTCNTZERO    0x00000001  // Counter=0 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_LOAD,
+// PWM_O_1_LOAD, PWM_O_2_LOAD, and PWM_O_3_LOAD registers.
+//
+//*****************************************************************************
+#define PWM_X_LOAD_M            0x0000FFFF  // Counter Load Value.
+#define PWM_X_LOAD_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_COUNT,
+// PWM_O_1_COUNT, PWM_O_2_COUNT, and PWM_O_3_COUNT registers.
+//
+//*****************************************************************************
+#define PWM_X_COUNT_M           0x0000FFFF  // Counter Value.
+#define PWM_X_COUNT_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPA,
+// PWM_O_1_CMPA, PWM_O_2_CMPA, and PWM_O_3_CMPA registers.
+//
+//*****************************************************************************
+#define PWM_X_CMPA_M            0x0000FFFF  // Comparator A Value.
+#define PWM_X_CMPA_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_CMPB,
+// PWM_O_1_CMPB, PWM_O_2_CMPB, and PWM_O_3_CMPB registers.
+//
+//*****************************************************************************
+#define PWM_X_CMPB_M            0x0000FFFF  // Comparator B Value.
+#define PWM_X_CMPB_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENA,
+// PWM_O_1_GENA, PWM_O_2_GENA, and PWM_O_3_GENA registers.
+//
+//*****************************************************************************
+#define PWM_X_GENA_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENA_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENA_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENA_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENA_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENA_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENA_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENA_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENA_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENA_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENA_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENA_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENA_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENA_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENA_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENA_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENA_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_GENB,
+// PWM_O_1_GENB, PWM_O_2_GENB, and PWM_O_3_GENB registers.
+//
+//*****************************************************************************
+#define PWM_X_GENB_ACTCMPBD_M   0x00000C00  // Action for Comparator B Down.
+#define PWM_X_GENB_ACTCMPBD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBD_INV 0x00000400  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBD_ZERO \
+                                0x00000800  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBD_ONE 0x00000C00  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPBU_M   0x00000300  // Action for Comparator B Up.
+#define PWM_X_GENB_ACTCMPBU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPBU_INV 0x00000100  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPBU_ZERO \
+                                0x00000200  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPBU_ONE 0x00000300  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAD_M   0x000000C0  // Action for Comparator A Down.
+#define PWM_X_GENB_ACTCMPAD_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAD_INV 0x00000040  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAD_ZERO \
+                                0x00000080  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAD_ONE 0x000000C0  // Set the output signal to 1.
+#define PWM_X_GENB_ACTCMPAU_M   0x00000030  // Action for Comparator A Up.
+#define PWM_X_GENB_ACTCMPAU_NONE \
+                                0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTCMPAU_INV 0x00000010  // Invert the output signal.
+#define PWM_X_GENB_ACTCMPAU_ZERO \
+                                0x00000020  // Set the output signal to 0.
+#define PWM_X_GENB_ACTCMPAU_ONE 0x00000030  // Set the output signal to 1.
+#define PWM_X_GENB_ACTLOAD_M    0x0000000C  // Action for Counter=Load.
+#define PWM_X_GENB_ACTLOAD_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTLOAD_INV  0x00000004  // Invert the output signal.
+#define PWM_X_GENB_ACTLOAD_ZERO 0x00000008  // Set the output signal to 0.
+#define PWM_X_GENB_ACTLOAD_ONE  0x0000000C  // Set the output signal to 1.
+#define PWM_X_GENB_ACTZERO_M    0x00000003  // Action for Counter=0.
+#define PWM_X_GENB_ACTZERO_NONE 0x00000000  // Do nothing.
+#define PWM_X_GENB_ACTZERO_INV  0x00000001  // Invert the output signal.
+#define PWM_X_GENB_ACTZERO_ZERO 0x00000002  // Set the output signal to 0.
+#define PWM_X_GENB_ACTZERO_ONE  0x00000003  // Set the output signal to 1.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBCTL,
+// PWM_O_1_DBCTL, PWM_O_2_DBCTL, and PWM_O_3_DBCTL registers.
+//
+//*****************************************************************************
+#define PWM_X_DBCTL_ENABLE      0x00000001  // Dead-Band Generator Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBRISE,
+// PWM_O_1_DBRISE, PWM_O_2_DBRISE, and PWM_O_3_DBRISE registers.
+//
+//*****************************************************************************
+#define PWM_X_DBRISE_DELAY_M    0x00000FFF  // Dead-Band Rise Delay.
+#define PWM_X_DBRISE_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_DBFALL,
+// PWM_O_1_DBFALL, PWM_O_2_DBFALL, and PWM_O_3_DBFALL registers.
+//
+//*****************************************************************************
+#define PWM_X_DBFALL_DELAY_M    0x00000FFF  // Dead-Band Fall Delay.
+#define PWM_X_DBFALL_DELAY_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSRC0,
+// PWM_O_1_FLTSRC0, PWM_O_2_FLTSRC0, and PWM_O_3_FLTSRC0 registers.
+//
+//*****************************************************************************
+#define PWM_X_FLTSRC0_FAULT3    0x00000008  // Fault3.
+#define PWM_X_FLTSRC0_FAULT2    0x00000004  // Fault2.
+#define PWM_X_FLTSRC0_FAULT1    0x00000002  // Fault1.
+#define PWM_X_FLTSRC0_FAULT0    0x00000001  // Fault0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSRC1,
+// PWM_O_1_FLTSRC1, PWM_O_2_FLTSRC1, and PWM_O_3_FLTSRC1 registers.
+//
+//*****************************************************************************
+#define PWM_X_FLTSRC1_DCMP7     0x00000080  // Digital Comparator 7.
+#define PWM_X_FLTSRC1_DCMP6     0x00000040  // Digital Comparator 6.
+#define PWM_X_FLTSRC1_DCMP5     0x00000020  // Digital Comparator 5.
+#define PWM_X_FLTSRC1_DCMP4     0x00000010  // Digital Comparator 4.
+#define PWM_X_FLTSRC1_DCMP3     0x00000008  // Digital Comparator 3.
+#define PWM_X_FLTSRC1_DCMP2     0x00000004  // Digital Comparator 2.
+#define PWM_X_FLTSRC1_DCMP1     0x00000002  // Digital Comparator 1.
+#define PWM_X_FLTSRC1_DCMP0     0x00000001  // Digital Comparator 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_MINFLTPER,
+// PWM_O_1_MINFLTPER, PWM_O_2_MINFLTPER, and PWM_O_3_MINFLTPER registers.
+//
+//*****************************************************************************
+#define PWM_X_MINFLTPER_M       0x0000FFFF  // Minimum Fault Period.
+#define PWM_X_MINFLTPER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSEN,
+// PWM_O_1_FLTSEN, PWM_O_2_FLTSEN, and PWM_O_3_FLTSEN registers.
+//
+//*****************************************************************************
+#define PWM_X_FLTSEN_FAULT3     0x00000008  // Fault3 Sense.
+#define PWM_X_FLTSEN_FAULT2     0x00000004  // Fault2 Sense.
+#define PWM_X_FLTSEN_FAULT1     0x00000002  // Fault1 Sense.
+#define PWM_X_FLTSEN_FAULT0     0x00000001  // Fault0 Sense.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSTAT0,
+// PWM_O_1_FLTSTAT0, PWM_O_2_FLTSTAT0, and PWM_O_3_FLTSTAT0 registers.
+//
+//*****************************************************************************
+#define PWM_X_FLTSTAT0_FAULT3   0x00000008  // Fault Input 3.
+#define PWM_X_FLTSTAT0_FAULT2   0x00000004  // Fault Input 2.
+#define PWM_X_FLTSTAT0_FAULT1   0x00000002  // Fault Input 1.
+#define PWM_X_FLTSTAT0_FAULT0   0x00000001  // Fault Input 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the PWM_O_0_FLTSTAT1,
+// PWM_O_1_FLTSTAT1, PWM_O_2_FLTSTAT1, and PWM_O_3_FLTSTAT1 registers.
+//
+//*****************************************************************************
+#define PWM_X_FLTSTAT1_DCMP7    0x00000080  // Digital Comparator 7 Trigger.
+#define PWM_X_FLTSTAT1_DCMP6    0x00000040  // Digital Comparator 6 Trigger.
+#define PWM_X_FLTSTAT1_DCMP5    0x00000020  // Digital Comparator 5 Trigger.
+#define PWM_X_FLTSTAT1_DCMP4    0x00000010  // Digital Comparator 4 Trigger.
+#define PWM_X_FLTSTAT1_DCMP3    0x00000008  // Digital Comparator 3 Trigger.
+#define PWM_X_FLTSTAT1_DCMP2    0x00000004  // Digital Comparator 2 Trigger.
+#define PWM_X_FLTSTAT1_DCMP1    0x00000002  // Digital Comparator 1 Trigger.
+#define PWM_X_FLTSTAT1_DCMP0    0x00000001  // Digital Comparator 0 Trigger.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_CTL register.
+//
+//*****************************************************************************
+#define QEI_CTL_FILTCNT_M       0x000F0000  // Input Filter Pre-Scale Count.
+#define QEI_CTL_FILTEN          0x00002000  // Enable Input Filter.
+#define QEI_CTL_STALLEN         0x00001000  // Stall QEI.
+#define QEI_CTL_INVI            0x00000800  // Invert Index Pulse.
+#define QEI_CTL_INVB            0x00000400  // Invert PhB.
+#define QEI_CTL_INVA            0x00000200  // Invert PhA.
+#define QEI_CTL_VELDIV_M        0x000001C0  // Predivide Velocity.
+#define QEI_CTL_VELDIV_1        0x00000000  // /1
+#define QEI_CTL_VELDIV_2        0x00000040  // /2
+#define QEI_CTL_VELDIV_4        0x00000080  // /4
+#define QEI_CTL_VELDIV_8        0x000000C0  // /8
+#define QEI_CTL_VELDIV_16       0x00000100  // /16
+#define QEI_CTL_VELDIV_32       0x00000140  // /32
+#define QEI_CTL_VELDIV_64       0x00000180  // /64
+#define QEI_CTL_VELDIV_128      0x000001C0  // /128
+#define QEI_CTL_VELEN           0x00000020  // Capture Velocity.
+#define QEI_CTL_RESMODE         0x00000010  // Reset Mode.
+#define QEI_CTL_CAPMODE         0x00000008  // Capture Mode.
+#define QEI_CTL_SIGMODE         0x00000004  // Signal Mode.
+#define QEI_CTL_SWAP            0x00000002  // Swap Signals.
+#define QEI_CTL_ENABLE          0x00000001  // Enable QEI.
+#define QEI_CTL_FILTCNT_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_STAT register.
+//
+//*****************************************************************************
+#define QEI_STAT_DIRECTION      0x00000002  // Direction of Rotation.
+#define QEI_STAT_ERROR          0x00000001  // Error Detected.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_POS register.
+//
+//*****************************************************************************
+#define QEI_POS_M               0xFFFFFFFF  // Current Position Integrator
+                                            // Value.
+#define QEI_POS_S               0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_MAXPOS register.
+//
+//*****************************************************************************
+#define QEI_MAXPOS_M            0xFFFFFFFF  // Maximum Position Integrator
+                                            // Value.
+#define QEI_MAXPOS_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_LOAD register.
+//
+//*****************************************************************************
+#define QEI_LOAD_M              0xFFFFFFFF  // Velocity Timer Load Value.
+#define QEI_LOAD_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_TIME register.
+//
+//*****************************************************************************
+#define QEI_TIME_M              0xFFFFFFFF  // Velocity Timer Current Value.
+#define QEI_TIME_S              0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_COUNT register.
+//
+//*****************************************************************************
+#define QEI_COUNT_M             0xFFFFFFFF  // Velocity Pulse Count.
+#define QEI_COUNT_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_SPEED register.
+//
+//*****************************************************************************
+#define QEI_SPEED_M             0xFFFFFFFF  // Velocity.
+#define QEI_SPEED_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_INTEN register.
+//
+//*****************************************************************************
+#define QEI_INTEN_ERROR         0x00000008  // Phase Error Interrupt Enable.
+#define QEI_INTEN_DIR           0x00000004  // Direction Change Interrupt
+                                            // Enable.
+#define QEI_INTEN_TIMER         0x00000002  // Timer Expires Interrupt Enable.
+#define QEI_INTEN_INDEX         0x00000001  // Index Pulse Detected Interrupt
+                                            // Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_RIS register.
+//
+//*****************************************************************************
+#define QEI_RIS_ERROR           0x00000008  // Phase Error Detected.
+#define QEI_RIS_DIR             0x00000004  // Direction Change Detected.
+#define QEI_RIS_TIMER           0x00000002  // Velocity Timer Expired.
+#define QEI_RIS_INDEX           0x00000001  // Index Pulse Asserted.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the QEI_O_ISC register.
+//
+//*****************************************************************************
+#define QEI_ISC_ERROR           0x00000008  // Phase Error Interrupt.
+#define QEI_ISC_DIR             0x00000004  // Direction Change Interrupt.
+#define QEI_ISC_TIMER           0x00000002  // Velocity Timer Expired
+                                            // Interrupt.
+#define QEI_ISC_INDEX           0x00000001  // Index Pulse Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CFG register.
+//
+//*****************************************************************************
+#define TIMER_CFG_M             0x00000007  // GPTM Configuration.
+#define TIMER_CFG_32_BIT_TIMER  0x00000000  // 32-bit timer configuration.
+#define TIMER_CFG_32_BIT_RTC    0x00000001  // 32-bit real-time clock (RTC)
+                                            // counter configuration.
+#define TIMER_CFG_16_BIT        0x00000004  // 16-bit timer configuration,
+                                            // function is controlled by bits
+                                            // 1:0 of GPTMTAMR and GPTMTBMR.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMR register.
+//
+//*****************************************************************************
+#define TIMER_TAMR_TASNAPS      0x00000080  // GPTM Timer A Snap-Shot Mode.
+#define TIMER_TAMR_TAWOT        0x00000040  // GPTM Timer A Wait-on-Trigger.
+#define TIMER_TAMR_TAMIE        0x00000020  // GPTM Timer A Match Interrupt
+                                            // Enable.
+#define TIMER_TAMR_TACDIR       0x00000010  // GPTM Timer A Count Direction.
+#define TIMER_TAMR_TAAMS        0x00000008  // GPTM Timer A Alternate Mode
+                                            // Select.
+#define TIMER_TAMR_TACMR        0x00000004  // GPTM Timer A Capture Mode.
+#define TIMER_TAMR_TAMR_M       0x00000003  // GPTM Timer A Mode.
+#define TIMER_TAMR_TAMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TAMR_TAMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TAMR_TAMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMR register.
+//
+//*****************************************************************************
+#define TIMER_TBMR_TBSNAPS      0x00000080  // GPTM Timer B Snap-Shot Mode.
+#define TIMER_TBMR_TBWOT        0x00000040  // GPTM Timer B Wait-on-Trigger.
+#define TIMER_TBMR_TBMIE        0x00000020  // GPTM Timer B Match Interrupt
+                                            // Enable.
+#define TIMER_TBMR_TBCDIR       0x00000010  // GPTM Timer B Count Direction.
+#define TIMER_TBMR_TBAMS        0x00000008  // GPTM Timer B Alternate Mode
+                                            // Select.
+#define TIMER_TBMR_TBCMR        0x00000004  // GPTM Timer B Capture Mode.
+#define TIMER_TBMR_TBMR_M       0x00000003  // GPTM Timer B Mode.
+#define TIMER_TBMR_TBMR_1_SHOT  0x00000001  // One-Shot Timer mode
+#define TIMER_TBMR_TBMR_PERIOD  0x00000002  // Periodic Timer mode
+#define TIMER_TBMR_TBMR_CAP     0x00000003  // Capture mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_CTL register.
+//
+//*****************************************************************************
+#define TIMER_CTL_TBPWML        0x00004000  // GPTM Timer B PWM Output Level.
+#define TIMER_CTL_TBOTE         0x00002000  // GPTM Timer B Output Trigger
+                                            // Enable.
+#define TIMER_CTL_TBEVENT_M     0x00000C00  // GPTM Timer B Event Mode.
+#define TIMER_CTL_TBEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TBEVENT_NEG   0x00000400  // Negative edge
+#define TIMER_CTL_TBEVENT_BOTH  0x00000C00  // Both edges
+#define TIMER_CTL_TBSTALL       0x00000200  // GPTM Timer B Stall Enable.
+#define TIMER_CTL_TBEN          0x00000100  // GPTM Timer B Enable.
+#define TIMER_CTL_TAPWML        0x00000040  // GPTM Timer A PWM Output Level.
+#define TIMER_CTL_TAOTE         0x00000020  // GPTM Timer A Output Trigger
+                                            // Enable.
+#define TIMER_CTL_RTCEN         0x00000010  // GPTM RTC Enable.
+#define TIMER_CTL_TAEVENT_M     0x0000000C  // GPTM Timer A Event Mode.
+#define TIMER_CTL_TAEVENT_POS   0x00000000  // Positive edge
+#define TIMER_CTL_TAEVENT_NEG   0x00000004  // Negative edge
+#define TIMER_CTL_TAEVENT_BOTH  0x0000000C  // Both edges
+#define TIMER_CTL_TASTALL       0x00000002  // GPTM Timer A Stall Enable.
+#define TIMER_CTL_TAEN          0x00000001  // GPTM Timer A Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_IMR register.
+//
+//*****************************************************************************
+#define TIMER_IMR_TBMIM         0x00000800  // GPTM Timer B Mode Match
+                                            // Interrupt Mask.
+#define TIMER_IMR_CBEIM         0x00000400  // GPTM Capture B Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CBMIM         0x00000200  // GPTM Capture B Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TBTOIM        0x00000100  // GPTM Timer B Time-Out Interrupt
+                                            // Mask.
+#define TIMER_IMR_TAMIM         0x00000010  // GPTM Timer A Mode Match
+                                            // Interrupt Mask.
+#define TIMER_IMR_RTCIM         0x00000008  // GPTM RTC Interrupt Mask.
+#define TIMER_IMR_CAEIM         0x00000004  // GPTM Capture A Event Interrupt
+                                            // Mask.
+#define TIMER_IMR_CAMIM         0x00000002  // GPTM Capture A Match Interrupt
+                                            // Mask.
+#define TIMER_IMR_TATOIM        0x00000001  // GPTM Timer A Time-Out Interrupt
+                                            // Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_RIS register.
+//
+//*****************************************************************************
+#define TIMER_RIS_TBMRIS        0x00000800  // GPTM Timer B Mode Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_CBERIS        0x00000400  // GPTM Capture B Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CBMRIS        0x00000200  // GPTM Capture B Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TBTORIS       0x00000100  // GPTM Timer B Time-Out Raw
+                                            // Interrupt.
+#define TIMER_RIS_TAMRIS        0x00000010  // GPTM Timer A Mode Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_RTCRIS        0x00000008  // GPTM RTC Raw Interrupt.
+#define TIMER_RIS_CAERIS        0x00000004  // GPTM Capture A Event Raw
+                                            // Interrupt.
+#define TIMER_RIS_CAMRIS        0x00000002  // GPTM Capture A Match Raw
+                                            // Interrupt.
+#define TIMER_RIS_TATORIS       0x00000001  // GPTM Timer A Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_MIS register.
+//
+//*****************************************************************************
+#define TIMER_MIS_TBMMIS        0x00000800  // GPTM Timer B Mode Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_CBEMIS        0x00000400  // GPTM Capture B Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CBMMIS        0x00000200  // GPTM Capture B Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TBTOMIS       0x00000100  // GPTM Timer B Time-Out Masked
+                                            // Interrupt.
+#define TIMER_MIS_TAMMIS        0x00000010  // GPTM Timer A Mode Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_RTCMIS        0x00000008  // GPTM RTC Masked Interrupt.
+#define TIMER_MIS_CAEMIS        0x00000004  // GPTM Capture A Event Masked
+                                            // Interrupt.
+#define TIMER_MIS_CAMMIS        0x00000002  // GPTM Capture A Match Masked
+                                            // Interrupt.
+#define TIMER_MIS_TATOMIS       0x00000001  // GPTM Timer A Time-Out Masked
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_ICR register.
+//
+//*****************************************************************************
+#define TIMER_ICR_TBMCINT       0x00000800  // GPTM Timer B Mode Match
+                                            // Interrupt Clear.
+#define TIMER_ICR_CBECINT       0x00000400  // GPTM Capture B Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CBMCINT       0x00000200  // GPTM Capture B Match Interrupt
+                                            // Clear.
+#define TIMER_ICR_TBTOCINT      0x00000100  // GPTM Timer B Time-Out Interrupt
+                                            // Clear.
+#define TIMER_ICR_TAMCINT       0x00000010  // GPTM Timer A Mode Match
+                                            // Interrupt Clear.
+#define TIMER_ICR_RTCCINT       0x00000008  // GPTM RTC Interrupt Clear.
+#define TIMER_ICR_CAECINT       0x00000004  // GPTM Capture A Event Interrupt
+                                            // Clear.
+#define TIMER_ICR_CAMCINT       0x00000002  // GPTM Capture A Match Interrupt
+                                            // Clear.
+#define TIMER_ICR_TATOCINT      0x00000001  // GPTM Timer A Time-Out Raw
+                                            // Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAILR register.
+//
+//*****************************************************************************
+#define TIMER_TAILR_TAILRH_M    0xFFFF0000  // GPTM Timer A Interval Load
+                                            // Register High.
+#define TIMER_TAILR_TAILRL_M    0x0000FFFF  // GPTM Timer A Interval Load
+                                            // Register Low.
+#define TIMER_TAILR_TAILRH_S    16
+#define TIMER_TAILR_TAILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBILR register.
+//
+//*****************************************************************************
+#define TIMER_TBILR_TBILRL_M    0x0000FFFF  // GPTM Timer B Interval Load
+                                            // Register.
+#define TIMER_TBILR_TBILRL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TAMATCHR_TAMRH_M  0xFFFF0000  // GPTM Timer A Match Register
+                                            // High.
+#define TIMER_TAMATCHR_TAMRL_M  0x0000FFFF  // GPTM Timer A Match Register Low.
+#define TIMER_TAMATCHR_TAMRH_S  16
+#define TIMER_TAMATCHR_TAMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBMATCHR
+// register.
+//
+//*****************************************************************************
+#define TIMER_TBMATCHR_TBMRL_M  0x0000FFFF  // GPTM Timer B Match Register Low.
+#define TIMER_TBMATCHR_TBMRL_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAPR register.
+//
+//*****************************************************************************
+#define TIMER_TAPR_TAPSR_M      0x000000FF  // GPTM Timer A Prescale.
+#define TIMER_TAPR_TAPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBPR register.
+//
+//*****************************************************************************
+#define TIMER_TBPR_TBPSR_M      0x000000FF  // GPTM Timer B Prescale.
+#define TIMER_TBPR_TBPSR_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAR register.
+//
+//*****************************************************************************
+#define TIMER_TAR_TARH_M        0xFFFF0000  // GPTM Timer A Register High.
+#define TIMER_TAR_TARL_M        0x0000FFFF  // GPTM Timer A Register Low.
+#define TIMER_TAR_TARH_S        16
+#define TIMER_TAR_TARL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBR register.
+//
+//*****************************************************************************
+#define TIMER_TBR_TBRL_M        0x0000FFFF  // GPTM Timer B.
+#define TIMER_TBR_TBRL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TAV register.
+//
+//*****************************************************************************
+#define TIMER_TAV_TAVH_M        0xFFFF0000  // GPTM Timer A Value High.
+#define TIMER_TAV_TAVL_M        0x0000FFFF  // GPTM Timer A Register Low.
+#define TIMER_TAV_TAVH_S        16
+#define TIMER_TAV_TAVL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the TIMER_O_TBV register.
+//
+//*****************************************************************************
+#define TIMER_TBV_TBVL_M        0x0000FFFF  // GPTM Timer B Register.
+#define TIMER_TBV_TBVL_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ACTSS register.
+//
+//*****************************************************************************
+#define ADC_ACTSS_ASEN3         0x00000008  // ADC SS3 Enable.
+#define ADC_ACTSS_ASEN2         0x00000004  // ADC SS2 Enable.
+#define ADC_ACTSS_ASEN1         0x00000002  // ADC SS1 Enable.
+#define ADC_ACTSS_ASEN0         0x00000001  // ADC SS0 Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_RIS register.
+//
+//*****************************************************************************
+#define ADC_RIS_INRDC           0x00010000  // Digital Comparator Raw Interrupt
+                                            // Status.
+#define ADC_RIS_INR3            0x00000008  // SS3 Raw Interrupt Status.
+#define ADC_RIS_INR2            0x00000004  // SS2 Raw Interrupt Status.
+#define ADC_RIS_INR1            0x00000002  // SS1 Raw Interrupt Status.
+#define ADC_RIS_INR0            0x00000001  // SS0 Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_IM register.
+//
+//*****************************************************************************
+#define ADC_IM_DCONSS3          0x00080000  // Digital Comparator Interrupt on
+                                            // SS3.
+#define ADC_IM_DCONSS2          0x00040000  // Digital Comparator Interrupt on
+                                            // SS2.
+#define ADC_IM_DCONSS1          0x00020000  // Digital Comparator Interrupt on
+                                            // SS1.
+#define ADC_IM_DCONSS0          0x00010000  // Digital Comparator Interrupt on
+                                            // SS0.
+#define ADC_IM_MASK3            0x00000008  // SS3 Interrupt Mask.
+#define ADC_IM_MASK2            0x00000004  // SS2 Interrupt Mask.
+#define ADC_IM_MASK1            0x00000002  // SS1 Interrupt Mask.
+#define ADC_IM_MASK0            0x00000001  // SS0 Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_ISC register.
+//
+//*****************************************************************************
+#define ADC_ISC_DCINSS3         0x00080000  // Digital Comparator Interrupt
+                                            // Status on SS3.
+#define ADC_ISC_DCINSS2         0x00040000  // Digital Comparator Interrupt
+                                            // Status on SS2.
+#define ADC_ISC_DCINSS1         0x00020000  // Digital Comparator Interrupt
+                                            // Status on SS1.
+#define ADC_ISC_DCINSS0         0x00010000  // Digital Comparator Interrupt
+                                            // Status on SS0.
+#define ADC_ISC_IN3             0x00000008  // SS3 Interrupt Status and Clear.
+#define ADC_ISC_IN2             0x00000004  // SS2 Interrupt Status and Clear.
+#define ADC_ISC_IN1             0x00000002  // SS1 Interrupt Status and Clear.
+#define ADC_ISC_IN0             0x00000001  // SS0 Interrupt Status and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_OSTAT register.
+//
+//*****************************************************************************
+#define ADC_OSTAT_OV3           0x00000008  // SS3 FIFO Overflow.
+#define ADC_OSTAT_OV2           0x00000004  // SS2 FIFO Overflow.
+#define ADC_OSTAT_OV1           0x00000002  // SS1 FIFO Overflow.
+#define ADC_OSTAT_OV0           0x00000001  // SS0 FIFO Overflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_EMUX register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_M          0x0000F000  // SS3 Trigger Select.
+#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog Comparator 0
+#define ADC_EMUX_EM3_COMP1      0x00002000  // Analog Comparator 1
+#define ADC_EMUX_EM3_COMP2      0x00003000  // Analog Comparator 2
+#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External (GPIO PB4)
+#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer
+#define ADC_EMUX_EM3_PWM0       0x00006000  // PWM0
+#define ADC_EMUX_EM3_PWM1       0x00007000  // PWM1
+#define ADC_EMUX_EM3_PWM2       0x00008000  // PWM2
+#define ADC_EMUX_EM3_PWM3       0x00009000  // PWM3
+#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always (continuously sample)
+#define ADC_EMUX_EM2_M          0x00000F00  // SS2 Trigger Select.
+#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog Comparator 0
+#define ADC_EMUX_EM2_COMP1      0x00000200  // Analog Comparator 1
+#define ADC_EMUX_EM2_COMP2      0x00000300  // Analog Comparator 2
+#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External (GPIO PB4)
+#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer
+#define ADC_EMUX_EM2_PWM0       0x00000600  // PWM0
+#define ADC_EMUX_EM2_PWM1       0x00000700  // PWM1
+#define ADC_EMUX_EM2_PWM2       0x00000800  // PWM2
+#define ADC_EMUX_EM2_PWM3       0x00000900  // PWM3
+#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always (continuously sample)
+#define ADC_EMUX_EM1_M          0x000000F0  // SS1 Trigger Select.
+#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog Comparator 0
+#define ADC_EMUX_EM1_COMP1      0x00000020  // Analog Comparator 1
+#define ADC_EMUX_EM1_COMP2      0x00000030  // Analog Comparator 2
+#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External (GPIO PB4)
+#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer
+#define ADC_EMUX_EM1_PWM0       0x00000060  // PWM0
+#define ADC_EMUX_EM1_PWM1       0x00000070  // PWM1
+#define ADC_EMUX_EM1_PWM2       0x00000080  // PWM2
+#define ADC_EMUX_EM1_PWM3       0x00000090  // PWM3
+#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always (continuously sample)
+#define ADC_EMUX_EM0_M          0x0000000F  // SS0 Trigger Select.
+#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Processor (default)
+#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog Comparator 0
+#define ADC_EMUX_EM0_COMP1      0x00000002  // Analog Comparator 1
+#define ADC_EMUX_EM0_COMP2      0x00000003  // Analog Comparator 2
+#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External (GPIO PB4)
+#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer
+#define ADC_EMUX_EM0_PWM0       0x00000006  // PWM0
+#define ADC_EMUX_EM0_PWM1       0x00000007  // PWM1
+#define ADC_EMUX_EM0_PWM2       0x00000008  // PWM2
+#define ADC_EMUX_EM0_PWM3       0x00000009  // PWM3
+#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always (continuously sample)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_USTAT register.
+//
+//*****************************************************************************
+#define ADC_USTAT_UV3           0x00000008  // SS3 FIFO Underflow.
+#define ADC_USTAT_UV2           0x00000004  // SS2 FIFO Underflow.
+#define ADC_USTAT_UV1           0x00000002  // SS1 FIFO Underflow.
+#define ADC_USTAT_UV0           0x00000001  // SS0 FIFO Underflow.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSPRI register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_M         0x00003000  // SS3 Priority.
+#define ADC_SSPRI_SS3_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS3_2ND       0x00001000  // Second priority
+#define ADC_SSPRI_SS3_3RD       0x00002000  // Third priority
+#define ADC_SSPRI_SS3_4TH       0x00003000  // Fourth priority
+#define ADC_SSPRI_SS2_M         0x00000300  // SS2 Priority.
+#define ADC_SSPRI_SS2_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS2_2ND       0x00000100  // Second priority
+#define ADC_SSPRI_SS2_3RD       0x00000200  // Third priority
+#define ADC_SSPRI_SS2_4TH       0x00000300  // Fourth priority
+#define ADC_SSPRI_SS1_M         0x00000030  // SS1 Priority.
+#define ADC_SSPRI_SS1_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS1_2ND       0x00000010  // Second priority
+#define ADC_SSPRI_SS1_3RD       0x00000020  // Third priority
+#define ADC_SSPRI_SS1_4TH       0x00000030  // Fourth priority
+#define ADC_SSPRI_SS0_M         0x00000003  // SS0 Priority.
+#define ADC_SSPRI_SS0_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS0_2ND       0x00000001  // Second priority
+#define ADC_SSPRI_SS0_3RD       0x00000002  // Third priority
+#define ADC_SSPRI_SS0_4TH       0x00000003  // Fourth priority
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_PSSI register.
+//
+//*****************************************************************************
+#define ADC_PSSI_GSYNC          0x80000000  // Global Synchronize.
+#define ADC_PSSI_SYNCWAIT       0x08000000  // Synchronize Wait.
+#define ADC_PSSI_SS3            0x00000008  // SS3 Initiate.
+#define ADC_PSSI_SS2            0x00000004  // SS2 Initiate.
+#define ADC_PSSI_SS1            0x00000002  // SS1 Initiate.
+#define ADC_PSSI_SS0            0x00000001  // SS0 Initiate.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SAC register.
+//
+//*****************************************************************************
+#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control.
+#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
+#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
+#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
+#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
+#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
+#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
+#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCISC register.
+//
+//*****************************************************************************
+#define ADC_DCISC_DCINT7        0x00000080  // Digital Comparator 7 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT6        0x00000040  // Digital Comparator 6 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT5        0x00000020  // Digital Comparator 5 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT4        0x00000010  // Digital Comparator 4 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT3        0x00000008  // Digital Comparator 3 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT2        0x00000004  // Digital Comparator 2 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT1        0x00000002  // Digital Comparator 1 Interrupt
+                                            // Status and Clear.
+#define ADC_DCISC_DCINT0        0x00000001  // Digital Comparator 0 Interrupt
+                                            // Status and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_CTL register.
+//
+//*****************************************************************************
+#define ADC_CTL_VREF            0x00000001  // Voltage Reference Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX0_MUX7_M       0xF0000000  // 8th Sample Input Select.
+#define ADC_SSMUX0_MUX6_M       0x0F000000  // 7th Sample Input Select.
+#define ADC_SSMUX0_MUX5_M       0x00F00000  // 6th Sample Input Select.
+#define ADC_SSMUX0_MUX4_M       0x000F0000  // 5th Sample Input Select.
+#define ADC_SSMUX0_MUX3_M       0x0000F000  // 4th Sample Input Select.
+#define ADC_SSMUX0_MUX2_M       0x00000F00  // 3rd Sample Input Select.
+#define ADC_SSMUX0_MUX1_M       0x000000F0  // 2nd Sample Input Select.
+#define ADC_SSMUX0_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX0_MUX7_S       28
+#define ADC_SSMUX0_MUX6_S       24
+#define ADC_SSMUX0_MUX5_S       20
+#define ADC_SSMUX0_MUX4_S       16
+#define ADC_SSMUX0_MUX3_S       12
+#define ADC_SSMUX0_MUX2_S       8
+#define ADC_SSMUX0_MUX1_S       4
+#define ADC_SSMUX0_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable.
+#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence.
+#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Diff Input Select.
+#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable.
+#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence.
+#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Diff Input Select.
+#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable.
+#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence.
+#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Diff Input Select.
+#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable.
+#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence.
+#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Diff Input Select.
+#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO0_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT0_HPTR_S     4
+#define ADC_SSFSTAT0_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP0 register.
+//
+//*****************************************************************************
+#define ADC_SSOP0_S7DCOP        0x10000000  // Sample 7 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S6DCOP        0x01000000  // Sample 6 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S5DCOP        0x00100000  // Sample 5 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S4DCOP        0x00010000  // Sample 4 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S3DCOP        0x00001000  // Sample 3 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP0_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC0 register.
+//
+//*****************************************************************************
+#define ADC_SSDC0_S7DCSEL_M     0xF0000000  // Sample 7 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S7DCSEL_0     0x00000000  // Digital Comparator Unit 0
+                                            // (ADCDCCMP0 and ADCCCTL0)
+#define ADC_SSDC0_S7DCSEL_1     0x10000000  // Digital Comparator Unit 1
+                                            // (ADCDCCMP1 and ADCCCTL1)
+#define ADC_SSDC0_S7DCSEL_2     0x20000000  // Digital Comparator Unit 2
+                                            // (ADCDCCMP2 and ADCCCTL2)
+#define ADC_SSDC0_S7DCSEL_3     0x30000000  // Digital Comparator Unit 3
+                                            // (ADCDCCMP3 and ADCCCTL3)
+#define ADC_SSDC0_S7DCSEL_4     0x40000000  // Digital Comparator Unit 4
+                                            // (ADCDCCMP4 and ADCCCTL4)
+#define ADC_SSDC0_S7DCSEL_5     0x50000000  // Digital Comparator Unit 5
+                                            // (ADCDCCMP5 and ADCCCTL5)
+#define ADC_SSDC0_S7DCSEL_6     0x60000000  // Digital Comparator Unit 6
+                                            // (ADCDCCMP6 and ADCCCTL6)
+#define ADC_SSDC0_S7DCSEL_7     0x70000000  // Digital Comparator Unit 7
+                                            // (ADCDCCMP7 and ADCCCTL7)
+#define ADC_SSDC0_S6DCSEL_M     0x0F000000  // Sample 6 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S5DCSEL_M     0x00F00000  // Sample 5 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S4DCSEL_M     0x000F0000  // Sample 4 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+#define ADC_SSDC0_S6DCSEL_S     24
+#define ADC_SSDC0_S5DCSEL_S     20
+#define ADC_SSDC0_S4DCSEL_S     16
+#define ADC_SSDC0_S3DCSEL_S     12
+#define ADC_SSDC0_S2DCSEL_S     8
+#define ADC_SSDC0_S1DCSEL_S     4
+#define ADC_SSDC0_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX1_MUX3_M       0x0000F000  // 4th Sample Input Select.
+#define ADC_SSMUX1_MUX2_M       0x00000F00  // 3rd Sample Input Select.
+#define ADC_SSMUX1_MUX1_M       0x000000F0  // 2nd Sample Input Select.
+#define ADC_SSMUX1_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX1_MUX3_S       12
+#define ADC_SSMUX1_MUX2_S       8
+#define ADC_SSMUX1_MUX1_S       4
+#define ADC_SSMUX1_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO1_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT1_HPTR_S     4
+#define ADC_SSFSTAT1_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP1 register.
+//
+//*****************************************************************************
+#define ADC_SSOP1_S3DCOP        0x00001000  // Sample 3 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP1_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP1_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP1_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC1 register.
+//
+//*****************************************************************************
+#define ADC_SSDC1_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S3DCSEL_0     0x00000000  // Digital Comparator Unit 0
+                                            // (ADCDCCMP0 and ADCCCTL0)
+#define ADC_SSDC1_S3DCSEL_1     0x00001000  // Digital Comparator Unit 1
+                                            // (ADCDCCMP1 and ADCCCTL1)
+#define ADC_SSDC1_S3DCSEL_2     0x00002000  // Digital Comparator Unit 2
+                                            // (ADCDCCMP2 and ADCCCTL2)
+#define ADC_SSDC1_S3DCSEL_3     0x00003000  // Digital Comparator Unit 3
+                                            // (ADCDCCMP3 and ADCCCTL3)
+#define ADC_SSDC1_S3DCSEL_4     0x00004000  // Digital Comparator Unit 4
+                                            // (ADCDCCMP4 and ADCCCTL4)
+#define ADC_SSDC1_S3DCSEL_5     0x00005000  // Digital Comparator Unit 5
+                                            // (ADCDCCMP5 and ADCCCTL5)
+#define ADC_SSDC1_S3DCSEL_6     0x00006000  // Digital Comparator Unit 6
+                                            // (ADCDCCMP6 and ADCCCTL6)
+#define ADC_SSDC1_S3DCSEL_7     0x00007000  // Digital Comparator Unit 7
+                                            // (ADCDCCMP7 and ADCCCTL7)
+#define ADC_SSDC1_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+#define ADC_SSDC1_S2DCSEL_S     8
+#define ADC_SSDC1_S1DCSEL_S     4
+#define ADC_SSDC1_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX2_MUX3_M       0x0000F000  // 4th Sample Input Select.
+#define ADC_SSMUX2_MUX2_M       0x00000F00  // 3rd Sample Input Select.
+#define ADC_SSMUX2_MUX1_M       0x000000F0  // 2nd Sample Input Select.
+#define ADC_SSMUX2_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX2_MUX3_S       12
+#define ADC_SSMUX2_MUX2_S       8
+#define ADC_SSMUX2_MUX1_S       4
+#define ADC_SSMUX2_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO2_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT2_HPTR_S     4
+#define ADC_SSFSTAT2_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP2 register.
+//
+//*****************************************************************************
+#define ADC_SSOP2_S3DCOP        0x00001000  // Sample 3 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP2_S2DCOP        0x00000100  // Sample 2 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP2_S1DCOP        0x00000010  // Sample 1 Digital Comparator
+                                            // Operation.
+#define ADC_SSOP2_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC2 register.
+//
+//*****************************************************************************
+#define ADC_SSDC2_S3DCSEL_M     0x0000F000  // Sample 3 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S3DCSEL_0     0x00000000  // Digital Comparator Unit 0
+                                            // (ADCDCCMP0 and ADCCCTL0)
+#define ADC_SSDC2_S3DCSEL_1     0x00001000  // Digital Comparator Unit 1
+                                            // (ADCDCCMP1 and ADCCCTL1)
+#define ADC_SSDC2_S3DCSEL_2     0x00002000  // Digital Comparator Unit 2
+                                            // (ADCDCCMP2 and ADCCCTL2)
+#define ADC_SSDC2_S3DCSEL_3     0x00003000  // Digital Comparator Unit 3
+                                            // (ADCDCCMP3 and ADCCCTL3)
+#define ADC_SSDC2_S3DCSEL_4     0x00004000  // Digital Comparator Unit 4
+                                            // (ADCDCCMP4 and ADCCCTL4)
+#define ADC_SSDC2_S3DCSEL_5     0x00005000  // Digital Comparator Unit 5
+                                            // (ADCDCCMP5 and ADCCCTL5)
+#define ADC_SSDC2_S3DCSEL_6     0x00006000  // Digital Comparator Unit 6
+                                            // (ADCDCCMP6 and ADCCCTL6)
+#define ADC_SSDC2_S3DCSEL_7     0x00007000  // Digital Comparator Unit 7
+                                            // (ADCDCCMP7 and ADCCCTL7)
+#define ADC_SSDC2_S2DCSEL_M     0x00000F00  // Sample 2 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S1DCSEL_M     0x000000F0  // Sample 1 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+#define ADC_SSDC2_S2DCSEL_S     8
+#define ADC_SSDC2_S1DCSEL_S     4
+#define ADC_SSDC2_S0DCSEL_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX3_MUX0_M       0x0000000F  // 1st Sample Input Select.
+#define ADC_SSMUX3_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL3_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL3_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL3_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO3_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT3_HPTR_S     4
+#define ADC_SSFSTAT3_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSOP3 register.
+//
+//*****************************************************************************
+#define ADC_SSOP3_S0DCOP        0x00000001  // Sample 0 Digital Comparator
+                                            // Operation.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSDC3 register.
+//
+//*****************************************************************************
+#define ADC_SSDC3_S0DCSEL_M     0x0000000F  // Sample 0 Digital Comparator
+                                            // Select.
+#define ADC_SSDC3_S0DCSEL_0     0x00000000  // Digital Comparator Unit 0
+                                            // (ADCDCCMP0 and ADCCCTL0)
+#define ADC_SSDC3_S0DCSEL_1     0x00000001  // Digital Comparator Unit 1
+                                            // (ADCDCCMP1 and ADCCCTL1)
+#define ADC_SSDC3_S0DCSEL_2     0x00000002  // Digital Comparator Unit 2
+                                            // (ADCDCCMP2 and ADCCCTL2)
+#define ADC_SSDC3_S0DCSEL_3     0x00000003  // Digital Comparator Unit 3
+                                            // (ADCDCCMP3 and ADCCCTL3)
+#define ADC_SSDC3_S0DCSEL_4     0x00000004  // Digital Comparator Unit 4
+                                            // (ADCDCCMP4 and ADCCCTL4)
+#define ADC_SSDC3_S0DCSEL_5     0x00000005  // Digital Comparator Unit 5
+                                            // (ADCDCCMP5 and ADCCCTL5)
+#define ADC_SSDC3_S0DCSEL_6     0x00000006  // Digital Comparator Unit 6
+                                            // (ADCDCCMP6 and ADCCCTL6)
+#define ADC_SSDC3_S0DCSEL_7     0x00000007  // Digital Comparator Unit 7
+                                            // (ADCDCCMP7 and ADCCCTL7)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCRIC register.
+//
+//*****************************************************************************
+#define ADC_DCRIC_DCTRIG7       0x00800000  // Digital Comparator Trigger 7.
+#define ADC_DCRIC_DCTRIG6       0x00400000  // Digital Comparator Trigger 6.
+#define ADC_DCRIC_DCTRIG5       0x00200000  // Digital Comparator Trigger 5.
+#define ADC_DCRIC_DCTRIG4       0x00100000  // Digital Comparator Trigger 4.
+#define ADC_DCRIC_DCTRIG3       0x00080000  // Digital Comparator Trigger 3.
+#define ADC_DCRIC_DCTRIG2       0x00040000  // Digital Comparator Trigger 2.
+#define ADC_DCRIC_DCTRIG1       0x00020000  // Digital Comparator Trigger 1.
+#define ADC_DCRIC_DCTRIG0       0x00010000  // Digital Comparator Trigger 0.
+#define ADC_DCRIC_DCINT7        0x00000080  // Digital Comparator Trigger 7.
+#define ADC_DCRIC_DCINT6        0x00000040  // Digital Comparator Trigger 6.
+#define ADC_DCRIC_DCINT5        0x00000020  // Digital Comparator Trigger 5.
+#define ADC_DCRIC_DCINT4        0x00000010  // Digital Comparator Trigger 4.
+#define ADC_DCRIC_DCINT3        0x00000008  // Digital Comparator Trigger 3.
+#define ADC_DCRIC_DCINT2        0x00000004  // Digital Comparator Trigger 2.
+#define ADC_DCRIC_DCINT1        0x00000002  // Digital Comparator Trigger 1.
+#define ADC_DCRIC_DCINT0        0x00000001  // Digital Comparator Trigger 0.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL0 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL0_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL0_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL0_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL0_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL0_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL0_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL0_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL0_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL0_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL0_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL0_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL0_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL0_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL0_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL0_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL0_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL0_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL0_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL0_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL0_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL1 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL1_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL1_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL1_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL1_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL1_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL1_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL1_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL1_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL1_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL1_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL1_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL1_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL1_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL1_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL1_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL1_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL1_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL1_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL1_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL1_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL2 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL2_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL2_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL2_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL2_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL2_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL2_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL2_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL2_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL2_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL2_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL2_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL2_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL2_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL2_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL2_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL2_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL2_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL2_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL2_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL2_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL3 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL3_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL3_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL3_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL3_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL3_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL3_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL3_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL3_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL3_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL3_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL3_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL3_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL3_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL3_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL3_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL3_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL3_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL3_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL3_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL3_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL4 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL4_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL4_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL4_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL4_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL4_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL4_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL4_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL4_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL4_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL4_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL4_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL4_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL4_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL4_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL4_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL4_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL4_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL4_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL4_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL4_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL5 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL5_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL5_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL5_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL5_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL5_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL5_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL5_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL5_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL5_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL5_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL5_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL5_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL5_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL5_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL5_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL5_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL5_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL5_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL5_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL5_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL6 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL6_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL6_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL6_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL6_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL6_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL6_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL6_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL6_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL6_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL6_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL6_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL6_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL6_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL6_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL6_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL6_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL6_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL6_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL6_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL6_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCTL7 register.
+//
+//*****************************************************************************
+#define ADC_DCCTL7_CTE          0x00001000  // Comparison Trigger Enable.
+#define ADC_DCCTL7_CTC_M        0x00000C00  // Comparison Trigger Condition.
+#define ADC_DCCTL7_CTC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL7_CTC_MID      0x00000400  // Mid Band
+#define ADC_DCCTL7_CTC_HIGH     0x00000C00  // High Band
+#define ADC_DCCTL7_CTM_M        0x00000300  // Comparison Trigger Mode.
+#define ADC_DCCTL7_CTM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL7_CTM_ONCE     0x00000100  // Once
+#define ADC_DCCTL7_CTM_HALWAYS  0x00000200  // Hysteresis Always
+#define ADC_DCCTL7_CTM_HONCE    0x00000300  // Hysteresis Once
+#define ADC_DCCTL7_CIE          0x00000010  // Comparison Interrupt Enable.
+#define ADC_DCCTL7_CIC_M        0x0000000C  // Comparison Interrupt Condition.
+#define ADC_DCCTL7_CIC_LOW      0x00000000  // Low Band
+#define ADC_DCCTL7_CIC_MID      0x00000004  // Mid Band
+#define ADC_DCCTL7_CIC_HIGH     0x0000000C  // High Band
+#define ADC_DCCTL7_CIM_M        0x00000003  // Comparison Interrupt Mode.
+#define ADC_DCCTL7_CIM_ALWAYS   0x00000000  // Always
+#define ADC_DCCTL7_CIM_ONCE     0x00000001  // Once
+#define ADC_DCCTL7_CIM_HALWAYS  0x00000002  // Hysteresis Always
+#define ADC_DCCTL7_CIM_HONCE    0x00000003  // Hysteresis Once
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP0 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP0_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP0_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP0_COMP1_S      16
+#define ADC_DCCMP0_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP1 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP1_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP1_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP1_COMP1_S      16
+#define ADC_DCCMP1_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP2 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP2_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP2_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP2_COMP1_S      16
+#define ADC_DCCMP2_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP3 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP3_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP3_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP3_COMP1_S      16
+#define ADC_DCCMP3_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP4 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP4_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP4_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP4_COMP1_S      16
+#define ADC_DCCMP4_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP5 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP5_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP5_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP5_COMP1_S      16
+#define ADC_DCCMP5_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP6 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP6_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP6_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP6_COMP1_S      16
+#define ADC_DCCMP6_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_DCCMP7 register.
+//
+//*****************************************************************************
+#define ADC_DCCMP7_COMP1_M      0x03FF0000  // Compare 1.
+#define ADC_DCCMP7_COMP0_M      0x000003FF  // Compare 0.
+#define ADC_DCCMP7_COMP1_S      16
+#define ADC_DCCMP7_COMP0_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_TMLB_CNT_M   0x000003C0  // Continuous Sample Counter.
+#define ADC_SSFIFO_TMLB_CONT    0x00000020  // Continuation Sample Indicator.
+#define ADC_SSFIFO_TMLB_DIFF    0x00000010  // Differential Sample Indicator.
+#define ADC_SSFIFO_TMLB_TS      0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_SSFIFO_TMLB_MUX_M   0x00000007  // Analog Input Indicator.
+#define ADC_SSFIFO_TMLB_CNT_S   6           // Sample counter shift
+#define ADC_SSFIFO_TMLB_MUX_S   0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACMIS register.
+//
+//*****************************************************************************
+#define COMP_ACMIS_IN2          0x00000004  // Comparator 2 Masked Interrupt
+                                            // Status.
+#define COMP_ACMIS_IN1          0x00000002  // Comparator 1 Masked Interrupt
+                                            // Status.
+#define COMP_ACMIS_IN0          0x00000001  // Comparator 0 Masked Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACRIS register.
+//
+//*****************************************************************************
+#define COMP_ACRIS_IN2          0x00000004  // Comparator 2 Interrupt Status.
+#define COMP_ACRIS_IN1          0x00000002  // Comparator 1 Interrupt Status.
+#define COMP_ACRIS_IN0          0x00000001  // Comparator 0 Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACINTEN register.
+//
+//*****************************************************************************
+#define COMP_ACINTEN_IN2        0x00000004  // Comparator 2 Interrupt Enable.
+#define COMP_ACINTEN_IN1        0x00000002  // Comparator 1 Interrupt Enable.
+#define COMP_ACINTEN_IN0        0x00000001  // Comparator 0 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACREFCTL
+// register.
+//
+//*****************************************************************************
+#define COMP_ACREFCTL_EN        0x00000200  // Resistor Ladder Enable.
+#define COMP_ACREFCTL_RNG       0x00000100  // Resistor Ladder Range.
+#define COMP_ACREFCTL_VREF_M    0x0000000F  // Resistor Ladder Voltage Ref.
+#define COMP_ACREFCTL_VREF_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT0 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT0_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL0 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL0_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL0_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL0_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL0_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL0_ASRCP_REF   0x00000400  // Internal voltage reference
+                                            // (VIREF)
+#define COMP_ACCTL0_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL0_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL0_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL0_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL0_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL0_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL0_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL0_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL0_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL0_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL0_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL0_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL0_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT1 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT1_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL1 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL1_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL1_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL1_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL1_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL1_ASRCP_REF   0x00000400  // Internal voltage reference
+                                            // (VIREF)
+#define COMP_ACCTL1_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL1_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL1_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL1_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL1_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL1_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL1_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL1_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL1_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL1_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL1_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL1_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL1_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACSTAT2 register.
+//
+//*****************************************************************************
+#define COMP_ACSTAT2_OVAL       0x00000002  // Comparator Output Value.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the COMP_O_ACCTL2 register.
+//
+//*****************************************************************************
+#define COMP_ACCTL2_TOEN        0x00000800  // Trigger Output Enable.
+#define COMP_ACCTL2_ASRCP_M     0x00000600  // Analog Source Positive.
+#define COMP_ACCTL2_ASRCP_PIN   0x00000000  // Pin value
+#define COMP_ACCTL2_ASRCP_PIN0  0x00000200  // Pin value of C0+
+#define COMP_ACCTL2_ASRCP_REF   0x00000400  // Internal voltage reference
+                                            // (VIREF)
+#define COMP_ACCTL2_TSLVAL      0x00000080  // Trigger Sense Level Value.
+#define COMP_ACCTL2_TSEN_M      0x00000060  // Trigger Sense.
+#define COMP_ACCTL2_TSEN_LEVEL  0x00000000  // Level sense, see TSLVAL
+#define COMP_ACCTL2_TSEN_FALL   0x00000020  // Falling edge
+#define COMP_ACCTL2_TSEN_RISE   0x00000040  // Rising edge
+#define COMP_ACCTL2_TSEN_BOTH   0x00000060  // Either edge
+#define COMP_ACCTL2_ISLVAL      0x00000010  // Interrupt Sense Level Value.
+#define COMP_ACCTL2_ISEN_M      0x0000000C  // Interrupt Sense.
+#define COMP_ACCTL2_ISEN_LEVEL  0x00000000  // Level sense, see ISLVAL
+#define COMP_ACCTL2_ISEN_FALL   0x00000004  // Falling edge
+#define COMP_ACCTL2_ISEN_RISE   0x00000008  // Rising edge
+#define COMP_ACCTL2_ISEN_BOTH   0x0000000C  // Either edge
+#define COMP_ACCTL2_CINV        0x00000002  // Comparator Output Invert.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_CTL register.
+//
+//*****************************************************************************
+#define CAN_CTL_TEST            0x00000080  // Test Mode Enable.
+#define CAN_CTL_CCE             0x00000040  // Configuration Change Enable.
+#define CAN_CTL_DAR             0x00000020  // Disable
+                                            // Automatic-Retransmission.
+#define CAN_CTL_EIE             0x00000008  // Error Interrupt Enable.
+#define CAN_CTL_SIE             0x00000004  // Status Interrupt Enable.
+#define CAN_CTL_IE              0x00000002  // CAN Interrupt Enable.
+#define CAN_CTL_INIT            0x00000001  // Initialization.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_STS register.
+//
+//*****************************************************************************
+#define CAN_STS_BOFF            0x00000080  // Bus-Off Status.
+#define CAN_STS_EWARN           0x00000040  // Warning Status.
+#define CAN_STS_EPASS           0x00000020  // Error Passive.
+#define CAN_STS_RXOK            0x00000010  // Received a Message Successfully.
+#define CAN_STS_TXOK            0x00000008  // Transmitted a Message
+                                            // Successfully.
+#define CAN_STS_LEC_M           0x00000007  // Last Error Code.
+#define CAN_STS_LEC_NONE        0x00000000  // No Error
+#define CAN_STS_LEC_STUFF       0x00000001  // Stuff Error
+#define CAN_STS_LEC_FORM        0x00000002  // Format Error
+#define CAN_STS_LEC_ACK         0x00000003  // ACK Error
+#define CAN_STS_LEC_BIT1        0x00000004  // Bit 1 Error
+#define CAN_STS_LEC_BIT0        0x00000005  // Bit 0 Error
+#define CAN_STS_LEC_CRC         0x00000006  // CRC Error
+#define CAN_STS_LEC_NOEVENT     0x00000007  // Unused
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_ERR register.
+//
+//*****************************************************************************
+#define CAN_ERR_RP              0x00008000  // Received Error Passive.
+#define CAN_ERR_REC_M           0x00007F00  // Receive Error Counter.
+#define CAN_ERR_TEC_M           0x000000FF  // Transmit Error Counter.
+#define CAN_ERR_REC_S           8
+#define CAN_ERR_TEC_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_BIT register.
+//
+//*****************************************************************************
+#define CAN_BIT_TSEG2_M         0x00007000  // Time Segment after Sample Point.
+#define CAN_BIT_TSEG1_M         0x00000F00  // Time Segment Before Sample
+                                            // Point.
+#define CAN_BIT_SJW_M           0x000000C0  // (Re)Synchronization Jump Width.
+#define CAN_BIT_BRP_M           0x0000003F  // Baud Rate Prescaler.
+#define CAN_BIT_TSEG2_S         12
+#define CAN_BIT_TSEG1_S         8
+#define CAN_BIT_SJW_S           6
+#define CAN_BIT_BRP_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_INT register.
+//
+//*****************************************************************************
+#define CAN_INT_INTID_M         0x0000FFFF  // Interrupt Identifier.
+#define CAN_INT_INTID_NONE      0x00000000  // No interrupt pending
+#define CAN_INT_INTID_STATUS    0x00008000  // Status Interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TST register.
+//
+//*****************************************************************************
+#define CAN_TST_RX              0x00000080  // Receive Observation.
+#define CAN_TST_TX_M            0x00000060  // Transmit Control.
+#define CAN_TST_TX_CANCTL       0x00000000  // CANnTx is controlled by the CAN
+                                            // module; default operation
+#define CAN_TST_TX_SAMPLE       0x00000020  // The sample point is driven on
+                                            // the CANnTx signal. This mode is
+                                            // useful to monitor bit timing.
+#define CAN_TST_TX_DOMINANT     0x00000040  // CANnTx drives a low value. This
+                                            // mode is useful for checking the
+                                            // physical layer of the CAN bus.
+#define CAN_TST_TX_RECESSIVE    0x00000060  // CANnTx drives a high value. This
+                                            // mode is useful for checking the
+                                            // physical layer of the CAN bus.
+#define CAN_TST_LBACK           0x00000010  // Loopback Mode.
+#define CAN_TST_SILENT          0x00000008  // Silent Mode.
+#define CAN_TST_BASIC           0x00000004  // Basic Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_BRPE register.
+//
+//*****************************************************************************
+#define CAN_BRPE_BRPE_M         0x0000000F  // Baud Rate Prescaler Extension.
+#define CAN_BRPE_BRPE_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF1CRQ_BUSY         0x00008000  // Busy Flag.
+#define CAN_IF1CRQ_MNUM_M       0x0000003F  // Message Number.
+#define CAN_IF1CRQ_MNUM_RSVD    0x00000000  // 0 is not a valid message number;
+                                            // it is interpreted as 0x20, or
+                                            // object 32.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF1CMSK_WRNRD       0x00000080  // Write, Not Read.
+#define CAN_IF1CMSK_MASK        0x00000040  // Access Mask Bits.
+#define CAN_IF1CMSK_ARB         0x00000020  // Access Arbitration Bits.
+#define CAN_IF1CMSK_CONTROL     0x00000010  // Access Control Bits.
+#define CAN_IF1CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit.
+#define CAN_IF1CMSK_NEWDAT      0x00000004  // NEWDAT 
+#define CAN_IF1CMSK_TXRQST      0x00000004  //  TXRQST Bit.
+#define CAN_IF1CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3.
+#define CAN_IF1CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask.
+#define CAN_IF1MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF1MSK2_MXTD        0x00008000  // Mask Extended Identifier.
+#define CAN_IF1MSK2_MDIR        0x00004000  // Mask Message Direction.
+#define CAN_IF1MSK2_IDMSK_M     0x00001FFF  // Identifier Mask.
+#define CAN_IF1MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB1_ID_M        0x0000FFFF  // Message Identifier.
+#define CAN_IF1ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1ARB2_MSGVAL      0x00008000  // Message Valid.
+#define CAN_IF1ARB2_XTD         0x00004000  // Extended Identifier.
+#define CAN_IF1ARB2_DIR         0x00002000  // Message Direction.
+#define CAN_IF1ARB2_ID_M        0x00001FFF  // Message Identifier.
+#define CAN_IF1ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF1MCTL_NEWDAT      0x00008000  // New Data.
+#define CAN_IF1MCTL_MSGLST      0x00004000  // Message Lost.
+#define CAN_IF1MCTL_INTPND      0x00002000  // Interrupt Pending.
+#define CAN_IF1MCTL_UMASK       0x00001000  // Use Acceptance Mask.
+#define CAN_IF1MCTL_TXIE        0x00000800  // Transmit Interrupt Enable.
+#define CAN_IF1MCTL_RXIE        0x00000400  // Receive Interrupt Enable.
+#define CAN_IF1MCTL_RMTEN       0x00000200  // Remote Enable.
+#define CAN_IF1MCTL_TXRQST      0x00000100  // Transmit Request.
+#define CAN_IF1MCTL_EOB         0x00000080  // End of Buffer.
+#define CAN_IF1MCTL_DLC_M       0x0000000F  // Data Length Code.
+#define CAN_IF1MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DA2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF1DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF1DB2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF1DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CRQ register.
+//
+//*****************************************************************************
+#define CAN_IF2CRQ_BUSY         0x00008000  // Busy Flag.
+#define CAN_IF2CRQ_MNUM_M       0x0000003F  // Message Number.
+#define CAN_IF2CRQ_MNUM_RSVD    0x00000000  // 0 is not a valid message number;
+                                            // it is interpreted as 0x20, or
+                                            // object 32.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2CMSK register.
+//
+//*****************************************************************************
+#define CAN_IF2CMSK_WRNRD       0x00000080  // Write, Not Read.
+#define CAN_IF2CMSK_MASK        0x00000040  // Access Mask Bits.
+#define CAN_IF2CMSK_ARB         0x00000020  // Access Arbitration Bits.
+#define CAN_IF2CMSK_CONTROL     0x00000010  // Access Control Bits.
+#define CAN_IF2CMSK_CLRINTPND   0x00000008  // Clear Interrupt Pending Bit.
+#define CAN_IF2CMSK_NEWDAT      0x00000004  // NEWDAT 
+#define CAN_IF2CMSK_TXRQST      0x00000004  //  TXRQST Bit.
+#define CAN_IF2CMSK_DATAA       0x00000002  // Access Data Byte 0 to 3.
+#define CAN_IF2CMSK_DATAB       0x00000001  // Access Data Byte 4 to 7.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK1 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK1_IDMSK_M     0x0000FFFF  // Identifier Mask.
+#define CAN_IF2MSK1_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MSK2 register.
+//
+//*****************************************************************************
+#define CAN_IF2MSK2_MXTD        0x00008000  // Mask Extended Identifier.
+#define CAN_IF2MSK2_MDIR        0x00004000  // Mask Message Direction.
+#define CAN_IF2MSK2_IDMSK_M     0x00001FFF  // Identifier Mask.
+#define CAN_IF2MSK2_IDMSK_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB1_ID_M        0x0000FFFF  // Message Identifier.
+#define CAN_IF2ARB1_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2ARB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2ARB2_MSGVAL      0x00008000  // Message Valid.
+#define CAN_IF2ARB2_XTD         0x00004000  // Extended Identifier.
+#define CAN_IF2ARB2_DIR         0x00002000  // Message Direction.
+#define CAN_IF2ARB2_ID_M        0x00001FFF  // Message Identifier.
+#define CAN_IF2ARB2_ID_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2MCTL register.
+//
+//*****************************************************************************
+#define CAN_IF2MCTL_NEWDAT      0x00008000  // New Data.
+#define CAN_IF2MCTL_MSGLST      0x00004000  // Message Lost.
+#define CAN_IF2MCTL_INTPND      0x00002000  // Interrupt Pending.
+#define CAN_IF2MCTL_UMASK       0x00001000  // Use Acceptance Mask.
+#define CAN_IF2MCTL_TXIE        0x00000800  // Transmit Interrupt Enable.
+#define CAN_IF2MCTL_RXIE        0x00000400  // Receive Interrupt Enable.
+#define CAN_IF2MCTL_RMTEN       0x00000200  // Remote Enable.
+#define CAN_IF2MCTL_TXRQST      0x00000100  // Transmit Request.
+#define CAN_IF2MCTL_EOB         0x00000080  // End of Buffer.
+#define CAN_IF2MCTL_DLC_M       0x0000000F  // Data Length Code.
+#define CAN_IF2MCTL_DLC_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DA1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DA2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DA2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DA2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB1 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB1_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DB1_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_IF2DB2 register.
+//
+//*****************************************************************************
+#define CAN_IF2DB2_DATA_M       0x0000FFFF  // Data.
+#define CAN_IF2DB2_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TXRQ1 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ1_TXRQST_M      0x0000FFFF  // Transmission Request Bits.
+#define CAN_TXRQ1_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_TXRQ2 register.
+//
+//*****************************************************************************
+#define CAN_TXRQ2_TXRQST_M      0x0000FFFF  // Transmission Request Bits.
+#define CAN_TXRQ2_TXRQST_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_NWDA1 register.
+//
+//*****************************************************************************
+#define CAN_NWDA1_NEWDAT_M      0x0000FFFF  // New Data Bits.
+#define CAN_NWDA1_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_NWDA2 register.
+//
+//*****************************************************************************
+#define CAN_NWDA2_NEWDAT_M      0x0000FFFF  // New Data Bits.
+#define CAN_NWDA2_NEWDAT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1INT register.
+//
+//*****************************************************************************
+#define CAN_MSG1INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits.
+#define CAN_MSG1INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2INT register.
+//
+//*****************************************************************************
+#define CAN_MSG2INT_INTPND_M    0x0000FFFF  // Interrupt Pending Bits.
+#define CAN_MSG2INT_INTPND_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG1VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG1VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits.
+#define CAN_MSG1VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the CAN_O_MSG2VAL register.
+//
+//*****************************************************************************
+#define CAN_MSG2VAL_MSGVAL_M    0x0000FFFF  // Message Valid Bits.
+#define CAN_MSG2VAL_MSGVAL_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR0 register.
+//
+//*****************************************************************************
+#define PHY_MR0_RESET           0x00008000  // Reset Registers.
+#define PHY_MR0_LOOPBK          0x00004000  // Loopback Mode.
+#define PHY_MR0_SPEEDSL         0x00002000  // Speed Select.
+#define PHY_MR0_ANEGEN          0x00001000  // Auto-Negotiation Enable.
+#define PHY_MR0_PWRDN           0x00000800  // Power Down.
+#define PHY_MR0_ISO             0x00000400  // Isolate.
+#define PHY_MR0_RANEG           0x00000200  // Restart Auto-Negotiation.
+#define PHY_MR0_DUPLEX          0x00000100  // Set Duplex Mode.
+#define PHY_MR0_COLT            0x00000080  // Collision Test.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RIS register.
+//
+//*****************************************************************************
+#define MAC_RIS_PHYINT          0x00000040  // PHY Interrupt.
+#define MAC_RIS_MDINT           0x00000020  // MII Transaction Complete.
+#define MAC_RIS_RXER            0x00000010  // Receive Error.
+#define MAC_RIS_FOV             0x00000008  // FIFO Overrun.
+#define MAC_RIS_TXEMP           0x00000004  // Transmit FIFO Empty.
+#define MAC_RIS_TXER            0x00000002  // Transmit Error.
+#define MAC_RIS_RXINT           0x00000001  // Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IACK register.
+//
+//*****************************************************************************
+#define MAC_IACK_PHYINT         0x00000040  // Clear PHY Interrupt.
+#define MAC_IACK_MDINT          0x00000020  // Clear MII Transaction Complete.
+#define MAC_IACK_RXER           0x00000010  // Clear Receive Error.
+#define MAC_IACK_FOV            0x00000008  // Clear FIFO Overrun.
+#define MAC_IACK_TXEMP          0x00000004  // Clear Transmit FIFO Empty.
+#define MAC_IACK_TXER           0x00000002  // Clear Transmit Error.
+#define MAC_IACK_RXINT          0x00000001  // Clear Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR1 register.
+//
+//*****************************************************************************
+#define PHY_MR1_100X_F          0x00004000  // 100BASE-TX Full-Duplex Mode.
+#define PHY_MR1_100X_H          0x00002000  // 100BASE-TX Half-Duplex Mode.
+#define PHY_MR1_10T_F           0x00001000  // 10BASE-T Full-Duplex Mode.
+#define PHY_MR1_10T_H           0x00000800  // 10BASE-T Half-Duplex Mode.
+#define PHY_MR1_ANEGC           0x00000020  // Auto-Negotiation Complete.
+#define PHY_MR1_RFAULT          0x00000010  // Remote Fault.
+#define PHY_MR1_ANEGA           0x00000008  // Auto-Negotiation.
+#define PHY_MR1_LINK            0x00000004  // Link Made.
+#define PHY_MR1_JAB             0x00000002  // Jabber Condition.
+#define PHY_MR1_EXTD            0x00000001  // Extended Capabilities.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR2 register.
+//
+//*****************************************************************************
+#define PHY_MR2_OUI_M           0x0000FFFF  // Organizationally Unique
+                                            // Identifier[21:6].
+#define PHY_MR2_OUI_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR3 register.
+//
+//*****************************************************************************
+#define PHY_MR3_OUI_M           0x0000FC00  // Organizationally Unique
+                                            // Identifier[5:0].
+#define PHY_MR3_MN_M            0x000003F0  // Model Number.
+#define PHY_MR3_RN_M            0x0000000F  // Revision Number.
+#define PHY_MR3_OUI_S           10
+#define PHY_MR3_MN_S            4
+#define PHY_MR3_RN_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IM register.
+//
+//*****************************************************************************
+#define MAC_IM_PHYINTM          0x00000040  // Mask PHY Interrupt.
+#define MAC_IM_MDINTM           0x00000020  // Mask MII Transaction Complete.
+#define MAC_IM_RXERM            0x00000010  // Mask Receive Error.
+#define MAC_IM_FOVM             0x00000008  // Mask FIFO Overrun.
+#define MAC_IM_TXEMPM           0x00000004  // Mask Transmit FIFO Empty.
+#define MAC_IM_TXERM            0x00000002  // Mask Transmit Error.
+#define MAC_IM_RXINTM           0x00000001  // Mask Packet Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR4 register.
+//
+//*****************************************************************************
+#define PHY_MR4_NP              0x00008000  // Next Page.
+#define PHY_MR4_RF              0x00002000  // Remote Fault.
+#define PHY_MR4_A3              0x00000100  // Technology Ability Field[3].
+#define PHY_MR4_A2              0x00000080  // Technology Ability Field[2].
+#define PHY_MR4_A1              0x00000040  // Technology Ability Field[1].
+#define PHY_MR4_A0              0x00000020  // Technology Ability Field[0].
+#define PHY_MR4_S_M             0x0000001F  // Selector Field.
+#define PHY_MR4_S_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR5 register.
+//
+//*****************************************************************************
+#define PHY_MR5_NP              0x00008000  // Next Page.
+#define PHY_MR5_ACK             0x00004000  // Acknowledge.
+#define PHY_MR5_RF              0x00002000  // Remote Fault.
+#define PHY_MR5_A_M             0x00001FE0  // Technology Ability Field.
+#define PHY_MR5_S_M             0x0000001F  // Selector Field.
+#define PHY_MR5_S_8023          0x00000001  // IEEE Std 802.3
+#define PHY_MR5_S_8029          0x00000002  // IEEE Std 802.9 ISLAN-16T
+#define PHY_MR5_S_8025          0x00000003  // IEEE Std 802.5
+#define PHY_MR5_S_1394          0x00000004  // IEEE Std 1394
+#define PHY_MR5_A_S             5
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR6 register.
+//
+//*****************************************************************************
+#define PHY_MR6_PDF             0x00000010  // Parallel Detection Fault.
+#define PHY_MR6_LPNPA           0x00000008  // Link Partner is Next Page Able.
+#define PHY_MR6_PRX             0x00000002  // New Page Received.
+#define PHY_MR6_LPANEGA         0x00000001  // Link Partner is Auto-Negotiation
+                                            // Able.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_RCTL register.
+//
+//*****************************************************************************
+#define MAC_RCTL_RSTFIFO        0x00000010  // Clear Receive FIFO.
+#define MAC_RCTL_BADCRC         0x00000008  // Enable Reject Bad CRC.
+#define MAC_RCTL_PRMS           0x00000004  // Enable Promiscuous Mode.
+#define MAC_RCTL_AMUL           0x00000002  // Enable Multicast Frames.
+#define MAC_RCTL_RXEN           0x00000001  // Enable Receiver.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TCTL register.
+//
+//*****************************************************************************
+#define MAC_TCTL_DUPLEX         0x00000010  // Enable Duplex Mode.
+#define MAC_TCTL_CRC            0x00000004  // Enable CRC Generation.
+#define MAC_TCTL_PADEN          0x00000002  // Enable Packet Padding.
+#define MAC_TCTL_TXEN           0x00000001  // Enable Transmitter.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_DATA register.
+//
+//*****************************************************************************
+#define MAC_DATA_TXDATA_M       0xFFFFFFFF  // Transmit FIFO Data.
+#define MAC_DATA_RXDATA_M       0xFFFFFFFF  // Receive FIFO Data.
+#define MAC_DATA_RXDATA_S       0
+#define MAC_DATA_TXDATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR16 register.
+//
+//*****************************************************************************
+#define PHY_MR16_SR_M           0x000003C0  // Silicon Revision Identifier.
+#define PHY_MR16_SR_S           6
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR17 register.
+//
+//*****************************************************************************
+#define PHY_MR17_FASTRIP        0x00004000  // 10-BASE-T Fast Mode Enable.
+#define PHY_MR17_EDPD           0x00002000  // Enable Energy Detect Power Down.
+#define PHY_MR17_LSQE           0x00000800  // Low Squelch Enable.
+#define PHY_MR17_MDPB           0x00000400  // Management Data Preamble Bypass.
+#define PHY_MR17_FLPBK          0x00000200  // Far Loopback Mode.
+#define PHY_MR17_FASTEST        0x00000100  // Auto-Negotiation Test Mode.
+#define PHY_MR17_REFCE          0x00000010  // Reference Clock Enable.
+#define PHY_MR17_PADBP          0x00000008  // PHY Address Bypass.
+#define PHY_MR17_FGLS           0x00000004  // Force Good Link Status.
+#define PHY_MR17_ENON           0x00000002  // Energy On.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA0 register.
+//
+//*****************************************************************************
+#define MAC_IA0_MACOCT4_M       0xFF000000  // MAC Address Octet 4.
+#define MAC_IA0_MACOCT3_M       0x00FF0000  // MAC Address Octet 3.
+#define MAC_IA0_MACOCT2_M       0x0000FF00  // MAC Address Octet 2.
+#define MAC_IA0_MACOCT1_M       0x000000FF  // MAC Address Octet 1.
+#define MAC_IA0_MACOCT4_S       24
+#define MAC_IA0_MACOCT3_S       16
+#define MAC_IA0_MACOCT2_S       8
+#define MAC_IA0_MACOCT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_IA1 register.
+//
+//*****************************************************************************
+#define MAC_IA1_MACOCT6_M       0x0000FF00  // MAC Address Octet 6.
+#define MAC_IA1_MACOCT5_M       0x000000FF  // MAC Address Octet 5.
+#define MAC_IA1_MACOCT6_S       8
+#define MAC_IA1_MACOCT5_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR27 register.
+//
+//*****************************************************************************
+#define PHY_MR27_XPOL           0x00000010  // Polarity State of 10 BASE-T.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_THR register.
+//
+//*****************************************************************************
+#define MAC_THR_THRESH_M        0x0000003F  // Threshold Value.
+#define MAC_THR_THRESH_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR29 register.
+//
+//*****************************************************************************
+#define PHY_MR29_EONIS          0x00000080  // ENERGYON Interrupt.
+#define PHY_MR29_ANCOMPIS       0x00000040  // Auto-Negotiation Complete
+                                            // Interrupt.
+#define PHY_MR29_RFLTIS         0x00000020  // Remote Fault Interrupt.
+#define PHY_MR29_LDIS           0x00000010  // Link Down Interrupt.
+#define PHY_MR29_LPACKIS        0x00000008  // Auto-Negotiation LP Acknowledge.
+#define PHY_MR29_PDFIS          0x00000004  // Parallel Detection Fault.
+#define PHY_MR29_PRXIS          0x00000002  // Auto Negotiation Page Received.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR30 register.
+//
+//*****************************************************************************
+#define PHY_MR30_EONIM          0x00000080  // ENERGYON Interrupt Enabled.
+#define PHY_MR30_ANCOMPIM       0x00000040  // Auto-Negotiation Complete
+                                            // Interrupt Enabled.
+#define PHY_MR30_RFLTIM         0x00000020  // Remote Fault Interrupt Enabled.
+#define PHY_MR30_LDIM           0x00000010  // Link Down Interrupt Enabled.
+#define PHY_MR30_LPACKIM        0x00000008  // Auto-Negotiation LP Acknowledge
+                                            // Enabled.
+#define PHY_MR30_PDFIM          0x00000004  // Parallel Detection Fault
+                                            // Enabled.
+#define PHY_MR30_PRXIM          0x00000002  // Auto Negotiation Page Received
+                                            // Enabled.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MR31 register.
+//
+//*****************************************************************************
+#define PHY_MR31_AUTODONE       0x00001000  // Auto Negotiation Done.
+#define PHY_MR31_SPEED_M        0x0000001C  // HCD Speed Value.
+#define PHY_MR31_SCRDIS         0x00000001  // Scramble Disable.
+#define PHY_MR31_SPEED_S        2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MCTL register.
+//
+//*****************************************************************************
+#define MAC_MCTL_REGADR_M       0x000000F8  // MII Register Address.
+#define MAC_MCTL_WRITE          0x00000002  // MII Register Transaction Type.
+#define MAC_MCTL_START          0x00000001  // MII Register Transaction Enable.
+#define MAC_MCTL_REGADR_S       3
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MDV register.
+//
+//*****************************************************************************
+#define MAC_MDV_DIV_M           0x000000FF  // Clock Divider.
+#define MAC_MDV_DIV_S           0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MTXD register.
+//
+//*****************************************************************************
+#define MAC_MTXD_MDTX_M         0x0000FFFF  // MII Register Transmit Data.
+#define MAC_MTXD_MDTX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MRXD register.
+//
+//*****************************************************************************
+#define MAC_MRXD_MDRX_M         0x0000FFFF  // MII Register Receive Data.
+#define MAC_MRXD_MDRX_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_NP register.
+//
+//*****************************************************************************
+#define MAC_NP_NPR_M            0x0000003F  // Number of Packets in Receive
+                                            // FIFO.
+#define MAC_NP_NPR_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_TR register.
+//
+//*****************************************************************************
+#define MAC_TR_NEWTX            0x00000001  // New Transmission.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_LED register.
+//
+//*****************************************************************************
+#define MAC_LED_LED1_M          0x000000F0  // LED1 Source.
+#define MAC_LED_LED1_LINK       0x00000000  // Link OK
+#define MAC_LED_LED1_RXTX       0x00000010  // RX or TX Activity (Default LED1)
+#define MAC_LED_LED1_100        0x00000050  // 100BASE-TX mode
+#define MAC_LED_LED1_10         0x00000060  // 10BASE-T mode
+#define MAC_LED_LED1_DUPLEX     0x00000070  // Full-Duplex
+#define MAC_LED_LED1_LINKACT    0x00000080  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+#define MAC_LED_LED0_M          0x0000000F  // LED0 Source.
+#define MAC_LED_LED0_LINK       0x00000000  // Link OK (Default LED0)
+#define MAC_LED_LED0_RXTX       0x00000001  // RX or TX Activity
+#define MAC_LED_LED0_100        0x00000005  // 100BASE-TX mode
+#define MAC_LED_LED0_10         0x00000006  // 10BASE-T mode
+#define MAC_LED_LED0_DUPLEX     0x00000007  // Full-Duplex
+#define MAC_LED_LED0_LINKACT    0x00000008  // Link OK &amp; Blink=RX or TX
+                                            // Activity
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the MAC_O_MDIX register.
+//
+//*****************************************************************************
+#define MAC_MDIX_EN             0x00000001  // MDI/MDI-X Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FADDR register.
+//
+//*****************************************************************************
+#define USB_FADDR_M             0x0000007F  // Function Address.
+#define USB_FADDR_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_POWER register.
+//
+//*****************************************************************************
+#define USB_POWER_ISOUP         0x00000080  // ISO Update.
+#define USB_POWER_SOFTCONN      0x00000040  // Soft Connect/Disconnect.
+#define USB_POWER_RESET         0x00000008  // Reset.
+#define USB_POWER_RESUME        0x00000004  // Resume Signaling.
+#define USB_POWER_SUSPEND       0x00000002  // Suspend Mode.
+#define USB_POWER_PWRDNPHY      0x00000001  // Power Down PHY.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXIS register.
+//
+//*****************************************************************************
+#define USB_TXIS_EP15           0x00008000  // TX Endpoint 15 Interrupt.
+#define USB_TXIS_EP14           0x00004000  // TX Endpoint 14 Interrupt.
+#define USB_TXIS_EP13           0x00002000  // TX Endpoint 13 Interrupt.
+#define USB_TXIS_EP12           0x00001000  // TX Endpoint 12 Interrupt.
+#define USB_TXIS_EP11           0x00000800  // TX Endpoint 11 Interrupt.
+#define USB_TXIS_EP10           0x00000400  // TX Endpoint 10 Interrupt.
+#define USB_TXIS_EP9            0x00000200  // TX Endpoint 9 Interrupt.
+#define USB_TXIS_EP8            0x00000100  // TX Endpoint 8 Interrupt.
+#define USB_TXIS_EP7            0x00000080  // TX Endpoint 7 Interrupt.
+#define USB_TXIS_EP6            0x00000040  // TX Endpoint 6 Interrupt.
+#define USB_TXIS_EP5            0x00000020  // TX Endpoint 5 Interrupt.
+#define USB_TXIS_EP4            0x00000010  // TX Endpoint 4 Interrupt.
+#define USB_TXIS_EP3            0x00000008  // TX Endpoint 3 Interrupt.
+#define USB_TXIS_EP2            0x00000004  // TX Endpoint 2 Interrupt.
+#define USB_TXIS_EP1            0x00000002  // TX Endpoint 1 Interrupt.
+#define USB_TXIS_EP0            0x00000001  // TX and RX Endpoint 0 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXIS register.
+//
+//*****************************************************************************
+#define USB_RXIS_EP15           0x00008000  // RX Endpoint 15 Interrupt.
+#define USB_RXIS_EP14           0x00004000  // RX Endpoint 14 Interrupt.
+#define USB_RXIS_EP13           0x00002000  // RX Endpoint 13 Interrupt.
+#define USB_RXIS_EP12           0x00001000  // RX Endpoint 12 Interrupt.
+#define USB_RXIS_EP11           0x00000800  // RX Endpoint 11 Interrupt.
+#define USB_RXIS_EP10           0x00000400  // RX Endpoint 10 Interrupt.
+#define USB_RXIS_EP9            0x00000200  // RX Endpoint 9 Interrupt.
+#define USB_RXIS_EP8            0x00000100  // RX Endpoint 8 Interrupt.
+#define USB_RXIS_EP7            0x00000080  // RX Endpoint 7 Interrupt.
+#define USB_RXIS_EP6            0x00000040  // RX Endpoint 6 Interrupt.
+#define USB_RXIS_EP5            0x00000020  // RX Endpoint 5 Interrupt.
+#define USB_RXIS_EP4            0x00000010  // RX Endpoint 4 Interrupt.
+#define USB_RXIS_EP3            0x00000008  // RX Endpoint 3 Interrupt.
+#define USB_RXIS_EP2            0x00000004  // RX Endpoint 2 Interrupt.
+#define USB_RXIS_EP1            0x00000002  // RX Endpoint 1 Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXIE register.
+//
+//*****************************************************************************
+#define USB_TXIE_EP15           0x00008000  // TX Endpoint 15 Interrupt Enable.
+#define USB_TXIE_EP14           0x00004000  // TX Endpoint 14 Interrupt Enable.
+#define USB_TXIE_EP13           0x00002000  // TX Endpoint 13 Interrupt Enable.
+#define USB_TXIE_EP12           0x00001000  // TX Endpoint 12 Interrupt Enable.
+#define USB_TXIE_EP11           0x00000800  // TX Endpoint 11 Interrupt Enable.
+#define USB_TXIE_EP10           0x00000400  // TX Endpoint 10 Interrupt Enable.
+#define USB_TXIE_EP9            0x00000200  // TX Endpoint 9 Interrupt Enable.
+#define USB_TXIE_EP8            0x00000100  // TX Endpoint 8 Interrupt Enable.
+#define USB_TXIE_EP7            0x00000080  // TX Endpoint 7 Interrupt Enable.
+#define USB_TXIE_EP6            0x00000040  // TX Endpoint 6 Interrupt Enable.
+#define USB_TXIE_EP5            0x00000020  // TX Endpoint 5 Interrupt Enable.
+#define USB_TXIE_EP4            0x00000010  // TX Endpoint 4 Interrupt Enable.
+#define USB_TXIE_EP3            0x00000008  // TX Endpoint 3 Interrupt Enable.
+#define USB_TXIE_EP2            0x00000004  // TX Endpoint 2 Interrupt Enable.
+#define USB_TXIE_EP1            0x00000002  // TX Endpoint 1 Interrupt Enable.
+#define USB_TXIE_EP0            0x00000001  // TX and RX Endpoint 0 Interrupt
+                                            // Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXIE register.
+//
+//*****************************************************************************
+#define USB_RXIE_EP15           0x00008000  // RX Endpoint 15 Interrupt Enable.
+#define USB_RXIE_EP14           0x00004000  // RX Endpoint 14 Interrupt Enable.
+#define USB_RXIE_EP13           0x00002000  // RX Endpoint 13 Interrupt Enable.
+#define USB_RXIE_EP12           0x00001000  // RX Endpoint 12 Interrupt Enable.
+#define USB_RXIE_EP11           0x00000800  // RX Endpoint 11 Interrupt Enable.
+#define USB_RXIE_EP10           0x00000400  // RX Endpoint 10 Interrupt Enable.
+#define USB_RXIE_EP9            0x00000200  // RX Endpoint 9 Interrupt Enable.
+#define USB_RXIE_EP8            0x00000100  // RX Endpoint 8 Interrupt Enable.
+#define USB_RXIE_EP7            0x00000080  // RX Endpoint 7 Interrupt Enable.
+#define USB_RXIE_EP6            0x00000040  // RX Endpoint 6 Interrupt Enable.
+#define USB_RXIE_EP5            0x00000020  // RX Endpoint 5 Interrupt Enable.
+#define USB_RXIE_EP4            0x00000010  // RX Endpoint 4 Interrupt Enable.
+#define USB_RXIE_EP3            0x00000008  // RX Endpoint 3 Interrupt Enable.
+#define USB_RXIE_EP2            0x00000004  // RX Endpoint 2 Interrupt Enable.
+#define USB_RXIE_EP1            0x00000002  // RX Endpoint 1 Interrupt Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IS register.
+//
+//*****************************************************************************
+#define USB_IS_VBUSERR          0x00000080  // VBus Error.
+#define USB_IS_SESREQ           0x00000040  // Session Request.
+#define USB_IS_DISCON           0x00000020  // Session Disconnect.
+#define USB_IS_CONN             0x00000010  // Session Connect.
+#define USB_IS_SOF              0x00000008  // Start of Frame.
+#define USB_IS_BABBLE           0x00000004  // Babble Detected.
+#define USB_IS_RESET            0x00000004  // Reset Signal Detected.
+#define USB_IS_RESUME           0x00000002  // Resume Signal Detected.
+#define USB_IS_SUSPEND          0x00000001  // Suspend Signal Detected.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IE register.
+//
+//*****************************************************************************
+#define USB_IE_VBUSERR          0x00000080  // Enable VBUS Error Interrupt.
+#define USB_IE_SESREQ           0x00000040  // Enable Session Request
+                                            // Interrupt.
+#define USB_IE_DISCON           0x00000020  // Enable Disconnect Interrupt.
+#define USB_IE_CONN             0x00000010  // Enable Connect Interrupt.
+#define USB_IE_SOF              0x00000008  // Enable Start-of-Frame Interrupt.
+#define USB_IE_BABBLE           0x00000004  // Enable Babble Interrupt.
+#define USB_IE_RESET            0x00000004  // Enable Reset Interrupt.
+#define USB_IE_RESUME           0x00000002  // Enable Resume Interrupt.
+#define USB_IE_SUSPND           0x00000001  // Enable Suspend Interrupt.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FRAME register.
+//
+//*****************************************************************************
+#define USB_FRAME_M             0x000007FF  // Frame Number.
+#define USB_FRAME_S             0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPIDX register.
+//
+//*****************************************************************************
+#define USB_EPIDX_EPIDX_M       0x0000000F  // Endpoint Index.
+#define USB_EPIDX_EPIDX_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TEST register.
+//
+//*****************************************************************************
+#define USB_TEST_FORCEH         0x00000080  // Force Host Mode.
+#define USB_TEST_FIFOACC        0x00000040  // FIFO Access.
+#define USB_TEST_FORCEFS        0x00000020  // Force Full Speed.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO0 register.
+//
+//*****************************************************************************
+#define USB_FIFO0_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO0_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO1 register.
+//
+//*****************************************************************************
+#define USB_FIFO1_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO1_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO2 register.
+//
+//*****************************************************************************
+#define USB_FIFO2_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO2_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO3 register.
+//
+//*****************************************************************************
+#define USB_FIFO3_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO3_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO4 register.
+//
+//*****************************************************************************
+#define USB_FIFO4_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO4_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO5 register.
+//
+//*****************************************************************************
+#define USB_FIFO5_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO5_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO6 register.
+//
+//*****************************************************************************
+#define USB_FIFO6_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO6_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO7 register.
+//
+//*****************************************************************************
+#define USB_FIFO7_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO7_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO8 register.
+//
+//*****************************************************************************
+#define USB_FIFO8_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO8_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO9 register.
+//
+//*****************************************************************************
+#define USB_FIFO9_EPDATA_M      0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO9_EPDATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO10 register.
+//
+//*****************************************************************************
+#define USB_FIFO10_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO10_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO11 register.
+//
+//*****************************************************************************
+#define USB_FIFO11_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO11_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO12 register.
+//
+//*****************************************************************************
+#define USB_FIFO12_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO12_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO13 register.
+//
+//*****************************************************************************
+#define USB_FIFO13_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO13_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO14 register.
+//
+//*****************************************************************************
+#define USB_FIFO14_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO14_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FIFO15 register.
+//
+//*****************************************************************************
+#define USB_FIFO15_EPDATA_M     0xFFFFFFFF  // Endpoint Data.
+#define USB_FIFO15_EPDATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DEVCTL register.
+//
+//*****************************************************************************
+#define USB_DEVCTL_DEV          0x00000080  // Device Mode.
+#define USB_DEVCTL_FSDEV        0x00000040  // Full-Speed Device Detected.
+#define USB_DEVCTL_LSDEV        0x00000020  // Low-Speed Device Detected.
+#define USB_DEVCTL_VBUS_M       0x00000018  // VBus Level.
+#define USB_DEVCTL_VBUS_NONE    0x00000000  // Below SessionEnd
+#define USB_DEVCTL_VBUS_SEND    0x00000008  // Above SessionEnd, below AValid
+#define USB_DEVCTL_VBUS_AVALID  0x00000010  // Above AValid, below VBusValid
+#define USB_DEVCTL_VBUS_VALID   0x00000018  // Above VBusValid
+#define USB_DEVCTL_HOST         0x00000004  // Host Mode.
+#define USB_DEVCTL_HOSTREQ      0x00000002  // Host Request.
+#define USB_DEVCTL_SESSION      0x00000001  // Session Start/End.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFIFOSZ register.
+//
+//*****************************************************************************
+#define USB_TXFIFOSZ_DPB        0x00000010  // Double Packet Buffer Support.
+#define USB_TXFIFOSZ_SIZE_M     0x0000000F  // Max Packet Size.
+#define USB_TXFIFOSZ_SIZE_8     0x00000000  // 8
+#define USB_TXFIFOSZ_SIZE_16    0x00000001  // 16
+#define USB_TXFIFOSZ_SIZE_32    0x00000002  // 32
+#define USB_TXFIFOSZ_SIZE_64    0x00000003  // 64
+#define USB_TXFIFOSZ_SIZE_128   0x00000004  // 128
+#define USB_TXFIFOSZ_SIZE_256   0x00000005  // 256
+#define USB_TXFIFOSZ_SIZE_512   0x00000006  // 512
+#define USB_TXFIFOSZ_SIZE_1024  0x00000007  // 1024
+#define USB_TXFIFOSZ_SIZE_2048  0x00000008  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFIFOSZ register.
+//
+//*****************************************************************************
+#define USB_RXFIFOSZ_DPB        0x00000010  // Double Packet Buffer Support.
+#define USB_RXFIFOSZ_SIZE_M     0x0000000F  // Max Packet Size.
+#define USB_RXFIFOSZ_SIZE_8     0x00000000  // 8
+#define USB_RXFIFOSZ_SIZE_16    0x00000001  // 16
+#define USB_RXFIFOSZ_SIZE_32    0x00000002  // 32
+#define USB_RXFIFOSZ_SIZE_64    0x00000003  // 64
+#define USB_RXFIFOSZ_SIZE_128   0x00000004  // 128
+#define USB_RXFIFOSZ_SIZE_256   0x00000005  // 256
+#define USB_RXFIFOSZ_SIZE_512   0x00000006  // 512
+#define USB_RXFIFOSZ_SIZE_1024  0x00000007  // 1024
+#define USB_RXFIFOSZ_SIZE_2048  0x00000008  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFIFOADD
+// register.
+//
+//*****************************************************************************
+#define USB_TXFIFOADD_ADDR_M    0x00001FFF  // Transmit/Receive Start Address.
+#define USB_TXFIFOADD_ADDR_0    0x00000000  // 0
+#define USB_TXFIFOADD_ADDR_8    0x00000001  // 8
+#define USB_TXFIFOADD_ADDR_16   0x00000002  // 16
+#define USB_TXFIFOADD_ADDR_32   0x00000003  // 32
+#define USB_TXFIFOADD_ADDR_64   0x00000004  // 64
+#define USB_TXFIFOADD_ADDR_128  0x00000005  // 128
+#define USB_TXFIFOADD_ADDR_256  0x00000006  // 256
+#define USB_TXFIFOADD_ADDR_512  0x00000007  // 512
+#define USB_TXFIFOADD_ADDR_1024 0x00000008  // 1024
+#define USB_TXFIFOADD_ADDR_2048 0x00000009  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFIFOADD
+// register.
+//
+//*****************************************************************************
+#define USB_RXFIFOADD_ADDR_M    0x00001FFF  // Transmit/Receive Start Address.
+#define USB_RXFIFOADD_ADDR_0    0x00000000  // 0
+#define USB_RXFIFOADD_ADDR_8    0x00000001  // 8
+#define USB_RXFIFOADD_ADDR_16   0x00000002  // 16
+#define USB_RXFIFOADD_ADDR_32   0x00000003  // 32
+#define USB_RXFIFOADD_ADDR_64   0x00000004  // 64
+#define USB_RXFIFOADD_ADDR_128  0x00000005  // 128
+#define USB_RXFIFOADD_ADDR_256  0x00000006  // 256
+#define USB_RXFIFOADD_ADDR_512  0x00000007  // 512
+#define USB_RXFIFOADD_ADDR_1024 0x00000008  // 1024
+#define USB_RXFIFOADD_ADDR_2048 0x00000009  // 2048
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CONTIM register.
+//
+//*****************************************************************************
+#define USB_CONTIM_WTCON_M      0x000000F0  // Connect Wait.
+#define USB_CONTIM_WTID_M       0x0000000F  // Wait ID.
+#define USB_CONTIM_WTCON_S      4
+#define USB_CONTIM_WTID_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VPLEN register.
+//
+//*****************************************************************************
+#define USB_VPLEN_VPLEN_M       0x000000FF  // VBus Pulse Length.
+#define USB_VPLEN_VPLEN_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_FSEOF register.
+//
+//*****************************************************************************
+#define USB_FSEOF_FSEOFG_M      0x000000FF  // Full-Speed End-of-Frame Gap.
+#define USB_FSEOF_FSEOFG_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_LSEOF register.
+//
+//*****************************************************************************
+#define USB_LSEOF_LSEOFG_M      0x000000FF  // Low-Speed End-of-Frame Gap.
+#define USB_LSEOF_LSEOFG_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR0
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR0_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR0_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR0
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR0_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR0_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR0_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT0
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT0_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT0_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR1_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR1_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR1_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR1_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR1_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT1
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT1_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT1_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR1_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR1_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR1
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR1_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR1_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR1_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT1
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT1_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT1_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR2_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR2_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR2_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR2_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR2_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT2
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT2_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT2_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR2_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR2_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR2
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR2_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR2_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR2_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT2
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT2_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT2_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR3_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR3_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR3_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR3_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR3_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT3
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT3_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT3_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR3_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR3_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR3
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR3_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR3_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR3_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT3
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT3_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT3_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR4_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR4_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR4_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR4_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR4_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT4
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT4_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT4_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR4_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR4_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR4
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR4_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR4_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR4_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT4
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT4_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT4_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR5_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR5_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR5_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR5_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR5_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT5
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT5_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT5_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR5_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR5_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR5
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR5_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR5_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR5_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT5
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT5_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT5_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR6_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR6_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR6_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR6_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR6_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT6
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT6_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT6_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR6_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR6_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR6
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR6_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR6_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR6_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT6
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT6_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT6_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR7_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR7_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR7_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR7_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR7_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT7
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT7_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT7_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR7_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR7_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR7
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR7_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR7_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR7_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT7
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT7_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT7_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR8_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR8_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR8_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR8_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR8_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT8
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT8_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT8_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR8_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR8_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR8
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR8_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR8_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR8_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT8
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT8_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT8_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR9_ADDR_M  0x0000007F  // Device Address.
+#define USB_TXFUNCADDR9_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR9_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR9_ADDR_M   0x0000007F  // Hub Address.
+#define USB_TXHUBADDR9_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT9
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT9_PORT_M   0x0000007F  // Hub Port.
+#define USB_TXHUBPORT9_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR9_ADDR_M  0x0000007F  // Device Address.
+#define USB_RXFUNCADDR9_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR9
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR9_MULTTRAN 0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR9_ADDR_M   0x0000007F  // Hub Address.
+#define USB_RXHUBADDR9_ADDR_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT9
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT9_PORT_M   0x0000007F  // Hub Port.
+#define USB_RXHUBPORT9_PORT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR10_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR10_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR10_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR10_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR10_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT10
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT10_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT10_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR10_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR10_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR10
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR10_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR10_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR10_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT10
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT10_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT10_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR11_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR11_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR11_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR11_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR11_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT11
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT11_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT11_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR11_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR11_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR11
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR11_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR11_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR11_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT11
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT11_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT11_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR12_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR12_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR12_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR12_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR12_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT12
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT12_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT12_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR12_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR12_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR12
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR12_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR12_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR12_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT12
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT12_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT12_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR13_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR13_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR13_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR13_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR13_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT13
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT13_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT13_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR13_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR13_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR13
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR13_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR13_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR13_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT13
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT13_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT13_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR14_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR14_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR14_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR14_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR14_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT14
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT14_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT14_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR14_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR14_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR14
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR14_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR14_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR14_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT14
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT14_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT14_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXFUNCADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_TXFUNCADDR15_ADDR_M 0x0000007F  // Device Address.
+#define USB_TXFUNCADDR15_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBADDR15_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_TXHUBADDR15_ADDR_M  0x0000007F  // Hub Address.
+#define USB_TXHUBADDR15_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXHUBPORT15
+// register.
+//
+//*****************************************************************************
+#define USB_TXHUBPORT15_PORT_M  0x0000007F  // Hub Port.
+#define USB_TXHUBPORT15_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXFUNCADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_RXFUNCADDR15_ADDR_M 0x0000007F  // Device Address.
+#define USB_RXFUNCADDR15_ADDR_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBADDR15
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBADDR15_MULTTRAN \
+                                0x00000080  // Multiple Translators.
+#define USB_RXHUBADDR15_ADDR_M  0x0000007F  // Hub Address.
+#define USB_RXHUBADDR15_ADDR_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXHUBPORT15
+// register.
+//
+//*****************************************************************************
+#define USB_RXHUBPORT15_PORT_M  0x0000007F  // Hub Port.
+#define USB_RXHUBPORT15_PORT_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CSRL0 register.
+//
+//*****************************************************************************
+#define USB_CSRL0_NAKTO         0x00000080  // NAK Timeout.
+#define USB_CSRL0_SETENDC       0x00000080  // Setup End Clear.
+#define USB_CSRL0_STATUS        0x00000040  // Status Packet.
+#define USB_CSRL0_RXRDYC        0x00000040  // RXRDY Clear.
+#define USB_CSRL0_REQPKT        0x00000020  // Request Packet.
+#define USB_CSRL0_STALL         0x00000020  // Send Stall.
+#define USB_CSRL0_SETEND        0x00000010  // Setup End.
+#define USB_CSRL0_ERROR         0x00000010  // Error.
+#define USB_CSRL0_DATAEND       0x00000008  // Data End.
+#define USB_CSRL0_SETUP         0x00000008  // Setup Packet.
+#define USB_CSRL0_STALLED       0x00000004  // Endpoint Stalled.
+#define USB_CSRL0_TXRDY         0x00000002  // Transmit Packet Ready.
+#define USB_CSRL0_RXRDY         0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_CSRH0 register.
+//
+//*****************************************************************************
+#define USB_CSRH0_DTWE          0x00000004  // Data Toggle Write Enable.
+#define USB_CSRH0_DT            0x00000002  // Data Toggle.
+#define USB_CSRH0_FLUSH         0x00000001  // Flush FIFO.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_COUNT0 register.
+//
+//*****************************************************************************
+#define USB_COUNT0_COUNT_M      0x0000007F  // Count.
+#define USB_COUNT0_COUNT_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TYPE0 register.
+//
+//*****************************************************************************
+#define USB_TYPE0_SPEED_M       0x000000C0  // Operating Speed.
+#define USB_TYPE0_SPEED_FULL    0x00000080  // Full
+#define USB_TYPE0_SPEED_LOW     0x000000C0  // Low
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_NAKLMT register.
+//
+//*****************************************************************************
+#define USB_NAKLMT_NAKLMT_M     0x0000001F  // EP0 NAK Limit.
+#define USB_NAKLMT_NAKLMT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP1 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP1_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP1_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL1 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL1_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL1_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL1_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL1_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL1_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL1_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL1_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL1_ERROR       0x00000004  // Error.
+#define USB_TXCSRL1_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL1_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL1_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH1 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH1_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH1_ISO         0x00000040  // ISO.
+#define USB_TXCSRH1_MODE        0x00000020  // Mode.
+#define USB_TXCSRH1_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH1_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH1_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH1_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH1_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP1 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP1_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP1_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL1 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL1_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL1_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL1_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL1_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL1_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL1_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL1_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL1_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL1_ERROR       0x00000004  // Error.
+#define USB_RXCSRL1_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL1_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH1 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH1_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH1_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH1_ISO         0x00000040  // ISO.
+#define USB_RXCSRH1_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH1_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH1_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH1_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH1_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH1_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH1_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT1 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT1_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT1_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE1 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE1_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE1_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE1_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE1_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE1_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE1_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE1_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE1_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE1_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE1_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE1_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL1
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL1_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL1_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL1_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL1_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE1 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE1_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE1_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE1_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE1_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE1_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE1_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE1_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE1_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE1_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE1_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE1_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL1
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL1_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL1_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL1_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL1_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP2 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP2_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP2_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL2 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL2_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL2_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL2_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL2_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL2_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL2_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL2_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL2_ERROR       0x00000004  // Error.
+#define USB_TXCSRL2_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL2_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL2_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH2 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH2_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH2_ISO         0x00000040  // ISO.
+#define USB_TXCSRH2_MODE        0x00000020  // Mode.
+#define USB_TXCSRH2_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH2_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH2_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH2_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH2_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP2 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP2_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP2_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL2 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL2_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL2_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL2_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL2_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL2_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL2_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL2_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL2_ERROR       0x00000004  // Error.
+#define USB_RXCSRL2_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL2_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL2_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH2 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH2_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH2_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH2_ISO         0x00000040  // ISO.
+#define USB_RXCSRH2_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH2_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH2_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH2_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH2_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH2_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH2_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT2 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT2_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT2_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE2 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE2_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE2_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE2_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE2_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE2_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE2_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE2_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE2_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE2_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE2_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE2_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL2
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL2_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL2_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL2_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL2_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE2 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE2_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE2_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE2_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE2_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE2_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE2_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE2_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE2_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE2_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE2_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE2_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL2
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL2_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL2_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL2_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL2_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP3 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP3_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP3_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL3 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL3_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL3_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL3_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL3_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL3_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL3_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL3_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL3_ERROR       0x00000004  // Error.
+#define USB_TXCSRL3_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL3_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL3_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH3 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH3_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH3_ISO         0x00000040  // ISO.
+#define USB_TXCSRH3_MODE        0x00000020  // Mode.
+#define USB_TXCSRH3_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH3_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH3_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH3_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH3_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP3 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP3_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP3_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL3 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL3_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL3_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL3_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL3_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL3_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL3_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL3_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL3_ERROR       0x00000004  // Error.
+#define USB_RXCSRL3_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL3_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL3_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH3 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH3_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH3_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH3_ISO         0x00000040  // ISO.
+#define USB_RXCSRH3_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH3_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH3_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH3_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH3_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH3_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH3_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT3 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT3_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT3_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE3 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE3_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE3_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE3_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE3_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE3_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE3_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE3_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE3_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE3_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE3_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE3_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL3
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL3_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL3_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL3_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL3_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE3 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE3_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE3_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE3_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE3_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE3_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE3_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE3_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE3_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE3_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE3_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE3_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL3
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL3_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL3_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL3_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL3_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP4 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP4_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP4_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL4 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL4_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL4_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL4_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL4_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL4_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL4_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL4_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL4_ERROR       0x00000004  // Error.
+#define USB_TXCSRL4_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL4_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL4_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH4 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH4_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH4_ISO         0x00000040  // ISO.
+#define USB_TXCSRH4_MODE        0x00000020  // Mode.
+#define USB_TXCSRH4_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH4_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH4_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH4_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH4_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP4 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP4_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP4_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL4 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL4_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL4_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL4_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL4_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL4_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL4_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL4_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL4_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL4_ERROR       0x00000004  // Error.
+#define USB_RXCSRL4_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL4_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH4 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH4_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH4_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH4_ISO         0x00000040  // ISO.
+#define USB_RXCSRH4_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH4_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH4_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH4_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH4_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH4_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH4_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT4 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT4_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT4_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE4 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE4_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE4_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE4_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE4_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE4_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE4_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE4_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE4_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE4_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE4_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE4_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL4
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL4_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL4_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL4_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL4_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE4 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE4_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE4_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE4_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE4_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE4_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE4_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE4_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE4_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE4_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE4_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE4_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL4
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL4_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL4_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL4_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL4_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP5 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP5_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP5_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL5 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL5_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL5_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL5_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL5_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL5_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL5_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL5_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL5_ERROR       0x00000004  // Error.
+#define USB_TXCSRL5_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL5_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL5_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH5 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH5_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH5_ISO         0x00000040  // ISO.
+#define USB_TXCSRH5_MODE        0x00000020  // Mode.
+#define USB_TXCSRH5_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH5_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH5_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH5_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH5_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP5 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP5_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP5_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL5 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL5_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL5_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL5_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL5_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL5_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL5_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL5_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL5_ERROR       0x00000004  // Error.
+#define USB_RXCSRL5_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL5_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL5_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH5 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH5_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH5_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH5_ISO         0x00000040  // ISO.
+#define USB_RXCSRH5_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH5_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH5_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH5_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH5_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH5_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH5_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT5 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT5_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT5_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE5 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE5_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE5_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE5_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE5_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE5_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE5_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE5_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE5_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE5_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE5_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE5_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL5
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL5_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL5_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL5_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL5_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE5 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE5_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE5_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE5_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE5_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE5_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE5_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE5_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE5_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE5_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE5_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE5_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL5
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL5_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL5_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL5_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL5_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP6 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP6_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP6_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL6 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL6_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL6_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL6_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL6_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL6_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL6_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL6_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL6_ERROR       0x00000004  // Error.
+#define USB_TXCSRL6_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL6_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL6_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH6 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH6_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH6_ISO         0x00000040  // ISO.
+#define USB_TXCSRH6_MODE        0x00000020  // Mode.
+#define USB_TXCSRH6_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH6_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH6_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH6_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH6_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP6 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP6_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP6_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL6 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL6_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL6_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL6_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL6_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL6_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL6_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL6_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL6_ERROR       0x00000004  // Error.
+#define USB_RXCSRL6_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL6_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL6_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH6 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH6_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH6_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH6_ISO         0x00000040  // ISO.
+#define USB_RXCSRH6_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH6_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH6_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH6_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH6_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH6_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH6_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT6 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT6_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT6_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE6 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE6_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE6_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE6_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE6_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE6_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE6_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE6_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE6_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE6_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE6_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE6_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL6
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL6_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL6_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL6_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL6_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE6 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE6_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE6_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE6_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE6_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE6_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE6_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE6_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE6_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE6_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE6_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE6_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL6
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL6_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL6_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL6_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL6_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP7 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP7_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP7_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL7 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL7_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL7_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL7_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL7_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL7_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL7_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL7_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL7_ERROR       0x00000004  // Error.
+#define USB_TXCSRL7_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL7_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL7_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH7 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH7_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH7_ISO         0x00000040  // ISO.
+#define USB_TXCSRH7_MODE        0x00000020  // Mode.
+#define USB_TXCSRH7_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH7_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH7_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH7_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH7_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP7 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP7_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP7_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL7 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL7_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL7_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL7_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL7_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL7_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL7_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL7_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL7_ERROR       0x00000004  // Error.
+#define USB_RXCSRL7_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL7_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL7_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH7 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH7_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH7_ISO         0x00000040  // ISO.
+#define USB_RXCSRH7_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH7_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH7_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH7_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH7_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH7_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH7_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH7_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT7 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT7_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT7_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE7 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE7_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE7_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE7_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE7_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE7_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE7_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE7_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE7_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE7_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE7_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE7_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL7
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL7_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL7_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL7_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL7_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE7 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE7_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE7_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE7_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE7_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE7_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE7_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE7_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE7_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE7_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE7_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE7_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL7
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL7_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL7_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL7_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL7_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP8 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP8_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP8_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL8 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL8_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL8_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL8_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL8_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL8_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL8_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL8_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL8_ERROR       0x00000004  // Error.
+#define USB_TXCSRL8_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL8_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL8_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH8 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH8_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH8_ISO         0x00000040  // ISO.
+#define USB_TXCSRH8_MODE        0x00000020  // Mode.
+#define USB_TXCSRH8_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH8_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH8_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH8_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH8_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP8 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP8_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP8_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL8 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL8_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL8_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL8_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL8_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL8_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL8_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL8_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL8_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL8_ERROR       0x00000004  // Error.
+#define USB_RXCSRL8_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL8_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH8 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH8_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH8_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH8_ISO         0x00000040  // ISO.
+#define USB_RXCSRH8_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH8_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH8_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH8_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH8_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH8_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH8_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT8 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT8_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT8_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE8 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE8_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE8_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE8_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE8_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE8_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE8_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE8_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE8_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE8_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE8_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE8_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL8
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL8_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL8_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL8_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL8_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE8 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE8_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE8_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE8_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE8_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE8_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE8_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE8_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE8_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE8_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE8_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE8_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL8
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL8_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL8_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL8_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL8_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP9 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP9_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_TXMAXP9_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL9 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL9_INCTX       0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL9_NAKTO       0x00000080  // NAK Timeout 
+#define USB_TXCSRL9_CLRDT       0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL9_STALLED     0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL9_SETUP       0x00000010  // Setup Packet.
+#define USB_TXCSRL9_STALL       0x00000010  // Send Stall.
+#define USB_TXCSRL9_FLUSH       0x00000008  // Flush FIFO.
+#define USB_TXCSRL9_ERROR       0x00000004  // Error.
+#define USB_TXCSRL9_UNDRN       0x00000004  // Underrun.
+#define USB_TXCSRL9_FIFONE      0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL9_TXRDY       0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH9 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH9_AUTOSET     0x00000080  // Auto Set.
+#define USB_TXCSRH9_ISO         0x00000040  // ISO.
+#define USB_TXCSRH9_MODE        0x00000020  // Mode.
+#define USB_TXCSRH9_DMAEN       0x00000010  // DMA Request Enable.
+#define USB_TXCSRH9_FDT         0x00000008  // Force Data Toggle.
+#define USB_TXCSRH9_DMAMOD      0x00000004  // DMA Request Mode.
+#define USB_TXCSRH9_DTWE        0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH9_DT          0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP9 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP9_MAXLOAD_M   0x000007FF  // Maximum Payload.
+#define USB_RXMAXP9_MAXLOAD_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL9 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL9_CLRDT       0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL9_STALLED     0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL9_STALL       0x00000020  // Send Stall.
+#define USB_RXCSRL9_REQPKT      0x00000020  // Request Packet.
+#define USB_RXCSRL9_FLUSH       0x00000010  // Flush FIFO.
+#define USB_RXCSRL9_DATAERR     0x00000008  // Data Error.
+#define USB_RXCSRL9_NAKTO       0x00000008  //  NAK Timeout.
+#define USB_RXCSRL9_ERROR       0x00000004  // Error.
+#define USB_RXCSRL9_OVER        0x00000004  // Overrun.
+#define USB_RXCSRL9_FULL        0x00000002  // FIFO Full.
+#define USB_RXCSRL9_RXRDY       0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH9 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH9_AUTOCL      0x00000080  // Auto Clear.
+#define USB_RXCSRH9_ISO         0x00000040  // ISO.
+#define USB_RXCSRH9_AUTORQ      0x00000040  // Auto Request.
+#define USB_RXCSRH9_DMAEN       0x00000020  // DMA Request Enable.
+#define USB_RXCSRH9_PIDERR      0x00000010  //  PID Error.
+#define USB_RXCSRH9_DISNYET     0x00000010  // Disable NYET 
+#define USB_RXCSRH9_DMAMOD      0x00000008  // DMA Request Mode.
+#define USB_RXCSRH9_DTWE        0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH9_DT          0x00000002  // Data Toggle.
+#define USB_RXCSRH9_INCRX       0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT9 register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT9_COUNT_M    0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT9_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE9 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE9_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_TXTYPE9_SPEED_DFLT  0x00000000  // Default
+#define USB_TXTYPE9_SPEED_FULL  0x00000080  // Full
+#define USB_TXTYPE9_SPEED_LOW   0x000000C0  // Low
+#define USB_TXTYPE9_PROTO_M     0x00000030  // Protocol.
+#define USB_TXTYPE9_PROTO_CTRL  0x00000000  // Control
+#define USB_TXTYPE9_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_TXTYPE9_PROTO_BULK  0x00000020  // Bulk
+#define USB_TXTYPE9_PROTO_INT   0x00000030  // Interrupt
+#define USB_TXTYPE9_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE9_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL9
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL9_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL9_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL9_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL9_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE9 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE9_SPEED_M     0x000000C0  // Operating Speed.
+#define USB_RXTYPE9_SPEED_DFLT  0x00000000  // Default
+#define USB_RXTYPE9_SPEED_FULL  0x00000080  // Full
+#define USB_RXTYPE9_SPEED_LOW   0x000000C0  // Low
+#define USB_RXTYPE9_PROTO_M     0x00000030  // Protocol.
+#define USB_RXTYPE9_PROTO_CTRL  0x00000000  // Control
+#define USB_RXTYPE9_PROTO_ISOC  0x00000010  // Isochronous
+#define USB_RXTYPE9_PROTO_BULK  0x00000020  // Bulk
+#define USB_RXTYPE9_PROTO_INT   0x00000030  // Interrupt
+#define USB_RXTYPE9_TEP_M       0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE9_TEP_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL9
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL9_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL9_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL9_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL9_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP10 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP10_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP10_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL10 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL10_NAKTO      0x00000080  // NAK Timeout 
+#define USB_TXCSRL10_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL10_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL10_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL10_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL10_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL10_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL10_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL10_ERROR      0x00000004  // Error.
+#define USB_TXCSRL10_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL10_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH10 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH10_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH10_ISO        0x00000040  // ISO.
+#define USB_TXCSRH10_MODE       0x00000020  // Mode.
+#define USB_TXCSRH10_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH10_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH10_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH10_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH10_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP10 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP10_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP10_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL10 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL10_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL10_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL10_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL10_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL10_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL10_NAKTO      0x00000008  //  NAK Timeout.
+#define USB_RXCSRL10_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL10_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL10_ERROR      0x00000004  // Error.
+#define USB_RXCSRL10_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL10_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH10 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH10_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH10_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH10_ISO        0x00000040  // ISO.
+#define USB_RXCSRH10_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH10_PIDERR     0x00000010  //  PID Error.
+#define USB_RXCSRH10_DISNYET    0x00000010  // Disable NYET 
+#define USB_RXCSRH10_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH10_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH10_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH10_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT10
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT10_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT10_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE10 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE10_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE10_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE10_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE10_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE10_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE10_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE10_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE10_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE10_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE10_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE10_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL10
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL10_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL10_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL10_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL10_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE10 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE10_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE10_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE10_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE10_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE10_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE10_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE10_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE10_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE10_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE10_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE10_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL10
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL10_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL10_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL10_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL10_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP11 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP11_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP11_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL11 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL11_NAKTO      0x00000080  // NAK Timeout 
+#define USB_TXCSRL11_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL11_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL11_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL11_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL11_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL11_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL11_ERROR      0x00000004  // Error.
+#define USB_TXCSRL11_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL11_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL11_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH11 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH11_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH11_ISO        0x00000040  // ISO.
+#define USB_TXCSRH11_MODE       0x00000020  // Mode.
+#define USB_TXCSRH11_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH11_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH11_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH11_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH11_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP11 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP11_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP11_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL11 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL11_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL11_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL11_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL11_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL11_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL11_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL11_NAKTO      0x00000008  //  NAK Timeout.
+#define USB_RXCSRL11_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL11_ERROR      0x00000004  // Error.
+#define USB_RXCSRL11_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL11_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH11 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH11_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH11_ISO        0x00000040  // ISO.
+#define USB_RXCSRH11_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH11_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH11_DISNYET    0x00000010  // Disable NYET 
+#define USB_RXCSRH11_PIDERR     0x00000010  //  PID Error.
+#define USB_RXCSRH11_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH11_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH11_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH11_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT11
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT11_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT11_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE11 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE11_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE11_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE11_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE11_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE11_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE11_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE11_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE11_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE11_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE11_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE11_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL11
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL11_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL11_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL11_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL11_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE11 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE11_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE11_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE11_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE11_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE11_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE11_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE11_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE11_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE11_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE11_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE11_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL11
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL11_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL11_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL11_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL11_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP12 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP12_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP12_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL12 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL12_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL12_NAKTO      0x00000080  // NAK Timeout 
+#define USB_TXCSRL12_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL12_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL12_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL12_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL12_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL12_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL12_ERROR      0x00000004  // Error.
+#define USB_TXCSRL12_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL12_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH12 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH12_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH12_ISO        0x00000040  // ISO.
+#define USB_TXCSRH12_MODE       0x00000020  // Mode.
+#define USB_TXCSRH12_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH12_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH12_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH12_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH12_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP12 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP12_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP12_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL12 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL12_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL12_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL12_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL12_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL12_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL12_NAKTO      0x00000008  //  NAK Timeout.
+#define USB_RXCSRL12_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL12_ERROR      0x00000004  // Error.
+#define USB_RXCSRL12_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL12_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL12_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH12 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH12_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH12_ISO        0x00000040  // ISO.
+#define USB_RXCSRH12_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH12_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH12_PIDERR     0x00000010  //  PID Error.
+#define USB_RXCSRH12_DISNYET    0x00000010  // Disable NYET 
+#define USB_RXCSRH12_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH12_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH12_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH12_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT12
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT12_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT12_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE12 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE12_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE12_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE12_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE12_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE12_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE12_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE12_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE12_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE12_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE12_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE12_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL12
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL12_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL12_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL12_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL12_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE12 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE12_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE12_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE12_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE12_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE12_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE12_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE12_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE12_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE12_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE12_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE12_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL12
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL12_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL12_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL12_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL12_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP13 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP13_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP13_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL13 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL13_NAKTO      0x00000080  // NAK Timeout 
+#define USB_TXCSRL13_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL13_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL13_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL13_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL13_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL13_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL13_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL13_ERROR      0x00000004  // Error.
+#define USB_TXCSRL13_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL13_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH13 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH13_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH13_ISO        0x00000040  // ISO.
+#define USB_TXCSRH13_MODE       0x00000020  // Mode.
+#define USB_TXCSRH13_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH13_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH13_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH13_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH13_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP13 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP13_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP13_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL13 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL13_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL13_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL13_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL13_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL13_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL13_NAKTO      0x00000008  //  NAK Timeout.
+#define USB_RXCSRL13_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL13_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL13_ERROR      0x00000004  // Error.
+#define USB_RXCSRL13_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL13_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH13 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH13_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH13_ISO        0x00000040  // ISO.
+#define USB_RXCSRH13_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH13_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH13_DISNYET    0x00000010  // Disable NYET 
+#define USB_RXCSRH13_PIDERR     0x00000010  //  PID Error.
+#define USB_RXCSRH13_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH13_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH13_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH13_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT13
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT13_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT13_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE13 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE13_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE13_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE13_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE13_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE13_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE13_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE13_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE13_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE13_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE13_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE13_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL13
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL13_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL13_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL13_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL13_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE13 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE13_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE13_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE13_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE13_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE13_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE13_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE13_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE13_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE13_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE13_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE13_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL13
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL13_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL13_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL13_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL13_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP14 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP14_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP14_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL14 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL14_NAKTO      0x00000080  // NAK Timeout 
+#define USB_TXCSRL14_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL14_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL14_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL14_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL14_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL14_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL14_ERROR      0x00000004  // Error.
+#define USB_TXCSRL14_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL14_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL14_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH14 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH14_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH14_ISO        0x00000040  // ISO.
+#define USB_TXCSRH14_MODE       0x00000020  // Mode.
+#define USB_TXCSRH14_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH14_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH14_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH14_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH14_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP14 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP14_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP14_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL14 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL14_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL14_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL14_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL14_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL14_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL14_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL14_NAKTO      0x00000008  //  NAK Timeout.
+#define USB_RXCSRL14_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL14_ERROR      0x00000004  // Error.
+#define USB_RXCSRL14_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL14_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH14 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH14_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH14_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH14_ISO        0x00000040  // ISO.
+#define USB_RXCSRH14_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH14_PIDERR     0x00000010  //  PID Error.
+#define USB_RXCSRH14_DISNYET    0x00000010  // Disable NYET 
+#define USB_RXCSRH14_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH14_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH14_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH14_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT14
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT14_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT14_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE14 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE14_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE14_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE14_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE14_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE14_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE14_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE14_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE14_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE14_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE14_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE14_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL14
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL14_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL14_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL14_TXPOLL_S \
+                                0
+#define USB_TXINTERVAL14_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE14 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE14_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE14_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE14_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE14_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE14_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE14_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE14_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE14_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE14_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE14_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE14_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL14
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL14_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL14_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL14_NAKLMT_S \
+                                0
+#define USB_RXINTERVAL14_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXMAXP15 register.
+//
+//*****************************************************************************
+#define USB_TXMAXP15_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_TXMAXP15_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRL15 register.
+//
+//*****************************************************************************
+#define USB_TXCSRL15_NAKTO      0x00000080  // NAK Timeout 
+#define USB_TXCSRL15_INCTX      0x00000080  // Incomplete Transmit.
+#define USB_TXCSRL15_CLRDT      0x00000040  // Clear Data Toggle.
+#define USB_TXCSRL15_STALLED    0x00000020  // Endpoint Stalled.
+#define USB_TXCSRL15_SETUP      0x00000010  // Setup Packet.
+#define USB_TXCSRL15_STALL      0x00000010  // Send Stall.
+#define USB_TXCSRL15_FLUSH      0x00000008  // Flush FIFO.
+#define USB_TXCSRL15_UNDRN      0x00000004  // Underrun.
+#define USB_TXCSRL15_ERROR      0x00000004  // Error.
+#define USB_TXCSRL15_FIFONE     0x00000002  // FIFO Not Empty.
+#define USB_TXCSRL15_TXRDY      0x00000001  // Transmit Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXCSRH15 register.
+//
+//*****************************************************************************
+#define USB_TXCSRH15_AUTOSET    0x00000080  // Auto Set.
+#define USB_TXCSRH15_ISO        0x00000040  // ISO.
+#define USB_TXCSRH15_MODE       0x00000020  // Mode.
+#define USB_TXCSRH15_DMAEN      0x00000010  // DMA Request Enable.
+#define USB_TXCSRH15_FDT        0x00000008  // Force Data Toggle.
+#define USB_TXCSRH15_DMAMOD     0x00000004  // DMA Request Mode.
+#define USB_TXCSRH15_DTWE       0x00000002  // Data Toggle Write Enable.
+#define USB_TXCSRH15_DT         0x00000001  // Data Toggle.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXMAXP15 register.
+//
+//*****************************************************************************
+#define USB_RXMAXP15_MAXLOAD_M  0x000007FF  // Maximum Payload.
+#define USB_RXMAXP15_MAXLOAD_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRL15 register.
+//
+//*****************************************************************************
+#define USB_RXCSRL15_CLRDT      0x00000080  // Clear Data Toggle.
+#define USB_RXCSRL15_STALLED    0x00000040  // Endpoint Stalled.
+#define USB_RXCSRL15_STALL      0x00000020  // Send Stall.
+#define USB_RXCSRL15_REQPKT     0x00000020  // Request Packet.
+#define USB_RXCSRL15_FLUSH      0x00000010  // Flush FIFO.
+#define USB_RXCSRL15_DATAERR    0x00000008  // Data Error.
+#define USB_RXCSRL15_NAKTO      0x00000008  //  NAK Timeout.
+#define USB_RXCSRL15_ERROR      0x00000004  // Error.
+#define USB_RXCSRL15_OVER       0x00000004  // Overrun.
+#define USB_RXCSRL15_FULL       0x00000002  // FIFO Full.
+#define USB_RXCSRL15_RXRDY      0x00000001  // Receive Packet Ready.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCSRH15 register.
+//
+//*****************************************************************************
+#define USB_RXCSRH15_AUTOCL     0x00000080  // Auto Clear.
+#define USB_RXCSRH15_AUTORQ     0x00000040  // Auto Request.
+#define USB_RXCSRH15_ISO        0x00000040  // ISO.
+#define USB_RXCSRH15_DMAEN      0x00000020  // DMA Request Enable.
+#define USB_RXCSRH15_PIDERR     0x00000010  //  PID Error.
+#define USB_RXCSRH15_DISNYET    0x00000010  // Disable NYET 
+#define USB_RXCSRH15_DMAMOD     0x00000008  // DMA Request Mode.
+#define USB_RXCSRH15_DTWE       0x00000004  // Data Toggle Write Enable.
+#define USB_RXCSRH15_DT         0x00000002  // Data Toggle.
+#define USB_RXCSRH15_INCRX      0x00000001  // Incomplete Receive.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXCOUNT15
+// register.
+//
+//*****************************************************************************
+#define USB_RXCOUNT15_COUNT_M   0x00001FFF  // Receive Packet Count.
+#define USB_RXCOUNT15_COUNT_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXTYPE15 register.
+//
+//*****************************************************************************
+#define USB_TXTYPE15_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_TXTYPE15_SPEED_DFLT 0x00000000  // Default
+#define USB_TXTYPE15_SPEED_FULL 0x00000080  // Full
+#define USB_TXTYPE15_SPEED_LOW  0x000000C0  // Low
+#define USB_TXTYPE15_PROTO_M    0x00000030  // Protocol.
+#define USB_TXTYPE15_PROTO_CTRL 0x00000000  // Control
+#define USB_TXTYPE15_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_TXTYPE15_PROTO_BULK 0x00000020  // Bulk
+#define USB_TXTYPE15_PROTO_INT  0x00000030  // Interrupt
+#define USB_TXTYPE15_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_TXTYPE15_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXINTERVAL15
+// register.
+//
+//*****************************************************************************
+#define USB_TXINTERVAL15_TXPOLL_M \
+                                0x000000FF  // TX Polling 
+#define USB_TXINTERVAL15_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_TXINTERVAL15_NAKLMT_S \
+                                0
+#define USB_TXINTERVAL15_TXPOLL_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXTYPE15 register.
+//
+//*****************************************************************************
+#define USB_RXTYPE15_SPEED_M    0x000000C0  // Operating Speed.
+#define USB_RXTYPE15_SPEED_DFLT 0x00000000  // Default
+#define USB_RXTYPE15_SPEED_FULL 0x00000080  // Full
+#define USB_RXTYPE15_SPEED_LOW  0x000000C0  // Low
+#define USB_RXTYPE15_PROTO_M    0x00000030  // Protocol.
+#define USB_RXTYPE15_PROTO_CTRL 0x00000000  // Control
+#define USB_RXTYPE15_PROTO_ISOC 0x00000010  // Isochronous
+#define USB_RXTYPE15_PROTO_BULK 0x00000020  // Bulk
+#define USB_RXTYPE15_PROTO_INT  0x00000030  // Interrupt
+#define USB_RXTYPE15_TEP_M      0x0000000F  // Target Endpoint Number.
+#define USB_RXTYPE15_TEP_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXINTERVAL15
+// register.
+//
+//*****************************************************************************
+#define USB_RXINTERVAL15_TXPOLL_M \
+                                0x000000FF  // RX Polling 
+#define USB_RXINTERVAL15_NAKLMT_M \
+                                0x000000FF  //  NAK Limit.
+#define USB_RXINTERVAL15_TXPOLL_S \
+                                0
+#define USB_RXINTERVAL15_NAKLMT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT1
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT1_M       0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT1_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT2
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT2_M       0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT2_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT3
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT3_M       0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT3_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT4
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT4_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT4_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT5
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT5_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT5_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT6
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT6_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT6_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT7
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT7_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT7_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT8
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT8_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT8_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT9
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT9_COUNT_M 0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT9_COUNT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT10
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT10_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT10_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT11
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT11_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT11_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT12
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT12_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT12_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT13
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT13_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT13_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT14
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT14_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT14_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RQPKTCOUNT15
+// register.
+//
+//*****************************************************************************
+#define USB_RQPKTCOUNT15_COUNT_M \
+                                0x0000FFFF  // Block Transfer Packet Count.
+#define USB_RQPKTCOUNT15_COUNT_S \
+                                0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_RXDPKTBUFDIS
+// register.
+//
+//*****************************************************************************
+#define USB_RXDPKTBUFDIS_EP15   0x00008000  // EP15 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP14   0x00004000  // EP14 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP13   0x00002000  // EP13 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP12   0x00001000  // EP12 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP11   0x00000800  // EP11 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP10   0x00000400  // EP10 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP9    0x00000200  // EP9 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP8    0x00000100  // EP8 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP7    0x00000080  // EP7 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP6    0x00000040  // EP6 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP5    0x00000020  // EP5 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP4    0x00000010  // EP4 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP3    0x00000008  // EP3 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP2    0x00000004  // EP2 RX Double-Packet Buffer
+                                            // Disable.
+#define USB_RXDPKTBUFDIS_EP1    0x00000002  // EP1 RX Double-Packet Buffer
+                                            // Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_TXDPKTBUFDIS
+// register.
+//
+//*****************************************************************************
+#define USB_TXDPKTBUFDIS_EP15   0x00008000  // EP15 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP14   0x00004000  // EP14 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP13   0x00002000  // EP13 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP12   0x00001000  // EP12 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP11   0x00000800  // EP11 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP10   0x00000400  // EP10 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP9    0x00000200  // EP9 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP8    0x00000100  // EP8 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP7    0x00000080  // EP7 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP6    0x00000040  // EP6 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP5    0x00000020  // EP5 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP4    0x00000010  // EP4 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP3    0x00000008  // EP3 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP2    0x00000004  // EP2 TX Double-Packet Buffer
+                                            // Disable.
+#define USB_TXDPKTBUFDIS_EP1    0x00000002  // EP1 TX Double-Packet Buffer
+                                            // Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPC register.
+//
+//*****************************************************************************
+#define USB_EPC_PFLTACT_M       0x00000300  // Power Fault Action.
+#define USB_EPC_PFLTACT_UNCHG   0x00000000  // Unchanged
+#define USB_EPC_PFLTACT_TRIS    0x00000100  // Tristate
+#define USB_EPC_PFLTACT_LOW     0x00000200  // Low
+#define USB_EPC_PFLTACT_HIGH    0x00000300  // High
+#define USB_EPC_PFLTAEN         0x00000040  // Power Fault Action Enable.
+#define USB_EPC_PFLTSEN_HIGH    0x00000020  // Power Fault Sense.
+#define USB_EPC_PFLTEN          0x00000010  // Power Fault Input Enable.
+#define USB_EPC_EPENDE          0x00000004  // EPEN Drive Enable.
+#define USB_EPC_EPEN_M          0x00000003  // External Power Supply Enable
+                                            // Configuration.
+#define USB_EPC_EPEN_LOW        0x00000000  // Power Enable Active Low
+#define USB_EPC_EPEN_HIGH       0x00000001  // Power Enable Active High
+#define USB_EPC_EPEN_VBLOW      0x00000002  // Power Enable High if VBUS Low
+#define USB_EPC_EPEN_VBHIGH     0x00000003  // Power Enable High if VBUS High
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCRIS register.
+//
+//*****************************************************************************
+#define USB_EPCRIS_PF           0x00000001  // USB Power Fault Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCIM register.
+//
+//*****************************************************************************
+#define USB_EPCIM_PF            0x00000001  // USB Power Fault Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPCISC register.
+//
+//*****************************************************************************
+#define USB_EPCISC_PF           0x00000001  // USB Power Fault Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRRIS register.
+//
+//*****************************************************************************
+#define USB_DRRIS_RESUME        0x00000001  // Resume Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRIM register.
+//
+//*****************************************************************************
+#define USB_DRIM_RESUME         0x00000001  // Resume Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_DRISC register.
+//
+//*****************************************************************************
+#define USB_DRISC_RESUME        0x00000001  // Resume Interrupt Status and
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDC register.
+//
+//*****************************************************************************
+#define USB_VDC_VBDEN           0x00000001  // VBUS Droop Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCRIS register.
+//
+//*****************************************************************************
+#define USB_VDCRIS_VD           0x00000001  // VBUS Droop Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCIM register.
+//
+//*****************************************************************************
+#define USB_VDCIM_VD            0x00000001  // VBUS Droop Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_VDCISC register.
+//
+//*****************************************************************************
+#define USB_VDCISC_VD           0x00000001  // VBUS Droop Interrupt Status and
+                                            // Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IDVRIS register.
+//
+//*****************************************************************************
+#define USB_IDVRIS_ID           0x00000001  // ID Valid Detect Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IDVIM register.
+//
+//*****************************************************************************
+#define USB_IDVIM_ID            0x00000001  // ID Valid Detect Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_IDVISC register.
+//
+//*****************************************************************************
+#define USB_IDVISC_ID           0x00000001  // ID Valid Detect Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the USB_O_EPS register.
+//
+//*****************************************************************************
+#define USB_EPS_DMAC_M          0x00000F00  // DMA C Select.
+#define USB_EPS_DMAB_M          0x000000F0  // DMA B Select.
+#define USB_EPS_DMAA_M          0x0000000F  // DMA A Select.
+#define USB_EPS_DMAB_S          4
+#define USB_EPS_DMAA_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXFIFO register.
+//
+//*****************************************************************************
+#define I2S_TXFIFO_M            0xFFFFFFFF  // TX Data.
+#define I2S_TXFIFO_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXFIFOCFG
+// register.
+//
+//*****************************************************************************
+#define I2S_TXFIFOCFG_CSS       0x00000002  // Compact Stereo Sample Size.
+#define I2S_TXFIFOCFG_LRS       0x00000001  // Left-Right Sample Indicator.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXCFG register.
+//
+//*****************************************************************************
+#define I2S_TXCFG_JST           0x20000000  // Justification of Output Data.
+#define I2S_TXCFG_DLY           0x10000000  // Data Delay.
+#define I2S_TXCFG_SCP           0x08000000  // SCLK Polarity.
+#define I2S_TXCFG_LRP           0x04000000  // Left/Right Clock Polarity.
+#define I2S_TXCFG_WM_M          0x03000000  // Write Mode.
+#define I2S_TXCFG_WM_DUAL       0x00000000  // Stereo mode
+#define I2S_TXCFG_WM_COMPACT    0x01000000  // Compact Stereo mode
+#define I2S_TXCFG_WM_MONO       0x02000000  // Mono mode
+#define I2S_TXCFG_FMT           0x00800000  // FIFO Empty.
+#define I2S_TXCFG_MSL           0x00400000  // SCLK Master/Slave.
+#define I2S_TXCFG_SSZ_M         0x0000FC00  // Sample Size.
+#define I2S_TXCFG_SDSZ_M        0x000003F0  // System Data Size.
+#define I2S_TXCFG_SSZ_S         10
+#define I2S_TXCFG_SDSZ_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXLIMIT register.
+//
+//*****************************************************************************
+#define I2S_TXLIMIT_LIMIT_M     0x0000001F  // FIFO Limit.
+#define I2S_TXLIMIT_LIMIT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXISM register.
+//
+//*****************************************************************************
+#define I2S_TXISM_FFI           0x00010000  // Transmit FIFO Service Request
+                                            // Interrupt.
+#define I2S_TXISM_FFM           0x00000001  // FIFO Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_TXLEV register.
+//
+//*****************************************************************************
+#define I2S_TXLEV_LEVEL_M       0x0000001F  // Number of Audio Samples.
+#define I2S_TXLEV_LEVEL_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXFIFO register.
+//
+//*****************************************************************************
+#define I2S_RXFIFO_M            0xFFFFFFFF  // RX Data.
+#define I2S_RXFIFO_S            0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXFIFOCFG
+// register.
+//
+//*****************************************************************************
+#define I2S_RXFIFOCFG_FMM       0x00000004  // FIFO Mono Mode.
+#define I2S_RXFIFOCFG_CSS       0x00000002  // Compact Stereo Sample Size.
+#define I2S_RXFIFOCFG_LRS       0x00000001  // Left-Right Sample Indicator.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXCFG register.
+//
+//*****************************************************************************
+#define I2S_RXCFG_JST           0x20000000  // Justification of Input Data.
+#define I2S_RXCFG_DLY           0x10000000  // Data Delay.
+#define I2S_RXCFG_SCP           0x08000000  // SCLK Polarity.
+#define I2S_RXCFG_LRP           0x04000000  // Left/Right Clock Polarity.
+#define I2S_RXCFG_RM            0x01000000  // Read Mode.
+#define I2S_RXCFG_MSL           0x00400000  // SCLK Master/Slave.
+#define I2S_RXCFG_SSZ_M         0x0000FC00  // Sample Size.
+#define I2S_RXCFG_SDSZ_M        0x000003F0  // System Data Size.
+#define I2S_RXCFG_SSZ_S         10
+#define I2S_RXCFG_SDSZ_S        4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXLIMIT register.
+//
+//*****************************************************************************
+#define I2S_RXLIMIT_LIMIT_M     0x0000001F  // FIFO Limit.
+#define I2S_RXLIMIT_LIMIT_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXISM register.
+//
+//*****************************************************************************
+#define I2S_RXISM_FFI           0x00010000  // Receive FIFO Service Request
+                                            // Interrupt.
+#define I2S_RXISM_FFM           0x00000001  // FIFO Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RXLEV register.
+//
+//*****************************************************************************
+#define I2S_RXLEV_LEVEL_M       0x0000001F  // Number of Audio Samples.
+#define I2S_RXLEV_LEVEL_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_CFG register.
+//
+//*****************************************************************************
+#define I2S_CFG_RXSLV           0x00000020  // When set, this bit configures
+                                            // the receiver to use the
+                                            // externally driven I2S0RXMCLK
+                                            // signal.
+#define I2S_CFG_TXSLV           0x00000010  // When set, this bit configures
+                                            // the transmitter to use the
+                                            // externally driven I2S0TXMCLK
+                                            // signal.
+#define I2S_CFG_RXEN            0x00000002  // Serial Receive Engine Enable.
+#define I2S_CFG_TXEN            0x00000001  // Serial Transmit Engine Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_IM register.
+//
+//*****************************************************************************
+#define I2S_IM_RXRE             0x00000020  // Receive FIFO Read Error.
+#define I2S_IM_RXFSR            0x00000010  // Receive FIFO Service Request.
+#define I2S_IM_TXWE             0x00000002  // Transmit FIFO Write Error.
+#define I2S_IM_TXFSR            0x00000001  // Transmit FIFO Service Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_RIS register.
+//
+//*****************************************************************************
+#define I2S_RIS_RXRE            0x00000020  // Receive FIFO Read Error.
+#define I2S_RIS_RXFSR           0x00000010  // Receive FIFO Service Request.
+#define I2S_RIS_TXWE            0x00000002  // Transmit FIFO Write Error.
+#define I2S_RIS_TXFSR           0x00000001  // Transmit FIFO Service Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_MIS register.
+//
+//*****************************************************************************
+#define I2S_MIS_RXRE            0x00000020  // Receive FIFO Read Error.
+#define I2S_MIS_RXFSR           0x00000010  // Receive FIFO Service Request.
+#define I2S_MIS_TXWE            0x00000002  // Transmit FIFO Write Error.
+#define I2S_MIS_TXFSR           0x00000001  // Transmit FIFO Service Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the I2S_O_IC register.
+//
+//*****************************************************************************
+#define I2S_IC_RXRE             0x00000020  // Receive FIFO Read Error.
+#define I2S_IC_TXWE             0x00000002  // Transmit FIFO Write Error.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_CFG register.
+//
+//*****************************************************************************
+#define EPI_CFG_BLKEN           0x00000010  // Block Enable.
+#define EPI_CFG_MODE_M          0x0000000F  // Mode Select.
+#define EPI_CFG_MODE_NONE       0x00000000  // General Purpose
+#define EPI_CFG_MODE_SDRAM      0x00000001  // Supports SDR SDRAM. Control,
+                                            // address, and data pins are
+                                            // configured using the EPISDRAMCFG
+                                            // and EPISDRAMCFG2 registers.
+#define EPI_CFG_MODE_HB8        0x00000002  // 8-Bit Host-Bus (HB8)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_BAUD register.
+//
+//*****************************************************************************
+#define EPI_BAUD_COUNT_M        0x0000FFFF  // Baud Rate Counter.
+#define EPI_BAUD_COUNT_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_SDRAMCFG register.
+//
+//*****************************************************************************
+#define EPI_SDRAMCFG_FREQ_M     0xC0000000  // Frequency Range.
+#define EPI_SDRAMCFG_FREQ_NONE  0x00000000  // 0
+#define EPI_SDRAMCFG_FREQ_15MHZ 0x40000000  // 15
+#define EPI_SDRAMCFG_FREQ_30MHZ 0x80000000  // 30
+#define EPI_SDRAMCFG_FREQ_50MHZ 0xC0000000  // 50
+#define EPI_SDRAMCFG_RFSH_M     0x07FF0000  // Refresh Counter.
+#define EPI_SDRAMCFG_SLEEP      0x00000200  // Sleep Mode.
+#define EPI_SDRAMCFG_SIZE_M     0x00000003  // Size of SDRAM.
+#define EPI_SDRAMCFG_SIZE_8MB   0x00000000  // 64Mb (8MB)
+#define EPI_SDRAMCFG_SIZE_16MB  0x00000001  // 128Mb (16MB)
+#define EPI_SDRAMCFG_SIZE_32MB  0x00000002  // 256Mb (32MB)
+#define EPI_SDRAMCFG_SIZE_64MB  0x00000003  // 512Mb (64MB)
+#define EPI_SDRAMCFG_RFSH_S     16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_GPCFG register.
+//
+//*****************************************************************************
+#define EPI_GPCFG_CLKPIN        0x80000000  // Clock Pin.
+#define EPI_GPCFG_CLKGATE       0x40000000  // Clock Gated.
+#define EPI_GPCFG_RDYEN         0x10000000  // Ready Enable.
+#define EPI_GPCFG_FRMPIN        0x08000000  // Framing Pin.
+#define EPI_GPCFG_FRM50         0x04000000  // 50/50 Frame.
+#define EPI_GPCFG_FRMCNT_M      0x03C00000  // Frame Count.
+#define EPI_GPCFG_RW            0x00200000  // Read and Write.
+#define EPI_GPCFG_WR2CYC        0x00080000  // 2-Cycle Writes.
+#define EPI_GPCFG_RD2CYC        0x00040000  // 2-Cycle Reads.
+#define EPI_GPCFG_MAXWAIT_M     0x0000FF00  // Maximum Wait.
+#define EPI_GPCFG_ASIZE_M       0x00000030  // Address Bus Size.
+#define EPI_GPCFG_ASIZE_NONE    0x00000000  // No address
+#define EPI_GPCFG_ASIZE_4BIT    0x00000010  // 4 Bits Wide (EPI24 to EPI27)
+#define EPI_GPCFG_ASIZE_12BIT   0x00000020  // 12 Bits Wide (EPI16 to EPI27).
+                                            // This size cannot be used with
+                                            // 24-bit data.
+#define EPI_GPCFG_ASIZE_20BIT   0x00000030  // 20 Bits Wide
+#define EPI_GPCFG_DSIZE_M       0x00000003  // Size of Data Bus.
+#define EPI_GPCFG_DSIZE_4BIT    0x00000000  // 8 Bits Wide (EPI0 to EPI7)
+#define EPI_GPCFG_DSIZE_16BIT   0x00000001  // 16 Bits Wide (EPI0 to EPI15)
+#define EPI_GPCFG_DSIZE_24BIT   0x00000002  // 24 Bits Wide (EPI0 to EPI23)
+#define EPI_GPCFG_DSIZE_32BIT   0x00000003  // 32 Bits Wide (EPI0 to
+                                            // EPI31).This size may not be used
+                                            // with a clock. This value is
+                                            // normally used for acquisition
+                                            // input and actuator control as
+                                            // well as other general-purpose
+                                            // uses that require 32 bits per
+                                            // direction.
+#define EPI_GPCFG_FRMCNT_S      22
+#define EPI_GPCFG_MAXWAIT_S     8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG_XFFEN        0x00800000  // External FIFO FULL Enable.
+#define EPI_HB8CFG_XFEEN        0x00400000  // External FIFO EMPTY Enable.
+#define EPI_HB8CFG_WRHIGH       0x00200000  // WRITE Strobe Polarity.
+#define EPI_HB8CFG_RDHIGH       0x00100000  // READ Strobe Polarity.
+#define EPI_HB8CFG_MAXWAIT_M    0x0000FF00  // Maximum Wait.
+#define EPI_HB8CFG_WRWS_M       0x000000C0  // Write Wait States.
+#define EPI_HB8CFG_WRWS_0       0x00000000  // No wait states
+#define EPI_HB8CFG_WRWS_1       0x00000040  // 1 wait state
+#define EPI_HB8CFG_WRWS_2       0x00000080  // 2 wait states
+#define EPI_HB8CFG_WRWS_3       0x000000C0  // 3 wait states
+#define EPI_HB8CFG_RDWS_M       0x00000030  // Read Wait States.
+#define EPI_HB8CFG_RDWS_0       0x00000000  // No wait states
+#define EPI_HB8CFG_RDWS_1       0x00000010  // 1 wait state
+#define EPI_HB8CFG_RDWS_2       0x00000020  // 2 wait states
+#define EPI_HB8CFG_RDWS_3       0x00000030  // 3 wait states
+#define EPI_HB8CFG_MODE_M       0x00000003  // Host Bus Sub-Mode.
+#define EPI_HB8CFG_MODE_MUX     0x00000000  // ADMUX - AD[7:0]
+#define EPI_HB8CFG_MODE_NMUX    0x00000001  // ADNONMUX - D[7:0]
+#define EPI_HB8CFG_MODE_SRAM    0x00000002  // SRAM
+#define EPI_HB8CFG_MODE_FIFO    0x00000003  // XFIFO - D[7:0]
+#define EPI_HB8CFG_MAXWAIT_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_SDRAMCFG2
+// register.
+//
+//*****************************************************************************
+#define EPI_SDRAMCFG2_RCM       0x80000000  // Read Capture Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_HB8CFG2 register.
+//
+//*****************************************************************************
+#define EPI_HB8CFG2_WORD        0x80000000  // Word Access Mode.
+#define EPI_HB8CFG2_CSCFG       0x01000000  // Chip Select Configuration.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_GPCFG2 register.
+//
+//*****************************************************************************
+#define EPI_GPCFG2_WORD         0x80000000  // Word Access Mode.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_ADDRMAP register.
+//
+//*****************************************************************************
+#define EPI_ADDRMAP_EPSZ_M      0x000000C0  // External Peripheral Size.
+#define EPI_ADDRMAP_EPSZ_256B   0x00000000  // 0x100 (256)
+#define EPI_ADDRMAP_EPSZ_64KB   0x00000040  // 0x1.0000 (64 KB)
+#define EPI_ADDRMAP_EPSZ_16MB   0x00000080  // 0x100.0000 (16 MB)
+#define EPI_ADDRMAP_EPSZ_512MB  0x000000C0  // 0x2000.0000 (512 MB)
+#define EPI_ADDRMAP_EPADR_M     0x00000030  // External Peripheral Address.
+#define EPI_ADDRMAP_EPADR_NONE  0x00000000  // Not mapped
+#define EPI_ADDRMAP_EPADR_A000  0x00000010  // At 0xA000.0000
+#define EPI_ADDRMAP_EPADR_C000  0x00000020  // At 0xC000.0000
+#define EPI_ADDRMAP_ERSZ_M      0x0000000C  // External RAM Size.
+#define EPI_ADDRMAP_ERSZ_256B   0x00000000  // 0x100 (256)
+#define EPI_ADDRMAP_ERSZ_64KB   0x00000004  // 0x1.0000 (64KB)
+#define EPI_ADDRMAP_ERSZ_16MB   0x00000008  // 0x100.0000 (16MB)
+#define EPI_ADDRMAP_ERSZ_512MB  0x0000000C  // 0x2000.0000 (512MB)
+#define EPI_ADDRMAP_ERADR_M     0x00000003  // External RAM Address.
+#define EPI_ADDRMAP_ERADR_NONE  0x00000000  // Not mapped
+#define EPI_ADDRMAP_ERADR_6000  0x00000001  // At 0x6000.0000
+#define EPI_ADDRMAP_ERADR_8000  0x00000002  // At 0x8000.0000
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RSIZE0 register.
+//
+//*****************************************************************************
+#define EPI_RSIZE0_SIZE_M       0x00000003  // Current Size.
+#define EPI_RSIZE0_SIZE_8BIT    0x00000001  // Byte (8 bits)
+#define EPI_RSIZE0_SIZE_16BIT   0x00000002  // Half-word (16 bits)
+#define EPI_RSIZE0_SIZE_32BIT   0x00000003  // Word (32 bits)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RADDR0 register.
+//
+//*****************************************************************************
+#define EPI_RADDR0_ADDR_M       0x1FFFFFFF  // Current Address.
+#define EPI_RADDR0_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RPSTD0 register.
+//
+//*****************************************************************************
+#define EPI_RPSTD0_POSTCNT_M    0x00001FFF  // Post Count.
+#define EPI_RPSTD0_POSTCNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RSIZE1 register.
+//
+//*****************************************************************************
+#define EPI_RSIZE1_SIZE_M       0x00000003  // Current Size.
+#define EPI_RSIZE1_SIZE_8BIT    0x00000001  // Byte (8 bits)
+#define EPI_RSIZE1_SIZE_16BIT   0x00000002  // Half-word (16 bits)
+#define EPI_RSIZE1_SIZE_32BIT   0x00000003  // Word (32 bits)
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RADDR1 register.
+//
+//*****************************************************************************
+#define EPI_RADDR1_ADDR_M       0x1FFFFFFF  // Current Address.
+#define EPI_RADDR1_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RPSTD1 register.
+//
+//*****************************************************************************
+#define EPI_RPSTD1_POSTCNT_M    0x00001FFF  // Post Count.
+#define EPI_RPSTD1_POSTCNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_STAT register.
+//
+//*****************************************************************************
+#define EPI_STAT_CELOW          0x00000200  // Clock Enable Low.
+#define EPI_STAT_XFFULL         0x00000100  // External FIFO Full.
+#define EPI_STAT_XFEMPTY        0x00000080  // External FIFO Empty.
+#define EPI_STAT_INITSEQ        0x00000040  // Initialization Sequence.
+#define EPI_STAT_WBUSY          0x00000020  // Write Busy.
+#define EPI_STAT_NBRBUSY        0x00000010  // Non-Blocking Read Busy.
+#define EPI_STAT_ACTIVE         0x00000001  // Register Active.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RFIFOCNT register.
+//
+//*****************************************************************************
+#define EPI_RFIFOCNT_COUNT_M    0x00000007  // FIFO Count.
+#define EPI_RFIFOCNT_COUNT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO register.
+//
+//*****************************************************************************
+#define EPI_READFIFO_DATA_M     0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO_DATA_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO1
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO1_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO1_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO2
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO2_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO2_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO3
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO3_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO3_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO4
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO4_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO4_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO5
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO5_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO5_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO6
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO6_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO6_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_READFIFO7
+// register.
+//
+//*****************************************************************************
+#define EPI_READFIFO7_DATA_M    0xFFFFFFFF  // Reads Data.
+#define EPI_READFIFO7_DATA_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_FIFOLVL register.
+//
+//*****************************************************************************
+#define EPI_FIFOLVL_WFERR       0x00020000  // Write Full Error.
+#define EPI_FIFOLVL_RSERR       0x00010000  // Read Stall Error.
+#define EPI_FIFOLVL_WRFIFO_M    0x00000070  // Write FIFO.
+#define EPI_FIFOLVL_WRFIFO_EMPT 0x00000000  // Trigger when there are 1 to 4
+                                            // spaces available in the WFIFO.
+#define EPI_FIFOLVL_WRFIFO_1_4  0x00000020  // Trigger when there are 1 to 3
+                                            // spaces available in the WFIFO.
+#define EPI_FIFOLVL_WRFIFO_1_2  0x00000030  // Trigger when there are 1 to 2
+                                            // spaces available in the WFIFO.
+#define EPI_FIFOLVL_WRFIFO_3_4  0x00000040  // Trigger when there is 1 space
+                                            // available in the WFIFO.
+#define EPI_FIFOLVL_RDFIFO_M    0x00000007  // Read FIFO.
+#define EPI_FIFOLVL_RDFIFO_1_8  0x00000001  // Trigger when there are 1 or more
+                                            // entries in the NBRFIFO.
+#define EPI_FIFOLVL_RDFIFO_1_4  0x00000002  // Trigger when there are 2 or more
+                                            // entries in the NBRFIFO.
+#define EPI_FIFOLVL_RDFIFO_1_2  0x00000003  // Trigger when there are 4 or more
+                                            // entries in the NBRFIFO.
+#define EPI_FIFOLVL_RDFIFO_3_4  0x00000004  // Trigger when there are 6 or more
+                                            // entries in the NBRFIFO.
+#define EPI_FIFOLVL_RDFIFO_7_8  0x00000005  // Trigger when there are 7 or more
+                                            // entries in the NBRFIFO.
+#define EPI_FIFOLVL_RDFIFO_FULL 0x00000006  // Trigger when there are 8 entries
+                                            // in the NBRFIFO.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_WFIFOCNT register.
+//
+//*****************************************************************************
+#define EPI_WFIFOCNT_WTAV_M     0x00000007  // Available Write Transactions.
+#define EPI_WFIFOCNT_WTAV_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_IM register.
+//
+//*****************************************************************************
+#define EPI_IM_WRIM             0x00000004  // Write Interrupt Mask.
+#define EPI_IM_RDIM             0x00000002  // Read Interrupt Mask.
+#define EPI_IM_ERRIM            0x00000001  // Error Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_RIS register.
+//
+//*****************************************************************************
+#define EPI_RIS_WRRIS           0x00000004  // Write Raw Interrupt Status.
+#define EPI_RIS_RDRIS           0x00000002  // Read Raw Interrupt Status.
+#define EPI_RIS_ERRRIS          0x00000001  // Error Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_MIS register.
+//
+//*****************************************************************************
+#define EPI_MIS_WRMIS           0x00000004  // Write Masked Interrupt Status.
+#define EPI_MIS_RDMIS           0x00000002  // Read Masked Interrupt Status.
+#define EPI_MIS_ERRMIS          0x00000001  // Error Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the EPI_O_EISC register.
+//
+//*****************************************************************************
+#define EPI_EISC_WTFULL         0x00000004  // Write FIFO Full Error.
+#define EPI_EISC_RSTALL         0x00000002  // Read Stalled Error.
+#define EPI_EISC_TOUT           0x00000001  // Timeout Error.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMA register.
+//
+//*****************************************************************************
+#define FLASH_FMA_OFFSET_M      0x0003FFFF  // Address Offset.
+#define FLASH_FMA_OFFSET_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMD register.
+//
+//*****************************************************************************
+#define FLASH_FMD_DATA_M        0xFFFFFFFF  // Data Value.
+#define FLASH_FMD_DATA_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC register.
+//
+//*****************************************************************************
+#define FLASH_FMC_WRKEY_M       0xFFFF0000  // Flash Memory Write Key.
+#define FLASH_FMC_WRKEY         0xA4420000  // FLASH write key
+#define FLASH_FMC_COMT          0x00000008  // Commit Register Value.
+#define FLASH_FMC_MERASE        0x00000004  // Mass Erase Flash Memory.
+#define FLASH_FMC_ERASE         0x00000002  // Erase a Page of Flash Memory.
+#define FLASH_FMC_WRITE         0x00000001  // Write a Word into Flash Memory.
+#define FLASH_FMC_WRKEY_S       16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCRIS register.
+//
+//*****************************************************************************
+#define FLASH_FCRIS_PRIS        0x00000002  // Programming Raw Interrupt
+                                            // Status.
+#define FLASH_FCRIS_ARIS        0x00000001  // Access Raw Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCIM register.
+//
+//*****************************************************************************
+#define FLASH_FCIM_PMASK        0x00000002  // Programming Interrupt Mask.
+#define FLASH_FCIM_AMASK        0x00000001  // Access Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FCMISC register.
+//
+//*****************************************************************************
+#define FLASH_FCMISC_PMISC      0x00000002  // Programming Masked Interrupt
+                                            // Status and Clear.
+#define FLASH_FCMISC_AMISC      0x00000001  // Access Masked Interrupt Status
+                                            // and Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FMC2 register.
+//
+//*****************************************************************************
+#define FLASH_FMC2_WRKEY_M      0xFFFF0000  // Flash Memory Write Key.
+#define FLASH_FMC2_WRBUF        0x00000001  // Buffered Flash Memory Write.
+#define FLASH_FMC2_WRKEY_S      16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FWBVAL register.
+//
+//*****************************************************************************
+#define FLASH_FWBVAL_FWB_M      0xFFFFFFFF  // Flash Memory Write Buffer.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_FWBN register.
+//
+//*****************************************************************************
+#define FLASH_FWBN_DATA_M       0xFFFFFFFF  // Data.
+#define FLASH_FWBN_DATA_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_RMCTL register.
+//
+//*****************************************************************************
+#define FLASH_RMCTL_BA          0x00000001  // Boot Alias.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_RMVER register.
+//
+//*****************************************************************************
+#define FLASH_RMVER_CONT_M      0xFF000000  // ROM Contents.
+#define FLASH_RMVER_CONT_LM_AES 0x02000000  // Stellaris Boot Loader &amp;
+                                            // DriverLib with AES
+#define FLASH_RMVER_SIZE_M      0x00FF0000  // ROM Size.
+#define FLASH_RMVER_SIZE_23_75K 0x00020000  // Stellaris Boot Loader &amp;
+                                            // DriverLib with AES,ethernet
+#define FLASH_RMVER_VER_M       0x0000FF00  // ROM Version.
+#define FLASH_RMVER_REV_M       0x000000FF  // ROM Revision.
+#define FLASH_RMVER_VER_S       8
+#define FLASH_RMVER_REV_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERDBG register.
+//
+//*****************************************************************************
+#define FLASH_USERDBG_NW        0x80000000  // User Debug Not Written.
+#define FLASH_USERDBG_DATA_M    0x7FFFFFFC  // User Data.
+#define FLASH_USERDBG_DBG1      0x00000002  // Debug Control 1.
+#define FLASH_USERDBG_DBG0      0x00000001  // Debug Control 0.
+#define FLASH_USERDBG_DATA_S    2
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG0 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG0_NW       0x80000000  // Not Written.
+#define FLASH_USERREG0_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG0_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG1 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG1_NW       0x80000000  // Not Written.
+#define FLASH_USERREG1_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG1_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG2 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG2_NW       0x80000000  // Not Written.
+#define FLASH_USERREG2_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG2_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the FLASH_USERREG3 register.
+//
+//*****************************************************************************
+#define FLASH_USERREG3_NW       0x80000000  // Not Written.
+#define FLASH_USERREG3_DATA_M   0x7FFFFFFF  // User Data.
+#define FLASH_USERREG3_DATA_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the erase size of the FLASH block that is
+// erased by an erase operation, and the protect size is the size of the FLASH
+// block that is protected by each protection register.
+//
+//*****************************************************************************
+#define FLASH_PROTECT_SIZE      0x00000800
+#define FLASH_ERASE_SIZE        0x00000400
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID0_VER_M       0x70000000  // DID0 Version.
+#define SYSCTL_DID0_VER_1       0x10000000  // Second version of the DID0
+                                            // register format.
+#define SYSCTL_DID0_CLASS_M     0x00FF0000  // Device Class.
+#define SYSCTL_DID0_CLASS_TEMPEST \
+                                0x00040000  // Stellaris(r) Tempest-class
+                                            // microcontrollers
+#define SYSCTL_DID0_MAJ_M       0x0000FF00  // Major Revision.
+#define SYSCTL_DID0_MAJ_REVA    0x00000000  // Revision A (initial device)
+#define SYSCTL_DID0_MAJ_REVB    0x00000100  // Revision B (first base layer
+                                            // revision)
+#define SYSCTL_DID0_MAJ_REVC    0x00000200  // Revision C (second base layer
+                                            // revision)
+#define SYSCTL_DID0_MIN_M       0x000000FF  // Minor Revision.
+#define SYSCTL_DID0_MIN_0       0x00000000  // Initial device, or a major
+                                            // revision update.
+#define SYSCTL_DID0_MIN_1       0x00000001  // First metal layer change.
+#define SYSCTL_DID0_MIN_2       0x00000002  // Second metal layer change.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DID1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DID1_VER_M       0xF0000000  // DID1 Version.
+#define SYSCTL_DID1_VER_1       0x10000000  // Second version of the DID1
+                                            // register format.
+#define SYSCTL_DID1_FAM_M       0x0F000000  // Family.
+#define SYSCTL_DID1_FAM_STELLARIS \
+                                0x00000000  // Stellaris family of
+                                            // microcontollers, that is, all
+                                            // devices with external part
+                                            // numbers starting
+                                            // with LM3S.
+#define SYSCTL_DID1_PRTNO_M     0x00FF0000  // Part Number.
+#define SYSCTL_DID1_PRTNO_9B92  0x006A0000  // LM3S9B92
+#define SYSCTL_DID1_PINCNT_M    0x0000E000  // Package Pin Count.
+#define SYSCTL_DID1_PINCNT_100  0x00004000  // 100-pin package
+#define SYSCTL_DID1_TEMP_M      0x000000E0  // Temperature Range.
+#define SYSCTL_DID1_TEMP_C      0x00000000  // Commercial temperature range (0C
+                                            // to 70C)
+#define SYSCTL_DID1_TEMP_I      0x00000020  // Industrial temperature range
+                                            // (-40C to 85C)
+#define SYSCTL_DID1_TEMP_E      0x00000040  // Extended temperature range (-40C
+                                            // to 105C)
+#define SYSCTL_DID1_PKG_M       0x00000018  // Package Type.
+#define SYSCTL_DID1_PKG_28SOIC  0x00000000  // SOIC package
+#define SYSCTL_DID1_PKG_48QFP   0x00000008  // LQFP package
+#define SYSCTL_DID1_PKG_BGA     0x00000010  // BGA package
+#define SYSCTL_DID1_ROHS        0x00000004  // RoHS-Compliance.
+#define SYSCTL_DID1_QUAL_M      0x00000003  // Qualification Status.
+#define SYSCTL_DID1_QUAL_ES     0x00000000  // Engineering Sample (unqualified)
+#define SYSCTL_DID1_QUAL_PP     0x00000001  // Pilot Production (unqualified)
+#define SYSCTL_DID1_QUAL_FQ     0x00000002  // Fully Qualified
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC0_SRAMSZ_M     0xFFFF0000  // SRAM Size.
+#define SYSCTL_DC0_SRAMSZ_96KB  0x017F0000  // 96 KB of SRAM
+#define SYSCTL_DC0_FLASHSZ_M    0x0000FFFF  // Flash Size.
+#define SYSCTL_DC0_FLASHSZ_256K 0x0000007F  // 256 KB of Flash
+#define SYSCTL_DC0_SRAMSZ_S     16          // SRAM size shift
+#define SYSCTL_DC0_FLASHSZ_S    0           // Flash size shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC1_WDT1         0x10000000  // Watchdog Timer1 Present.
+#define SYSCTL_DC1_CAN1         0x02000000  // CAN Module 1 Present.
+#define SYSCTL_DC1_CAN0         0x01000000  // CAN Module 0 Present.
+#define SYSCTL_DC1_PWM          0x00100000  // PWM Module Present.
+#define SYSCTL_DC1_ADC1         0x00020000  // ADC Module 1 Present.
+#define SYSCTL_DC1_ADC0         0x00010000  // ADC Module 0 Present.
+#define SYSCTL_DC1_MINSYSDIV_M  0x0000F000  // System Clock Divider.
+#define SYSCTL_DC1_MINSYSDIV_100 \
+                                0x00001000  // Divide VCO (400MHZ) by 5 minimum
+#define SYSCTL_DC1_MINSYSDIV_66 0x00002000  // Divide VCO (400MHZ) by 2*2 + 2 =
+                                            // 6 minimum
+#define SYSCTL_DC1_MINSYSDIV_50 0x00003000  // Specifies a 50-MHz CPU clock
+                                            // with a PLL divider of 4.
+#define SYSCTL_DC1_MINSYSDIV_25 0x00007000  // Specifies a 25-MHz clock with a
+                                            // PLL divider of 8.
+#define SYSCTL_DC1_MINSYSDIV_20 0x00009000  // Specifies a 20-MHz clock with a
+                                            // PLL divider of 10.
+#define SYSCTL_DC1_ADC1SPD_M    0x00000C00  // Max ADC1 Speed.
+#define SYSCTL_DC1_ADC1SPD_1M   0x00000C00  // 1M samples/second
+#define SYSCTL_DC1_ADC0SPD_M    0x00000300  // Max ADC0 Speed.
+#define SYSCTL_DC1_ADC0SPD_1M   0x00000300  // 1M samples/second
+#define SYSCTL_DC1_MPU          0x00000080  // MPU Present.
+#define SYSCTL_DC1_TEMP         0x00000020  // Temp Sensor Present.
+#define SYSCTL_DC1_PLL          0x00000010  // PLL Present.
+#define SYSCTL_DC1_WDT0         0x00000008  // Watchdog Timer 0 Present.
+#define SYSCTL_DC1_SWO          0x00000004  // SWO Trace Port Present.
+#define SYSCTL_DC1_SWD          0x00000002  // SWD Present.
+#define SYSCTL_DC1_JTAG         0x00000001  // JTAG Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC2_EPI0         0x40000000  // EPI Module 0 Present.
+#define SYSCTL_DC2_I2S0         0x10000000  // I2S Module 0 Present.
+#define SYSCTL_DC2_COMP2        0x04000000  // Analog Comparator 2 Present.
+#define SYSCTL_DC2_COMP1        0x02000000  // Analog Comparator 1 Present.
+#define SYSCTL_DC2_COMP0        0x01000000  // Analog Comparator 0 Present.
+#define SYSCTL_DC2_TIMER3       0x00080000  // Timer Module 3 Present.
+#define SYSCTL_DC2_TIMER2       0x00040000  // Timer Module 2 Present.
+#define SYSCTL_DC2_TIMER1       0x00020000  // Timer Module 1 Present.
+#define SYSCTL_DC2_TIMER0       0x00010000  // Timer Module 0 Present.
+#define SYSCTL_DC2_I2C1         0x00004000  // I2C Module 1 Present.
+#define SYSCTL_DC2_I2C0         0x00001000  // I2C Module 0 Present.
+#define SYSCTL_DC2_QEI1         0x00000200  // QEI Module 1 Present.
+#define SYSCTL_DC2_QEI0         0x00000100  // QEI Module 0 Present.
+#define SYSCTL_DC2_SSI1         0x00000020  // SSI Module 1 Present.
+#define SYSCTL_DC2_SSI0         0x00000010  // SSI Module 0 Present.
+#define SYSCTL_DC2_UART2        0x00000004  // UART Module 2 Present.
+#define SYSCTL_DC2_UART1        0x00000002  // UART Module 1 Present.
+#define SYSCTL_DC2_UART0        0x00000001  // UART Module 0 Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC3 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC3_32KHZ        0x80000000  // 32KHz Input Clock Available.
+#define SYSCTL_DC3_CCP5         0x20000000  // CCP5 Pin Present.
+#define SYSCTL_DC3_CCP4         0x10000000  // CCP4 Pin Present.
+#define SYSCTL_DC3_CCP3         0x08000000  // CCP3 Pin Present.
+#define SYSCTL_DC3_CCP2         0x04000000  // CCP2 Pin Present.
+#define SYSCTL_DC3_CCP1         0x02000000  // CCP1 Pin Present.
+#define SYSCTL_DC3_CCP0         0x01000000  // CCP0 Pin Present.
+#define SYSCTL_DC3_ADC0AIN7     0x00800000  // ADC Module 0 AIN7 Pin Present.
+#define SYSCTL_DC3_ADC0AIN6     0x00400000  // ADC Module 0 AIN6 Pin Present.
+#define SYSCTL_DC3_ADC0AIN5     0x00200000  // ADC Module 0 AIN5 Pin Present.
+#define SYSCTL_DC3_ADC0AIN4     0x00100000  // ADC Module 0 AIN4 Pin Present.
+#define SYSCTL_DC3_ADC0AIN3     0x00080000  // ADC Module 0 AIN3 Pin Present.
+#define SYSCTL_DC3_ADC0AIN2     0x00040000  // ADC Module 0 AIN2 Pin Present.
+#define SYSCTL_DC3_ADC0AIN1     0x00020000  // ADC Module 0 AIN1 Pin Present.
+#define SYSCTL_DC3_ADC0AIN0     0x00010000  // ADC Module 0 AIN0 Pin Present.
+#define SYSCTL_DC3_PWMFAULT     0x00008000  // PWM Fault Pin Present.
+#define SYSCTL_DC3_C2PLUS       0x00002000  // C2+ Pin Present.
+#define SYSCTL_DC3_C2MINUS      0x00001000  // C2- Pin Present.
+#define SYSCTL_DC3_C1PLUS       0x00000400  // C1+ Pin Present.
+#define SYSCTL_DC3_C1MINUS      0x00000200  // C1- Pin Present.
+#define SYSCTL_DC3_C0PLUS       0x00000080  // C0+ Pin Present.
+#define SYSCTL_DC3_C0MINUS      0x00000040  // C0- Pin Present.
+#define SYSCTL_DC3_PWM5         0x00000020  // PWM5 Pin Present.
+#define SYSCTL_DC3_PWM4         0x00000010  // PWM4 Pin Present.
+#define SYSCTL_DC3_PWM3         0x00000008  // PWM3 Pin Present.
+#define SYSCTL_DC3_PWM2         0x00000004  // PWM2 Pin Present.
+#define SYSCTL_DC3_PWM1         0x00000002  // PWM1 Pin Present.
+#define SYSCTL_DC3_PWM0         0x00000001  // PWM0 Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC4 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC4_EPHY0        0x40000000  // Ethernet PHY Layer 0 Present.
+#define SYSCTL_DC4_EMAC0        0x10000000  // Ethernet MAC Layer 0 Present.
+#define SYSCTL_DC4_CCP7         0x00008000  // CCP7 Pin Present.
+#define SYSCTL_DC4_CCP6         0x00004000  // CCP6 Pin Present.
+#define SYSCTL_DC4_UDMA         0x00002000  // Micro-DMA Module Present.
+#define SYSCTL_DC4_ROM          0x00001000  // Internal Code ROM Present.
+#define SYSCTL_DC4_GPIOJ        0x00000100  // GPIO Port J Present.
+#define SYSCTL_DC4_GPIOH        0x00000080  // GPIO Port H Present.
+#define SYSCTL_DC4_GPIOG        0x00000040  // GPIO Port G Present.
+#define SYSCTL_DC4_GPIOF        0x00000020  // GPIO Port F Present.
+#define SYSCTL_DC4_GPIOE        0x00000010  // GPIO Port E Present.
+#define SYSCTL_DC4_GPIOD        0x00000008  // GPIO Port D Present.
+#define SYSCTL_DC4_GPIOC        0x00000004  // GPIO Port C Present.
+#define SYSCTL_DC4_GPIOB        0x00000002  // GPIO Port B Present.
+#define SYSCTL_DC4_GPIOA        0x00000001  // GPIO Port A Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC5 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC5_PWMFAULT3    0x08000000  // PWM Fault 3 Pin Present.
+#define SYSCTL_DC5_PWMFAULT2    0x04000000  // PWM Fault 2 Pin Present.
+#define SYSCTL_DC5_PWMFAULT1    0x02000000  // PWM Fault 1 Pin Present.
+#define SYSCTL_DC5_PWMFAULT0    0x01000000  // PWM Fault 0 Pin Present.
+#define SYSCTL_DC5_PWMEFLT      0x00200000  // PWM Extended Fault Active.
+#define SYSCTL_DC5_PWMESYNC     0x00100000  // PWM Extended SYNC Active.
+#define SYSCTL_DC5_PWM7         0x00000080  // PWM7 Pin Present.
+#define SYSCTL_DC5_PWM6         0x00000040  // PWM6 Pin Present.
+#define SYSCTL_DC5_PWM5         0x00000020  // PWM5 Pin Present.
+#define SYSCTL_DC5_PWM4         0x00000010  // PWM4 Pin Present.
+#define SYSCTL_DC5_PWM3         0x00000008  // PWM3 Pin Present.
+#define SYSCTL_DC5_PWM2         0x00000004  // PWM2 Pin Present.
+#define SYSCTL_DC5_PWM1         0x00000002  // PWM1 Pin Present.
+#define SYSCTL_DC5_PWM0         0x00000001  // PWM0 Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC6 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC6_USB0PHY      0x00000010  // USB Module 0 PHY Present.
+#define SYSCTL_DC6_USB0_M       0x00000003  // USB Module 0 Present.
+#define SYSCTL_DC6_USB0_OTG     0x00000003  // USB0 is OTG.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC7 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC7_DMACH30      0x40000000  // SW.
+#define SYSCTL_DC7_DMACH29      0x20000000  // I2S0_TX / CAN1_TX.
+#define SYSCTL_DC7_DMACH28      0x10000000  // I2S0_RX / CAN1_RX.
+#define SYSCTL_DC7_DMACH27      0x08000000  // CAN1_TX / ADC1_SS3.
+#define SYSCTL_DC7_DMACH26      0x04000000  // CAN1_RX / ADC1_SS2.
+#define SYSCTL_DC7_DMACH25      0x02000000  // SSI1_TX / ADC1_SS1.
+#define SYSCTL_DC7_DMACH24      0x01000000  // SSI1_RX / ADC1_SS0.
+#define SYSCTL_DC7_DMACH23      0x00800000  // UART1_TX / CAN2_TX.
+#define SYSCTL_DC7_DMACH22      0x00400000  // UART1_RX / CAN2_RX.
+#define SYSCTL_DC7_DMACH21      0x00200000  // Timer1B / EPI0_TX.
+#define SYSCTL_DC7_DMACH20      0x00100000  // Timer1A / EPI0_RX.
+#define SYSCTL_DC7_DMACH19      0x00080000  // Timer0B / Timer1B.
+#define SYSCTL_DC7_DMACH18      0x00040000  // Timer0A / Timer1A.
+#define SYSCTL_DC7_DMACH17      0x00020000  // ADC0_SS3.
+#define SYSCTL_DC7_DMACH16      0x00010000  // ADC0_SS2.
+#define SYSCTL_DC7_DMACH15      0x00008000  // ADC0_SS1 / Timer2B.
+#define SYSCTL_DC7_DMACH14      0x00004000  // ADC0_SS0 / Timer2A.
+#define SYSCTL_DC7_DMACH13      0x00002000  // CAN0_TX / UART2_TX.
+#define SYSCTL_DC7_DMACH12      0x00001000  // CAN0_RX / UART2_RX.
+#define SYSCTL_DC7_DMACH11      0x00000800  // SSI0_TX / UART1_TX.
+#define SYSCTL_DC7_DMACH10      0x00000400  // SSI0_RX / UART1_RX.
+#define SYSCTL_DC7_DMACH9       0x00000200  // UART0_TX / SSI1_TX.
+#define SYSCTL_DC7_DMACH8       0x00000100  // UART0_RX / SSI1_RX.
+#define SYSCTL_DC7_DMACH7       0x00000080  // ETH_TX / Timer2B.
+#define SYSCTL_DC7_DMACH6       0x00000040  // ETH_RX / Timer2A.
+#define SYSCTL_DC7_DMACH5       0x00000020  // USB_EP3_TX / Timer2B.
+#define SYSCTL_DC7_DMACH4       0x00000010  // USB_EP3_RX / Timer2A.
+#define SYSCTL_DC7_DMACH3       0x00000008  // USB_EP2_TX / Timer3B.
+#define SYSCTL_DC7_DMACH2       0x00000004  // USB_EP2_RX / Timer3A.
+#define SYSCTL_DC7_DMACH1       0x00000002  // USB_EP1_TX / UART2_TX.
+#define SYSCTL_DC7_DMACH0       0x00000001  // USB_EP1_RX / UART2_RX.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC8 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC8_ADC1AIN15    0x80000000  // ADC Module 1 AIN15 Pin Present.
+#define SYSCTL_DC8_ADC1AIN14    0x40000000  // ADC Module 1 AIN14 Pin Present.
+#define SYSCTL_DC8_ADC1AIN13    0x20000000  // ADC Module 1 AIN13 Pin Present.
+#define SYSCTL_DC8_ADC1AIN12    0x10000000  // ADC Module 1 AIN12 Pin Present.
+#define SYSCTL_DC8_ADC1AIN11    0x08000000  // ADC Module 1 AIN11 Pin Present.
+#define SYSCTL_DC8_ADC1AIN10    0x04000000  // ADC Module 1 AIN10 Pin Present.
+#define SYSCTL_DC8_ADC1AIN9     0x02000000  // ADC Module 1 AIN9 Pin Present.
+#define SYSCTL_DC8_ADC1AIN8     0x01000000  // ADC Module 1 AIN8 Pin Present.
+#define SYSCTL_DC8_ADC1AIN7     0x00800000  // ADC Module 1 AIN7 Pin Present.
+#define SYSCTL_DC8_ADC1AIN6     0x00400000  // ADC Module 1 AIN6 Pin Present.
+#define SYSCTL_DC8_ADC1AIN5     0x00200000  // ADC Module 1 AIN5 Pin Present.
+#define SYSCTL_DC8_ADC1AIN4     0x00100000  // ADC Module 1 AIN4 Pin Present.
+#define SYSCTL_DC8_ADC1AIN3     0x00080000  // ADC Module 1 AIN3 Pin Present.
+#define SYSCTL_DC8_ADC1AIN2     0x00040000  // ADC Module 1 AIN2 Pin Present.
+#define SYSCTL_DC8_ADC1AIN1     0x00020000  // ADC Module 1 AIN1 Pin Present.
+#define SYSCTL_DC8_ADC1AIN0     0x00010000  // ADC Module 1 AIN0 Pin Present.
+#define SYSCTL_DC8_ADC0AIN15    0x00008000  // ADC Module 0 AIN15 Pin Present.
+#define SYSCTL_DC8_ADC0AIN14    0x00004000  // ADC Module 0 AIN14 Pin Present.
+#define SYSCTL_DC8_ADC0AIN13    0x00002000  // ADC Module 0 AIN13 Pin Present.
+#define SYSCTL_DC8_ADC0AIN12    0x00001000  // ADC Module 0 AIN12 Pin Present.
+#define SYSCTL_DC8_ADC0AIN11    0x00000800  // ADC Module 0 AIN11 Pin Present.
+#define SYSCTL_DC8_ADC0AIN10    0x00000400  // ADC Module 0 AIN10 Pin Present.
+#define SYSCTL_DC8_ADC0AIN9     0x00000200  // ADC Module 0 AIN9 Pin Present.
+#define SYSCTL_DC8_ADC0AIN8     0x00000100  // ADC Module 0 AIN8 Pin Present.
+#define SYSCTL_DC8_ADC0AIN7     0x00000080  // ADC Module 0 AIN7 Pin Present.
+#define SYSCTL_DC8_ADC0AIN6     0x00000040  // ADC Module 0 AIN6 Pin Present.
+#define SYSCTL_DC8_ADC0AIN5     0x00000020  // ADC Module 0 AIN5 Pin Present.
+#define SYSCTL_DC8_ADC0AIN4     0x00000010  // ADC Module 0 AIN4 Pin Present.
+#define SYSCTL_DC8_ADC0AIN3     0x00000008  // ADC Module 0 AIN3 Pin Present.
+#define SYSCTL_DC8_ADC0AIN2     0x00000004  // ADC Module 0 AIN2 Pin Present.
+#define SYSCTL_DC8_ADC0AIN1     0x00000002  // ADC Module 0 AIN1 Pin Present.
+#define SYSCTL_DC8_ADC0AIN0     0x00000001  // ADC Module 0 AIN0 Pin Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PBORCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_PBORCTL_BORIOR   0x00000002  // BOR Interrupt or Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR0_WDT1       0x10000000  // WDT1 Reset Control.
+#define SYSCTL_SRCR0_CAN1       0x02000000  // CAN1 Reset Control.
+#define SYSCTL_SRCR0_CAN0       0x01000000  // CAN0 Reset Control.
+#define SYSCTL_SRCR0_PWM        0x00100000  // PWM Reset Control.
+#define SYSCTL_SRCR0_ADC1       0x00020000  // ADC1 Reset Control.
+#define SYSCTL_SRCR0_ADC0       0x00010000  // ADC0 Reset Control.
+#define SYSCTL_SRCR0_WDT0       0x00000008  // WDT0 Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR1_EPI0       0x40000000  // EPI0 Reset Control.
+#define SYSCTL_SRCR1_I2S0       0x10000000  // I2S0 Reset Control.
+#define SYSCTL_SRCR1_COMP2      0x04000000  // Analog Comp 2 Reset Control.
+#define SYSCTL_SRCR1_COMP1      0x02000000  // Analog Comp 1 Reset Control.
+#define SYSCTL_SRCR1_COMP0      0x01000000  // Analog Comp 0 Reset Control.
+#define SYSCTL_SRCR1_TIMER3     0x00080000  // Timer 3 Reset Control.
+#define SYSCTL_SRCR1_TIMER2     0x00040000  // Timer 2 Reset Control.
+#define SYSCTL_SRCR1_TIMER1     0x00020000  // Timer 1 Reset Control.
+#define SYSCTL_SRCR1_TIMER0     0x00010000  // Timer 0 Reset Control.
+#define SYSCTL_SRCR1_I2C1       0x00004000  // I2C1 Reset Control.
+#define SYSCTL_SRCR1_I2C0       0x00001000  // I2C0 Reset Control.
+#define SYSCTL_SRCR1_QEI1       0x00000200  // QEI1 Reset Control.
+#define SYSCTL_SRCR1_QEI0       0x00000100  // QEI0 Reset Control.
+#define SYSCTL_SRCR1_SSI1       0x00000020  // SSI1 Reset Control.
+#define SYSCTL_SRCR1_SSI0       0x00000010  // SSI0 Reset Control.
+#define SYSCTL_SRCR1_UART2      0x00000004  // UART2 Reset Control.
+#define SYSCTL_SRCR1_UART1      0x00000002  // UART1 Reset Control.
+#define SYSCTL_SRCR1_UART0      0x00000001  // UART0 Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SRCR2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SRCR2_EPHY0      0x40000000  // PHY0 Reset Control.
+#define SYSCTL_SRCR2_EMAC0      0x10000000  // MAC0 Reset Control.
+#define SYSCTL_SRCR2_USB0       0x00010000  // USB0 Reset Control.
+#define SYSCTL_SRCR2_UDMA       0x00002000  // Micro-DMA Reset Control.
+#define SYSCTL_SRCR2_GPIOJ      0x00000100  // Port J Reset Control.
+#define SYSCTL_SRCR2_GPIOH      0x00000080  // Port H Reset Control.
+#define SYSCTL_SRCR2_GPIOG      0x00000040  // Port G Reset Control.
+#define SYSCTL_SRCR2_GPIOF      0x00000020  // Port F Reset Control.
+#define SYSCTL_SRCR2_GPIOE      0x00000010  // Port E Reset Control.
+#define SYSCTL_SRCR2_GPIOD      0x00000008  // Port D Reset Control.
+#define SYSCTL_SRCR2_GPIOC      0x00000004  // Port C Reset Control.
+#define SYSCTL_SRCR2_GPIOB      0x00000002  // Port B Reset Control.
+#define SYSCTL_SRCR2_GPIOA      0x00000001  // Port A Reset Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RIS register.
+//
+//*****************************************************************************
+#define SYSCTL_RIS_MOSCPUPRIS   0x00000100  // MOSC Power Up Raw Interrupt
+                                            // Status.
+#define SYSCTL_RIS_USBPLLLRIS   0x00000080  // USB PLL Lock Raw Interrupt
+                                            // Status.
+#define SYSCTL_RIS_PLLLRIS      0x00000040  // PLL Lock Raw Interrupt Status.
+#define SYSCTL_RIS_BORRIS       0x00000002  // Brown-Out Reset Raw Interrupt
+                                            // Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_IMC register.
+//
+//*****************************************************************************
+#define SYSCTL_IMC_MOSCPUPIM    0x00000100  // MOSC Power Up Interrupt Mask.
+#define SYSCTL_IMC_USBPLLLIM    0x00000080  // USB PLL Lock Interrupt Mask.
+#define SYSCTL_IMC_PLLLIM       0x00000040  // PLL Lock Interrupt Mask.
+#define SYSCTL_IMC_BORIM        0x00000002  // Brown-Out Reset Interrupt Mask.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MISC register.
+//
+//*****************************************************************************
+#define SYSCTL_MISC_MOSCPUPMIS  0x00000100  // MOSC Power Up Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_USBPLLLMIS  0x00000080  // USB PLL Lock Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_PLLLMIS     0x00000040  // PLL Lock Masked Interrupt
+                                            // Status.
+#define SYSCTL_MISC_BORMIS      0x00000002  // BOR Masked Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RESC register.
+//
+//*****************************************************************************
+#define SYSCTL_RESC_MOSCFAIL    0x00010000  // MOSC Failure Reset.
+#define SYSCTL_RESC_WDT1        0x00000020  // Watchdog Timer 1 Reset.
+#define SYSCTL_RESC_SW          0x00000010  // Software Reset.
+#define SYSCTL_RESC_WDT0        0x00000008  // Watchdog Timer 0 Reset.
+#define SYSCTL_RESC_BOR         0x00000004  // Brown-Out Reset.
+#define SYSCTL_RESC_POR         0x00000002  // Power-On Reset.
+#define SYSCTL_RESC_EXT         0x00000001  // External Reset.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC_ACG          0x08000000  // Auto Clock Gating.
+#define SYSCTL_RCC_SYSDIV_M     0x07800000  // System Clock Divisor.
+#define SYSCTL_RCC_SYSDIV_2     0x00800000  // /2
+#define SYSCTL_RCC_SYSDIV_3     0x01000000  // /3
+#define SYSCTL_RCC_SYSDIV_4     0x01800000  // /4
+#define SYSCTL_RCC_SYSDIV_5     0x02000000  // /5
+#define SYSCTL_RCC_SYSDIV_6     0x02800000  // /6
+#define SYSCTL_RCC_SYSDIV_7     0x03000000  // /7
+#define SYSCTL_RCC_SYSDIV_8     0x03800000  // /8
+#define SYSCTL_RCC_SYSDIV_9     0x04000000  // /9
+#define SYSCTL_RCC_SYSDIV_10    0x04800000  // /10
+#define SYSCTL_RCC_SYSDIV_11    0x05000000  // /11
+#define SYSCTL_RCC_SYSDIV_12    0x05800000  // /12
+#define SYSCTL_RCC_SYSDIV_13    0x06000000  // /13
+#define SYSCTL_RCC_SYSDIV_14    0x06800000  // /14
+#define SYSCTL_RCC_SYSDIV_15    0x07000000  // /15
+#define SYSCTL_RCC_SYSDIV_16    0x07800000  // /16
+#define SYSCTL_RCC_USESYSDIV    0x00400000  // Enable System Clock Divider.
+#define SYSCTL_RCC_USEPWMDIV    0x00100000  // Enable PWM Clock Divisor.
+#define SYSCTL_RCC_PWMDIV_M     0x000E0000  // PWM Unit Clock Divisor.
+#define SYSCTL_RCC_PWMDIV_2     0x00000000  // /2
+#define SYSCTL_RCC_PWMDIV_4     0x00020000  // /4
+#define SYSCTL_RCC_PWMDIV_8     0x00040000  // /8
+#define SYSCTL_RCC_PWMDIV_16    0x00060000  // /16
+#define SYSCTL_RCC_PWMDIV_32    0x00080000  // /32
+#define SYSCTL_RCC_PWMDIV_64    0x000A0000  // /64
+#define SYSCTL_RCC_PWRDN        0x00002000  // PLL Power Down.
+#define SYSCTL_RCC_BYPASS       0x00000800  // PLL Bypass.
+#define SYSCTL_RCC_XTAL_M       0x000007C0  // Crystal Value.
+#define SYSCTL_RCC_XTAL_1MHZ    0x00000000  // 1.000
+#define SYSCTL_RCC_XTAL_1_84MHZ 0x00000040  // 1.8432
+#define SYSCTL_RCC_XTAL_2MHZ    0x00000080  // 2.000
+#define SYSCTL_RCC_XTAL_2_45MHZ 0x000000C0  // 2.4576
+#define SYSCTL_RCC_XTAL_3_57MHZ 0x00000100  // 3.579545 MHz
+#define SYSCTL_RCC_XTAL_3_68MHZ 0x00000140  // 3.6864 MHz
+#define SYSCTL_RCC_XTAL_4MHZ    0x00000180  // 4 MHz (USB)
+#define SYSCTL_RCC_XTAL_4_09MHZ 0x000001C0  // 4.096 MHz
+#define SYSCTL_RCC_XTAL_4_91MHZ 0x00000200  // 4.9152 MHz
+#define SYSCTL_RCC_XTAL_5MHZ    0x00000240  // 5 MHz (USB)
+#define SYSCTL_RCC_XTAL_5_12MHZ 0x00000280  // 5.12 MHz
+#define SYSCTL_RCC_XTAL_6MHZ    0x000002C0  // 6 MHz (reset value)(USB)
+#define SYSCTL_RCC_XTAL_6_14MHZ 0x00000300  // 6.144 MHz
+#define SYSCTL_RCC_XTAL_7_37MHZ 0x00000340  // 7.3728 MHz
+#define SYSCTL_RCC_XTAL_8MHZ    0x00000380  // 8 MHz (USB)
+#define SYSCTL_RCC_XTAL_8_19MHZ 0x000003C0  // 8.192 MHz
+#define SYSCTL_RCC_XTAL_10MHZ   0x00000400  // 10.0 MHz (USB)
+#define SYSCTL_RCC_XTAL_12MHZ   0x00000440  // 12.0 MHz (USB)
+#define SYSCTL_RCC_XTAL_12_2MHZ 0x00000480  // 12.288 MHz
+#define SYSCTL_RCC_XTAL_13_5MHZ 0x000004C0  // 13.56 MHz
+#define SYSCTL_RCC_XTAL_14_3MHZ 0x00000500  // 14.31818 MHz
+#define SYSCTL_RCC_XTAL_16MHZ   0x00000540  // 16.0 MHz (USB)
+#define SYSCTL_RCC_XTAL_16_3MHZ 0x00000580  // 16.384 MHz
+#define SYSCTL_RCC_OSCSRC_M     0x00000030  // Oscillator Source.
+#define SYSCTL_RCC_OSCSRC_MAIN  0x00000000  // MOSC
+#define SYSCTL_RCC_OSCSRC_INT   0x00000010  // PIOSC
+#define SYSCTL_RCC_OSCSRC_INT4  0x00000020  // PIOSC/4
+#define SYSCTL_RCC_OSCSRC_30    0x00000030  // 30 kHz
+#define SYSCTL_RCC_IOSCDIS      0x00000002  // Precision Internal Oscillator
+                                            // Disable.
+#define SYSCTL_RCC_MOSCDIS      0x00000001  // Main Oscillator Disable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PLLCFG register.
+//
+//*****************************************************************************
+#define SYSCTL_PLLCFG_F_M       0x00003FE0  // PLL F Value.
+#define SYSCTL_PLLCFG_R_M       0x0000001F  // PLL R Value.
+#define SYSCTL_PLLCFG_F_S       5
+#define SYSCTL_PLLCFG_R_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_GPIOHBCTL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_GPIOHBCTL_PORTJ  0x00000100  // Port J Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTH  0x00000080  // Port H Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTG  0x00000040  // Port G Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTF  0x00000020  // Port F Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTE  0x00000010  // Port E Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTD  0x00000008  // Port D Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTC  0x00000004  // Port C Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTB  0x00000002  // Port B Advanced Host Bus.
+#define SYSCTL_GPIOHBCTL_PORTA  0x00000001  // Port A Advanced Host Bus.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCC2_USERCC2     0x80000000  // Use RCC2.
+#define SYSCTL_RCC2_USEFRACT    0x40000000  // Use FRACT.
+#define SYSCTL_RCC2_SYSDIV2_M   0x1F800000  // System Clock Divisor.
+#define SYSCTL_RCC2_SYSDIV2_2   0x00800000  // System clock /2
+#define SYSCTL_RCC2_SYSDIV2_3   0x01000000  // System clock /3
+#define SYSCTL_RCC2_SYSDIV2_4   0x01800000  // System clock /4
+#define SYSCTL_RCC2_SYSDIV2_5   0x02000000  // System clock /5
+#define SYSCTL_RCC2_SYSDIV2_6   0x02800000  // System clock /6
+#define SYSCTL_RCC2_SYSDIV2_7   0x03000000  // System clock /7
+#define SYSCTL_RCC2_SYSDIV2_8   0x03800000  // System clock /8
+#define SYSCTL_RCC2_SYSDIV2_9   0x04000000  // System clock /9
+#define SYSCTL_RCC2_SYSDIV2_10  0x04800000  // System clock /10
+#define SYSCTL_RCC2_SYSDIV2_11  0x05000000  // System clock /11
+#define SYSCTL_RCC2_SYSDIV2_12  0x05800000  // System clock /12
+#define SYSCTL_RCC2_SYSDIV2_13  0x06000000  // System clock /13
+#define SYSCTL_RCC2_SYSDIV2_14  0x06800000  // System clock /14
+#define SYSCTL_RCC2_SYSDIV2_15  0x07000000  // System clock /15
+#define SYSCTL_RCC2_SYSDIV2_16  0x07800000  // System clock /16
+#define SYSCTL_RCC2_SYSDIV2_17  0x08000000  // System clock /17
+#define SYSCTL_RCC2_SYSDIV2_18  0x08800000  // System clock /18
+#define SYSCTL_RCC2_SYSDIV2_19  0x09000000  // System clock /19
+#define SYSCTL_RCC2_SYSDIV2_20  0x09800000  // System clock /20
+#define SYSCTL_RCC2_SYSDIV2_21  0x0A000000  // System clock /21
+#define SYSCTL_RCC2_SYSDIV2_22  0x0A800000  // System clock /22
+#define SYSCTL_RCC2_SYSDIV2_23  0x0B000000  // System clock /23
+#define SYSCTL_RCC2_SYSDIV2_24  0x0B800000  // System clock /24
+#define SYSCTL_RCC2_SYSDIV2_25  0x0C000000  // System clock /25
+#define SYSCTL_RCC2_SYSDIV2_26  0x0C800000  // System clock /26
+#define SYSCTL_RCC2_SYSDIV2_27  0x0D000000  // System clock /27
+#define SYSCTL_RCC2_SYSDIV2_28  0x0D800000  // System clock /28
+#define SYSCTL_RCC2_SYSDIV2_29  0x0E000000  // System clock /29
+#define SYSCTL_RCC2_SYSDIV2_30  0x0E800000  // System clock /30
+#define SYSCTL_RCC2_SYSDIV2_31  0x0F000000  // System clock /31
+#define SYSCTL_RCC2_SYSDIV2_32  0x0F800000  // System clock /32
+#define SYSCTL_RCC2_SYSDIV2_33  0x10000000  // System clock /33
+#define SYSCTL_RCC2_SYSDIV2_34  0x10800000  // System clock /34
+#define SYSCTL_RCC2_SYSDIV2_35  0x11000000  // System clock /35
+#define SYSCTL_RCC2_SYSDIV2_36  0x11800000  // System clock /36
+#define SYSCTL_RCC2_SYSDIV2_37  0x12000000  // System clock /37
+#define SYSCTL_RCC2_SYSDIV2_38  0x12800000  // System clock /38
+#define SYSCTL_RCC2_SYSDIV2_39  0x13000000  // System clock /39
+#define SYSCTL_RCC2_SYSDIV2_40  0x13800000  // System clock /40
+#define SYSCTL_RCC2_SYSDIV2_41  0x14000000  // System clock /41
+#define SYSCTL_RCC2_SYSDIV2_42  0x14800000  // System clock /42
+#define SYSCTL_RCC2_SYSDIV2_43  0x15000000  // System clock /43
+#define SYSCTL_RCC2_SYSDIV2_44  0x15800000  // System clock /44
+#define SYSCTL_RCC2_SYSDIV2_45  0x16000000  // System clock /45
+#define SYSCTL_RCC2_SYSDIV2_46  0x16800000  // System clock /46
+#define SYSCTL_RCC2_SYSDIV2_47  0x17000000  // System clock /47
+#define SYSCTL_RCC2_SYSDIV2_48  0x17800000  // System clock /48
+#define SYSCTL_RCC2_SYSDIV2_49  0x18000000  // System clock /49
+#define SYSCTL_RCC2_SYSDIV2_50  0x18800000  // System clock /50
+#define SYSCTL_RCC2_SYSDIV2_51  0x19000000  // System clock /51
+#define SYSCTL_RCC2_SYSDIV2_52  0x19800000  // System clock /52
+#define SYSCTL_RCC2_SYSDIV2_53  0x1A000000  // System clock /53
+#define SYSCTL_RCC2_SYSDIV2_54  0x1A800000  // System clock /54
+#define SYSCTL_RCC2_SYSDIV2_55  0x1B000000  // System clock /55
+#define SYSCTL_RCC2_SYSDIV2_56  0x1B800000  // System clock /56
+#define SYSCTL_RCC2_SYSDIV2_57  0x1C000000  // System clock /57
+#define SYSCTL_RCC2_SYSDIV2_58  0x1C800000  // System clock /58
+#define SYSCTL_RCC2_SYSDIV2_59  0x1D000000  // System clock /59
+#define SYSCTL_RCC2_SYSDIV2_60  0x1D800000  // System clock /60
+#define SYSCTL_RCC2_SYSDIV2_61  0x1E000000  // System clock /61
+#define SYSCTL_RCC2_SYSDIV2_62  0x1E800000  // System clock /62
+#define SYSCTL_RCC2_SYSDIV2_63  0x1F000000  // System clock /63
+#define SYSCTL_RCC2_SYSDIV2_64  0x1F800000  // System clock /64
+#define SYSCTL_RCC2_FRACT       0x00400000  // Fractional Divider.
+#define SYSCTL_RCC2_USBPWRDN    0x00004000  // Power-Down USB PLL.
+#define SYSCTL_RCC2_PWRDN2      0x00002000  // Power-Down PLL.
+#define SYSCTL_RCC2_BYPASS2     0x00000800  // PLL Bypass.
+#define SYSCTL_RCC2_OSCSRC2_M   0x00000070  // Oscillator Source.
+#define SYSCTL_RCC2_OSCSRC2_MO  0x00000000  // MOSC
+#define SYSCTL_RCC2_OSCSRC2_IO  0x00000010  // PIOSC
+#define SYSCTL_RCC2_OSCSRC2_IO4 0x00000020  // PIOSC/4
+#define SYSCTL_RCC2_OSCSRC2_30  0x00000030  // 30 kHz
+#define SYSCTL_RCC2_SYSDIV2_S   23
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_MOSCCTL register.
+//
+//*****************************************************************************
+#define SYSCTL_MOSCCTL_CVAL     0x00000001  // Clock Validation for MOSC.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC0_WDT1       0x10000000  // WDT1 Clock Gating Control.
+#define SYSCTL_RCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
+#define SYSCTL_RCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_RCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_RCGC0_ADC1       0x00020000  // ADC1 Clock Gating Control.
+#define SYSCTL_RCGC0_ADC0       0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_RCGC0_ADC1SPD_M  0x00000C00  // ADC1 Sample Speed.
+#define SYSCTL_RCGC0_ADC1SPD_1M 0x00000C00  // 1M samples/second
+#define SYSCTL_RCGC0_ADC0SPD_M  0x00000300  // ADC0 Sample Speed.
+#define SYSCTL_RCGC0_ADC0SPD_1M 0x00000300  // 1M samples/second
+#define SYSCTL_RCGC0_WDT0       0x00000008  // WDT0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC1_EPI0       0x40000000  // EPI0 Clock Gating.
+#define SYSCTL_RCGC1_I2S0       0x10000000  // I2S0 Clock Gating.
+#define SYSCTL_RCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_RCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_RCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_RCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_RCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_RCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_RCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_RCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_RCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_RCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_RCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_RCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_RCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
+#define SYSCTL_RCGC2_UDMA       0x00002000  // Micro-DMA Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOJ      0x00000100  // Port J Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_RCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC0_WDT1       0x10000000  // WDT1 Clock Gating Control.
+#define SYSCTL_SCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
+#define SYSCTL_SCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_SCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_SCGC0_ADC1       0x00020000  // ADC1 Clock Gating Control.
+#define SYSCTL_SCGC0_ADC0       0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_SCGC0_ADC1SPD_M  0x00000C00  // ADC1 Sample Speed.
+#define SYSCTL_SCGC0_ADC1SPD_1M 0x00000C00  // 1M samples/second
+#define SYSCTL_SCGC0_ADC0SPD_M  0x00000300  // ADC0 Sample Speed.
+#define SYSCTL_SCGC0_ADC0SPD_1M 0x00000300  // 1M samples/second
+#define SYSCTL_SCGC0_WDT0       0x00000008  // WDT0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC1_EPI0       0x40000000  // EPI0 Clock Gating.
+#define SYSCTL_SCGC1_I2S0       0x10000000  // I2S0 Clock Gating.
+#define SYSCTL_SCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_SCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_SCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_SCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_SCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_SCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_SCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_SCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_SCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_SCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_SCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_SCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_SCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
+#define SYSCTL_SCGC2_UDMA       0x00002000  // Micro-DMA Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOJ      0x00000100  // Port J Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_SCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC0 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC0_WDT1       0x10000000  // WDT1 Clock Gating Control.
+#define SYSCTL_DCGC0_CAN1       0x02000000  // CAN1 Clock Gating Control.
+#define SYSCTL_DCGC0_CAN0       0x01000000  // CAN0 Clock Gating Control.
+#define SYSCTL_DCGC0_PWM        0x00100000  // PWM Clock Gating Control.
+#define SYSCTL_DCGC0_ADC1       0x00020000  // ADC1 Clock Gating Control.
+#define SYSCTL_DCGC0_ADC0       0x00010000  // ADC0 Clock Gating Control.
+#define SYSCTL_DCGC0_ADC1SPD_M  0x00000C00  // ADC1 Sample Speed.
+#define SYSCTL_DCGC0_ADC1SPD_1M 0x00000C00  // 1M samples/second
+#define SYSCTL_DCGC0_ADC0SPD_M  0x00000300  // ADC0 Sample Speed.
+#define SYSCTL_DCGC0_ADC0SPD_1M 0x00000300  // 1M samples/second
+#define SYSCTL_DCGC0_WDT0       0x00000008  // WDT0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC1 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC1_EPI0       0x40000000  // EPI0 Clock Gating.
+#define SYSCTL_DCGC1_I2S0       0x10000000  // I2S0 Clock Gating.
+#define SYSCTL_DCGC1_COMP2      0x04000000  // Analog Comparator 2 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_COMP1      0x02000000  // Analog Comparator 1 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_COMP0      0x01000000  // Analog Comparator 0 Clock
+                                            // Gating.
+#define SYSCTL_DCGC1_TIMER3     0x00080000  // Timer 3 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control.
+#define SYSCTL_DCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control.
+#define SYSCTL_DCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control.
+#define SYSCTL_DCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control.
+#define SYSCTL_DCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control.
+#define SYSCTL_DCGC1_UART2      0x00000004  // UART2 Clock Gating Control.
+#define SYSCTL_DCGC1_UART1      0x00000002  // UART1 Clock Gating Control.
+#define SYSCTL_DCGC1_UART0      0x00000001  // UART0 Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DCGC2 register.
+//
+//*****************************************************************************
+#define SYSCTL_DCGC2_EPHY0      0x40000000  // PHY0 Clock Gating Control.
+#define SYSCTL_DCGC2_EMAC0      0x10000000  // MAC0 Clock Gating Control.
+#define SYSCTL_DCGC2_USB0       0x00010000  // USB0 Clock Gating Control.
+#define SYSCTL_DCGC2_UDMA       0x00002000  // Micro-DMA Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOJ      0x00000100  // Port J Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOH      0x00000080  // Port H Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOG      0x00000040  // Port G Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOF      0x00000020  // Port F Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOE      0x00000010  // Port E Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOD      0x00000008  // Port D Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOC      0x00000004  // Port C Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOB      0x00000002  // Port B Clock Gating Control.
+#define SYSCTL_DCGC2_GPIOA      0x00000001  // Port A Clock Gating Control.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSLPCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSLPCLKCFG_D_M   0x1F800000  // Divider Field Override.
+#define SYSCTL_DSLPCLKCFG_D_2   0x00800000  // /2
+#define SYSCTL_DSLPCLKCFG_D_3   0x01000000  // /3
+#define SYSCTL_DSLPCLKCFG_D_4   0x01800000  // /4
+#define SYSCTL_DSLPCLKCFG_D_5   0x02000000  // /5
+#define SYSCTL_DSLPCLKCFG_D_6   0x02800000  // /6
+#define SYSCTL_DSLPCLKCFG_D_7   0x03000000  // /7
+#define SYSCTL_DSLPCLKCFG_D_8   0x03800000  // /8
+#define SYSCTL_DSLPCLKCFG_D_9   0x04000000  // /9
+#define SYSCTL_DSLPCLKCFG_D_10  0x04800000  // /10
+#define SYSCTL_DSLPCLKCFG_D_11  0x05000000  // /11
+#define SYSCTL_DSLPCLKCFG_D_12  0x05800000  // /12
+#define SYSCTL_DSLPCLKCFG_D_13  0x06000000  // /13
+#define SYSCTL_DSLPCLKCFG_D_14  0x06800000  // /14
+#define SYSCTL_DSLPCLKCFG_D_15  0x07000000  // /15
+#define SYSCTL_DSLPCLKCFG_D_16  0x07800000  // /16
+#define SYSCTL_DSLPCLKCFG_O_M   0x00000070  // Clock Source.
+#define SYSCTL_DSLPCLKCFG_O_IGN 0x00000000  // MOSC
+#define SYSCTL_DSLPCLKCFG_O_IO  0x00000010  // PIOSC
+#define SYSCTL_DSLPCLKCFG_O_30  0x00000030  // 30 kHz
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DSFLASHCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_DSFLASHCFG_SHDWN 0x00000001  // Flash Shutdown.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_PIOSCCAL
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_PIOSCCAL_UTEN    0x80000000  // Use User Trim Value.
+#define SYSCTL_PIOSCCAL_UPDATE  0x00000100  // Update Trim.
+#define SYSCTL_PIOSCCAL_UT_M    0x0000007F  // User Trim Value.
+#define SYSCTL_PIOSCCAL_UT_S    0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_I2SMCLKCFG
+// register.
+//
+//*****************************************************************************
+#define SYSCTL_I2SMCLKCFG_RXEN  0x80000000  // RX Clock Enable.
+#define SYSCTL_I2SMCLKCFG_RXI_M 0x0FF00000  // RX Clock Integer Input.
+#define SYSCTL_I2SMCLKCFG_RXF_M 0x000F0000  // RX Clock Fractional Input.
+#define SYSCTL_I2SMCLKCFG_TXEN  0x00008000  // TX Clock Enable.
+#define SYSCTL_I2SMCLKCFG_TXI_M 0x00000FF0  // TX Clock Integer Input.
+#define SYSCTL_I2SMCLKCFG_TXF_M 0x0000000F  // TX Clock Fractional Input.
+#define SYSCTL_I2SMCLKCFG_RXI_S 20
+#define SYSCTL_I2SMCLKCFG_RXF_S 16
+#define SYSCTL_I2SMCLKCFG_TXI_S 4
+#define SYSCTL_I2SMCLKCFG_TXF_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_DC9 register.
+//
+//*****************************************************************************
+#define SYSCTL_DC9_ADC1DC7      0x00800000  // ADC1 DC7 Present.
+#define SYSCTL_DC9_ADC1DC6      0x00400000  // ADC1 DC6 Present.
+#define SYSCTL_DC9_ADC1DC5      0x00200000  // ADC1 DC5 Present.
+#define SYSCTL_DC9_ADC1DC4      0x00100000  // ADC1 DC4 Present.
+#define SYSCTL_DC9_ADC1DC3      0x00080000  // ADC1 DC3 Present.
+#define SYSCTL_DC9_ADC1DC2      0x00040000  // ADC1 DC2 Present.
+#define SYSCTL_DC9_ADC1DC1      0x00020000  // ADC1 DC1 Present.
+#define SYSCTL_DC9_ADC1DC0      0x00010000  // ADC1 DC0 Present.
+#define SYSCTL_DC9_ADC0DC7      0x00000080  // ADC0 DC7 Present.
+#define SYSCTL_DC9_ADC0DC6      0x00000040  // ADC0 DC6 Present.
+#define SYSCTL_DC9_ADC0DC5      0x00000020  // ADC0 DC5 Present.
+#define SYSCTL_DC9_ADC0DC4      0x00000010  // ADC0 DC4 Present.
+#define SYSCTL_DC9_ADC0DC3      0x00000008  // ADC0 DC3 Present.
+#define SYSCTL_DC9_ADC0DC2      0x00000004  // ADC0 DC2 Present.
+#define SYSCTL_DC9_ADC0DC1      0x00000002  // ADC0 DC1 Present.
+#define SYSCTL_DC9_ADC0DC0      0x00000001  // ADC0 DC0 Present.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the SYSCTL_NVMSTAT register.
+//
+//*****************************************************************************
+#define SYSCTL_NVMSTAT_FWB      0x00000001  // 32 Word Flash Write Buffer
+                                            // Active.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_SRCENDP register.
+//
+//*****************************************************************************
+#define UDMA_SRCENDP_ADDR_M     0xFFFFFFFF  // Source Address End Pointer.
+#define UDMA_SRCENDP_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_DSTENDP register.
+//
+//*****************************************************************************
+#define UDMA_DSTENDP_ADDR_M     0xFFFFFFFF  // Destination Address End Pointer.
+#define UDMA_DSTENDP_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_O_CHCTL register.
+//
+//*****************************************************************************
+#define UDMA_CHCTL_DSTINC_M     0xC0000000  // Destination Address Increment.
+#define UDMA_CHCTL_DSTINC_8     0x00000000  // Byte
+#define UDMA_CHCTL_DSTINC_16    0x40000000  // Half-word
+#define UDMA_CHCTL_DSTINC_32    0x80000000  // Word
+#define UDMA_CHCTL_DSTINC_NONE  0xC0000000  // No increment
+#define UDMA_CHCTL_DSTSIZE_M    0x30000000  // Destination Data Size.
+#define UDMA_CHCTL_DSTSIZE_8    0x00000000  // Byte
+#define UDMA_CHCTL_DSTSIZE_16   0x10000000  // Half-word
+#define UDMA_CHCTL_DSTSIZE_32   0x20000000  // Word
+#define UDMA_CHCTL_SRCINC_M     0x0C000000  // Source Address Increment.
+#define UDMA_CHCTL_SRCINC_8     0x00000000  // Byte
+#define UDMA_CHCTL_SRCINC_16    0x04000000  // Half-word
+#define UDMA_CHCTL_SRCINC_32    0x08000000  // Word
+#define UDMA_CHCTL_SRCINC_NONE  0x0C000000  // No increment
+#define UDMA_CHCTL_SRCSIZE_M    0x03000000  // Source Data Size.
+#define UDMA_CHCTL_SRCSIZE_8    0x00000000  // Byte
+#define UDMA_CHCTL_SRCSIZE_16   0x01000000  // Half-word
+#define UDMA_CHCTL_SRCSIZE_32   0x02000000  // Word
+#define UDMA_CHCTL_ARBSIZE_M    0x0003C000  // Arbitration Size.
+#define UDMA_CHCTL_ARBSIZE_1    0x00000000  // 1 Transfer
+#define UDMA_CHCTL_ARBSIZE_2    0x00004000  // 2 Transfers
+#define UDMA_CHCTL_ARBSIZE_4    0x00008000  // 4 Transfers
+#define UDMA_CHCTL_ARBSIZE_8    0x0000C000  // 8 Transfers
+#define UDMA_CHCTL_ARBSIZE_16   0x00010000  // 16 Transfers
+#define UDMA_CHCTL_ARBSIZE_32   0x00014000  // 32 Transfers
+#define UDMA_CHCTL_ARBSIZE_64   0x00018000  // 64 Transfers
+#define UDMA_CHCTL_ARBSIZE_128  0x0001C000  // 128 Transfers
+#define UDMA_CHCTL_ARBSIZE_256  0x00020000  // 256 Transfers
+#define UDMA_CHCTL_ARBSIZE_512  0x00024000  // 512 Transfers
+#define UDMA_CHCTL_ARBSIZE_1024 0x00028000  // 1024 Transfers
+#define UDMA_CHCTL_XFERSIZE_M   0x00003FF0  // Transfer Size (minus 1).
+#define UDMA_CHCTL_NXTUSEBURST  0x00000008  // Next Useburst.
+#define UDMA_CHCTL_XFERMODE_M   0x00000007  // DMA Transfer Mode.
+#define UDMA_CHCTL_XFERMODE_STOP \
+                                0x00000000  // Stop
+#define UDMA_CHCTL_XFERMODE_BASIC \
+                                0x00000001  // Basic
+#define UDMA_CHCTL_XFERMODE_AUTO \
+                                0x00000002  // Auto-Request
+#define UDMA_CHCTL_XFERMODE_PINGPONG \
+                                0x00000003  // Ping-Pong
+#define UDMA_CHCTL_XFERMODE_MEM_SG \
+                                0x00000004  // Memory Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_MEM_SGA \
+                                0x00000005  // Alternate Memory Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_PER_SG \
+                                0x00000006  // Peripheral Scatter-Gather
+#define UDMA_CHCTL_XFERMODE_PER_SGA \
+                                0x00000007  // Alternate Peripheral
+                                            // Scatter-Gather
+#define UDMA_CHCTL_XFERSIZE_S   4
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_STAT register.
+//
+//*****************************************************************************
+#define UDMA_STAT_DMACHANS_M    0x001F0000  // Available DMA Channels Minus 1.
+#define UDMA_STAT_STATE_M       0x000000F0  // Control State Machine Status.
+#define UDMA_STAT_STATE_IDLE    0x00000000  // Idle
+#define UDMA_STAT_STATE_RD_CTRL 0x00000010  // Read Chan Control Data
+#define UDMA_STAT_STATE_RD_SRCENDP \
+                                0x00000020  // Read Source End Ptr
+#define UDMA_STAT_STATE_RD_DSTENDP \
+                                0x00000030  // Read Dest End Ptr
+#define UDMA_STAT_STATE_RD_SRCDAT \
+                                0x00000040  // Read Source Data
+#define UDMA_STAT_STATE_WR_DSTDAT \
+                                0x00000050  // Write Dest Data
+#define UDMA_STAT_STATE_WAIT    0x00000060  // Wait for Req Clear
+#define UDMA_STAT_STATE_WR_CTRL 0x00000070  // Write Chan Control Data
+#define UDMA_STAT_STATE_STALL   0x00000080  // Stalled
+#define UDMA_STAT_STATE_DONE    0x00000090  // Done
+#define UDMA_STAT_STATE_UNDEF   0x000000A0  // Undefined
+#define UDMA_STAT_MASTEN        0x00000001  // Master Enable.
+#define UDMA_STAT_DMACHANS_S    16
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CFG register.
+//
+//*****************************************************************************
+#define UDMA_CFG_MASTEN         0x00000001  // Controller Master Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CTLBASE register.
+//
+//*****************************************************************************
+#define UDMA_CTLBASE_ADDR_M     0xFFFFFC00  // Channel Control Base Address.
+#define UDMA_CTLBASE_ADDR_S     10
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTBASE register.
+//
+//*****************************************************************************
+#define UDMA_ALTBASE_ADDR_M     0xFFFFFFFF  // Alternate Channel Address
+                                            // Pointer.
+#define UDMA_ALTBASE_ADDR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_WAITSTAT register.
+//
+//*****************************************************************************
+#define UDMA_WAITSTAT_WAITREQ_M 0xFFFFFFFF  // Channel [n] Wait Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_SWREQ register.
+//
+//*****************************************************************************
+#define UDMA_SWREQ_M            0xFFFFFFFF  // Channel [n] Software Request.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_USEBURSTSET
+// register.
+//
+//*****************************************************************************
+#define UDMA_USEBURSTSET_SET_M  0xFFFFFFFF  // Channel [n] Useburst Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_USEBURSTCLR
+// register.
+//
+//*****************************************************************************
+#define UDMA_USEBURSTCLR_CLR_M  0xFFFFFFFF  // Channel [n] Useburst Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_REQMASKSET
+// register.
+//
+//*****************************************************************************
+#define UDMA_REQMASKSET_SET_M   0xFFFFFFFF  // Channel [n] Request Mask Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_REQMASKCLR
+// register.
+//
+//*****************************************************************************
+#define UDMA_REQMASKCLR_CLR_M   0xFFFFFFFF  // Channel [n] Request Mask Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ENASET register.
+//
+//*****************************************************************************
+#define UDMA_ENASET_SET_M       0xFFFFFFFF  // Channel [n] Enable Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ENACLR register.
+//
+//*****************************************************************************
+#define UDMA_ENACLR_CLR_M       0xFFFFFFFF  // Clear Channel [n] Enable.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTSET register.
+//
+//*****************************************************************************
+#define UDMA_ALTSET_SET_M       0xFFFFFFFF  // Channel [n] Alternate Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ALTCLR register.
+//
+//*****************************************************************************
+#define UDMA_ALTCLR_CLR_M       0xFFFFFFFF  // Channel [n] Alternate Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_PRIOSET register.
+//
+//*****************************************************************************
+#define UDMA_PRIOSET_SET_M      0xFFFFFFFF  // Channel [n] Priority Set.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_PRIOCLR register.
+//
+//*****************************************************************************
+#define UDMA_PRIOCLR_CLR_M      0xFFFFFFFF  // Channel [n] Priority Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_ERRCLR register.
+//
+//*****************************************************************************
+#define UDMA_ERRCLR_ERRCLR      0x00000001  // DMA Bus Error Clear.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHALT register.
+//
+//*****************************************************************************
+#define UDMA_CHALT_M            0xFFFFFFFF  // Channel [n] Alternate Assignment
+                                            // Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the UDMA_CHIS register.
+//
+//*****************************************************************************
+#define UDMA_CHIS_M             0xFFFFFFFF  // Channel [n] Interrupt Status.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_INT_TYPE_LINES_M   0x0000001F  // Number of interrupt lines (x32)
+#define NVIC_INT_TYPE_LINES_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CTRL_COUNT      0x00010000  // Count flag
+#define NVIC_ST_CTRL_CLK_SRC    0x00000004  // Clock Source
+#define NVIC_ST_CTRL_INTEN      0x00000002  // Interrupt enable
+#define NVIC_ST_CTRL_ENABLE     0x00000001  // Counter mode
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_RELOAD register.
+//
+//*****************************************************************************
+#define NVIC_ST_RELOAD_M        0x00FFFFFF  // Counter load value
+#define NVIC_ST_RELOAD_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CURRENT
+// register.
+//
+//*****************************************************************************
+#define NVIC_ST_CURRENT_M       0x00FFFFFF  // Counter current value
+#define NVIC_ST_CURRENT_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ST_CAL register.
+//
+//*****************************************************************************
+#define NVIC_ST_CAL_NOREF       0x80000000  // No reference clock
+#define NVIC_ST_CAL_SKEW        0x40000000  // Clock skew
+#define NVIC_ST_CAL_ONEMS_M     0x00FFFFFF  // 1ms reference value
+#define NVIC_ST_CAL_ONEMS_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN0 register.
+//
+//*****************************************************************************
+#define NVIC_EN0_INT31          0x80000000  // Interrupt 31 enable
+#define NVIC_EN0_INT30          0x40000000  // Interrupt 30 enable
+#define NVIC_EN0_INT29          0x20000000  // Interrupt 29 enable
+#define NVIC_EN0_INT28          0x10000000  // Interrupt 28 enable
+#define NVIC_EN0_INT27          0x08000000  // Interrupt 27 enable
+#define NVIC_EN0_INT26          0x04000000  // Interrupt 26 enable
+#define NVIC_EN0_INT25          0x02000000  // Interrupt 25 enable
+#define NVIC_EN0_INT24          0x01000000  // Interrupt 24 enable
+#define NVIC_EN0_INT23          0x00800000  // Interrupt 23 enable
+#define NVIC_EN0_INT22          0x00400000  // Interrupt 22 enable
+#define NVIC_EN0_INT21          0x00200000  // Interrupt 21 enable
+#define NVIC_EN0_INT20          0x00100000  // Interrupt 20 enable
+#define NVIC_EN0_INT19          0x00080000  // Interrupt 19 enable
+#define NVIC_EN0_INT18          0x00040000  // Interrupt 18 enable
+#define NVIC_EN0_INT17          0x00020000  // Interrupt 17 enable
+#define NVIC_EN0_INT16          0x00010000  // Interrupt 16 enable
+#define NVIC_EN0_INT15          0x00008000  // Interrupt 15 enable
+#define NVIC_EN0_INT14          0x00004000  // Interrupt 14 enable
+#define NVIC_EN0_INT13          0x00002000  // Interrupt 13 enable
+#define NVIC_EN0_INT12          0x00001000  // Interrupt 12 enable
+#define NVIC_EN0_INT11          0x00000800  // Interrupt 11 enable
+#define NVIC_EN0_INT10          0x00000400  // Interrupt 10 enable
+#define NVIC_EN0_INT9           0x00000200  // Interrupt 9 enable
+#define NVIC_EN0_INT8           0x00000100  // Interrupt 8 enable
+#define NVIC_EN0_INT7           0x00000080  // Interrupt 7 enable
+#define NVIC_EN0_INT6           0x00000040  // Interrupt 6 enable
+#define NVIC_EN0_INT5           0x00000020  // Interrupt 5 enable
+#define NVIC_EN0_INT4           0x00000010  // Interrupt 4 enable
+#define NVIC_EN0_INT3           0x00000008  // Interrupt 3 enable
+#define NVIC_EN0_INT2           0x00000004  // Interrupt 2 enable
+#define NVIC_EN0_INT1           0x00000002  // Interrupt 1 enable
+#define NVIC_EN0_INT0           0x00000001  // Interrupt 0 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_EN1 register.
+//
+//*****************************************************************************
+#define NVIC_EN1_INT59          0x08000000  // Interrupt 59 enable
+#define NVIC_EN1_INT58          0x04000000  // Interrupt 58 enable
+#define NVIC_EN1_INT57          0x02000000  // Interrupt 57 enable
+#define NVIC_EN1_INT56          0x01000000  // Interrupt 56 enable
+#define NVIC_EN1_INT55          0x00800000  // Interrupt 55 enable
+#define NVIC_EN1_INT54          0x00400000  // Interrupt 54 enable
+#define NVIC_EN1_INT53          0x00200000  // Interrupt 53 enable
+#define NVIC_EN1_INT52          0x00100000  // Interrupt 52 enable
+#define NVIC_EN1_INT51          0x00080000  // Interrupt 51 enable
+#define NVIC_EN1_INT50          0x00040000  // Interrupt 50 enable
+#define NVIC_EN1_INT49          0x00020000  // Interrupt 49 enable
+#define NVIC_EN1_INT48          0x00010000  // Interrupt 48 enable
+#define NVIC_EN1_INT47          0x00008000  // Interrupt 47 enable
+#define NVIC_EN1_INT46          0x00004000  // Interrupt 46 enable
+#define NVIC_EN1_INT45          0x00002000  // Interrupt 45 enable
+#define NVIC_EN1_INT44          0x00001000  // Interrupt 44 enable
+#define NVIC_EN1_INT43          0x00000800  // Interrupt 43 enable
+#define NVIC_EN1_INT42          0x00000400  // Interrupt 42 enable
+#define NVIC_EN1_INT41          0x00000200  // Interrupt 41 enable
+#define NVIC_EN1_INT40          0x00000100  // Interrupt 40 enable
+#define NVIC_EN1_INT39          0x00000080  // Interrupt 39 enable
+#define NVIC_EN1_INT38          0x00000040  // Interrupt 38 enable
+#define NVIC_EN1_INT37          0x00000020  // Interrupt 37 enable
+#define NVIC_EN1_INT36          0x00000010  // Interrupt 36 enable
+#define NVIC_EN1_INT35          0x00000008  // Interrupt 35 enable
+#define NVIC_EN1_INT34          0x00000004  // Interrupt 34 enable
+#define NVIC_EN1_INT33          0x00000002  // Interrupt 33 enable
+#define NVIC_EN1_INT32          0x00000001  // Interrupt 32 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS0 register.
+//
+//*****************************************************************************
+#define NVIC_DIS0_INT31         0x80000000  // Interrupt 31 disable
+#define NVIC_DIS0_INT30         0x40000000  // Interrupt 30 disable
+#define NVIC_DIS0_INT29         0x20000000  // Interrupt 29 disable
+#define NVIC_DIS0_INT28         0x10000000  // Interrupt 28 disable
+#define NVIC_DIS0_INT27         0x08000000  // Interrupt 27 disable
+#define NVIC_DIS0_INT26         0x04000000  // Interrupt 26 disable
+#define NVIC_DIS0_INT25         0x02000000  // Interrupt 25 disable
+#define NVIC_DIS0_INT24         0x01000000  // Interrupt 24 disable
+#define NVIC_DIS0_INT23         0x00800000  // Interrupt 23 disable
+#define NVIC_DIS0_INT22         0x00400000  // Interrupt 22 disable
+#define NVIC_DIS0_INT21         0x00200000  // Interrupt 21 disable
+#define NVIC_DIS0_INT20         0x00100000  // Interrupt 20 disable
+#define NVIC_DIS0_INT19         0x00080000  // Interrupt 19 disable
+#define NVIC_DIS0_INT18         0x00040000  // Interrupt 18 disable
+#define NVIC_DIS0_INT17         0x00020000  // Interrupt 17 disable
+#define NVIC_DIS0_INT16         0x00010000  // Interrupt 16 disable
+#define NVIC_DIS0_INT15         0x00008000  // Interrupt 15 disable
+#define NVIC_DIS0_INT14         0x00004000  // Interrupt 14 disable
+#define NVIC_DIS0_INT13         0x00002000  // Interrupt 13 disable
+#define NVIC_DIS0_INT12         0x00001000  // Interrupt 12 disable
+#define NVIC_DIS0_INT11         0x00000800  // Interrupt 11 disable
+#define NVIC_DIS0_INT10         0x00000400  // Interrupt 10 disable
+#define NVIC_DIS0_INT9          0x00000200  // Interrupt 9 disable
+#define NVIC_DIS0_INT8          0x00000100  // Interrupt 8 disable
+#define NVIC_DIS0_INT7          0x00000080  // Interrupt 7 disable
+#define NVIC_DIS0_INT6          0x00000040  // Interrupt 6 disable
+#define NVIC_DIS0_INT5          0x00000020  // Interrupt 5 disable
+#define NVIC_DIS0_INT4          0x00000010  // Interrupt 4 disable
+#define NVIC_DIS0_INT3          0x00000008  // Interrupt 3 disable
+#define NVIC_DIS0_INT2          0x00000004  // Interrupt 2 disable
+#define NVIC_DIS0_INT1          0x00000002  // Interrupt 1 disable
+#define NVIC_DIS0_INT0          0x00000001  // Interrupt 0 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DIS1 register.
+//
+//*****************************************************************************
+#define NVIC_DIS1_INT59         0x08000000  // Interrupt 59 disable
+#define NVIC_DIS1_INT58         0x04000000  // Interrupt 58 disable
+#define NVIC_DIS1_INT57         0x02000000  // Interrupt 57 disable
+#define NVIC_DIS1_INT56         0x01000000  // Interrupt 56 disable
+#define NVIC_DIS1_INT55         0x00800000  // Interrupt 55 disable
+#define NVIC_DIS1_INT54         0x00400000  // Interrupt 54 disable
+#define NVIC_DIS1_INT53         0x00200000  // Interrupt 53 disable
+#define NVIC_DIS1_INT52         0x00100000  // Interrupt 52 disable
+#define NVIC_DIS1_INT51         0x00080000  // Interrupt 51 disable
+#define NVIC_DIS1_INT50         0x00040000  // Interrupt 50 disable
+#define NVIC_DIS1_INT49         0x00020000  // Interrupt 49 disable
+#define NVIC_DIS1_INT48         0x00010000  // Interrupt 48 disable
+#define NVIC_DIS1_INT47         0x00008000  // Interrupt 47 disable
+#define NVIC_DIS1_INT46         0x00004000  // Interrupt 46 disable
+#define NVIC_DIS1_INT45         0x00002000  // Interrupt 45 disable
+#define NVIC_DIS1_INT44         0x00001000  // Interrupt 44 disable
+#define NVIC_DIS1_INT43         0x00000800  // Interrupt 43 disable
+#define NVIC_DIS1_INT42         0x00000400  // Interrupt 42 disable
+#define NVIC_DIS1_INT41         0x00000200  // Interrupt 41 disable
+#define NVIC_DIS1_INT40         0x00000100  // Interrupt 40 disable
+#define NVIC_DIS1_INT39         0x00000080  // Interrupt 39 disable
+#define NVIC_DIS1_INT38         0x00000040  // Interrupt 38 disable
+#define NVIC_DIS1_INT37         0x00000020  // Interrupt 37 disable
+#define NVIC_DIS1_INT36         0x00000010  // Interrupt 36 disable
+#define NVIC_DIS1_INT35         0x00000008  // Interrupt 35 disable
+#define NVIC_DIS1_INT34         0x00000004  // Interrupt 34 disable
+#define NVIC_DIS1_INT33         0x00000002  // Interrupt 33 disable
+#define NVIC_DIS1_INT32         0x00000001  // Interrupt 32 disable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND0 register.
+//
+//*****************************************************************************
+#define NVIC_PEND0_INT31        0x80000000  // Interrupt 31 pend
+#define NVIC_PEND0_INT30        0x40000000  // Interrupt 30 pend
+#define NVIC_PEND0_INT29        0x20000000  // Interrupt 29 pend
+#define NVIC_PEND0_INT28        0x10000000  // Interrupt 28 pend
+#define NVIC_PEND0_INT27        0x08000000  // Interrupt 27 pend
+#define NVIC_PEND0_INT26        0x04000000  // Interrupt 26 pend
+#define NVIC_PEND0_INT25        0x02000000  // Interrupt 25 pend
+#define NVIC_PEND0_INT24        0x01000000  // Interrupt 24 pend
+#define NVIC_PEND0_INT23        0x00800000  // Interrupt 23 pend
+#define NVIC_PEND0_INT22        0x00400000  // Interrupt 22 pend
+#define NVIC_PEND0_INT21        0x00200000  // Interrupt 21 pend
+#define NVIC_PEND0_INT20        0x00100000  // Interrupt 20 pend
+#define NVIC_PEND0_INT19        0x00080000  // Interrupt 19 pend
+#define NVIC_PEND0_INT18        0x00040000  // Interrupt 18 pend
+#define NVIC_PEND0_INT17        0x00020000  // Interrupt 17 pend
+#define NVIC_PEND0_INT16        0x00010000  // Interrupt 16 pend
+#define NVIC_PEND0_INT15        0x00008000  // Interrupt 15 pend
+#define NVIC_PEND0_INT14        0x00004000  // Interrupt 14 pend
+#define NVIC_PEND0_INT13        0x00002000  // Interrupt 13 pend
+#define NVIC_PEND0_INT12        0x00001000  // Interrupt 12 pend
+#define NVIC_PEND0_INT11        0x00000800  // Interrupt 11 pend
+#define NVIC_PEND0_INT10        0x00000400  // Interrupt 10 pend
+#define NVIC_PEND0_INT9         0x00000200  // Interrupt 9 pend
+#define NVIC_PEND0_INT8         0x00000100  // Interrupt 8 pend
+#define NVIC_PEND0_INT7         0x00000080  // Interrupt 7 pend
+#define NVIC_PEND0_INT6         0x00000040  // Interrupt 6 pend
+#define NVIC_PEND0_INT5         0x00000020  // Interrupt 5 pend
+#define NVIC_PEND0_INT4         0x00000010  // Interrupt 4 pend
+#define NVIC_PEND0_INT3         0x00000008  // Interrupt 3 pend
+#define NVIC_PEND0_INT2         0x00000004  // Interrupt 2 pend
+#define NVIC_PEND0_INT1         0x00000002  // Interrupt 1 pend
+#define NVIC_PEND0_INT0         0x00000001  // Interrupt 0 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PEND1 register.
+//
+//*****************************************************************************
+#define NVIC_PEND1_INT59        0x08000000  // Interrupt 59 pend
+#define NVIC_PEND1_INT58        0x04000000  // Interrupt 58 pend
+#define NVIC_PEND1_INT57        0x02000000  // Interrupt 57 pend
+#define NVIC_PEND1_INT56        0x01000000  // Interrupt 56 pend
+#define NVIC_PEND1_INT55        0x00800000  // Interrupt 55 pend
+#define NVIC_PEND1_INT54        0x00400000  // Interrupt 54 pend
+#define NVIC_PEND1_INT53        0x00200000  // Interrupt 53 pend
+#define NVIC_PEND1_INT52        0x00100000  // Interrupt 52 pend
+#define NVIC_PEND1_INT51        0x00080000  // Interrupt 51 pend
+#define NVIC_PEND1_INT50        0x00040000  // Interrupt 50 pend
+#define NVIC_PEND1_INT49        0x00020000  // Interrupt 49 pend
+#define NVIC_PEND1_INT48        0x00010000  // Interrupt 48 pend
+#define NVIC_PEND1_INT47        0x00008000  // Interrupt 47 pend
+#define NVIC_PEND1_INT46        0x00004000  // Interrupt 46 pend
+#define NVIC_PEND1_INT45        0x00002000  // Interrupt 45 pend
+#define NVIC_PEND1_INT44        0x00001000  // Interrupt 44 pend
+#define NVIC_PEND1_INT43        0x00000800  // Interrupt 43 pend
+#define NVIC_PEND1_INT42        0x00000400  // Interrupt 42 pend
+#define NVIC_PEND1_INT41        0x00000200  // Interrupt 41 pend
+#define NVIC_PEND1_INT40        0x00000100  // Interrupt 40 pend
+#define NVIC_PEND1_INT39        0x00000080  // Interrupt 39 pend
+#define NVIC_PEND1_INT38        0x00000040  // Interrupt 38 pend
+#define NVIC_PEND1_INT37        0x00000020  // Interrupt 37 pend
+#define NVIC_PEND1_INT36        0x00000010  // Interrupt 36 pend
+#define NVIC_PEND1_INT35        0x00000008  // Interrupt 35 pend
+#define NVIC_PEND1_INT34        0x00000004  // Interrupt 34 pend
+#define NVIC_PEND1_INT33        0x00000002  // Interrupt 33 pend
+#define NVIC_PEND1_INT32        0x00000001  // Interrupt 32 pend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND0 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND0_INT31      0x80000000  // Interrupt 31 unpend
+#define NVIC_UNPEND0_INT30      0x40000000  // Interrupt 30 unpend
+#define NVIC_UNPEND0_INT29      0x20000000  // Interrupt 29 unpend
+#define NVIC_UNPEND0_INT28      0x10000000  // Interrupt 28 unpend
+#define NVIC_UNPEND0_INT27      0x08000000  // Interrupt 27 unpend
+#define NVIC_UNPEND0_INT26      0x04000000  // Interrupt 26 unpend
+#define NVIC_UNPEND0_INT25      0x02000000  // Interrupt 25 unpend
+#define NVIC_UNPEND0_INT24      0x01000000  // Interrupt 24 unpend
+#define NVIC_UNPEND0_INT23      0x00800000  // Interrupt 23 unpend
+#define NVIC_UNPEND0_INT22      0x00400000  // Interrupt 22 unpend
+#define NVIC_UNPEND0_INT21      0x00200000  // Interrupt 21 unpend
+#define NVIC_UNPEND0_INT20      0x00100000  // Interrupt 20 unpend
+#define NVIC_UNPEND0_INT19      0x00080000  // Interrupt 19 unpend
+#define NVIC_UNPEND0_INT18      0x00040000  // Interrupt 18 unpend
+#define NVIC_UNPEND0_INT17      0x00020000  // Interrupt 17 unpend
+#define NVIC_UNPEND0_INT16      0x00010000  // Interrupt 16 unpend
+#define NVIC_UNPEND0_INT15      0x00008000  // Interrupt 15 unpend
+#define NVIC_UNPEND0_INT14      0x00004000  // Interrupt 14 unpend
+#define NVIC_UNPEND0_INT13      0x00002000  // Interrupt 13 unpend
+#define NVIC_UNPEND0_INT12      0x00001000  // Interrupt 12 unpend
+#define NVIC_UNPEND0_INT11      0x00000800  // Interrupt 11 unpend
+#define NVIC_UNPEND0_INT10      0x00000400  // Interrupt 10 unpend
+#define NVIC_UNPEND0_INT9       0x00000200  // Interrupt 9 unpend
+#define NVIC_UNPEND0_INT8       0x00000100  // Interrupt 8 unpend
+#define NVIC_UNPEND0_INT7       0x00000080  // Interrupt 7 unpend
+#define NVIC_UNPEND0_INT6       0x00000040  // Interrupt 6 unpend
+#define NVIC_UNPEND0_INT5       0x00000020  // Interrupt 5 unpend
+#define NVIC_UNPEND0_INT4       0x00000010  // Interrupt 4 unpend
+#define NVIC_UNPEND0_INT3       0x00000008  // Interrupt 3 unpend
+#define NVIC_UNPEND0_INT2       0x00000004  // Interrupt 2 unpend
+#define NVIC_UNPEND0_INT1       0x00000002  // Interrupt 1 unpend
+#define NVIC_UNPEND0_INT0       0x00000001  // Interrupt 0 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_UNPEND1 register.
+//
+//*****************************************************************************
+#define NVIC_UNPEND1_INT59      0x08000000  // Interrupt 59 unpend
+#define NVIC_UNPEND1_INT58      0x04000000  // Interrupt 58 unpend
+#define NVIC_UNPEND1_INT57      0x02000000  // Interrupt 57 unpend
+#define NVIC_UNPEND1_INT56      0x01000000  // Interrupt 56 unpend
+#define NVIC_UNPEND1_INT55      0x00800000  // Interrupt 55 unpend
+#define NVIC_UNPEND1_INT54      0x00400000  // Interrupt 54 unpend
+#define NVIC_UNPEND1_INT53      0x00200000  // Interrupt 53 unpend
+#define NVIC_UNPEND1_INT52      0x00100000  // Interrupt 52 unpend
+#define NVIC_UNPEND1_INT51      0x00080000  // Interrupt 51 unpend
+#define NVIC_UNPEND1_INT50      0x00040000  // Interrupt 50 unpend
+#define NVIC_UNPEND1_INT49      0x00020000  // Interrupt 49 unpend
+#define NVIC_UNPEND1_INT48      0x00010000  // Interrupt 48 unpend
+#define NVIC_UNPEND1_INT47      0x00008000  // Interrupt 47 unpend
+#define NVIC_UNPEND1_INT46      0x00004000  // Interrupt 46 unpend
+#define NVIC_UNPEND1_INT45      0x00002000  // Interrupt 45 unpend
+#define NVIC_UNPEND1_INT44      0x00001000  // Interrupt 44 unpend
+#define NVIC_UNPEND1_INT43      0x00000800  // Interrupt 43 unpend
+#define NVIC_UNPEND1_INT42      0x00000400  // Interrupt 42 unpend
+#define NVIC_UNPEND1_INT41      0x00000200  // Interrupt 41 unpend
+#define NVIC_UNPEND1_INT40      0x00000100  // Interrupt 40 unpend
+#define NVIC_UNPEND1_INT39      0x00000080  // Interrupt 39 unpend
+#define NVIC_UNPEND1_INT38      0x00000040  // Interrupt 38 unpend
+#define NVIC_UNPEND1_INT37      0x00000020  // Interrupt 37 unpend
+#define NVIC_UNPEND1_INT36      0x00000010  // Interrupt 36 unpend
+#define NVIC_UNPEND1_INT35      0x00000008  // Interrupt 35 unpend
+#define NVIC_UNPEND1_INT34      0x00000004  // Interrupt 34 unpend
+#define NVIC_UNPEND1_INT33      0x00000002  // Interrupt 33 unpend
+#define NVIC_UNPEND1_INT32      0x00000001  // Interrupt 32 unpend
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE0 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE0_INT31      0x80000000  // Interrupt 31 active
+#define NVIC_ACTIVE0_INT30      0x40000000  // Interrupt 30 active
+#define NVIC_ACTIVE0_INT29      0x20000000  // Interrupt 29 active
+#define NVIC_ACTIVE0_INT28      0x10000000  // Interrupt 28 active
+#define NVIC_ACTIVE0_INT27      0x08000000  // Interrupt 27 active
+#define NVIC_ACTIVE0_INT26      0x04000000  // Interrupt 26 active
+#define NVIC_ACTIVE0_INT25      0x02000000  // Interrupt 25 active
+#define NVIC_ACTIVE0_INT24      0x01000000  // Interrupt 24 active
+#define NVIC_ACTIVE0_INT23      0x00800000  // Interrupt 23 active
+#define NVIC_ACTIVE0_INT22      0x00400000  // Interrupt 22 active
+#define NVIC_ACTIVE0_INT21      0x00200000  // Interrupt 21 active
+#define NVIC_ACTIVE0_INT20      0x00100000  // Interrupt 20 active
+#define NVIC_ACTIVE0_INT19      0x00080000  // Interrupt 19 active
+#define NVIC_ACTIVE0_INT18      0x00040000  // Interrupt 18 active
+#define NVIC_ACTIVE0_INT17      0x00020000  // Interrupt 17 active
+#define NVIC_ACTIVE0_INT16      0x00010000  // Interrupt 16 active
+#define NVIC_ACTIVE0_INT15      0x00008000  // Interrupt 15 active
+#define NVIC_ACTIVE0_INT14      0x00004000  // Interrupt 14 active
+#define NVIC_ACTIVE0_INT13      0x00002000  // Interrupt 13 active
+#define NVIC_ACTIVE0_INT12      0x00001000  // Interrupt 12 active
+#define NVIC_ACTIVE0_INT11      0x00000800  // Interrupt 11 active
+#define NVIC_ACTIVE0_INT10      0x00000400  // Interrupt 10 active
+#define NVIC_ACTIVE0_INT9       0x00000200  // Interrupt 9 active
+#define NVIC_ACTIVE0_INT8       0x00000100  // Interrupt 8 active
+#define NVIC_ACTIVE0_INT7       0x00000080  // Interrupt 7 active
+#define NVIC_ACTIVE0_INT6       0x00000040  // Interrupt 6 active
+#define NVIC_ACTIVE0_INT5       0x00000020  // Interrupt 5 active
+#define NVIC_ACTIVE0_INT4       0x00000010  // Interrupt 4 active
+#define NVIC_ACTIVE0_INT3       0x00000008  // Interrupt 3 active
+#define NVIC_ACTIVE0_INT2       0x00000004  // Interrupt 2 active
+#define NVIC_ACTIVE0_INT1       0x00000002  // Interrupt 1 active
+#define NVIC_ACTIVE0_INT0       0x00000001  // Interrupt 0 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_ACTIVE1 register.
+//
+//*****************************************************************************
+#define NVIC_ACTIVE1_INT59      0x08000000  // Interrupt 59 active
+#define NVIC_ACTIVE1_INT58      0x04000000  // Interrupt 58 active
+#define NVIC_ACTIVE1_INT57      0x02000000  // Interrupt 57 active
+#define NVIC_ACTIVE1_INT56      0x01000000  // Interrupt 56 active
+#define NVIC_ACTIVE1_INT55      0x00800000  // Interrupt 55 active
+#define NVIC_ACTIVE1_INT54      0x00400000  // Interrupt 54 active
+#define NVIC_ACTIVE1_INT53      0x00200000  // Interrupt 53 active
+#define NVIC_ACTIVE1_INT52      0x00100000  // Interrupt 52 active
+#define NVIC_ACTIVE1_INT51      0x00080000  // Interrupt 51 active
+#define NVIC_ACTIVE1_INT50      0x00040000  // Interrupt 50 active
+#define NVIC_ACTIVE1_INT49      0x00020000  // Interrupt 49 active
+#define NVIC_ACTIVE1_INT48      0x00010000  // Interrupt 48 active
+#define NVIC_ACTIVE1_INT47      0x00008000  // Interrupt 47 active
+#define NVIC_ACTIVE1_INT46      0x00004000  // Interrupt 46 active
+#define NVIC_ACTIVE1_INT45      0x00002000  // Interrupt 45 active
+#define NVIC_ACTIVE1_INT44      0x00001000  // Interrupt 44 active
+#define NVIC_ACTIVE1_INT43      0x00000800  // Interrupt 43 active
+#define NVIC_ACTIVE1_INT42      0x00000400  // Interrupt 42 active
+#define NVIC_ACTIVE1_INT41      0x00000200  // Interrupt 41 active
+#define NVIC_ACTIVE1_INT40      0x00000100  // Interrupt 40 active
+#define NVIC_ACTIVE1_INT39      0x00000080  // Interrupt 39 active
+#define NVIC_ACTIVE1_INT38      0x00000040  // Interrupt 38 active
+#define NVIC_ACTIVE1_INT37      0x00000020  // Interrupt 37 active
+#define NVIC_ACTIVE1_INT36      0x00000010  // Interrupt 36 active
+#define NVIC_ACTIVE1_INT35      0x00000008  // Interrupt 35 active
+#define NVIC_ACTIVE1_INT34      0x00000004  // Interrupt 34 active
+#define NVIC_ACTIVE1_INT33      0x00000002  // Interrupt 33 active
+#define NVIC_ACTIVE1_INT32      0x00000001  // Interrupt 32 active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI0 register.
+//
+//*****************************************************************************
+#define NVIC_PRI0_INT3_M        0xFF000000  // Interrupt 3 priority mask
+#define NVIC_PRI0_INT2_M        0x00FF0000  // Interrupt 2 priority mask
+#define NVIC_PRI0_INT1_M        0x0000FF00  // Interrupt 1 priority mask
+#define NVIC_PRI0_INT0_M        0x000000FF  // Interrupt 0 priority mask
+#define NVIC_PRI0_INT3_S        24
+#define NVIC_PRI0_INT2_S        16
+#define NVIC_PRI0_INT1_S        8
+#define NVIC_PRI0_INT0_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_PRI1_INT7_M        0xFF000000  // Interrupt 7 priority mask
+#define NVIC_PRI1_INT6_M        0x00FF0000  // Interrupt 6 priority mask
+#define NVIC_PRI1_INT5_M        0x0000FF00  // Interrupt 5 priority mask
+#define NVIC_PRI1_INT4_M        0x000000FF  // Interrupt 4 priority mask
+#define NVIC_PRI1_INT7_S        24
+#define NVIC_PRI1_INT6_S        16
+#define NVIC_PRI1_INT5_S        8
+#define NVIC_PRI1_INT4_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_PRI2_INT11_M       0xFF000000  // Interrupt 11 priority mask
+#define NVIC_PRI2_INT10_M       0x00FF0000  // Interrupt 10 priority mask
+#define NVIC_PRI2_INT9_M        0x0000FF00  // Interrupt 9 priority mask
+#define NVIC_PRI2_INT8_M        0x000000FF  // Interrupt 8 priority mask
+#define NVIC_PRI2_INT11_S       24
+#define NVIC_PRI2_INT10_S       16
+#define NVIC_PRI2_INT9_S        8
+#define NVIC_PRI2_INT8_S        0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_PRI3_INT15_M       0xFF000000  // Interrupt 15 priority mask
+#define NVIC_PRI3_INT14_M       0x00FF0000  // Interrupt 14 priority mask
+#define NVIC_PRI3_INT13_M       0x0000FF00  // Interrupt 13 priority mask
+#define NVIC_PRI3_INT12_M       0x000000FF  // Interrupt 12 priority mask
+#define NVIC_PRI3_INT15_S       24
+#define NVIC_PRI3_INT14_S       16
+#define NVIC_PRI3_INT13_S       8
+#define NVIC_PRI3_INT12_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI4 register.
+//
+//*****************************************************************************
+#define NVIC_PRI4_INT19_M       0xFF000000  // Interrupt 19 priority mask
+#define NVIC_PRI4_INT18_M       0x00FF0000  // Interrupt 18 priority mask
+#define NVIC_PRI4_INT17_M       0x0000FF00  // Interrupt 17 priority mask
+#define NVIC_PRI4_INT16_M       0x000000FF  // Interrupt 16 priority mask
+#define NVIC_PRI4_INT19_S       24
+#define NVIC_PRI4_INT18_S       16
+#define NVIC_PRI4_INT17_S       8
+#define NVIC_PRI4_INT16_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI5 register.
+//
+//*****************************************************************************
+#define NVIC_PRI5_INT23_M       0xFF000000  // Interrupt 23 priority mask
+#define NVIC_PRI5_INT22_M       0x00FF0000  // Interrupt 22 priority mask
+#define NVIC_PRI5_INT21_M       0x0000FF00  // Interrupt 21 priority mask
+#define NVIC_PRI5_INT20_M       0x000000FF  // Interrupt 20 priority mask
+#define NVIC_PRI5_INT23_S       24
+#define NVIC_PRI5_INT22_S       16
+#define NVIC_PRI5_INT21_S       8
+#define NVIC_PRI5_INT20_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI6 register.
+//
+//*****************************************************************************
+#define NVIC_PRI6_INT27_M       0xFF000000  // Interrupt 27 priority mask
+#define NVIC_PRI6_INT26_M       0x00FF0000  // Interrupt 26 priority mask
+#define NVIC_PRI6_INT25_M       0x0000FF00  // Interrupt 25 priority mask
+#define NVIC_PRI6_INT24_M       0x000000FF  // Interrupt 24 priority mask
+#define NVIC_PRI6_INT27_S       24
+#define NVIC_PRI6_INT26_S       16
+#define NVIC_PRI6_INT25_S       8
+#define NVIC_PRI6_INT24_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI7 register.
+//
+//*****************************************************************************
+#define NVIC_PRI7_INT31_M       0xFF000000  // Interrupt 31 priority mask
+#define NVIC_PRI7_INT30_M       0x00FF0000  // Interrupt 30 priority mask
+#define NVIC_PRI7_INT29_M       0x0000FF00  // Interrupt 29 priority mask
+#define NVIC_PRI7_INT28_M       0x000000FF  // Interrupt 28 priority mask
+#define NVIC_PRI7_INT31_S       24
+#define NVIC_PRI7_INT30_S       16
+#define NVIC_PRI7_INT29_S       8
+#define NVIC_PRI7_INT28_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI8 register.
+//
+//*****************************************************************************
+#define NVIC_PRI8_INT35_M       0xFF000000  // Interrupt 35 priority mask
+#define NVIC_PRI8_INT34_M       0x00FF0000  // Interrupt 34 priority mask
+#define NVIC_PRI8_INT33_M       0x0000FF00  // Interrupt 33 priority mask
+#define NVIC_PRI8_INT32_M       0x000000FF  // Interrupt 32 priority mask
+#define NVIC_PRI8_INT35_S       24
+#define NVIC_PRI8_INT34_S       16
+#define NVIC_PRI8_INT33_S       8
+#define NVIC_PRI8_INT32_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI9 register.
+//
+//*****************************************************************************
+#define NVIC_PRI9_INT39_M       0xFF000000  // Interrupt 39 priority mask
+#define NVIC_PRI9_INT38_M       0x00FF0000  // Interrupt 38 priority mask
+#define NVIC_PRI9_INT37_M       0x0000FF00  // Interrupt 37 priority mask
+#define NVIC_PRI9_INT36_M       0x000000FF  // Interrupt 36 priority mask
+#define NVIC_PRI9_INT39_S       24
+#define NVIC_PRI9_INT38_S       16
+#define NVIC_PRI9_INT37_S       8
+#define NVIC_PRI9_INT36_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_PRI10 register.
+//
+//*****************************************************************************
+#define NVIC_PRI10_INT43_M      0xFF000000  // Interrupt 43 priority mask
+#define NVIC_PRI10_INT42_M      0x00FF0000  // Interrupt 42 priority mask
+#define NVIC_PRI10_INT41_M      0x0000FF00  // Interrupt 41 priority mask
+#define NVIC_PRI10_INT40_M      0x000000FF  // Interrupt 40 priority mask
+#define NVIC_PRI10_INT43_S      24
+#define NVIC_PRI10_INT42_S      16
+#define NVIC_PRI10_INT41_S      8
+#define NVIC_PRI10_INT40_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CPUID register.
+//
+//*****************************************************************************
+#define NVIC_CPUID_IMP_M        0xFF000000  // Implementer
+#define NVIC_CPUID_VAR_M        0x00F00000  // Variant
+#define NVIC_CPUID_PARTNO_M     0x0000FFF0  // Processor part number
+#define NVIC_CPUID_REV_M        0x0000000F  // Revision
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_INT_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_INT_CTRL_NMI_SET   0x80000000  // Pend a NMI
+#define NVIC_INT_CTRL_PEND_SV   0x10000000  // Pend a PendSV
+#define NVIC_INT_CTRL_UNPEND_SV 0x08000000  // Unpend a PendSV
+#define NVIC_INT_CTRL_ISR_PRE   0x00800000  // Debug interrupt handling
+#define NVIC_INT_CTRL_ISR_PEND  0x00400000  // Debug interrupt pending
+#define NVIC_INT_CTRL_VEC_PEN_M 0x003FF000  // Highest pending exception
+#define NVIC_INT_CTRL_RET_BASE  0x00000800  // Return to base
+#define NVIC_INT_CTRL_VEC_ACT_M 0x000003FF  // Current active exception
+#define NVIC_INT_CTRL_VEC_PEN_S 12
+#define NVIC_INT_CTRL_VEC_ACT_S 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_VTABLE register.
+//
+//*****************************************************************************
+#define NVIC_VTABLE_BASE        0x20000000  // Vector table base
+#define NVIC_VTABLE_OFFSET_M    0x1FFFFF00  // Vector table offset
+#define NVIC_VTABLE_OFFSET_S    8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_APINT register.
+//
+//*****************************************************************************
+#define NVIC_APINT_VECTKEY_M    0xFFFF0000  // Vector key mask
+#define NVIC_APINT_VECTKEY      0x05FA0000  // Vector key
+#define NVIC_APINT_ENDIANESS    0x00008000  // Data endianess
+#define NVIC_APINT_PRIGROUP_M   0x00000700  // Priority group
+#define NVIC_APINT_PRIGROUP_0_8 0x00000700  // Priority group 0.8 split
+#define NVIC_APINT_PRIGROUP_1_7 0x00000600  // Priority group 1.7 split
+#define NVIC_APINT_PRIGROUP_2_6 0x00000500  // Priority group 2.6 split
+#define NVIC_APINT_PRIGROUP_3_5 0x00000400  // Priority group 3.5 split
+#define NVIC_APINT_PRIGROUP_4_4 0x00000300  // Priority group 4.4 split
+#define NVIC_APINT_PRIGROUP_5_3 0x00000200  // Priority group 5.3 split
+#define NVIC_APINT_PRIGROUP_6_2 0x00000100  // Priority group 6.2 split
+#define NVIC_APINT_SYSRESETREQ  0x00000004  // System reset request
+#define NVIC_APINT_VECT_CLR_ACT 0x00000002  // Clear active NMI/fault info
+#define NVIC_APINT_VECT_RESET   0x00000001  // System reset
+#define NVIC_APINT_PRIGROUP_7_1 0x00000000  // Priority group 7.1 split
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_SYS_CTRL_SEVONPEND 0x00000010  // Wakeup on pend
+#define NVIC_SYS_CTRL_SLEEPDEEP 0x00000004  // Deep sleep enable
+#define NVIC_SYS_CTRL_SLEEPEXIT 0x00000002  // Sleep on ISR exit
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_CFG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_CFG_CTRL_BFHFNMIGN 0x00000100  // Ignore bus fault in NMI/fault
+#define NVIC_CFG_CTRL_DIV0      0x00000010  // Trap on divide by 0
+#define NVIC_CFG_CTRL_UNALIGNED 0x00000008  // Trap on unaligned access
+#define NVIC_CFG_CTRL_DEEP_PEND 0x00000004  // Allow deep interrupt trigger
+#define NVIC_CFG_CTRL_MAIN_PEND 0x00000002  // Allow main interrupt trigger
+#define NVIC_CFG_CTRL_BASE_THR  0x00000001  // Thread state control
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI1 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI1_RES_M     0xFF000000  // Priority of reserved handler
+#define NVIC_SYS_PRI1_USAGE_M   0x00FF0000  // Priority of usage fault handler
+#define NVIC_SYS_PRI1_BUS_M     0x0000FF00  // Priority of bus fault handler
+#define NVIC_SYS_PRI1_MEM_M     0x000000FF  // Priority of mem manage handler
+#define NVIC_SYS_PRI1_USAGE_S   16
+#define NVIC_SYS_PRI1_BUS_S     8
+#define NVIC_SYS_PRI1_MEM_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI2 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI2_SVC_M     0xFF000000  // Priority of SVCall handler
+#define NVIC_SYS_PRI2_RES_M     0x00FFFFFF  // Priority of reserved handlers
+#define NVIC_SYS_PRI2_SVC_S     24
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_PRI3 register.
+//
+//*****************************************************************************
+#define NVIC_SYS_PRI3_TICK_M    0xFF000000  // Priority of Sys Tick handler
+#define NVIC_SYS_PRI3_PENDSV_M  0x00FF0000  // Priority of PendSV handler
+#define NVIC_SYS_PRI3_RES_M     0x0000FF00  // Priority of reserved handler
+#define NVIC_SYS_PRI3_DEBUG_M   0x000000FF  // Priority of debug handler
+#define NVIC_SYS_PRI3_TICK_S    24
+#define NVIC_SYS_PRI3_PENDSV_S  16
+#define NVIC_SYS_PRI3_DEBUG_S   0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SYS_HND_CTRL
+// register.
+//
+//*****************************************************************************
+#define NVIC_SYS_HND_CTRL_USAGE 0x00040000  // Usage fault enable
+#define NVIC_SYS_HND_CTRL_BUS   0x00020000  // Bus fault enable
+#define NVIC_SYS_HND_CTRL_MEM   0x00010000  // Mem manage fault enable
+#define NVIC_SYS_HND_CTRL_SVC   0x00008000  // SVCall is pended
+#define NVIC_SYS_HND_CTRL_BUSP  0x00004000  // Bus fault is pended
+#define NVIC_SYS_HND_CTRL_TICK  0x00000800  // Sys tick is active
+#define NVIC_SYS_HND_CTRL_PNDSV 0x00000400  // PendSV is active
+#define NVIC_SYS_HND_CTRL_MON   0x00000100  // Monitor is active
+#define NVIC_SYS_HND_CTRL_SVCA  0x00000080  // SVCall is active
+#define NVIC_SYS_HND_CTRL_USGA  0x00000008  // Usage fault is active
+#define NVIC_SYS_HND_CTRL_BUSA  0x00000002  // Bus fault is active
+#define NVIC_SYS_HND_CTRL_MEMA  0x00000001  // Mem manage is active
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_STAT_DIV0    0x02000000  // Divide by zero fault
+#define NVIC_FAULT_STAT_UNALIGN 0x01000000  // Unaligned access fault
+#define NVIC_FAULT_STAT_NOCP    0x00080000  // No coprocessor fault
+#define NVIC_FAULT_STAT_INVPC   0x00040000  // Invalid PC fault
+#define NVIC_FAULT_STAT_INVSTAT 0x00020000  // Invalid state fault
+#define NVIC_FAULT_STAT_UNDEF   0x00010000  // Undefined instruction fault
+#define NVIC_FAULT_STAT_BFARV   0x00008000  // BFAR is valid
+#define NVIC_FAULT_STAT_BSTKE   0x00001000  // Stack bus fault
+#define NVIC_FAULT_STAT_BUSTKE  0x00000800  // Unstack bus fault
+#define NVIC_FAULT_STAT_IMPRE   0x00000400  // Imprecise data bus error
+#define NVIC_FAULT_STAT_PRECISE 0x00000200  // Precise data bus error
+#define NVIC_FAULT_STAT_IBUS    0x00000100  // Instruction bus fault
+#define NVIC_FAULT_STAT_MMARV   0x00000080  // MMAR is valid
+#define NVIC_FAULT_STAT_MSTKE   0x00000010  // Stack access violation
+#define NVIC_FAULT_STAT_MUSTKE  0x00000008  // Unstack access violation
+#define NVIC_FAULT_STAT_DERR    0x00000002  // Data access violation
+#define NVIC_FAULT_STAT_IERR    0x00000001  // Instruction access violation
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_HFAULT_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_HFAULT_STAT_DBG    0x80000000  // Debug event
+#define NVIC_HFAULT_STAT_FORCED 0x40000000  // Cannot execute fault handler
+#define NVIC_HFAULT_STAT_VECT   0x00000002  // Vector table read fault
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DEBUG_STAT
+// register.
+//
+//*****************************************************************************
+#define NVIC_DEBUG_STAT_EXTRNL  0x00000010  // EDBGRQ asserted
+#define NVIC_DEBUG_STAT_VCATCH  0x00000008  // Vector catch
+#define NVIC_DEBUG_STAT_DWTTRAP 0x00000004  // DWT match
+#define NVIC_DEBUG_STAT_BKPT    0x00000002  // Breakpoint instruction
+#define NVIC_DEBUG_STAT_HALTED  0x00000001  // Halt request
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MM_ADDR register.
+//
+//*****************************************************************************
+#define NVIC_MM_ADDR_M          0xFFFFFFFF  // Data fault address
+#define NVIC_MM_ADDR_S          0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_FAULT_ADDR
+// register.
+//
+//*****************************************************************************
+#define NVIC_FAULT_ADDR_M       0xFFFFFFFF  // Data bus fault address
+#define NVIC_FAULT_ADDR_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_TYPE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_TYPE_IREGION_M 0x00FF0000  // Number of I regions
+#define NVIC_MPU_TYPE_DREGION_M 0x0000FF00  // Number of D regions
+#define NVIC_MPU_TYPE_SEPARATE  0x00000001  // Separate or unified MPU
+#define NVIC_MPU_TYPE_IREGION_S 16
+#define NVIC_MPU_TYPE_DREGION_S 8
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_MPU_CTRL_PRIVDEFEN 0x00000004  // MPU default region in priv mode
+#define NVIC_MPU_CTRL_HFNMIENA  0x00000002  // MPU enabled during faults
+#define NVIC_MPU_CTRL_ENABLE    0x00000001  // MPU enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_NUMBER
+// register.
+//
+//*****************************************************************************
+#define NVIC_MPU_NUMBER_M       0x000000FF  // MPU region to access
+#define NVIC_MPU_NUMBER_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_BASE register.
+//
+//*****************************************************************************
+#define NVIC_MPU_BASE_ADDR_M    0xFFFFFFE0  // Base address mask
+#define NVIC_MPU_BASE_VALID     0x00000010  // Region number valid
+#define NVIC_MPU_BASE_REGION_M  0x0000000F  // Region number
+#define NVIC_MPU_BASE_ADDR_S    8
+#define NVIC_MPU_BASE_REGION_S  0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_MPU_ATTR register.
+//
+//*****************************************************************************
+#define NVIC_MPU_ATTR_M         0xFFFF0000  // Attributes
+#define NVIC_MPU_ATTR_AP_NO_NO  0x00000000  // prv: no access, usr: no access
+#define NVIC_MPU_ATTR_BUFFRABLE 0x00010000  // Bufferable
+#define NVIC_MPU_ATTR_CACHEABLE 0x00020000  // Cacheable
+#define NVIC_MPU_ATTR_SHAREABLE 0x00040000  // Shareable
+#define NVIC_MPU_ATTR_TEX_M     0x00380000  // Type extension mask
+#define NVIC_MPU_ATTR_AP_RW_NO  0x01000000  // prv: rw, usr: none
+#define NVIC_MPU_ATTR_AP_RW_RO  0x02000000  // prv: rw, usr: read-only
+#define NVIC_MPU_ATTR_AP_RW_RW  0x03000000  // prv: rw, usr: rw
+#define NVIC_MPU_ATTR_AP_RO_NO  0x05000000  // prv: ro, usr: none
+#define NVIC_MPU_ATTR_AP_RO_RO  0x06000000  // prv: ro, usr: ro
+#define NVIC_MPU_ATTR_AP_M      0x07000000  // Access permissions mask
+#define NVIC_MPU_ATTR_XN        0x10000000  // Execute disable
+#define NVIC_MPU_ATTR_SRD_M     0x0000FF00  // Sub-region disable mask
+#define NVIC_MPU_ATTR_SRD_0     0x00000100  // Sub-region 0 disable
+#define NVIC_MPU_ATTR_SRD_1     0x00000200  // Sub-region 1 disable
+#define NVIC_MPU_ATTR_SRD_2     0x00000400  // Sub-region 2 disable
+#define NVIC_MPU_ATTR_SRD_3     0x00000800  // Sub-region 3 disable
+#define NVIC_MPU_ATTR_SRD_4     0x00001000  // Sub-region 4 disable
+#define NVIC_MPU_ATTR_SRD_5     0x00002000  // Sub-region 5 disable
+#define NVIC_MPU_ATTR_SRD_6     0x00004000  // Sub-region 6 disable
+#define NVIC_MPU_ATTR_SRD_7     0x00008000  // Sub-region 7 disable
+#define NVIC_MPU_ATTR_SIZE_M    0x0000003E  // Region size mask
+#define NVIC_MPU_ATTR_SIZE_32B  0x00000008  // Region size 32 bytes
+#define NVIC_MPU_ATTR_SIZE_64B  0x0000000A  // Region size 64 bytes
+#define NVIC_MPU_ATTR_SIZE_128B 0x0000000C  // Region size 128 bytes
+#define NVIC_MPU_ATTR_SIZE_256B 0x0000000E  // Region size 256 bytes
+#define NVIC_MPU_ATTR_SIZE_512B 0x00000010  // Region size 512 bytes
+#define NVIC_MPU_ATTR_SIZE_1K   0x00000012  // Region size 1 Kbytes
+#define NVIC_MPU_ATTR_SIZE_2K   0x00000014  // Region size 2 Kbytes
+#define NVIC_MPU_ATTR_SIZE_4K   0x00000016  // Region size 4 Kbytes
+#define NVIC_MPU_ATTR_SIZE_8K   0x00000018  // Region size 8 Kbytes
+#define NVIC_MPU_ATTR_SIZE_16K  0x0000001A  // Region size 16 Kbytes
+#define NVIC_MPU_ATTR_SIZE_32K  0x0000001C  // Region size 32 Kbytes
+#define NVIC_MPU_ATTR_SIZE_64K  0x0000001E  // Region size 64 Kbytes
+#define NVIC_MPU_ATTR_SIZE_128K 0x00000020  // Region size 128 Kbytes
+#define NVIC_MPU_ATTR_SIZE_256K 0x00000022  // Region size 256 Kbytes
+#define NVIC_MPU_ATTR_SIZE_512K 0x00000024  // Region size 512 Kbytes
+#define NVIC_MPU_ATTR_SIZE_1M   0x00000026  // Region size 1 Mbytes
+#define NVIC_MPU_ATTR_SIZE_2M   0x00000028  // Region size 2 Mbytes
+#define NVIC_MPU_ATTR_SIZE_4M   0x0000002A  // Region size 4 Mbytes
+#define NVIC_MPU_ATTR_SIZE_8M   0x0000002C  // Region size 8 Mbytes
+#define NVIC_MPU_ATTR_SIZE_16M  0x0000002E  // Region size 16 Mbytes
+#define NVIC_MPU_ATTR_SIZE_32M  0x00000030  // Region size 32 Mbytes
+#define NVIC_MPU_ATTR_SIZE_64M  0x00000032  // Region size 64 Mbytes
+#define NVIC_MPU_ATTR_SIZE_128M 0x00000034  // Region size 128 Mbytes
+#define NVIC_MPU_ATTR_SIZE_256M 0x00000036  // Region size 256 Mbytes
+#define NVIC_MPU_ATTR_SIZE_512M 0x00000038  // Region size 512 Mbytes
+#define NVIC_MPU_ATTR_SIZE_1G   0x0000003A  // Region size 1 Gbytes
+#define NVIC_MPU_ATTR_SIZE_2G   0x0000003C  // Region size 2 Gbytes
+#define NVIC_MPU_ATTR_SIZE_4G   0x0000003E  // Region size 4 Gbytes
+#define NVIC_MPU_ATTR_ENABLE    0x00000001  // Region enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_CTRL register.
+//
+//*****************************************************************************
+#define NVIC_DBG_CTRL_DBGKEY_M  0xFFFF0000  // Debug key mask
+#define NVIC_DBG_CTRL_DBGKEY    0xA05F0000  // Debug key
+#define NVIC_DBG_CTRL_S_RESET_ST \
+                                0x02000000  // Core has reset since last read
+#define NVIC_DBG_CTRL_S_RETIRE_ST \
+                                0x01000000  // Core has executed insruction
+                                            // since last read
+#define NVIC_DBG_CTRL_S_LOCKUP  0x00080000  // Core is locked up
+#define NVIC_DBG_CTRL_S_SLEEP   0x00040000  // Core is sleeping
+#define NVIC_DBG_CTRL_S_HALT    0x00020000  // Core status on halt
+#define NVIC_DBG_CTRL_S_REGRDY  0x00010000  // Register read/write available
+#define NVIC_DBG_CTRL_C_SNAPSTALL \
+                                0x00000020  // Breaks a stalled load/store
+#define NVIC_DBG_CTRL_C_MASKINT 0x00000008  // Mask interrupts when stepping
+#define NVIC_DBG_CTRL_C_STEP    0x00000004  // Step the core
+#define NVIC_DBG_CTRL_C_HALT    0x00000002  // Halt the core
+#define NVIC_DBG_CTRL_C_DEBUGEN 0x00000001  // Enable debug
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_XFER register.
+//
+//*****************************************************************************
+#define NVIC_DBG_XFER_REG_WNR   0x00010000  // Write or not read
+#define NVIC_DBG_XFER_REG_SEL_M 0x0000001F  // Register
+#define NVIC_DBG_XFER_REG_CFBP  0x00000014  // Control/Fault/BasePri/PriMask
+#define NVIC_DBG_XFER_REG_DSP   0x00000013  // Deep SP
+#define NVIC_DBG_XFER_REG_PSP   0x00000012  // Process SP
+#define NVIC_DBG_XFER_REG_MSP   0x00000011  // Main SP
+#define NVIC_DBG_XFER_REG_FLAGS 0x00000010  // xPSR/Flags register
+#define NVIC_DBG_XFER_REG_R15   0x0000000F  // Register R15
+#define NVIC_DBG_XFER_REG_R14   0x0000000E  // Register R14
+#define NVIC_DBG_XFER_REG_R13   0x0000000D  // Register R13
+#define NVIC_DBG_XFER_REG_R12   0x0000000C  // Register R12
+#define NVIC_DBG_XFER_REG_R11   0x0000000B  // Register R11
+#define NVIC_DBG_XFER_REG_R10   0x0000000A  // Register R10
+#define NVIC_DBG_XFER_REG_R9    0x00000009  // Register R9
+#define NVIC_DBG_XFER_REG_R8    0x00000008  // Register R8
+#define NVIC_DBG_XFER_REG_R7    0x00000007  // Register R7
+#define NVIC_DBG_XFER_REG_R6    0x00000006  // Register R6
+#define NVIC_DBG_XFER_REG_R5    0x00000005  // Register R5
+#define NVIC_DBG_XFER_REG_R4    0x00000004  // Register R4
+#define NVIC_DBG_XFER_REG_R3    0x00000003  // Register R3
+#define NVIC_DBG_XFER_REG_R2    0x00000002  // Register R2
+#define NVIC_DBG_XFER_REG_R1    0x00000001  // Register R1
+#define NVIC_DBG_XFER_REG_R0    0x00000000  // Register R0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_DATA register.
+//
+//*****************************************************************************
+#define NVIC_DBG_DATA_M         0xFFFFFFFF  // Data temporary cache
+#define NVIC_DBG_DATA_S         0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_DBG_INT register.
+//
+//*****************************************************************************
+#define NVIC_DBG_INT_HARDERR    0x00000400  // Debug trap on hard fault
+#define NVIC_DBG_INT_INTERR     0x00000200  // Debug trap on interrupt errors
+#define NVIC_DBG_INT_BUSERR     0x00000100  // Debug trap on bus error
+#define NVIC_DBG_INT_STATERR    0x00000080  // Debug trap on usage fault state
+#define NVIC_DBG_INT_CHKERR     0x00000040  // Debug trap on usage fault check
+#define NVIC_DBG_INT_NOCPERR    0x00000020  // Debug trap on coprocessor error
+#define NVIC_DBG_INT_MMERR      0x00000010  // Debug trap on mem manage fault
+#define NVIC_DBG_INT_RESET      0x00000008  // Core reset status
+#define NVIC_DBG_INT_RSTPENDCLR 0x00000004  // Clear pending core reset
+#define NVIC_DBG_INT_RSTPENDING 0x00000002  // Core reset is pending
+#define NVIC_DBG_INT_RSTVCATCH  0x00000001  // Reset vector catch
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the NVIC_SW_TRIG register.
+//
+//*****************************************************************************
+#define NVIC_SW_TRIG_INTID_M    0x000003FF  // Interrupt to trigger
+#define NVIC_SW_TRIG_INTID_S    0
+
+#endif // __LM3S9B92_H__


Property changes on: trunk/src/platform/lm3s/lm3s9b92.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/platform.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -43,6 +43,16 @@
 #include &quot;disp.h&quot;
 #include &quot;adc.h&quot;
 
+#ifdef FORLM3S9B92
+  #include &quot;lm3s9b92.h&quot;
+#elif FORLM3S8962
+  #include &quot;lm3s8962.h&quot;
+#elif FORLM3S6965
+  #include &quot;lm3s6965.h&quot;
+#elif FORLM3S6918
+  #include &quot;lm3s6918.h&quot;
+#endif
+
 // UIP sys tick data
 // NOTE: when using virtual timers, SYSTICKHZ and VTMR_FREQ_HZ should have the
 // same value, as they're served by the same timer (the systick)
@@ -107,12 +117,28 @@
 // ****************************************************************************
 // PIO
 // Same configuration on LM3S8962, LM3S6965, LM3S6918 (8 ports)
+// 9B92 has 9 ports (Port J in addition to A-H)
+#ifdef FORLM3S9B92
+  static const u32 pio_base[] = { GPIO_PORTA_BASE, GPIO_PORTB_BASE, GPIO_PORTC_BASE, GPIO_PORTD_BASE,
+                                  GPIO_PORTE_BASE, GPIO_PORTF_BASE, GPIO_PORTG_BASE, GPIO_PORTH_BASE, 
+                                  GPIO_PORTJ_BASE };
+                                  
+  static const u32 pio_sysctl[] = { SYSCTL_PERIPH_GPIOA, SYSCTL_PERIPH_GPIOB, SYSCTL_PERIPH_GPIOC, SYSCTL_PERIPH_GPIOD,
+                                    SYSCTL_PERIPH_GPIOE, SYSCTL_PERIPH_GPIOF, SYSCTL_PERIPH_GPIOG, SYSCTL_PERIPH_GPIOH,
+                                    SYSCTL_PERIPH_GPIOJ };
+#else
+  static const u32 pio_base[] = { GPIO_PORTA_BASE, GPIO_PORTB_BASE, GPIO_PORTC_BASE, GPIO_PORTD_BASE,
+                                  GPIO_PORTE_BASE, GPIO_PORTF_BASE, GPIO_PORTG_BASE, GPIO_PORTH_BASE };
+  
+  static const u32 pio_sysctl[] = { SYSCTL_PERIPH_GPIOA, SYSCTL_PERIPH_GPIOB, SYSCTL_PERIPH_GPIOC, SYSCTL_PERIPH_GPIOD,
+                                    SYSCTL_PERIPH_GPIOE, SYSCTL_PERIPH_GPIOF, SYSCTL_PERIPH_GPIOG, SYSCTL_PERIPH_GPIOH };
+#endif
 
-static const u32 pio_base[] = { GPIO_PORTA_BASE, GPIO_PORTB_BASE, GPIO_PORTC_BASE, GPIO_PORTD_BASE,
-                                GPIO_PORTE_BASE, GPIO_PORTF_BASE, GPIO_PORTG_BASE, GPIO_PORTH_BASE };
-static const u32 pio_sysctl[] = { SYSCTL_PERIPH_GPIOA, SYSCTL_PERIPH_GPIOB, SYSCTL_PERIPH_GPIOC, SYSCTL_PERIPH_GPIOD,
-                                  SYSCTL_PERIPH_GPIOE, SYSCTL_PERIPH_GPIOF, SYSCTL_PERIPH_GPIOG, SYSCTL_PERIPH_GPIOH };
 
+
+
+
+
 static void pios_init()
 {
   unsigned i;
@@ -177,7 +203,7 @@
 
 // ****************************************************************************
 // SPI
-// Same configuration on LM3S8962, LM3S6965 and LM3S6918 (2 SPI ports)
+// Same configuration on LM3S8962, LM3S6965, LM3S6918 and LM3S9B92 (2 SPI ports)
 
 // All possible LM3S SPIs defs
 // FIXME this anticipates support for a platform with 2 SPI port
@@ -235,7 +261,7 @@
 
 // ****************************************************************************
 // UART
-// Different configurations for LM3S8962, LM3S6918 (2 UARTs) and LM3S6965 (3 UARTs)
+// Different configurations for LM3S8962, LM3S6918 (2 UARTs) and LM3S6965, LM3S9B92 (3 UARTs)
 
 // All possible LM3S uarts defs
 static const u32 uart_base[] = { UART0_BASE, UART1_BASE, UART2_BASE };
@@ -334,7 +360,7 @@
 
 // ****************************************************************************
 // Timers
-// Same on LM3S8962, LM3S6965 and LM3S6918 (4 timers)
+// Same on LM3S8962, LM3S6965, LM3S6918 and LM3S9B92 (4 timers)
 
 // All possible LM3S timers defs
 static const u32 timer_base[] = { TIMER0_BASE, TIMER1_BASE, TIMER2_BASE, TIMER3_BASE };
@@ -408,12 +434,21 @@
 // Port/pin information for all channels
 #ifdef FORLM3S6965
   const static u32 pwm_ports[] =  { GPIO_PORTF_BASE, GPIO_PORTD_BASE, GPIO_PORTB_BASE, GPIO_PORTB_BASE, GPIO_PORTE_BASE, GPIO_PORTE_BASE };
+#elif FORLM3S9B92
+  const static u32 pwm_ports[] =  { GPIO_PORTD_BASE, GPIO_PORTD_BASE, GPIO_PORTB_BASE, GPIO_PORTB_BASE, GPIO_PORTE_BASE, GPIO_PORTE_BASE };
+  // GPIOPCTL probably needs modification to do PWM for 2&amp;3, Digital Function 2
 #else
   const static u32 pwm_ports[] =  { GPIO_PORTF_BASE, GPIO_PORTG_BASE, GPIO_PORTB_BASE, GPIO_PORTB_BASE, GPIO_PORTE_BASE, GPIO_PORTE_BASE };
 #endif
 const static u8 pwm_pins[] = { GPIO_PIN_0, GPIO_PIN_1, GPIO_PIN_0, GPIO_PIN_1, GPIO_PIN_0, GPIO_PIN_1 };
+
 // PWM generators
-const static u16 pwm_gens[] = { PWM_GEN_0, PWM_GEN_1, PWM_GEN_2 };
+#ifdef FORLM3S9B92
+  const static u16 pwm_gens[] = { PWM_GEN_0, PWM_GEN_1, PWM_GEN_2, PWM_GEN_3 };
+#else
+  const static u16 pwm_gens[] = { PWM_GEN_0, PWM_GEN_1, PWM_GEN_2 };
+#endif
+
 // PWM outputs
 const static u16 pwm_outs[] = { PWM_OUT_0, PWM_OUT_1, PWM_OUT_2, PWM_OUT_3, PWM_OUT_4, PWM_OUT_5 };
 

Modified: trunk/src/platform/lm3s/platform_conf.h
===================================================================
--- trunk/src/platform/lm3s/platform_conf.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/platform_conf.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -105,7 +105,11 @@
 #define VTMR_FREQ_HZ          4
 
 // Number of resources (0 if not available/not implemented)
-#define NUM_PIO               7
+#ifdef FORLM3S9B92
+  #define NUM_PIO             8
+#else
+  #define NUM_PIO             7
+#endif
 #define NUM_SPI               1
 #ifdef FORLM3S6965
   #define NUM_UART            3

Modified: trunk/src/platform/lm3s/pwm.c
===================================================================
--- trunk/src/platform/lm3s/pwm.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/pwm.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,1697 +1,1728 @@
-//*****************************************************************************
-//
-// pwm.c - API for the PWM modules
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup pwm_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_pwm.h&quot;
-#include &quot;hw_sysctl.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-#include &quot;pwm.h&quot;
-
-//*****************************************************************************
-//
-// Misc macros for manipulating the encoded generator and output defines used
-// by the API.
-//
-//*****************************************************************************
-#define PWM_GEN_BADDR(_mod_, _gen_)                                           \
-                                ((_mod_) + (_gen_))
-#define PWM_GEN_EXT_BADDR(_mod_, _gen_)                                       \
-                                ((_mod_) + PWM_GEN_EXT_0 +                    \
-                                 ((_gen_) - PWM_GEN_0) * 2)
-#define PWM_OUT_BADDR(_mod_, _out_)                                           \
-                                ((_mod_) + ((_out_) &amp; 0xFFFFFFC0))
-#define PWM_IS_OUTPUT_ODD(_out_)                                              \
-                                ((_out_) &amp; 0x00000001)
-
-//*****************************************************************************
-//
-//! \internal
-//! Checks a PWM generator number.
-//!
-//! \param ulGen is the generator number.
-//!
-//! This function determines if a PWM generator number is valid.
-//!
-//! \return Returnes \b true if the generator number is valid and \b false
-//! otherwise.
-//
-//*****************************************************************************
-#ifdef DEBUG
-static tBoolean
-PWMGenValid(unsigned long ulGen)
-{
-    return((ulGen == PWM_GEN_0) || (ulGen == PWM_GEN_1) ||
-           (ulGen == PWM_GEN_2) || (ulGen == PWM_GEN_3));
-}
-#endif
-
-//*****************************************************************************
-//
-//! \internal
-//! Checks a PWM output number.
-//!
-//! \param ulPWMOut is the output number.
-//!
-//! This function determines if a PWM output number is valid.
-//!
-//! \return Returns \b true if the output number is valid and \b false
-//! otherwise.
-//
-//*****************************************************************************
-#ifdef DEBUG
-static tBoolean
-PWMOutValid(unsigned long ulPWMOut)
-{
-    return((ulPWMOut == PWM_OUT_0) || (ulPWMOut == PWM_OUT_1) ||
-           (ulPWMOut == PWM_OUT_2) || (ulPWMOut == PWM_OUT_3) ||
-           (ulPWMOut == PWM_OUT_4) || (ulPWMOut == PWM_OUT_5) ||
-           (ulPWMOut == PWM_OUT_6) || (ulPWMOut == PWM_OUT_7));
-}
-#endif
-
-//*****************************************************************************
-//
-//! Configures a PWM generator.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to configure.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulConfig is the configuration for the PWM generator.
-//!
-//! This function is used to set the mode of operation for a PWM generator.
-//! The counting mode, synchronization mode, and debug behavior are all
-//! configured.  After configuration, the generator is left in the disabled
-//! state.
-//!
-//! A PWM generator can count in two different modes:  count down mode or count
-//! up/down mode.  In count down mode, it will count from a value down to zero,
-//! and then reset to the preset value.  This will produce left-aligned PWM
-//! signals (that is the rising edge of the two PWM signals produced by the
-//! generator will occur at the same time).  In count up/down mode, it will
-//! count up from zero to the preset value, count back down to zero, and then
-//! repeat the process.  This will produce center-aligned PWM signals (that is,
-//! the middle of the high/low period of the PWM signals produced by the
-//! generator will occur at the same time).
-//!
-//! When the PWM generator parameters (period and pulse width) are modified,
-//! their affect on the output PWM signals can be delayed.  In synchronous
-//! mode, the parameter updates are not applied until a synchronization event
-//! occurs.  This allows multiple parameters to be modified and take affect
-//! simultaneously, instead of one at a time.  Additionally, parameters to
-//! multiple PWM generators in synchronous mode can be updated simultaneously,
-//! allowing them to be treated as if they were a unified generator.  In
-//! non-synchronous mode, the parameter updates are not delayed until a
-//! synchronization event.  In either mode, the parameter updates only occur
-//! when the counter is at zero to help prevent oddly formed PWM signals during
-//! the update (that is, a PWM pulse that is too short or too long).
-//!
-//! The PWM generator can either pause or continue running when the processor
-//! is stopped via the debugger.  If configured to pause, it will continue to
-//! count until it reaches zero, at which point it will pause until the
-//! processor is restarted.  If configured to continue running, it will keep
-//! counting as if nothing had happened.
-//!
-//! The \e ulConfig parameter contains the desired configuration.  It is the
-//! logical OR of the following:
-//!
-//! - \b PWM_GEN_MODE_DOWN or \b PWM_GEN_MODE_UP_DOWN to specify the counting
-//!   mode
-//! - \b PWM_GEN_MODE_SYNC or \b PWM_GEN_MODE_NO_SYNC to specify the counter
-//!   load and comparator update synchronization mode
-//! - \b PWM_GEN_MODE_DBG_RUN or \b PWM_GEN_MODE_DBG_STOP to specify the debug
-//!   behavior
-//! - \b PWM_GEN_MODE_GEN_NO_SYNC, \b PWM_GEN_MODE_GEN_SYNC_LOCAL, or
-//!   \b PWM_GEN_MODE_GEN_SYNC_GLOBAL to specify the update synchronization
-//!   mode for generator counting mode changes
-//! - \b PWM_GEN_MODE_DB_NO_SYNC, \b PWM_GEN_MODE_DB_SYNC_LOCAL, or
-//!   \b PWM_GEN_MODE_DB_SYNC_GLOBAL to specify the deadband parameter
-//!   synchronization mode
-//! - \b PWM_GEN_MODE_FAULT_LATCHED or \b PWM_GEN_MODE_FAULT_UNLATCHED to
-//!   specify whether fault conditions are latched or not
-//! - \b PWM_GEN_MODE_FAULT_MINPER or \b PWM_GEN_MODE_FAULT_NO_MINPER to
-//!   specify whether minimum fault period support is required
-//! - \b PWM_GEN_MODE_FAULT_EXT or \b PWM_GEN_MODE_FAULT_LEGACY to specify
-//!   whether extended fault source selection support is enabled or not
-//!
-//! Setting \b PWM_GEN_MODE_FAULT_MINPER allows an application to set the
-//! minimum duration of a PWM fault signal.  Fault will be signaled for at
-//! least this time even if the external fault pin deasserts earlier.  Care
-//! should be taken when using this mode since during the fault signal period,
-//! the fault interrupt from the PWM generator will remain asserted.  The fault
-//! interrupt handler may, therefore, reenter immediately if it exits prior to
-//! expiration of the fault timer.
-//!
-//! \note Changes to the counter mode will affect the period of the PWM signals
-//! produced.  PWMGenPeriodSet() and PWMPulseWidthSet() should be called after
-//! any changes to the counter mode of a generator.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenConfigure(unsigned long ulBase, unsigned long ulGen,
-                unsigned long ulConfig)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Compute the generator's base address.
-    //
-    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
-
-    //
-    // Change the global configuration of the generator.
-    //
-    HWREG(ulGen + PWM_O_X_CTL) = ((HWREG(ulGen + PWM_O_X_CTL) &amp;
-                                   ~(PWM_X_CTL_MODE | PWM_X_CTL_DEBUG |
-                                     PWM_X_CTL_LATCH | PWM_X_CTL_MINFLTPER |
-                                     PWM_X_CTL_FLTSRC | PWM_X_CTL_DBFALLUPD_M |
-                                     PWM_X_CTL_DBRISEUPD_M |
-                                     PWM_X_CTL_DBCTLUPD_M |
-                                     PWM_X_CTL_GENBUPD_M |
-                                     PWM_X_CTL_GENAUPD_M |
-                                     PWM_X_CTL_LOADUPD | PWM_X_CTL_CMPAUPD |
-                                     PWM_X_CTL_CMPBUPD)) | ulConfig);
-
-    //
-    // Set the individual PWM generator controls.
-    //
-    if(ulConfig &amp; PWM_X_CTL_MODE)
-    {
-        //
-        // In up/down count mode, set the signal high on up count comparison
-        // and low on down count comparison (that is, center align the
-        // signals).
-        //
-        HWREG(ulGen + PWM_O_X_GENA) = (PWM_X_GENA_ACTCMPAU_ONE |
-                                       PWM_X_GENA_ACTCMPAD_ZERO);
-        HWREG(ulGen + PWM_O_X_GENB) = (PWM_X_GENB_ACTCMPBU_ONE |
-                                       PWM_X_GENB_ACTCMPBD_ZERO);
-    }
-    else
-    {
-        //
-        // In down count mode, set the signal high on load and low on count
-        // comparison (that is, left align the signals).
-        //
-        HWREG(ulGen + PWM_O_X_GENA) = (PWM_X_GENA_ACTLOAD_ONE |
-                                       PWM_X_GENA_ACTCMPAD_ZERO);
-        HWREG(ulGen + PWM_O_X_GENB) = (PWM_X_GENB_ACTLOAD_ONE |
-                                       PWM_X_GENB_ACTCMPBD_ZERO);
-    }
-}
-
-//*****************************************************************************
-//
-//! Set the period of a PWM generator.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to be modified.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulPeriod specifies the period of PWM generator output, measured
-//! in clock ticks.
-//!
-//! This function sets the period of the specified PWM generator block, where
-//! the period of the generator block is defined as the number of PWM clock
-//! ticks between pulses on the generator block zero signal.
-//!
-//! \note Any subsequent calls made to this function before an update occurs
-//! will cause the previous values to be overwritten.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenPeriodSet(unsigned long ulBase, unsigned long ulGen,
-                unsigned long ulPeriod)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Compute the generator's base address.
-    //
-    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
-
-    //
-    // Set the reload register based on the mode.
-    //
-    if(HWREG(ulGen + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
-    {
-        //
-        // In up/down count mode, set the reload register to half the requested
-        // period.
-        //
-        ASSERT((ulPeriod / 2) &lt; 65536);
-        HWREG(ulGen + PWM_O_X_LOAD) = ulPeriod / 2;
-    }
-    else
-    {
-        //
-        // In down count mode, set the reload register to the requested period
-        // minus one.
-        //
-        ASSERT((ulPeriod &lt;= 65536) &amp;&amp; (ulPeriod != 0));
-        HWREG(ulGen + PWM_O_X_LOAD) = ulPeriod - 1;
-    }
-}
-
-//*****************************************************************************
-//
-//! Gets the period of a PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to query.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//!
-//! This function gets the period of the specified PWM generator block.  The
-//! period of the generator block is defined as the number of PWM clock ticks
-//! between pulses on the generator block zero signal.
-//!
-//! If the update of the counter for the specified PWM generator has yet
-//! to be completed, the value returned may not be the active period.  The
-//! value returned is the programmed period, measured in PWM clock ticks.
-//!
-//! \return Returns the programmed period of the specified generator block
-//! in PWM clock ticks.
-//
-//*****************************************************************************
-unsigned long
-PWMGenPeriodGet(unsigned long ulBase, unsigned long ulGen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Compute the generator's base address.
-    //
-    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
-
-    //
-    // Figure out the counter mode.
-    //
-    if(HWREG(ulGen + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
-    {
-        //
-        // The period is twice the reload register value.
-        //
-        return(HWREG(ulGen + PWM_O_X_LOAD) * 2);
-    }
-    else
-    {
-        //
-        // The period is the reload register value plus one.
-        //
-        return(HWREG(ulGen + PWM_O_X_LOAD) + 1);
-    }
-}
-
-//*****************************************************************************
-//
-//! Enables the timer/counter for a PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to be enabled.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//!
-//! This function allows the PWM clock to drive the timer/counter for the
-//! specified generator block.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenEnable(unsigned long ulBase, unsigned long ulGen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Enable the PWM generator.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_CTL) |= PWM_X_CTL_ENABLE;
-}
-
-//*****************************************************************************
-//
-//! Disables the timer/counter for a PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to be disabled.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//!
-//! This function blocks the PWM clock from driving the timer/counter for the
-//! specified generator block.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenDisable(unsigned long ulBase, unsigned long ulGen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Disable the PWM generator.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, + ulGen) + PWM_O_X_CTL) &amp;= ~(PWM_X_CTL_ENABLE);
-}
-
-//*****************************************************************************
-//
-//! Sets the pulse width for the specified PWM output.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulPWMOut is the PWM output to modify.  Must be one of \b PWM_OUT_0,
-//! \b PWM_OUT_1, \b PWM_OUT_2, \b PWM_OUT_3, \b PWM_OUT_4, \b PWM_OUT_5,
-//! \b PWM_OUT_6, or \b PWM_OUT_7.
-//! \param ulWidth specifies the width of the positive portion of the pulse.
-//!
-//! This function sets the pulse width for the specified PWM output, where the
-//! pulse width is defined as the number of PWM clock ticks.
-//!
-//! \note Any subsequent calls made to this function before an update occurs
-//! will cause the previous values to be overwritten.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMPulseWidthSet(unsigned long ulBase, unsigned long ulPWMOut,
-                 unsigned long ulWidth)
-{
-    unsigned long ulGenBase, ulReg;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMOutValid(ulPWMOut));
-
-    //
-    // Compute the generator's base address.
-    //
-    ulGenBase = PWM_OUT_BADDR(ulBase, ulPWMOut);
-
-    //
-    // If the counter is in up/down count mode, divide the width by two.
-    //
-    if(HWREG(ulGenBase + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
-    {
-        ulWidth /= 2;
-    }
-
-    //
-    // Get the period.
-    //
-    ulReg = HWREG(ulGenBase + PWM_O_X_LOAD);
-
-    //
-    // Make sure the width is not too large.
-    //
-    ASSERT(ulWidth &lt; ulReg);
-
-    //
-    // Compute the compare value.
-    //
-    ulReg = ulReg - ulWidth;
-
-    //
-    // Write to the appropriate registers.
-    //
-    if(PWM_IS_OUTPUT_ODD(ulPWMOut))
-    {
-        HWREG(ulGenBase + PWM_O_X_CMPB) = ulReg;
-    }
-    else
-    {
-        HWREG(ulGenBase + PWM_O_X_CMPA) = ulReg;
-    }
-}
-
-//*****************************************************************************
-//
-//! Gets the pulse width of a PWM output.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulPWMOut is the PWM output to query.  Must be one of \b PWM_OUT_0,
-//! \b PWM_OUT_1, \b PWM_OUT_2, \b PWM_OUT_3, \b PWM_OUT_4, \b PWM_OUT_5,
-//! \b PWM_OUT_6, or \b PWM_OUT_7.
-//!
-//! This function gets the currently programmed pulse width for the specified
-//! PWM output.  If the update of the comparator for the specified output has
-//! yet to be completed, the value returned may not be the active pulse width.
-//! The value returned is the programmed pulse width, measured in PWM clock
-//! ticks.
-//!
-//! \return Returns the width of the pulse in PWM clock ticks.
-//
-//*****************************************************************************
-unsigned long
-PWMPulseWidthGet(unsigned long ulBase, unsigned long ulPWMOut)
-{
-    unsigned long ulGenBase, ulReg, ulLoad;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMOutValid(ulPWMOut));
-
-    //
-    // Compute the generator's base address.
-    //
-    ulGenBase = PWM_OUT_BADDR(ulBase, ulPWMOut);
-
-    //
-    // Then compute the pulse width.  If mode is UpDown, set
-    // width = (load - compare) * 2.  Otherwise, set width = load - compare.
-    //
-    ulLoad = HWREG(ulGenBase + PWM_O_X_LOAD);
-    if(PWM_IS_OUTPUT_ODD(ulPWMOut))
-    {
-        ulReg = HWREG(ulGenBase + PWM_O_X_CMPB);
-    }
-    else
-    {
-        ulReg = HWREG(ulGenBase + PWM_O_X_CMPA);
-    }
-    ulReg = ulLoad - ulReg;
-
-    //
-    // If in up/down count mode, double the pulse width.
-    //
-    if(HWREG(ulGenBase + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
-    {
-        ulReg = ulReg * 2;
-    }
-
-    //
-    // Return the pulse width.
-    //
-    return(ulReg);
-}
-
-//*****************************************************************************
-//
-//! Enables the PWM dead band output, and sets the dead band delays.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to modify.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param usRise specifies the width of delay from the rising edge.
-//! \param usFall specifies the width of delay from the falling edge.
-//!
-//! This function sets the dead bands for the specified PWM generator,
-//! where the dead bands are defined as the number of \b PWM clock ticks
-//! from the rising or falling edge of the generator's \b OutA signal.
-//! Note that this function causes the coupling of \b OutB to \b OutA.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMDeadBandEnable(unsigned long ulBase, unsigned long ulGen,
-                  unsigned short usRise, unsigned short usFall)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT(usRise &lt; 4096);
-    ASSERT(usFall &lt; 4096);
-
-    //
-    // Compute the generator's base address.
-    //
-    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
-
-    //
-    // Write the dead band delay values.
-    //
-    HWREG(ulGen + PWM_O_X_DBRISE) = usRise;
-    HWREG(ulGen + PWM_O_X_DBFALL) = usFall;
-
-    //
-    // Enable the deadband functionality.
-    //
-    HWREG(ulGen + PWM_O_X_DBCTL) |= PWM_X_DBCTL_ENABLE;
-}
-
-//*****************************************************************************
-//
-//! Disables the PWM dead band output.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to modify.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//!
-//! This function disables the dead band mode for the specified PWM generator.
-//! Doing so decouples the \b OutA and \b OutB signals.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMDeadBandDisable(unsigned long ulBase, unsigned long ulGen)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Disable the deadband functionality.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_DBCTL) &amp;=
-        ~(PWM_X_DBCTL_ENABLE);
-}
-
-//*****************************************************************************
-//
-//! Synchronizes all pending updates.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGenBits are the PWM generator blocks to be updated.  Must be the
-//! logical OR of any of \b PWM_GEN_0_BIT, \b PWM_GEN_1_BIT,
-//! \b PWM_GEN_2_BIT, or \b PWM_GEN_3_BIT.
-//!
-//! For the selected PWM generators, this function causes all queued updates to
-//! the period or pulse width to be applied the next time the corresponding
-//! counter becomes zero.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMSyncUpdate(unsigned long ulBase, unsigned long ulGenBits)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(!(ulGenBits &amp; ~(PWM_GEN_0_BIT | PWM_GEN_1_BIT | PWM_GEN_2_BIT |
-                           PWM_GEN_3_BIT)));
-
-    //
-    // Synchronize pending PWM register changes.
-    //
-    HWREG(ulBase + PWM_O_CTL) = ulGenBits;
-}
-
-//*****************************************************************************
-//
-//! Synchronizes the counters in one or multiple PWM generator blocks.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGenBits are the PWM generator blocks to be synchronized.  Must be
-//! the logical OR of any of \b PWM_GEN_0_BIT, \b PWM_GEN_1_BIT,
-//! \b PWM_GEN_2_BIT, or \b PWM_GEN_3_BIT.
-//!
-//! For the selected PWM module, this function synchronizes the time base
-//! of the generator blocks by causing the specified generator counters to be
-//! reset to zero.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMSyncTimeBase(unsigned long ulBase, unsigned long ulGenBits)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(!(ulGenBits &amp; ~(PWM_GEN_0_BIT | PWM_GEN_1_BIT | PWM_GEN_2_BIT |
-                           PWM_GEN_3_BIT)));
-
-    //
-    // Synchronize the counters in the specified generators by writing to the
-    // module's synchronization register.
-    //
-    HWREG(ulBase + PWM_O_SYNC) = ulGenBits;
-}
-
-//*****************************************************************************
-//
-//! Enables or disables PWM outputs.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
-//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
-//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT,
-//! or \b PWM_OUT_7_BIT.
-//! \param bEnable determines if the signal is enabled or disabled.
-//!
-//! This function is used to enable or disable the selected PWM outputs.  The
-//! outputs are selected using the parameter \e ulPWMOutBits.  The parameter
-//! \e bEnable determines the state of the selected outputs.  If \e bEnable is
-//! \b true, then the selected PWM outputs are enabled, or placed in the active
-//! state.  If \e bEnable is \b false, then the selected outputs are disabled,
-//! or placed in the inactive state.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMOutputState(unsigned long ulBase, unsigned long ulPWMOutBits,
-               tBoolean bEnable)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
-                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
-                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
-
-    //
-    // Read the module's ENABLE output control register, and set or clear the
-    // requested bits.
-    //
-    if(bEnable == true)
-    {
-        HWREG(ulBase + PWM_O_ENABLE) |= ulPWMOutBits;
-    }
-    else
-    {
-        HWREG(ulBase + PWM_O_ENABLE) &amp;= ~(ulPWMOutBits);
-    }
-}
-
-//*****************************************************************************
-//
-//! Selects the inversion mode for PWM outputs.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
-//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
-//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT, or
-//! \b PWM_OUT_7_BIT.
-//! \param bInvert determines if the signal is inverted or passed through.
-//!
-//! This function is used to select the inversion mode for the selected PWM
-//! outputs.  The outputs are selected using the parameter \e ulPWMOutBits.
-//! The parameter \e bInvert determines the inversion mode for the selected
-//! outputs.  If \e bInvert is \b true, this function will cause the specified
-//! PWM output signals to be inverted, or made active low.  If \e bInvert is
-//! \b false, the specified output will be passed through as is, or be made
-//! active high.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMOutputInvert(unsigned long ulBase, unsigned long ulPWMOutBits,
-                tBoolean bInvert)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
-                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
-                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
-
-    //
-    // Read the module's INVERT output control register, and set or clear the
-    // requested bits.
-    //
-    if(bInvert == true)
-    {
-        HWREG(ulBase + PWM_O_INVERT) |= ulPWMOutBits;
-    }
-    else
-    {
-        HWREG(ulBase + PWM_O_INVERT) &amp;= ~(ulPWMOutBits);
-    }
-}
-
-//*****************************************************************************
-//
-//! Specifies the level of PWM outputs suppressed in response to a fault
-//! condition.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
-//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
-//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT, or
-//! \b PWM_OUT_7_BIT.
-//! \param bDriveHigh determines if the signal is driven high or low during an
-//! active fault condition.
-//!
-//! This function determines whether a PWM output pin that is suppressed in
-//! response to a fault condition will be driven high or low.  The affected
-//! outputs are selected using the parameter \e ulPWMOutBits.  The parameter
-//! \e bDriveHigh determines the output level for the pins identified by
-//! \e ulPWMOutBits.  If \e bDriveHigh is \b true then the selected outputs
-//! will be driven high when a fault is detected.  If it is \e false, the pins
-//! will be driven low.
-//!
-//! In a fault condition, pins which have not been configured to be suppressed
-//! via a call to PWMOutputFault() are unaffected by this function.
-//!
-//! \note This function is available only on devices which support extended
-//! PWM fault handling.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMOutputFaultLevel(unsigned long ulBase, unsigned long ulPWMOutBits,
-                    tBoolean bDriveHigh)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
-                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
-                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
-
-    //
-    // Read the module's FAULT output control register, and set or clear the
-    // requested bits.
-    //
-    if(bDriveHigh == true)
-    {
-        HWREG(ulBase + PWM_O_FAULTVAL) |= ulPWMOutBits;
-    }
-    else
-    {
-        HWREG(ulBase + PWM_O_FAULTVAL) &amp;= ~(ulPWMOutBits);
-    }
-}
-
-//*****************************************************************************
-//
-//! Specifies the state of PWM outputs in response to a fault condition.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
-//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
-//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT, or
-//! \b PWM_OUT_7_BIT.
-//! \param bFaultSuppress determines if the signal is suppressed or passed
-//! through during an active fault condition.
-//!
-//! This function sets the fault handling characteristics of the selected PWM
-//! outputs.  The outputs are selected using the parameter \e ulPWMOutBits.
-//! The parameter \e bFaultSuppress determines the fault handling
-//! characteristics for the selected outputs.  If \e bFaultSuppress is \b true,
-//! then the selected outputs will be made inactive.  If \e bFaultSuppress is
-//! \b false, then the selected outputs are unaffected by the detected fault.
-//!
-//! On devices supporting extended PWM fault handling, the state the affected
-//! output pins are driven to can be configured with PWMOutputFaultLevel().  If
-//! not configured, or if the device does not support extended PWM fault
-//! handling, affected outputs will be driven low on a fault condition.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMOutputFault(unsigned long ulBase, unsigned long ulPWMOutBits,
-               tBoolean bFaultSuppress)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
-                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
-                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
-
-    //
-    // Read the module's FAULT output control register, and set or clear the
-    // requested bits.
-    //
-    if(bFaultSuppress == true)
-    {
-        HWREG(ulBase + PWM_O_FAULT) |= ulPWMOutBits;
-    }
-    else
-    {
-        HWREG(ulBase + PWM_O_FAULT) &amp;= ~(ulPWMOutBits);
-    }
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for the specified PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator in question.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param pfnIntHandler is a pointer to the function to be called when the PWM
-//! generator interrupt occurs.
-//!
-//! This function will ensure that the interrupt handler specified by
-//! \e pfnIntHandler is called when an interrupt is detected for the specified
-//! PWM generator block.  This function will also enable the corresponding
-//! PWM generator interrupt in the interrupt controller; individual generator
-//! interrupts and interrupt sources must be enabled with PWMIntEnable() and
-//! PWMGenIntTrigEnable().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenIntRegister(unsigned long ulBase, unsigned long ulGen,
-                  void (*pfnIntHandler)(void))
-{
-    unsigned long ulInt;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Get the interrupt number associated with the specified generator.
-    //
-    if(ulGen == PWM_GEN_3)
-    {
-        ulInt = INT_PWM3;
-    }
-    else
-    {
-        ulInt = INT_PWM0 + (ulGen &gt;&gt; 6) - 1;
-    }
-
-    //
-    // Register the interrupt handler.
-    //
-    IntRegister(ulInt, pfnIntHandler);
-
-    //
-    // Enable the PWMx interrupt.
-    //
-    IntEnable(ulInt);
-}
-
-//*****************************************************************************
-//
-//! Removes an interrupt handler for the specified PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator in question.  Must be one of
-//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//!
-//! This function will unregister the interrupt handler for the specified
-//! PWM generator block.  This function will also disable the corresponding
-//! PWM generator interrupt in the interrupt controller; individual generator
-//! interrupts and interrupt sources must be disabled with PWMIntDisable() and
-//! PWMGenIntTrigDisable().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenIntUnregister(unsigned long ulBase, unsigned long ulGen)
-{
-    unsigned long ulInt;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Get the interrupt number associated with the specified generator.
-    //
-    if(ulGen == PWM_GEN_3)
-    {
-        ulInt = INT_PWM3;
-    }
-    else
-    {
-        ulInt = INT_PWM0 + (ulGen &gt;&gt; 6) - 1;
-    }
-
-    //
-    // Disable the PWMx interrupt.
-    //
-    IntDisable(ulInt);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(ulInt);
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for a fault condition detected in a PWM
-//! module.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param pfnIntHandler is a pointer to the function to be called when the PWM
-//! fault interrupt occurs.
-//!
-//! This function will ensure that the interrupt handler specified by
-//! \e pfnIntHandler is called when a fault interrupt is detected for the
-//! selected PWM module.  This function will also enable the PWM fault
-//! interrupt in the NVIC; the PWM fault interrupt must also be enabled at the
-//! module level using PWMIntEnable().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMFaultIntRegister(unsigned long ulBase, void (*pfnIntHandler)(void))
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-
-    //
-    // Register the interrupt handler, returning an error if one occurs.
-    //
-    IntRegister(INT_PWM_FAULT, pfnIntHandler);
-
-    //
-    // Enable the PWM fault interrupt.
-    //
-    IntEnable(INT_PWM_FAULT);
-}
-
-//*****************************************************************************
-//
-//! Removes the PWM fault condition interrupt handler.
-//!
-//! \param ulBase is the base address of the PWM module.
-//!
-//! This function will remove the interrupt handler for a PWM fault interrupt
-//! from the selected PWM module.  This function will also disable the PWM
-//! fault interrupt in the NVIC; the PWM fault interrupt must also be disabled
-//! at the module level using PWMIntDisable().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMFaultIntUnregister(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-
-    //
-    // Disable the PWM fault interrupt.
-    //
-    IntDisable(INT_PWM_FAULT);
-
-    //
-    // Unregister the interrupt handler, returning an error if one occurs.
-    //
-    IntUnregister(INT_PWM_FAULT);
-}
-
-//*****************************************************************************
-//
-//! Enables interrupts and triggers for the specified PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to have interrupts and triggers enabled.
-//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulIntTrig specifies the interrupts and triggers to be enabled.
-//!
-//! Unmasks the specified interrupt(s) and trigger(s) by setting the
-//! specified bits of the interrupt/trigger enable register for the specified
-//! PWM generator.  The \e ulIntTrig parameter is the logical OR of
-//! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,
-//! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, \b PWM_INT_CNT_BD,
-//! \b PWM_TR_CNT_ZERO, \b PWM_TR_CNT_LOAD, \b PWM_TR_CNT_AU, \b PWM_TR_CNT_AD,
-//! \b PWM_TR_CNT_BU, or \b PWM_TR_CNT_BD.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenIntTrigEnable(unsigned long ulBase, unsigned long ulGen,
-                    unsigned long ulIntTrig)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT((ulIntTrig &amp; ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD |
-                          PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU |
-                          PWM_INT_CNT_BD | PWM_TR_CNT_ZERO | PWM_TR_CNT_LOAD |
-                          PWM_TR_CNT_AU | PWM_TR_CNT_AD | PWM_TR_CNT_BU |
-                          PWM_TR_CNT_BD)) == 0);
-
-    //
-    // Enable the specified interrupts/triggers.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_INTEN) |= ulIntTrig;
-}
-
-//*****************************************************************************
-//
-//! Disables interrupts for the specified PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to have interrupts and triggers disabled.
-//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulIntTrig specifies the interrupts and triggers to be disabled.
-//!
-//! Masks the specified interrupt(s) and trigger(s) by clearing the
-//! specified bits of the interrupt/trigger enable register for the specified
-//! PWM generator.  The \e ulIntTrig parameter is the logical OR of
-//! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,
-//! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, \b PWM_INT_CNT_BD,
-//! \b PWM_TR_CNT_ZERO, \b PWM_TR_CNT_LOAD, \b PWM_TR_CNT_AU, \b PWM_TR_CNT_AD,
-//! \b PWM_TR_CNT_BU, or \b PWM_TR_CNT_BD.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenIntTrigDisable(unsigned long ulBase, unsigned long ulGen,
-                     unsigned long ulIntTrig)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT((ulIntTrig &amp; ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD |
-                          PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU |
-                          PWM_INT_CNT_BD | PWM_TR_CNT_ZERO | PWM_TR_CNT_LOAD |
-                          PWM_TR_CNT_AU | PWM_TR_CNT_AD | PWM_TR_CNT_BU |
-                          PWM_TR_CNT_BD)) == 0);
-
-    //
-    // Disable the specified interrupts/triggers.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_INTEN) &amp;= ~(ulIntTrig);
-}
-
-//*****************************************************************************
-//
-//! Gets interrupt status for the specified PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to query.  Must be one of \b PWM_GEN_0,
-//! \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param bMasked specifies whether masked or raw interrupt status is
-//! returned.
-//!
-//! If \e bMasked is set as \b true, then the masked interrupt status is
-//! returned; otherwise, the raw interrupt status will be returned.
-//!
-//! \return Returns the contents of the interrupt status register, or the
-//! contents of the raw interrupt status register, for the specified
-//! PWM generator.
-//
-//*****************************************************************************
-unsigned long
-PWMGenIntStatus(unsigned long ulBase, unsigned long ulGen, tBoolean bMasked)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-
-    //
-    // Compute the generator's base address.
-    //
-    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
-
-    //
-    // Read and return the specified generator's raw or enabled interrupt
-    // status.
-    //
-    if(bMasked == true)
-    {
-        return(HWREG(ulGen + PWM_O_X_ISC));
-    }
-    else
-    {
-        return(HWREG(ulGen + PWM_O_X_RIS));
-    }
-}
-
-//*****************************************************************************
-//
-//! Clears the specified interrupt(s) for the specified PWM generator block.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator to query.  Must be one of \b PWM_GEN_0,
-//! \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulInts specifies the interrupts to be cleared.
-//!
-//! Clears the specified interrupt(s) by writing a 1 to the specified bits
-//! of the interrupt status register for the specified PWM generator.  The
-//! \e ulInts parameter is the logical OR of \b PWM_INT_CNT_ZERO,
-//! \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU, \b PWM_INT_CNT_AD,
-//! \b PWM_INT_CNT_BU, or \b PWM_INT_CNT_BD.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenIntClear(unsigned long ulBase, unsigned long ulGen, unsigned long ulInts)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT((ulInts &amp; ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD | PWM_INT_CNT_AU |
-                       PWM_INT_CNT_AD | PWM_INT_CNT_BU | PWM_INT_CNT_BD)) ==
-           0);
-
-    //
-    // Clear the requested interrupts by writing ones to the specified bit
-    // of the module's interrupt enable register.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_ISC) = ulInts;
-}
-
-//*****************************************************************************
-//
-//! Enables generator and fault interrupts for a PWM module.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGenFault contains the interrupts to be enabled.  Must be a logical
-//! OR of any of \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2,
-//! \b PWM_INT_GEN_3, \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2,
-//! or \b PWM_INT_FAULT3.
-//!
-//! Unmasks the specified interrupt(s) by setting the specified bits of
-//! the interrupt enable register for the selected PWM module.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMIntEnable(unsigned long ulBase, unsigned long ulGenFault)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT((ulGenFault &amp; ~(PWM_INT_GEN_0 | PWM_INT_GEN_1 | PWM_INT_GEN_2 |
-                           PWM_INT_GEN_3 | PWM_INT_FAULT0 | PWM_INT_FAULT1 |
-                           PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
-
-    //
-    // Read the module's interrupt enable register, and enable interrupts
-    // for the specified PWM generators.
-    //
-    HWREG(ulBase + PWM_O_INTEN) |= ulGenFault;
-}
-
-//*****************************************************************************
-//
-//! Disables generator and fault interrupts for a PWM module.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGenFault contains the interrupts to be disabled.  Must be a
-//! logical OR of any of \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2,
-//! \b PWM_INT_GEN_3, \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2,
-//! or \b PWM_INT_FAULT3.
-//!
-//! Masks the specified interrupt(s) by clearing the specified bits of
-//! the interrupt enable register for the selected PWM module.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMIntDisable(unsigned long ulBase, unsigned long ulGenFault)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT((ulGenFault &amp; ~(PWM_INT_GEN_0 | PWM_INT_GEN_1 | PWM_INT_GEN_2 |
-                           PWM_INT_GEN_3 | PWM_INT_FAULT0 | PWM_INT_FAULT1 |
-                           PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
-
-    //
-    // Read the module's interrupt enable register, and disable interrupts
-    // for the specified PWM generators.
-    //
-    HWREG(ulBase + PWM_O_INTEN) &amp;= ~(ulGenFault);
-}
-
-//*****************************************************************************
-//
-//! Clears the fault interrupt for a PWM module.
-//!
-//! \param ulBase is the base address of the PWM module.
-//!
-//! Clears the fault interrupt by writing to the appropriate bit of the
-//! interrupt status register for the selected PWM module.
-//!
-//! This function clears only the FAULT0 interrupt and is retained for
-//! backwards compatibility.  It is recommended that PWMFaultIntClearExt() be
-//! used instead since it supports all fault interrupts supported on devices
-//! with and without extended PWM fault handling support.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMFaultIntClear(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-
-    //
-    // Write the only writeable bit in the module's interrupt register.
-    //
-    HWREG(ulBase + PWM_O_ISC) = PWM_ISC_INTFAULT0;
-}
-
-//*****************************************************************************
-//
-//! Gets the interrupt status for a PWM module.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param bMasked specifies whether masked or raw interrupt status is
-//! returned.
-//!
-//! If \e bMasked is set as \b true, then the masked interrupt status is
-//! returned; otherwise, the raw interrupt status will be returned.
-//!
-//! \return The current interrupt status, enumerated as a bit field of
-//! \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2, \b PWM_INT_GEN_3,
-//! \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2, and
-//! \b PWM_INT_FAULT3.
-//!
-//*****************************************************************************
-unsigned long
-PWMIntStatus(unsigned long ulBase, tBoolean bMasked)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-
-    //
-    // Read and return either the module's raw or enabled interrupt status.
-    //
-    if(bMasked == true)
-    {
-        return(HWREG(ulBase + PWM_O_ISC));
-    }
-    else
-    {
-        return(HWREG(ulBase + PWM_O_RIS));
-    }
-}
-
-//*****************************************************************************
-//
-//! Clears the fault interrupt for a PWM module.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulFaultInts specifies the fault interrupts to clear.
-//!
-//! Clears one or more fault interrupts by writing to the appropriate bit of
-//! the PWM interrupt status register.  The parameter \e ulFaultInts must be
-//! the logical OR of any of \b PWM_INT_FAULT0, \b PWM_INT_FAULT1,
-//! \b PWM_INT_FAULT2, or \b PWM_INT_FAULT3.
-//!
-//! When running on a device supporting extended PWM fault handling, the fault
-//! interrupts are derived by performing a logical OR of each of the configured
-//! fault trigger signals for a given generator.  Therefore, these interrupts
-//! are not directly related to the four possible FAULTn inputs to the device
-//! but indicate that a fault has been signaled to one of the four possible PWM
-//! generators.  On a device without extended PWM fault handling, the interrupt
-//! is directly related to the state of the single FAULT pin.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several cycles before the interrupt source is actually cleared.  Therefore,
-//! it is recommended that the interrupt source be cleared early in the
-//! interrupt handler (as opposed to the very last action) to avoid returning
-//! from the interrupt handler before the interrupt source is actually cleared.
-//! Failure to do so may result in the interrupt handler being immediately
-//! reentered (since NVIC still sees the interrupt source asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMFaultIntClearExt(unsigned long ulBase, unsigned long ulFaultInts)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT((ulFaultInts &amp; ~(PWM_INT_FAULT0 | PWM_INT_FAULT1 |
-                            PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
-
-    //
-    // Clear the supplied fault bits.
-    //
-    HWREG(ulBase + PWM_O_ISC) = ulFaultInts;
-}
-
-//*****************************************************************************
-//
-//! Configures the minimum fault period and fault pin senses for a given
-//! PWM generator.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator whose fault configuration is being set.
-//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulMinFaultPeriod is the minimum fault active period expressed in
-//! PWM clock cycles.
-//! \param ulFaultSenses indicates which sense of each FAULT input should be
-//! considered the ``asserted'' state.  Valid values are logical OR
-//! combinations of \b PWM_FAULTn_SENSE_HIGH and \b PWM_FAULTn_SENSE_LOW.
-//!
-//! This function sets the minimum fault period for a given generator along
-//! with the sense of each of the 4 possible fault inputs.  The minimum fault
-//! period is expressed in PWM clock cycles and takes effect only if
-//! PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_PER set in the
-//! \e ulConfig parameter.  When a fault input is asserted, the minimum fault
-//! period timer ensures that it remains asserted for at least the number of
-//! clock cycles specified.
-//!
-//! \note This function is only available on devices supporting extended PWM
-//! fault handling.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenFaultConfigure(unsigned long ulBase, unsigned long ulGen,
-                     unsigned long ulMinFaultPeriod,
-                     unsigned long ulFaultSenses)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT(ulMinFaultPeriod &lt; PWM_X_MINFLTPER_M);
-    ASSERT((ulFaultSenses &amp; ~(PWM_FAULT0_SENSE_HIGH | PWM_FAULT0_SENSE_LOW |
-                              PWM_FAULT1_SENSE_HIGH | PWM_FAULT1_SENSE_LOW |
-                              PWM_FAULT2_SENSE_HIGH | PWM_FAULT2_SENSE_LOW |
-                              PWM_FAULT3_SENSE_HIGH | PWM_FAULT3_SENSE_LOW)) ==
-           0);
-
-    //
-    // Write the minimum fault period.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_MINFLTPER) = ulMinFaultPeriod;
-
-    //
-    // Write the fault senses.
-    //
-    HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSEN) = ulFaultSenses;
-}
-
-//*****************************************************************************
-//
-//! Configures the set of fault triggers for a given PWM generator.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator whose fault triggers are being set.  Must
-//! be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulGroup indicates the subset of possible faults that are to be
-//! configured.  This must be \b PWM_FAULT_GROUP_0.
-//! \param ulFaultTriggers defines the set of inputs that are to contribute
-//! towards generation of the fault signal to the given PWM generator.  For
-//! \b PWM_FAULT_GROUP_0, this will be the logical OR of \b PWM_FAULT_FAULT0,
-//! \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or \b PWM_FAULT_FAULT3.
-//!
-//! This function allows selection of the set of fault inputs that will be
-//! combined to generate a fault condition to a given PWM generator.  By
-//! default, all generators use only FAULT0 (for backwards compatibility) but
-//! if PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_SRC in the
-//! \e ulConfig parameter, extended fault handling is enabled and this function
-//! must be called to configure the fault triggers.
-//!
-//! The fault signal to the PWM generator is generated by ORing together each
-//! of the signals whose inputs are specified in the \e ulFaultTriggers
-//! parameter after having adjusted the sense of each FAULTn input based on the
-//! configuration previously set using a call to PWMGenFaultConfigure().
-//!
-//! \note This function is only available on devices supporting extended PWM
-//! fault handling.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenFaultTriggerSet(unsigned long ulBase, unsigned long ulGen,
-                      unsigned long ulGroup, unsigned long ulFaultTriggers)
-{
-    //
-    // Check for valid parameters.
-    //
-    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT(ulGroup == PWM_FAULT_GROUP_0);
-    ASSERT((ulFaultTriggers &amp; ~(PWM_FAULT_FAULT0 | PWM_FAULT_FAULT1 |
-                                PWM_FAULT_FAULT2 | PWM_FAULT_FAULT3)) == 0);
-
-    //
-    // Write the fault triggers to the appropriate register.
-    //
-    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC0) = ulFaultTriggers;
-}
-
-//*****************************************************************************
-//
-//! Returns the set of fault triggers currently configured for a given PWM
-//! generator.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator whose fault triggers are being queried.
-//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
-//! \param ulGroup indicates the subset of faults that are being queried.  This
-//! must be \b PWM_FAULT_GROUP_0.
-//!
-//! This function allows an application to query the current set of inputs that
-//! contribute towards the generation of a fault condition to a given PWM
-//! generator.
-//!
-//! \note This function is only available on devices supporting extended PWM
-//! fault handling.
-//!
-//! \return Returns the current fault triggers configured for the fault group
-//! provided.  For \b PWM_FAULT_GROUP_0, the returned value will be a logical
-//! OR of \b PWM_FAULT_FAULT0, \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or
-//! \b PWM_FAULT_FAULT3.
-//
-//*****************************************************************************
-unsigned long
-PWMGenFaultTriggerGet(unsigned long ulBase, unsigned long ulGen,
-                      unsigned long ulGroup)
-{
-    //
-    // Check for valid parameters.
-    //
-    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT(ulGroup == PWM_FAULT_GROUP_0);
-
-    //
-    // Return the current fault triggers.
-    //
-    return(HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC0));
-}
-
-//*****************************************************************************
-//
-//! Returns the current state of the fault triggers for a given PWM generator.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator whose fault trigger states are being
-//! queried.  Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or
-//! \b PWM_GEN_3.
-//! \param ulGroup indicates the subset of faults that are being queried.  This
-//! must be \b PWM_FAULT_GROUP_0.
-//!
-//! This function allows an application to query the current state of each of
-//! the fault trigger inputs to a given PWM generator.  The current state of
-//! each fault trigger input is returned unless PWMGenConfigure() has
-//! previously been called with flag \b PWM_GEN_MODE_LATCH_FAULT in the
-//! \e ulConfig parameter in which case the returned status is the latched
-//! fault trigger status.
-//!
-//! If latched faults are configured, the application must call
-//! PWMGenFaultClear() to clear each trigger.
-//!
-//! \note This function is only available on devices supporting extended PWM
-//! fault handling.
-//!
-//! \return Returns the current state of the fault triggers for the given PWM
-//! generator.  A set bit indicates that the associated trigger is active.  For
-//! \b PWM_FAULT_GROUP_0, the returned value will be a logical OR of
-//! \b PWM_FAULT_FAULT0, \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or
-//! \b PWM_FAULT_FAULT3.
-//
-//*****************************************************************************
-unsigned long
-PWMGenFaultStatus(unsigned long ulBase, unsigned long ulGen,
-                  unsigned long ulGroup)
-{
-    //
-    // Check for valid parameters.
-    //
-    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT(ulGroup == PWM_FAULT_GROUP_0);
-
-    //
-    // Return the current fault status.
-    //
-    return(HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT0));
-}
-
-//*****************************************************************************
-//
-//! Clears one or more latched fault triggers for a given PWM generator.
-//!
-//! \param ulBase is the base address of the PWM module.
-//! \param ulGen is the PWM generator whose fault trigger states are being
-//! queried.  Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or
-//! \b PWM_GEN_3.
-//! \param ulGroup indicates the subset of faults that are being queried.  This
-//! must be \b PWM_FAULT_GROUP_0.
-//! \param ulFaultTriggers is the set of fault triggers which are to be
-//! cleared.
-//!
-//! This function allows an application to clear the fault triggers for a given
-//! PWM generator.  This is only required if PWMGenConfigure() has previously
-//! been called with flag \b PWM_GEN_MODE_LATCH_FAULT in parameter \e ulConfig.
-//!
-//! \note This function is only available on devices supporting extended PWM
-//! fault handling.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-PWMGenFaultClear(unsigned long ulBase, unsigned long ulGen,
-                 unsigned long ulGroup, unsigned long ulFaultTriggers)
-{
-    //
-    // Check for valid parameters.
-    //
-    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
-    ASSERT(ulBase == PWM_BASE);
-    ASSERT(PWMGenValid(ulGen));
-    ASSERT(ulGroup == PWM_FAULT_GROUP_0);
-    ASSERT((ulFaultTriggers &amp; ~(PWM_FAULT_FAULT0 | PWM_FAULT_FAULT1 |
-                                PWM_FAULT_FAULT2 | PWM_FAULT_FAULT3)) == 0);
-
-    //
-    // Clear the given faults.
-    //
-    HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT0) =
-        ulFaultTriggers;
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// pwm.c - API for the PWM modules
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup pwm_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_pwm.h&quot;
+#include &quot;hw_sysctl.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;pwm.h&quot;
+
+//*****************************************************************************
+//
+// Misc macros for manipulating the encoded generator and output defines used
+// by the API.
+//
+//*****************************************************************************
+#define PWM_GEN_BADDR(_mod_, _gen_)                                           \
+                                ((_mod_) + (_gen_))
+#define PWM_GEN_EXT_BADDR(_mod_, _gen_)                                       \
+                                ((_mod_) + PWM_GEN_EXT_0 +                    \
+                                 ((_gen_) - PWM_GEN_0) * 2)
+#define PWM_OUT_BADDR(_mod_, _out_)                                           \
+                                ((_mod_) + ((_out_) &amp; 0xFFFFFFC0))
+#define PWM_IS_OUTPUT_ODD(_out_)                                              \
+                                ((_out_) &amp; 0x00000001)
+
+//*****************************************************************************
+//
+//! \internal
+//! Checks a PWM generator number.
+//!
+//! \param ulGen is the generator number.
+//!
+//! This function determines if a PWM generator number is valid.
+//!
+//! \return Returnes \b true if the generator number is valid and \b false
+//! otherwise.
+//
+//*****************************************************************************
+#ifdef DEBUG
+static tBoolean
+PWMGenValid(unsigned long ulGen)
+{
+    return((ulGen == PWM_GEN_0) || (ulGen == PWM_GEN_1) ||
+           (ulGen == PWM_GEN_2) || (ulGen == PWM_GEN_3));
+}
+#endif
+
+//*****************************************************************************
+//
+//! \internal
+//! Checks a PWM output number.
+//!
+//! \param ulPWMOut is the output number.
+//!
+//! This function determines if a PWM output number is valid.
+//!
+//! \return Returns \b true if the output number is valid and \b false
+//! otherwise.
+//
+//*****************************************************************************
+#ifdef DEBUG
+static tBoolean
+PWMOutValid(unsigned long ulPWMOut)
+{
+    return((ulPWMOut == PWM_OUT_0) || (ulPWMOut == PWM_OUT_1) ||
+           (ulPWMOut == PWM_OUT_2) || (ulPWMOut == PWM_OUT_3) ||
+           (ulPWMOut == PWM_OUT_4) || (ulPWMOut == PWM_OUT_5) ||
+           (ulPWMOut == PWM_OUT_6) || (ulPWMOut == PWM_OUT_7));
+}
+#endif
+
+//*****************************************************************************
+//
+//! Configures a PWM generator.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to configure.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulConfig is the configuration for the PWM generator.
+//!
+//! This function is used to set the mode of operation for a PWM generator.
+//! The counting mode, synchronization mode, and debug behavior are all
+//! configured.  After configuration, the generator is left in the disabled
+//! state.
+//!
+//! A PWM generator can count in two different modes:  count down mode or count
+//! up/down mode.  In count down mode, it will count from a value down to zero,
+//! and then reset to the preset value.  This will produce left-aligned PWM
+//! signals (that is the rising edge of the two PWM signals produced by the
+//! generator will occur at the same time).  In count up/down mode, it will
+//! count up from zero to the preset value, count back down to zero, and then
+//! repeat the process.  This will produce center-aligned PWM signals (that is,
+//! the middle of the high/low period of the PWM signals produced by the
+//! generator will occur at the same time).
+//!
+//! When the PWM generator parameters (period and pulse width) are modified,
+//! their affect on the output PWM signals can be delayed.  In synchronous
+//! mode, the parameter updates are not applied until a synchronization event
+//! occurs.  This allows multiple parameters to be modified and take affect
+//! simultaneously, instead of one at a time.  Additionally, parameters to
+//! multiple PWM generators in synchronous mode can be updated simultaneously,
+//! allowing them to be treated as if they were a unified generator.  In
+//! non-synchronous mode, the parameter updates are not delayed until a
+//! synchronization event.  In either mode, the parameter updates only occur
+//! when the counter is at zero to help prevent oddly formed PWM signals during
+//! the update (that is, a PWM pulse that is too short or too long).
+//!
+//! The PWM generator can either pause or continue running when the processor
+//! is stopped via the debugger.  If configured to pause, it will continue to
+//! count until it reaches zero, at which point it will pause until the
+//! processor is restarted.  If configured to continue running, it will keep
+//! counting as if nothing had happened.
+//!
+//! The \e ulConfig parameter contains the desired configuration.  It is the
+//! logical OR of the following:
+//!
+//! - \b PWM_GEN_MODE_DOWN or \b PWM_GEN_MODE_UP_DOWN to specify the counting
+//!   mode
+//! - \b PWM_GEN_MODE_SYNC or \b PWM_GEN_MODE_NO_SYNC to specify the counter
+//!   load and comparator update synchronization mode
+//! - \b PWM_GEN_MODE_DBG_RUN or \b PWM_GEN_MODE_DBG_STOP to specify the debug
+//!   behavior
+//! - \b PWM_GEN_MODE_GEN_NO_SYNC, \b PWM_GEN_MODE_GEN_SYNC_LOCAL, or
+//!   \b PWM_GEN_MODE_GEN_SYNC_GLOBAL to specify the update synchronization
+//!   mode for generator counting mode changes
+//! - \b PWM_GEN_MODE_DB_NO_SYNC, \b PWM_GEN_MODE_DB_SYNC_LOCAL, or
+//!   \b PWM_GEN_MODE_DB_SYNC_GLOBAL to specify the deadband parameter
+//!   synchronization mode
+//! - \b PWM_GEN_MODE_FAULT_LATCHED or \b PWM_GEN_MODE_FAULT_UNLATCHED to
+//!   specify whether fault conditions are latched or not
+//! - \b PWM_GEN_MODE_FAULT_MINPER or \b PWM_GEN_MODE_FAULT_NO_MINPER to
+//!   specify whether minimum fault period support is required
+//! - \b PWM_GEN_MODE_FAULT_EXT or \b PWM_GEN_MODE_FAULT_LEGACY to specify
+//!   whether extended fault source selection support is enabled or not
+//!
+//! Setting \b PWM_GEN_MODE_FAULT_MINPER allows an application to set the
+//! minimum duration of a PWM fault signal.  Fault will be signaled for at
+//! least this time even if the external fault pin deasserts earlier.  Care
+//! should be taken when using this mode since during the fault signal period,
+//! the fault interrupt from the PWM generator will remain asserted.  The fault
+//! interrupt handler may, therefore, reenter immediately if it exits prior to
+//! expiration of the fault timer.
+//!
+//! \note Changes to the counter mode will affect the period of the PWM signals
+//! produced.  PWMGenPeriodSet() and PWMPulseWidthSet() should be called after
+//! any changes to the counter mode of a generator.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenConfigure(unsigned long ulBase, unsigned long ulGen,
+                unsigned long ulConfig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Compute the generator's base address.
+    //
+    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
+
+    //
+    // Change the global configuration of the generator.
+    //
+    HWREG(ulGen + PWM_O_X_CTL) = ((HWREG(ulGen + PWM_O_X_CTL) &amp;
+                                   ~(PWM_X_CTL_MODE | PWM_X_CTL_DEBUG |
+                                     PWM_X_CTL_LATCH | PWM_X_CTL_MINFLTPER |
+                                     PWM_X_CTL_FLTSRC | PWM_X_CTL_DBFALLUPD_M |
+                                     PWM_X_CTL_DBRISEUPD_M |
+                                     PWM_X_CTL_DBCTLUPD_M |
+                                     PWM_X_CTL_GENBUPD_M |
+                                     PWM_X_CTL_GENAUPD_M |
+                                     PWM_X_CTL_LOADUPD | PWM_X_CTL_CMPAUPD |
+                                     PWM_X_CTL_CMPBUPD)) | ulConfig);
+
+    //
+    // Set the individual PWM generator controls.
+    //
+    if(ulConfig &amp; PWM_X_CTL_MODE)
+    {
+        //
+        // In up/down count mode, set the signal high on up count comparison
+        // and low on down count comparison (that is, center align the
+        // signals).
+        //
+        HWREG(ulGen + PWM_O_X_GENA) = (PWM_X_GENA_ACTCMPAU_ONE |
+                                       PWM_X_GENA_ACTCMPAD_ZERO);
+        HWREG(ulGen + PWM_O_X_GENB) = (PWM_X_GENB_ACTCMPBU_ONE |
+                                       PWM_X_GENB_ACTCMPBD_ZERO);
+    }
+    else
+    {
+        //
+        // In down count mode, set the signal high on load and low on count
+        // comparison (that is, left align the signals).
+        //
+        HWREG(ulGen + PWM_O_X_GENA) = (PWM_X_GENA_ACTLOAD_ONE |
+                                       PWM_X_GENA_ACTCMPAD_ZERO);
+        HWREG(ulGen + PWM_O_X_GENB) = (PWM_X_GENB_ACTLOAD_ONE |
+                                       PWM_X_GENB_ACTCMPBD_ZERO);
+    }
+}
+
+//*****************************************************************************
+//
+//! Set the period of a PWM generator.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to be modified.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulPeriod specifies the period of PWM generator output, measured
+//! in clock ticks.
+//!
+//! This function sets the period of the specified PWM generator block, where
+//! the period of the generator block is defined as the number of PWM clock
+//! ticks between pulses on the generator block zero signal.
+//!
+//! \note Any subsequent calls made to this function before an update occurs
+//! will cause the previous values to be overwritten.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenPeriodSet(unsigned long ulBase, unsigned long ulGen,
+                unsigned long ulPeriod)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Compute the generator's base address.
+    //
+    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
+
+    //
+    // Set the reload register based on the mode.
+    //
+    if(HWREG(ulGen + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
+    {
+        //
+        // In up/down count mode, set the reload register to half the requested
+        // period.
+        //
+        ASSERT((ulPeriod / 2) &lt; 65536);
+        HWREG(ulGen + PWM_O_X_LOAD) = ulPeriod / 2;
+    }
+    else
+    {
+        //
+        // In down count mode, set the reload register to the requested period
+        // minus one.
+        //
+        ASSERT((ulPeriod &lt;= 65536) &amp;&amp; (ulPeriod != 0));
+        HWREG(ulGen + PWM_O_X_LOAD) = ulPeriod - 1;
+    }
+}
+
+//*****************************************************************************
+//
+//! Gets the period of a PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to query.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//!
+//! This function gets the period of the specified PWM generator block.  The
+//! period of the generator block is defined as the number of PWM clock ticks
+//! between pulses on the generator block zero signal.
+//!
+//! If the update of the counter for the specified PWM generator has yet
+//! to be completed, the value returned may not be the active period.  The
+//! value returned is the programmed period, measured in PWM clock ticks.
+//!
+//! \return Returns the programmed period of the specified generator block
+//! in PWM clock ticks.
+//
+//*****************************************************************************
+unsigned long
+PWMGenPeriodGet(unsigned long ulBase, unsigned long ulGen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Compute the generator's base address.
+    //
+    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
+
+    //
+    // Figure out the counter mode.
+    //
+    if(HWREG(ulGen + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
+    {
+        //
+        // The period is twice the reload register value.
+        //
+        return(HWREG(ulGen + PWM_O_X_LOAD) * 2);
+    }
+    else
+    {
+        //
+        // The period is the reload register value plus one.
+        //
+        return(HWREG(ulGen + PWM_O_X_LOAD) + 1);
+    }
+}
+
+//*****************************************************************************
+//
+//! Enables the timer/counter for a PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to be enabled.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//!
+//! This function allows the PWM clock to drive the timer/counter for the
+//! specified generator block.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenEnable(unsigned long ulBase, unsigned long ulGen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Enable the PWM generator.
+    //
+    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_CTL) |= PWM_X_CTL_ENABLE;
+}
+
+//*****************************************************************************
+//
+//! Disables the timer/counter for a PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to be disabled.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//!
+//! This function blocks the PWM clock from driving the timer/counter for the
+//! specified generator block.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenDisable(unsigned long ulBase, unsigned long ulGen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Disable the PWM generator.
+    //
+    HWREG(PWM_GEN_BADDR(ulBase, + ulGen) + PWM_O_X_CTL) &amp;= ~(PWM_X_CTL_ENABLE);
+}
+
+//*****************************************************************************
+//
+//! Sets the pulse width for the specified PWM output.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulPWMOut is the PWM output to modify.  Must be one of \b PWM_OUT_0,
+//! \b PWM_OUT_1, \b PWM_OUT_2, \b PWM_OUT_3, \b PWM_OUT_4, \b PWM_OUT_5,
+//! \b PWM_OUT_6, or \b PWM_OUT_7.
+//! \param ulWidth specifies the width of the positive portion of the pulse.
+//!
+//! This function sets the pulse width for the specified PWM output, where the
+//! pulse width is defined as the number of PWM clock ticks.
+//!
+//! \note Any subsequent calls made to this function before an update occurs
+//! will cause the previous values to be overwritten.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMPulseWidthSet(unsigned long ulBase, unsigned long ulPWMOut,
+                 unsigned long ulWidth)
+{
+    unsigned long ulGenBase, ulReg;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMOutValid(ulPWMOut));
+
+    //
+    // Compute the generator's base address.
+    //
+    ulGenBase = PWM_OUT_BADDR(ulBase, ulPWMOut);
+
+    //
+    // If the counter is in up/down count mode, divide the width by two.
+    //
+    if(HWREG(ulGenBase + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
+    {
+        ulWidth /= 2;
+    }
+
+    //
+    // Get the period.
+    //
+    ulReg = HWREG(ulGenBase + PWM_O_X_LOAD);
+
+    //
+    // Make sure the width is not too large.
+    //
+    ASSERT(ulWidth &lt; ulReg);
+
+    //
+    // Compute the compare value.
+    //
+    ulReg = ulReg - ulWidth;
+
+    //
+    // Write to the appropriate registers.
+    //
+    if(PWM_IS_OUTPUT_ODD(ulPWMOut))
+    {
+        HWREG(ulGenBase + PWM_O_X_CMPB) = ulReg;
+    }
+    else
+    {
+        HWREG(ulGenBase + PWM_O_X_CMPA) = ulReg;
+    }
+}
+
+//*****************************************************************************
+//
+//! Gets the pulse width of a PWM output.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulPWMOut is the PWM output to query.  Must be one of \b PWM_OUT_0,
+//! \b PWM_OUT_1, \b PWM_OUT_2, \b PWM_OUT_3, \b PWM_OUT_4, \b PWM_OUT_5,
+//! \b PWM_OUT_6, or \b PWM_OUT_7.
+//!
+//! This function gets the currently programmed pulse width for the specified
+//! PWM output.  If the update of the comparator for the specified output has
+//! yet to be completed, the value returned may not be the active pulse width.
+//! The value returned is the programmed pulse width, measured in PWM clock
+//! ticks.
+//!
+//! \return Returns the width of the pulse in PWM clock ticks.
+//
+//*****************************************************************************
+unsigned long
+PWMPulseWidthGet(unsigned long ulBase, unsigned long ulPWMOut)
+{
+    unsigned long ulGenBase, ulReg, ulLoad;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMOutValid(ulPWMOut));
+
+    //
+    // Compute the generator's base address.
+    //
+    ulGenBase = PWM_OUT_BADDR(ulBase, ulPWMOut);
+
+    //
+    // Then compute the pulse width.  If mode is UpDown, set
+    // width = (load - compare) * 2.  Otherwise, set width = load - compare.
+    //
+    ulLoad = HWREG(ulGenBase + PWM_O_X_LOAD);
+    if(PWM_IS_OUTPUT_ODD(ulPWMOut))
+    {
+        ulReg = HWREG(ulGenBase + PWM_O_X_CMPB);
+    }
+    else
+    {
+        ulReg = HWREG(ulGenBase + PWM_O_X_CMPA);
+    }
+    ulReg = ulLoad - ulReg;
+
+    //
+    // If in up/down count mode, double the pulse width.
+    //
+    if(HWREG(ulGenBase + PWM_O_X_CTL) &amp; PWM_X_CTL_MODE)
+    {
+        ulReg = ulReg * 2;
+    }
+
+    //
+    // Return the pulse width.
+    //
+    return(ulReg);
+}
+
+//*****************************************************************************
+//
+//! Enables the PWM dead band output, and sets the dead band delays.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to modify.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param usRise specifies the width of delay from the rising edge.
+//! \param usFall specifies the width of delay from the falling edge.
+//!
+//! This function sets the dead bands for the specified PWM generator,
+//! where the dead bands are defined as the number of \b PWM clock ticks
+//! from the rising or falling edge of the generator's \b OutA signal.
+//! Note that this function causes the coupling of \b OutB to \b OutA.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMDeadBandEnable(unsigned long ulBase, unsigned long ulGen,
+                  unsigned short usRise, unsigned short usFall)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT(usRise &lt; 4096);
+    ASSERT(usFall &lt; 4096);
+
+    //
+    // Compute the generator's base address.
+    //
+    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
+
+    //
+    // Write the dead band delay values.
+    //
+    HWREG(ulGen + PWM_O_X_DBRISE) = usRise;
+    HWREG(ulGen + PWM_O_X_DBFALL) = usFall;
+
+    //
+    // Enable the deadband functionality.
+    //
+    HWREG(ulGen + PWM_O_X_DBCTL) |= PWM_X_DBCTL_ENABLE;
+}
+
+//*****************************************************************************
+//
+//! Disables the PWM dead band output.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to modify.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//!
+//! This function disables the dead band mode for the specified PWM generator.
+//! Doing so decouples the \b OutA and \b OutB signals.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMDeadBandDisable(unsigned long ulBase, unsigned long ulGen)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Disable the deadband functionality.
+    //
+    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_DBCTL) &amp;=
+        ~(PWM_X_DBCTL_ENABLE);
+}
+
+//*****************************************************************************
+//
+//! Synchronizes all pending updates.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGenBits are the PWM generator blocks to be updated.  Must be the
+//! logical OR of any of \b PWM_GEN_0_BIT, \b PWM_GEN_1_BIT,
+//! \b PWM_GEN_2_BIT, or \b PWM_GEN_3_BIT.
+//!
+//! For the selected PWM generators, this function causes all queued updates to
+//! the period or pulse width to be applied the next time the corresponding
+//! counter becomes zero.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMSyncUpdate(unsigned long ulBase, unsigned long ulGenBits)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(!(ulGenBits &amp; ~(PWM_GEN_0_BIT | PWM_GEN_1_BIT | PWM_GEN_2_BIT |
+                           PWM_GEN_3_BIT)));
+
+    //
+    // Synchronize pending PWM register changes.
+    //
+    HWREG(ulBase + PWM_O_CTL) = ulGenBits;
+}
+
+//*****************************************************************************
+//
+//! Synchronizes the counters in one or multiple PWM generator blocks.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGenBits are the PWM generator blocks to be synchronized.  Must be
+//! the logical OR of any of \b PWM_GEN_0_BIT, \b PWM_GEN_1_BIT,
+//! \b PWM_GEN_2_BIT, or \b PWM_GEN_3_BIT.
+//!
+//! For the selected PWM module, this function synchronizes the time base
+//! of the generator blocks by causing the specified generator counters to be
+//! reset to zero.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMSyncTimeBase(unsigned long ulBase, unsigned long ulGenBits)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(!(ulGenBits &amp; ~(PWM_GEN_0_BIT | PWM_GEN_1_BIT | PWM_GEN_2_BIT |
+                           PWM_GEN_3_BIT)));
+
+    //
+    // Synchronize the counters in the specified generators by writing to the
+    // module's synchronization register.
+    //
+    HWREG(ulBase + PWM_O_SYNC) = ulGenBits;
+}
+
+//*****************************************************************************
+//
+//! Enables or disables PWM outputs.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
+//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
+//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT,
+//! or \b PWM_OUT_7_BIT.
+//! \param bEnable determines if the signal is enabled or disabled.
+//!
+//! This function is used to enable or disable the selected PWM outputs.  The
+//! outputs are selected using the parameter \e ulPWMOutBits.  The parameter
+//! \e bEnable determines the state of the selected outputs.  If \e bEnable is
+//! \b true, then the selected PWM outputs are enabled, or placed in the active
+//! state.  If \e bEnable is \b false, then the selected outputs are disabled,
+//! or placed in the inactive state.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMOutputState(unsigned long ulBase, unsigned long ulPWMOutBits,
+               tBoolean bEnable)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
+                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
+                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
+
+    //
+    // Read the module's ENABLE output control register, and set or clear the
+    // requested bits.
+    //
+    if(bEnable == true)
+    {
+        HWREG(ulBase + PWM_O_ENABLE) |= ulPWMOutBits;
+    }
+    else
+    {
+        HWREG(ulBase + PWM_O_ENABLE) &amp;= ~(ulPWMOutBits);
+    }
+}
+
+//*****************************************************************************
+//
+//! Selects the inversion mode for PWM outputs.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
+//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
+//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT, or
+//! \b PWM_OUT_7_BIT.
+//! \param bInvert determines if the signal is inverted or passed through.
+//!
+//! This function is used to select the inversion mode for the selected PWM
+//! outputs.  The outputs are selected using the parameter \e ulPWMOutBits.
+//! The parameter \e bInvert determines the inversion mode for the selected
+//! outputs.  If \e bInvert is \b true, this function will cause the specified
+//! PWM output signals to be inverted, or made active low.  If \e bInvert is
+//! \b false, the specified output will be passed through as is, or be made
+//! active high.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMOutputInvert(unsigned long ulBase, unsigned long ulPWMOutBits,
+                tBoolean bInvert)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
+                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
+                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
+
+    //
+    // Read the module's INVERT output control register, and set or clear the
+    // requested bits.
+    //
+    if(bInvert == true)
+    {
+        HWREG(ulBase + PWM_O_INVERT) |= ulPWMOutBits;
+    }
+    else
+    {
+        HWREG(ulBase + PWM_O_INVERT) &amp;= ~(ulPWMOutBits);
+    }
+}
+
+//*****************************************************************************
+//
+//! Specifies the level of PWM outputs suppressed in response to a fault
+//! condition.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
+//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
+//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT, or
+//! \b PWM_OUT_7_BIT.
+//! \param bDriveHigh determines if the signal is driven high or low during an
+//! active fault condition.
+//!
+//! This function determines whether a PWM output pin that is suppressed in
+//! response to a fault condition will be driven high or low.  The affected
+//! outputs are selected using the parameter \e ulPWMOutBits.  The parameter
+//! \e bDriveHigh determines the output level for the pins identified by
+//! \e ulPWMOutBits.  If \e bDriveHigh is \b true then the selected outputs
+//! will be driven high when a fault is detected.  If it is \e false, the pins
+//! will be driven low.
+//!
+//! In a fault condition, pins which have not been configured to be suppressed
+//! via a call to PWMOutputFault() are unaffected by this function.
+//!
+//! \note This function is available only on devices which support extended
+//! PWM fault handling.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMOutputFaultLevel(unsigned long ulBase, unsigned long ulPWMOutBits,
+                    tBoolean bDriveHigh)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
+                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
+                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
+
+    //
+    // Read the module's FAULT output control register, and set or clear the
+    // requested bits.
+    //
+    if(bDriveHigh == true)
+    {
+        HWREG(ulBase + PWM_O_FAULTVAL) |= ulPWMOutBits;
+    }
+    else
+    {
+        HWREG(ulBase + PWM_O_FAULTVAL) &amp;= ~(ulPWMOutBits);
+    }
+}
+
+//*****************************************************************************
+//
+//! Specifies the state of PWM outputs in response to a fault condition.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulPWMOutBits are the PWM outputs to be modified.  Must be the
+//! logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT, \b PWM_OUT_2_BIT,
+//! \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT, \b PWM_OUT_6_BIT, or
+//! \b PWM_OUT_7_BIT.
+//! \param bFaultSuppress determines if the signal is suppressed or passed
+//! through during an active fault condition.
+//!
+//! This function sets the fault handling characteristics of the selected PWM
+//! outputs.  The outputs are selected using the parameter \e ulPWMOutBits.
+//! The parameter \e bFaultSuppress determines the fault handling
+//! characteristics for the selected outputs.  If \e bFaultSuppress is \b true,
+//! then the selected outputs will be made inactive.  If \e bFaultSuppress is
+//! \b false, then the selected outputs are unaffected by the detected fault.
+//!
+//! On devices supporting extended PWM fault handling, the state the affected
+//! output pins are driven to can be configured with PWMOutputFaultLevel().  If
+//! not configured, or if the device does not support extended PWM fault
+//! handling, affected outputs will be driven low on a fault condition.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMOutputFault(unsigned long ulBase, unsigned long ulPWMOutBits,
+               tBoolean bFaultSuppress)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(!(ulPWMOutBits &amp; ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT |
+                              PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT |
+                              PWM_OUT_6_BIT | PWM_OUT_7_BIT)));
+
+    //
+    // Read the module's FAULT output control register, and set or clear the
+    // requested bits.
+    //
+    if(bFaultSuppress == true)
+    {
+        HWREG(ulBase + PWM_O_FAULT) |= ulPWMOutBits;
+    }
+    else
+    {
+        HWREG(ulBase + PWM_O_FAULT) &amp;= ~(ulPWMOutBits);
+    }
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the specified PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator in question.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param pfnIntHandler is a pointer to the function to be called when the PWM
+//! generator interrupt occurs.
+//!
+//! This function will ensure that the interrupt handler specified by
+//! \e pfnIntHandler is called when an interrupt is detected for the specified
+//! PWM generator block.  This function will also enable the corresponding
+//! PWM generator interrupt in the interrupt controller; individual generator
+//! interrupts and interrupt sources must be enabled with PWMIntEnable() and
+//! PWMGenIntTrigEnable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenIntRegister(unsigned long ulBase, unsigned long ulGen,
+                  void (*pfnIntHandler)(void))
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Get the interrupt number associated with the specified generator.
+    //
+    if(ulGen == PWM_GEN_3)
+    {
+        ulInt = INT_PWM3;
+    }
+    else
+    {
+        ulInt = INT_PWM0 + (ulGen &gt;&gt; 6) - 1;
+    }
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(ulInt, pfnIntHandler);
+
+    //
+    // Enable the PWMx interrupt.
+    //
+    IntEnable(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Removes an interrupt handler for the specified PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator in question.  Must be one of
+//! \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//!
+//! This function will unregister the interrupt handler for the specified
+//! PWM generator block.  This function will also disable the corresponding
+//! PWM generator interrupt in the interrupt controller; individual generator
+//! interrupts and interrupt sources must be disabled with PWMIntDisable() and
+//! PWMGenIntTrigDisable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenIntUnregister(unsigned long ulBase, unsigned long ulGen)
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Get the interrupt number associated with the specified generator.
+    //
+    if(ulGen == PWM_GEN_3)
+    {
+        ulInt = INT_PWM3;
+    }
+    else
+    {
+        ulInt = INT_PWM0 + (ulGen &gt;&gt; 6) - 1;
+    }
+
+    //
+    // Disable the PWMx interrupt.
+    //
+    IntDisable(ulInt);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for a fault condition detected in a PWM
+//! module.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param pfnIntHandler is a pointer to the function to be called when the PWM
+//! fault interrupt occurs.
+//!
+//! This function will ensure that the interrupt handler specified by
+//! \e pfnIntHandler is called when a fault interrupt is detected for the
+//! selected PWM module.  This function will also enable the PWM fault
+//! interrupt in the NVIC; the PWM fault interrupt must also be enabled at the
+//! module level using PWMIntEnable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMFaultIntRegister(unsigned long ulBase, void (*pfnIntHandler)(void))
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+
+    //
+    // Register the interrupt handler, returning an error if one occurs.
+    //
+    IntRegister(INT_PWM_FAULT, pfnIntHandler);
+
+    //
+    // Enable the PWM fault interrupt.
+    //
+    IntEnable(INT_PWM_FAULT);
+}
+
+//*****************************************************************************
+//
+//! Removes the PWM fault condition interrupt handler.
+//!
+//! \param ulBase is the base address of the PWM module.
+//!
+//! This function will remove the interrupt handler for a PWM fault interrupt
+//! from the selected PWM module.  This function will also disable the PWM
+//! fault interrupt in the NVIC; the PWM fault interrupt must also be disabled
+//! at the module level using PWMIntDisable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMFaultIntUnregister(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+
+    //
+    // Disable the PWM fault interrupt.
+    //
+    IntDisable(INT_PWM_FAULT);
+
+    //
+    // Unregister the interrupt handler, returning an error if one occurs.
+    //
+    IntUnregister(INT_PWM_FAULT);
+}
+
+//*****************************************************************************
+//
+//! Enables interrupts and triggers for the specified PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to have interrupts and triggers enabled.
+//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulIntTrig specifies the interrupts and triggers to be enabled.
+//!
+//! Unmasks the specified interrupt(s) and trigger(s) by setting the
+//! specified bits of the interrupt/trigger enable register for the specified
+//! PWM generator.  The \e ulIntTrig parameter is the logical OR of
+//! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,
+//! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, \b PWM_INT_CNT_BD,
+//! \b PWM_TR_CNT_ZERO, \b PWM_TR_CNT_LOAD, \b PWM_TR_CNT_AU, \b PWM_TR_CNT_AD,
+//! \b PWM_TR_CNT_BU, or \b PWM_TR_CNT_BD.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenIntTrigEnable(unsigned long ulBase, unsigned long ulGen,
+                    unsigned long ulIntTrig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT((ulIntTrig &amp; ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD |
+                          PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU |
+                          PWM_INT_CNT_BD | PWM_TR_CNT_ZERO | PWM_TR_CNT_LOAD |
+                          PWM_TR_CNT_AU | PWM_TR_CNT_AD | PWM_TR_CNT_BU |
+                          PWM_TR_CNT_BD)) == 0);
+
+    //
+    // Enable the specified interrupts/triggers.
+    //
+    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_INTEN) |= ulIntTrig;
+}
+
+//*****************************************************************************
+//
+//! Disables interrupts for the specified PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to have interrupts and triggers disabled.
+//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulIntTrig specifies the interrupts and triggers to be disabled.
+//!
+//! Masks the specified interrupt(s) and trigger(s) by clearing the
+//! specified bits of the interrupt/trigger enable register for the specified
+//! PWM generator.  The \e ulIntTrig parameter is the logical OR of
+//! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,
+//! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, \b PWM_INT_CNT_BD,
+//! \b PWM_TR_CNT_ZERO, \b PWM_TR_CNT_LOAD, \b PWM_TR_CNT_AU, \b PWM_TR_CNT_AD,
+//! \b PWM_TR_CNT_BU, or \b PWM_TR_CNT_BD.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenIntTrigDisable(unsigned long ulBase, unsigned long ulGen,
+                     unsigned long ulIntTrig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT((ulIntTrig &amp; ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD |
+                          PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU |
+                          PWM_INT_CNT_BD | PWM_TR_CNT_ZERO | PWM_TR_CNT_LOAD |
+                          PWM_TR_CNT_AU | PWM_TR_CNT_AD | PWM_TR_CNT_BU |
+                          PWM_TR_CNT_BD)) == 0);
+
+    //
+    // Disable the specified interrupts/triggers.
+    //
+    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_INTEN) &amp;= ~(ulIntTrig);
+}
+
+//*****************************************************************************
+//
+//! Gets interrupt status for the specified PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to query.  Must be one of \b PWM_GEN_0,
+//! \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param bMasked specifies whether masked or raw interrupt status is
+//! returned.
+//!
+//! If \e bMasked is set as \b true, then the masked interrupt status is
+//! returned; otherwise, the raw interrupt status will be returned.
+//!
+//! \return Returns the contents of the interrupt status register, or the
+//! contents of the raw interrupt status register, for the specified
+//! PWM generator.
+//
+//*****************************************************************************
+unsigned long
+PWMGenIntStatus(unsigned long ulBase, unsigned long ulGen, tBoolean bMasked)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+
+    //
+    // Compute the generator's base address.
+    //
+    ulGen = PWM_GEN_BADDR(ulBase, ulGen);
+
+    //
+    // Read and return the specified generator's raw or enabled interrupt
+    // status.
+    //
+    if(bMasked == true)
+    {
+        return(HWREG(ulGen + PWM_O_X_ISC));
+    }
+    else
+    {
+        return(HWREG(ulGen + PWM_O_X_RIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears the specified interrupt(s) for the specified PWM generator block.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator to query.  Must be one of \b PWM_GEN_0,
+//! \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulInts specifies the interrupts to be cleared.
+//!
+//! Clears the specified interrupt(s) by writing a 1 to the specified bits
+//! of the interrupt status register for the specified PWM generator.  The
+//! \e ulInts parameter is the logical OR of \b PWM_INT_CNT_ZERO,
+//! \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU, \b PWM_INT_CNT_AD,
+//! \b PWM_INT_CNT_BU, or \b PWM_INT_CNT_BD.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenIntClear(unsigned long ulBase, unsigned long ulGen, unsigned long ulInts)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT((ulInts &amp; ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD | PWM_INT_CNT_AU |
+                       PWM_INT_CNT_AD | PWM_INT_CNT_BU | PWM_INT_CNT_BD)) ==
+           0);
+
+    //
+    // Clear the requested interrupts by writing ones to the specified bit
+    // of the module's interrupt enable register.
+    //
+    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_ISC) = ulInts;
+}
+
+//*****************************************************************************
+//
+//! Enables generator and fault interrupts for a PWM module.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGenFault contains the interrupts to be enabled.  Must be a logical
+//! OR of any of \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2,
+//! \b PWM_INT_GEN_3, \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2,
+//! or \b PWM_INT_FAULT3.
+//!
+//! Unmasks the specified interrupt(s) by setting the specified bits of
+//! the interrupt enable register for the selected PWM module.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMIntEnable(unsigned long ulBase, unsigned long ulGenFault)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT((ulGenFault &amp; ~(PWM_INT_GEN_0 | PWM_INT_GEN_1 | PWM_INT_GEN_2 |
+                           PWM_INT_GEN_3 | PWM_INT_FAULT0 | PWM_INT_FAULT1 |
+                           PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
+
+    //
+    // Read the module's interrupt enable register, and enable interrupts
+    // for the specified PWM generators.
+    //
+    HWREG(ulBase + PWM_O_INTEN) |= ulGenFault;
+}
+
+//*****************************************************************************
+//
+//! Disables generator and fault interrupts for a PWM module.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGenFault contains the interrupts to be disabled.  Must be a
+//! logical OR of any of \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2,
+//! \b PWM_INT_GEN_3, \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2,
+//! or \b PWM_INT_FAULT3.
+//!
+//! Masks the specified interrupt(s) by clearing the specified bits of
+//! the interrupt enable register for the selected PWM module.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMIntDisable(unsigned long ulBase, unsigned long ulGenFault)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT((ulGenFault &amp; ~(PWM_INT_GEN_0 | PWM_INT_GEN_1 | PWM_INT_GEN_2 |
+                           PWM_INT_GEN_3 | PWM_INT_FAULT0 | PWM_INT_FAULT1 |
+                           PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
+
+    //
+    // Read the module's interrupt enable register, and disable interrupts
+    // for the specified PWM generators.
+    //
+    HWREG(ulBase + PWM_O_INTEN) &amp;= ~(ulGenFault);
+}
+
+//*****************************************************************************
+//
+//! Clears the fault interrupt for a PWM module.
+//!
+//! \param ulBase is the base address of the PWM module.
+//!
+//! Clears the fault interrupt by writing to the appropriate bit of the
+//! interrupt status register for the selected PWM module.
+//!
+//! This function clears only the FAULT0 interrupt and is retained for
+//! backwards compatibility.  It is recommended that PWMFaultIntClearExt() be
+//! used instead since it supports all fault interrupts supported on devices
+//! with and without extended PWM fault handling support.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMFaultIntClear(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+
+    //
+    // Write the only writeable bit in the module's interrupt register.
+    //
+    HWREG(ulBase + PWM_O_ISC) = PWM_ISC_INTFAULT0;
+}
+
+//*****************************************************************************
+//
+//! Gets the interrupt status for a PWM module.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param bMasked specifies whether masked or raw interrupt status is
+//! returned.
+//!
+//! If \e bMasked is set as \b true, then the masked interrupt status is
+//! returned; otherwise, the raw interrupt status will be returned.
+//!
+//! \return The current interrupt status, enumerated as a bit field of
+//! \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2, \b PWM_INT_GEN_3,
+//! \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2, and
+//! \b PWM_INT_FAULT3.
+//!
+//*****************************************************************************
+unsigned long
+PWMIntStatus(unsigned long ulBase, tBoolean bMasked)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+
+    //
+    // Read and return either the module's raw or enabled interrupt status.
+    //
+    if(bMasked == true)
+    {
+        return(HWREG(ulBase + PWM_O_ISC));
+    }
+    else
+    {
+        return(HWREG(ulBase + PWM_O_RIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears the fault interrupt for a PWM module.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulFaultInts specifies the fault interrupts to clear.
+//!
+//! Clears one or more fault interrupts by writing to the appropriate bit of
+//! the PWM interrupt status register.  The parameter \e ulFaultInts must be
+//! the logical OR of any of \b PWM_INT_FAULT0, \b PWM_INT_FAULT1,
+//! \b PWM_INT_FAULT2, or \b PWM_INT_FAULT3.
+//!
+//! When running on a device supporting extended PWM fault handling, the fault
+//! interrupts are derived by performing a logical OR of each of the configured
+//! fault trigger signals for a given generator.  Therefore, these interrupts
+//! are not directly related to the four possible FAULTn inputs to the device
+//! but indicate that a fault has been signaled to one of the four possible PWM
+//! generators.  On a device without extended PWM fault handling, the interrupt
+//! is directly related to the state of the single FAULT pin.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several cycles before the interrupt source is actually cleared.  Therefore,
+//! it is recommended that the interrupt source be cleared early in the
+//! interrupt handler (as opposed to the very last action) to avoid returning
+//! from the interrupt handler before the interrupt source is actually cleared.
+//! Failure to do so may result in the interrupt handler being immediately
+//! reentered (since NVIC still sees the interrupt source asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMFaultIntClearExt(unsigned long ulBase, unsigned long ulFaultInts)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT((ulFaultInts &amp; ~(PWM_INT_FAULT0 | PWM_INT_FAULT1 |
+                            PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0);
+
+    //
+    // Clear the supplied fault bits.
+    //
+    HWREG(ulBase + PWM_O_ISC) = ulFaultInts;
+}
+
+//*****************************************************************************
+//
+//! Configures the minimum fault period and fault pin senses for a given
+//! PWM generator.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator whose fault configuration is being set.
+//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulMinFaultPeriod is the minimum fault active period expressed in
+//! PWM clock cycles.
+//! \param ulFaultSenses indicates which sense of each FAULT input should be
+//! considered the ``asserted'' state.  Valid values are logical OR
+//! combinations of \b PWM_FAULTn_SENSE_HIGH and \b PWM_FAULTn_SENSE_LOW.
+//!
+//! This function sets the minimum fault period for a given generator along
+//! with the sense of each of the 4 possible fault inputs.  The minimum fault
+//! period is expressed in PWM clock cycles and takes effect only if
+//! PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_PER set in the
+//! \e ulConfig parameter.  When a fault input is asserted, the minimum fault
+//! period timer ensures that it remains asserted for at least the number of
+//! clock cycles specified.
+//!
+//! \note This function is only available on devices supporting extended PWM
+//! fault handling.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenFaultConfigure(unsigned long ulBase, unsigned long ulGen,
+                     unsigned long ulMinFaultPeriod,
+                     unsigned long ulFaultSenses)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT(ulMinFaultPeriod &lt; PWM_X_MINFLTPER_M);
+    ASSERT((ulFaultSenses &amp; ~(PWM_FAULT0_SENSE_HIGH | PWM_FAULT0_SENSE_LOW |
+                              PWM_FAULT1_SENSE_HIGH | PWM_FAULT1_SENSE_LOW |
+                              PWM_FAULT2_SENSE_HIGH | PWM_FAULT2_SENSE_LOW |
+                              PWM_FAULT3_SENSE_HIGH | PWM_FAULT3_SENSE_LOW)) ==
+           0);
+
+    //
+    // Write the minimum fault period.
+    //
+    HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_MINFLTPER) = ulMinFaultPeriod;
+
+    //
+    // Write the fault senses.
+    //
+    HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSEN) = ulFaultSenses;
+}
+
+//*****************************************************************************
+//
+//! Configures the set of fault triggers for a given PWM generator.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator whose fault triggers are being set.  Must
+//! be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulGroup indicates the subset of possible faults that are to be
+//! configured.  This must be \b PWM_FAULT_GROUP_0.
+//! \param ulFaultTriggers defines the set of inputs that are to contribute
+//! towards generation of the fault signal to the given PWM generator.  For
+//! \b PWM_FAULT_GROUP_0, this will be the logical OR of \b PWM_FAULT_FAULT0,
+//! \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or \b PWM_FAULT_FAULT3.
+//!
+//! This function allows selection of the set of fault inputs that will be
+//! combined to generate a fault condition to a given PWM generator.  By
+//! default, all generators use only FAULT0 (for backwards compatibility) but
+//! if PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_SRC in the
+//! \e ulConfig parameter, extended fault handling is enabled and this function
+//! must be called to configure the fault triggers.
+//!
+//! The fault signal to the PWM generator is generated by ORing together each
+//! of the signals whose inputs are specified in the \e ulFaultTriggers
+//! parameter after having adjusted the sense of each FAULTn input based on the
+//! configuration previously set using a call to PWMGenFaultConfigure().
+//!
+//! \note This function is only available on devices supporting extended PWM
+//! fault handling.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenFaultTriggerSet(unsigned long ulBase, unsigned long ulGen,
+                      unsigned long ulGroup, unsigned long ulFaultTriggers)
+{
+    //
+    // Check for valid parameters.
+    //
+    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
+    ASSERT((ulFaultTriggers &amp; ~(PWM_FAULT_FAULT0 | PWM_FAULT_FAULT1 |
+                                PWM_FAULT_FAULT2 | PWM_FAULT_FAULT3)) == 0);
+
+    //
+    // Write the fault triggers to the appropriate register.
+    //
+    if(ulGroup == PWM_FAULT_GROUP_0)
+    {
+        HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC0) =
+            ulFaultTriggers;
+    }
+    else
+    {
+        HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC1) =
+            ulFaultTriggers;
+    }
+}
+
+//*****************************************************************************
+//
+//! Returns the set of fault triggers currently configured for a given PWM
+//! generator.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator whose fault triggers are being queried.
+//! Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.
+//! \param ulGroup indicates the subset of faults that are being queried.  This
+//! must be \b PWM_FAULT_GROUP_0.
+//!
+//! This function allows an application to query the current set of inputs that
+//! contribute towards the generation of a fault condition to a given PWM
+//! generator.
+//!
+//! \note This function is only available on devices supporting extended PWM
+//! fault handling.
+//!
+//! \return Returns the current fault triggers configured for the fault group
+//! provided.  For \b PWM_FAULT_GROUP_0, the returned value will be a logical
+//! OR of \b PWM_FAULT_FAULT0, \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or
+//! \b PWM_FAULT_FAULT3.
+//
+//*****************************************************************************
+unsigned long
+PWMGenFaultTriggerGet(unsigned long ulBase, unsigned long ulGen,
+                      unsigned long ulGroup)
+{
+    //
+    // Check for valid parameters.
+    //
+    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
+
+    //
+    // Return the current fault triggers.
+    //
+    if(ulGroup == PWM_FAULT_GROUP_0)
+    {
+        return(HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC0));
+    }
+    else
+    {
+        return(HWREG(PWM_GEN_BADDR(ulBase, ulGen) + PWM_O_X_FLTSRC1));
+    }
+}
+
+//*****************************************************************************
+//
+//! Returns the current state of the fault triggers for a given PWM generator.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator whose fault trigger states are being
+//! queried.  Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or
+//! \b PWM_GEN_3.
+//! \param ulGroup indicates the subset of faults that are being queried.  This
+//! must be \b PWM_FAULT_GROUP_0.
+//!
+//! This function allows an application to query the current state of each of
+//! the fault trigger inputs to a given PWM generator.  The current state of
+//! each fault trigger input is returned unless PWMGenConfigure() has
+//! previously been called with flag \b PWM_GEN_MODE_LATCH_FAULT in the
+//! \e ulConfig parameter in which case the returned status is the latched
+//! fault trigger status.
+//!
+//! If latched faults are configured, the application must call
+//! PWMGenFaultClear() to clear each trigger.
+//!
+//! \note This function is only available on devices supporting extended PWM
+//! fault handling.
+//!
+//! \return Returns the current state of the fault triggers for the given PWM
+//! generator.  A set bit indicates that the associated trigger is active.  For
+//! \b PWM_FAULT_GROUP_0, the returned value will be a logical OR of
+//! \b PWM_FAULT_FAULT0, \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or
+//! \b PWM_FAULT_FAULT3.
+//
+//*****************************************************************************
+unsigned long
+PWMGenFaultStatus(unsigned long ulBase, unsigned long ulGen,
+                  unsigned long ulGroup)
+{
+    //
+    // Check for valid parameters.
+    //
+    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
+
+    //
+    // Return the current fault status.
+    //
+    if(ulGroup == PWM_FAULT_GROUP_0)
+    {
+        return(HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT0));
+    }
+    else
+    {
+        return(HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT1));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears one or more latched fault triggers for a given PWM generator.
+//!
+//! \param ulBase is the base address of the PWM module.
+//! \param ulGen is the PWM generator whose fault trigger states are being
+//! queried.  Must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or
+//! \b PWM_GEN_3.
+//! \param ulGroup indicates the subset of faults that are being queried.  This
+//! must be \b PWM_FAULT_GROUP_0.
+//! \param ulFaultTriggers is the set of fault triggers which are to be
+//! cleared.
+//!
+//! This function allows an application to clear the fault triggers for a given
+//! PWM generator.  This is only required if PWMGenConfigure() has previously
+//! been called with flag \b PWM_GEN_MODE_LATCH_FAULT in parameter \e ulConfig.
+//!
+//! \note This function is only available on devices supporting extended PWM
+//! fault handling.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+PWMGenFaultClear(unsigned long ulBase, unsigned long ulGen,
+                 unsigned long ulGroup, unsigned long ulFaultTriggers)
+{
+    //
+    // Check for valid parameters.
+    //
+    ASSERT(HWREG(SYSCTL_DC5) &amp; SYSCTL_DC5_PWMEFLT);
+    ASSERT(ulBase == PWM_BASE);
+    ASSERT(PWMGenValid(ulGen));
+    ASSERT((ulGroup == PWM_FAULT_GROUP_0) || (ulGroup == PWM_FAULT_GROUP_1));
+    ASSERT((ulFaultTriggers &amp; ~(PWM_FAULT_FAULT0 | PWM_FAULT_FAULT1 |
+                                PWM_FAULT_FAULT2 | PWM_FAULT_FAULT3)) == 0);
+
+    //
+    // Clear the given faults.
+    //
+    if(ulGroup == PWM_FAULT_GROUP_0)
+    {
+        HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT0) =
+            ulFaultTriggers;
+    }
+    else
+    {
+        HWREG(PWM_GEN_EXT_BADDR(ulBase, ulGen) + PWM_O_X_FLTSTAT1) =
+            ulFaultTriggers;
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/pwm.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/pwm.h
===================================================================
--- trunk/src/platform/lm3s/pwm.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/pwm.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,269 +1,277 @@
-//*****************************************************************************
-//
-// pwm.h - API function protoypes for Pulse Width Modulation (PWM) ports
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __PWM_H__
-#define __PWM_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// The following defines are passed to PWMGenConfigure() as the ulConfig
-// parameter and specify the configuration of the PWM generator.
-//
-//*****************************************************************************
-#define PWM_GEN_MODE_DOWN       0x00000000  // Down count mode
-#define PWM_GEN_MODE_UP_DOWN    0x00000002  // Up/Down count mode
-#define PWM_GEN_MODE_SYNC       0x00000038  // Synchronous updates
-#define PWM_GEN_MODE_NO_SYNC    0x00000000  // Immediate updates
-#define PWM_GEN_MODE_DBG_RUN    0x00000004  // Continue running in debug mode
-#define PWM_GEN_MODE_DBG_STOP   0x00000000  // Stop running in debug mode
-#define PWM_GEN_MODE_FAULT_LATCHED \
-                                0x00040000  // Fault is latched
-#define PWM_GEN_MODE_FAULT_UNLATCHED \
-                                0x00000000  // Fault is not latched
-#define PWM_GEN_MODE_FAULT_MINPER \
-                                0x00020000  // Enable min fault period
-#define PWM_GEN_MODE_FAULT_NO_MINPER \
-                                0x00000000  // Disable min fault period
-#define PWM_GEN_MODE_FAULT_EXT  0x00010000  // Enable extended fault support
-#define PWM_GEN_MODE_FAULT_LEGACY \
-                                0x00000000  // Disable extended fault support
-#define PWM_GEN_MODE_DB_NO_SYNC 0x00000000  // Deadband updates occur
-                                            // immediately
-#define PWM_GEN_MODE_DB_SYNC_LOCAL \
-                                0x0000A800  // Deadband updates locally
-                                            // synchronized
-#define PWM_GEN_MODE_DB_SYNC_GLOBAL \
-                                0x0000FC00  // Deadband updates globally
-                                            // synchronized
-#define PWM_GEN_MODE_GEN_NO_SYNC \
-                                0x00000000  // Generator mode updates occur
-                                            // immediately
-#define PWM_GEN_MODE_GEN_SYNC_LOCAL \
-                                0x00000280  // Generator mode updates locally
-                                            // synchronized
-#define PWM_GEN_MODE_GEN_SYNC_GLOBAL \
-                                0x000003C0  // Generator mode updates globally
-                                            // synchronized
-
-//*****************************************************************************
-//
-// Defines for enabling, disabling, and clearing PWM generator interrupts and
-// triggers.
-//
-//*****************************************************************************
-#define PWM_INT_CNT_ZERO        0x00000001  // Int if COUNT = 0
-#define PWM_INT_CNT_LOAD        0x00000002  // Int if COUNT = LOAD
-#define PWM_INT_CNT_AU          0x00000004  // Int if COUNT = CMPA U
-#define PWM_INT_CNT_AD          0x00000008  // Int if COUNT = CMPA D
-#define PWM_INT_CNT_BU          0x00000010  // Int if COUNT = CMPA U
-#define PWM_INT_CNT_BD          0x00000020  // Int if COUNT = CMPA D
-#define PWM_TR_CNT_ZERO         0x00000100  // Trig if COUNT = 0
-#define PWM_TR_CNT_LOAD         0x00000200  // Trig if COUNT = LOAD
-#define PWM_TR_CNT_AU           0x00000400  // Trig if COUNT = CMPA U
-#define PWM_TR_CNT_AD           0x00000800  // Trig if COUNT = CMPA D
-#define PWM_TR_CNT_BU           0x00001000  // Trig if COUNT = CMPA U
-#define PWM_TR_CNT_BD           0x00002000  // Trig if COUNT = CMPA D
-
-//*****************************************************************************
-//
-// Defines for enabling, disabling, and clearing PWM interrupts.
-//
-//*****************************************************************************
-#define PWM_INT_GEN_0           0x00000001  // Generator 0 interrupt
-#define PWM_INT_GEN_1           0x00000002  // Generator 1 interrupt
-#define PWM_INT_GEN_2           0x00000004  // Generator 2 interrupt
-#define PWM_INT_GEN_3           0x00000008  // Generator 3 interrupt
-#ifndef DEPRECATED
-#define PWM_INT_FAULT           0x00010000  // Fault interrupt
-#endif
-#define PWM_INT_FAULT0          0x00010000  // Fault0 interrupt
-#define PWM_INT_FAULT1          0x00020000  // Fault1 interrupt
-#define PWM_INT_FAULT2          0x00040000  // Fault2 interrupt
-#define PWM_INT_FAULT3          0x00080000  // Fault3 interrupt
-#define PWM_INT_FAULT_M         0x000F0000  // Fault interrupt source mask
-
-//*****************************************************************************
-//
-// Defines to identify the generators within a module.
-//
-//*****************************************************************************
-#define PWM_GEN_0               0x00000040  // Offset address of Gen0
-#define PWM_GEN_1               0x00000080  // Offset address of Gen1
-#define PWM_GEN_2               0x000000C0  // Offset address of Gen2
-#define PWM_GEN_3               0x00000100  // Offset address of Gen3
-
-#define PWM_GEN_0_BIT           0x00000001  // Bit-wise ID for Gen0
-#define PWM_GEN_1_BIT           0x00000002  // Bit-wise ID for Gen1
-#define PWM_GEN_2_BIT           0x00000004  // Bit-wise ID for Gen2
-#define PWM_GEN_3_BIT           0x00000008  // Bit-wise ID for Gen3
-
-#define PWM_GEN_EXT_0           0x00000800  // Offset of Gen0 ext address range
-#define PWM_GEN_EXT_1           0x00000880  // Offset of Gen1 ext address range
-#define PWM_GEN_EXT_2           0x00000900  // Offset of Gen2 ext address range
-#define PWM_GEN_EXT_3           0x00000980  // Offset of Gen3 ext address range
-
-//*****************************************************************************
-//
-// Defines to identify the outputs within a module.
-//
-//*****************************************************************************
-#define PWM_OUT_0               0x00000040  // Encoded offset address of PWM0
-#define PWM_OUT_1               0x00000041  // Encoded offset address of PWM1
-#define PWM_OUT_2               0x00000082  // Encoded offset address of PWM2
-#define PWM_OUT_3               0x00000083  // Encoded offset address of PWM3
-#define PWM_OUT_4               0x000000C4  // Encoded offset address of PWM4
-#define PWM_OUT_5               0x000000C5  // Encoded offset address of PWM5
-#define PWM_OUT_6               0x00000106  // Encoded offset address of PWM6
-#define PWM_OUT_7               0x00000107  // Encoded offset address of PWM7
-
-#define PWM_OUT_0_BIT           0x00000001  // Bit-wise ID for PWM0
-#define PWM_OUT_1_BIT           0x00000002  // Bit-wise ID for PWM1
-#define PWM_OUT_2_BIT           0x00000004  // Bit-wise ID for PWM2
-#define PWM_OUT_3_BIT           0x00000008  // Bit-wise ID for PWM3
-#define PWM_OUT_4_BIT           0x00000010  // Bit-wise ID for PWM4
-#define PWM_OUT_5_BIT           0x00000020  // Bit-wise ID for PWM5
-#define PWM_OUT_6_BIT           0x00000040  // Bit-wise ID for PWM6
-#define PWM_OUT_7_BIT           0x00000080  // Bit-wise ID for PWM7
-
-//*****************************************************************************
-//
-// Defines to identify each of the possible fault trigger conditions in
-// PWM_FAULT_GROUP_0
-//
-//*****************************************************************************
-#define PWM_FAULT_GROUP_0       0
-
-#define PWM_FAULT_FAULT0        0x00000001
-#define PWM_FAULT_FAULT1        0x00000002
-#define PWM_FAULT_FAULT2        0x00000004
-#define PWM_FAULT_FAULT3        0x00000008
-#define PWM_FAULT_ACMP0         0x00010000
-#define PWM_FAULT_ACMP1         0x00020000
-#define PWM_FAULT_ACMP2         0x00040000
-
-//*****************************************************************************
-//
-// Defines to identify the sense of each of the external FAULTn signals
-//
-//*****************************************************************************
-#define PWM_FAULT0_SENSE_HIGH   0x00000000
-#define PWM_FAULT0_SENSE_LOW    0x00000001
-#define PWM_FAULT1_SENSE_HIGH   0x00000000
-#define PWM_FAULT1_SENSE_LOW    0x00000002
-#define PWM_FAULT2_SENSE_HIGH   0x00000000
-#define PWM_FAULT2_SENSE_LOW    0x00000004
-#define PWM_FAULT3_SENSE_HIGH   0x00000000
-#define PWM_FAULT3_SENSE_LOW    0x00000008
-
-//*****************************************************************************
-//
-// API Function prototypes
-//
-//*****************************************************************************
-extern void PWMGenConfigure(unsigned long ulBase, unsigned long ulGen,
-                            unsigned long ulConfig);
-extern void PWMGenPeriodSet(unsigned long ulBase, unsigned long ulGen,
-                            unsigned long ulPeriod);
-extern unsigned long PWMGenPeriodGet(unsigned long ulBase,
-                                     unsigned long ulGen);
-extern void PWMGenEnable(unsigned long ulBase, unsigned long ulGen);
-extern void PWMGenDisable(unsigned long ulBase, unsigned long ulGen);
-extern void PWMPulseWidthSet(unsigned long ulBase, unsigned long ulPWMOut,
-                             unsigned long ulWidth);
-extern unsigned long PWMPulseWidthGet(unsigned long ulBase,
-                                      unsigned long ulPWMOut);
-extern void PWMDeadBandEnable(unsigned long ulBase, unsigned long ulGen,
-                              unsigned short usRise, unsigned short usFall);
-extern void PWMDeadBandDisable(unsigned long ulBase, unsigned long ulGen);
-extern void PWMSyncUpdate(unsigned long ulBase, unsigned long ulGenBits);
-extern void PWMSyncTimeBase(unsigned long ulBase, unsigned long ulGenBits);
-extern void PWMOutputState(unsigned long ulBase, unsigned long ulPWMOutBits,
-                           tBoolean bEnable);
-extern void PWMOutputInvert(unsigned long ulBase, unsigned long ulPWMOutBits,
-                            tBoolean bInvert);
-extern void PWMOutputFaultLevel(unsigned long ulBase,
-                                unsigned long ulPWMOutBits,
-                                tBoolean bDriveHigh);
-extern void PWMOutputFault(unsigned long ulBase, unsigned long ulPWMOutBits,
-                           tBoolean bFaultSuppress);
-extern void PWMGenIntRegister(unsigned long ulBase, unsigned long ulGen,
-                              void (*pfnIntHandler)(void));
-extern void PWMGenIntUnregister(unsigned long ulBase, unsigned long ulGen);
-extern void PWMFaultIntRegister(unsigned long ulBase,
-                                void (*pfnIntHandler)(void));
-extern void PWMFaultIntUnregister(unsigned long ulBase);
-extern void PWMGenIntTrigEnable(unsigned long ulBase, unsigned long ulGen,
-                                unsigned long ulIntTrig);
-extern void PWMGenIntTrigDisable(unsigned long ulBase, unsigned long ulGen,
-                                 unsigned long ulIntTrig);
-extern unsigned long PWMGenIntStatus(unsigned long ulBase, unsigned long ulGen,
-                                     tBoolean bMasked);
-extern void PWMGenIntClear(unsigned long ulBase, unsigned long ulGen,
-                           unsigned long ulInts);
-extern void PWMIntEnable(unsigned long ulBase, unsigned long ulGenFault);
-extern void PWMIntDisable(unsigned long ulBase, unsigned long ulGenFault);
-extern void PWMFaultIntClear(unsigned long ulBase);
-extern unsigned long PWMIntStatus(unsigned long ulBase, tBoolean bMasked);
-extern void PWMFaultIntClearExt(unsigned long ulBase,
-                                unsigned long ulFaultInts);
-extern void PWMGenFaultConfigure(unsigned long ulBase, unsigned long ulGen,
-                                 unsigned long ulMinFaultPeriod,
-                                 unsigned long ulFaultSenses);
-extern void PWMGenFaultTriggerSet(unsigned long ulBase, unsigned long ulGen,
-                                  unsigned long ulGroup,
-                                  unsigned long ulFaultTriggers);
-extern unsigned long PWMGenFaultTriggerGet(unsigned long ulBase,
-                                           unsigned long ulGen,
-                                           unsigned long ulGroup);
-extern unsigned long PWMGenFaultStatus(unsigned long ulBase,
-                                       unsigned long ulGen,
-                                       unsigned long ulGroup);
-extern void PWMGenFaultClear(unsigned long ulBase, unsigned long ulGen,
-                             unsigned long ulGroup,
-                             unsigned long ulFaultTriggers);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __PWM_H__
+//*****************************************************************************
+//
+// pwm.h - API function protoypes for Pulse Width Modulation (PWM) ports
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __PWM_H__
+#define __PWM_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// The following defines are passed to PWMGenConfigure() as the ulConfig
+// parameter and specify the configuration of the PWM generator.
+//
+//*****************************************************************************
+#define PWM_GEN_MODE_DOWN       0x00000000  // Down count mode
+#define PWM_GEN_MODE_UP_DOWN    0x00000002  // Up/Down count mode
+#define PWM_GEN_MODE_SYNC       0x00000038  // Synchronous updates
+#define PWM_GEN_MODE_NO_SYNC    0x00000000  // Immediate updates
+#define PWM_GEN_MODE_DBG_RUN    0x00000004  // Continue running in debug mode
+#define PWM_GEN_MODE_DBG_STOP   0x00000000  // Stop running in debug mode
+#define PWM_GEN_MODE_FAULT_LATCHED \
+                                0x00040000  // Fault is latched
+#define PWM_GEN_MODE_FAULT_UNLATCHED \
+                                0x00000000  // Fault is not latched
+#define PWM_GEN_MODE_FAULT_MINPER \
+                                0x00020000  // Enable min fault period
+#define PWM_GEN_MODE_FAULT_NO_MINPER \
+                                0x00000000  // Disable min fault period
+#define PWM_GEN_MODE_FAULT_EXT  0x00010000  // Enable extended fault support
+#define PWM_GEN_MODE_FAULT_LEGACY \
+                                0x00000000  // Disable extended fault support
+#define PWM_GEN_MODE_DB_NO_SYNC 0x00000000  // Deadband updates occur
+                                            // immediately
+#define PWM_GEN_MODE_DB_SYNC_LOCAL \
+                                0x0000A800  // Deadband updates locally
+                                            // synchronized
+#define PWM_GEN_MODE_DB_SYNC_GLOBAL \
+                                0x0000FC00  // Deadband updates globally
+                                            // synchronized
+#define PWM_GEN_MODE_GEN_NO_SYNC \
+                                0x00000000  // Generator mode updates occur
+                                            // immediately
+#define PWM_GEN_MODE_GEN_SYNC_LOCAL \
+                                0x00000280  // Generator mode updates locally
+                                            // synchronized
+#define PWM_GEN_MODE_GEN_SYNC_GLOBAL \
+                                0x000003C0  // Generator mode updates globally
+                                            // synchronized
+
+//*****************************************************************************
+//
+// Defines for enabling, disabling, and clearing PWM generator interrupts and
+// triggers.
+//
+//*****************************************************************************
+#define PWM_INT_CNT_ZERO        0x00000001  // Int if COUNT = 0
+#define PWM_INT_CNT_LOAD        0x00000002  // Int if COUNT = LOAD
+#define PWM_INT_CNT_AU          0x00000004  // Int if COUNT = CMPA U
+#define PWM_INT_CNT_AD          0x00000008  // Int if COUNT = CMPA D
+#define PWM_INT_CNT_BU          0x00000010  // Int if COUNT = CMPA U
+#define PWM_INT_CNT_BD          0x00000020  // Int if COUNT = CMPA D
+#define PWM_TR_CNT_ZERO         0x00000100  // Trig if COUNT = 0
+#define PWM_TR_CNT_LOAD         0x00000200  // Trig if COUNT = LOAD
+#define PWM_TR_CNT_AU           0x00000400  // Trig if COUNT = CMPA U
+#define PWM_TR_CNT_AD           0x00000800  // Trig if COUNT = CMPA D
+#define PWM_TR_CNT_BU           0x00001000  // Trig if COUNT = CMPA U
+#define PWM_TR_CNT_BD           0x00002000  // Trig if COUNT = CMPA D
+
+//*****************************************************************************
+//
+// Defines for enabling, disabling, and clearing PWM interrupts.
+//
+//*****************************************************************************
+#define PWM_INT_GEN_0           0x00000001  // Generator 0 interrupt
+#define PWM_INT_GEN_1           0x00000002  // Generator 1 interrupt
+#define PWM_INT_GEN_2           0x00000004  // Generator 2 interrupt
+#define PWM_INT_GEN_3           0x00000008  // Generator 3 interrupt
+#ifndef DEPRECATED
+#define PWM_INT_FAULT           0x00010000  // Fault interrupt
+#endif
+#define PWM_INT_FAULT0          0x00010000  // Fault0 interrupt
+#define PWM_INT_FAULT1          0x00020000  // Fault1 interrupt
+#define PWM_INT_FAULT2          0x00040000  // Fault2 interrupt
+#define PWM_INT_FAULT3          0x00080000  // Fault3 interrupt
+#define PWM_INT_FAULT_M         0x000F0000  // Fault interrupt source mask
+
+//*****************************************************************************
+//
+// Defines to identify the generators within a module.
+//
+//*****************************************************************************
+#define PWM_GEN_0               0x00000040  // Offset address of Gen0
+#define PWM_GEN_1               0x00000080  // Offset address of Gen1
+#define PWM_GEN_2               0x000000C0  // Offset address of Gen2
+#define PWM_GEN_3               0x00000100  // Offset address of Gen3
+
+#define PWM_GEN_0_BIT           0x00000001  // Bit-wise ID for Gen0
+#define PWM_GEN_1_BIT           0x00000002  // Bit-wise ID for Gen1
+#define PWM_GEN_2_BIT           0x00000004  // Bit-wise ID for Gen2
+#define PWM_GEN_3_BIT           0x00000008  // Bit-wise ID for Gen3
+
+#define PWM_GEN_EXT_0           0x00000800  // Offset of Gen0 ext address range
+#define PWM_GEN_EXT_1           0x00000880  // Offset of Gen1 ext address range
+#define PWM_GEN_EXT_2           0x00000900  // Offset of Gen2 ext address range
+#define PWM_GEN_EXT_3           0x00000980  // Offset of Gen3 ext address range
+
+//*****************************************************************************
+//
+// Defines to identify the outputs within a module.
+//
+//*****************************************************************************
+#define PWM_OUT_0               0x00000040  // Encoded offset address of PWM0
+#define PWM_OUT_1               0x00000041  // Encoded offset address of PWM1
+#define PWM_OUT_2               0x00000082  // Encoded offset address of PWM2
+#define PWM_OUT_3               0x00000083  // Encoded offset address of PWM3
+#define PWM_OUT_4               0x000000C4  // Encoded offset address of PWM4
+#define PWM_OUT_5               0x000000C5  // Encoded offset address of PWM5
+#define PWM_OUT_6               0x00000106  // Encoded offset address of PWM6
+#define PWM_OUT_7               0x00000107  // Encoded offset address of PWM7
+
+#define PWM_OUT_0_BIT           0x00000001  // Bit-wise ID for PWM0
+#define PWM_OUT_1_BIT           0x00000002  // Bit-wise ID for PWM1
+#define PWM_OUT_2_BIT           0x00000004  // Bit-wise ID for PWM2
+#define PWM_OUT_3_BIT           0x00000008  // Bit-wise ID for PWM3
+#define PWM_OUT_4_BIT           0x00000010  // Bit-wise ID for PWM4
+#define PWM_OUT_5_BIT           0x00000020  // Bit-wise ID for PWM5
+#define PWM_OUT_6_BIT           0x00000040  // Bit-wise ID for PWM6
+#define PWM_OUT_7_BIT           0x00000080  // Bit-wise ID for PWM7
+
+//*****************************************************************************
+//
+// Defines to identify each of the possible fault trigger conditions in
+// PWM_FAULT_GROUP_0.
+//
+//*****************************************************************************
+#define PWM_FAULT_GROUP_0       0
+
+#define PWM_FAULT_FAULT0        0x00000001
+#define PWM_FAULT_FAULT1        0x00000002
+#define PWM_FAULT_FAULT2        0x00000004
+#define PWM_FAULT_FAULT3        0x00000008
+#define PWM_FAULT_ACMP0         0x00010000
+#define PWM_FAULT_ACMP1         0x00020000
+#define PWM_FAULT_ACMP2         0x00040000
+
+//*****************************************************************************
+//
+// Defines to identify each of the possible fault trigger conditions in
+// PWM_FAULT_GROUP_1.
+//
+//*****************************************************************************
+#define PWM_FAULT_GROUP_1       1
+
+//*****************************************************************************
+//
+// Defines to identify the sense of each of the external FAULTn signals
+//
+//*****************************************************************************
+#define PWM_FAULT0_SENSE_HIGH   0x00000000
+#define PWM_FAULT0_SENSE_LOW    0x00000001
+#define PWM_FAULT1_SENSE_HIGH   0x00000000
+#define PWM_FAULT1_SENSE_LOW    0x00000002
+#define PWM_FAULT2_SENSE_HIGH   0x00000000
+#define PWM_FAULT2_SENSE_LOW    0x00000004
+#define PWM_FAULT3_SENSE_HIGH   0x00000000
+#define PWM_FAULT3_SENSE_LOW    0x00000008
+
+//*****************************************************************************
+//
+// API Function prototypes
+//
+//*****************************************************************************
+extern void PWMGenConfigure(unsigned long ulBase, unsigned long ulGen,
+                            unsigned long ulConfig);
+extern void PWMGenPeriodSet(unsigned long ulBase, unsigned long ulGen,
+                            unsigned long ulPeriod);
+extern unsigned long PWMGenPeriodGet(unsigned long ulBase,
+                                     unsigned long ulGen);
+extern void PWMGenEnable(unsigned long ulBase, unsigned long ulGen);
+extern void PWMGenDisable(unsigned long ulBase, unsigned long ulGen);
+extern void PWMPulseWidthSet(unsigned long ulBase, unsigned long ulPWMOut,
+                             unsigned long ulWidth);
+extern unsigned long PWMPulseWidthGet(unsigned long ulBase,
+                                      unsigned long ulPWMOut);
+extern void PWMDeadBandEnable(unsigned long ulBase, unsigned long ulGen,
+                              unsigned short usRise, unsigned short usFall);
+extern void PWMDeadBandDisable(unsigned long ulBase, unsigned long ulGen);
+extern void PWMSyncUpdate(unsigned long ulBase, unsigned long ulGenBits);
+extern void PWMSyncTimeBase(unsigned long ulBase, unsigned long ulGenBits);
+extern void PWMOutputState(unsigned long ulBase, unsigned long ulPWMOutBits,
+                           tBoolean bEnable);
+extern void PWMOutputInvert(unsigned long ulBase, unsigned long ulPWMOutBits,
+                            tBoolean bInvert);
+extern void PWMOutputFaultLevel(unsigned long ulBase,
+                                unsigned long ulPWMOutBits,
+                                tBoolean bDriveHigh);
+extern void PWMOutputFault(unsigned long ulBase, unsigned long ulPWMOutBits,
+                           tBoolean bFaultSuppress);
+extern void PWMGenIntRegister(unsigned long ulBase, unsigned long ulGen,
+                              void (*pfnIntHandler)(void));
+extern void PWMGenIntUnregister(unsigned long ulBase, unsigned long ulGen);
+extern void PWMFaultIntRegister(unsigned long ulBase,
+                                void (*pfnIntHandler)(void));
+extern void PWMFaultIntUnregister(unsigned long ulBase);
+extern void PWMGenIntTrigEnable(unsigned long ulBase, unsigned long ulGen,
+                                unsigned long ulIntTrig);
+extern void PWMGenIntTrigDisable(unsigned long ulBase, unsigned long ulGen,
+                                 unsigned long ulIntTrig);
+extern unsigned long PWMGenIntStatus(unsigned long ulBase, unsigned long ulGen,
+                                     tBoolean bMasked);
+extern void PWMGenIntClear(unsigned long ulBase, unsigned long ulGen,
+                           unsigned long ulInts);
+extern void PWMIntEnable(unsigned long ulBase, unsigned long ulGenFault);
+extern void PWMIntDisable(unsigned long ulBase, unsigned long ulGenFault);
+extern void PWMFaultIntClear(unsigned long ulBase);
+extern unsigned long PWMIntStatus(unsigned long ulBase, tBoolean bMasked);
+extern void PWMFaultIntClearExt(unsigned long ulBase,
+                                unsigned long ulFaultInts);
+extern void PWMGenFaultConfigure(unsigned long ulBase, unsigned long ulGen,
+                                 unsigned long ulMinFaultPeriod,
+                                 unsigned long ulFaultSenses);
+extern void PWMGenFaultTriggerSet(unsigned long ulBase, unsigned long ulGen,
+                                  unsigned long ulGroup,
+                                  unsigned long ulFaultTriggers);
+extern unsigned long PWMGenFaultTriggerGet(unsigned long ulBase,
+                                           unsigned long ulGen,
+                                           unsigned long ulGroup);
+extern unsigned long PWMGenFaultStatus(unsigned long ulBase,
+                                       unsigned long ulGen,
+                                       unsigned long ulGroup);
+extern void PWMGenFaultClear(unsigned long ulBase, unsigned long ulGen,
+                             unsigned long ulGroup,
+                             unsigned long ulFaultTriggers);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __PWM_H__


Property changes on: trunk/src/platform/lm3s/pwm.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/rom.h
===================================================================
--- trunk/src/platform/lm3s/rom.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/rom.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,2252 @@
+//*****************************************************************************
+//
+// rom.h - Macros to facilitate calling functions in the ROM.
+//
+// Copyright (c) 2007-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __ROM_H__
+#define __ROM_H__
+
+//*****************************************************************************
+//
+// Pointers to the main API tables.
+//
+//*****************************************************************************
+#define ROM_APITABLE            ((unsigned long *)0x01000010)
+#define ROM_VERSION             (ROM_APITABLE[0])
+#define ROM_UARTTABLE           ((unsigned long *)(ROM_APITABLE[1]))
+#define ROM_SSITABLE            ((unsigned long *)(ROM_APITABLE[2]))
+#define ROM_I2CTABLE            ((unsigned long *)(ROM_APITABLE[3]))
+#define ROM_GPIOTABLE           ((unsigned long *)(ROM_APITABLE[4]))
+#define ROM_ADCTABLE            ((unsigned long *)(ROM_APITABLE[5]))
+#define ROM_COMPARATORTABLE     ((unsigned long *)(ROM_APITABLE[6]))
+#define ROM_FLASHTABLE          ((unsigned long *)(ROM_APITABLE[7]))
+#define ROM_PWMTABLE            ((unsigned long *)(ROM_APITABLE[8]))
+#define ROM_QEITABLE            ((unsigned long *)(ROM_APITABLE[9]))
+#define ROM_SYSTICKTABLE        ((unsigned long *)(ROM_APITABLE[10]))
+#define ROM_TIMERTABLE          ((unsigned long *)(ROM_APITABLE[11]))
+#define ROM_WATCHDOGTABLE       ((unsigned long *)(ROM_APITABLE[12]))
+#define ROM_SYSCTLTABLE         ((unsigned long *)(ROM_APITABLE[13]))
+#define ROM_INTERRUPTTABLE      ((unsigned long *)(ROM_APITABLE[14]))
+#define ROM_ETHERNETTABLE       ((unsigned long *)(ROM_APITABLE[15]))
+#define ROM_USBTABLE            ((unsigned long *)(ROM_APITABLE[16]))
+#define ROM_UDMATABLE           ((unsigned long *)(ROM_APITABLE[17]))
+#define ROM_CANTABLE            ((unsigned long *)(ROM_APITABLE[18]))
+#define ROM_HIBERNATETABLE      ((unsigned long *)(ROM_APITABLE[19]))
+#define ROM_MPUTABLE            ((unsigned long *)(ROM_APITABLE[20]))
+#define ROM_SOFTWARETABLE       ((unsigned long *)(ROM_APITABLE[21]))
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the ADC API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceDataGet                                                \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum,                               \
+                   unsigned long *pulBuffer))ROM_ADCTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCIntDisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCIntEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCIntStatus                                                      \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulSequenceNum,                      \
+                            tBoolean bMasked))ROM_ADCTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCIntClear                                                       \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceEnable                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceDisable                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceConfigure                                              \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum,                               \
+                   unsigned long ulTrigger,                                   \
+                   unsigned long ulPriority))ROM_ADCTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceStepConfigure                                          \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum,                               \
+                   unsigned long ulStep,                                      \
+                   unsigned long ulConfig))ROM_ADCTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceOverflow                                               \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceOverflowClear                                          \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceUnderflow                                              \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCSequenceUnderflowClear                                         \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCProcessorTrigger                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSequenceNum))ROM_ADCTABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ADCHardwareOversampleConfigure                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulFactor))ROM_ADCTABLE[14])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the CAN API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANIntClear                                                       \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntClr))ROM_CANTABLE[0])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANInit                                                           \
+        ((void (*)(unsigned long ulBase))ROM_CANTABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANEnable                                                         \
+        ((void (*)(unsigned long ulBase))ROM_CANTABLE[2])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANDisable                                                        \
+        ((void (*)(unsigned long ulBase))ROM_CANTABLE[3])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANBitTimingSet                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   tCANBitClkParms *pClkParms))ROM_CANTABLE[4])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANBitTimingGet                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   tCANBitClkParms *pClkParms))ROM_CANTABLE[5])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANMessageSet                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulObjID,                                     \
+                   tCANMsgObject *pMsgObject,                                 \
+                   tMsgObjType eMsgType))ROM_CANTABLE[6])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANMessageGet                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulObjID,                                     \
+                   tCANMsgObject *pMsgObject,                                 \
+                   tBoolean bClrPendingInt))ROM_CANTABLE[7])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANStatusGet                                                      \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tCANStsReg eStatusReg))ROM_CANTABLE[8])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANMessageClear                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulObjID))ROM_CANTABLE[9])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANIntEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_CANTABLE[10])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANIntDisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_CANTABLE[11])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANIntStatus                                                      \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tCANIntStsReg eIntStsReg))ROM_CANTABLE[12])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANRetryGet                                                       \
+        ((tBoolean (*)(unsigned long ulBase))ROM_CANTABLE[13])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANRetrySet                                                       \
+        ((void (*)(unsigned long ulBase,                                      \
+                   tBoolean bAutoRetry))ROM_CANTABLE[14])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_CANErrCntrGet                                                     \
+        ((tBoolean (*)(unsigned long ulBase,                                  \
+                       unsigned long *pulRxCount,                             \
+                       unsigned long *pulTxCount))ROM_CANTABLE[15])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Comparator API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ComparatorIntClear                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulComp))ROM_COMPARATORTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ComparatorConfigure                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulComp,                                      \
+                   unsigned long ulConfig))ROM_COMPARATORTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ComparatorRefSet                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulRef))ROM_COMPARATORTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ComparatorValueGet                                                \
+        ((tBoolean (*)(unsigned long ulBase,                                  \
+                       unsigned long ulComp))ROM_COMPARATORTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ComparatorIntEnable                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulComp))ROM_COMPARATORTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ComparatorIntDisable                                              \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulComp))ROM_COMPARATORTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_ComparatorIntStatus                                               \
+        ((tBoolean (*)(unsigned long ulBase,                                  \
+                       unsigned long ulComp,                                  \
+                       tBoolean bMasked))ROM_COMPARATORTABLE[6])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Ethernet API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetIntClear                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_ETHERNETTABLE[0])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetInitExpClk                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEthClk))ROM_ETHERNETTABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetConfigSet                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulConfig))ROM_ETHERNETTABLE[2])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetConfigGet                                                 \
+        ((unsigned long (*)(unsigned long ulBase))ROM_ETHERNETTABLE[3])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetMACAddrSet                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char *pucMACAddr))ROM_ETHERNETTABLE[4])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetMACAddrGet                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char *pucMACAddr))ROM_ETHERNETTABLE[5])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetEnable                                                    \
+        ((void (*)(unsigned long ulBase))ROM_ETHERNETTABLE[6])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetDisable                                                   \
+        ((void (*)(unsigned long ulBase))ROM_ETHERNETTABLE[7])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetPacketAvail                                               \
+        ((tBoolean (*)(unsigned long ulBase))ROM_ETHERNETTABLE[8])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetSpaceAvail                                                \
+        ((tBoolean (*)(unsigned long ulBase))ROM_ETHERNETTABLE[9])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetPacketGetNonBlocking                                      \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned char *pucBuf,                                     \
+                   long lBufLen))ROM_ETHERNETTABLE[10])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetPacketGet                                                 \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned char *pucBuf,                                     \
+                   long lBufLen))ROM_ETHERNETTABLE[11])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetPacketPutNonBlocking                                      \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned char *pucBuf,                                     \
+                   long lBufLen))ROM_ETHERNETTABLE[12])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetPacketPut                                                 \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned char *pucBuf,                                     \
+                   long lBufLen))ROM_ETHERNETTABLE[13])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetIntEnable                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_ETHERNETTABLE[14])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetIntDisable                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_ETHERNETTABLE[15])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetIntStatus                                                 \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tBoolean bMasked))ROM_ETHERNETTABLE[16])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetPHYWrite                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char ucRegAddr,                                   \
+                   unsigned long ulData))ROM_ETHERNETTABLE[17])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_EthernetPHYRead                                                   \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned char ucRegAddr))ROM_ETHERNETTABLE[18])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UpdateEthernet                                                    \
+        ((void (*)(unsigned long ulClock))ROM_ETHERNETTABLE[19])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Flash API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashProgram                                                      \
+        ((long (*)(unsigned long *pulData,                                    \
+                   unsigned long ulAddress,                                   \
+                   unsigned long ulCount))ROM_FLASHTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashUsecGet                                                      \
+        ((unsigned long (*)(void))ROM_FLASHTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashUsecSet                                                      \
+        ((void (*)(unsigned long ulClocks))ROM_FLASHTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashErase                                                        \
+        ((long (*)(unsigned long ulAddress))ROM_FLASHTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashProtectGet                                                   \
+        ((tFlashProtection (*)(unsigned long ulAddress))ROM_FLASHTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashProtectSet                                                   \
+        ((long (*)(unsigned long ulAddress,                                   \
+                   tFlashProtection eProtect))ROM_FLASHTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashProtectSave                                                  \
+        ((long (*)(void))ROM_FLASHTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashUserGet                                                      \
+        ((long (*)(unsigned long *pulUser0,                                   \
+                   unsigned long *pulUser1))ROM_FLASHTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashUserSet                                                      \
+        ((long (*)(unsigned long ulUser0,                                     \
+                   unsigned long ulUser1))ROM_FLASHTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashUserSave                                                     \
+        ((long (*)(void))ROM_FLASHTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashIntEnable                                                    \
+        ((void (*)(unsigned long ulIntFlags))ROM_FLASHTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashIntDisable                                                   \
+        ((void (*)(unsigned long ulIntFlags))ROM_FLASHTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashIntGetStatus                                                 \
+        ((unsigned long (*)(tBoolean bMasked))ROM_FLASHTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_FlashIntClear                                                     \
+        ((void (*)(unsigned long ulIntFlags))ROM_FLASHTABLE[13])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the GPIO API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinWrite                                                      \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins,                                      \
+                   unsigned char ucVal))ROM_GPIOTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIODirModeSet                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins,                                      \
+                   unsigned long ulPinIO))ROM_GPIOTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIODirModeGet                                                    \
+        ((unsigned long (*)(unsigned long ulPort,                             \
+                            unsigned char ucPin))ROM_GPIOTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOIntTypeSet                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins,                                      \
+                   unsigned long ulIntType))ROM_GPIOTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOIntTypeGet                                                    \
+        ((unsigned long (*)(unsigned long ulPort,                             \
+                            unsigned char ucPin))ROM_GPIOTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPadConfigSet                                                  \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins,                                      \
+                   unsigned long ulStrength,                                  \
+                   unsigned long ulPadType))ROM_GPIOTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPadConfigGet                                                  \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPin,                                       \
+                   unsigned long *pulStrength,                                \
+                   unsigned long *pulPadType))ROM_GPIOTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinIntEnable                                                  \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinIntDisable                                                 \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinIntStatus                                                  \
+        ((long (*)(unsigned long ulPort,                                      \
+                   tBoolean bMasked))ROM_GPIOTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinIntClear                                                   \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinRead                                                       \
+        ((long (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeCAN                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeComparator                                             \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeGPIOInput                                              \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[14])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeGPIOOutput                                             \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[15])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeI2C                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[16])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypePWM                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[17])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeQEI                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[18])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeSSI                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[19])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeTimer                                                  \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[20])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeUART                                                   \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[21])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeGPIOOutputOD                                           \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[22])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeADC                                                    \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[23])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_GPIOPinTypeUSBDigital                                             \
+        ((void (*)(unsigned long ulPort,                                      \
+                   unsigned char ucPins))ROM_GPIOTABLE[24])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Hibernate API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateIntClear                                                 \
+        ((void (*)(unsigned long ulIntFlags))ROM_HIBERNATETABLE[0])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateEnableExpClk                                             \
+        ((void (*)(unsigned long ulHibClk))ROM_HIBERNATETABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateDisable                                                  \
+        ((void (*)(void))ROM_HIBERNATETABLE[2])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateClockSelect                                              \
+        ((void (*)(unsigned long ulClockInput))ROM_HIBERNATETABLE[3])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCEnable                                                \
+        ((void (*)(void))ROM_HIBERNATETABLE[4])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCDisable                                               \
+        ((void (*)(void))ROM_HIBERNATETABLE[5])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateWakeSet                                                  \
+        ((void (*)(unsigned long ulWakeFlags))ROM_HIBERNATETABLE[6])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateWakeGet                                                  \
+        ((unsigned long (*)(void))ROM_HIBERNATETABLE[7])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateLowBatSet                                                \
+        ((void (*)(unsigned long ulLowBatFlags))ROM_HIBERNATETABLE[8])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateLowBatGet                                                \
+        ((unsigned long (*)(void))ROM_HIBERNATETABLE[9])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCSet                                                   \
+        ((void (*)(unsigned long ulRTCValue))ROM_HIBERNATETABLE[10])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCGet                                                   \
+        ((unsigned long (*)(void))ROM_HIBERNATETABLE[11])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCMatch0Set                                             \
+        ((void (*)(unsigned long ulMatch))ROM_HIBERNATETABLE[12])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCMatch0Get                                             \
+        ((unsigned long (*)(void))ROM_HIBERNATETABLE[13])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCMatch1Set                                             \
+        ((void (*)(unsigned long ulMatch))ROM_HIBERNATETABLE[14])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCMatch1Get                                             \
+        ((unsigned long (*)(void))ROM_HIBERNATETABLE[15])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCTrimSet                                               \
+        ((void (*)(unsigned long ulTrim))ROM_HIBERNATETABLE[16])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRTCTrimGet                                               \
+        ((unsigned long (*)(void))ROM_HIBERNATETABLE[17])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateDataSet                                                  \
+        ((void (*)(unsigned long *pulData,                                    \
+                   unsigned long ulCount))ROM_HIBERNATETABLE[18])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateDataGet                                                  \
+        ((void (*)(unsigned long *pulData,                                    \
+                   unsigned long ulCount))ROM_HIBERNATETABLE[19])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateRequest                                                  \
+        ((void (*)(void))ROM_HIBERNATETABLE[20])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateIntEnable                                                \
+        ((void (*)(unsigned long ulIntFlags))ROM_HIBERNATETABLE[21])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateIntDisable                                               \
+        ((void (*)(unsigned long ulIntFlags))ROM_HIBERNATETABLE[22])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateIntStatus                                                \
+        ((unsigned long (*)(tBoolean bMasked))ROM_HIBERNATETABLE[23])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_HibernateIsActive                                                 \
+        ((unsigned int (*)(void))ROM_HIBERNATETABLE[24])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the I2C API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterDataPut                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char ucData))ROM_I2CTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterInitExpClk                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulI2CClk,                                    \
+                   tBoolean bFast))ROM_I2CTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveInit                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char ucSlaveAddr))ROM_I2CTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterEnable                                                   \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveEnable                                                    \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterDisable                                                  \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveDisable                                                   \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterIntEnable                                                \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveIntEnable                                                 \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterIntDisable                                               \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveIntDisable                                                \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterIntStatus                                                \
+        ((tBoolean (*)(unsigned long ulBase,                                  \
+                       tBoolean bMasked))ROM_I2CTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveIntStatus                                                 \
+        ((tBoolean (*)(unsigned long ulBase,                                  \
+                       tBoolean bMasked))ROM_I2CTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterIntClear                                                 \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveIntClear                                                  \
+        ((void (*)(unsigned long ulBase))ROM_I2CTABLE[14])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterSlaveAddrSet                                             \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char ucSlaveAddr,                                 \
+                   tBoolean bReceive))ROM_I2CTABLE[15])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterBusy                                                     \
+        ((tBoolean (*)(unsigned long ulBase))ROM_I2CTABLE[16])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterBusBusy                                                  \
+        ((tBoolean (*)(unsigned long ulBase))ROM_I2CTABLE[17])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterControl                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulCmd))ROM_I2CTABLE[18])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterErr                                                      \
+        ((unsigned long (*)(unsigned long ulBase))ROM_I2CTABLE[19])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CMasterDataGet                                                  \
+        ((unsigned long (*)(unsigned long ulBase))ROM_I2CTABLE[20])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveStatus                                                    \
+        ((unsigned long (*)(unsigned long ulBase))ROM_I2CTABLE[21])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveDataPut                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char ucData))ROM_I2CTABLE[22])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_I2CSlaveDataGet                                                   \
+        ((unsigned long (*)(unsigned long ulBase))ROM_I2CTABLE[23])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UpdateI2C                                                         \
+        ((void (*)(void))ROM_I2CTABLE[24])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Interrupt API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntEnable                                                         \
+        ((void (*)(unsigned long ulInterrupt))ROM_INTERRUPTTABLE[0])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntMasterEnable                                                   \
+        ((tBoolean (*)(void))ROM_INTERRUPTTABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntMasterDisable                                                  \
+        ((tBoolean (*)(void))ROM_INTERRUPTTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntDisable                                                        \
+        ((void (*)(unsigned long ulInterrupt))ROM_INTERRUPTTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntPriorityGroupingSet                                            \
+        ((void (*)(unsigned long ulBits))ROM_INTERRUPTTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntPriorityGroupingGet                                            \
+        ((unsigned long (*)(void))ROM_INTERRUPTTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntPrioritySet                                                    \
+        ((void (*)(unsigned long ulInterrupt,                                 \
+                   unsigned char ucPriority))ROM_INTERRUPTTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_IntPriorityGet                                                    \
+        ((long (*)(unsigned long ulInterrupt))ROM_INTERRUPTTABLE[7])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the MPU API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_MPUEnable                                                         \
+        ((void (*)(unsigned long ulMPUConfig))ROM_MPUTABLE[0])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_MPUDisable                                                        \
+        ((void (*)(void))ROM_MPUTABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_MPURegionCountGet                                                 \
+        ((unsigned long (*)(void))ROM_MPUTABLE[2])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_MPURegionEnable                                                   \
+        ((void (*)(unsigned long ulRegion))ROM_MPUTABLE[3])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_MPURegionDisable                                                  \
+        ((void (*)(unsigned long ulRegion))ROM_MPUTABLE[4])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_MPURegionSet                                                      \
+        ((void (*)(unsigned long ulRegion,                                    \
+                   unsigned long ulAddr,                                      \
+                   unsigned long ulFlags))ROM_MPUTABLE[5])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_MPURegionGet                                                      \
+        ((void (*)(unsigned long ulRegion,                                    \
+                   unsigned long *pulAddr,                                    \
+                   unsigned long *pulFlags))ROM_MPUTABLE[6])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the PWM API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMPulseWidthSet                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulPWMOut,                                    \
+                   unsigned long ulWidth))ROM_PWMTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenConfigure                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulConfig))ROM_PWMTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenPeriodSet                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulPeriod))ROM_PWMTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenPeriodGet                                                   \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulGen))ROM_PWMTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen))ROM_PWMTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenDisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen))ROM_PWMTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMPulseWidthGet                                                  \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulPWMOut))ROM_PWMTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMDeadBandEnable                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned short usRise,                                     \
+                   unsigned short usFall))ROM_PWMTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMDeadBandDisable                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen))ROM_PWMTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMSyncUpdate                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGenBits))ROM_PWMTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMSyncTimeBase                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGenBits))ROM_PWMTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMOutputState                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulPWMOutBits,                                \
+                   tBoolean bEnable))ROM_PWMTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMOutputInvert                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulPWMOutBits,                                \
+                   tBoolean bInvert))ROM_PWMTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMOutputFault                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulPWMOutBits,                                \
+                   tBoolean bFaultSuppress))ROM_PWMTABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenIntTrigEnable                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulIntTrig))ROM_PWMTABLE[14])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenIntTrigDisable                                              \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulIntTrig))ROM_PWMTABLE[15])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenIntStatus                                                   \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulGen,                              \
+                            tBoolean bMasked))ROM_PWMTABLE[16])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenIntClear                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulInts))ROM_PWMTABLE[17])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMIntEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGenFault))ROM_PWMTABLE[18])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMIntDisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGenFault))ROM_PWMTABLE[19])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMFaultIntClear                                                  \
+        ((void (*)(unsigned long ulBase))ROM_PWMTABLE[20])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMIntStatus                                                      \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tBoolean bMasked))ROM_PWMTABLE[21])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMOutputFaultLevel                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulPWMOutBits,                                \
+                   tBoolean bDriveHigh))ROM_PWMTABLE[22])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMFaultIntClearExt                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulFaultInts))ROM_PWMTABLE[23])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenFaultConfigure                                              \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulMinFaultPeriod,                            \
+                   unsigned long ulFaultSenses))ROM_PWMTABLE[24])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenFaultTriggerSet                                             \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulGroup,                                     \
+                   unsigned long ulFaultTriggers))ROM_PWMTABLE[25])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenFaultTriggerGet                                             \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulGen,                              \
+                            unsigned long ulGroup))ROM_PWMTABLE[26])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenFaultStatus                                                 \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulGen,                              \
+                            unsigned long ulGroup))ROM_PWMTABLE[27])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_PWMGenFaultClear                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulGen,                                       \
+                   unsigned long ulGroup,                                     \
+                   unsigned long ulFaultTriggers))ROM_PWMTABLE[28])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the QEI API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIPositionGet                                                    \
+        ((unsigned long (*)(unsigned long ulBase))ROM_QEITABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIEnable                                                         \
+        ((void (*)(unsigned long ulBase))ROM_QEITABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIDisable                                                        \
+        ((void (*)(unsigned long ulBase))ROM_QEITABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIConfigure                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulConfig,                                    \
+                   unsigned long ulMaxPosition))ROM_QEITABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIPositionSet                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulPosition))ROM_QEITABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIDirectionGet                                                   \
+        ((long (*)(unsigned long ulBase))ROM_QEITABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIErrorGet                                                       \
+        ((tBoolean (*)(unsigned long ulBase))ROM_QEITABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIVelocityEnable                                                 \
+        ((void (*)(unsigned long ulBase))ROM_QEITABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIVelocityDisable                                                \
+        ((void (*)(unsigned long ulBase))ROM_QEITABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIVelocityConfigure                                              \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulPreDiv,                                    \
+                   unsigned long ulPeriod))ROM_QEITABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIVelocityGet                                                    \
+        ((unsigned long (*)(unsigned long ulBase))ROM_QEITABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIIntEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_QEITABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIIntDisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_QEITABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIIntStatus                                                      \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tBoolean bMasked))ROM_QEITABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_QEIIntClear                                                       \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_QEITABLE[14])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the SSI API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIDataPut                                                        \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulData))ROM_SSITABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIConfigSetExpClk                                                \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulSSIClk,                                    \
+                   unsigned long ulProtocol,                                  \
+                   unsigned long ulMode,                                      \
+                   unsigned long ulBitRate,                                   \
+                   unsigned long ulDataWidth))ROM_SSITABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIEnable                                                         \
+        ((void (*)(unsigned long ulBase))ROM_SSITABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIDisable                                                        \
+        ((void (*)(unsigned long ulBase))ROM_SSITABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIIntEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_SSITABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIIntDisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_SSITABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIIntStatus                                                      \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tBoolean bMasked))ROM_SSITABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIIntClear                                                       \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_SSITABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIDataPutNonBlocking                                             \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long ulData))ROM_SSITABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIDataGet                                                        \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long *pulData))ROM_SSITABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIDataGetNonBlocking                                             \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long *pulData))ROM_SSITABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UpdateSSI                                                         \
+        ((void (*)(void))ROM_SSITABLE[11])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIDMAEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulDMAFlags))ROM_SSITABLE[12])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SSIDMADisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulDMAFlags))ROM_SSITABLE[13])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the SysCtl API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlSleep                                                       \
+        ((void (*)(void))ROM_SYSCTLTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlSRAMSizeGet                                                 \
+        ((unsigned long (*)(void))ROM_SYSCTLTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlFlashSizeGet                                                \
+        ((unsigned long (*)(void))ROM_SYSCTLTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPinPresent                                                  \
+        ((tBoolean (*)(unsigned long ulPin))ROM_SYSCTLTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralPresent                                           \
+        ((tBoolean (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralReset                                             \
+        ((void (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralEnable                                            \
+        ((void (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralDisable                                           \
+        ((void (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralSleepEnable                                       \
+        ((void (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralSleepDisable                                      \
+        ((void (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralDeepSleepEnable                                   \
+        ((void (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralDeepSleepDisable                                  \
+        ((void (*)(unsigned long ulPeripheral))ROM_SYSCTLTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPeripheralClockGating                                       \
+        ((void (*)(tBoolean bEnable))ROM_SYSCTLTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlIntEnable                                                   \
+        ((void (*)(unsigned long ulInts))ROM_SYSCTLTABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlIntDisable                                                  \
+        ((void (*)(unsigned long ulInts))ROM_SYSCTLTABLE[14])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlIntClear                                                    \
+        ((void (*)(unsigned long ulInts))ROM_SYSCTLTABLE[15])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlIntStatus                                                   \
+        ((unsigned long (*)(tBoolean bMasked))ROM_SYSCTLTABLE[16])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlLDOSet                                                      \
+        ((void (*)(unsigned long ulVoltage))ROM_SYSCTLTABLE[17])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlLDOGet                                                      \
+        ((unsigned long (*)(void))ROM_SYSCTLTABLE[18])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlReset                                                       \
+        ((void (*)(void))ROM_SYSCTLTABLE[19])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlDeepSleep                                                   \
+        ((void (*)(void))ROM_SYSCTLTABLE[20])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlResetCauseGet                                               \
+        ((unsigned long (*)(void))ROM_SYSCTLTABLE[21])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlResetCauseClear                                             \
+        ((void (*)(unsigned long ulCauses))ROM_SYSCTLTABLE[22])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlClockSet                                                    \
+        ((void (*)(unsigned long ulConfig))ROM_SYSCTLTABLE[23])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlClockGet                                                    \
+        ((unsigned long (*)(void))ROM_SYSCTLTABLE[24])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPWMClockSet                                                 \
+        ((void (*)(unsigned long ulConfig))ROM_SYSCTLTABLE[25])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlPWMClockGet                                                 \
+        ((unsigned long (*)(void))ROM_SYSCTLTABLE[26])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlADCSpeedSet                                                 \
+        ((void (*)(unsigned long ulSpeed))ROM_SYSCTLTABLE[27])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlADCSpeedGet                                                 \
+        ((unsigned long (*)(void))ROM_SYSCTLTABLE[28])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlGPIOAHBEnable                                               \
+        ((void (*)(unsigned long ulGPIOPeripheral))ROM_SYSCTLTABLE[29])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlGPIOAHBDisable                                              \
+        ((void (*)(unsigned long ulGPIOPeripheral))ROM_SYSCTLTABLE[30])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlUSBPLLEnable                                                \
+        ((void (*)(void))ROM_SYSCTLTABLE[31])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysCtlUSBPLLDisable                                               \
+        ((void (*)(void))ROM_SYSCTLTABLE[32])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the SysTick API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysTickValueGet                                                   \
+        ((unsigned long (*)(void))ROM_SYSTICKTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysTickEnable                                                     \
+        ((void (*)(void))ROM_SYSTICKTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysTickDisable                                                    \
+        ((void (*)(void))ROM_SYSTICKTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysTickIntEnable                                                  \
+        ((void (*)(void))ROM_SYSTICKTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysTickIntDisable                                                 \
+        ((void (*)(void))ROM_SYSTICKTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysTickPeriodSet                                                  \
+        ((void (*)(unsigned long ulPeriod))ROM_SYSTICKTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_SysTickPeriodGet                                                  \
+        ((unsigned long (*)(void))ROM_SYSTICKTABLE[6])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Timer API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerIntClear                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_TIMERTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerEnable                                                       \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer))ROM_TIMERTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerDisable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer))ROM_TIMERTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerConfigure                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulConfig))ROM_TIMERTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerControlLevel                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer,                                     \
+                   tBoolean bInvert))ROM_TIMERTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerControlTrigger                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer,                                     \
+                   tBoolean bEnable))ROM_TIMERTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerControlEvent                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer,                                     \
+                   unsigned long ulEvent))ROM_TIMERTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerControlStall                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer,                                     \
+                   tBoolean bStall))ROM_TIMERTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerRTCEnable                                                    \
+        ((void (*)(unsigned long ulBase))ROM_TIMERTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerRTCDisable                                                   \
+        ((void (*)(unsigned long ulBase))ROM_TIMERTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerPrescaleSet                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer,                                     \
+                   unsigned long ulValue))ROM_TIMERTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerPrescaleGet                                                  \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulTimer))ROM_TIMERTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerLoadSet                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer,                                     \
+                   unsigned long ulValue))ROM_TIMERTABLE[14])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerLoadGet                                                      \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulTimer))ROM_TIMERTABLE[15])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerValueGet                                                     \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulTimer))ROM_TIMERTABLE[16])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerMatchSet                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTimer,                                     \
+                   unsigned long ulValue))ROM_TIMERTABLE[17])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerMatchGet                                                     \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulTimer))ROM_TIMERTABLE[18])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerIntEnable                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_TIMERTABLE[19])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerIntDisable                                                   \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_TIMERTABLE[20])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_TimerIntStatus                                                    \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tBoolean bMasked))ROM_TIMERTABLE[21])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the UART API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTCharPut                                                       \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned char ucData))ROM_UARTTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTParityModeSet                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulParity))ROM_UARTTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTParityModeGet                                                 \
+        ((unsigned long (*)(unsigned long ulBase))ROM_UARTTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTFIFOLevelSet                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulTxLevel,                                   \
+                   unsigned long ulRxLevel))ROM_UARTTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTFIFOLevelGet                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long *pulTxLevel,                                 \
+                   unsigned long *pulRxLevel))ROM_UARTTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTConfigSetExpClk                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulUARTClk,                                   \
+                   unsigned long ulBaud,                                      \
+                   unsigned long ulConfig))ROM_UARTTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTConfigGetExpClk                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulUARTClk,                                   \
+                   unsigned long *pulBaud,                                    \
+                   unsigned long *pulConfig))ROM_UARTTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTEnable                                                        \
+        ((void (*)(unsigned long ulBase))ROM_UARTTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTDisable                                                       \
+        ((void (*)(unsigned long ulBase))ROM_UARTTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTEnableSIR                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   tBoolean bLowPower))ROM_UARTTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTDisableSIR                                                    \
+        ((void (*)(unsigned long ulBase))ROM_UARTTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTCharsAvail                                                    \
+        ((tBoolean (*)(unsigned long ulBase))ROM_UARTTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTSpaceAvail                                                    \
+        ((tBoolean (*)(unsigned long ulBase))ROM_UARTTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTCharGetNonBlocking                                            \
+        ((long (*)(unsigned long ulBase))ROM_UARTTABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTCharGet                                                       \
+        ((long (*)(unsigned long ulBase))ROM_UARTTABLE[14])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTCharPutNonBlocking                                            \
+        ((tBoolean (*)(unsigned long ulBase,                                  \
+                       unsigned char ucData))ROM_UARTTABLE[15])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTBreakCtl                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   tBoolean bBreakState))ROM_UARTTABLE[16])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTIntEnable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_UARTTABLE[17])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTIntDisable                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_UARTTABLE[18])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTIntStatus                                                     \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tBoolean bMasked))ROM_UARTTABLE[19])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTIntClear                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_UARTTABLE[20])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UpdateUART                                                        \
+        ((void (*)(void))ROM_UARTTABLE[21])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTDMAEnable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulDMAFlags))ROM_UARTTABLE[22])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_UARTDMADisable                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulDMAFlags))ROM_UARTTABLE[23])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the uDMA API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelTransferSet                                            \
+        ((void (*)(unsigned long ulChannel,                                   \
+                   unsigned long ulMode,                                      \
+                   void *pvSrcAddr,                                           \
+                   void *pvDstAddr,                                           \
+                   unsigned long ulTransferSize))ROM_UDMATABLE[0])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAEnable                                                        \
+        ((void (*)(void))ROM_UDMATABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMADisable                                                       \
+        ((void (*)(void))ROM_UDMATABLE[2])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAErrorStatusGet                                                \
+        ((unsigned long (*)(void))ROM_UDMATABLE[3])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAErrorStatusClear                                              \
+        ((void (*)(void))ROM_UDMATABLE[4])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelEnable                                                 \
+        ((void (*)(unsigned long ulChannel))ROM_UDMATABLE[5])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelDisable                                                \
+        ((void (*)(unsigned long ulChannel))ROM_UDMATABLE[6])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelIsEnabled                                              \
+        ((tBoolean (*)(unsigned long ulChannel))ROM_UDMATABLE[7])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAControlBaseSet                                                \
+        ((void (*)(void *pControlTable))ROM_UDMATABLE[8])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAControlBaseGet                                                \
+        ((void * (*)(void))ROM_UDMATABLE[9])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelRequest                                                \
+        ((void (*)(unsigned long ulChannel))ROM_UDMATABLE[10])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelAttributeEnable                                        \
+        ((void (*)(unsigned long ulChannel,                                   \
+                   unsigned long ulAttr))ROM_UDMATABLE[11])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelAttributeDisable                                       \
+        ((void (*)(unsigned long ulChannel,                                   \
+                   unsigned long ulAttr))ROM_UDMATABLE[12])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelAttributeGet                                           \
+        ((unsigned long (*)(unsigned long ulChannel))ROM_UDMATABLE[13])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelControlSet                                             \
+        ((void (*)(unsigned long ulChannel,                                   \
+                   unsigned long ulControl))ROM_UDMATABLE[14])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelSizeGet                                                \
+        ((unsigned long (*)(unsigned long ulChannel))ROM_UDMATABLE[15])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_uDMAChannelModeGet                                                \
+        ((unsigned long (*)(unsigned long ulChannel))ROM_UDMATABLE[16])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the USB API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBIntStatus                                                      \
+        ((unsigned long (*)(unsigned long ulBase))ROM_USBTABLE[0])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevAddrGet                                                     \
+        ((unsigned long (*)(unsigned long ulBase))ROM_USBTABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevAddrSet                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulAddress))ROM_USBTABLE[2])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevConnect                                                     \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[3])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevDisconnect                                                  \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[4])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevEndpointConfig                                              \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulMaxPacketSize,                             \
+                   unsigned long ulFlags))ROM_USBTABLE[5])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevEndpointDataAck                                             \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   tBoolean bIsLastPacket))ROM_USBTABLE[6])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevEndpointStall                                               \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulFlags))ROM_USBTABLE[7])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevEndpointStallClear                                          \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulFlags))ROM_USBTABLE[8])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBDevEndpointStatusClear                                         \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulFlags))ROM_USBTABLE[9])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBEndpointDataGet                                                \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned char *pucData,                                    \
+                   unsigned long *pulSize))ROM_USBTABLE[10])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBEndpointDataPut                                                \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned char *pucData,                                    \
+                   unsigned long ulSize))ROM_USBTABLE[11])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBEndpointDataSend                                               \
+        ((long (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulTransType))ROM_USBTABLE[12])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBEndpointDataToggleClear                                        \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulFlags))ROM_USBTABLE[13])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBEndpointStatus                                                 \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulEndpoint))ROM_USBTABLE[14])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBFIFOAddrGet                                                    \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulEndpoint))ROM_USBTABLE[15])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBFIFOConfigGet                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long *pulFIFOAddress,                             \
+                   unsigned long *pulFIFOSize,                                \
+                   unsigned long ulFlags))ROM_USBTABLE[16])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBFIFOConfigSet                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulFIFOAddress,                               \
+                   unsigned long ulFIFOSize,                                  \
+                   unsigned long ulFlags))ROM_USBTABLE[17])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBFIFOFlush                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulFlags))ROM_USBTABLE[18])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBFrameNumberGet                                                 \
+        ((unsigned long (*)(unsigned long ulBase))ROM_USBTABLE[19])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostAddrGet                                                    \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulEndpoint,                         \
+                            unsigned long ulFlags))ROM_USBTABLE[20])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostAddrSet                                                    \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulAddr,                                      \
+                   unsigned long ulFlags))ROM_USBTABLE[21])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostEndpointConfig                                             \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulMaxPacketSize,                             \
+                   unsigned long ulNAKPollInterval,                           \
+                   unsigned long ulTargetEndpoint,                            \
+                   unsigned long ulFlags))ROM_USBTABLE[22])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostEndpointDataAck                                            \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint))ROM_USBTABLE[23])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostEndpointDataToggle                                         \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   tBoolean bDataToggle,                                      \
+                   unsigned long ulFlags))ROM_USBTABLE[24])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostEndpointStatusClear                                        \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulFlags))ROM_USBTABLE[25])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostHubAddrGet                                                 \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            unsigned long ulEndpoint,                         \
+                            unsigned long ulFlags))ROM_USBTABLE[26])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostHubAddrSet                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint,                                  \
+                   unsigned long ulAddr,                                      \
+                   unsigned long ulFlags))ROM_USBTABLE[27])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostPwrDisable                                                 \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[28])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostPwrEnable                                                  \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[29])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostPwrFaultConfig                                             \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulFlags))ROM_USBTABLE[30])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostPwrFaultDisable                                            \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[31])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostPwrFaultEnable                                             \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[32])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostRequestIN                                                  \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulEndpoint))ROM_USBTABLE[33])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostRequestStatus                                              \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[34])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostReset                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   tBoolean bStart))ROM_USBTABLE[35])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostResume                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   tBoolean bStart))ROM_USBTABLE[36])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostSpeedGet                                                   \
+        ((unsigned long (*)(unsigned long ulBase))ROM_USBTABLE[37])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBHostSuspend                                                    \
+        ((void (*)(unsigned long ulBase))ROM_USBTABLE[38])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBIntDisable                                                     \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_USBTABLE[39])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_USBIntEnable                                                      \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulIntFlags))ROM_USBTABLE[40])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Watchdog API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogIntClear                                                  \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[0])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogRunning                                                   \
+        ((tBoolean (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[1])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogEnable                                                    \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[2])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogResetEnable                                               \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[3])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogResetDisable                                              \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[4])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogLock                                                      \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[5])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogUnlock                                                    \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[6])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogLockState                                                 \
+        ((tBoolean (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[7])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogReloadSet                                                 \
+        ((void (*)(unsigned long ulBase,                                      \
+                   unsigned long ulLoadVal))ROM_WATCHDOGTABLE[8])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogReloadGet                                                 \
+        ((unsigned long (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[9])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogValueGet                                                  \
+        ((unsigned long (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[10])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogIntEnable                                                 \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[11])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogIntStatus                                                 \
+        ((unsigned long (*)(unsigned long ulBase,                             \
+                            tBoolean bMasked))ROM_WATCHDOGTABLE[12])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogStallEnable                                               \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[13])
+#endif
+#if defined(TARGET_IS_DUSTDEVIL_RA0) || \
+    defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_WatchdogStallDisable                                              \
+        ((void (*)(unsigned long ulBase))ROM_WATCHDOGTABLE[14])
+#endif
+
+//*****************************************************************************
+//
+// Macros for calling ROM functions in the Software API.
+//
+//*****************************************************************************
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_Crc16Array                                                        \
+        ((unsigned short (*)(unsigned long ulWordLen,                         \
+                             unsigned long *pulData))ROM_SOFTWARETABLE[1])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_Crc16Array3                                                       \
+        ((void (*)(unsigned long ulWordLen,                                   \
+                   unsigned long *pulData,                                    \
+                   unsigned short *pusCrc3))ROM_SOFTWARETABLE[2])
+#endif
+#if defined(TARGET_IS_TEMPEST_RB1)
+#define ROM_pvAESTable                                                        \
+        ((void *)&amp;(ROM_SOFTWARETABLE[7]))
+#endif
+
+#endif // __ROM_H__


Property changes on: trunk/src/platform/lm3s/rom.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/rom_map.h
===================================================================
--- trunk/src/platform/lm3s/rom_map.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/rom_map.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,2763 @@
+//*****************************************************************************
+//
+// rom_map.h - Macros to facilitate calling functions in the ROM when they are
+//             available and in flash otherwise.
+//
+// Copyright (c) 2008-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __ROM_MAP_H__
+#define __ROM_MAP_H__
+
+//*****************************************************************************
+//
+// Macros for the ADC API.
+//
+//*****************************************************************************
+#ifdef ROM_ADCSequenceDataGet
+#define MAP_ADCSequenceDataGet \
+        ROM_ADCSequenceDataGet
+#else
+#define MAP_ADCSequenceDataGet \
+        ADCSequenceDataGet
+#endif
+#ifdef ROM_ADCIntDisable
+#define MAP_ADCIntDisable \
+        ROM_ADCIntDisable
+#else
+#define MAP_ADCIntDisable \
+        ADCIntDisable
+#endif
+#ifdef ROM_ADCIntEnable
+#define MAP_ADCIntEnable \
+        ROM_ADCIntEnable
+#else
+#define MAP_ADCIntEnable \
+        ADCIntEnable
+#endif
+#ifdef ROM_ADCIntStatus
+#define MAP_ADCIntStatus \
+        ROM_ADCIntStatus
+#else
+#define MAP_ADCIntStatus \
+        ADCIntStatus
+#endif
+#ifdef ROM_ADCIntClear
+#define MAP_ADCIntClear \
+        ROM_ADCIntClear
+#else
+#define MAP_ADCIntClear \
+        ADCIntClear
+#endif
+#ifdef ROM_ADCSequenceEnable
+#define MAP_ADCSequenceEnable \
+        ROM_ADCSequenceEnable
+#else
+#define MAP_ADCSequenceEnable \
+        ADCSequenceEnable
+#endif
+#ifdef ROM_ADCSequenceDisable
+#define MAP_ADCSequenceDisable \
+        ROM_ADCSequenceDisable
+#else
+#define MAP_ADCSequenceDisable \
+        ADCSequenceDisable
+#endif
+#ifdef ROM_ADCSequenceConfigure
+#define MAP_ADCSequenceConfigure \
+        ROM_ADCSequenceConfigure
+#else
+#define MAP_ADCSequenceConfigure \
+        ADCSequenceConfigure
+#endif
+#ifdef ROM_ADCSequenceStepConfigure
+#define MAP_ADCSequenceStepConfigure \
+        ROM_ADCSequenceStepConfigure
+#else
+#define MAP_ADCSequenceStepConfigure \
+        ADCSequenceStepConfigure
+#endif
+#ifdef ROM_ADCSequenceOverflow
+#define MAP_ADCSequenceOverflow \
+        ROM_ADCSequenceOverflow
+#else
+#define MAP_ADCSequenceOverflow \
+        ADCSequenceOverflow
+#endif
+#ifdef ROM_ADCSequenceOverflowClear
+#define MAP_ADCSequenceOverflowClear \
+        ROM_ADCSequenceOverflowClear
+#else
+#define MAP_ADCSequenceOverflowClear \
+        ADCSequenceOverflowClear
+#endif
+#ifdef ROM_ADCSequenceUnderflow
+#define MAP_ADCSequenceUnderflow \
+        ROM_ADCSequenceUnderflow
+#else
+#define MAP_ADCSequenceUnderflow \
+        ADCSequenceUnderflow
+#endif
+#ifdef ROM_ADCSequenceUnderflowClear
+#define MAP_ADCSequenceUnderflowClear \
+        ROM_ADCSequenceUnderflowClear
+#else
+#define MAP_ADCSequenceUnderflowClear \
+        ADCSequenceUnderflowClear
+#endif
+#ifdef ROM_ADCProcessorTrigger
+#define MAP_ADCProcessorTrigger \
+        ROM_ADCProcessorTrigger
+#else
+#define MAP_ADCProcessorTrigger \
+        ADCProcessorTrigger
+#endif
+#ifdef ROM_ADCHardwareOversampleConfigure
+#define MAP_ADCHardwareOversampleConfigure \
+        ROM_ADCHardwareOversampleConfigure
+#else
+#define MAP_ADCHardwareOversampleConfigure \
+        ADCHardwareOversampleConfigure
+#endif
+
+//*****************************************************************************
+//
+// Macros for the CAN API.
+//
+//*****************************************************************************
+#ifdef ROM_CANIntClear
+#define MAP_CANIntClear \
+        ROM_CANIntClear
+#else
+#define MAP_CANIntClear \
+        CANIntClear
+#endif
+#ifdef ROM_CANInit
+#define MAP_CANInit \
+        ROM_CANInit
+#else
+#define MAP_CANInit \
+        CANInit
+#endif
+#ifdef ROM_CANEnable
+#define MAP_CANEnable \
+        ROM_CANEnable
+#else
+#define MAP_CANEnable \
+        CANEnable
+#endif
+#ifdef ROM_CANDisable
+#define MAP_CANDisable \
+        ROM_CANDisable
+#else
+#define MAP_CANDisable \
+        CANDisable
+#endif
+#ifdef ROM_CANBitTimingSet
+#define MAP_CANBitTimingSet \
+        ROM_CANBitTimingSet
+#else
+#define MAP_CANBitTimingSet \
+        CANBitTimingSet
+#endif
+#ifdef ROM_CANBitTimingGet
+#define MAP_CANBitTimingGet \
+        ROM_CANBitTimingGet
+#else
+#define MAP_CANBitTimingGet \
+        CANBitTimingGet
+#endif
+#ifdef ROM_CANMessageSet
+#define MAP_CANMessageSet \
+        ROM_CANMessageSet
+#else
+#define MAP_CANMessageSet \
+        CANMessageSet
+#endif
+#ifdef ROM_CANMessageGet
+#define MAP_CANMessageGet \
+        ROM_CANMessageGet
+#else
+#define MAP_CANMessageGet \
+        CANMessageGet
+#endif
+#ifdef ROM_CANStatusGet
+#define MAP_CANStatusGet \
+        ROM_CANStatusGet
+#else
+#define MAP_CANStatusGet \
+        CANStatusGet
+#endif
+#ifdef ROM_CANMessageClear
+#define MAP_CANMessageClear \
+        ROM_CANMessageClear
+#else
+#define MAP_CANMessageClear \
+        CANMessageClear
+#endif
+#ifdef ROM_CANIntEnable
+#define MAP_CANIntEnable \
+        ROM_CANIntEnable
+#else
+#define MAP_CANIntEnable \
+        CANIntEnable
+#endif
+#ifdef ROM_CANIntDisable
+#define MAP_CANIntDisable \
+        ROM_CANIntDisable
+#else
+#define MAP_CANIntDisable \
+        CANIntDisable
+#endif
+#ifdef ROM_CANIntStatus
+#define MAP_CANIntStatus \
+        ROM_CANIntStatus
+#else
+#define MAP_CANIntStatus \
+        CANIntStatus
+#endif
+#ifdef ROM_CANRetryGet
+#define MAP_CANRetryGet \
+        ROM_CANRetryGet
+#else
+#define MAP_CANRetryGet \
+        CANRetryGet
+#endif
+#ifdef ROM_CANRetrySet
+#define MAP_CANRetrySet \
+        ROM_CANRetrySet
+#else
+#define MAP_CANRetrySet \
+        CANRetrySet
+#endif
+#ifdef ROM_CANErrCntrGet
+#define MAP_CANErrCntrGet \
+        ROM_CANErrCntrGet
+#else
+#define MAP_CANErrCntrGet \
+        CANErrCntrGet
+#endif
+
+//*****************************************************************************
+//
+// Macros for the Comparator API.
+//
+//*****************************************************************************
+#ifdef ROM_ComparatorIntClear
+#define MAP_ComparatorIntClear \
+        ROM_ComparatorIntClear
+#else
+#define MAP_ComparatorIntClear \
+        ComparatorIntClear
+#endif
+#ifdef ROM_ComparatorConfigure
+#define MAP_ComparatorConfigure \
+        ROM_ComparatorConfigure
+#else
+#define MAP_ComparatorConfigure \
+        ComparatorConfigure
+#endif
+#ifdef ROM_ComparatorRefSet
+#define MAP_ComparatorRefSet \
+        ROM_ComparatorRefSet
+#else
+#define MAP_ComparatorRefSet \
+        ComparatorRefSet
+#endif
+#ifdef ROM_ComparatorValueGet
+#define MAP_ComparatorValueGet \
+        ROM_ComparatorValueGet
+#else
+#define MAP_ComparatorValueGet \
+        ComparatorValueGet
+#endif
+#ifdef ROM_ComparatorIntEnable
+#define MAP_ComparatorIntEnable \
+        ROM_ComparatorIntEnable
+#else
+#define MAP_ComparatorIntEnable \
+        ComparatorIntEnable
+#endif
+#ifdef ROM_ComparatorIntDisable
+#define MAP_ComparatorIntDisable \
+        ROM_ComparatorIntDisable
+#else
+#define MAP_ComparatorIntDisable \
+        ComparatorIntDisable
+#endif
+#ifdef ROM_ComparatorIntStatus
+#define MAP_ComparatorIntStatus \
+        ROM_ComparatorIntStatus
+#else
+#define MAP_ComparatorIntStatus \
+        ComparatorIntStatus
+#endif
+
+//*****************************************************************************
+//
+// Macros for the Ethernet API.
+//
+//*****************************************************************************
+#ifdef ROM_EthernetIntClear
+#define MAP_EthernetIntClear \
+        ROM_EthernetIntClear
+#else
+#define MAP_EthernetIntClear \
+        EthernetIntClear
+#endif
+#ifdef ROM_EthernetInitExpClk
+#define MAP_EthernetInitExpClk \
+        ROM_EthernetInitExpClk
+#else
+#define MAP_EthernetInitExpClk \
+        EthernetInitExpClk
+#endif
+#ifdef ROM_EthernetConfigSet
+#define MAP_EthernetConfigSet \
+        ROM_EthernetConfigSet
+#else
+#define MAP_EthernetConfigSet \
+        EthernetConfigSet
+#endif
+#ifdef ROM_EthernetConfigGet
+#define MAP_EthernetConfigGet \
+        ROM_EthernetConfigGet
+#else
+#define MAP_EthernetConfigGet \
+        EthernetConfigGet
+#endif
+#ifdef ROM_EthernetMACAddrSet
+#define MAP_EthernetMACAddrSet \
+        ROM_EthernetMACAddrSet
+#else
+#define MAP_EthernetMACAddrSet \
+        EthernetMACAddrSet
+#endif
+#ifdef ROM_EthernetMACAddrGet
+#define MAP_EthernetMACAddrGet \
+        ROM_EthernetMACAddrGet
+#else
+#define MAP_EthernetMACAddrGet \
+        EthernetMACAddrGet
+#endif
+#ifdef ROM_EthernetEnable
+#define MAP_EthernetEnable \
+        ROM_EthernetEnable
+#else
+#define MAP_EthernetEnable \
+        EthernetEnable
+#endif
+#ifdef ROM_EthernetDisable
+#define MAP_EthernetDisable \
+        ROM_EthernetDisable
+#else
+#define MAP_EthernetDisable \
+        EthernetDisable
+#endif
+#ifdef ROM_EthernetPacketAvail
+#define MAP_EthernetPacketAvail \
+        ROM_EthernetPacketAvail
+#else
+#define MAP_EthernetPacketAvail \
+        EthernetPacketAvail
+#endif
+#ifdef ROM_EthernetSpaceAvail
+#define MAP_EthernetSpaceAvail \
+        ROM_EthernetSpaceAvail
+#else
+#define MAP_EthernetSpaceAvail \
+        EthernetSpaceAvail
+#endif
+#ifdef ROM_EthernetPacketGetNonBlocking
+#define MAP_EthernetPacketGetNonBlocking \
+        ROM_EthernetPacketGetNonBlocking
+#else
+#define MAP_EthernetPacketGetNonBlocking \
+        EthernetPacketGetNonBlocking
+#endif
+#ifdef ROM_EthernetPacketGet
+#define MAP_EthernetPacketGet \
+        ROM_EthernetPacketGet
+#else
+#define MAP_EthernetPacketGet \
+        EthernetPacketGet
+#endif
+#ifdef ROM_EthernetPacketPutNonBlocking
+#define MAP_EthernetPacketPutNonBlocking \
+        ROM_EthernetPacketPutNonBlocking
+#else
+#define MAP_EthernetPacketPutNonBlocking \
+        EthernetPacketPutNonBlocking
+#endif
+#ifdef ROM_EthernetPacketPut
+#define MAP_EthernetPacketPut \
+        ROM_EthernetPacketPut
+#else
+#define MAP_EthernetPacketPut \
+        EthernetPacketPut
+#endif
+#ifdef ROM_EthernetIntEnable
+#define MAP_EthernetIntEnable \
+        ROM_EthernetIntEnable
+#else
+#define MAP_EthernetIntEnable \
+        EthernetIntEnable
+#endif
+#ifdef ROM_EthernetIntDisable
+#define MAP_EthernetIntDisable \
+        ROM_EthernetIntDisable
+#else
+#define MAP_EthernetIntDisable \
+        EthernetIntDisable
+#endif
+#ifdef ROM_EthernetIntStatus
+#define MAP_EthernetIntStatus \
+        ROM_EthernetIntStatus
+#else
+#define MAP_EthernetIntStatus \
+        EthernetIntStatus
+#endif
+#ifdef ROM_EthernetPHYWrite
+#define MAP_EthernetPHYWrite \
+        ROM_EthernetPHYWrite
+#else
+#define MAP_EthernetPHYWrite \
+        EthernetPHYWrite
+#endif
+#ifdef ROM_EthernetPHYRead
+#define MAP_EthernetPHYRead \
+        ROM_EthernetPHYRead
+#else
+#define MAP_EthernetPHYRead \
+        EthernetPHYRead
+#endif
+
+//*****************************************************************************
+//
+// Macros for the Flash API.
+//
+//*****************************************************************************
+#ifdef ROM_FlashProgram
+#define MAP_FlashProgram \
+        ROM_FlashProgram
+#else
+#define MAP_FlashProgram \
+        FlashProgram
+#endif
+#ifdef ROM_FlashUsecGet
+#define MAP_FlashUsecGet \
+        ROM_FlashUsecGet
+#else
+#define MAP_FlashUsecGet \
+        FlashUsecGet
+#endif
+#ifdef ROM_FlashUsecSet
+#define MAP_FlashUsecSet \
+        ROM_FlashUsecSet
+#else
+#define MAP_FlashUsecSet \
+        FlashUsecSet
+#endif
+#ifdef ROM_FlashErase
+#define MAP_FlashErase \
+        ROM_FlashErase
+#else
+#define MAP_FlashErase \
+        FlashErase
+#endif
+#ifdef ROM_FlashProtectGet
+#define MAP_FlashProtectGet \
+        ROM_FlashProtectGet
+#else
+#define MAP_FlashProtectGet \
+        FlashProtectGet
+#endif
+#ifdef ROM_FlashProtectSet
+#define MAP_FlashProtectSet \
+        ROM_FlashProtectSet
+#else
+#define MAP_FlashProtectSet \
+        FlashProtectSet
+#endif
+#ifdef ROM_FlashProtectSave
+#define MAP_FlashProtectSave \
+        ROM_FlashProtectSave
+#else
+#define MAP_FlashProtectSave \
+        FlashProtectSave
+#endif
+#ifdef ROM_FlashUserGet
+#define MAP_FlashUserGet \
+        ROM_FlashUserGet
+#else
+#define MAP_FlashUserGet \
+        FlashUserGet
+#endif
+#ifdef ROM_FlashUserSet
+#define MAP_FlashUserSet \
+        ROM_FlashUserSet
+#else
+#define MAP_FlashUserSet \
+        FlashUserSet
+#endif
+#ifdef ROM_FlashUserSave
+#define MAP_FlashUserSave \
+        ROM_FlashUserSave
+#else
+#define MAP_FlashUserSave \
+        FlashUserSave
+#endif
+#ifdef ROM_FlashIntEnable
+#define MAP_FlashIntEnable \
+        ROM_FlashIntEnable
+#else
+#define MAP_FlashIntEnable \
+        FlashIntEnable
+#endif
+#ifdef ROM_FlashIntDisable
+#define MAP_FlashIntDisable \
+        ROM_FlashIntDisable
+#else
+#define MAP_FlashIntDisable \
+        FlashIntDisable
+#endif
+#ifdef ROM_FlashIntGetStatus
+#define MAP_FlashIntGetStatus \
+        ROM_FlashIntGetStatus
+#else
+#define MAP_FlashIntGetStatus \
+        FlashIntGetStatus
+#endif
+#ifdef ROM_FlashIntClear
+#define MAP_FlashIntClear \
+        ROM_FlashIntClear
+#else
+#define MAP_FlashIntClear \
+        FlashIntClear
+#endif
+
+//*****************************************************************************
+//
+// Macros for the GPIO API.
+//
+//*****************************************************************************
+#ifdef ROM_GPIOPinWrite
+#define MAP_GPIOPinWrite \
+        ROM_GPIOPinWrite
+#else
+#define MAP_GPIOPinWrite \
+        GPIOPinWrite
+#endif
+#ifdef ROM_GPIODirModeSet
+#define MAP_GPIODirModeSet \
+        ROM_GPIODirModeSet
+#else
+#define MAP_GPIODirModeSet \
+        GPIODirModeSet
+#endif
+#ifdef ROM_GPIODirModeGet
+#define MAP_GPIODirModeGet \
+        ROM_GPIODirModeGet
+#else
+#define MAP_GPIODirModeGet \
+        GPIODirModeGet
+#endif
+#ifdef ROM_GPIOIntTypeSet
+#define MAP_GPIOIntTypeSet \
+        ROM_GPIOIntTypeSet
+#else
+#define MAP_GPIOIntTypeSet \
+        GPIOIntTypeSet
+#endif
+#ifdef ROM_GPIOIntTypeGet
+#define MAP_GPIOIntTypeGet \
+        ROM_GPIOIntTypeGet
+#else
+#define MAP_GPIOIntTypeGet \
+        GPIOIntTypeGet
+#endif
+#ifdef ROM_GPIOPadConfigSet
+#define MAP_GPIOPadConfigSet \
+        ROM_GPIOPadConfigSet
+#else
+#define MAP_GPIOPadConfigSet \
+        GPIOPadConfigSet
+#endif
+#ifdef ROM_GPIOPadConfigGet
+#define MAP_GPIOPadConfigGet \
+        ROM_GPIOPadConfigGet
+#else
+#define MAP_GPIOPadConfigGet \
+        GPIOPadConfigGet
+#endif
+#ifdef ROM_GPIOPinIntEnable
+#define MAP_GPIOPinIntEnable \
+        ROM_GPIOPinIntEnable
+#else
+#define MAP_GPIOPinIntEnable \
+        GPIOPinIntEnable
+#endif
+#ifdef ROM_GPIOPinIntDisable
+#define MAP_GPIOPinIntDisable \
+        ROM_GPIOPinIntDisable
+#else
+#define MAP_GPIOPinIntDisable \
+        GPIOPinIntDisable
+#endif
+#ifdef ROM_GPIOPinIntStatus
+#define MAP_GPIOPinIntStatus \
+        ROM_GPIOPinIntStatus
+#else
+#define MAP_GPIOPinIntStatus \
+        GPIOPinIntStatus
+#endif
+#ifdef ROM_GPIOPinIntClear
+#define MAP_GPIOPinIntClear \
+        ROM_GPIOPinIntClear
+#else
+#define MAP_GPIOPinIntClear \
+        GPIOPinIntClear
+#endif
+#ifdef ROM_GPIOPinRead
+#define MAP_GPIOPinRead \
+        ROM_GPIOPinRead
+#else
+#define MAP_GPIOPinRead \
+        GPIOPinRead
+#endif
+#ifdef ROM_GPIOPinTypeCAN
+#define MAP_GPIOPinTypeCAN \
+        ROM_GPIOPinTypeCAN
+#else
+#define MAP_GPIOPinTypeCAN \
+        GPIOPinTypeCAN
+#endif
+#ifdef ROM_GPIOPinTypeComparator
+#define MAP_GPIOPinTypeComparator \
+        ROM_GPIOPinTypeComparator
+#else
+#define MAP_GPIOPinTypeComparator \
+        GPIOPinTypeComparator
+#endif
+#ifdef ROM_GPIOPinTypeGPIOInput
+#define MAP_GPIOPinTypeGPIOInput \
+        ROM_GPIOPinTypeGPIOInput
+#else
+#define MAP_GPIOPinTypeGPIOInput \
+        GPIOPinTypeGPIOInput
+#endif
+#ifdef ROM_GPIOPinTypeGPIOOutput
+#define MAP_GPIOPinTypeGPIOOutput \
+        ROM_GPIOPinTypeGPIOOutput
+#else
+#define MAP_GPIOPinTypeGPIOOutput \
+        GPIOPinTypeGPIOOutput
+#endif
+#ifdef ROM_GPIOPinTypeI2C
+#define MAP_GPIOPinTypeI2C \
+        ROM_GPIOPinTypeI2C
+#else
+#define MAP_GPIOPinTypeI2C \
+        GPIOPinTypeI2C
+#endif
+#ifdef ROM_GPIOPinTypePWM
+#define MAP_GPIOPinTypePWM \
+        ROM_GPIOPinTypePWM
+#else
+#define MAP_GPIOPinTypePWM \
+        GPIOPinTypePWM
+#endif
+#ifdef ROM_GPIOPinTypeQEI
+#define MAP_GPIOPinTypeQEI \
+        ROM_GPIOPinTypeQEI
+#else
+#define MAP_GPIOPinTypeQEI \
+        GPIOPinTypeQEI
+#endif
+#ifdef ROM_GPIOPinTypeSSI
+#define MAP_GPIOPinTypeSSI \
+        ROM_GPIOPinTypeSSI
+#else
+#define MAP_GPIOPinTypeSSI \
+        GPIOPinTypeSSI
+#endif
+#ifdef ROM_GPIOPinTypeTimer
+#define MAP_GPIOPinTypeTimer \
+        ROM_GPIOPinTypeTimer
+#else
+#define MAP_GPIOPinTypeTimer \
+        GPIOPinTypeTimer
+#endif
+#ifdef ROM_GPIOPinTypeUART
+#define MAP_GPIOPinTypeUART \
+        ROM_GPIOPinTypeUART
+#else
+#define MAP_GPIOPinTypeUART \
+        GPIOPinTypeUART
+#endif
+#ifdef ROM_GPIOPinTypeGPIOOutputOD
+#define MAP_GPIOPinTypeGPIOOutputOD \
+        ROM_GPIOPinTypeGPIOOutputOD
+#else
+#define MAP_GPIOPinTypeGPIOOutputOD \
+        GPIOPinTypeGPIOOutputOD
+#endif
+#ifdef ROM_GPIOPinTypeADC
+#define MAP_GPIOPinTypeADC \
+        ROM_GPIOPinTypeADC
+#else
+#define MAP_GPIOPinTypeADC \
+        GPIOPinTypeADC
+#endif
+#ifdef ROM_GPIOPinTypeUSBDigital
+#define MAP_GPIOPinTypeUSBDigital \
+        ROM_GPIOPinTypeUSBDigital
+#else
+#define MAP_GPIOPinTypeUSBDigital \
+        GPIOPinTypeUSBDigital
+#endif
+
+//*****************************************************************************
+//
+// Macros for the Hibernate API.
+//
+//*****************************************************************************
+#ifdef ROM_HibernateIntClear
+#define MAP_HibernateIntClear \
+        ROM_HibernateIntClear
+#else
+#define MAP_HibernateIntClear \
+        HibernateIntClear
+#endif
+#ifdef ROM_HibernateEnableExpClk
+#define MAP_HibernateEnableExpClk \
+        ROM_HibernateEnableExpClk
+#else
+#define MAP_HibernateEnableExpClk \
+        HibernateEnableExpClk
+#endif
+#ifdef ROM_HibernateDisable
+#define MAP_HibernateDisable \
+        ROM_HibernateDisable
+#else
+#define MAP_HibernateDisable \
+        HibernateDisable
+#endif
+#ifdef ROM_HibernateClockSelect
+#define MAP_HibernateClockSelect \
+        ROM_HibernateClockSelect
+#else
+#define MAP_HibernateClockSelect \
+        HibernateClockSelect
+#endif
+#ifdef ROM_HibernateRTCEnable
+#define MAP_HibernateRTCEnable \
+        ROM_HibernateRTCEnable
+#else
+#define MAP_HibernateRTCEnable \
+        HibernateRTCEnable
+#endif
+#ifdef ROM_HibernateRTCDisable
+#define MAP_HibernateRTCDisable \
+        ROM_HibernateRTCDisable
+#else
+#define MAP_HibernateRTCDisable \
+        HibernateRTCDisable
+#endif
+#ifdef ROM_HibernateWakeSet
+#define MAP_HibernateWakeSet \
+        ROM_HibernateWakeSet
+#else
+#define MAP_HibernateWakeSet \
+        HibernateWakeSet
+#endif
+#ifdef ROM_HibernateWakeGet
+#define MAP_HibernateWakeGet \
+        ROM_HibernateWakeGet
+#else
+#define MAP_HibernateWakeGet \
+        HibernateWakeGet
+#endif
+#ifdef ROM_HibernateLowBatSet
+#define MAP_HibernateLowBatSet \
+        ROM_HibernateLowBatSet
+#else
+#define MAP_HibernateLowBatSet \
+        HibernateLowBatSet
+#endif
+#ifdef ROM_HibernateLowBatGet
+#define MAP_HibernateLowBatGet \
+        ROM_HibernateLowBatGet
+#else
+#define MAP_HibernateLowBatGet \
+        HibernateLowBatGet
+#endif
+#ifdef ROM_HibernateRTCSet
+#define MAP_HibernateRTCSet \
+        ROM_HibernateRTCSet
+#else
+#define MAP_HibernateRTCSet \
+        HibernateRTCSet
+#endif
+#ifdef ROM_HibernateRTCGet
+#define MAP_HibernateRTCGet \
+        ROM_HibernateRTCGet
+#else
+#define MAP_HibernateRTCGet \
+        HibernateRTCGet
+#endif
+#ifdef ROM_HibernateRTCMatch0Set
+#define MAP_HibernateRTCMatch0Set \
+        ROM_HibernateRTCMatch0Set
+#else
+#define MAP_HibernateRTCMatch0Set \
+        HibernateRTCMatch0Set
+#endif
+#ifdef ROM_HibernateRTCMatch0Get
+#define MAP_HibernateRTCMatch0Get \
+        ROM_HibernateRTCMatch0Get
+#else
+#define MAP_HibernateRTCMatch0Get \
+        HibernateRTCMatch0Get
+#endif
+#ifdef ROM_HibernateRTCMatch1Set
+#define MAP_HibernateRTCMatch1Set \
+        ROM_HibernateRTCMatch1Set
+#else
+#define MAP_HibernateRTCMatch1Set \
+        HibernateRTCMatch1Set
+#endif
+#ifdef ROM_HibernateRTCMatch1Get
+#define MAP_HibernateRTCMatch1Get \
+        ROM_HibernateRTCMatch1Get
+#else
+#define MAP_HibernateRTCMatch1Get \
+        HibernateRTCMatch1Get
+#endif
+#ifdef ROM_HibernateRTCTrimSet
+#define MAP_HibernateRTCTrimSet \
+        ROM_HibernateRTCTrimSet
+#else
+#define MAP_HibernateRTCTrimSet \
+        HibernateRTCTrimSet
+#endif
+#ifdef ROM_HibernateRTCTrimGet
+#define MAP_HibernateRTCTrimGet \
+        ROM_HibernateRTCTrimGet
+#else
+#define MAP_HibernateRTCTrimGet \
+        HibernateRTCTrimGet
+#endif
+#ifdef ROM_HibernateDataSet
+#define MAP_HibernateDataSet \
+        ROM_HibernateDataSet
+#else
+#define MAP_HibernateDataSet \
+        HibernateDataSet
+#endif
+#ifdef ROM_HibernateDataGet
+#define MAP_HibernateDataGet \
+        ROM_HibernateDataGet
+#else
+#define MAP_HibernateDataGet \
+        HibernateDataGet
+#endif
+#ifdef ROM_HibernateRequest
+#define MAP_HibernateRequest \
+        ROM_HibernateRequest
+#else
+#define MAP_HibernateRequest \
+        HibernateRequest
+#endif
+#ifdef ROM_HibernateIntEnable
+#define MAP_HibernateIntEnable \
+        ROM_HibernateIntEnable
+#else
+#define MAP_HibernateIntEnable \
+        HibernateIntEnable
+#endif
+#ifdef ROM_HibernateIntDisable
+#define MAP_HibernateIntDisable \
+        ROM_HibernateIntDisable
+#else
+#define MAP_HibernateIntDisable \
+        HibernateIntDisable
+#endif
+#ifdef ROM_HibernateIntStatus
+#define MAP_HibernateIntStatus \
+        ROM_HibernateIntStatus
+#else
+#define MAP_HibernateIntStatus \
+        HibernateIntStatus
+#endif
+#ifdef ROM_HibernateIsActive
+#define MAP_HibernateIsActive \
+        ROM_HibernateIsActive
+#else
+#define MAP_HibernateIsActive \
+        HibernateIsActive
+#endif
+
+//*****************************************************************************
+//
+// Macros for the I2C API.
+//
+//*****************************************************************************
+#ifdef ROM_I2CMasterDataPut
+#define MAP_I2CMasterDataPut \
+        ROM_I2CMasterDataPut
+#else
+#define MAP_I2CMasterDataPut \
+        I2CMasterDataPut
+#endif
+#ifdef ROM_I2CMasterInitExpClk
+#define MAP_I2CMasterInitExpClk \
+        ROM_I2CMasterInitExpClk
+#else
+#define MAP_I2CMasterInitExpClk \
+        I2CMasterInitExpClk
+#endif
+#ifdef ROM_I2CSlaveInit
+#define MAP_I2CSlaveInit \
+        ROM_I2CSlaveInit
+#else
+#define MAP_I2CSlaveInit \
+        I2CSlaveInit
+#endif
+#ifdef ROM_I2CMasterEnable
+#define MAP_I2CMasterEnable \
+        ROM_I2CMasterEnable
+#else
+#define MAP_I2CMasterEnable \
+        I2CMasterEnable
+#endif
+#ifdef ROM_I2CSlaveEnable
+#define MAP_I2CSlaveEnable \
+        ROM_I2CSlaveEnable
+#else
+#define MAP_I2CSlaveEnable \
+        I2CSlaveEnable
+#endif
+#ifdef ROM_I2CMasterDisable
+#define MAP_I2CMasterDisable \
+        ROM_I2CMasterDisable
+#else
+#define MAP_I2CMasterDisable \
+        I2CMasterDisable
+#endif
+#ifdef ROM_I2CSlaveDisable
+#define MAP_I2CSlaveDisable \
+        ROM_I2CSlaveDisable
+#else
+#define MAP_I2CSlaveDisable \
+        I2CSlaveDisable
+#endif
+#ifdef ROM_I2CMasterIntEnable
+#define MAP_I2CMasterIntEnable \
+        ROM_I2CMasterIntEnable
+#else
+#define MAP_I2CMasterIntEnable \
+        I2CMasterIntEnable
+#endif
+#ifdef ROM_I2CSlaveIntEnable
+#define MAP_I2CSlaveIntEnable \
+        ROM_I2CSlaveIntEnable
+#else
+#define MAP_I2CSlaveIntEnable \
+        I2CSlaveIntEnable
+#endif
+#ifdef ROM_I2CMasterIntDisable
+#define MAP_I2CMasterIntDisable \
+        ROM_I2CMasterIntDisable
+#else
+#define MAP_I2CMasterIntDisable \
+        I2CMasterIntDisable
+#endif
+#ifdef ROM_I2CSlaveIntDisable
+#define MAP_I2CSlaveIntDisable \
+        ROM_I2CSlaveIntDisable
+#else
+#define MAP_I2CSlaveIntDisable \
+        I2CSlaveIntDisable
+#endif
+#ifdef ROM_I2CMasterIntStatus
+#define MAP_I2CMasterIntStatus \
+        ROM_I2CMasterIntStatus
+#else
+#define MAP_I2CMasterIntStatus \
+        I2CMasterIntStatus
+#endif
+#ifdef ROM_I2CSlaveIntStatus
+#define MAP_I2CSlaveIntStatus \
+        ROM_I2CSlaveIntStatus
+#else
+#define MAP_I2CSlaveIntStatus \
+        I2CSlaveIntStatus
+#endif
+#ifdef ROM_I2CMasterIntClear
+#define MAP_I2CMasterIntClear \
+        ROM_I2CMasterIntClear
+#else
+#define MAP_I2CMasterIntClear \
+        I2CMasterIntClear
+#endif
+#ifdef ROM_I2CSlaveIntClear
+#define MAP_I2CSlaveIntClear \
+        ROM_I2CSlaveIntClear
+#else
+#define MAP_I2CSlaveIntClear \
+        I2CSlaveIntClear
+#endif
+#ifdef ROM_I2CMasterSlaveAddrSet
+#define MAP_I2CMasterSlaveAddrSet \
+        ROM_I2CMasterSlaveAddrSet
+#else
+#define MAP_I2CMasterSlaveAddrSet \
+        I2CMasterSlaveAddrSet
+#endif
+#ifdef ROM_I2CMasterBusy
+#define MAP_I2CMasterBusy \
+        ROM_I2CMasterBusy
+#else
+#define MAP_I2CMasterBusy \
+        I2CMasterBusy
+#endif
+#ifdef ROM_I2CMasterBusBusy
+#define MAP_I2CMasterBusBusy \
+        ROM_I2CMasterBusBusy
+#else
+#define MAP_I2CMasterBusBusy \
+        I2CMasterBusBusy
+#endif
+#ifdef ROM_I2CMasterControl
+#define MAP_I2CMasterControl \
+        ROM_I2CMasterControl
+#else
+#define MAP_I2CMasterControl \
+        I2CMasterControl
+#endif
+#ifdef ROM_I2CMasterErr
+#define MAP_I2CMasterErr \
+        ROM_I2CMasterErr
+#else
+#define MAP_I2CMasterErr \
+        I2CMasterErr
+#endif
+#ifdef ROM_I2CMasterDataGet
+#define MAP_I2CMasterDataGet \
+        ROM_I2CMasterDataGet
+#else
+#define MAP_I2CMasterDataGet \
+        I2CMasterDataGet
+#endif
+#ifdef ROM_I2CSlaveStatus
+#define MAP_I2CSlaveStatus \
+        ROM_I2CSlaveStatus
+#else
+#define MAP_I2CSlaveStatus \
+        I2CSlaveStatus
+#endif
+#ifdef ROM_I2CSlaveDataPut
+#define MAP_I2CSlaveDataPut \
+        ROM_I2CSlaveDataPut
+#else
+#define MAP_I2CSlaveDataPut \
+        I2CSlaveDataPut
+#endif
+#ifdef ROM_I2CSlaveDataGet
+#define MAP_I2CSlaveDataGet \
+        ROM_I2CSlaveDataGet
+#else
+#define MAP_I2CSlaveDataGet \
+        I2CSlaveDataGet
+#endif
+
+//*****************************************************************************
+//
+// Macros for the Interrupt API.
+//
+//*****************************************************************************
+#ifdef ROM_IntEnable
+#define MAP_IntEnable \
+        ROM_IntEnable
+#else
+#define MAP_IntEnable \
+        IntEnable
+#endif
+#ifdef ROM_IntMasterEnable
+#define MAP_IntMasterEnable \
+        ROM_IntMasterEnable
+#else
+#define MAP_IntMasterEnable \
+        IntMasterEnable
+#endif
+#ifdef ROM_IntMasterDisable
+#define MAP_IntMasterDisable \
+        ROM_IntMasterDisable
+#else
+#define MAP_IntMasterDisable \
+        IntMasterDisable
+#endif
+#ifdef ROM_IntDisable
+#define MAP_IntDisable \
+        ROM_IntDisable
+#else
+#define MAP_IntDisable \
+        IntDisable
+#endif
+#ifdef ROM_IntPriorityGroupingSet
+#define MAP_IntPriorityGroupingSet \
+        ROM_IntPriorityGroupingSet
+#else
+#define MAP_IntPriorityGroupingSet \
+        IntPriorityGroupingSet
+#endif
+#ifdef ROM_IntPriorityGroupingGet
+#define MAP_IntPriorityGroupingGet \
+        ROM_IntPriorityGroupingGet
+#else
+#define MAP_IntPriorityGroupingGet \
+        IntPriorityGroupingGet
+#endif
+#ifdef ROM_IntPrioritySet
+#define MAP_IntPrioritySet \
+        ROM_IntPrioritySet
+#else
+#define MAP_IntPrioritySet \
+        IntPrioritySet
+#endif
+#ifdef ROM_IntPriorityGet
+#define MAP_IntPriorityGet \
+        ROM_IntPriorityGet
+#else
+#define MAP_IntPriorityGet \
+        IntPriorityGet
+#endif
+
+//*****************************************************************************
+//
+// Macros for the MPU API.
+//
+//*****************************************************************************
+#ifdef ROM_MPUEnable
+#define MAP_MPUEnable \
+        ROM_MPUEnable
+#else
+#define MAP_MPUEnable \
+        MPUEnable
+#endif
+#ifdef ROM_MPUDisable
+#define MAP_MPUDisable \
+        ROM_MPUDisable
+#else
+#define MAP_MPUDisable \
+        MPUDisable
+#endif
+#ifdef ROM_MPURegionCountGet
+#define MAP_MPURegionCountGet \
+        ROM_MPURegionCountGet
+#else
+#define MAP_MPURegionCountGet \
+        MPURegionCountGet
+#endif
+#ifdef ROM_MPURegionEnable
+#define MAP_MPURegionEnable \
+        ROM_MPURegionEnable
+#else
+#define MAP_MPURegionEnable \
+        MPURegionEnable
+#endif
+#ifdef ROM_MPURegionDisable
+#define MAP_MPURegionDisable \
+        ROM_MPURegionDisable
+#else
+#define MAP_MPURegionDisable \
+        MPURegionDisable
+#endif
+#ifdef ROM_MPURegionSet
+#define MAP_MPURegionSet \
+        ROM_MPURegionSet
+#else
+#define MAP_MPURegionSet \
+        MPURegionSet
+#endif
+#ifdef ROM_MPURegionGet
+#define MAP_MPURegionGet \
+        ROM_MPURegionGet
+#else
+#define MAP_MPURegionGet \
+        MPURegionGet
+#endif
+
+//*****************************************************************************
+//
+// Macros for the PWM API.
+//
+//*****************************************************************************
+#ifdef ROM_PWMPulseWidthSet
+#define MAP_PWMPulseWidthSet \
+        ROM_PWMPulseWidthSet
+#else
+#define MAP_PWMPulseWidthSet \
+        PWMPulseWidthSet
+#endif
+#ifdef ROM_PWMGenConfigure
+#define MAP_PWMGenConfigure \
+        ROM_PWMGenConfigure
+#else
+#define MAP_PWMGenConfigure \
+        PWMGenConfigure
+#endif
+#ifdef ROM_PWMGenPeriodSet
+#define MAP_PWMGenPeriodSet \
+        ROM_PWMGenPeriodSet
+#else
+#define MAP_PWMGenPeriodSet \
+        PWMGenPeriodSet
+#endif
+#ifdef ROM_PWMGenPeriodGet
+#define MAP_PWMGenPeriodGet \
+        ROM_PWMGenPeriodGet
+#else
+#define MAP_PWMGenPeriodGet \
+        PWMGenPeriodGet
+#endif
+#ifdef ROM_PWMGenEnable
+#define MAP_PWMGenEnable \
+        ROM_PWMGenEnable
+#else
+#define MAP_PWMGenEnable \
+        PWMGenEnable
+#endif
+#ifdef ROM_PWMGenDisable
+#define MAP_PWMGenDisable \
+        ROM_PWMGenDisable
+#else
+#define MAP_PWMGenDisable \
+        PWMGenDisable
+#endif
+#ifdef ROM_PWMPulseWidthGet
+#define MAP_PWMPulseWidthGet \
+        ROM_PWMPulseWidthGet
+#else
+#define MAP_PWMPulseWidthGet \
+        PWMPulseWidthGet
+#endif
+#ifdef ROM_PWMDeadBandEnable
+#define MAP_PWMDeadBandEnable \
+        ROM_PWMDeadBandEnable
+#else
+#define MAP_PWMDeadBandEnable \
+        PWMDeadBandEnable
+#endif
+#ifdef ROM_PWMDeadBandDisable
+#define MAP_PWMDeadBandDisable \
+        ROM_PWMDeadBandDisable
+#else
+#define MAP_PWMDeadBandDisable \
+        PWMDeadBandDisable
+#endif
+#ifdef ROM_PWMSyncUpdate
+#define MAP_PWMSyncUpdate \
+        ROM_PWMSyncUpdate
+#else
+#define MAP_PWMSyncUpdate \
+        PWMSyncUpdate
+#endif
+#ifdef ROM_PWMSyncTimeBase
+#define MAP_PWMSyncTimeBase \
+        ROM_PWMSyncTimeBase
+#else
+#define MAP_PWMSyncTimeBase \
+        PWMSyncTimeBase
+#endif
+#ifdef ROM_PWMOutputState
+#define MAP_PWMOutputState \
+        ROM_PWMOutputState
+#else
+#define MAP_PWMOutputState \
+        PWMOutputState
+#endif
+#ifdef ROM_PWMOutputInvert
+#define MAP_PWMOutputInvert \
+        ROM_PWMOutputInvert
+#else
+#define MAP_PWMOutputInvert \
+        PWMOutputInvert
+#endif
+#ifdef ROM_PWMOutputFault
+#define MAP_PWMOutputFault \
+        ROM_PWMOutputFault
+#else
+#define MAP_PWMOutputFault \
+        PWMOutputFault
+#endif
+#ifdef ROM_PWMGenIntTrigEnable
+#define MAP_PWMGenIntTrigEnable \
+        ROM_PWMGenIntTrigEnable
+#else
+#define MAP_PWMGenIntTrigEnable \
+        PWMGenIntTrigEnable
+#endif
+#ifdef ROM_PWMGenIntTrigDisable
+#define MAP_PWMGenIntTrigDisable \
+        ROM_PWMGenIntTrigDisable
+#else
+#define MAP_PWMGenIntTrigDisable \
+        PWMGenIntTrigDisable
+#endif
+#ifdef ROM_PWMGenIntStatus
+#define MAP_PWMGenIntStatus \
+        ROM_PWMGenIntStatus
+#else
+#define MAP_PWMGenIntStatus \
+        PWMGenIntStatus
+#endif
+#ifdef ROM_PWMGenIntClear
+#define MAP_PWMGenIntClear \
+        ROM_PWMGenIntClear
+#else
+#define MAP_PWMGenIntClear \
+        PWMGenIntClear
+#endif
+#ifdef ROM_PWMIntEnable
+#define MAP_PWMIntEnable \
+        ROM_PWMIntEnable
+#else
+#define MAP_PWMIntEnable \
+        PWMIntEnable
+#endif
+#ifdef ROM_PWMIntDisable
+#define MAP_PWMIntDisable \
+        ROM_PWMIntDisable
+#else
+#define MAP_PWMIntDisable \
+        PWMIntDisable
+#endif
+#ifdef ROM_PWMFaultIntClear
+#define MAP_PWMFaultIntClear \
+        ROM_PWMFaultIntClear
+#else
+#define MAP_PWMFaultIntClear \
+        PWMFaultIntClear
+#endif
+#ifdef ROM_PWMIntStatus
+#define MAP_PWMIntStatus \
+        ROM_PWMIntStatus
+#else
+#define MAP_PWMIntStatus \
+        PWMIntStatus
+#endif
+#ifdef ROM_PWMOutputFaultLevel
+#define MAP_PWMOutputFaultLevel \
+        ROM_PWMOutputFaultLevel
+#else
+#define MAP_PWMOutputFaultLevel \
+        PWMOutputFaultLevel
+#endif
+#ifdef ROM_PWMFaultIntClearExt
+#define MAP_PWMFaultIntClearExt \
+        ROM_PWMFaultIntClearExt
+#else
+#define MAP_PWMFaultIntClearExt \
+        PWMFaultIntClearExt
+#endif
+#ifdef ROM_PWMGenFaultConfigure
+#define MAP_PWMGenFaultConfigure \
+        ROM_PWMGenFaultConfigure
+#else
+#define MAP_PWMGenFaultConfigure \
+        PWMGenFaultConfigure
+#endif
+#ifdef ROM_PWMGenFaultTriggerSet
+#define MAP_PWMGenFaultTriggerSet \
+        ROM_PWMGenFaultTriggerSet
+#else
+#define MAP_PWMGenFaultTriggerSet \
+        PWMGenFaultTriggerSet
+#endif
+#ifdef ROM_PWMGenFaultTriggerGet
+#define MAP_PWMGenFaultTriggerGet \
+        ROM_PWMGenFaultTriggerGet
+#else
+#define MAP_PWMGenFaultTriggerGet \
+        PWMGenFaultTriggerGet
+#endif
+#ifdef ROM_PWMGenFaultStatus
+#define MAP_PWMGenFaultStatus \
+        ROM_PWMGenFaultStatus
+#else
+#define MAP_PWMGenFaultStatus \
+        PWMGenFaultStatus
+#endif
+#ifdef ROM_PWMGenFaultClear
+#define MAP_PWMGenFaultClear \
+        ROM_PWMGenFaultClear
+#else
+#define MAP_PWMGenFaultClear \
+        PWMGenFaultClear
+#endif
+
+//*****************************************************************************
+//
+// Macros for the QEI API.
+//
+//*****************************************************************************
+#ifdef ROM_QEIPositionGet
+#define MAP_QEIPositionGet \
+        ROM_QEIPositionGet
+#else
+#define MAP_QEIPositionGet \
+        QEIPositionGet
+#endif
+#ifdef ROM_QEIEnable
+#define MAP_QEIEnable \
+        ROM_QEIEnable
+#else
+#define MAP_QEIEnable \
+        QEIEnable
+#endif
+#ifdef ROM_QEIDisable
+#define MAP_QEIDisable \
+        ROM_QEIDisable
+#else
+#define MAP_QEIDisable \
+        QEIDisable
+#endif
+#ifdef ROM_QEIConfigure
+#define MAP_QEIConfigure \
+        ROM_QEIConfigure
+#else
+#define MAP_QEIConfigure \
+        QEIConfigure
+#endif
+#ifdef ROM_QEIPositionSet
+#define MAP_QEIPositionSet \
+        ROM_QEIPositionSet
+#else
+#define MAP_QEIPositionSet \
+        QEIPositionSet
+#endif
+#ifdef ROM_QEIDirectionGet
+#define MAP_QEIDirectionGet \
+        ROM_QEIDirectionGet
+#else
+#define MAP_QEIDirectionGet \
+        QEIDirectionGet
+#endif
+#ifdef ROM_QEIErrorGet
+#define MAP_QEIErrorGet \
+        ROM_QEIErrorGet
+#else
+#define MAP_QEIErrorGet \
+        QEIErrorGet
+#endif
+#ifdef ROM_QEIVelocityEnable
+#define MAP_QEIVelocityEnable \
+        ROM_QEIVelocityEnable
+#else
+#define MAP_QEIVelocityEnable \
+        QEIVelocityEnable
+#endif
+#ifdef ROM_QEIVelocityDisable
+#define MAP_QEIVelocityDisable \
+        ROM_QEIVelocityDisable
+#else
+#define MAP_QEIVelocityDisable \
+        QEIVelocityDisable
+#endif
+#ifdef ROM_QEIVelocityConfigure
+#define MAP_QEIVelocityConfigure \
+        ROM_QEIVelocityConfigure
+#else
+#define MAP_QEIVelocityConfigure \
+        QEIVelocityConfigure
+#endif
+#ifdef ROM_QEIVelocityGet
+#define MAP_QEIVelocityGet \
+        ROM_QEIVelocityGet
+#else
+#define MAP_QEIVelocityGet \
+        QEIVelocityGet
+#endif
+#ifdef ROM_QEIIntEnable
+#define MAP_QEIIntEnable \
+        ROM_QEIIntEnable
+#else
+#define MAP_QEIIntEnable \
+        QEIIntEnable
+#endif
+#ifdef ROM_QEIIntDisable
+#define MAP_QEIIntDisable \
+        ROM_QEIIntDisable
+#else
+#define MAP_QEIIntDisable \
+        QEIIntDisable
+#endif
+#ifdef ROM_QEIIntStatus
+#define MAP_QEIIntStatus \
+        ROM_QEIIntStatus
+#else
+#define MAP_QEIIntStatus \
+        QEIIntStatus
+#endif
+#ifdef ROM_QEIIntClear
+#define MAP_QEIIntClear \
+        ROM_QEIIntClear
+#else
+#define MAP_QEIIntClear \
+        QEIIntClear
+#endif
+
+//*****************************************************************************
+//
+// Macros for the SSI API.
+//
+//*****************************************************************************
+#ifdef ROM_SSIDataPut
+#define MAP_SSIDataPut \
+        ROM_SSIDataPut
+#else
+#define MAP_SSIDataPut \
+        SSIDataPut
+#endif
+#ifdef ROM_SSIConfigSetExpClk
+#define MAP_SSIConfigSetExpClk \
+        ROM_SSIConfigSetExpClk
+#else
+#define MAP_SSIConfigSetExpClk \
+        SSIConfigSetExpClk
+#endif
+#ifdef ROM_SSIEnable
+#define MAP_SSIEnable \
+        ROM_SSIEnable
+#else
+#define MAP_SSIEnable \
+        SSIEnable
+#endif
+#ifdef ROM_SSIDisable
+#define MAP_SSIDisable \
+        ROM_SSIDisable
+#else
+#define MAP_SSIDisable \
+        SSIDisable
+#endif
+#ifdef ROM_SSIIntEnable
+#define MAP_SSIIntEnable \
+        ROM_SSIIntEnable
+#else
+#define MAP_SSIIntEnable \
+        SSIIntEnable
+#endif
+#ifdef ROM_SSIIntDisable
+#define MAP_SSIIntDisable \
+        ROM_SSIIntDisable
+#else
+#define MAP_SSIIntDisable \
+        SSIIntDisable
+#endif
+#ifdef ROM_SSIIntStatus
+#define MAP_SSIIntStatus \
+        ROM_SSIIntStatus
+#else
+#define MAP_SSIIntStatus \
+        SSIIntStatus
+#endif
+#ifdef ROM_SSIIntClear
+#define MAP_SSIIntClear \
+        ROM_SSIIntClear
+#else
+#define MAP_SSIIntClear \
+        SSIIntClear
+#endif
+#ifdef ROM_SSIDataPutNonBlocking
+#define MAP_SSIDataPutNonBlocking \
+        ROM_SSIDataPutNonBlocking
+#else
+#define MAP_SSIDataPutNonBlocking \
+        SSIDataPutNonBlocking
+#endif
+#ifdef ROM_SSIDataGet
+#define MAP_SSIDataGet \
+        ROM_SSIDataGet
+#else
+#define MAP_SSIDataGet \
+        SSIDataGet
+#endif
+#ifdef ROM_SSIDataGetNonBlocking
+#define MAP_SSIDataGetNonBlocking \
+        ROM_SSIDataGetNonBlocking
+#else
+#define MAP_SSIDataGetNonBlocking \
+        SSIDataGetNonBlocking
+#endif
+#ifdef ROM_SSIDMAEnable
+#define MAP_SSIDMAEnable \
+        ROM_SSIDMAEnable
+#else
+#define MAP_SSIDMAEnable \
+        SSIDMAEnable
+#endif
+#ifdef ROM_SSIDMADisable
+#define MAP_SSIDMADisable \
+        ROM_SSIDMADisable
+#else
+#define MAP_SSIDMADisable \
+        SSIDMADisable
+#endif
+
+//*****************************************************************************
+//
+// Macros for the SysCtl API.
+//
+//*****************************************************************************
+#ifdef ROM_SysCtlSleep
+#define MAP_SysCtlSleep \
+        ROM_SysCtlSleep
+#else
+#define MAP_SysCtlSleep \
+        SysCtlSleep
+#endif
+#ifdef ROM_SysCtlSRAMSizeGet
+#define MAP_SysCtlSRAMSizeGet \
+        ROM_SysCtlSRAMSizeGet
+#else
+#define MAP_SysCtlSRAMSizeGet \
+        SysCtlSRAMSizeGet
+#endif
+#ifdef ROM_SysCtlFlashSizeGet
+#define MAP_SysCtlFlashSizeGet \
+        ROM_SysCtlFlashSizeGet
+#else
+#define MAP_SysCtlFlashSizeGet \
+        SysCtlFlashSizeGet
+#endif
+#ifdef ROM_SysCtlPinPresent
+#define MAP_SysCtlPinPresent \
+        ROM_SysCtlPinPresent
+#else
+#define MAP_SysCtlPinPresent \
+        SysCtlPinPresent
+#endif
+#ifdef ROM_SysCtlPeripheralPresent
+#define MAP_SysCtlPeripheralPresent \
+        ROM_SysCtlPeripheralPresent
+#else
+#define MAP_SysCtlPeripheralPresent \
+        SysCtlPeripheralPresent
+#endif
+#ifdef ROM_SysCtlPeripheralReset
+#define MAP_SysCtlPeripheralReset \
+        ROM_SysCtlPeripheralReset
+#else
+#define MAP_SysCtlPeripheralReset \
+        SysCtlPeripheralReset
+#endif
+#ifdef ROM_SysCtlPeripheralEnable
+#define MAP_SysCtlPeripheralEnable \
+        ROM_SysCtlPeripheralEnable
+#else
+#define MAP_SysCtlPeripheralEnable \
+        SysCtlPeripheralEnable
+#endif
+#ifdef ROM_SysCtlPeripheralDisable
+#define MAP_SysCtlPeripheralDisable \
+        ROM_SysCtlPeripheralDisable
+#else
+#define MAP_SysCtlPeripheralDisable \
+        SysCtlPeripheralDisable
+#endif
+#ifdef ROM_SysCtlPeripheralSleepEnable
+#define MAP_SysCtlPeripheralSleepEnable \
+        ROM_SysCtlPeripheralSleepEnable
+#else
+#define MAP_SysCtlPeripheralSleepEnable \
+        SysCtlPeripheralSleepEnable
+#endif
+#ifdef ROM_SysCtlPeripheralSleepDisable
+#define MAP_SysCtlPeripheralSleepDisable \
+        ROM_SysCtlPeripheralSleepDisable
+#else
+#define MAP_SysCtlPeripheralSleepDisable \
+        SysCtlPeripheralSleepDisable
+#endif
+#ifdef ROM_SysCtlPeripheralDeepSleepEnable
+#define MAP_SysCtlPeripheralDeepSleepEnable \
+        ROM_SysCtlPeripheralDeepSleepEnable
+#else
+#define MAP_SysCtlPeripheralDeepSleepEnable \
+        SysCtlPeripheralDeepSleepEnable
+#endif
+#ifdef ROM_SysCtlPeripheralDeepSleepDisable
+#define MAP_SysCtlPeripheralDeepSleepDisable \
+        ROM_SysCtlPeripheralDeepSleepDisable
+#else
+#define MAP_SysCtlPeripheralDeepSleepDisable \
+        SysCtlPeripheralDeepSleepDisable
+#endif
+#ifdef ROM_SysCtlPeripheralClockGating
+#define MAP_SysCtlPeripheralClockGating \
+        ROM_SysCtlPeripheralClockGating
+#else
+#define MAP_SysCtlPeripheralClockGating \
+        SysCtlPeripheralClockGating
+#endif
+#ifdef ROM_SysCtlIntEnable
+#define MAP_SysCtlIntEnable \
+        ROM_SysCtlIntEnable
+#else
+#define MAP_SysCtlIntEnable \
+        SysCtlIntEnable
+#endif
+#ifdef ROM_SysCtlIntDisable
+#define MAP_SysCtlIntDisable \
+        ROM_SysCtlIntDisable
+#else
+#define MAP_SysCtlIntDisable \
+        SysCtlIntDisable
+#endif
+#ifdef ROM_SysCtlIntClear
+#define MAP_SysCtlIntClear \
+        ROM_SysCtlIntClear
+#else
+#define MAP_SysCtlIntClear \
+        SysCtlIntClear
+#endif
+#ifdef ROM_SysCtlIntStatus
+#define MAP_SysCtlIntStatus \
+        ROM_SysCtlIntStatus
+#else
+#define MAP_SysCtlIntStatus \
+        SysCtlIntStatus
+#endif
+#ifdef ROM_SysCtlLDOSet
+#define MAP_SysCtlLDOSet \
+        ROM_SysCtlLDOSet
+#else
+#define MAP_SysCtlLDOSet \
+        SysCtlLDOSet
+#endif
+#ifdef ROM_SysCtlLDOGet
+#define MAP_SysCtlLDOGet \
+        ROM_SysCtlLDOGet
+#else
+#define MAP_SysCtlLDOGet \
+        SysCtlLDOGet
+#endif
+#ifdef ROM_SysCtlReset
+#define MAP_SysCtlReset \
+        ROM_SysCtlReset
+#else
+#define MAP_SysCtlReset \
+        SysCtlReset
+#endif
+#ifdef ROM_SysCtlDeepSleep
+#define MAP_SysCtlDeepSleep \
+        ROM_SysCtlDeepSleep
+#else
+#define MAP_SysCtlDeepSleep \
+        SysCtlDeepSleep
+#endif
+#ifdef ROM_SysCtlResetCauseGet
+#define MAP_SysCtlResetCauseGet \
+        ROM_SysCtlResetCauseGet
+#else
+#define MAP_SysCtlResetCauseGet \
+        SysCtlResetCauseGet
+#endif
+#ifdef ROM_SysCtlResetCauseClear
+#define MAP_SysCtlResetCauseClear \
+        ROM_SysCtlResetCauseClear
+#else
+#define MAP_SysCtlResetCauseClear \
+        SysCtlResetCauseClear
+#endif
+#ifdef ROM_SysCtlClockSet
+#define MAP_SysCtlClockSet \
+        ROM_SysCtlClockSet
+#else
+#define MAP_SysCtlClockSet \
+        SysCtlClockSet
+#endif
+#ifdef ROM_SysCtlClockGet
+#define MAP_SysCtlClockGet \
+        ROM_SysCtlClockGet
+#else
+#define MAP_SysCtlClockGet \
+        SysCtlClockGet
+#endif
+#ifdef ROM_SysCtlPWMClockSet
+#define MAP_SysCtlPWMClockSet \
+        ROM_SysCtlPWMClockSet
+#else
+#define MAP_SysCtlPWMClockSet \
+        SysCtlPWMClockSet
+#endif
+#ifdef ROM_SysCtlPWMClockGet
+#define MAP_SysCtlPWMClockGet \
+        ROM_SysCtlPWMClockGet
+#else
+#define MAP_SysCtlPWMClockGet \
+        SysCtlPWMClockGet
+#endif
+#ifdef ROM_SysCtlADCSpeedSet
+#define MAP_SysCtlADCSpeedSet \
+        ROM_SysCtlADCSpeedSet
+#else
+#define MAP_SysCtlADCSpeedSet \
+        SysCtlADCSpeedSet
+#endif
+#ifdef ROM_SysCtlADCSpeedGet
+#define MAP_SysCtlADCSpeedGet \
+        ROM_SysCtlADCSpeedGet
+#else
+#define MAP_SysCtlADCSpeedGet \
+        SysCtlADCSpeedGet
+#endif
+#ifdef ROM_SysCtlGPIOAHBEnable
+#define MAP_SysCtlGPIOAHBEnable \
+        ROM_SysCtlGPIOAHBEnable
+#else
+#define MAP_SysCtlGPIOAHBEnable \
+        SysCtlGPIOAHBEnable
+#endif
+#ifdef ROM_SysCtlGPIOAHBDisable
+#define MAP_SysCtlGPIOAHBDisable \
+        ROM_SysCtlGPIOAHBDisable
+#else
+#define MAP_SysCtlGPIOAHBDisable \
+        SysCtlGPIOAHBDisable
+#endif
+#ifdef ROM_SysCtlUSBPLLEnable
+#define MAP_SysCtlUSBPLLEnable \
+        ROM_SysCtlUSBPLLEnable
+#else
+#define MAP_SysCtlUSBPLLEnable \
+        SysCtlUSBPLLEnable
+#endif
+#ifdef ROM_SysCtlUSBPLLDisable
+#define MAP_SysCtlUSBPLLDisable \
+        ROM_SysCtlUSBPLLDisable
+#else
+#define MAP_SysCtlUSBPLLDisable \
+        SysCtlUSBPLLDisable
+#endif
+
+//*****************************************************************************
+//
+// Macros for the SysTick API.
+//
+//*****************************************************************************
+#ifdef ROM_SysTickValueGet
+#define MAP_SysTickValueGet \
+        ROM_SysTickValueGet
+#else
+#define MAP_SysTickValueGet \
+        SysTickValueGet
+#endif
+#ifdef ROM_SysTickEnable
+#define MAP_SysTickEnable \
+        ROM_SysTickEnable
+#else
+#define MAP_SysTickEnable \
+        SysTickEnable
+#endif
+#ifdef ROM_SysTickDisable
+#define MAP_SysTickDisable \
+        ROM_SysTickDisable
+#else
+#define MAP_SysTickDisable \
+        SysTickDisable
+#endif
+#ifdef ROM_SysTickIntEnable
+#define MAP_SysTickIntEnable \
+        ROM_SysTickIntEnable
+#else
+#define MAP_SysTickIntEnable \
+        SysTickIntEnable
+#endif
+#ifdef ROM_SysTickIntDisable
+#define MAP_SysTickIntDisable \
+        ROM_SysTickIntDisable
+#else
+#define MAP_SysTickIntDisable \
+        SysTickIntDisable
+#endif
+#ifdef ROM_SysTickPeriodSet
+#define MAP_SysTickPeriodSet \
+        ROM_SysTickPeriodSet
+#else
+#define MAP_SysTickPeriodSet \
+        SysTickPeriodSet
+#endif
+#ifdef ROM_SysTickPeriodGet
+#define MAP_SysTickPeriodGet \
+        ROM_SysTickPeriodGet
+#else
+#define MAP_SysTickPeriodGet \
+        SysTickPeriodGet
+#endif
+
+//*****************************************************************************
+//
+// Macros for the Timer API.
+//
+//*****************************************************************************
+#ifdef ROM_TimerIntClear
+#define MAP_TimerIntClear \
+        ROM_TimerIntClear
+#else
+#define MAP_TimerIntClear \
+        TimerIntClear
+#endif
+#ifdef ROM_TimerEnable
+#define MAP_TimerEnable \
+        ROM_TimerEnable
+#else
+#define MAP_TimerEnable \
+        TimerEnable
+#endif
+#ifdef ROM_TimerDisable
+#define MAP_TimerDisable \
+        ROM_TimerDisable
+#else
+#define MAP_TimerDisable \
+        TimerDisable
+#endif
+#ifdef ROM_TimerConfigure
+#define MAP_TimerConfigure \
+        ROM_TimerConfigure
+#else
+#define MAP_TimerConfigure \
+        TimerConfigure
+#endif
+#ifdef ROM_TimerControlLevel
+#define MAP_TimerControlLevel \
+        ROM_TimerControlLevel
+#else
+#define MAP_TimerControlLevel \
+        TimerControlLevel
+#endif
+#ifdef ROM_TimerControlTrigger
+#define MAP_TimerControlTrigger \
+        ROM_TimerControlTrigger
+#else
+#define MAP_TimerControlTrigger \
+        TimerControlTrigger
+#endif
+#ifdef ROM_TimerControlEvent
+#define MAP_TimerControlEvent \
+        ROM_TimerControlEvent
+#else
+#define MAP_TimerControlEvent \
+        TimerControlEvent
+#endif
+#ifdef ROM_TimerControlStall
+#define MAP_TimerControlStall \
+        ROM_TimerControlStall
+#else
+#define MAP_TimerControlStall \
+        TimerControlStall
+#endif
+#ifdef ROM_TimerRTCEnable
+#define MAP_TimerRTCEnable \
+        ROM_TimerRTCEnable
+#else
+#define MAP_TimerRTCEnable \
+        TimerRTCEnable
+#endif
+#ifdef ROM_TimerRTCDisable
+#define MAP_TimerRTCDisable \
+        ROM_TimerRTCDisable
+#else
+#define MAP_TimerRTCDisable \
+        TimerRTCDisable
+#endif
+#ifdef ROM_TimerPrescaleSet
+#define MAP_TimerPrescaleSet \
+        ROM_TimerPrescaleSet
+#else
+#define MAP_TimerPrescaleSet \
+        TimerPrescaleSet
+#endif
+#ifdef ROM_TimerPrescaleGet
+#define MAP_TimerPrescaleGet \
+        ROM_TimerPrescaleGet
+#else
+#define MAP_TimerPrescaleGet \
+        TimerPrescaleGet
+#endif
+#ifdef ROM_TimerLoadSet
+#define MAP_TimerLoadSet \
+        ROM_TimerLoadSet
+#else
+#define MAP_TimerLoadSet \
+        TimerLoadSet
+#endif
+#ifdef ROM_TimerLoadGet
+#define MAP_TimerLoadGet \
+        ROM_TimerLoadGet
+#else
+#define MAP_TimerLoadGet \
+        TimerLoadGet
+#endif
+#ifdef ROM_TimerValueGet
+#define MAP_TimerValueGet \
+        ROM_TimerValueGet
+#else
+#define MAP_TimerValueGet \
+        TimerValueGet
+#endif
+#ifdef ROM_TimerMatchSet
+#define MAP_TimerMatchSet \
+        ROM_TimerMatchSet
+#else
+#define MAP_TimerMatchSet \
+        TimerMatchSet
+#endif
+#ifdef ROM_TimerMatchGet
+#define MAP_TimerMatchGet \
+        ROM_TimerMatchGet
+#else
+#define MAP_TimerMatchGet \
+        TimerMatchGet
+#endif
+#ifdef ROM_TimerIntEnable
+#define MAP_TimerIntEnable \
+        ROM_TimerIntEnable
+#else
+#define MAP_TimerIntEnable \
+        TimerIntEnable
+#endif
+#ifdef ROM_TimerIntDisable
+#define MAP_TimerIntDisable \
+        ROM_TimerIntDisable
+#else
+#define MAP_TimerIntDisable \
+        TimerIntDisable
+#endif
+#ifdef ROM_TimerIntStatus
+#define MAP_TimerIntStatus \
+        ROM_TimerIntStatus
+#else
+#define MAP_TimerIntStatus \
+        TimerIntStatus
+#endif
+
+//*****************************************************************************
+//
+// Macros for the UART API.
+//
+//*****************************************************************************
+#ifdef ROM_UARTCharPut
+#define MAP_UARTCharPut \
+        ROM_UARTCharPut
+#else
+#define MAP_UARTCharPut \
+        UARTCharPut
+#endif
+#ifdef ROM_UARTParityModeSet
+#define MAP_UARTParityModeSet \
+        ROM_UARTParityModeSet
+#else
+#define MAP_UARTParityModeSet \
+        UARTParityModeSet
+#endif
+#ifdef ROM_UARTParityModeGet
+#define MAP_UARTParityModeGet \
+        ROM_UARTParityModeGet
+#else
+#define MAP_UARTParityModeGet \
+        UARTParityModeGet
+#endif
+#ifdef ROM_UARTFIFOLevelSet
+#define MAP_UARTFIFOLevelSet \
+        ROM_UARTFIFOLevelSet
+#else
+#define MAP_UARTFIFOLevelSet \
+        UARTFIFOLevelSet
+#endif
+#ifdef ROM_UARTFIFOLevelGet
+#define MAP_UARTFIFOLevelGet \
+        ROM_UARTFIFOLevelGet
+#else
+#define MAP_UARTFIFOLevelGet \
+        UARTFIFOLevelGet
+#endif
+#ifdef ROM_UARTConfigSetExpClk
+#define MAP_UARTConfigSetExpClk \
+        ROM_UARTConfigSetExpClk
+#else
+#define MAP_UARTConfigSetExpClk \
+        UARTConfigSetExpClk
+#endif
+#ifdef ROM_UARTConfigGetExpClk
+#define MAP_UARTConfigGetExpClk \
+        ROM_UARTConfigGetExpClk
+#else
+#define MAP_UARTConfigGetExpClk \
+        UARTConfigGetExpClk
+#endif
+#ifdef ROM_UARTEnable
+#define MAP_UARTEnable \
+        ROM_UARTEnable
+#else
+#define MAP_UARTEnable \
+        UARTEnable
+#endif
+#ifdef ROM_UARTDisable
+#define MAP_UARTDisable \
+        ROM_UARTDisable
+#else
+#define MAP_UARTDisable \
+        UARTDisable
+#endif
+#ifdef ROM_UARTEnableSIR
+#define MAP_UARTEnableSIR \
+        ROM_UARTEnableSIR
+#else
+#define MAP_UARTEnableSIR \
+        UARTEnableSIR
+#endif
+#ifdef ROM_UARTDisableSIR
+#define MAP_UARTDisableSIR \
+        ROM_UARTDisableSIR
+#else
+#define MAP_UARTDisableSIR \
+        UARTDisableSIR
+#endif
+#ifdef ROM_UARTCharsAvail
+#define MAP_UARTCharsAvail \
+        ROM_UARTCharsAvail
+#else
+#define MAP_UARTCharsAvail \
+        UARTCharsAvail
+#endif
+#ifdef ROM_UARTSpaceAvail
+#define MAP_UARTSpaceAvail \
+        ROM_UARTSpaceAvail
+#else
+#define MAP_UARTSpaceAvail \
+        UARTSpaceAvail
+#endif
+#ifdef ROM_UARTCharGetNonBlocking
+#define MAP_UARTCharGetNonBlocking \
+        ROM_UARTCharGetNonBlocking
+#else
+#define MAP_UARTCharGetNonBlocking \
+        UARTCharGetNonBlocking
+#endif
+#ifdef ROM_UARTCharGet
+#define MAP_UARTCharGet \
+        ROM_UARTCharGet
+#else
+#define MAP_UARTCharGet \
+        UARTCharGet
+#endif
+#ifdef ROM_UARTCharPutNonBlocking
+#define MAP_UARTCharPutNonBlocking \
+        ROM_UARTCharPutNonBlocking
+#else
+#define MAP_UARTCharPutNonBlocking \
+        UARTCharPutNonBlocking
+#endif
+#ifdef ROM_UARTBreakCtl
+#define MAP_UARTBreakCtl \
+        ROM_UARTBreakCtl
+#else
+#define MAP_UARTBreakCtl \
+        UARTBreakCtl
+#endif
+#ifdef ROM_UARTIntEnable
+#define MAP_UARTIntEnable \
+        ROM_UARTIntEnable
+#else
+#define MAP_UARTIntEnable \
+        UARTIntEnable
+#endif
+#ifdef ROM_UARTIntDisable
+#define MAP_UARTIntDisable \
+        ROM_UARTIntDisable
+#else
+#define MAP_UARTIntDisable \
+        UARTIntDisable
+#endif
+#ifdef ROM_UARTIntStatus
+#define MAP_UARTIntStatus \
+        ROM_UARTIntStatus
+#else
+#define MAP_UARTIntStatus \
+        UARTIntStatus
+#endif
+#ifdef ROM_UARTIntClear
+#define MAP_UARTIntClear \
+        ROM_UARTIntClear
+#else
+#define MAP_UARTIntClear \
+        UARTIntClear
+#endif
+#ifdef ROM_UARTDMAEnable
+#define MAP_UARTDMAEnable \
+        ROM_UARTDMAEnable
+#else
+#define MAP_UARTDMAEnable \
+        UARTDMAEnable
+#endif
+#ifdef ROM_UARTDMADisable
+#define MAP_UARTDMADisable \
+        ROM_UARTDMADisable
+#else
+#define MAP_UARTDMADisable \
+        UARTDMADisable
+#endif
+
+//*****************************************************************************
+//
+// Macros for the uDMA API.
+//
+//*****************************************************************************
+#ifdef ROM_uDMAChannelTransferSet
+#define MAP_uDMAChannelTransferSet \
+        ROM_uDMAChannelTransferSet
+#else
+#define MAP_uDMAChannelTransferSet \
+        uDMAChannelTransferSet
+#endif
+#ifdef ROM_uDMAEnable
+#define MAP_uDMAEnable \
+        ROM_uDMAEnable
+#else
+#define MAP_uDMAEnable \
+        uDMAEnable
+#endif
+#ifdef ROM_uDMADisable
+#define MAP_uDMADisable \
+        ROM_uDMADisable
+#else
+#define MAP_uDMADisable \
+        uDMADisable
+#endif
+#ifdef ROM_uDMAErrorStatusGet
+#define MAP_uDMAErrorStatusGet \
+        ROM_uDMAErrorStatusGet
+#else
+#define MAP_uDMAErrorStatusGet \
+        uDMAErrorStatusGet
+#endif
+#ifdef ROM_uDMAErrorStatusClear
+#define MAP_uDMAErrorStatusClear \
+        ROM_uDMAErrorStatusClear
+#else
+#define MAP_uDMAErrorStatusClear \
+        uDMAErrorStatusClear
+#endif
+#ifdef ROM_uDMAChannelEnable
+#define MAP_uDMAChannelEnable \
+        ROM_uDMAChannelEnable
+#else
+#define MAP_uDMAChannelEnable \
+        uDMAChannelEnable
+#endif
+#ifdef ROM_uDMAChannelDisable
+#define MAP_uDMAChannelDisable \
+        ROM_uDMAChannelDisable
+#else
+#define MAP_uDMAChannelDisable \
+        uDMAChannelDisable
+#endif
+#ifdef ROM_uDMAChannelIsEnabled
+#define MAP_uDMAChannelIsEnabled \
+        ROM_uDMAChannelIsEnabled
+#else
+#define MAP_uDMAChannelIsEnabled \
+        uDMAChannelIsEnabled
+#endif
+#ifdef ROM_uDMAControlBaseSet
+#define MAP_uDMAControlBaseSet \
+        ROM_uDMAControlBaseSet
+#else
+#define MAP_uDMAControlBaseSet \
+        uDMAControlBaseSet
+#endif
+#ifdef ROM_uDMAControlBaseGet
+#define MAP_uDMAControlBaseGet \
+        ROM_uDMAControlBaseGet
+#else
+#define MAP_uDMAControlBaseGet \
+        uDMAControlBaseGet
+#endif
+#ifdef ROM_uDMAChannelRequest
+#define MAP_uDMAChannelRequest \
+        ROM_uDMAChannelRequest
+#else
+#define MAP_uDMAChannelRequest \
+        uDMAChannelRequest
+#endif
+#ifdef ROM_uDMAChannelAttributeEnable
+#define MAP_uDMAChannelAttributeEnable \
+        ROM_uDMAChannelAttributeEnable
+#else
+#define MAP_uDMAChannelAttributeEnable \
+        uDMAChannelAttributeEnable
+#endif
+#ifdef ROM_uDMAChannelAttributeDisable
+#define MAP_uDMAChannelAttributeDisable \
+        ROM_uDMAChannelAttributeDisable
+#else
+#define MAP_uDMAChannelAttributeDisable \
+        uDMAChannelAttributeDisable
+#endif
+#ifdef ROM_uDMAChannelAttributeGet
+#define MAP_uDMAChannelAttributeGet \
+        ROM_uDMAChannelAttributeGet
+#else
+#define MAP_uDMAChannelAttributeGet \
+        uDMAChannelAttributeGet
+#endif
+#ifdef ROM_uDMAChannelControlSet
+#define MAP_uDMAChannelControlSet \
+        ROM_uDMAChannelControlSet
+#else
+#define MAP_uDMAChannelControlSet \
+        uDMAChannelControlSet
+#endif
+#ifdef ROM_uDMAChannelSizeGet
+#define MAP_uDMAChannelSizeGet \
+        ROM_uDMAChannelSizeGet
+#else
+#define MAP_uDMAChannelSizeGet \
+        uDMAChannelSizeGet
+#endif
+#ifdef ROM_uDMAChannelModeGet
+#define MAP_uDMAChannelModeGet \
+        ROM_uDMAChannelModeGet
+#else
+#define MAP_uDMAChannelModeGet \
+        uDMAChannelModeGet
+#endif
+
+//*****************************************************************************
+//
+// Macros for the USB API.
+//
+//*****************************************************************************
+#ifdef ROM_USBIntStatus
+#define MAP_USBIntStatus \
+        ROM_USBIntStatus
+#else
+#define MAP_USBIntStatus \
+        USBIntStatus
+#endif
+#ifdef ROM_USBDevAddrGet
+#define MAP_USBDevAddrGet \
+        ROM_USBDevAddrGet
+#else
+#define MAP_USBDevAddrGet \
+        USBDevAddrGet
+#endif
+#ifdef ROM_USBDevAddrSet
+#define MAP_USBDevAddrSet \
+        ROM_USBDevAddrSet
+#else
+#define MAP_USBDevAddrSet \
+        USBDevAddrSet
+#endif
+#ifdef ROM_USBDevConnect
+#define MAP_USBDevConnect \
+        ROM_USBDevConnect
+#else
+#define MAP_USBDevConnect \
+        USBDevConnect
+#endif
+#ifdef ROM_USBDevDisconnect
+#define MAP_USBDevDisconnect \
+        ROM_USBDevDisconnect
+#else
+#define MAP_USBDevDisconnect \
+        USBDevDisconnect
+#endif
+#ifdef ROM_USBDevEndpointConfig
+#define MAP_USBDevEndpointConfig \
+        ROM_USBDevEndpointConfig
+#else
+#define MAP_USBDevEndpointConfig \
+        USBDevEndpointConfig
+#endif
+#ifdef ROM_USBDevEndpointDataAck
+#define MAP_USBDevEndpointDataAck \
+        ROM_USBDevEndpointDataAck
+#else
+#define MAP_USBDevEndpointDataAck \
+        USBDevEndpointDataAck
+#endif
+#ifdef ROM_USBDevEndpointStall
+#define MAP_USBDevEndpointStall \
+        ROM_USBDevEndpointStall
+#else
+#define MAP_USBDevEndpointStall \
+        USBDevEndpointStall
+#endif
+#ifdef ROM_USBDevEndpointStallClear
+#define MAP_USBDevEndpointStallClear \
+        ROM_USBDevEndpointStallClear
+#else
+#define MAP_USBDevEndpointStallClear \
+        USBDevEndpointStallClear
+#endif
+#ifdef ROM_USBDevEndpointStatusClear
+#define MAP_USBDevEndpointStatusClear \
+        ROM_USBDevEndpointStatusClear
+#else
+#define MAP_USBDevEndpointStatusClear \
+        USBDevEndpointStatusClear
+#endif
+#ifdef ROM_USBEndpointDataGet
+#define MAP_USBEndpointDataGet \
+        ROM_USBEndpointDataGet
+#else
+#define MAP_USBEndpointDataGet \
+        USBEndpointDataGet
+#endif
+#ifdef ROM_USBEndpointDataPut
+#define MAP_USBEndpointDataPut \
+        ROM_USBEndpointDataPut
+#else
+#define MAP_USBEndpointDataPut \
+        USBEndpointDataPut
+#endif
+#ifdef ROM_USBEndpointDataSend
+#define MAP_USBEndpointDataSend \
+        ROM_USBEndpointDataSend
+#else
+#define MAP_USBEndpointDataSend \
+        USBEndpointDataSend
+#endif
+#ifdef ROM_USBEndpointDataToggleClear
+#define MAP_USBEndpointDataToggleClear \
+        ROM_USBEndpointDataToggleClear
+#else
+#define MAP_USBEndpointDataToggleClear \
+        USBEndpointDataToggleClear
+#endif
+#ifdef ROM_USBEndpointStatus
+#define MAP_USBEndpointStatus \
+        ROM_USBEndpointStatus
+#else
+#define MAP_USBEndpointStatus \
+        USBEndpointStatus
+#endif
+#ifdef ROM_USBFIFOAddrGet
+#define MAP_USBFIFOAddrGet \
+        ROM_USBFIFOAddrGet
+#else
+#define MAP_USBFIFOAddrGet \
+        USBFIFOAddrGet
+#endif
+#ifdef ROM_USBFIFOConfigGet
+#define MAP_USBFIFOConfigGet \
+        ROM_USBFIFOConfigGet
+#else
+#define MAP_USBFIFOConfigGet \
+        USBFIFOConfigGet
+#endif
+#ifdef ROM_USBFIFOConfigSet
+#define MAP_USBFIFOConfigSet \
+        ROM_USBFIFOConfigSet
+#else
+#define MAP_USBFIFOConfigSet \
+        USBFIFOConfigSet
+#endif
+#ifdef ROM_USBFIFOFlush
+#define MAP_USBFIFOFlush \
+        ROM_USBFIFOFlush
+#else
+#define MAP_USBFIFOFlush \
+        USBFIFOFlush
+#endif
+#ifdef ROM_USBFrameNumberGet
+#define MAP_USBFrameNumberGet \
+        ROM_USBFrameNumberGet
+#else
+#define MAP_USBFrameNumberGet \
+        USBFrameNumberGet
+#endif
+#ifdef ROM_USBHostAddrGet
+#define MAP_USBHostAddrGet \
+        ROM_USBHostAddrGet
+#else
+#define MAP_USBHostAddrGet \
+        USBHostAddrGet
+#endif
+#ifdef ROM_USBHostAddrSet
+#define MAP_USBHostAddrSet \
+        ROM_USBHostAddrSet
+#else
+#define MAP_USBHostAddrSet \
+        USBHostAddrSet
+#endif
+#ifdef ROM_USBHostEndpointConfig
+#define MAP_USBHostEndpointConfig \
+        ROM_USBHostEndpointConfig
+#else
+#define MAP_USBHostEndpointConfig \
+        USBHostEndpointConfig
+#endif
+#ifdef ROM_USBHostEndpointDataAck
+#define MAP_USBHostEndpointDataAck \
+        ROM_USBHostEndpointDataAck
+#else
+#define MAP_USBHostEndpointDataAck \
+        USBHostEndpointDataAck
+#endif
+#ifdef ROM_USBHostEndpointDataToggle
+#define MAP_USBHostEndpointDataToggle \
+        ROM_USBHostEndpointDataToggle
+#else
+#define MAP_USBHostEndpointDataToggle \
+        USBHostEndpointDataToggle
+#endif
+#ifdef ROM_USBHostEndpointStatusClear
+#define MAP_USBHostEndpointStatusClear \
+        ROM_USBHostEndpointStatusClear
+#else
+#define MAP_USBHostEndpointStatusClear \
+        USBHostEndpointStatusClear
+#endif
+#ifdef ROM_USBHostHubAddrGet
+#define MAP_USBHostHubAddrGet \
+        ROM_USBHostHubAddrGet
+#else
+#define MAP_USBHostHubAddrGet \
+        USBHostHubAddrGet
+#endif
+#ifdef ROM_USBHostHubAddrSet
+#define MAP_USBHostHubAddrSet \
+        ROM_USBHostHubAddrSet
+#else
+#define MAP_USBHostHubAddrSet \
+        USBHostHubAddrSet
+#endif
+#ifdef ROM_USBHostPwrDisable
+#define MAP_USBHostPwrDisable \
+        ROM_USBHostPwrDisable
+#else
+#define MAP_USBHostPwrDisable \
+        USBHostPwrDisable
+#endif
+#ifdef ROM_USBHostPwrEnable
+#define MAP_USBHostPwrEnable \
+        ROM_USBHostPwrEnable
+#else
+#define MAP_USBHostPwrEnable \
+        USBHostPwrEnable
+#endif
+#ifdef ROM_USBHostPwrFaultConfig
+#define MAP_USBHostPwrFaultConfig \
+        ROM_USBHostPwrFaultConfig
+#else
+#define MAP_USBHostPwrFaultConfig \
+        USBHostPwrFaultConfig
+#endif
+#ifdef ROM_USBHostPwrFaultDisable
+#define MAP_USBHostPwrFaultDisable \
+        ROM_USBHostPwrFaultDisable
+#else
+#define MAP_USBHostPwrFaultDisable \
+        USBHostPwrFaultDisable
+#endif
+#ifdef ROM_USBHostPwrFaultEnable
+#define MAP_USBHostPwrFaultEnable \
+        ROM_USBHostPwrFaultEnable
+#else
+#define MAP_USBHostPwrFaultEnable \
+        USBHostPwrFaultEnable
+#endif
+#ifdef ROM_USBHostRequestIN
+#define MAP_USBHostRequestIN \
+        ROM_USBHostRequestIN
+#else
+#define MAP_USBHostRequestIN \
+        USBHostRequestIN
+#endif
+#ifdef ROM_USBHostRequestStatus
+#define MAP_USBHostRequestStatus \
+        ROM_USBHostRequestStatus
+#else
+#define MAP_USBHostRequestStatus \
+        USBHostRequestStatus
+#endif
+#ifdef ROM_USBHostReset
+#define MAP_USBHostReset \
+        ROM_USBHostReset
+#else
+#define MAP_USBHostReset \
+        USBHostReset
+#endif
+#ifdef ROM_USBHostResume
+#define MAP_USBHostResume \
+        ROM_USBHostResume
+#else
+#define MAP_USBHostResume \
+        USBHostResume
+#endif
+#ifdef ROM_USBHostSpeedGet
+#define MAP_USBHostSpeedGet \
+        ROM_USBHostSpeedGet
+#else
+#define MAP_USBHostSpeedGet \
+        USBHostSpeedGet
+#endif
+#ifdef ROM_USBHostSuspend
+#define MAP_USBHostSuspend \
+        ROM_USBHostSuspend
+#else
+#define MAP_USBHostSuspend \
+        USBHostSuspend
+#endif
+#ifdef ROM_USBIntDisable
+#define MAP_USBIntDisable \
+        ROM_USBIntDisable
+#else
+#define MAP_USBIntDisable \
+        USBIntDisable
+#endif
+#ifdef ROM_USBIntEnable
+#define MAP_USBIntEnable \
+        ROM_USBIntEnable
+#else
+#define MAP_USBIntEnable \
+        USBIntEnable
+#endif
+
+//*****************************************************************************
+//
+// Macros for the Watchdog API.
+//
+//*****************************************************************************
+#ifdef ROM_WatchdogIntClear
+#define MAP_WatchdogIntClear \
+        ROM_WatchdogIntClear
+#else
+#define MAP_WatchdogIntClear \
+        WatchdogIntClear
+#endif
+#ifdef ROM_WatchdogRunning
+#define MAP_WatchdogRunning \
+        ROM_WatchdogRunning
+#else
+#define MAP_WatchdogRunning \
+        WatchdogRunning
+#endif
+#ifdef ROM_WatchdogEnable
+#define MAP_WatchdogEnable \
+        ROM_WatchdogEnable
+#else
+#define MAP_WatchdogEnable \
+        WatchdogEnable
+#endif
+#ifdef ROM_WatchdogResetEnable
+#define MAP_WatchdogResetEnable \
+        ROM_WatchdogResetEnable
+#else
+#define MAP_WatchdogResetEnable \
+        WatchdogResetEnable
+#endif
+#ifdef ROM_WatchdogResetDisable
+#define MAP_WatchdogResetDisable \
+        ROM_WatchdogResetDisable
+#else
+#define MAP_WatchdogResetDisable \
+        WatchdogResetDisable
+#endif
+#ifdef ROM_WatchdogLock
+#define MAP_WatchdogLock \
+        ROM_WatchdogLock
+#else
+#define MAP_WatchdogLock \
+        WatchdogLock
+#endif
+#ifdef ROM_WatchdogUnlock
+#define MAP_WatchdogUnlock \
+        ROM_WatchdogUnlock
+#else
+#define MAP_WatchdogUnlock \
+        WatchdogUnlock
+#endif
+#ifdef ROM_WatchdogLockState
+#define MAP_WatchdogLockState \
+        ROM_WatchdogLockState
+#else
+#define MAP_WatchdogLockState \
+        WatchdogLockState
+#endif
+#ifdef ROM_WatchdogReloadSet
+#define MAP_WatchdogReloadSet \
+        ROM_WatchdogReloadSet
+#else
+#define MAP_WatchdogReloadSet \
+        WatchdogReloadSet
+#endif
+#ifdef ROM_WatchdogReloadGet
+#define MAP_WatchdogReloadGet \
+        ROM_WatchdogReloadGet
+#else
+#define MAP_WatchdogReloadGet \
+        WatchdogReloadGet
+#endif
+#ifdef ROM_WatchdogValueGet
+#define MAP_WatchdogValueGet \
+        ROM_WatchdogValueGet
+#else
+#define MAP_WatchdogValueGet \
+        WatchdogValueGet
+#endif
+#ifdef ROM_WatchdogIntEnable
+#define MAP_WatchdogIntEnable \
+        ROM_WatchdogIntEnable
+#else
+#define MAP_WatchdogIntEnable \
+        WatchdogIntEnable
+#endif
+#ifdef ROM_WatchdogIntStatus
+#define MAP_WatchdogIntStatus \
+        ROM_WatchdogIntStatus
+#else
+#define MAP_WatchdogIntStatus \
+        WatchdogIntStatus
+#endif
+#ifdef ROM_WatchdogStallEnable
+#define MAP_WatchdogStallEnable \
+        ROM_WatchdogStallEnable
+#else
+#define MAP_WatchdogStallEnable \
+        WatchdogStallEnable
+#endif
+#ifdef ROM_WatchdogStallDisable
+#define MAP_WatchdogStallDisable \
+        ROM_WatchdogStallDisable
+#else
+#define MAP_WatchdogStallDisable \
+        WatchdogStallDisable
+#endif
+
+#endif // __ROM_MAP_H__


Property changes on: trunk/src/platform/lm3s/rom_map.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/ssi.c
===================================================================
--- trunk/src/platform/lm3s/ssi.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/ssi.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,681 +1,680 @@
-//*****************************************************************************
-//
-// ssi.c - Driver for Synchronous Serial Interface.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup ssi_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_ssi.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-#include &quot;ssi.h&quot;
-#include &quot;sysctl.h&quot;
-
-//*****************************************************************************
-//
-//! Configures the synchronous serial interface.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param ulSSIClk is the rate of the clock supplied to the SSI module.
-//! \param ulProtocol specifies the data transfer protocol.
-//! \param ulMode specifies the mode of operation.
-//! \param ulBitRate specifies the clock rate.
-//! \param ulDataWidth specifies number of bits transferred per frame.
-//!
-//! This function configures the synchronous serial interface.  It sets
-//! the SSI protocol, mode of operation, bit rate, and data width.
-//!
-//! The \e ulProtocol parameter defines the data frame format.  The
-//! \e ulProtocol parameter can be one of the following values:
-//! \b SSI_FRF_MOTO_MODE_0, \b SSI_FRF_MOTO_MODE_1, \b SSI_FRF_MOTO_MODE_2,
-//! \b SSI_FRF_MOTO_MODE_3, \b SSI_FRF_TI, or \b SSI_FRF_NMW.  The Motorola
-//! frame formats imply the following polarity and phase configurations:
-//!
-//! &lt;pre&gt;
-//! Polarity Phase       Mode
-//!   0       0   SSI_FRF_MOTO_MODE_0
-//!   0       1   SSI_FRF_MOTO_MODE_1
-//!   1       0   SSI_FRF_MOTO_MODE_2
-//!   1       1   SSI_FRF_MOTO_MODE_3
-//! &lt;/pre&gt;
-//!
-//! The \e ulMode parameter defines the operating mode of the SSI module.  The
-//! SSI module can operate as a master or slave; if a slave, the SSI can be
-//! configured to disable output on its serial output line.  The \e ulMode
-//! parameter can be one of the following values: \b SSI_MODE_MASTER,
-//! \b SSI_MODE_SLAVE, or \b SSI_MODE_SLAVE_OD.
-//!
-//! The \e ulBitRate parameter defines the bit rate for the SSI.  This bit rate
-//! must satisfy the following clock ratio criteria:
-//!
-//! - FSSI &gt;= 2 * bit rate (master mode)
-//! - FSSI &gt;= 12 * bit rate (slave modes)
-//!
-//! where FSSI is the frequency of the clock supplied to the SSI module.
-//!
-//! The \e ulDataWidth parameter defines the width of the data transfers, and
-//! can be a value between 4 and 16, inclusive.
-//!
-//! The peripheral clock will be the same as the processor clock.  This will be
-//! the value returned by SysCtlClockGet(), or it can be explicitly hard coded
-//! if it is constant and known (to save the code/execution overhead of a call
-//! to SysCtlClockGet()).
-//!
-//! This function replaces the original SSIConfig() API and performs the same
-//! actions.  A macro is provided in &lt;tt&gt;ssi.h&lt;/tt&gt; to map the original API to
-//! this API.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIConfigSetExpClk(unsigned long ulBase, unsigned long ulSSIClk,
-                   unsigned long ulProtocol, unsigned long ulMode,
-                   unsigned long ulBitRate, unsigned long ulDataWidth)
-{
-    unsigned long ulMaxBitRate;
-    unsigned long ulRegVal;
-    unsigned long ulPreDiv;
-    unsigned long ulSCR;
-    unsigned long ulSPH_SPO;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-    ASSERT((ulProtocol == SSI_FRF_MOTO_MODE_0) ||
-           (ulProtocol == SSI_FRF_MOTO_MODE_1) ||
-           (ulProtocol == SSI_FRF_MOTO_MODE_2) ||
-           (ulProtocol == SSI_FRF_MOTO_MODE_3) ||
-           (ulProtocol == SSI_FRF_TI) ||
-           (ulProtocol == SSI_FRF_NMW));
-    ASSERT((ulMode == SSI_MODE_MASTER) ||
-           (ulMode == SSI_MODE_SLAVE) ||
-           (ulMode == SSI_MODE_SLAVE_OD));
-    ASSERT(((ulMode == SSI_MODE_MASTER) &amp;&amp; (ulBitRate &lt;= (ulSSIClk / 2))) ||
-           ((ulMode != SSI_MODE_MASTER) &amp;&amp; (ulBitRate &lt;= (ulSSIClk / 12))));
-    ASSERT((ulSSIClk / ulBitRate) &lt;= (254 * 256));
-    ASSERT((ulDataWidth &gt;= 4) &amp;&amp; (ulDataWidth &lt;= 16));
-
-    //
-    // Set the mode.
-    //
-    ulRegVal = (ulMode == SSI_MODE_SLAVE_OD) ? SSI_CR1_SOD : 0;
-    ulRegVal |= (ulMode == SSI_MODE_MASTER) ? 0 : SSI_CR1_MS;
-    HWREG(ulBase + SSI_O_CR1) = ulRegVal;
-
-    //
-    // Set the clock predivider.
-    //
-    ulMaxBitRate = ulSSIClk / ulBitRate;
-    ulPreDiv = 0;
-    do
-    {
-        ulPreDiv += 2;
-        ulSCR = (ulMaxBitRate / ulPreDiv) - 1;
-    }
-    while(ulSCR &gt; 255);
-    HWREG(ulBase + SSI_O_CPSR) = ulPreDiv;
-
-    //
-    // Set protocol and clock rate.
-    //
-    ulSPH_SPO = ulProtocol &lt;&lt; 6;
-    ulProtocol &amp;= SSI_CR0_FRF_M;
-    ulRegVal = (ulSCR &lt;&lt; 8) | ulSPH_SPO | ulProtocol | (ulDataWidth - 1);
-    HWREG(ulBase + SSI_O_CR0) = ulRegVal;
-}
-
-//*****************************************************************************
-//
-//! Enables the synchronous serial interface.
-//!
-//! \param ulBase specifies the SSI module base address.
-//!
-//! This will enable operation of the synchronous serial interface.  It must be
-//! configured before it is enabled.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIEnable(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Read-modify-write the enable bit.
-    //
-    HWREG(ulBase + SSI_O_CR1) |= SSI_CR1_SSE;
-}
-
-//*****************************************************************************
-//
-//! Disables the synchronous serial interface.
-//!
-//! \param ulBase specifies the SSI module base address.
-//!
-//! This will disable operation of the synchronous serial interface.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIDisable(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Read-modify-write the enable bit.
-    //
-    HWREG(ulBase + SSI_O_CR1) &amp;= ~(SSI_CR1_SSE);
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for the synchronous serial interface.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param pfnHandler is a pointer to the function to be called when the
-//! synchronous serial interface interrupt occurs.
-//!
-//! This sets the handler to be called when an SSI interrupt
-//! occurs.  This will enable the global interrupt in the interrupt controller;
-//! specific SSI interrupts must be enabled via SSIIntEnable().  If necessary,
-//! it is the interrupt handler's responsibility to clear the interrupt source
-//! via SSIIntClear().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
-{
-    unsigned long ulInt;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Determine the interrupt number based on the SSI port.
-    //
-    ulInt = (ulBase == SSI0_BASE) ? INT_SSI0 : INT_SSI1;
-
-    //
-    // Register the interrupt handler, returning an error if an error occurs.
-    //
-    IntRegister(ulInt, pfnHandler);
-
-    //
-    // Enable the synchronous serial interface interrupt.
-    //
-    IntEnable(ulInt);
-}
-
-//*****************************************************************************
-//
-//! Unregisters an interrupt handler for the synchronous serial interface.
-//!
-//! \param ulBase specifies the SSI module base address.
-//!
-//! This function will clear the handler to be called when a SSI
-//! interrupt occurs.  This will also mask off the interrupt in the interrupt
-//! controller so that the interrupt handler no longer is called.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIIntUnregister(unsigned long ulBase)
-{
-    unsigned long ulInt;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Determine the interrupt number based on the SSI port.
-    //
-    ulInt = (ulBase == SSI0_BASE) ? INT_SSI0 : INT_SSI1;
-
-    //
-    // Disable the interrupt.
-    //
-    IntDisable(ulInt);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(ulInt);
-}
-
-//*****************************************************************************
-//
-//! Enables individual SSI interrupt sources.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param ulIntFlags is a bit mask of the interrupt sources to be enabled.
-//!
-//! Enables the indicated SSI interrupt sources.  Only the sources that are
-//! enabled can be reflected to the processor interrupt; disabled sources have
-//! no effect on the processor.  The \e ulIntFlags parameter can be any of the
-//! \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, or \b SSI_RXOR values.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Enable the specified interrupts.
-    //
-    HWREG(ulBase + SSI_O_IM) |= ulIntFlags;
-}
-
-//*****************************************************************************
-//
-//! Disables individual SSI interrupt sources.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param ulIntFlags is a bit mask of the interrupt sources to be disabled.
-//!
-//! Disables the indicated SSI interrupt sources.  The \e ulIntFlags parameter
-//! can be any of the \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, or \b SSI_RXOR
-//! values.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Disable the specified interrupts.
-    //
-    HWREG(ulBase + SSI_O_IM) &amp;= ~(ulIntFlags);
-}
-
-//*****************************************************************************
-//
-//! Gets the current interrupt status.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param bMasked is \b false if the raw interrupt status is required and
-//! \b true if the masked interrupt status is required.
-//!
-//! This returns the interrupt status for the SSI module.  Either the raw
-//! interrupt status or the status of interrupts that are allowed to reflect to
-//! the processor can be returned.
-//!
-//! \return The current interrupt status, enumerated as a bit field of
-//! \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, and \b SSI_RXOR.
-//
-//*****************************************************************************
-unsigned long
-SSIIntStatus(unsigned long ulBase, tBoolean bMasked)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Return either the interrupt status or the raw interrupt status as
-    // requested.
-    //
-    if(bMasked)
-    {
-        return(HWREG(ulBase + SSI_O_MIS));
-    }
-    else
-    {
-        return(HWREG(ulBase + SSI_O_RIS));
-    }
-}
-
-//*****************************************************************************
-//
-//! Clears SSI interrupt sources.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
-//!
-//! The specified SSI interrupt sources are cleared, so that
-//! they no longer assert.  This must be done in the interrupt handler to
-//! keep it from being called again immediately upon exit.
-//! The \e ulIntFlags parameter can consist of either or both the \b SSI_RXTO
-//! and \b SSI_RXOR values.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIIntClear(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Clear the requested interrupt sources.
-    //
-    HWREG(ulBase + SSI_O_ICR) = ulIntFlags;
-}
-
-//*****************************************************************************
-//
-//! Puts a data element into the SSI transmit FIFO.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param ulData data to be transmitted over the SSI interface.
-//!
-//! This function will place the supplied data into the transmit FIFO of
-//! the specified SSI module.
-//!
-//! \note The upper 32 - N bits of the \e ulData will be discarded by the
-//! hardware, where N is the data width as configured by SSIConfigSetExpClk().
-//! For example, if the interface is configured for 8-bit data width, the upper
-//! 24 bits of \e ulData will be discarded.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIDataPut(unsigned long ulBase, unsigned long ulData)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-    ASSERT((ulData &amp; (0xfffffffe &lt;&lt; (HWREG(ulBase + SSI_O_CR0) &amp;
-                                     SSI_CR0_DSS_M))) == 0);
-
-    //
-    // Wait until there is space.
-    //
-    while(!(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_TNF))
-    {
-    }
-
-    //
-    // Write the data to the SSI.
-    //
-    HWREG(ulBase + SSI_O_DR) = ulData;
-}
-
-//*****************************************************************************
-//
-//! Puts a data element into the SSI transmit FIFO.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param ulData data to be transmitted over the SSI interface.
-//!
-//! This function will place the supplied data into the transmit FIFO of
-//! the specified SSI module.  If there is no space in the FIFO, then this
-//! function will return a zero.
-//!
-//! This function replaces the original SSIDataNonBlockingPut() API and
-//! performs the same actions.  A macro is provided in &lt;tt&gt;ssi.h&lt;/tt&gt; to map
-//! the original API to this API.
-//!
-//! \note The upper 32 - N bits of the \e ulData will be discarded by the
-//! hardware, where N is the data width as configured by SSIConfigSetExpClk().
-//! For example, if the interface is configured for 8-bit data width, the upper
-//! 24 bits of \e ulData will be discarded.
-//!
-//! \return Returns the number of elements written to the SSI transmit FIFO.
-//
-//*****************************************************************************
-long
-SSIDataPutNonBlocking(unsigned long ulBase, unsigned long ulData)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-    ASSERT((ulData &amp; (0xfffffffe &lt;&lt; (HWREG(ulBase + SSI_O_CR0) &amp;
-                                     SSI_CR0_DSS_M))) == 0);
-
-    //
-    // Check for space to write.
-    //
-    if(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_TNF)
-    {
-        HWREG(ulBase + SSI_O_DR) = ulData;
-        return(1);
-    }
-    else
-    {
-        return(0);
-    }
-}
-
-//*****************************************************************************
-//
-//! Gets a data element from the SSI receive FIFO.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param pulData pointer to a storage location for data that was received
-//! over the SSI interface.
-//!
-//! This function will get received data from the receive FIFO of the specified
-//! SSI module, and place that data into the location specified by the
-//! \e pulData parameter.
-//!
-//! \note Only the lower N bits of the value written to \e pulData will contain
-//! valid data, where N is the data width as configured by
-//! SSIConfigSetExpClk().  For example, if the interface is configured for
-//! 8-bit data width, only the lower 8 bits of the value written to \e pulData
-//! will contain valid data.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIDataGet(unsigned long ulBase, unsigned long *pulData)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Wait until there is data to be read.
-    //
-    while(!(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_RNE))
-    {
-    }
-
-    //
-    // Read data from SSI.
-    //
-    *pulData = HWREG(ulBase + SSI_O_DR);
-}
-
-//*****************************************************************************
-//
-//! Gets a data element from the SSI receive FIFO.
-//!
-//! \param ulBase specifies the SSI module base address.
-//! \param pulData pointer to a storage location for data that was received
-//! over the SSI interface.
-//!
-//! This function will get received data from the receive FIFO of
-//! the specified SSI module, and place that data into the location specified
-//! by the \e ulData parameter.  If there is no data in the FIFO, then this
-//! function will return a zero.
-//!
-//! This function replaces the original SSIDataNonBlockingGet() API and
-//! performs the same actions.  A macro is provided in &lt;tt&gt;ssi.h&lt;/tt&gt; to map
-//! the original API to this API.
-//!
-//! \note Only the lower N bits of the value written to \e pulData will contain
-//! valid data, where N is the data width as configured by
-//! SSIConfigSetExpClk().  For example, if the interface is configured for
-//! 8-bit data width, only the lower 8 bits of the value written to \e pulData
-//! will contain valid data.
-//!
-//! \return Returns the number of elements read from the SSI receive FIFO.
-//
-//*****************************************************************************
-long
-SSIDataGetNonBlocking(unsigned long ulBase, unsigned long *pulData)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Check for data to read.
-    //
-    if(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_RNE)
-    {
-        *pulData = HWREG(ulBase + SSI_O_DR);
-        return(1);
-    }
-    else
-    {
-        return(0);
-    }
-}
-
-//*****************************************************************************
-//
-//! Enable SSI DMA operation.
-//!
-//! \param ulBase is the base address of the SSI port.
-//! \param ulDMAFlags is a bit mask of the DMA features to enable.
-//!
-//! The specified SSI DMA features are enabled.  The SSI can be
-//! configured to use DMA for transmit and/or receive data transfers.
-//! The \e ulDMAFlags parameter is the logical OR of any of the following
-//! values:
-//!
-//! - SSI_DMA_RX - enable DMA for receive
-//! - SSI_DMA_TX - enable DMA for transmit
-//!
-//! \note The uDMA controller must also be set up before DMA can be used
-//! with the SSI.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIDMAEnable(unsigned long ulBase, unsigned long ulDMAFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Set the requested bits in the UART DMA control register.
-    //
-    HWREG(ulBase + SSI_O_DMACTL) |= ulDMAFlags;
-}
-
-//*****************************************************************************
-//
-//! Disable SSI DMA operation.
-//!
-//! \param ulBase is the base address of the SSI port.
-//! \param ulDMAFlags is a bit mask of the DMA features to disable.
-//!
-//! This function is used to disable SSI DMA features that were enabled
-//! by SSIDMAEnable().  The specified SSI DMA features are disabled.  The
-//! \e ulDMAFlags parameter is the logical OR of any of the following values:
-//!
-//! - SSI_DMA_RX - disable DMA for receive
-//! - SSI_DMA_TX - disable DMA for transmit
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SSIDMADisable(unsigned long ulBase, unsigned long ulDMAFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
-
-    //
-    // Clear the requested bits in the UART DMA control register.
-    //
-    HWREG(ulBase + SSI_O_DMACTL) &amp;= ~ulDMAFlags;
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// ssi.c - Driver for Synchronous Serial Interface.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup ssi_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_ssi.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;ssi.h&quot;
+
+//*****************************************************************************
+//
+//! Configures the synchronous serial interface.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param ulSSIClk is the rate of the clock supplied to the SSI module.
+//! \param ulProtocol specifies the data transfer protocol.
+//! \param ulMode specifies the mode of operation.
+//! \param ulBitRate specifies the clock rate.
+//! \param ulDataWidth specifies number of bits transferred per frame.
+//!
+//! This function configures the synchronous serial interface.  It sets
+//! the SSI protocol, mode of operation, bit rate, and data width.
+//!
+//! The \e ulProtocol parameter defines the data frame format.  The
+//! \e ulProtocol parameter can be one of the following values:
+//! \b SSI_FRF_MOTO_MODE_0, \b SSI_FRF_MOTO_MODE_1, \b SSI_FRF_MOTO_MODE_2,
+//! \b SSI_FRF_MOTO_MODE_3, \b SSI_FRF_TI, or \b SSI_FRF_NMW.  The Motorola
+//! frame formats imply the following polarity and phase configurations:
+//!
+//! &lt;pre&gt;
+//! Polarity Phase       Mode
+//!   0       0   SSI_FRF_MOTO_MODE_0
+//!   0       1   SSI_FRF_MOTO_MODE_1
+//!   1       0   SSI_FRF_MOTO_MODE_2
+//!   1       1   SSI_FRF_MOTO_MODE_3
+//! &lt;/pre&gt;
+//!
+//! The \e ulMode parameter defines the operating mode of the SSI module.  The
+//! SSI module can operate as a master or slave; if a slave, the SSI can be
+//! configured to disable output on its serial output line.  The \e ulMode
+//! parameter can be one of the following values: \b SSI_MODE_MASTER,
+//! \b SSI_MODE_SLAVE, or \b SSI_MODE_SLAVE_OD.
+//!
+//! The \e ulBitRate parameter defines the bit rate for the SSI.  This bit rate
+//! must satisfy the following clock ratio criteria:
+//!
+//! - FSSI &gt;= 2 * bit rate (master mode)
+//! - FSSI &gt;= 12 * bit rate (slave modes)
+//!
+//! where FSSI is the frequency of the clock supplied to the SSI module.
+//!
+//! The \e ulDataWidth parameter defines the width of the data transfers, and
+//! can be a value between 4 and 16, inclusive.
+//!
+//! The peripheral clock will be the same as the processor clock.  This will be
+//! the value returned by SysCtlClockGet(), or it can be explicitly hard coded
+//! if it is constant and known (to save the code/execution overhead of a call
+//! to SysCtlClockGet()).
+//!
+//! This function replaces the original SSIConfig() API and performs the same
+//! actions.  A macro is provided in &lt;tt&gt;ssi.h&lt;/tt&gt; to map the original API to
+//! this API.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIConfigSetExpClk(unsigned long ulBase, unsigned long ulSSIClk,
+                   unsigned long ulProtocol, unsigned long ulMode,
+                   unsigned long ulBitRate, unsigned long ulDataWidth)
+{
+    unsigned long ulMaxBitRate;
+    unsigned long ulRegVal;
+    unsigned long ulPreDiv;
+    unsigned long ulSCR;
+    unsigned long ulSPH_SPO;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+    ASSERT((ulProtocol == SSI_FRF_MOTO_MODE_0) ||
+           (ulProtocol == SSI_FRF_MOTO_MODE_1) ||
+           (ulProtocol == SSI_FRF_MOTO_MODE_2) ||
+           (ulProtocol == SSI_FRF_MOTO_MODE_3) ||
+           (ulProtocol == SSI_FRF_TI) ||
+           (ulProtocol == SSI_FRF_NMW));
+    ASSERT((ulMode == SSI_MODE_MASTER) ||
+           (ulMode == SSI_MODE_SLAVE) ||
+           (ulMode == SSI_MODE_SLAVE_OD));
+    ASSERT(((ulMode == SSI_MODE_MASTER) &amp;&amp; (ulBitRate &lt;= (ulSSIClk / 2))) ||
+           ((ulMode != SSI_MODE_MASTER) &amp;&amp; (ulBitRate &lt;= (ulSSIClk / 12))));
+    ASSERT((ulSSIClk / ulBitRate) &lt;= (254 * 256));
+    ASSERT((ulDataWidth &gt;= 4) &amp;&amp; (ulDataWidth &lt;= 16));
+
+    //
+    // Set the mode.
+    //
+    ulRegVal = (ulMode == SSI_MODE_SLAVE_OD) ? SSI_CR1_SOD : 0;
+    ulRegVal |= (ulMode == SSI_MODE_MASTER) ? 0 : SSI_CR1_MS;
+    HWREG(ulBase + SSI_O_CR1) = ulRegVal;
+
+    //
+    // Set the clock predivider.
+    //
+    ulMaxBitRate = ulSSIClk / ulBitRate;
+    ulPreDiv = 0;
+    do
+    {
+        ulPreDiv += 2;
+        ulSCR = (ulMaxBitRate / ulPreDiv) - 1;
+    }
+    while(ulSCR &gt; 255);
+    HWREG(ulBase + SSI_O_CPSR) = ulPreDiv;
+
+    //
+    // Set protocol and clock rate.
+    //
+    ulSPH_SPO = ulProtocol &lt;&lt; 6;
+    ulProtocol &amp;= SSI_CR0_FRF_M;
+    ulRegVal = (ulSCR &lt;&lt; 8) | ulSPH_SPO | ulProtocol | (ulDataWidth - 1);
+    HWREG(ulBase + SSI_O_CR0) = ulRegVal;
+}
+
+//*****************************************************************************
+//
+//! Enables the synchronous serial interface.
+//!
+//! \param ulBase specifies the SSI module base address.
+//!
+//! This will enable operation of the synchronous serial interface.  It must be
+//! configured before it is enabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIEnable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Read-modify-write the enable bit.
+    //
+    HWREG(ulBase + SSI_O_CR1) |= SSI_CR1_SSE;
+}
+
+//*****************************************************************************
+//
+//! Disables the synchronous serial interface.
+//!
+//! \param ulBase specifies the SSI module base address.
+//!
+//! This will disable operation of the synchronous serial interface.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIDisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Read-modify-write the enable bit.
+    //
+    HWREG(ulBase + SSI_O_CR1) &amp;= ~(SSI_CR1_SSE);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the synchronous serial interface.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param pfnHandler is a pointer to the function to be called when the
+//! synchronous serial interface interrupt occurs.
+//!
+//! This sets the handler to be called when an SSI interrupt
+//! occurs.  This will enable the global interrupt in the interrupt controller;
+//! specific SSI interrupts must be enabled via SSIIntEnable().  If necessary,
+//! it is the interrupt handler's responsibility to clear the interrupt source
+//! via SSIIntClear().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Determine the interrupt number based on the SSI port.
+    //
+    ulInt = (ulBase == SSI0_BASE) ? INT_SSI0 : INT_SSI1;
+
+    //
+    // Register the interrupt handler, returning an error if an error occurs.
+    //
+    IntRegister(ulInt, pfnHandler);
+
+    //
+    // Enable the synchronous serial interface interrupt.
+    //
+    IntEnable(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Unregisters an interrupt handler for the synchronous serial interface.
+//!
+//! \param ulBase specifies the SSI module base address.
+//!
+//! This function will clear the handler to be called when a SSI
+//! interrupt occurs.  This will also mask off the interrupt in the interrupt
+//! controller so that the interrupt handler no longer is called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIIntUnregister(unsigned long ulBase)
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Determine the interrupt number based on the SSI port.
+    //
+    ulInt = (ulBase == SSI0_BASE) ? INT_SSI0 : INT_SSI1;
+
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(ulInt);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Enables individual SSI interrupt sources.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param ulIntFlags is a bit mask of the interrupt sources to be enabled.
+//!
+//! Enables the indicated SSI interrupt sources.  Only the sources that are
+//! enabled can be reflected to the processor interrupt; disabled sources have
+//! no effect on the processor.  The \e ulIntFlags parameter can be any of the
+//! \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, or \b SSI_RXOR values.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(ulBase + SSI_O_IM) |= ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Disables individual SSI interrupt sources.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param ulIntFlags is a bit mask of the interrupt sources to be disabled.
+//!
+//! Disables the indicated SSI interrupt sources.  The \e ulIntFlags parameter
+//! can be any of the \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, or \b SSI_RXOR
+//! values.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(ulBase + SSI_O_IM) &amp;= ~(ulIntFlags);
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param bMasked is \b false if the raw interrupt status is required and
+//! \b true if the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the SSI module.  Either the raw
+//! interrupt status or the status of interrupts that are allowed to reflect to
+//! the processor can be returned.
+//!
+//! \return The current interrupt status, enumerated as a bit field of
+//! \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, and \b SSI_RXOR.
+//
+//*****************************************************************************
+unsigned long
+SSIIntStatus(unsigned long ulBase, tBoolean bMasked)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    if(bMasked)
+    {
+        return(HWREG(ulBase + SSI_O_MIS));
+    }
+    else
+    {
+        return(HWREG(ulBase + SSI_O_RIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears SSI interrupt sources.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
+//!
+//! The specified SSI interrupt sources are cleared, so that
+//! they no longer assert.  This must be done in the interrupt handler to
+//! keep it from being called again immediately upon exit.
+//! The \e ulIntFlags parameter can consist of either or both the \b SSI_RXTO
+//! and \b SSI_RXOR values.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIIntClear(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Clear the requested interrupt sources.
+    //
+    HWREG(ulBase + SSI_O_ICR) = ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Puts a data element into the SSI transmit FIFO.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param ulData data to be transmitted over the SSI interface.
+//!
+//! This function will place the supplied data into the transmit FIFO of
+//! the specified SSI module.
+//!
+//! \note The upper 32 - N bits of the \e ulData will be discarded by the
+//! hardware, where N is the data width as configured by SSIConfigSetExpClk().
+//! For example, if the interface is configured for 8-bit data width, the upper
+//! 24 bits of \e ulData will be discarded.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIDataPut(unsigned long ulBase, unsigned long ulData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+    ASSERT((ulData &amp; (0xfffffffe &lt;&lt; (HWREG(ulBase + SSI_O_CR0) &amp;
+                                     SSI_CR0_DSS_M))) == 0);
+
+    //
+    // Wait until there is space.
+    //
+    while(!(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_TNF))
+    {
+    }
+
+    //
+    // Write the data to the SSI.
+    //
+    HWREG(ulBase + SSI_O_DR) = ulData;
+}
+
+//*****************************************************************************
+//
+//! Puts a data element into the SSI transmit FIFO.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param ulData data to be transmitted over the SSI interface.
+//!
+//! This function will place the supplied data into the transmit FIFO of
+//! the specified SSI module.  If there is no space in the FIFO, then this
+//! function will return a zero.
+//!
+//! This function replaces the original SSIDataNonBlockingPut() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;ssi.h&lt;/tt&gt; to map
+//! the original API to this API.
+//!
+//! \note The upper 32 - N bits of the \e ulData will be discarded by the
+//! hardware, where N is the data width as configured by SSIConfigSetExpClk().
+//! For example, if the interface is configured for 8-bit data width, the upper
+//! 24 bits of \e ulData will be discarded.
+//!
+//! \return Returns the number of elements written to the SSI transmit FIFO.
+//
+//*****************************************************************************
+long
+SSIDataPutNonBlocking(unsigned long ulBase, unsigned long ulData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+    ASSERT((ulData &amp; (0xfffffffe &lt;&lt; (HWREG(ulBase + SSI_O_CR0) &amp;
+                                     SSI_CR0_DSS_M))) == 0);
+
+    //
+    // Check for space to write.
+    //
+    if(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_TNF)
+    {
+        HWREG(ulBase + SSI_O_DR) = ulData;
+        return(1);
+    }
+    else
+    {
+        return(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Gets a data element from the SSI receive FIFO.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param pulData pointer to a storage location for data that was received
+//! over the SSI interface.
+//!
+//! This function will get received data from the receive FIFO of the specified
+//! SSI module, and place that data into the location specified by the
+//! \e pulData parameter.
+//!
+//! \note Only the lower N bits of the value written to \e pulData will contain
+//! valid data, where N is the data width as configured by
+//! SSIConfigSetExpClk().  For example, if the interface is configured for
+//! 8-bit data width, only the lower 8 bits of the value written to \e pulData
+//! will contain valid data.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIDataGet(unsigned long ulBase, unsigned long *pulData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Wait until there is data to be read.
+    //
+    while(!(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_RNE))
+    {
+    }
+
+    //
+    // Read data from SSI.
+    //
+    *pulData = HWREG(ulBase + SSI_O_DR);
+}
+
+//*****************************************************************************
+//
+//! Gets a data element from the SSI receive FIFO.
+//!
+//! \param ulBase specifies the SSI module base address.
+//! \param pulData pointer to a storage location for data that was received
+//! over the SSI interface.
+//!
+//! This function will get received data from the receive FIFO of
+//! the specified SSI module, and place that data into the location specified
+//! by the \e ulData parameter.  If there is no data in the FIFO, then this
+//! function will return a zero.
+//!
+//! This function replaces the original SSIDataNonBlockingGet() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;ssi.h&lt;/tt&gt; to map
+//! the original API to this API.
+//!
+//! \note Only the lower N bits of the value written to \e pulData will contain
+//! valid data, where N is the data width as configured by
+//! SSIConfigSetExpClk().  For example, if the interface is configured for
+//! 8-bit data width, only the lower 8 bits of the value written to \e pulData
+//! will contain valid data.
+//!
+//! \return Returns the number of elements read from the SSI receive FIFO.
+//
+//*****************************************************************************
+long
+SSIDataGetNonBlocking(unsigned long ulBase, unsigned long *pulData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Check for data to read.
+    //
+    if(HWREG(ulBase + SSI_O_SR) &amp; SSI_SR_RNE)
+    {
+        *pulData = HWREG(ulBase + SSI_O_DR);
+        return(1);
+    }
+    else
+    {
+        return(0);
+    }
+}
+
+//*****************************************************************************
+//
+//! Enable SSI DMA operation.
+//!
+//! \param ulBase is the base address of the SSI port.
+//! \param ulDMAFlags is a bit mask of the DMA features to enable.
+//!
+//! The specified SSI DMA features are enabled.  The SSI can be
+//! configured to use DMA for transmit and/or receive data transfers.
+//! The \e ulDMAFlags parameter is the logical OR of any of the following
+//! values:
+//!
+//! - SSI_DMA_RX - enable DMA for receive
+//! - SSI_DMA_TX - enable DMA for transmit
+//!
+//! \note The uDMA controller must also be set up before DMA can be used
+//! with the SSI.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIDMAEnable(unsigned long ulBase, unsigned long ulDMAFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Set the requested bits in the UART DMA control register.
+    //
+    HWREG(ulBase + SSI_O_DMACTL) |= ulDMAFlags;
+}
+
+//*****************************************************************************
+//
+//! Disable SSI DMA operation.
+//!
+//! \param ulBase is the base address of the SSI port.
+//! \param ulDMAFlags is a bit mask of the DMA features to disable.
+//!
+//! This function is used to disable SSI DMA features that were enabled
+//! by SSIDMAEnable().  The specified SSI DMA features are disabled.  The
+//! \e ulDMAFlags parameter is the logical OR of any of the following values:
+//!
+//! - SSI_DMA_RX - disable DMA for receive
+//! - SSI_DMA_TX - disable DMA for transmit
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SSIDMADisable(unsigned long ulBase, unsigned long ulDMAFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == SSI0_BASE) || (ulBase == SSI1_BASE));
+
+    //
+    // Clear the requested bits in the UART DMA control register.
+    //
+    HWREG(ulBase + SSI_O_DMACTL) &amp;= ~ulDMAFlags;
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/ssi.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/ssi.h
===================================================================
--- trunk/src/platform/lm3s/ssi.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/ssi.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,127 +1,127 @@
-//*****************************************************************************
-//
-// ssi.h - Prototypes for the Synchronous Serial Interface Driver.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __SSI_H__
-#define __SSI_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Values that can be passed to SSIIntEnable, SSIIntDisable, and SSIIntClear
-// as the ulIntFlags parameter, and returned by SSIIntStatus.
-//
-//*****************************************************************************
-#define SSI_TXFF                0x00000008  // TX FIFO half empty or less
-#define SSI_RXFF                0x00000004  // RX FIFO half full or less
-#define SSI_RXTO                0x00000002  // RX timeout
-#define SSI_RXOR                0x00000001  // RX overrun
-
-//*****************************************************************************
-//
-// Values that can be passed to SSIConfigSetExpClk.
-//
-//*****************************************************************************
-#define SSI_FRF_MOTO_MODE_0     0x00000000  // Moto fmt, polarity 0, phase 0
-#define SSI_FRF_MOTO_MODE_1     0x00000002  // Moto fmt, polarity 0, phase 1
-#define SSI_FRF_MOTO_MODE_2     0x00000001  // Moto fmt, polarity 1, phase 0
-#define SSI_FRF_MOTO_MODE_3     0x00000003  // Moto fmt, polarity 1, phase 1
-#define SSI_FRF_TI              0x00000010  // TI frame format
-#define SSI_FRF_NMW             0x00000020  // National MicroWire frame format
-
-#define SSI_MODE_MASTER         0x00000000  // SSI master
-#define SSI_MODE_SLAVE          0x00000001  // SSI slave
-#define SSI_MODE_SLAVE_OD       0x00000002  // SSI slave with output disabled
-
-//*****************************************************************************
-//
-// Values that can be passed to SSIDMAEnable() and SSIDMADisable().
-//
-//*****************************************************************************
-#define SSI_DMA_TX              0x00000002  // Enable DMA for transmit
-#define SSI_DMA_RX              0x00000001  // Enable DMA for receive
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern void SSIConfigSetExpClk(unsigned long ulBase, unsigned long ulSSIClk,
-                               unsigned long ulProtocol, unsigned long ulMode,
-                               unsigned long ulBitRate,
-                               unsigned long ulDataWidth);
-extern void SSIDataGet(unsigned long ulBase, unsigned long *pulData);
-extern long SSIDataGetNonBlocking(unsigned long ulBase,
-                                  unsigned long *pulData);
-extern void SSIDataPut(unsigned long ulBase, unsigned long ulData);
-extern long SSIDataPutNonBlocking(unsigned long ulBase, unsigned long ulData);
-extern void SSIDisable(unsigned long ulBase);
-extern void SSIEnable(unsigned long ulBase);
-extern void SSIIntClear(unsigned long ulBase, unsigned long ulIntFlags);
-extern void SSIIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
-extern void SSIIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
-extern void SSIIntRegister(unsigned long ulBase, void(*pfnHandler)(void));
-extern unsigned long SSIIntStatus(unsigned long ulBase, tBoolean bMasked);
-extern void SSIIntUnregister(unsigned long ulBase);
-extern void SSIDMAEnable(unsigned long ulBase, unsigned long ulDMAFlags);
-extern void SSIDMADisable(unsigned long ulBase, unsigned long ulDMAFlags);
-
-//*****************************************************************************
-//
-// Several SSI APIs have been renamed, with the original function name being
-// deprecated.  These defines provide backward compatibility.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-#include &quot;sysctl.h&quot;
-#define SSIConfig(a, b, c, d, e)                            \
-        SSIConfigSetExpClk(a, SysCtlClockGet(), b, c, d, e)
-#define SSIDataNonBlockingGet(a, b) \
-        SSIDataGetNonBlocking(a, b)
-#define SSIDataNonBlockingPut(a, b) \
-        SSIDataPutNonBlocking(a, b)
-#endif
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __SSI_H__
+//*****************************************************************************
+//
+// ssi.h - Prototypes for the Synchronous Serial Interface Driver.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __SSI_H__
+#define __SSI_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to SSIIntEnable, SSIIntDisable, and SSIIntClear
+// as the ulIntFlags parameter, and returned by SSIIntStatus.
+//
+//*****************************************************************************
+#define SSI_TXFF                0x00000008  // TX FIFO half empty or less
+#define SSI_RXFF                0x00000004  // RX FIFO half full or less
+#define SSI_RXTO                0x00000002  // RX timeout
+#define SSI_RXOR                0x00000001  // RX overrun
+
+//*****************************************************************************
+//
+// Values that can be passed to SSIConfigSetExpClk.
+//
+//*****************************************************************************
+#define SSI_FRF_MOTO_MODE_0     0x00000000  // Moto fmt, polarity 0, phase 0
+#define SSI_FRF_MOTO_MODE_1     0x00000002  // Moto fmt, polarity 0, phase 1
+#define SSI_FRF_MOTO_MODE_2     0x00000001  // Moto fmt, polarity 1, phase 0
+#define SSI_FRF_MOTO_MODE_3     0x00000003  // Moto fmt, polarity 1, phase 1
+#define SSI_FRF_TI              0x00000010  // TI frame format
+#define SSI_FRF_NMW             0x00000020  // National MicroWire frame format
+
+#define SSI_MODE_MASTER         0x00000000  // SSI master
+#define SSI_MODE_SLAVE          0x00000001  // SSI slave
+#define SSI_MODE_SLAVE_OD       0x00000002  // SSI slave with output disabled
+
+//*****************************************************************************
+//
+// Values that can be passed to SSIDMAEnable() and SSIDMADisable().
+//
+//*****************************************************************************
+#define SSI_DMA_TX              0x00000002  // Enable DMA for transmit
+#define SSI_DMA_RX              0x00000001  // Enable DMA for receive
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern void SSIConfigSetExpClk(unsigned long ulBase, unsigned long ulSSIClk,
+                               unsigned long ulProtocol, unsigned long ulMode,
+                               unsigned long ulBitRate,
+                               unsigned long ulDataWidth);
+extern void SSIDataGet(unsigned long ulBase, unsigned long *pulData);
+extern long SSIDataGetNonBlocking(unsigned long ulBase,
+                                  unsigned long *pulData);
+extern void SSIDataPut(unsigned long ulBase, unsigned long ulData);
+extern long SSIDataPutNonBlocking(unsigned long ulBase, unsigned long ulData);
+extern void SSIDisable(unsigned long ulBase);
+extern void SSIEnable(unsigned long ulBase);
+extern void SSIIntClear(unsigned long ulBase, unsigned long ulIntFlags);
+extern void SSIIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void SSIIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void SSIIntRegister(unsigned long ulBase, void(*pfnHandler)(void));
+extern unsigned long SSIIntStatus(unsigned long ulBase, tBoolean bMasked);
+extern void SSIIntUnregister(unsigned long ulBase);
+extern void SSIDMAEnable(unsigned long ulBase, unsigned long ulDMAFlags);
+extern void SSIDMADisable(unsigned long ulBase, unsigned long ulDMAFlags);
+
+//*****************************************************************************
+//
+// Several SSI APIs have been renamed, with the original function name being
+// deprecated.  These defines provide backward compatibility.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#include &quot;sysctl.h&quot;
+#define SSIConfig(a, b, c, d, e)                            \
+        SSIConfigSetExpClk(a, SysCtlClockGet(), b, c, d, e)
+#define SSIDataNonBlockingGet(a, b) \
+        SSIDataGetNonBlocking(a, b)
+#define SSIDataNonBlockingPut(a, b) \
+        SSIDataPutNonBlocking(a, b)
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __SSI_H__


Property changes on: trunk/src/platform/lm3s/ssi.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/sysctl.c
===================================================================
--- trunk/src/platform/lm3s/sysctl.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/sysctl.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,2125 +1,2339 @@
-//*****************************************************************************
-//
-// sysctl.c - Driver for the system controller.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup sysctl_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_nvic.h&quot;
-#include &quot;hw_sysctl.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;cpu.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-#include &quot;sysctl.h&quot;
-
-//*****************************************************************************
-//
-// This macro extracts the array index out of the peripheral number.
-//
-//*****************************************************************************
-#define SYSCTL_PERIPH_INDEX(a)  (((a) &gt;&gt; 28) &amp; 0xf)
-
-//*****************************************************************************
-//
-// This macro constructs the peripheral bit mask from the peripheral number.
-//
-//*****************************************************************************
-#define SYSCTL_PERIPH_MASK(a)   (((a) &amp; 0xffff) &lt;&lt; (((a) &amp; 0x001f0000) &gt;&gt; 16))
-
-//*****************************************************************************
-//
-// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
-// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL DC? register that
-// contains the peripheral present bit for that peripheral.
-//
-//*****************************************************************************
-static const unsigned long g_pulDCRegs[] =
-{
-    SYSCTL_DC1,
-    SYSCTL_DC2,
-    SYSCTL_DC4,
-    SYSCTL_DC1
-};
-
-//*****************************************************************************
-//
-// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
-// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_SRCR? register that
-// controls the software reset for that peripheral.
-//
-//*****************************************************************************
-static const unsigned long g_pulSRCRRegs[] =
-{
-    SYSCTL_SRCR0,
-    SYSCTL_SRCR1,
-    SYSCTL_SRCR2
-};
-
-//*****************************************************************************
-//
-// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
-// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_RCGC? register that
-// controls the run-mode enable for that peripheral.
-//
-//*****************************************************************************
-static const unsigned long g_pulRCGCRegs[] =
-{
-    SYSCTL_RCGC0,
-    SYSCTL_RCGC1,
-    SYSCTL_RCGC2
-};
-
-//*****************************************************************************
-//
-// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
-// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_SCGC? register that
-// controls the sleep-mode enable for that peripheral.
-//
-//*****************************************************************************
-static const unsigned long g_pulSCGCRegs[] =
-{
-    SYSCTL_SCGC0,
-    SYSCTL_SCGC1,
-    SYSCTL_SCGC2
-};
-
-//*****************************************************************************
-//
-// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
-// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_DCGC? register that
-// controls the deep-sleep-mode enable for that peripheral.
-//
-//*****************************************************************************
-static const unsigned long g_pulDCGCRegs[] =
-{
-    SYSCTL_DCGC0,
-    SYSCTL_DCGC1,
-    SYSCTL_DCGC2
-};
-
-//*****************************************************************************
-//
-// An array that maps the crystal number in RCC to a frequency.
-//
-//*****************************************************************************
-static const unsigned long g_pulXtals[] =
-{
-    1000000,
-    1843200,
-    2000000,
-    2457600,
-    3579545,
-    3686400,
-    4000000,
-    4096000,
-    4915200,
-    5000000,
-    5120000,
-    6000000,
-    6144000,
-    7372800,
-    8000000,
-    8192000,
-    10000000,
-    12000000,
-    12288000,
-    13560000,
-    14318180,
-    16000000,
-    16384000
-};
-
-//*****************************************************************************
-//
-//! \internal
-//! Checks a peripheral identifier.
-//!
-//! \param ulPeripheral is the peripheral identifier.
-//!
-//! This function determines if a peripheral identifier is valid.
-//!
-//! \return Returns \b true if the peripheral identifier is valid and \b false
-//! otherwise.
-//
-//*****************************************************************************
-#ifdef DEBUG
-static tBoolean
-SysCtlPeripheralValid(unsigned long ulPeripheral)
-{
-    return((ulPeripheral == SYSCTL_PERIPH_ADC) ||
-           (ulPeripheral == SYSCTL_PERIPH_CAN0) ||
-           (ulPeripheral == SYSCTL_PERIPH_CAN1) ||
-           (ulPeripheral == SYSCTL_PERIPH_CAN2) ||
-           (ulPeripheral == SYSCTL_PERIPH_COMP0) ||
-           (ulPeripheral == SYSCTL_PERIPH_COMP1) ||
-           (ulPeripheral == SYSCTL_PERIPH_COMP2) ||
-           (ulPeripheral == SYSCTL_PERIPH_ETH) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOA) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOB) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOC) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOD) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOE) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOF) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOG) ||
-           (ulPeripheral == SYSCTL_PERIPH_GPIOH) ||
-           (ulPeripheral == SYSCTL_PERIPH_HIBERNATE) ||
-           (ulPeripheral == SYSCTL_PERIPH_I2C0) ||
-           (ulPeripheral == SYSCTL_PERIPH_I2C1) ||
-           (ulPeripheral == SYSCTL_PERIPH_IEEE1588) ||
-           (ulPeripheral == SYSCTL_PERIPH_MPU) ||
-           (ulPeripheral == SYSCTL_PERIPH_PLL) ||
-           (ulPeripheral == SYSCTL_PERIPH_PWM) ||
-           (ulPeripheral == SYSCTL_PERIPH_QEI0) ||
-           (ulPeripheral == SYSCTL_PERIPH_QEI1) ||
-           (ulPeripheral == SYSCTL_PERIPH_SSI0) ||
-           (ulPeripheral == SYSCTL_PERIPH_SSI1) ||
-           (ulPeripheral == SYSCTL_PERIPH_TEMP) ||
-           (ulPeripheral == SYSCTL_PERIPH_TIMER0) ||
-           (ulPeripheral == SYSCTL_PERIPH_TIMER1) ||
-           (ulPeripheral == SYSCTL_PERIPH_TIMER2) ||
-           (ulPeripheral == SYSCTL_PERIPH_TIMER3) ||
-           (ulPeripheral == SYSCTL_PERIPH_UART0) ||
-           (ulPeripheral == SYSCTL_PERIPH_UART1) ||
-           (ulPeripheral == SYSCTL_PERIPH_UART2) ||
-           (ulPeripheral == SYSCTL_PERIPH_UDMA) ||
-           (ulPeripheral == SYSCTL_PERIPH_USB0) ||
-           (ulPeripheral == SYSCTL_PERIPH_WDOG));
-}
-#endif
-
-//*****************************************************************************
-//
-//! Gets the size of the SRAM.
-//!
-//! This function determines the size of the SRAM on the Stellaris device.
-//!
-//! \return The total number of bytes of SRAM.
-//
-//*****************************************************************************
-unsigned long
-SysCtlSRAMSizeGet(void)
-{
-    //
-    // Compute the size of the SRAM.
-    //
-    return(((HWREG(SYSCTL_DC0) &amp; SYSCTL_DC0_SRAMSZ_M) &gt;&gt; 8) + 0x100);
-}
-
-//*****************************************************************************
-//
-//! Gets the size of the flash.
-//!
-//! This function determines the size of the flash on the Stellaris device.
-//!
-//! \return The total number of bytes of flash.
-//
-//*****************************************************************************
-unsigned long
-SysCtlFlashSizeGet(void)
-{
-    //
-    // Compute the size of the flash.
-    //
-    return(((HWREG(SYSCTL_DC0) &amp; SYSCTL_DC0_FLASHSZ_M) &lt;&lt; 11) + 0x800);
-}
-
-//*****************************************************************************
-//
-//! Determines if a pin is present.
-//!
-//! \param ulPin is the pin in question.
-//!
-//! Determines if a particular pin is present in the device.  The PWM, analog
-//! comparators, ADC, and timers have a varying number of pins across members
-//! of the Stellaris family; this will determine which are present on this
-//! device.
-//!
-//! The \e ulPin argument must be only one of the following values:
-//! \b SYSCTL_PIN_PWM0, \b SYSCTL_PIN_PWM1, \b SYSCTL_PIN_PWM2,
-//! \b SYSCTL_PIN_PWM3, \b SYSCTL_PIN_PWM4, \b SYSCTL_PIN_PWM5,
-//! \b SYSCTL_PIN_C0MINUS, \b SYSCTL_PIN_C0PLUS, \b SYSCTL_PIN_C0O,
-//! \b SYSCTL_PIN_C1MINUS, \b SYSCTL_PIN_C1PLUS, \b SYSCTL_PIN_C1O,
-//! \b SYSCTL_PIN_C2MINUS, \b SYSCTL_PIN_C2PLUS, \b SYSCTL_PIN_C2O,
-//! \b SYSCTL_PIN_ADC0, \b SYSCTL_PIN_ADC1, \b SYSCTL_PIN_ADC2,
-//! \b SYSCTL_PIN_ADC3, \b SYSCTL_PIN_ADC4, \b SYSCTL_PIN_ADC5,
-//! \b SYSCTL_PIN_ADC6, \b SYSCTL_PIN_ADC7, \b SYSCTL_PIN_CCP0,
-//! \b SYSCTL_PIN_CCP1, \b SYSCTL_PIN_CCP2, \b SYSCTL_PIN_CCP3,
-//! \b SYSCTL_PIN_CCP4, \b SYSCTL_PIN_CCP5, \b SYSCTL_PIN_CCP6,
-//! \b SYSCTL_PIN_CCP7, \b SYSCTL_PIN_32KHZ, or \b SYSCTL_PIN_MC_FAULT0.
-//!
-//! \return Returns \b true if the specified pin is present and \b false if it
-//! is not.
-//
-//*****************************************************************************
-tBoolean
-SysCtlPinPresent(unsigned long ulPin)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulPin == SYSCTL_PIN_PWM0) ||
-           (ulPin == SYSCTL_PIN_PWM1) ||
-           (ulPin == SYSCTL_PIN_PWM2) ||
-           (ulPin == SYSCTL_PIN_PWM3) ||
-           (ulPin == SYSCTL_PIN_PWM4) ||
-           (ulPin == SYSCTL_PIN_PWM5) ||
-           (ulPin == SYSCTL_PIN_C0MINUS) ||
-           (ulPin == SYSCTL_PIN_C0PLUS) ||
-           (ulPin == SYSCTL_PIN_C0O) ||
-           (ulPin == SYSCTL_PIN_C1MINUS) ||
-           (ulPin == SYSCTL_PIN_C1PLUS) ||
-           (ulPin == SYSCTL_PIN_C1O) ||
-           (ulPin == SYSCTL_PIN_C2MINUS) ||
-           (ulPin == SYSCTL_PIN_C2PLUS) ||
-           (ulPin == SYSCTL_PIN_C2O) ||
-           (ulPin == SYSCTL_PIN_MC_FAULT0) ||
-           (ulPin == SYSCTL_PIN_ADC0) ||
-           (ulPin == SYSCTL_PIN_ADC1) ||
-           (ulPin == SYSCTL_PIN_ADC2) ||
-           (ulPin == SYSCTL_PIN_ADC3) ||
-           (ulPin == SYSCTL_PIN_ADC4) ||
-           (ulPin == SYSCTL_PIN_ADC5) ||
-           (ulPin == SYSCTL_PIN_ADC6) ||
-           (ulPin == SYSCTL_PIN_ADC7) ||
-           (ulPin == SYSCTL_PIN_CCP0) ||
-           (ulPin == SYSCTL_PIN_CCP1) ||
-           (ulPin == SYSCTL_PIN_CCP2) ||
-           (ulPin == SYSCTL_PIN_CCP3) ||
-           (ulPin == SYSCTL_PIN_CCP4) ||
-           (ulPin == SYSCTL_PIN_CCP5) ||
-           (ulPin == SYSCTL_PIN_32KHZ));
-
-    //
-    // Determine if this pin is present.
-    //
-    if(HWREG(SYSCTL_DC3) &amp; ulPin)
-    {
-        return(true);
-    }
-    else
-    {
-        return(false);
-    }
-}
-
-//*****************************************************************************
-//
-//! Determines if a peripheral is present.
-//!
-//! \param ulPeripheral is the peripheral in question.
-//!
-//! Determines if a particular peripheral is present in the device.  Each
-//! member of the Stellaris family has a different peripheral set; this will
-//! determine which are present on this device.
-//!
-//! The \e ulPeripheral parameter must be only one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_IEEE1588, \b SYSCTL_PERIPH_MPU,
-//! \b SYSCTL_PERIPH_PLL, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TEMP, \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1,
-//! \b SYSCTL_PERIPH_TIMER2, \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0,
-//! \b SYSCTL_PERIPH_UART1, \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA,
-//! \b SYSCTL_PERIPH_USB0, or \b SYSCTL_PERIPH_WDOG.
-//!
-//! \return Returns \b true if the specified peripheral is present and \b false
-//! if it is not.
-//
-//*****************************************************************************
-tBoolean
-SysCtlPeripheralPresent(unsigned long ulPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Read the correct DC register and determine if this peripheral exists.
-    //
-    if(HWREG(g_pulDCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;
-       SYSCTL_PERIPH_MASK(ulPeripheral))
-    {
-        return(true);
-    }
-    else
-    {
-        return(false);
-    }
-}
-
-//*****************************************************************************
-//
-//! Performs a software reset of a peripheral.
-//!
-//! \param ulPeripheral is the peripheral to reset.
-//!
-//! This function performs a software reset of the specified peripheral.  An
-//! individual peripheral reset signal is asserted for a brief period and then
-//! deasserted, leaving the peripheral in a operating state but in its reset
-//! condition.
-//!
-//! The \e ulPeripheral parameter must be only one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
-//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
-//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
-//! \b SYSCTL_PERIPH_WDOG.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralReset(unsigned long ulPeripheral)
-{
-    volatile unsigned long ulDelay;
-
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Put the peripheral into the reset state.
-    //
-    HWREG(g_pulSRCRRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
-        SYSCTL_PERIPH_MASK(ulPeripheral);
-
-    //
-    // Delay for a little bit.
-    //
-    for(ulDelay = 0; ulDelay &lt; 16; ulDelay++)
-    {
-    }
-
-    //
-    // Take the peripheral out of the reset state.
-    //
-    HWREG(g_pulSRCRRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
-        ~SYSCTL_PERIPH_MASK(ulPeripheral);
-}
-
-//*****************************************************************************
-//
-//! Enables a peripheral.
-//!
-//! \param ulPeripheral is the peripheral to enable.
-//!
-//! Peripherals are enabled with this function.  At power-up, all peripherals
-//! are disabled; they must be enabled in order to operate or respond to
-//! register reads/writes.
-//!
-//! The \e ulPeripheral parameter must be only one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
-//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
-//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
-//! \b SYSCTL_PERIPH_WDOG.
-//!
-//! \note It takes five clock cycles after the write to enable a peripheral
-//! before the the peripheral is actually enabled.  During this time, attempts
-//! to access the peripheral will result in a bus fault.  Care should be taken
-//! to ensure that the peripheral is not accessed during this brief time
-//! period.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralEnable(unsigned long ulPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Enable this peripheral.
-    //
-    HWREG(g_pulRCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
-        SYSCTL_PERIPH_MASK(ulPeripheral);
-}
-
-//*****************************************************************************
-//
-//! Disables a peripheral.
-//!
-//! \param ulPeripheral is the peripheral to disable.
-//!
-//! Peripherals are disabled with this function.  Once disabled, they will not
-//! operate or respond to register reads/writes.
-//!
-//! The \e ulPeripheral parameter must be only one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
-//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
-//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
-//! \b SYSCTL_PERIPH_WDOG.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralDisable(unsigned long ulPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Disable this peripheral.
-    //
-    HWREG(g_pulRCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
-        ~SYSCTL_PERIPH_MASK(ulPeripheral);
-}
-
-//*****************************************************************************
-//
-//! Enables a peripheral in sleep mode.
-//!
-//! \param ulPeripheral is the peripheral to enable in sleep mode.
-//!
-//! This function allows a peripheral to continue operating when the processor
-//! goes into sleep mode.  Since the clocking configuration of the device does
-//! not change, any peripheral can safely continue operating while the
-//! processor is in sleep mode, and can therefore wake the processor from sleep
-//! mode.
-//!
-//! Sleep mode clocking of peripherals must be enabled via
-//! SysCtlPeripheralClockGating(); if disabled, the peripheral sleep mode
-//! configuration is maintained but has no effect when sleep mode is entered.
-//!
-//! The \e ulPeripheral parameter must be only one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
-//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
-//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
-//! \b SYSCTL_PERIPH_WDOG.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralSleepEnable(unsigned long ulPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Enable this peripheral in sleep mode.
-    //
-    HWREG(g_pulSCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
-        SYSCTL_PERIPH_MASK(ulPeripheral);
-}
-
-//*****************************************************************************
-//
-//! Disables a peripheral in sleep mode.
-//!
-//! \param ulPeripheral is the peripheral to disable in sleep mode.
-//!
-//! This function causes a peripheral to stop operating when the processor goes
-//! into sleep mode.  Disabling peripherals while in sleep mode helps to lower
-//! the current draw of the device.  If enabled (via SysCtlPeripheralEnable()),
-//! the peripheral will automatically resume operation when the processor
-//! leaves sleep mode, maintaining its entire state from before sleep mode was
-//! entered.
-//!
-//! Sleep mode clocking of peripherals must be enabled via
-//! SysCtlPeripheralClockGating(); if disabled, the peripheral sleep mode
-//! configuration is maintained but has no effect when sleep mode is entered.
-//!
-//! The \e ulPeripheral parameter must be only one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
-//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
-//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
-//! \b SYSCTL_PERIPH_WDOG.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralSleepDisable(unsigned long ulPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Disable this peripheral in sleep mode.
-    //
-    HWREG(g_pulSCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
-        ~SYSCTL_PERIPH_MASK(ulPeripheral);
-}
-
-//*****************************************************************************
-//
-//! Enables a peripheral in deep-sleep mode.
-//!
-//! \param ulPeripheral is the peripheral to enable in deep-sleep mode.
-//!
-//! This function allows a peripheral to continue operating when the processor
-//! goes into deep-sleep mode.  Since the clocking configuration of the device
-//! may change, not all peripherals can safely continue operating while the
-//! processor is in sleep mode.  Those that must run at a particular frequency
-//! (such as a UART) will not work as expected if the clock changes.  It is the
-//! responsibility of the caller to make sensible choices.
-//!
-//! Deep-sleep mode clocking of peripherals must be enabled via
-//! SysCtlPeripheralClockGating(); if disabled, the peripheral deep-sleep mode
-//! configuration is maintained but has no effect when deep-sleep mode is
-//! entered.
-//!
-//! The \e ulPeripheral parameter must be one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
-//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
-//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
-//! \b SYSCTL_PERIPH_WDOG.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralDeepSleepEnable(unsigned long ulPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Enable this peripheral in deep-sleep mode.
-    //
-    HWREG(g_pulDCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
-        SYSCTL_PERIPH_MASK(ulPeripheral);
-}
-
-//*****************************************************************************
-//
-//! Disables a peripheral in deep-sleep mode.
-//!
-//! \param ulPeripheral is the peripheral to disable in deep-sleep mode.
-//!
-//! This function causes a peripheral to stop operating when the processor goes
-//! into deep-sleep mode.  Disabling peripherals while in deep-sleep mode helps
-//! to lower the current draw of the device, and can keep peripherals that
-//! require a particular clock frequency from operating when the clock changes
-//! as a result of entering deep-sleep mode.  If enabled (via
-//! SysCtlPeripheralEnable()), the peripheral will automatically resume
-//! operation when the processor leaves deep-sleep mode, maintaining its entire
-//! state from before deep-sleep mode was entered.
-//!
-//! Deep-sleep mode clocking of peripherals must be enabled via
-//! SysCtlPeripheralClockGating(); if disabled, the peripheral deep-sleep mode
-//! configuration is maintained but has no effect when deep-sleep mode is
-//! entered.
-//!
-//! The \e ulPeripheral parameter must be one of the following values:
-//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
-//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
-//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
-//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
-//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
-//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
-//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
-//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
-//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
-//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
-//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
-//! \b SYSCTL_PERIPH_WDOG.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralDeepSleepDisable(unsigned long ulPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(SysCtlPeripheralValid(ulPeripheral));
-
-    //
-    // Disable this peripheral in deep-sleep mode.
-    //
-    HWREG(g_pulDCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
-        ~SYSCTL_PERIPH_MASK(ulPeripheral);
-}
-
-//*****************************************************************************
-//
-//! Controls peripheral clock gating in sleep and deep-sleep mode.
-//!
-//! \param bEnable is a boolean that is \b true if the sleep and deep-sleep
-//! peripheral configuration should be used and \b false if not.
-//!
-//! This function controls how peripherals are clocked when the processor goes
-//! into sleep or deep-sleep mode.  By default, the peripherals are clocked the
-//! same as in run mode; if peripheral clock gating is enabled they are clocked
-//! according to the configuration set by SysCtlPeripheralSleepEnable(),
-//! SysCtlPeripheralSleepDisable(), SysCtlPeripheralDeepSleepEnable(), and
-//! SysCtlPeripheralDeepSleepDisable().
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPeripheralClockGating(tBoolean bEnable)
-{
-    //
-    // Enable peripheral clock gating as requested.
-    //
-    if(bEnable)
-    {
-        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_ACG;
-    }
-    else
-    {
-        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_ACG);
-    }
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for the system control interrupt.
-//!
-//! \param pfnHandler is a pointer to the function to be called when the system
-//! control interrupt occurs.
-//!
-//! This sets the handler to be called when a system control interrupt occurs.
-//! This will enable the global interrupt in the interrupt controller; specific
-//! system control interrupts must be enabled via SysCtlIntEnable().  It is the
-//! interrupt handler's responsibility to clear the interrupt source via
-//! SysCtlIntClear().
-//!
-//! System control can generate interrupts when the PLL achieves lock, if the
-//! internal LDO current limit is exceeded, if the internal oscillator fails,
-//! if the main oscillator fails, if the internal LDO output voltage droops too
-//! much, if the external voltage droops too much, or if the PLL fails.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlIntRegister(void (*pfnHandler)(void))
-{
-    //
-    // Register the interrupt handler, returning an error if an error occurs.
-    //
-    IntRegister(INT_SYSCTL, pfnHandler);
-
-    //
-    // Enable the system control interrupt.
-    //
-    IntEnable(INT_SYSCTL);
-}
-
-//*****************************************************************************
-//
-//! Unregisters the interrupt handler for the system control interrupt.
-//!
-//! This function will clear the handler to be called when a system control
-//! interrupt occurs.  This will also mask off the interrupt in the interrupt
-//! controller so that the interrupt handler no longer is called.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlIntUnregister(void)
-{
-    //
-    // Disable the interrupt.
-    //
-    IntDisable(INT_SYSCTL);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(INT_SYSCTL);
-}
-
-//*****************************************************************************
-//
-//! Enables individual system control interrupt sources.
-//!
-//! \param ulInts is a bit mask of the interrupt sources to be enabled.  Must
-//! be a logical OR of \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT,
-//! \b SYSCTL_INT_IOSC_FAIL, \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR,
-//! \b SYSCTL_INT_BOR, and/or \b SYSCTL_INT_PLL_FAIL.
-//!
-//! Enables the indicated system control interrupt sources.  Only the sources
-//! that are enabled can be reflected to the processor interrupt; disabled
-//! sources have no effect on the processor.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlIntEnable(unsigned long ulInts)
-{
-    //
-    // Enable the specified interrupts.
-    //
-    HWREG(SYSCTL_IMC) |= ulInts;
-}
-
-//*****************************************************************************
-//
-//! Disables individual system control interrupt sources.
-//!
-//! \param ulInts is a bit mask of the interrupt sources to be disabled.  Must
-//! be a logical OR of \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT,
-//! \b SYSCTL_INT_IOSC_FAIL, \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR,
-//! \b SYSCTL_INT_BOR, and/or \b SYSCTL_INT_PLL_FAIL.
-//!
-//! Disables the indicated system control interrupt sources.  Only the sources
-//! that are enabled can be reflected to the processor interrupt; disabled
-//! sources have no effect on the processor.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlIntDisable(unsigned long ulInts)
-{
-    //
-    // Disable the specified interrupts.
-    //
-    HWREG(SYSCTL_IMC) &amp;= ~(ulInts);
-}
-
-//*****************************************************************************
-//
-//! Clears system control interrupt sources.
-//!
-//! \param ulInts is a bit mask of the interrupt sources to be cleared.  Must
-//! be a logical OR of \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT,
-//! \b SYSCTL_INT_IOSC_FAIL, \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR,
-//! \b SYSCTL_INT_BOR, and/or \b SYSCTL_INT_PLL_FAIL.
-//!
-//! The specified system control interrupt sources are cleared, so that they no
-//! longer assert.  This must be done in the interrupt handler to keep it from
-//! being called again immediately upon exit.
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlIntClear(unsigned long ulInts)
-{
-    //
-    // Clear the requested interrupt sources.
-    //
-    HWREG(SYSCTL_MISC) = ulInts;
-}
-
-//*****************************************************************************
-//
-//! Gets the current interrupt status.
-//!
-//! \param bMasked is false if the raw interrupt status is required and true if
-//! the masked interrupt status is required.
-//!
-//! This returns the interrupt status for the system controller.  Either the
-//! raw interrupt status or the status of interrupts that are allowed to
-//! reflect to the processor can be returned.
-//!
-//! \return The current interrupt status, enumerated as a bit field of
-//! \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT, \b SYSCTL_INT_IOSC_FAIL,
-//! \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR, \b SYSCTL_INT_BOR, and
-//! \b SYSCTL_INT_PLL_FAIL.
-//
-//*****************************************************************************
-unsigned long
-SysCtlIntStatus(tBoolean bMasked)
-{
-    //
-    // Return either the interrupt status or the raw interrupt status as
-    // requested.
-    //
-    if(bMasked)
-    {
-        return(HWREG(SYSCTL_MISC));
-    }
-    else
-    {
-        return(HWREG(SYSCTL_RIS));
-    }
-}
-
-//*****************************************************************************
-//
-//! Sets the output voltage of the LDO.
-//!
-//! \param ulVoltage is the required output voltage from the LDO.  Must be one
-//! of \b SYSCTL_LDO_2_25V, \b SYSCTL_LDO_2_30V, \b SYSCTL_LDO_2_35V,
-//! \b SYSCTL_LDO_2_40V, \b SYSCTL_LDO_2_45V, \b SYSCTL_LDO_2_50V,
-//! \b SYSCTL_LDO_2_55V, \b SYSCTL_LDO_2_60V, \b SYSCTL_LDO_2_65V,
-//! \b SYSCTL_LDO_2_70V, or \b SYSCTL_LDO_2_75V.
-//!
-//! This function sets the output voltage of the LDO.  The default voltage is
-//! 2.5 V; it can be adjusted +/- 10%.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlLDOSet(unsigned long ulVoltage)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulVoltage == SYSCTL_LDO_2_25V) ||
-           (ulVoltage == SYSCTL_LDO_2_30V) ||
-           (ulVoltage == SYSCTL_LDO_2_35V) ||
-           (ulVoltage == SYSCTL_LDO_2_40V) ||
-           (ulVoltage == SYSCTL_LDO_2_45V) ||
-           (ulVoltage == SYSCTL_LDO_2_50V) ||
-           (ulVoltage == SYSCTL_LDO_2_55V) ||
-           (ulVoltage == SYSCTL_LDO_2_60V) ||
-           (ulVoltage == SYSCTL_LDO_2_65V) ||
-           (ulVoltage == SYSCTL_LDO_2_70V) ||
-           (ulVoltage == SYSCTL_LDO_2_75V));
-
-    //
-    // Set the LDO voltage to the requested value.
-    //
-    HWREG(SYSCTL_LDOPCTL) = ulVoltage;
-}
-
-//*****************************************************************************
-//
-//! Gets the output voltage of the LDO.
-//!
-//! This function determines the output voltage of the LDO, as specified by the
-//! control register.
-//!
-//! \return Returns the current voltage of the LDO; will be one of
-//! \b SYSCTL_LDO_2_25V, \b SYSCTL_LDO_2_30V, \b SYSCTL_LDO_2_35V,
-//! \b SYSCTL_LDO_2_40V, \b SYSCTL_LDO_2_45V, \b SYSCTL_LDO_2_50V,
-//! \b SYSCTL_LDO_2_55V, \b SYSCTL_LDO_2_60V, \b SYSCTL_LDO_2_65V,
-//! \b SYSCTL_LDO_2_70V, or \b SYSCTL_LDO_2_75V.
-//
-//*****************************************************************************
-unsigned long
-SysCtlLDOGet(void)
-{
-    //
-    // Return the LDO voltage setting.
-    //
-    return(HWREG(SYSCTL_LDOPCTL));
-}
-
-//*****************************************************************************
-//
-//! Configures the LDO failure control.
-//!
-//! \param ulConfig is the required LDO failure control setting; can be either
-//! \b SYSCTL_LDOCFG_ARST or \b SYSCTL_LDOCFG_NORST.
-//!
-//! This function allows the LDO to be configured to cause a processor reset
-//! when the output voltage becomes unregulated.
-//!
-//! The LDO failure control is only available on Sandstorm-class devices.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlLDOConfigSet(unsigned long ulConfig)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulConfig == SYSCTL_LDOCFG_ARST) ||
-           (ulConfig == SYSCTL_LDOCFG_NORST));
-
-    //
-    // Set the reset control as requested.
-    //
-    HWREG(SYSCTL_LDOARST) = ulConfig;
-}
-
-//*****************************************************************************
-//
-//! Resets the device.
-//!
-//! This function will perform a software reset of the entire device.  The
-//! processor and all peripherals will be reset and all device registers will
-//! return to their default values (with the exception of the reset cause
-//! register, which will maintain its current value but have the software reset
-//! bit set as well).
-//!
-//! \return This function does not return.
-//
-//*****************************************************************************
-void
-SysCtlReset(void)
-{
-    //
-    // Perform a software reset request.  This will cause the device to reset,
-    // no further code will be executed.
-    //
-    HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ;
-
-    //
-    // The device should have reset, so this should never be reached.  Just in
-    // case, loop forever.
-    //
-    while(1)
-    {
-    }
-}
-
-//*****************************************************************************
-//
-//! Puts the processor into sleep mode.
-//!
-//! This function places the processor into sleep mode; it will not return
-//! until the processor returns to run mode.  The peripherals that are enabled
-//! via SysCtlPeripheralSleepEnable() continue to operate and can wake up the
-//! processor (if automatic clock gating is enabled with
-//! SysCtlPeripheralClockGating(), otherwise all peripherals continue to
-//! operate).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlSleep(void)
-{
-    //
-    // Wait for an interrupt.
-    //
-    CPUwfi();
-}
-
-//*****************************************************************************
-//
-//! Puts the processor into deep-sleep mode.
-//!
-//! This function places the processor into deep-sleep mode; it will not return
-//! until the processor returns to run mode.  The peripherals that are enabled
-//! via SysCtlPeripheralDeepSleepEnable() continue to operate and can wake up
-//! the processor (if automatic clock gating is enabled with
-//! SysCtlPeripheralClockGating(), otherwise all peripherals continue to
-//! operate).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlDeepSleep(void)
-{
-    //
-    // Enable deep-sleep.
-    //
-    HWREG(NVIC_SYS_CTRL) |= NVIC_SYS_CTRL_SLEEPDEEP;
-
-    //
-    // Wait for an interrupt.
-    //
-    CPUwfi();
-
-    //
-    // Disable deep-sleep so that a future sleep will work correctly.
-    //
-    HWREG(NVIC_SYS_CTRL) &amp;= ~(NVIC_SYS_CTRL_SLEEPDEEP);
-}
-
-//*****************************************************************************
-//
-//! Gets the reason for a reset.
-//!
-//! This function will return the reason(s) for a reset.  Since the reset
-//! reasons are sticky until either cleared by software or an external reset,
-//! multiple reset reasons may be returned if multiple resets have occurred.
-//! The reset reason will be a logical OR of \b SYSCTL_CAUSE_LDO,
-//! \b SYSCTL_CAUSE_SW, \b SYSCTL_CAUSE_WDOG, \b SYSCTL_CAUSE_BOR,
-//! \b SYSCTL_CAUSE_POR, and/or \b SYSCTL_CAUSE_EXT.
-//!
-//! \return Returns the reason(s) for a reset.
-//
-//*****************************************************************************
-unsigned long
-SysCtlResetCauseGet(void)
-{
-    //
-    // Return the reset reasons.
-    //
-    return(HWREG(SYSCTL_RESC));
-}
-
-//*****************************************************************************
-//
-//! Clears reset reasons.
-//!
-//! \param ulCauses are the reset causes to be cleared; must be a logical OR of
-//! \b SYSCTL_CAUSE_LDO, \b SYSCTL_CAUSE_SW, \b SYSCTL_CAUSE_WDOG,
-//! \b SYSCTL_CAUSE_BOR, \b SYSCTL_CAUSE_POR, and/or \b SYSCTL_CAUSE_EXT.
-//!
-//! This function clears the specified sticky reset reasons.  Once cleared,
-//! another reset for the same reason can be detected, and a reset for a
-//! different reason can be distinguished (instead of having two reset causes
-//! set).  If the reset reason is used by an application, all reset causes
-//! should be cleared after they are retrieved with SysCtlResetCauseGet().
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlResetCauseClear(unsigned long ulCauses)
-{
-    //
-    // Clear the given reset reasons.
-    //
-    HWREG(SYSCTL_RESC) &amp;= ~(ulCauses);
-}
-
-//*****************************************************************************
-//
-//! Configures the brown-out control.
-//!
-//! \param ulConfig is the desired configuration of the brown-out control.
-//! Must be the logical OR of \b SYSCTL_BOR_RESET and/or
-//! \b SYSCTL_BOR_RESAMPLE.
-//! \param ulDelay is the number of internal oscillator cycles to wait before
-//! resampling an asserted brown-out signal.  This value only has meaning when
-//! \b SYSCTL_BOR_RESAMPLE is set and must be less than 8192.
-//!
-//! This function configures how the brown-out control operates.  It can detect
-//! a brown-out by looking at only the brown-out output, or it can wait for it
-//! to be active for two consecutive samples separated by a configurable time.
-//! When it detects a brown-out condition, it can either reset the device or
-//! generate a processor interrupt.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlBrownOutConfigSet(unsigned long ulConfig, unsigned long ulDelay)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(!(ulConfig &amp; ~(SYSCTL_BOR_RESET | SYSCTL_BOR_RESAMPLE)));
-    ASSERT(ulDelay &lt; 8192);
-
-    //
-    // Configure the brown-out reset control.
-    //
-    HWREG(SYSCTL_PBORCTL) = (ulDelay &lt;&lt; SYSCTL_PBORCTL_BORTIM_S) | ulConfig;
-}
-
-//*****************************************************************************
-//
-//! Provides a small delay.
-//!
-//! \param ulCount is the number of delay loop iterations to perform.
-//!
-//! This function provides a means of generating a constant length delay.  It
-//! is written in assembly to keep the delay consistent across tool chains,
-//! avoiding the need to tune the delay based on the tool chain in use.
-//!
-//! The loop takes 3 cycles/loop.
-//!
-//! \return None.
-//
-//*****************************************************************************
-#if defined(ewarm) || defined(DOXYGEN)
-void
-SysCtlDelay(unsigned long ulCount)
-{
-    __asm(&quot;    subs    r0, #1\n&quot;
-          &quot;    bne.n   SysCtlDelay\n&quot;
-          &quot;    bx      lr&quot;);
-}
-#endif
-#if defined(codered) || defined(gcc) || defined(sourcerygxx)
-void __attribute__((naked))
-SysCtlDelay(unsigned long ulCount)
-{
-    __asm(&quot;    subs    r0, #1\n&quot;
-          &quot;    bne     SysCtlDelay\n&quot;
-          &quot;    bx      lr&quot;);
-}
-#endif
-#if defined(rvmdk) || defined(__ARMCC_VERSION)
-__asm void
-SysCtlDelay(unsigned long ulCount)
-{
-    subs    r0, #1;
-    bne     SysCtlDelay;
-    bx      lr;
-}
-#endif
-
-//*****************************************************************************
-//
-//! Sets the clocking of the device.
-//!
-//! \param ulConfig is the required configuration of the device clocking.
-//!
-//! This function configures the clocking of the device.  The input crystal
-//! frequency, oscillator to be used, use of the PLL, and the system clock
-//! divider are all configured with this function.
-//!
-//! The \e ulConfig parameter is the logical OR of several different values,
-//! many of which are grouped into sets where only one can be chosen.
-//!
-//! The system clock divider is chosen with one of the following values:
-//! \b SYSCTL_SYSDIV_1, \b SYSCTL_SYSDIV_2, \b SYSCTL_SYSDIV_3, ...
-//! \b SYSCTL_SYSDIV_64.  Only \b SYSCTL_SYSDIV_1 through \b SYSCTL_SYSDIV_16
-//! are valid on Sandstorm-class devices.
-//!
-//! The use of the PLL is chosen with either \b SYSCTL_USE_PLL or
-//! \b SYSCTL_USE_OSC.
-//!
-//! The external crystal frequency is chosen with one of the following values:
-//! \b SYSCTL_XTAL_1MHZ, \b SYSCTL_XTAL_1_84MHZ, \b SYSCTL_XTAL_2MHZ,
-//! \b SYSCTL_XTAL_2_45MHZ, \b SYSCTL_XTAL_3_57MHZ, \b SYSCTL_XTAL_3_68MHZ,
-//! \b SYSCTL_XTAL_4MHZ, \b SYSCTL_XTAL_4_09MHZ, \b SYSCTL_XTAL_4_91MHZ,
-//! \b SYSCTL_XTAL_5MHZ, \b SYSCTL_XTAL_5_12MHZ, \b SYSCTL_XTAL_6MHZ,
-//! \b SYSCTL_XTAL_6_14MHZ, \b SYSCTL_XTAL_7_37MHZ, \b SYSCTL_XTAL_8MHZ,
-//! \b SYSCTL_XTAL_8_19MHZ, \b SYSCTL_XTAL_10MHZ, \b SYSCTL_XTAL_12MHZ,
-//! \b SYSCTL_XTAL_12_2MHZ, \b SYSCTL_XTAL_13_5MHZ, \b SYSCTL_XTAL_14_3MHZ,
-//! \b SYSCTL_XTAL_16MHZ, or \b SYSCTL_XTAL_16_3MHZ.  Values below
-//! \b SYSCTL_XTAL_3_57MHZ are not valid when the PLL is in operation.  On
-//! Sandstorm- and Fury-class devices, values above \b SYSCTL_XTAL_8_19MHZ are
-//! not valid.
-//!
-//! The oscillator source is chosen with one of the following values:
-//! \b SYSCTL_OSC_MAIN, \b SYSCTL_OSC_INT, \b SYSCTL_OSC_INT4,
-//! \b SYSCTL_OSC_INT30, or \b SYSCTL_OSC_EXT32.  On Sandstorm-class devices,
-//! \b SYSCTL_OSC_INT30 and \b SYSCTL_OSC_EXT32 are not valid.
-//! \b SYSCTL_OSC_EXT32 is only available on devices with the hibernate module,
-//! and then only when the hibernate module has been enabled.
-//!
-//! The internal and main oscillators are disabled with the
-//! \b SYSCTL_INT_OSC_DIS and \b SYSCTL_MAIN_OSC_DIS flags, respectively.
-//! The external oscillator must be enabled in order to use an external clock
-//! source.  Note that attempts to disable the oscillator used to clock the
-//! device will be prevented by the hardware.
-//!
-//! To clock the system from an external source (such as an external crystal
-//! oscillator), use \b SYSCTL_USE_OSC \b | \b SYSCTL_OSC_MAIN.  To clock the
-//! system from the main oscillator, use \b SYSCTL_USE_OSC \b |
-//! \b SYSCTL_OSC_MAIN.  To clock the system from the PLL, use
-//! \b SYSCTL_USE_PLL \b | \b SYSCTL_OSC_MAIN, and select the appropriate
-//! crystal with one of the \b SYSCTL_XTAL_xxx values.
-//!
-//! \note If selecting the PLL as the system clock source (that is, via
-//! \b SYSCTL_USE_PLL), this function will poll the PLL lock interrupt to
-//! determine when the PLL has locked.  If an interrupt handler for the
-//! system control interrupt is in place, and it responds to and clears the
-//! PLL lock interrupt, this function will delay until its timeout has occurred
-//! instead of completing as soon as PLL lock is achieved.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlClockSet(unsigned long ulConfig)
-{
-    unsigned long ulDelay, ulRCC, ulRCC2;
-
-    //
-    // See if this is a Sandstorm-class device and clocking features from newer
-    // devices were requested.
-    //
-    if(CLASS_IS_SANDSTORM &amp;&amp; (ulConfig &amp; SYSCTL_RCC2_USERCC2))
-    {
-        //
-        // Return without changing the clocking since the requested
-        // configuration can not be achieved.
-        //
-        return;
-    }
-
-    //
-    // Get the current value of the RCC and RCC2 registers.  If using a
-    // Sandstorm-class device, the RCC2 register will read back as zero and the
-    // writes to it from within this function will be ignored.
-    //
-    ulRCC = HWREG(SYSCTL_RCC);
-    ulRCC2 = HWREG(SYSCTL_RCC2);
-
-    //
-    // Bypass the PLL and system clock dividers for now.
-    //
-    ulRCC |= SYSCTL_RCC_BYPASS;
-    ulRCC &amp;= ~(SYSCTL_RCC_USESYSDIV);
-    ulRCC2 |= SYSCTL_RCC2_BYPASS2;
-
-    //
-    // Write the new RCC value.
-    //
-    HWREG(SYSCTL_RCC) = ulRCC;
-    HWREG(SYSCTL_RCC2) = ulRCC2;
-
-    //
-    // See if either oscillator needs to be enabled.
-    //
-    if(((ulRCC &amp; SYSCTL_RCC_IOSCDIS) &amp;&amp; !(ulConfig &amp; SYSCTL_RCC_IOSCDIS)) ||
-       ((ulRCC &amp; SYSCTL_RCC_MOSCDIS) &amp;&amp; !(ulConfig &amp; SYSCTL_RCC_MOSCDIS)))
-    {
-        //
-        // Make sure that the required oscillators are enabled.  For now, the
-        // previously enabled oscillators must be enabled along with the newly
-        // requested oscillators.
-        //
-        ulRCC &amp;= (~(SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS) |
-                  (ulConfig &amp; (SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS)));
-
-        //
-        // Write the new RCC value.
-        //
-        HWREG(SYSCTL_RCC) = ulRCC;
-
-        //
-        // Wait for a bit, giving the oscillator time to stabilize.  The number
-        // of iterations is adjusted based on the current clock source; a
-        // smaller number of iterations is required for slower clock rates.
-        //
-        if(((ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp;
-            (((ulRCC2 &amp; SYSCTL_RCC2_OSCSRC2_M) == SYSCTL_RCC2_OSCSRC2_30) ||
-             ((ulRCC2 &amp; SYSCTL_RCC2_OSCSRC2_M) == SYSCTL_RCC2_OSCSRC2_32))) ||
-           (!(ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp;
-            ((ulRCC &amp; SYSCTL_RCC_OSCSRC_M) == SYSCTL_RCC_OSCSRC_30)))
-        {
-            //
-            // Delay for 4096 iterations.
-            //
-            SysCtlDelay(4096);
-        }
-        else
-        {
-            //
-            // Delay for 524,288 iterations.
-            //
-            SysCtlDelay(524288);
-        }
-    }
-
-    //
-    // Set the new crystal value, oscillator source, and PLL configuration.
-    // Since the OSCSRC2 field in RCC2 overlaps the XTAL field in RCC, the
-    // OSCSRC field has a special encoding within ulConfig to avoid the
-    // overlap.
-    //
-    ulRCC &amp;= ~(SYSCTL_RCC_XTAL_M | SYSCTL_RCC_OSCSRC_M |
-               SYSCTL_RCC_PWRDN | SYSCTL_RCC_OEN);
-    ulRCC |= ulConfig &amp; (SYSCTL_RCC_XTAL_M | SYSCTL_RCC_OSCSRC_M |
-                         SYSCTL_RCC_PWRDN | SYSCTL_RCC_OEN);
-    ulRCC2 &amp;= ~(SYSCTL_RCC2_USERCC2 | SYSCTL_RCC2_OSCSRC2_M |
-                SYSCTL_RCC2_PWRDN2);
-    ulRCC2 |= ulConfig &amp; (SYSCTL_RCC2_USERCC2 | SYSCTL_RCC_OSCSRC_M |
-                          SYSCTL_RCC2_PWRDN2);
-    ulRCC2 |= (ulConfig &amp; 0x00000008) &lt;&lt; 3;
-
-    //
-    // Clear the PLL lock interrupt.
-    //
-    HWREG(SYSCTL_MISC) = SYSCTL_INT_PLL_LOCK;
-
-    //
-    // Write the new RCC value.
-    //
-    if(ulRCC2 &amp; SYSCTL_RCC2_USERCC2)
-    {
-        HWREG(SYSCTL_RCC2) = ulRCC2;
-        HWREG(SYSCTL_RCC) = ulRCC;
-    }
-    else
-    {
-        HWREG(SYSCTL_RCC) = ulRCC;
-        HWREG(SYSCTL_RCC2) = ulRCC2;
-    }
-
-    //
-    // Wait for a bit so that new crystal value and oscillator source can take
-    // effect.
-    //
-    SysCtlDelay(16);
-
-    //
-    // Set the requested system divider and disable the appropriate
-    // oscillators.  This will not get written immediately.
-    //
-    ulRCC &amp;= ~(SYSCTL_RCC_SYSDIV_M | SYSCTL_RCC_USESYSDIV |
-               SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS);
-    ulRCC |= ulConfig &amp; (SYSCTL_RCC_SYSDIV_M | SYSCTL_RCC_USESYSDIV |
-                         SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS);
-    ulRCC2 &amp;= ~(SYSCTL_RCC2_SYSDIV2_M);
-    ulRCC2 |= ulConfig &amp; SYSCTL_RCC2_SYSDIV2_M;
-
-    //
-    // See if the PLL output is being used to clock the system.
-    //
-    if(!(ulConfig &amp; SYSCTL_RCC_BYPASS))
-    {
-        //
-        // Wait until the PLL has locked.
-        //
-        for(ulDelay = 32768; ulDelay &gt; 0; ulDelay--)
-        {
-            if(HWREG(SYSCTL_RIS) &amp; SYSCTL_INT_PLL_LOCK)
-            {
-                break;
-            }
-        }
-
-        //
-        // Enable use of the PLL.
-        //
-        ulRCC &amp;= ~(SYSCTL_RCC_BYPASS);
-        ulRCC2 &amp;= ~(SYSCTL_RCC2_BYPASS2);
-    }
-
-    //
-    // Write the final RCC value.
-    //
-    HWREG(SYSCTL_RCC) = ulRCC;
-    HWREG(SYSCTL_RCC2) = ulRCC2;
-
-    //
-    // Delay for a little bit so that the system divider takes effect.
-    //
-    SysCtlDelay(16);
-}
-
-//*****************************************************************************
-//
-//! Gets the processor clock rate.
-//!
-//! This function determines the clock rate of the processor clock.  This is
-//! also the clock rate of all the peripheral modules (with the exception of
-//! PWM, which has its own clock divider).
-//!
-//! \note This will not return accurate results if SysCtlClockSet() has not
-//! been called to configure the clocking of the device, or if the device is
-//! directly clocked from a crystal (or a clock source) that is not one of the
-//! supported crystal frequencies.  In the later case, this function should be
-//! modified to directly return the correct system clock rate.
-//!
-//! \return The processor clock rate.
-//
-//*****************************************************************************
-unsigned long
-SysCtlClockGet(void)
-{
-    unsigned long ulRCC, ulRCC2, ulPLL, ulClk;
-
-    //
-    // Read RCC and RCC2.  For Sandstorm-class devices (which do not have
-    // RCC2), the RCC2 read will return 0, which indicates that RCC2 is
-    // disabled (since the SYSCTL_RCC2_USERCC2 bit is clear).
-    //
-    ulRCC = HWREG(SYSCTL_RCC);
-    ulRCC2 = HWREG(SYSCTL_RCC2);
-
-    //
-    // Get the base clock rate.
-    //
-    switch((ulRCC2 &amp; SYSCTL_RCC2_USERCC2) ?
-           (ulRCC2 &amp; SYSCTL_RCC2_OSCSRC2_M) :
-           (ulRCC &amp; SYSCTL_RCC_OSCSRC_M))
-    {
-        //
-        // The main oscillator is the clock source.  Determine its rate from
-        // the crystal setting field.
-        //
-        case SYSCTL_RCC_OSCSRC_MAIN:
-        {
-            ulClk = g_pulXtals[(ulRCC &amp; SYSCTL_RCC_XTAL_M) &gt;&gt;
-                               SYSCTL_RCC_XTAL_S];
-            break;
-        }
-
-        //
-        // The internal oscillator is the source clock.
-        //
-        case SYSCTL_RCC_OSCSRC_INT:
-        {
-            //
-            // See if this is a Sandstorm-class or Fury-class device.
-            //
-            if(CLASS_IS_SANDSTORM)
-            {
-                //
-                // The internal oscillator on a Sandstorm-class device is
-                // 15 MHz +/- 50%.
-                //
-                ulClk = 15000000;
-            }
-            else
-            {
-                //
-                // The internal oscillator on a Fury-class device is 12 MHz
-                // +/- 30%.
-                //
-                ulClk = 12000000;
-            }
-            break;
-        }
-
-        //
-        // The internal oscillator divided by four is the source clock.
-        //
-        case SYSCTL_RCC_OSCSRC_INT4:
-        {
-            //
-            // See if this is a Sandstorm-class or Fury-class device.
-            //
-            if(CLASS_IS_SANDSTORM)
-            {
-                //
-                // The internal oscillator on a Sandstorm-class device is
-                // 15 MHz +/- 50%.
-                //
-                ulClk = 15000000 / 4;
-            }
-            else
-            {
-                //
-                // The internal oscillator on a Fury-class device is 12 MHz
-                // +/- 30%.
-                //
-                ulClk = 12000000 / 4;
-            }
-            break;
-        }
-
-        //
-        // The internal 30 KHz oscillator is the source clock.
-        //
-        case SYSCTL_RCC_OSCSRC_30:
-        {
-            //
-            // The internal 30 KHz oscillator has an accuracy of +/- 30%.
-            //
-            ulClk = 30000;
-            break;
-        }
-
-        //
-        // The 32 KHz clock from the hibernate module is the source clock.
-        //
-        case SYSCTL_RCC2_OSCSRC2_32:
-        {
-            ulClk = 32768;
-            break;
-        }
-
-        //
-        // An unknown setting, so return a zero clock (that is, an unknown
-        // clock rate).
-        //
-        default:
-        {
-            return(0);
-        }
-    }
-
-    //
-    // See if the PLL is being used.
-    //
-    if(((ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp; !(ulRCC2 &amp; SYSCTL_RCC2_BYPASS2)) ||
-       (!(ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp; !(ulRCC &amp; SYSCTL_RCC_BYPASS)))
-    {
-        //
-        // Get the PLL configuration.
-        //
-        ulPLL = HWREG(SYSCTL_PLLCFG);
-
-        //
-        // See if this is a Sandstorm-class or Fury-class device.
-        //
-        if(CLASS_IS_SANDSTORM)
-        {
-            //
-            // Compute the PLL output frequency based on its input frequency.
-            // The formula for a Sandstorm-class devices is
-            // &quot;(xtal * (f + 2)) / (r + 2)&quot;.
-            //
-            ulClk = ((ulClk * (((ulPLL &amp; SYSCTL_PLLCFG_F_M) &gt;&gt;
-                                SYSCTL_PLLCFG_F_S) + 2)) /
-                     (((ulPLL &amp; SYSCTL_PLLCFG_R_M) &gt;&gt;
-                       SYSCTL_PLLCFG_R_S) + 2));
-        }
-        else
-        {
-            //
-            // Compute the PLL output frequency based on its input frequency.
-            // The formula for a Fury-class device is
-            // &quot;(xtal * f) / ((r + 1) * 2)&quot;.
-            //
-            ulClk = ((ulClk * ((ulPLL &amp; SYSCTL_PLLCFG_F_M) &gt;&gt;
-                               SYSCTL_PLLCFG_F_S)) /
-                     ((((ulPLL &amp; SYSCTL_PLLCFG_R_M) &gt;&gt;
-                        SYSCTL_PLLCFG_R_S) + 1) * 2));
-        }
-
-        //
-        // See if the optional output divide by 2 is being used.
-        //
-        if(ulPLL &amp; SYSCTL_PLLCFG_OD_2)
-        {
-            ulClk /= 2;
-        }
-
-        //
-        // See if the optional output divide by 4 is being used.
-        //
-        if(ulPLL &amp; SYSCTL_PLLCFG_OD_4)
-        {
-            ulClk /= 4;
-        }
-    }
-
-    //
-    // See if the system divider is being used.
-    //
-    if(ulRCC &amp; SYSCTL_RCC_USESYSDIV)
-    {
-        //
-        // Adjust the clock rate by the system clock divider.
-        //
-        if(ulRCC2 &amp; SYSCTL_RCC2_USERCC2)
-        {
-            ulClk /= (((ulRCC2 &amp; SYSCTL_RCC2_SYSDIV2_M) &gt;&gt;
-                       SYSCTL_RCC2_SYSDIV2_S) + 1);
-        }
-        else
-        {
-            ulClk /= (((ulRCC &amp; SYSCTL_RCC_SYSDIV_M) &gt;&gt; SYSCTL_RCC_SYSDIV_S) +
-                      1);
-        }
-    }
-
-    //
-    // Return the computed clock rate.
-    //
-    return(ulClk);
-}
-
-//*****************************************************************************
-//
-//! Sets the PWM clock configuration.
-//!
-//! \param ulConfig is the configuration for the PWM clock; it must be one of
-//! \b SYSCTL_PWMDIV_1, \b SYSCTL_PWMDIV_2, \b SYSCTL_PWMDIV_4,
-//! \b SYSCTL_PWMDIV_8, \b SYSCTL_PWMDIV_16, \b SYSCTL_PWMDIV_32, or
-//! \b SYSCTL_PWMDIV_64.
-//!
-//! This function sets the rate of the clock provided to the PWM module as a
-//! ratio of the processor clock.  This clock is used by the PWM module to
-//! generate PWM signals; its rate forms the basis for all PWM signals.
-//!
-//! \note The clocking of the PWM is dependent upon the system clock rate as
-//! configured by SysCtlClockSet().
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPWMClockSet(unsigned long ulConfig)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulConfig == SYSCTL_PWMDIV_1) ||
-           (ulConfig == SYSCTL_PWMDIV_2) ||
-           (ulConfig == SYSCTL_PWMDIV_4) ||
-           (ulConfig == SYSCTL_PWMDIV_8) ||
-           (ulConfig == SYSCTL_PWMDIV_16) ||
-           (ulConfig == SYSCTL_PWMDIV_32) ||
-           (ulConfig == SYSCTL_PWMDIV_64));
-
-    //
-    // Check that there is a PWM block on this part.
-    //
-    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_PWM);
-
-    //
-    // Set the PWM clock configuration into the run-mode clock configuration
-    // register.
-    //
-    HWREG(SYSCTL_RCC) = ((HWREG(SYSCTL_RCC) &amp;
-                          ~(SYSCTL_RCC_USEPWMDIV | SYSCTL_RCC_PWMDIV_M)) |
-                         ulConfig);
-}
-
-//*****************************************************************************
-//
-//! Gets the current PWM clock configuration.
-//!
-//! This function returns the current PWM clock configuration.
-//!
-//! \return Returns the current PWM clock configuration; will be one of
-//! \b SYSCTL_PWMDIV_1, \b SYSCTL_PWMDIV_2, \b SYSCTL_PWMDIV_4,
-//! \b SYSCTL_PWMDIV_8, \b SYSCTL_PWMDIV_16, \b SYSCTL_PWMDIV_32, or
-//! \b SYSCTL_PWMDIV_64.
-//
-//*****************************************************************************
-unsigned long
-SysCtlPWMClockGet(void)
-{
-    //
-    // Check that there is a PWM block on this part.
-    //
-    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_PWM);
-
-    //
-    // Return the current PWM clock configuration.  Make sure that
-    // SYSCTL_PWMDIV_1 is returned in all cases where the divider is disabled.
-    //
-    if(!(HWREG(SYSCTL_RCC) &amp; SYSCTL_RCC_USEPWMDIV))
-    {
-        //
-        // The divider is not active so reflect this in the value we return.
-        //
-        return(SYSCTL_PWMDIV_1);
-    }
-    else
-    {
-        //
-        // The divider is active so directly return the masked register value.
-        //
-        return(HWREG(SYSCTL_RCC) &amp;
-               (SYSCTL_RCC_USEPWMDIV | SYSCTL_RCC_PWMDIV_M));
-    }
-}
-
-//*****************************************************************************
-//
-//! Sets the sample rate of the ADC.
-//!
-//! \param ulSpeed is the desired sample rate of the ADC; must be one of
-//! \b SYSCTL_ADCSPEED_1MSPS, \b SYSCTL_ADCSPEED_500KSPS,
-//! \b SYSCTL_ADCSPEED_250KSPS, or \b SYSCTL_ADCSPEED_125KSPS.
-//!
-//! This function sets the rate at which the ADC samples are captured by the
-//! ADC block.  The sampling speed may be limited by the hardware, so the
-//! sample rate may end up being slower than requested.  SysCtlADCSpeedGet()
-//! will return the actual speed in use.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlADCSpeedSet(unsigned long ulSpeed)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulSpeed == SYSCTL_ADCSPEED_1MSPS) ||
-           (ulSpeed == SYSCTL_ADCSPEED_500KSPS) ||
-           (ulSpeed == SYSCTL_ADCSPEED_250KSPS) ||
-           (ulSpeed == SYSCTL_ADCSPEED_125KSPS));
-
-    //
-    // Check that there is an ADC block on this part.
-    //
-    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_ADC);
-
-    //
-    // Set the ADC speed in run, sleep, and deep-sleep mode.
-    //
-    HWREG(SYSCTL_RCGC0) = ((HWREG(SYSCTL_RCGC0) &amp; ~(SYSCTL_RCGC0_ADCSPD_M)) |
-                           ulSpeed);
-    HWREG(SYSCTL_SCGC0) = ((HWREG(SYSCTL_SCGC0) &amp; ~(SYSCTL_SCGC0_ADCSPD_M)) |
-                           ulSpeed);
-    HWREG(SYSCTL_DCGC0) = ((HWREG(SYSCTL_DCGC0) &amp; ~(SYSCTL_DCGC0_ADCSPD_M)) |
-                           ulSpeed);
-}
-
-//*****************************************************************************
-//
-//! Gets the sample rate of the ADC.
-//!
-//! This function gets the current sample rate of the ADC.
-//!
-//! \return Returns the current ADC sample rate; will be one of
-//! \b SYSCTL_ADCSPEED_1MSPS, \b SYSCTL_ADCSPEED_500KSPS,
-//! \b SYSCTL_ADCSPEED_250KSPS, or \b SYSCTL_ADCSPEED_125KSPS.
-//
-//*****************************************************************************
-unsigned long
-SysCtlADCSpeedGet(void)
-{
-    //
-    // Check that there is an ADC block on this part.
-    //
-    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_ADC);
-
-    //
-    // Return the current ADC speed.
-    //
-    return(HWREG(SYSCTL_RCGC0) &amp; SYSCTL_RCGC0_ADCSPD_M);
-}
-
-//*****************************************************************************
-//
-//! Configures the internal oscillator verification timer.
-//!
-//! \param bEnable is a boolean that is \b true if the internal oscillator
-//! verification timer should be enabled.
-//!
-//! This function allows the internal oscillator verification timer to be
-//! enabled or disabled.  When enabled, an interrupt will be generated if the
-//! internal oscillator ceases to operate.
-//!
-//! The internal oscillator verification timer is only available on
-//! Sandstorm-class devices.
-//!
-//! \note Both oscillators (main and internal) must be enabled for this
-//! verification timer to operate as the main oscillator will verify the
-//! internal oscillator.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlIOSCVerificationSet(tBoolean bEnable)
-{
-    //
-    // Enable or disable the internal oscillator verification timer as
-    // requested.
-    //
-    if(bEnable)
-    {
-        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_IOSCVER;
-    }
-    else
-    {
-        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_IOSCVER);
-    }
-}
-
-//*****************************************************************************
-//
-//! Configures the main oscillator verification timer.
-//!
-//! \param bEnable is a boolean that is \b true if the main oscillator
-//! verification timer should be enabled.
-//!
-//! This function allows the main oscillator verification timer to be enabled
-//! or disabled.  When enabled, an interrupt will be generated if the main
-//! oscillator ceases to operate.
-//!
-//! The main oscillator verification timer is only available on
-//! Sandstorm-class devices.
-//!
-//! \note Both oscillators (main and internal) must be enabled for this
-//! verification timer to operate as the internal oscillator will verify the
-//! main oscillator.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlMOSCVerificationSet(tBoolean bEnable)
-{
-    //
-    // Enable or disable the main oscillator verification timer as requested.
-    //
-    if(bEnable)
-    {
-        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_MOSCVER;
-    }
-    else
-    {
-        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_MOSCVER);
-    }
-}
-
-//*****************************************************************************
-//
-//! Configures the PLL verification timer.
-//!
-//! \param bEnable is a boolean that is \b true if the PLL verification timer
-//! should be enabled.
-//!
-//! This function allows the PLL verification timer to be enabled or disabled.
-//! When enabled, an interrupt will be generated if the PLL ceases to operate.
-//!
-//! The PLL verification timer is only available on Sandstorm-class devices.
-//!
-//! \note The main oscillator must be enabled for this verification timer to
-//! operate as it is used to check the PLL.  Also, the verification timer
-//! should be disabled while the PLL is being reconfigured via
-//! SysCtlClockSet().
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlPLLVerificationSet(tBoolean bEnable)
-{
-    //
-    // Enable or disable the PLL verification timer as requested.
-    //
-    if(bEnable)
-    {
-        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_PLLVER;
-    }
-    else
-    {
-        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_PLLVER);
-    }
-}
-
-//*****************************************************************************
-//
-//! Clears the clock verification status.
-//!
-//! This function clears the status of the clock verification timers, allowing
-//! them to assert another failure if detected.
-//!
-//! The clock verification timers are only available on Sandstorm-class
-//! devices.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlClkVerificationClear(void)
-{
-    //
-    // Clear the clock verification.
-    //
-    HWREG(SYSCTL_CLKVCLR) = SYSCTL_CLKVCLR_VERCLR;
-
-    //
-    // The bit does not self-reset, so clear it.
-    //
-    HWREG(SYSCTL_CLKVCLR) = 0;
-}
-
-//*****************************************************************************
-//
-//! Enables a GPIO peripheral for access from the high speed bus.
-//!
-//! \param ulGPIOPeripheral is the GPIO peripheral to enable.
-//!
-//! This function is used to enable the specified GPIO peripherals to be
-//! accessed from the high speed bus instead of the peripheral bus.  When
-//! a GPIO peripheral is enabled for high speed access, the \b _AHB_BASE
-//! form of the base address should be used for GPIO functions.  For example,
-//! instead of using \b GPIO_PORTA_BASE as the base address for GPIO functions,
-//! use \b GPIO_PORTA_AHB_BASE instead.
-//!
-//! The \e ulGPIOPeripheral argument must be only one of the following values:
-//! \b SYSCTL_PERIPH_GPIOA, \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC,
-//! \b SYSCTL_PERIPH_GPIOD, \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF,
-//! \b SYSCTL_PERIPH_GPIOG, or \b SYSCTL_PERIPH_GPIOH.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlGPIOAHBEnable(unsigned long ulGPIOPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulGPIOPeripheral == SYSCTL_PERIPH_GPIOA) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOB) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOC) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOD) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOE) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOF) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOG) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOH));
-
-    //
-    // Enable this GPIO for AHB access.
-    //
-    HWREG(SYSCTL_GPIOHSCTL) |= ulGPIOPeripheral &amp; 0xFFFF;
-}
-
-//*****************************************************************************
-//
-//! Disables a GPIO peripheral for access from the high speed bus.
-//!
-//! \param ulGPIOPeripheral is the GPIO peripheral to disable.
-//!
-//! This function will disable the specified GPIO peripherals for access
-//! from the high speed bus.  Once disabled, the GPIO peripheral is accessed
-//! from the peripheral bus.
-//!
-//! The \b ulGPIOPeripheral argument must be only one of the following values:
-//! \b SYSCTL_PERIPH_GPIOA, \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC,
-//! \b SYSCTL_PERIPH_GPIOD, \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF,
-//! \b SYSCTL_PERIPH_GPIOG, or \b SYSCTL_PERIPH_GPIOH.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlGPIOAHBDisable(unsigned long ulGPIOPeripheral)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulGPIOPeripheral == SYSCTL_PERIPH_GPIOA) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOB) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOC) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOD) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOE) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOF) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOG) ||
-           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOH));
-
-    //
-    // Disable this GPIO for AHB access.
-    //
-    HWREG(SYSCTL_GPIOHSCTL) &amp;= ~(ulGPIOPeripheral &amp; 0xFFFF);
-}
-
-//*****************************************************************************
-//
-//! Powers up the USB PLL.
-//!
-//! This function will enable the USB controller's PLL which is used by it's
-//! physical layer.  This call is necessary before connecting to any external
-//! devices.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlUSBPLLEnable(void)
-{
-    //
-    // Turn on the USB PLL.
-    //
-    HWREG(SYSCTL_RCC2) &amp;= ~SYSCTL_RCC2_USBPWRDN;
-}
-
-//*****************************************************************************
-//
-//! Powers down the USB PLL.
-//!
-//! This function will disable the USB controller's PLL which is used by it's
-//! physical layer.  The USB registers are still accessible, but the physical
-//! layer will no longer function.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysCtlUSBPLLDisable(void)
-{
-    //
-    // Turn of USB PLL.
-    //
-    HWREG(SYSCTL_RCC2) |= SYSCTL_RCC2_USBPWRDN;
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// sysctl.c - Driver for the system controller.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup sysctl_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_nvic.h&quot;
+#include &quot;hw_sysctl.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;cpu.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;sysctl.h&quot;
+
+//*****************************************************************************
+//
+// This macro extracts the array index out of the peripheral number.
+//
+//*****************************************************************************
+#define SYSCTL_PERIPH_INDEX(a)  (((a) &gt;&gt; 28) &amp; 0xf)
+
+//*****************************************************************************
+//
+// This macro constructs the peripheral bit mask from the peripheral number.
+//
+//*****************************************************************************
+#define SYSCTL_PERIPH_MASK(a)   (((a) &amp; 0xffff) &lt;&lt; (((a) &amp; 0x001f0000) &gt;&gt; 16))
+
+//*****************************************************************************
+//
+// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
+// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL DC? register that
+// contains the peripheral present bit for that peripheral.
+//
+//*****************************************************************************
+static const unsigned long g_pulDCRegs[] =
+{
+    SYSCTL_DC1,
+    SYSCTL_DC2,
+    SYSCTL_DC4,
+    SYSCTL_DC1
+};
+
+//*****************************************************************************
+//
+// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
+// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_SRCR? register that
+// controls the software reset for that peripheral.
+//
+//*****************************************************************************
+static const unsigned long g_pulSRCRRegs[] =
+{
+    SYSCTL_SRCR0,
+    SYSCTL_SRCR1,
+    SYSCTL_SRCR2
+};
+
+//*****************************************************************************
+//
+// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
+// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_RCGC? register that
+// controls the run-mode enable for that peripheral.
+//
+//*****************************************************************************
+static const unsigned long g_pulRCGCRegs[] =
+{
+    SYSCTL_RCGC0,
+    SYSCTL_RCGC1,
+    SYSCTL_RCGC2
+};
+
+//*****************************************************************************
+//
+// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
+// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_SCGC? register that
+// controls the sleep-mode enable for that peripheral.
+//
+//*****************************************************************************
+static const unsigned long g_pulSCGCRegs[] =
+{
+    SYSCTL_SCGC0,
+    SYSCTL_SCGC1,
+    SYSCTL_SCGC2
+};
+
+//*****************************************************************************
+//
+// An array that maps the &quot;peripheral set&quot; number (which is stored in the upper
+// nibble of the SYSCTL_PERIPH_* defines) to the SYSCTL_DCGC? register that
+// controls the deep-sleep-mode enable for that peripheral.
+//
+//*****************************************************************************
+static const unsigned long g_pulDCGCRegs[] =
+{
+    SYSCTL_DCGC0,
+    SYSCTL_DCGC1,
+    SYSCTL_DCGC2
+};
+
+//*****************************************************************************
+//
+// An array that maps the crystal number in RCC to a frequency.
+//
+//*****************************************************************************
+static const unsigned long g_pulXtals[] =
+{
+    1000000,
+    1843200,
+    2000000,
+    2457600,
+    3579545,
+    3686400,
+    4000000,
+    4096000,
+    4915200,
+    5000000,
+    5120000,
+    6000000,
+    6144000,
+    7372800,
+    8000000,
+    8192000,
+    10000000,
+    12000000,
+    12288000,
+    13560000,
+    14318180,
+    16000000,
+    16384000
+};
+
+//*****************************************************************************
+//
+//! \internal
+//! Checks a peripheral identifier.
+//!
+//! \param ulPeripheral is the peripheral identifier.
+//!
+//! This function determines if a peripheral identifier is valid.
+//!
+//! \return Returns \b true if the peripheral identifier is valid and \b false
+//! otherwise.
+//
+//*****************************************************************************
+#ifdef DEBUG
+static tBoolean
+SysCtlPeripheralValid(unsigned long ulPeripheral)
+{
+    return((ulPeripheral == SYSCTL_PERIPH_ADC0) ||
+           (ulPeripheral == SYSCTL_PERIPH_ADC1) ||
+           (ulPeripheral == SYSCTL_PERIPH_CAN0) ||
+           (ulPeripheral == SYSCTL_PERIPH_CAN1) ||
+           (ulPeripheral == SYSCTL_PERIPH_CAN2) ||
+           (ulPeripheral == SYSCTL_PERIPH_COMP0) ||
+           (ulPeripheral == SYSCTL_PERIPH_COMP1) ||
+           (ulPeripheral == SYSCTL_PERIPH_COMP2) ||
+           (ulPeripheral == SYSCTL_PERIPH_EPI0) ||
+           (ulPeripheral == SYSCTL_PERIPH_ETH) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOA) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOB) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOC) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOD) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOE) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOF) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOG) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOH) ||
+           (ulPeripheral == SYSCTL_PERIPH_GPIOJ) ||
+           (ulPeripheral == SYSCTL_PERIPH_HIBERNATE) ||
+           (ulPeripheral == SYSCTL_PERIPH_I2C0) ||
+           (ulPeripheral == SYSCTL_PERIPH_I2C1) ||
+           (ulPeripheral == SYSCTL_PERIPH_I2S0) ||
+           (ulPeripheral == SYSCTL_PERIPH_IEEE1588) ||
+           (ulPeripheral == SYSCTL_PERIPH_MPU) ||
+           (ulPeripheral == SYSCTL_PERIPH_PLL) ||
+           (ulPeripheral == SYSCTL_PERIPH_PWM) ||
+           (ulPeripheral == SYSCTL_PERIPH_QEI0) ||
+           (ulPeripheral == SYSCTL_PERIPH_QEI1) ||
+           (ulPeripheral == SYSCTL_PERIPH_SSI0) ||
+           (ulPeripheral == SYSCTL_PERIPH_SSI1) ||
+           (ulPeripheral == SYSCTL_PERIPH_TEMP) ||
+           (ulPeripheral == SYSCTL_PERIPH_TIMER0) ||
+           (ulPeripheral == SYSCTL_PERIPH_TIMER1) ||
+           (ulPeripheral == SYSCTL_PERIPH_TIMER2) ||
+           (ulPeripheral == SYSCTL_PERIPH_TIMER3) ||
+           (ulPeripheral == SYSCTL_PERIPH_UART0) ||
+           (ulPeripheral == SYSCTL_PERIPH_UART1) ||
+           (ulPeripheral == SYSCTL_PERIPH_UART2) ||
+           (ulPeripheral == SYSCTL_PERIPH_UDMA) ||
+           (ulPeripheral == SYSCTL_PERIPH_USB0) ||
+           (ulPeripheral == SYSCTL_PERIPH_WDOG0) ||
+           (ulPeripheral == SYSCTL_PERIPH_WDOG1));
+}
+#endif
+
+//*****************************************************************************
+//
+//! Gets the size of the SRAM.
+//!
+//! This function determines the size of the SRAM on the Stellaris device.
+//!
+//! \return The total number of bytes of SRAM.
+//
+//*****************************************************************************
+unsigned long
+SysCtlSRAMSizeGet(void)
+{
+    //
+    // Compute the size of the SRAM.
+    //
+    return(((HWREG(SYSCTL_DC0) &amp; SYSCTL_DC0_SRAMSZ_M) &gt;&gt; 8) + 0x100);
+}
+
+//*****************************************************************************
+//
+//! Gets the size of the flash.
+//!
+//! This function determines the size of the flash on the Stellaris device.
+//!
+//! \return The total number of bytes of flash.
+//
+//*****************************************************************************
+unsigned long
+SysCtlFlashSizeGet(void)
+{
+    //
+    // Compute the size of the flash.
+    //
+    return(((HWREG(SYSCTL_DC0) &amp; SYSCTL_DC0_FLASHSZ_M) &lt;&lt; 11) + 0x800);
+}
+
+//*****************************************************************************
+//
+//! Determines if a pin is present.
+//!
+//! \param ulPin is the pin in question.
+//!
+//! Determines if a particular pin is present in the device.  The PWM, analog
+//! comparators, ADC, and timers have a varying number of pins across members
+//! of the Stellaris family; this will determine which are present on this
+//! device.
+//!
+//! The \e ulPin argument must be only one of the following values:
+//! \b SYSCTL_PIN_PWM0, \b SYSCTL_PIN_PWM1, \b SYSCTL_PIN_PWM2,
+//! \b SYSCTL_PIN_PWM3, \b SYSCTL_PIN_PWM4, \b SYSCTL_PIN_PWM5,
+//! \b SYSCTL_PIN_C0MINUS, \b SYSCTL_PIN_C0PLUS, \b SYSCTL_PIN_C0O,
+//! \b SYSCTL_PIN_C1MINUS, \b SYSCTL_PIN_C1PLUS, \b SYSCTL_PIN_C1O,
+//! \b SYSCTL_PIN_C2MINUS, \b SYSCTL_PIN_C2PLUS, \b SYSCTL_PIN_C2O,
+//! \b SYSCTL_PIN_ADC0, \b SYSCTL_PIN_ADC1, \b SYSCTL_PIN_ADC2,
+//! \b SYSCTL_PIN_ADC3, \b SYSCTL_PIN_ADC4, \b SYSCTL_PIN_ADC5,
+//! \b SYSCTL_PIN_ADC6, \b SYSCTL_PIN_ADC7, \b SYSCTL_PIN_CCP0,
+//! \b SYSCTL_PIN_CCP1, \b SYSCTL_PIN_CCP2, \b SYSCTL_PIN_CCP3,
+//! \b SYSCTL_PIN_CCP4, \b SYSCTL_PIN_CCP5, \b SYSCTL_PIN_CCP6,
+//! \b SYSCTL_PIN_CCP7, \b SYSCTL_PIN_32KHZ, or \b SYSCTL_PIN_MC_FAULT0.
+//!
+//! \return Returns \b true if the specified pin is present and \b false if it
+//! is not.
+//
+//*****************************************************************************
+tBoolean
+SysCtlPinPresent(unsigned long ulPin)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulPin == SYSCTL_PIN_PWM0) ||
+           (ulPin == SYSCTL_PIN_PWM1) ||
+           (ulPin == SYSCTL_PIN_PWM2) ||
+           (ulPin == SYSCTL_PIN_PWM3) ||
+           (ulPin == SYSCTL_PIN_PWM4) ||
+           (ulPin == SYSCTL_PIN_PWM5) ||
+           (ulPin == SYSCTL_PIN_C0MINUS) ||
+           (ulPin == SYSCTL_PIN_C0PLUS) ||
+           (ulPin == SYSCTL_PIN_C0O) ||
+           (ulPin == SYSCTL_PIN_C1MINUS) ||
+           (ulPin == SYSCTL_PIN_C1PLUS) ||
+           (ulPin == SYSCTL_PIN_C1O) ||
+           (ulPin == SYSCTL_PIN_C2MINUS) ||
+           (ulPin == SYSCTL_PIN_C2PLUS) ||
+           (ulPin == SYSCTL_PIN_C2O) ||
+           (ulPin == SYSCTL_PIN_MC_FAULT0) ||
+           (ulPin == SYSCTL_PIN_ADC0) ||
+           (ulPin == SYSCTL_PIN_ADC1) ||
+           (ulPin == SYSCTL_PIN_ADC2) ||
+           (ulPin == SYSCTL_PIN_ADC3) ||
+           (ulPin == SYSCTL_PIN_ADC4) ||
+           (ulPin == SYSCTL_PIN_ADC5) ||
+           (ulPin == SYSCTL_PIN_ADC6) ||
+           (ulPin == SYSCTL_PIN_ADC7) ||
+           (ulPin == SYSCTL_PIN_CCP0) ||
+           (ulPin == SYSCTL_PIN_CCP1) ||
+           (ulPin == SYSCTL_PIN_CCP2) ||
+           (ulPin == SYSCTL_PIN_CCP3) ||
+           (ulPin == SYSCTL_PIN_CCP4) ||
+           (ulPin == SYSCTL_PIN_CCP5) ||
+           (ulPin == SYSCTL_PIN_32KHZ));
+
+    //
+    // Determine if this pin is present.
+    //
+    if(HWREG(SYSCTL_DC3) &amp; ulPin)
+    {
+        return(true);
+    }
+    else
+    {
+        return(false);
+    }
+}
+
+//*****************************************************************************
+//
+//! Determines if a peripheral is present.
+//!
+//! \param ulPeripheral is the peripheral in question.
+//!
+//! Determines if a particular peripheral is present in the device.  Each
+//! member of the Stellaris family has a different peripheral set; this will
+//! determine which are present on this device.
+//!
+//! The \e ulPeripheral parameter must be only one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_IEEE1588, \b SYSCTL_PERIPH_MPU,
+//! \b SYSCTL_PERIPH_PLL, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TEMP, \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1,
+//! \b SYSCTL_PERIPH_TIMER2, \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0,
+//! \b SYSCTL_PERIPH_UART1, \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA,
+//! \b SYSCTL_PERIPH_USB0, or \b SYSCTL_PERIPH_WDOG.
+//!
+//! \return Returns \b true if the specified peripheral is present and \b false
+//! if it is not.
+//
+//*****************************************************************************
+tBoolean
+SysCtlPeripheralPresent(unsigned long ulPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Read the correct DC register and determine if this peripheral exists.
+    //
+    if(ulPeripheral == SYSCTL_PERIPH_USB0)
+    {
+        //
+        // USB is a special case since the DC bit is missing for USB0.
+        //
+        if(HWREG(SYSCTL_DC6) &amp;&amp; SYSCTL_DC6_USB0_M)
+        {
+            return(true);
+        }
+        else
+        {
+            return(false);
+        }
+    }
+    else if(HWREG(g_pulDCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;
+            SYSCTL_PERIPH_MASK(ulPeripheral))
+    {
+        return(true);
+    }
+    else
+    {
+        return(false);
+    }
+}
+
+//*****************************************************************************
+//
+//! Performs a software reset of a peripheral.
+//!
+//! \param ulPeripheral is the peripheral to reset.
+//!
+//! This function performs a software reset of the specified peripheral.  An
+//! individual peripheral reset signal is asserted for a brief period and then
+//! deasserted, leaving the peripheral in a operating state but in its reset
+//! condition.
+//!
+//! The \e ulPeripheral parameter must be only one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
+//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
+//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
+//! \b SYSCTL_PERIPH_WDOG.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralReset(unsigned long ulPeripheral)
+{
+    volatile unsigned long ulDelay;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Put the peripheral into the reset state.
+    //
+    HWREG(g_pulSRCRRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
+        SYSCTL_PERIPH_MASK(ulPeripheral);
+
+    //
+    // Delay for a little bit.
+    //
+    for(ulDelay = 0; ulDelay &lt; 16; ulDelay++)
+    {
+    }
+
+    //
+    // Take the peripheral out of the reset state.
+    //
+    HWREG(g_pulSRCRRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
+        ~SYSCTL_PERIPH_MASK(ulPeripheral);
+}
+
+//*****************************************************************************
+//
+//! Enables a peripheral.
+//!
+//! \param ulPeripheral is the peripheral to enable.
+//!
+//! Peripherals are enabled with this function.  At power-up, all peripherals
+//! are disabled; they must be enabled in order to operate or respond to
+//! register reads/writes.
+//!
+//! The \e ulPeripheral parameter must be only one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
+//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
+//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
+//! \b SYSCTL_PERIPH_WDOG.
+//!
+//! \note It takes five clock cycles after the write to enable a peripheral
+//! before the the peripheral is actually enabled.  During this time, attempts
+//! to access the peripheral will result in a bus fault.  Care should be taken
+//! to ensure that the peripheral is not accessed during this brief time
+//! period.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralEnable(unsigned long ulPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Enable this peripheral.
+    //
+    HWREG(g_pulRCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
+        SYSCTL_PERIPH_MASK(ulPeripheral);
+}
+
+//*****************************************************************************
+//
+//! Disables a peripheral.
+//!
+//! \param ulPeripheral is the peripheral to disable.
+//!
+//! Peripherals are disabled with this function.  Once disabled, they will not
+//! operate or respond to register reads/writes.
+//!
+//! The \e ulPeripheral parameter must be only one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
+//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
+//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
+//! \b SYSCTL_PERIPH_WDOG.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralDisable(unsigned long ulPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Disable this peripheral.
+    //
+    HWREG(g_pulRCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
+        ~SYSCTL_PERIPH_MASK(ulPeripheral);
+}
+
+//*****************************************************************************
+//
+//! Enables a peripheral in sleep mode.
+//!
+//! \param ulPeripheral is the peripheral to enable in sleep mode.
+//!
+//! This function allows a peripheral to continue operating when the processor
+//! goes into sleep mode.  Since the clocking configuration of the device does
+//! not change, any peripheral can safely continue operating while the
+//! processor is in sleep mode, and can therefore wake the processor from sleep
+//! mode.
+//!
+//! Sleep mode clocking of peripherals must be enabled via
+//! SysCtlPeripheralClockGating(); if disabled, the peripheral sleep mode
+//! configuration is maintained but has no effect when sleep mode is entered.
+//!
+//! The \e ulPeripheral parameter must be only one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
+//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
+//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
+//! \b SYSCTL_PERIPH_WDOG.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralSleepEnable(unsigned long ulPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Enable this peripheral in sleep mode.
+    //
+    HWREG(g_pulSCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
+        SYSCTL_PERIPH_MASK(ulPeripheral);
+}
+
+//*****************************************************************************
+//
+//! Disables a peripheral in sleep mode.
+//!
+//! \param ulPeripheral is the peripheral to disable in sleep mode.
+//!
+//! This function causes a peripheral to stop operating when the processor goes
+//! into sleep mode.  Disabling peripherals while in sleep mode helps to lower
+//! the current draw of the device.  If enabled (via SysCtlPeripheralEnable()),
+//! the peripheral will automatically resume operation when the processor
+//! leaves sleep mode, maintaining its entire state from before sleep mode was
+//! entered.
+//!
+//! Sleep mode clocking of peripherals must be enabled via
+//! SysCtlPeripheralClockGating(); if disabled, the peripheral sleep mode
+//! configuration is maintained but has no effect when sleep mode is entered.
+//!
+//! The \e ulPeripheral parameter must be only one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
+//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
+//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
+//! \b SYSCTL_PERIPH_WDOG.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralSleepDisable(unsigned long ulPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Disable this peripheral in sleep mode.
+    //
+    HWREG(g_pulSCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
+        ~SYSCTL_PERIPH_MASK(ulPeripheral);
+}
+
+//*****************************************************************************
+//
+//! Enables a peripheral in deep-sleep mode.
+//!
+//! \param ulPeripheral is the peripheral to enable in deep-sleep mode.
+//!
+//! This function allows a peripheral to continue operating when the processor
+//! goes into deep-sleep mode.  Since the clocking configuration of the device
+//! may change, not all peripherals can safely continue operating while the
+//! processor is in sleep mode.  Those that must run at a particular frequency
+//! (such as a UART) will not work as expected if the clock changes.  It is the
+//! responsibility of the caller to make sensible choices.
+//!
+//! Deep-sleep mode clocking of peripherals must be enabled via
+//! SysCtlPeripheralClockGating(); if disabled, the peripheral deep-sleep mode
+//! configuration is maintained but has no effect when deep-sleep mode is
+//! entered.
+//!
+//! The \e ulPeripheral parameter must be one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
+//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
+//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
+//! \b SYSCTL_PERIPH_WDOG.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralDeepSleepEnable(unsigned long ulPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Enable this peripheral in deep-sleep mode.
+    //
+    HWREG(g_pulDCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) |=
+        SYSCTL_PERIPH_MASK(ulPeripheral);
+}
+
+//*****************************************************************************
+//
+//! Disables a peripheral in deep-sleep mode.
+//!
+//! \param ulPeripheral is the peripheral to disable in deep-sleep mode.
+//!
+//! This function causes a peripheral to stop operating when the processor goes
+//! into deep-sleep mode.  Disabling peripherals while in deep-sleep mode helps
+//! to lower the current draw of the device, and can keep peripherals that
+//! require a particular clock frequency from operating when the clock changes
+//! as a result of entering deep-sleep mode.  If enabled (via
+//! SysCtlPeripheralEnable()), the peripheral will automatically resume
+//! operation when the processor leaves deep-sleep mode, maintaining its entire
+//! state from before deep-sleep mode was entered.
+//!
+//! Deep-sleep mode clocking of peripherals must be enabled via
+//! SysCtlPeripheralClockGating(); if disabled, the peripheral deep-sleep mode
+//! configuration is maintained but has no effect when deep-sleep mode is
+//! entered.
+//!
+//! The \e ulPeripheral parameter must be one of the following values:
+//! \b SYSCTL_PERIPH_ADC, \b SYSCTL_PERIPH_CAN0, \b SYSCTL_PERIPH_CAN1,
+//! \b SYSCTL_PERIPH_CAN2, \b SYSCTL_PERIPH_COMP0, \b SYSCTL_PERIPH_COMP1,
+//! \b SYSCTL_PERIPH_COMP2, \b SYSCTL_PERIPH_ETH, \b SYSCTL_PERIPH_GPIOA,
+//! \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC, \b SYSCTL_PERIPH_GPIOD,
+//! \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF, \b SYSCTL_PERIPH_GPIOG,
+//! \b SYSCTL_PERIPH_GPIOH, \b SYSCTL_PERIPH_HIBERNATE, \b SYSCTL_PERIPH_I2C0,
+//! \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_PWM, \b SYSCTL_PERIPH_QEI0,
+//! \b SYSCTL_PERIPH_QEI1, \b SYSCTL_PERIPH_SSI0, \b SYSCTL_PERIPH_SSI1,
+//! \b SYSCTL_PERIPH_TIMER0, \b SYSCTL_PERIPH_TIMER1, \b SYSCTL_PERIPH_TIMER2,
+//! \b SYSCTL_PERIPH_TIMER3, \b SYSCTL_PERIPH_UART0, \b SYSCTL_PERIPH_UART1,
+//! \b SYSCTL_PERIPH_UART2, \b SYSCTL_PERIPH_UDMA, \b SYSCTL_PERIPH_USB0, or
+//! \b SYSCTL_PERIPH_WDOG.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralDeepSleepDisable(unsigned long ulPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(SysCtlPeripheralValid(ulPeripheral));
+
+    //
+    // Disable this peripheral in deep-sleep mode.
+    //
+    HWREG(g_pulDCGCRegs[SYSCTL_PERIPH_INDEX(ulPeripheral)]) &amp;=
+        ~SYSCTL_PERIPH_MASK(ulPeripheral);
+}
+
+//*****************************************************************************
+//
+//! Controls peripheral clock gating in sleep and deep-sleep mode.
+//!
+//! \param bEnable is a boolean that is \b true if the sleep and deep-sleep
+//! peripheral configuration should be used and \b false if not.
+//!
+//! This function controls how peripherals are clocked when the processor goes
+//! into sleep or deep-sleep mode.  By default, the peripherals are clocked the
+//! same as in run mode; if peripheral clock gating is enabled they are clocked
+//! according to the configuration set by SysCtlPeripheralSleepEnable(),
+//! SysCtlPeripheralSleepDisable(), SysCtlPeripheralDeepSleepEnable(), and
+//! SysCtlPeripheralDeepSleepDisable().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPeripheralClockGating(tBoolean bEnable)
+{
+    //
+    // Enable peripheral clock gating as requested.
+    //
+    if(bEnable)
+    {
+        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_ACG;
+    }
+    else
+    {
+        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_ACG);
+    }
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the system control interrupt.
+//!
+//! \param pfnHandler is a pointer to the function to be called when the system
+//! control interrupt occurs.
+//!
+//! This sets the handler to be called when a system control interrupt occurs.
+//! This will enable the global interrupt in the interrupt controller; specific
+//! system control interrupts must be enabled via SysCtlIntEnable().  It is the
+//! interrupt handler's responsibility to clear the interrupt source via
+//! SysCtlIntClear().
+//!
+//! System control can generate interrupts when the PLL achieves lock, if the
+//! internal LDO current limit is exceeded, if the internal oscillator fails,
+//! if the main oscillator fails, if the internal LDO output voltage droops too
+//! much, if the external voltage droops too much, or if the PLL fails.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlIntRegister(void (*pfnHandler)(void))
+{
+    //
+    // Register the interrupt handler, returning an error if an error occurs.
+    //
+    IntRegister(INT_SYSCTL, pfnHandler);
+
+    //
+    // Enable the system control interrupt.
+    //
+    IntEnable(INT_SYSCTL);
+}
+
+//*****************************************************************************
+//
+//! Unregisters the interrupt handler for the system control interrupt.
+//!
+//! This function will clear the handler to be called when a system control
+//! interrupt occurs.  This will also mask off the interrupt in the interrupt
+//! controller so that the interrupt handler no longer is called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlIntUnregister(void)
+{
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(INT_SYSCTL);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(INT_SYSCTL);
+}
+
+//*****************************************************************************
+//
+//! Enables individual system control interrupt sources.
+//!
+//! \param ulInts is a bit mask of the interrupt sources to be enabled.  Must
+//! be a logical OR of \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT,
+//! \b SYSCTL_INT_IOSC_FAIL, \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR,
+//! \b SYSCTL_INT_BOR, and/or \b SYSCTL_INT_PLL_FAIL.
+//!
+//! Enables the indicated system control interrupt sources.  Only the sources
+//! that are enabled can be reflected to the processor interrupt; disabled
+//! sources have no effect on the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlIntEnable(unsigned long ulInts)
+{
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(SYSCTL_IMC) |= ulInts;
+}
+
+//*****************************************************************************
+//
+//! Disables individual system control interrupt sources.
+//!
+//! \param ulInts is a bit mask of the interrupt sources to be disabled.  Must
+//! be a logical OR of \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT,
+//! \b SYSCTL_INT_IOSC_FAIL, \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR,
+//! \b SYSCTL_INT_BOR, and/or \b SYSCTL_INT_PLL_FAIL.
+//!
+//! Disables the indicated system control interrupt sources.  Only the sources
+//! that are enabled can be reflected to the processor interrupt; disabled
+//! sources have no effect on the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlIntDisable(unsigned long ulInts)
+{
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(SYSCTL_IMC) &amp;= ~(ulInts);
+}
+
+//*****************************************************************************
+//
+//! Clears system control interrupt sources.
+//!
+//! \param ulInts is a bit mask of the interrupt sources to be cleared.  Must
+//! be a logical OR of \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT,
+//! \b SYSCTL_INT_IOSC_FAIL, \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR,
+//! \b SYSCTL_INT_BOR, and/or \b SYSCTL_INT_PLL_FAIL.
+//!
+//! The specified system control interrupt sources are cleared, so that they no
+//! longer assert.  This must be done in the interrupt handler to keep it from
+//! being called again immediately upon exit.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlIntClear(unsigned long ulInts)
+{
+    //
+    // Clear the requested interrupt sources.
+    //
+    HWREG(SYSCTL_MISC) = ulInts;
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param bMasked is false if the raw interrupt status is required and true if
+//! the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the system controller.  Either the
+//! raw interrupt status or the status of interrupts that are allowed to
+//! reflect to the processor can be returned.
+//!
+//! \return The current interrupt status, enumerated as a bit field of
+//! \b SYSCTL_INT_PLL_LOCK, \b SYSCTL_INT_CUR_LIMIT, \b SYSCTL_INT_IOSC_FAIL,
+//! \b SYSCTL_INT_MOSC_FAIL, \b SYSCTL_INT_POR, \b SYSCTL_INT_BOR, and
+//! \b SYSCTL_INT_PLL_FAIL.
+//
+//*****************************************************************************
+unsigned long
+SysCtlIntStatus(tBoolean bMasked)
+{
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    if(bMasked)
+    {
+        return(HWREG(SYSCTL_MISC));
+    }
+    else
+    {
+        return(HWREG(SYSCTL_RIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Sets the output voltage of the LDO.
+//!
+//! \param ulVoltage is the required output voltage from the LDO.  Must be one
+//! of \b SYSCTL_LDO_2_25V, \b SYSCTL_LDO_2_30V, \b SYSCTL_LDO_2_35V,
+//! \b SYSCTL_LDO_2_40V, \b SYSCTL_LDO_2_45V, \b SYSCTL_LDO_2_50V,
+//! \b SYSCTL_LDO_2_55V, \b SYSCTL_LDO_2_60V, \b SYSCTL_LDO_2_65V,
+//! \b SYSCTL_LDO_2_70V, or \b SYSCTL_LDO_2_75V.
+//!
+//! This function sets the output voltage of the LDO.  The default voltage is
+//! 2.5 V; it can be adjusted +/- 10%.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlLDOSet(unsigned long ulVoltage)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulVoltage == SYSCTL_LDO_2_25V) ||
+           (ulVoltage == SYSCTL_LDO_2_30V) ||
+           (ulVoltage == SYSCTL_LDO_2_35V) ||
+           (ulVoltage == SYSCTL_LDO_2_40V) ||
+           (ulVoltage == SYSCTL_LDO_2_45V) ||
+           (ulVoltage == SYSCTL_LDO_2_50V) ||
+           (ulVoltage == SYSCTL_LDO_2_55V) ||
+           (ulVoltage == SYSCTL_LDO_2_60V) ||
+           (ulVoltage == SYSCTL_LDO_2_65V) ||
+           (ulVoltage == SYSCTL_LDO_2_70V) ||
+           (ulVoltage == SYSCTL_LDO_2_75V));
+
+    //
+    // Set the LDO voltage to the requested value.
+    //
+    HWREG(SYSCTL_LDOPCTL) = ulVoltage;
+}
+
+//*****************************************************************************
+//
+//! Gets the output voltage of the LDO.
+//!
+//! This function determines the output voltage of the LDO, as specified by the
+//! control register.
+//!
+//! \return Returns the current voltage of the LDO; will be one of
+//! \b SYSCTL_LDO_2_25V, \b SYSCTL_LDO_2_30V, \b SYSCTL_LDO_2_35V,
+//! \b SYSCTL_LDO_2_40V, \b SYSCTL_LDO_2_45V, \b SYSCTL_LDO_2_50V,
+//! \b SYSCTL_LDO_2_55V, \b SYSCTL_LDO_2_60V, \b SYSCTL_LDO_2_65V,
+//! \b SYSCTL_LDO_2_70V, or \b SYSCTL_LDO_2_75V.
+//
+//*****************************************************************************
+unsigned long
+SysCtlLDOGet(void)
+{
+    //
+    // Return the LDO voltage setting.
+    //
+    return(HWREG(SYSCTL_LDOPCTL));
+}
+
+//*****************************************************************************
+//
+//! Configures the LDO failure control.
+//!
+//! \param ulConfig is the required LDO failure control setting; can be either
+//! \b SYSCTL_LDOCFG_ARST or \b SYSCTL_LDOCFG_NORST.
+//!
+//! This function allows the LDO to be configured to cause a processor reset
+//! when the output voltage becomes unregulated.
+//!
+//! The LDO failure control is only available on Sandstorm-class devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlLDOConfigSet(unsigned long ulConfig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulConfig == SYSCTL_LDOCFG_ARST) ||
+           (ulConfig == SYSCTL_LDOCFG_NORST));
+
+    //
+    // Set the reset control as requested.
+    //
+    HWREG(SYSCTL_LDOARST) = ulConfig;
+}
+
+//*****************************************************************************
+//
+//! Resets the device.
+//!
+//! This function will perform a software reset of the entire device.  The
+//! processor and all peripherals will be reset and all device registers will
+//! return to their default values (with the exception of the reset cause
+//! register, which will maintain its current value but have the software reset
+//! bit set as well).
+//!
+//! \return This function does not return.
+//
+//*****************************************************************************
+void
+SysCtlReset(void)
+{
+    //
+    // Perform a software reset request.  This will cause the device to reset,
+    // no further code will be executed.
+    //
+    HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ;
+
+    //
+    // The device should have reset, so this should never be reached.  Just in
+    // case, loop forever.
+    //
+    while(1)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+//! Puts the processor into sleep mode.
+//!
+//! This function places the processor into sleep mode; it will not return
+//! until the processor returns to run mode.  The peripherals that are enabled
+//! via SysCtlPeripheralSleepEnable() continue to operate and can wake up the
+//! processor (if automatic clock gating is enabled with
+//! SysCtlPeripheralClockGating(), otherwise all peripherals continue to
+//! operate).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlSleep(void)
+{
+    //
+    // Wait for an interrupt.
+    //
+    CPUwfi();
+}
+
+//*****************************************************************************
+//
+//! Puts the processor into deep-sleep mode.
+//!
+//! This function places the processor into deep-sleep mode; it will not return
+//! until the processor returns to run mode.  The peripherals that are enabled
+//! via SysCtlPeripheralDeepSleepEnable() continue to operate and can wake up
+//! the processor (if automatic clock gating is enabled with
+//! SysCtlPeripheralClockGating(), otherwise all peripherals continue to
+//! operate).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlDeepSleep(void)
+{
+    //
+    // Enable deep-sleep.
+    //
+    HWREG(NVIC_SYS_CTRL) |= NVIC_SYS_CTRL_SLEEPDEEP;
+
+    //
+    // Wait for an interrupt.
+    //
+    CPUwfi();
+
+    //
+    // Disable deep-sleep so that a future sleep will work correctly.
+    //
+    HWREG(NVIC_SYS_CTRL) &amp;= ~(NVIC_SYS_CTRL_SLEEPDEEP);
+}
+
+//*****************************************************************************
+//
+//! Gets the reason for a reset.
+//!
+//! This function will return the reason(s) for a reset.  Since the reset
+//! reasons are sticky until either cleared by software or an external reset,
+//! multiple reset reasons may be returned if multiple resets have occurred.
+//! The reset reason will be a logical OR of \b SYSCTL_CAUSE_LDO,
+//! \b SYSCTL_CAUSE_SW, \b SYSCTL_CAUSE_WDOG, \b SYSCTL_CAUSE_BOR,
+//! \b SYSCTL_CAUSE_POR, and/or \b SYSCTL_CAUSE_EXT.
+//!
+//! \return Returns the reason(s) for a reset.
+//
+//*****************************************************************************
+unsigned long
+SysCtlResetCauseGet(void)
+{
+    //
+    // Return the reset reasons.
+    //
+    return(HWREG(SYSCTL_RESC));
+}
+
+//*****************************************************************************
+//
+//! Clears reset reasons.
+//!
+//! \param ulCauses are the reset causes to be cleared; must be a logical OR of
+//! \b SYSCTL_CAUSE_LDO, \b SYSCTL_CAUSE_SW, \b SYSCTL_CAUSE_WDOG,
+//! \b SYSCTL_CAUSE_BOR, \b SYSCTL_CAUSE_POR, and/or \b SYSCTL_CAUSE_EXT.
+//!
+//! This function clears the specified sticky reset reasons.  Once cleared,
+//! another reset for the same reason can be detected, and a reset for a
+//! different reason can be distinguished (instead of having two reset causes
+//! set).  If the reset reason is used by an application, all reset causes
+//! should be cleared after they are retrieved with SysCtlResetCauseGet().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlResetCauseClear(unsigned long ulCauses)
+{
+    //
+    // Clear the given reset reasons.
+    //
+    HWREG(SYSCTL_RESC) &amp;= ~(ulCauses);
+}
+
+//*****************************************************************************
+//
+//! Configures the brown-out control.
+//!
+//! \param ulConfig is the desired configuration of the brown-out control.
+//! Must be the logical OR of \b SYSCTL_BOR_RESET and/or
+//! \b SYSCTL_BOR_RESAMPLE.
+//! \param ulDelay is the number of internal oscillator cycles to wait before
+//! resampling an asserted brown-out signal.  This value only has meaning when
+//! \b SYSCTL_BOR_RESAMPLE is set and must be less than 8192.
+//!
+//! This function configures how the brown-out control operates.  It can detect
+//! a brown-out by looking at only the brown-out output, or it can wait for it
+//! to be active for two consecutive samples separated by a configurable time.
+//! When it detects a brown-out condition, it can either reset the device or
+//! generate a processor interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlBrownOutConfigSet(unsigned long ulConfig, unsigned long ulDelay)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!(ulConfig &amp; ~(SYSCTL_BOR_RESET | SYSCTL_BOR_RESAMPLE)));
+    ASSERT(ulDelay &lt; 8192);
+
+    //
+    // Configure the brown-out reset control.
+    //
+    HWREG(SYSCTL_PBORCTL) = (ulDelay &lt;&lt; SYSCTL_PBORCTL_BORTIM_S) | ulConfig;
+}
+
+//*****************************************************************************
+//
+//! Provides a small delay.
+//!
+//! \param ulCount is the number of delay loop iterations to perform.
+//!
+//! This function provides a means of generating a constant length delay.  It
+//! is written in assembly to keep the delay consistent across tool chains,
+//! avoiding the need to tune the delay based on the tool chain in use.
+//!
+//! The loop takes 3 cycles/loop.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#if defined(ewarm) || defined(DOXYGEN)
+void
+SysCtlDelay(unsigned long ulCount)
+{
+    __asm(&quot;    subs    r0, #1\n&quot;
+          &quot;    bne.n   SysCtlDelay\n&quot;
+          &quot;    bx      lr&quot;);
+}
+#endif
+#if defined(codered) || defined(gcc) || defined(sourcerygxx)
+void __attribute__((naked))
+SysCtlDelay(unsigned long ulCount)
+{
+    __asm(&quot;    subs    r0, #1\n&quot;
+          &quot;    bne     SysCtlDelay\n&quot;
+          &quot;    bx      lr&quot;);
+}
+#endif
+#if defined(rvmdk) || defined(__ARMCC_VERSION)
+__asm void
+SysCtlDelay(unsigned long ulCount)
+{
+    subs    r0, #1;
+    bne     SysCtlDelay;
+    bx      lr;
+}
+#endif
+
+//*****************************************************************************
+//
+//! Sets the clocking of the device.
+//!
+//! \param ulConfig is the required configuration of the device clocking.
+//!
+//! This function configures the clocking of the device.  The input crystal
+//! frequency, oscillator to be used, use of the PLL, and the system clock
+//! divider are all configured with this function.
+//!
+//! The \e ulConfig parameter is the logical OR of several different values,
+//! many of which are grouped into sets where only one can be chosen.
+//!
+//! The system clock divider is chosen with one of the following values:
+//! \b SYSCTL_SYSDIV_1, \b SYSCTL_SYSDIV_2, \b SYSCTL_SYSDIV_3, ...
+//! \b SYSCTL_SYSDIV_64.  Only \b SYSCTL_SYSDIV_1 through \b SYSCTL_SYSDIV_16
+//! are valid on Sandstorm-class devices.
+//!
+//! The use of the PLL is chosen with either \b SYSCTL_USE_PLL or
+//! \b SYSCTL_USE_OSC.
+//!
+//! The external crystal frequency is chosen with one of the following values:
+//! \b SYSCTL_XTAL_1MHZ, \b SYSCTL_XTAL_1_84MHZ, \b SYSCTL_XTAL_2MHZ,
+//! \b SYSCTL_XTAL_2_45MHZ, \b SYSCTL_XTAL_3_57MHZ, \b SYSCTL_XTAL_3_68MHZ,
+//! \b SYSCTL_XTAL_4MHZ, \b SYSCTL_XTAL_4_09MHZ, \b SYSCTL_XTAL_4_91MHZ,
+//! \b SYSCTL_XTAL_5MHZ, \b SYSCTL_XTAL_5_12MHZ, \b SYSCTL_XTAL_6MHZ,
+//! \b SYSCTL_XTAL_6_14MHZ, \b SYSCTL_XTAL_7_37MHZ, \b SYSCTL_XTAL_8MHZ,
+//! \b SYSCTL_XTAL_8_19MHZ, \b SYSCTL_XTAL_10MHZ, \b SYSCTL_XTAL_12MHZ,
+//! \b SYSCTL_XTAL_12_2MHZ, \b SYSCTL_XTAL_13_5MHZ, \b SYSCTL_XTAL_14_3MHZ,
+//! \b SYSCTL_XTAL_16MHZ, or \b SYSCTL_XTAL_16_3MHZ.  Values below
+//! \b SYSCTL_XTAL_3_57MHZ are not valid when the PLL is in operation.  On
+//! Sandstorm- and Fury-class devices, values above \b SYSCTL_XTAL_8_19MHZ are
+//! not valid.
+//!
+//! The oscillator source is chosen with one of the following values:
+//! \b SYSCTL_OSC_MAIN, \b SYSCTL_OSC_INT, \b SYSCTL_OSC_INT4,
+//! \b SYSCTL_OSC_INT30, or \b SYSCTL_OSC_EXT32.  On Sandstorm-class devices,
+//! \b SYSCTL_OSC_INT30 and \b SYSCTL_OSC_EXT32 are not valid.
+//! \b SYSCTL_OSC_EXT32 is only available on devices with the hibernate module,
+//! and then only when the hibernate module has been enabled.
+//!
+//! The internal and main oscillators are disabled with the
+//! \b SYSCTL_INT_OSC_DIS and \b SYSCTL_MAIN_OSC_DIS flags, respectively.
+//! The external oscillator must be enabled in order to use an external clock
+//! source.  Note that attempts to disable the oscillator used to clock the
+//! device will be prevented by the hardware.
+//!
+//! To clock the system from an external source (such as an external crystal
+//! oscillator), use \b SYSCTL_USE_OSC \b | \b SYSCTL_OSC_MAIN.  To clock the
+//! system from the main oscillator, use \b SYSCTL_USE_OSC \b |
+//! \b SYSCTL_OSC_MAIN.  To clock the system from the PLL, use
+//! \b SYSCTL_USE_PLL \b | \b SYSCTL_OSC_MAIN, and select the appropriate
+//! crystal with one of the \b SYSCTL_XTAL_xxx values.
+//!
+//! \note If selecting the PLL as the system clock source (that is, via
+//! \b SYSCTL_USE_PLL), this function will poll the PLL lock interrupt to
+//! determine when the PLL has locked.  If an interrupt handler for the
+//! system control interrupt is in place, and it responds to and clears the
+//! PLL lock interrupt, this function will delay until its timeout has occurred
+//! instead of completing as soon as PLL lock is achieved.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlClockSet(unsigned long ulConfig)
+{
+    unsigned long ulDelay, ulRCC, ulRCC2;
+
+    //
+    // See if this is a Sandstorm-class device and clocking features from newer
+    // devices were requested.
+    //
+    if(CLASS_IS_SANDSTORM &amp;&amp; (ulConfig &amp; SYSCTL_RCC2_USERCC2))
+    {
+        //
+        // Return without changing the clocking since the requested
+        // configuration can not be achieved.
+        //
+        return;
+    }
+
+    //
+    // Get the current value of the RCC and RCC2 registers.  If using a
+    // Sandstorm-class device, the RCC2 register will read back as zero and the
+    // writes to it from within this function will be ignored.
+    //
+    ulRCC = HWREG(SYSCTL_RCC);
+    ulRCC2 = HWREG(SYSCTL_RCC2);
+
+    //
+    // Bypass the PLL and system clock dividers for now.
+    //
+    ulRCC |= SYSCTL_RCC_BYPASS;
+    ulRCC &amp;= ~(SYSCTL_RCC_USESYSDIV);
+    ulRCC2 |= SYSCTL_RCC2_BYPASS2;
+
+    //
+    // Write the new RCC value.
+    //
+    HWREG(SYSCTL_RCC) = ulRCC;
+    HWREG(SYSCTL_RCC2) = ulRCC2;
+
+    //
+    // See if either oscillator needs to be enabled.
+    //
+    if(((ulRCC &amp; SYSCTL_RCC_IOSCDIS) &amp;&amp; !(ulConfig &amp; SYSCTL_RCC_IOSCDIS)) ||
+       ((ulRCC &amp; SYSCTL_RCC_MOSCDIS) &amp;&amp; !(ulConfig &amp; SYSCTL_RCC_MOSCDIS)))
+    {
+        //
+        // Make sure that the required oscillators are enabled.  For now, the
+        // previously enabled oscillators must be enabled along with the newly
+        // requested oscillators.
+        //
+        ulRCC &amp;= (~(SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS) |
+                  (ulConfig &amp; (SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS)));
+
+        //
+        // Write the new RCC value.
+        //
+        HWREG(SYSCTL_RCC) = ulRCC;
+
+        //
+        // Wait for a bit, giving the oscillator time to stabilize.  The number
+        // of iterations is adjusted based on the current clock source; a
+        // smaller number of iterations is required for slower clock rates.
+        //
+        if(((ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp;
+            (((ulRCC2 &amp; SYSCTL_RCC2_OSCSRC2_M) == SYSCTL_RCC2_OSCSRC2_30) ||
+             ((ulRCC2 &amp; SYSCTL_RCC2_OSCSRC2_M) == SYSCTL_RCC2_OSCSRC2_32))) ||
+           (!(ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp;
+            ((ulRCC &amp; SYSCTL_RCC_OSCSRC_M) == SYSCTL_RCC_OSCSRC_30)))
+        {
+            //
+            // Delay for 4096 iterations.
+            //
+            SysCtlDelay(4096);
+        }
+        else
+        {
+            //
+            // Delay for 524,288 iterations.
+            //
+            SysCtlDelay(524288);
+        }
+    }
+
+    //
+    // Set the new crystal value, oscillator source, and PLL configuration.
+    // Since the OSCSRC2 field in RCC2 overlaps the XTAL field in RCC, the
+    // OSCSRC field has a special encoding within ulConfig to avoid the
+    // overlap.
+    //
+    ulRCC &amp;= ~(SYSCTL_RCC_XTAL_M | SYSCTL_RCC_OSCSRC_M |
+               SYSCTL_RCC_PWRDN | SYSCTL_RCC_OEN);
+    ulRCC |= ulConfig &amp; (SYSCTL_RCC_XTAL_M | SYSCTL_RCC_OSCSRC_M |
+                         SYSCTL_RCC_PWRDN | SYSCTL_RCC_OEN);
+    ulRCC2 &amp;= ~(SYSCTL_RCC2_USERCC2 | SYSCTL_RCC2_OSCSRC2_M |
+                SYSCTL_RCC2_PWRDN2);
+    ulRCC2 |= ulConfig &amp; (SYSCTL_RCC2_USERCC2 | SYSCTL_RCC_OSCSRC_M |
+                          SYSCTL_RCC2_PWRDN2);
+    ulRCC2 |= (ulConfig &amp; 0x00000008) &lt;&lt; 3;
+
+    //
+    // Clear the PLL lock interrupt.
+    //
+    HWREG(SYSCTL_MISC) = SYSCTL_INT_PLL_LOCK;
+
+    //
+    // Write the new RCC value.
+    //
+    if(ulRCC2 &amp; SYSCTL_RCC2_USERCC2)
+    {
+        HWREG(SYSCTL_RCC2) = ulRCC2;
+        HWREG(SYSCTL_RCC) = ulRCC;
+    }
+    else
+    {
+        HWREG(SYSCTL_RCC) = ulRCC;
+        HWREG(SYSCTL_RCC2) = ulRCC2;
+    }
+
+    //
+    // Wait for a bit so that new crystal value and oscillator source can take
+    // effect.
+    //
+    SysCtlDelay(16);
+
+    //
+    // Set the requested system divider and disable the appropriate
+    // oscillators.  This will not get written immediately.
+    //
+    ulRCC &amp;= ~(SYSCTL_RCC_SYSDIV_M | SYSCTL_RCC_USESYSDIV |
+               SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS);
+    ulRCC |= ulConfig &amp; (SYSCTL_RCC_SYSDIV_M | SYSCTL_RCC_USESYSDIV |
+                         SYSCTL_RCC_IOSCDIS | SYSCTL_RCC_MOSCDIS);
+    ulRCC2 &amp;= ~(SYSCTL_RCC2_SYSDIV2_M);
+    ulRCC2 |= ulConfig &amp; SYSCTL_RCC2_SYSDIV2_M;
+    if(ulConfig &amp; SYSCTL_RCC2_USEFRACT)
+    {
+        ulRCC |= SYSCTL_RCC_USESYSDIV;
+        ulRCC2 &amp;= ~(SYSCTL_RCC_USESYSDIV);
+        ulRCC2 |= ulConfig &amp; (SYSCTL_RCC2_USEFRACT | SYSCTL_RCC2_FRACT);
+    }
+    else
+    {
+        ulRCC2 &amp;= ~(SYSCTL_RCC2_USEFRACT);
+    }
+
+    //
+    // See if the PLL output is being used to clock the system.
+    //
+    if(!(ulConfig &amp; SYSCTL_RCC_BYPASS))
+    {
+        //
+        // Wait until the PLL has locked.
+        //
+        for(ulDelay = 32768; ulDelay &gt; 0; ulDelay--)
+        {
+            if(HWREG(SYSCTL_RIS) &amp; SYSCTL_INT_PLL_LOCK)
+            {
+                break;
+            }
+        }
+
+        //
+        // Enable use of the PLL.
+        //
+        ulRCC &amp;= ~(SYSCTL_RCC_BYPASS);
+        ulRCC2 &amp;= ~(SYSCTL_RCC2_BYPASS2);
+    }
+
+    //
+    // Write the final RCC value.
+    //
+    HWREG(SYSCTL_RCC) = ulRCC;
+    HWREG(SYSCTL_RCC2) = ulRCC2;
+
+    //
+    // Delay for a little bit so that the system divider takes effect.
+    //
+    SysCtlDelay(16);
+}
+
+//*****************************************************************************
+//
+//! Gets the processor clock rate.
+//!
+//! This function determines the clock rate of the processor clock.  This is
+//! also the clock rate of all the peripheral modules (with the exception of
+//! PWM, which has its own clock divider).
+//!
+//! \note This will not return accurate results if SysCtlClockSet() has not
+//! been called to configure the clocking of the device, or if the device is
+//! directly clocked from a crystal (or a clock source) that is not one of the
+//! supported crystal frequencies.  In the later case, this function should be
+//! modified to directly return the correct system clock rate.
+//!
+//! \return The processor clock rate.
+//
+//*****************************************************************************
+unsigned long
+SysCtlClockGet(void)
+{
+    unsigned long ulRCC, ulRCC2, ulPLL, ulClk;
+
+    //
+    // Read RCC and RCC2.  For Sandstorm-class devices (which do not have
+    // RCC2), the RCC2 read will return 0, which indicates that RCC2 is
+    // disabled (since the SYSCTL_RCC2_USERCC2 bit is clear).
+    //
+    ulRCC = HWREG(SYSCTL_RCC);
+    ulRCC2 = HWREG(SYSCTL_RCC2);
+
+    //
+    // Get the base clock rate.
+    //
+    switch((ulRCC2 &amp; SYSCTL_RCC2_USERCC2) ?
+           (ulRCC2 &amp; SYSCTL_RCC2_OSCSRC2_M) :
+           (ulRCC &amp; SYSCTL_RCC_OSCSRC_M))
+    {
+        //
+        // The main oscillator is the clock source.  Determine its rate from
+        // the crystal setting field.
+        //
+        case SYSCTL_RCC_OSCSRC_MAIN:
+        {
+            ulClk = g_pulXtals[(ulRCC &amp; SYSCTL_RCC_XTAL_M) &gt;&gt;
+                               SYSCTL_RCC_XTAL_S];
+            break;
+        }
+
+        //
+        // The internal oscillator is the source clock.
+        //
+        case SYSCTL_RCC_OSCSRC_INT:
+        {
+            //
+            // See if this is a Sandstorm-class or Fury-class device.
+            //
+            if(CLASS_IS_SANDSTORM)
+            {
+                //
+                // The internal oscillator on a Sandstorm-class device is
+                // 15 MHz +/- 50%.
+                //
+                ulClk = 15000000;
+            }
+            else if((CLASS_IS_FURY &amp;&amp; REVISION_IS_A2) ||
+                    (CLASS_IS_DUSTDEVIL &amp;&amp; REVISION_IS_A0))
+            {
+                //
+                // The internal oscillator on a rev A2 Fury-class device and a
+                // rev A0 Dustdevil-class device is 12 MHz +/- 30%.
+                //
+                ulClk = 12000000;
+            }
+            else
+            {
+                //
+                // The internal oscillator on all other devices is 16 MHz.
+                //
+                ulClk = 16000000;
+            }
+            break;
+        }
+
+        //
+        // The internal oscillator divided by four is the source clock.
+        //
+        case SYSCTL_RCC_OSCSRC_INT4:
+        {
+            //
+            // See if this is a Sandstorm-class or Fury-class device.
+            //
+            if(CLASS_IS_SANDSTORM)
+            {
+                //
+                // The internal oscillator on a Sandstorm-class device is
+                // 15 MHz +/- 50%.
+                //
+                ulClk = 15000000 / 4;
+            }
+            else if((CLASS_IS_FURY &amp;&amp; REVISION_IS_A2) ||
+                    (CLASS_IS_DUSTDEVIL &amp;&amp; REVISION_IS_A0))
+            {
+                //
+                // The internal oscillator on a rev A2 Fury-class device and a
+                // rev A0 Dustdevil-class device is 12 MHz +/- 30%.
+                //
+                ulClk = 12000000 / 4;
+            }
+            else
+            {
+                //
+                // The internal oscillator on a Tempest-class device is 16 MHz.
+                //
+                ulClk = 16000000 / 4;
+            }
+            break;
+        }
+
+        //
+        // The internal 30 KHz oscillator is the source clock.
+        //
+        case SYSCTL_RCC_OSCSRC_30:
+        {
+            //
+            // The internal 30 KHz oscillator has an accuracy of +/- 30%.
+            //
+            ulClk = 30000;
+            break;
+        }
+
+        //
+        // The 4.19 MHz clock from the hibernate module is the clock source.
+        //
+        case SYSCTL_RCC2_OSCSRC2_419:
+        {
+            ulClk = 4194304;
+            break;
+        }
+
+        //
+        // The 32 KHz clock from the hibernate module is the source clock.
+        //
+        case SYSCTL_RCC2_OSCSRC2_32:
+        {
+            ulClk = 32768;
+            break;
+        }
+
+        //
+        // An unknown setting, so return a zero clock (that is, an unknown
+        // clock rate).
+        //
+        default:
+        {
+            return(0);
+        }
+    }
+
+    //
+    // See if the PLL is being used.
+    //
+    if(((ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp; !(ulRCC2 &amp; SYSCTL_RCC2_BYPASS2)) ||
+       (!(ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp; !(ulRCC &amp; SYSCTL_RCC_BYPASS)))
+    {
+        //
+        // Get the PLL configuration.
+        //
+        ulPLL = HWREG(SYSCTL_PLLCFG);
+
+        //
+        // See if this is a Sandstorm-class or Fury-class device.
+        //
+        if(CLASS_IS_SANDSTORM)
+        {
+            //
+            // Compute the PLL output frequency based on its input frequency.
+            // The formula for a Sandstorm-class devices is
+            // &quot;(xtal * (f + 2)) / (r + 2)&quot;.
+            //
+            ulClk = ((ulClk * (((ulPLL &amp; SYSCTL_PLLCFG_F_M) &gt;&gt;
+                                SYSCTL_PLLCFG_F_S) + 2)) /
+                     (((ulPLL &amp; SYSCTL_PLLCFG_R_M) &gt;&gt;
+                       SYSCTL_PLLCFG_R_S) + 2));
+        }
+        else
+        {
+            //
+            // Compute the PLL output frequency based on its input frequency.
+            // The formula for a Fury-class device is
+            // &quot;(xtal * f) / ((r + 1) * 2)&quot;.
+            //
+            ulClk = ((ulClk * ((ulPLL &amp; SYSCTL_PLLCFG_F_M) &gt;&gt;
+                               SYSCTL_PLLCFG_F_S)) /
+                     ((((ulPLL &amp; SYSCTL_PLLCFG_R_M) &gt;&gt;
+                        SYSCTL_PLLCFG_R_S) + 1) * 2));
+        }
+
+        //
+        // See if the optional output divide by 2 is being used.
+        //
+        if(ulPLL &amp; SYSCTL_PLLCFG_OD_2)
+        {
+            ulClk /= 2;
+        }
+
+        //
+        // See if the optional output divide by 4 is being used.
+        //
+        if(ulPLL &amp; SYSCTL_PLLCFG_OD_4)
+        {
+            ulClk /= 4;
+        }
+
+        //
+        // Force the system divider to be enabled.  It is always used when
+        // using the PLL, but in some cases it will not read as being enabled.
+        //
+        ulRCC |= SYSCTL_RCC_USESYSDIV;
+    }
+
+    //
+    // See if the system divider is being used.
+    //
+    if(ulRCC &amp; SYSCTL_RCC_USESYSDIV)
+    {
+        //
+        // Adjust the clock rate by the system clock divider.
+        //
+        if(ulRCC2 &amp; SYSCTL_RCC2_USERCC2)
+        {
+            if((ulRCC2 &amp; SYSCTL_RCC2_USEFRACT) &amp;&amp;
+               (((ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp;
+                 !(ulRCC2 &amp; SYSCTL_RCC2_BYPASS2)) ||
+                (!(ulRCC2 &amp; SYSCTL_RCC2_USERCC2) &amp;&amp;
+                 !(ulRCC &amp; SYSCTL_RCC_BYPASS))))
+
+            {
+                ulClk = ((ulClk * 2) / (((ulRCC2 &amp; (SYSCTL_RCC2_SYSDIV2_M |
+                                                    SYSCTL_RCC2_FRACT)) &gt;&gt;
+                                         (SYSCTL_RCC2_SYSDIV2_S - 1)) + 1));
+            }
+            else
+            {
+                ulClk /= (((ulRCC2 &amp; SYSCTL_RCC2_SYSDIV2_M) &gt;&gt;
+                           SYSCTL_RCC2_SYSDIV2_S) + 1);
+            }
+        }
+        else
+        {
+            ulClk /= (((ulRCC &amp; SYSCTL_RCC_SYSDIV_M) &gt;&gt; SYSCTL_RCC_SYSDIV_S) +
+                      1);
+        }
+    }
+
+    //
+    // Return the computed clock rate.
+    //
+    return(ulClk);
+}
+
+//*****************************************************************************
+//
+//! Sets the PWM clock configuration.
+//!
+//! \param ulConfig is the configuration for the PWM clock; it must be one of
+//! \b SYSCTL_PWMDIV_1, \b SYSCTL_PWMDIV_2, \b SYSCTL_PWMDIV_4,
+//! \b SYSCTL_PWMDIV_8, \b SYSCTL_PWMDIV_16, \b SYSCTL_PWMDIV_32, or
+//! \b SYSCTL_PWMDIV_64.
+//!
+//! This function sets the rate of the clock provided to the PWM module as a
+//! ratio of the processor clock.  This clock is used by the PWM module to
+//! generate PWM signals; its rate forms the basis for all PWM signals.
+//!
+//! \note The clocking of the PWM is dependent upon the system clock rate as
+//! configured by SysCtlClockSet().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPWMClockSet(unsigned long ulConfig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulConfig == SYSCTL_PWMDIV_1) ||
+           (ulConfig == SYSCTL_PWMDIV_2) ||
+           (ulConfig == SYSCTL_PWMDIV_4) ||
+           (ulConfig == SYSCTL_PWMDIV_8) ||
+           (ulConfig == SYSCTL_PWMDIV_16) ||
+           (ulConfig == SYSCTL_PWMDIV_32) ||
+           (ulConfig == SYSCTL_PWMDIV_64));
+
+    //
+    // Check that there is a PWM block on this part.
+    //
+    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_PWM);
+
+    //
+    // Set the PWM clock configuration into the run-mode clock configuration
+    // register.
+    //
+    HWREG(SYSCTL_RCC) = ((HWREG(SYSCTL_RCC) &amp;
+                          ~(SYSCTL_RCC_USEPWMDIV | SYSCTL_RCC_PWMDIV_M)) |
+                         ulConfig);
+}
+
+//*****************************************************************************
+//
+//! Gets the current PWM clock configuration.
+//!
+//! This function returns the current PWM clock configuration.
+//!
+//! \return Returns the current PWM clock configuration; will be one of
+//! \b SYSCTL_PWMDIV_1, \b SYSCTL_PWMDIV_2, \b SYSCTL_PWMDIV_4,
+//! \b SYSCTL_PWMDIV_8, \b SYSCTL_PWMDIV_16, \b SYSCTL_PWMDIV_32, or
+//! \b SYSCTL_PWMDIV_64.
+//
+//*****************************************************************************
+unsigned long
+SysCtlPWMClockGet(void)
+{
+    //
+    // Check that there is a PWM block on this part.
+    //
+    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_PWM);
+
+    //
+    // Return the current PWM clock configuration.  Make sure that
+    // SYSCTL_PWMDIV_1 is returned in all cases where the divider is disabled.
+    //
+    if(!(HWREG(SYSCTL_RCC) &amp; SYSCTL_RCC_USEPWMDIV))
+    {
+        //
+        // The divider is not active so reflect this in the value we return.
+        //
+        return(SYSCTL_PWMDIV_1);
+    }
+    else
+    {
+        //
+        // The divider is active so directly return the masked register value.
+        //
+        return(HWREG(SYSCTL_RCC) &amp;
+               (SYSCTL_RCC_USEPWMDIV | SYSCTL_RCC_PWMDIV_M));
+    }
+}
+
+//*****************************************************************************
+//
+//! Sets the sample rate of the ADC.
+//!
+//! \param ulSpeed is the desired sample rate of the ADC; must be one of
+//! \b SYSCTL_ADCSPEED_1MSPS, \b SYSCTL_ADCSPEED_500KSPS,
+//! \b SYSCTL_ADCSPEED_250KSPS, or \b SYSCTL_ADCSPEED_125KSPS.
+//!
+//! This function sets the rate at which the ADC samples are captured by the
+//! ADC block.  The sampling speed may be limited by the hardware, so the
+//! sample rate may end up being slower than requested.  SysCtlADCSpeedGet()
+//! will return the actual speed in use.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlADCSpeedSet(unsigned long ulSpeed)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulSpeed == SYSCTL_ADCSPEED_1MSPS) ||
+           (ulSpeed == SYSCTL_ADCSPEED_500KSPS) ||
+           (ulSpeed == SYSCTL_ADCSPEED_250KSPS) ||
+           (ulSpeed == SYSCTL_ADCSPEED_125KSPS));
+
+    //
+    // Check that there is an ADC block on this part.
+    //
+    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_ADC0);
+
+    //
+    // Set the ADC speed in run, sleep, and deep-sleep mode.
+    //
+    HWREG(SYSCTL_RCGC0) = ((HWREG(SYSCTL_RCGC0) &amp; ~(SYSCTL_RCGC0_ADCSPD_M)) |
+                           ulSpeed);
+    HWREG(SYSCTL_SCGC0) = ((HWREG(SYSCTL_SCGC0) &amp; ~(SYSCTL_SCGC0_ADCSPD_M)) |
+                           ulSpeed);
+    HWREG(SYSCTL_DCGC0) = ((HWREG(SYSCTL_DCGC0) &amp; ~(SYSCTL_DCGC0_ADCSPD_M)) |
+                           ulSpeed);
+}
+
+//*****************************************************************************
+//
+//! Gets the sample rate of the ADC.
+//!
+//! This function gets the current sample rate of the ADC.
+//!
+//! \return Returns the current ADC sample rate; will be one of
+//! \b SYSCTL_ADCSPEED_1MSPS, \b SYSCTL_ADCSPEED_500KSPS,
+//! \b SYSCTL_ADCSPEED_250KSPS, or \b SYSCTL_ADCSPEED_125KSPS.
+//
+//*****************************************************************************
+unsigned long
+SysCtlADCSpeedGet(void)
+{
+    //
+    // Check that there is an ADC block on this part.
+    //
+    ASSERT(HWREG(SYSCTL_DC1) &amp; SYSCTL_DC1_ADC0);
+
+    //
+    // Return the current ADC speed.
+    //
+    return(HWREG(SYSCTL_RCGC0) &amp; SYSCTL_RCGC0_ADCSPD_M);
+}
+
+//*****************************************************************************
+//
+//! Configures the internal oscillator verification timer.
+//!
+//! \param bEnable is a boolean that is \b true if the internal oscillator
+//! verification timer should be enabled.
+//!
+//! This function allows the internal oscillator verification timer to be
+//! enabled or disabled.  When enabled, an interrupt will be generated if the
+//! internal oscillator ceases to operate.
+//!
+//! The internal oscillator verification timer is only available on
+//! Sandstorm-class devices.
+//!
+//! \note Both oscillators (main and internal) must be enabled for this
+//! verification timer to operate as the main oscillator will verify the
+//! internal oscillator.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlIOSCVerificationSet(tBoolean bEnable)
+{
+    //
+    // Enable or disable the internal oscillator verification timer as
+    // requested.
+    //
+    if(bEnable)
+    {
+        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_IOSCVER;
+    }
+    else
+    {
+        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_IOSCVER);
+    }
+}
+
+//*****************************************************************************
+//
+//! Configures the main oscillator verification timer.
+//!
+//! \param bEnable is a boolean that is \b true if the main oscillator
+//! verification timer should be enabled.
+//!
+//! This function allows the main oscillator verification timer to be enabled
+//! or disabled.  When enabled, an interrupt will be generated if the main
+//! oscillator ceases to operate.
+//!
+//! The main oscillator verification timer is only available on
+//! Sandstorm-class devices.
+//!
+//! \note Both oscillators (main and internal) must be enabled for this
+//! verification timer to operate as the internal oscillator will verify the
+//! main oscillator.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlMOSCVerificationSet(tBoolean bEnable)
+{
+    //
+    // Enable or disable the main oscillator verification timer as requested.
+    //
+    if(bEnable)
+    {
+        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_MOSCVER;
+    }
+    else
+    {
+        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_MOSCVER);
+    }
+}
+
+//*****************************************************************************
+//
+//! Configures the PLL verification timer.
+//!
+//! \param bEnable is a boolean that is \b true if the PLL verification timer
+//! should be enabled.
+//!
+//! This function allows the PLL verification timer to be enabled or disabled.
+//! When enabled, an interrupt will be generated if the PLL ceases to operate.
+//!
+//! The PLL verification timer is only available on Sandstorm-class devices.
+//!
+//! \note The main oscillator must be enabled for this verification timer to
+//! operate as it is used to check the PLL.  Also, the verification timer
+//! should be disabled while the PLL is being reconfigured via
+//! SysCtlClockSet().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlPLLVerificationSet(tBoolean bEnable)
+{
+    //
+    // Enable or disable the PLL verification timer as requested.
+    //
+    if(bEnable)
+    {
+        HWREG(SYSCTL_RCC) |= SYSCTL_RCC_PLLVER;
+    }
+    else
+    {
+        HWREG(SYSCTL_RCC) &amp;= ~(SYSCTL_RCC_PLLVER);
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears the clock verification status.
+//!
+//! This function clears the status of the clock verification timers, allowing
+//! them to assert another failure if detected.
+//!
+//! The clock verification timers are only available on Sandstorm-class
+//! devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlClkVerificationClear(void)
+{
+    //
+    // Clear the clock verification.
+    //
+    HWREG(SYSCTL_CLKVCLR) = SYSCTL_CLKVCLR_VERCLR;
+
+    //
+    // The bit does not self-reset, so clear it.
+    //
+    HWREG(SYSCTL_CLKVCLR) = 0;
+}
+
+//*****************************************************************************
+//
+//! Enables a GPIO peripheral for access from the AHB.
+//!
+//! \param ulGPIOPeripheral is the GPIO peripheral to enable.
+//!
+//! This function is used to enable the specified GPIO peripheral to be
+//! accessed from the Advanced Host Bus (AHB) instead of the legacy Advanced
+//! Peripheral Bus (APB).  When a GPIO peripheral is enabled for AHB access,
+//! the \b _AHB_BASE form of the base address should be used for GPIO
+//! functions.  For example, instead of using \b GPIO_PORTA_BASE as the base
+//! address for GPIO functions, use \b GPIO_PORTA_AHB_BASE instead.
+//!
+//! The \e ulGPIOPeripheral argument must be only one of the following values:
+//! \b SYSCTL_PERIPH_GPIOA, \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC,
+//! \b SYSCTL_PERIPH_GPIOD, \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF,
+//! \b SYSCTL_PERIPH_GPIOG, or \b SYSCTL_PERIPH_GPIOH.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlGPIOAHBEnable(unsigned long ulGPIOPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulGPIOPeripheral == SYSCTL_PERIPH_GPIOA) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOB) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOC) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOD) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOE) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOF) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOG) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOH) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOJ));
+
+    //
+    // Enable this GPIO for AHB access.
+    //
+    HWREG(SYSCTL_GPIOHSCTL) |= ulGPIOPeripheral &amp; 0xFFFF;
+}
+
+//*****************************************************************************
+//
+//! Disables a GPIO peripheral for access from the AHB.
+//!
+//! \param ulGPIOPeripheral is the GPIO peripheral to disable.
+//!
+//! This function disables the specified GPIO peripheral for access from the
+//! Advanced Host Bus (AHB).  Once disabled, the GPIO peripheral is accessed
+//! from the legacy Advanced Peripheral Bus (AHB).
+//!
+//! The \b ulGPIOPeripheral argument must be only one of the following values:
+//! \b SYSCTL_PERIPH_GPIOA, \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC,
+//! \b SYSCTL_PERIPH_GPIOD, \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF,
+//! \b SYSCTL_PERIPH_GPIOG, or \b SYSCTL_PERIPH_GPIOH.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlGPIOAHBDisable(unsigned long ulGPIOPeripheral)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulGPIOPeripheral == SYSCTL_PERIPH_GPIOA) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOB) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOC) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOD) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOE) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOF) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOG) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOH) ||
+           (ulGPIOPeripheral == SYSCTL_PERIPH_GPIOJ));
+
+    //
+    // Disable this GPIO for AHB access.
+    //
+    HWREG(SYSCTL_GPIOHSCTL) &amp;= ~(ulGPIOPeripheral &amp; 0xFFFF);
+}
+
+//*****************************************************************************
+//
+//! Powers up the USB PLL.
+//!
+//! This function will enable the USB controller's PLL which is used by it's
+//! physical layer.  This call is necessary before connecting to any external
+//! devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlUSBPLLEnable(void)
+{
+    //
+    // Turn on the USB PLL.
+    //
+    HWREG(SYSCTL_RCC2) &amp;= ~SYSCTL_RCC2_USBPWRDN;
+}
+
+//*****************************************************************************
+//
+//! Powers down the USB PLL.
+//!
+//! This function will disable the USB controller's PLL which is used by it's
+//! physical layer.  The USB registers are still accessible, but the physical
+//! layer will no longer function.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysCtlUSBPLLDisable(void)
+{
+    //
+    // Turn of USB PLL.
+    //
+    HWREG(SYSCTL_RCC2) |= SYSCTL_RCC2_USBPWRDN;
+}
+
+//*****************************************************************************
+//
+//! Sets the MCLK frequency provided to the I2S module.
+//!
+//! \param ulInputClock is the input clock to the MCLK divider.  If this is
+//! zero, the value is computed from the current PLL configuration.
+//! \param ulMClk is the desired MCLK frequency.  If this is zero, MCLK output
+//! is disabled.
+//!
+//! This function sets the dividers to provide MCLK to the I2S module.  A MCLK
+//! divider will be chosen that produces the MCLK frequency that is the closest
+//! possible to the requested frequency, which may be above or below the
+//! requested frequency.
+//!
+//! The actual MCLK frequency will be returned.  It is the responsibility of
+//! the application to determine if the selected MCLK is acceptable; in general
+//! the human ear can not discern the frequency difference if it is within 0.3%
+//! of the desired frequency (though there is a very small percentage of the
+//! population that can discern lower frequency deviations).
+//!
+//! \return Returns the actual MCLK frequency.
+//
+//*****************************************************************************
+unsigned long
+SysCtlI2SMClkSet(unsigned long ulInputClock, unsigned long ulMClk)
+{
+    unsigned long ulDivInt, ulDivFrac, ulPLL;
+
+    //
+    // See if the I2S MCLK should be disabled.
+    //
+    if(ulMClk == 0)
+    {
+        //
+        // Disable the I2S MCLK and return.
+        //
+        HWREG(SYSCTL_I2SMCLKCFG) = 0;
+        return(0);
+    }
+
+    //
+    // See if the input clock was specified.
+    //
+    if(ulInputClock == 0)
+    {
+        //
+        // The input clock was not specified, so compute the output frequency
+        // of the PLL.  Get the current PLL configuration.
+        //
+        ulPLL = HWREG(SYSCTL_PLLCFG);
+
+        //
+        // Get the frequency of the crystal in use.
+        //
+        ulInputClock = g_pulXtals[(HWREG(SYSCTL_RCC) &amp; SYSCTL_RCC_XTAL_M) &gt;&gt;
+                                  SYSCTL_RCC_XTAL_S];
+
+        //
+        // Calculate the PLL output frequency.
+        //
+        ulInputClock = ((ulInputClock * ((ulPLL &amp; SYSCTL_PLLCFG_F_M) &gt;&gt;
+                                         SYSCTL_PLLCFG_F_S)) /
+                        ((((ulPLL &amp; SYSCTL_PLLCFG_R_M) &gt;&gt;
+                           SYSCTL_PLLCFG_R_S) + 1)));
+
+        //
+        // See if the optional output divide by 2 is being used.
+        //
+        if(ulPLL &amp; SYSCTL_PLLCFG_OD_2)
+        {
+            ulInputClock /= 2;
+        }
+
+        //
+        // See if the optional output divide by 4 is being used.
+        //
+        if(ulPLL &amp; SYSCTL_PLLCFG_OD_4)
+        {
+            ulInputClock /= 4;
+        }
+    }
+
+    //
+    // Verify that the requested MCLK frequency is attainable.
+    //
+    ASSERT(ulMClk &lt; ulInputClock);
+
+    //
+    // Add a rounding factor to the input clock, so that the MCLK frequency
+    // that is closest to the desire value is selected.
+    //
+    ulInputClock += (ulMClk / 32) - 1;
+
+    //
+    // Compute the integer portion of the MCLK divider.
+    //
+    ulDivInt = ulInputClock / ulMClk;
+
+    //
+    // If the divisor is too large, then simply use the maximum divisor.
+    //
+    if(CLASS_IS_TEMPEST &amp;&amp; REVISION_IS_B1 &amp;&amp; (ulDivInt &gt; 255))
+    {
+        ulDivInt = 255;
+        ulDivFrac = 15;
+    }
+    else if(ulDivInt &gt; 1023)
+    {
+        ulDivInt = 1023;
+        ulDivFrac = 15;
+    }
+    else
+    {
+        //
+        // Compute the fractional portion of the MCLK divider.
+        //
+        ulDivFrac = ((ulInputClock - (ulDivInt * ulMClk)) * 16) / ulMClk;
+    }
+
+    //
+    // Set the divisor for the Tx and Rx MCLK generators and enable the clocks.
+    //
+    HWREG(SYSCTL_I2SMCLKCFG) = (SYSCTL_I2SMCLKCFG_RXEN |
+                                (ulDivInt &lt;&lt; SYSCTL_I2SMCLKCFG_RXI_S) |
+                                (ulDivFrac &lt;&lt; SYSCTL_I2SMCLKCFG_RXF_S) |
+                                SYSCTL_I2SMCLKCFG_TXEN |
+                                (ulDivInt &lt;&lt; SYSCTL_I2SMCLKCFG_TXI_S) |
+                                (ulDivFrac &lt;&lt; SYSCTL_I2SMCLKCFG_TXF_S));
+
+    //
+    // Return the actual MCLK frequency.
+    //
+    ulInputClock -= (ulMClk / 32) - 1;
+    ulDivInt = (ulDivInt * 16) + ulDivFrac;
+    ulMClk = (ulInputClock / ulDivInt) * 16;
+    ulMClk += ((ulInputClock - ((ulMClk / 16) * ulDivInt)) * 16) / ulDivInt;
+    return(ulMClk);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/sysctl.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/sysctl.h
===================================================================
--- trunk/src/platform/lm3s/sysctl.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/sysctl.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,392 +1,469 @@
-//*****************************************************************************
-//
-// sysctl.h - Prototypes for the system control driver.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __SYSCTL_H__
-#define __SYSCTL_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the
-// SysCtlPeripheralPresent(), SysCtlPeripheralEnable(),
-// SysCtlPeripheralDisable(), and SysCtlPeripheralReset() APIs as the
-// ulPeripheral parameter.  The peripherals in the fourth group (upper nibble
-// is 3) can only be used with the SysCtlPeripheralPresent() API.
-//
-//*****************************************************************************
-#define SYSCTL_PERIPH_WDOG      0x00000008  // Watchdog
-#define SYSCTL_PERIPH_HIBERNATE 0x00000040  // Hibernation module
-#define SYSCTL_PERIPH_ADC       0x00100001  // ADC
-#define SYSCTL_PERIPH_PWM       0x00100010  // PWM
-#define SYSCTL_PERIPH_CAN0      0x00100100  // CAN 0
-#define SYSCTL_PERIPH_CAN1      0x00100200  // CAN 1
-#define SYSCTL_PERIPH_CAN2      0x00100400  // CAN 2
-#define SYSCTL_PERIPH_UART0     0x10000001  // UART 0
-#define SYSCTL_PERIPH_UART1     0x10000002  // UART 1
-#define SYSCTL_PERIPH_UART2     0x10000004  // UART 2
-#ifndef DEPRECATED
-#define SYSCTL_PERIPH_SSI       0x10000010  // SSI
-#endif
-#define SYSCTL_PERIPH_SSI0      0x10000010  // SSI 0
-#define SYSCTL_PERIPH_SSI1      0x10000020  // SSI 1
-#ifndef DEPRECATED
-#define SYSCTL_PERIPH_QEI       0x10000100  // QEI
-#endif
-#define SYSCTL_PERIPH_QEI0      0x10000100  // QEI 0
-#define SYSCTL_PERIPH_QEI1      0x10000200  // QEI 1
-#ifndef DEPRECATED
-#define SYSCTL_PERIPH_I2C       0x10001000  // I2C
-#endif
-#define SYSCTL_PERIPH_I2C0      0x10001000  // I2C 0
-#define SYSCTL_PERIPH_I2C1      0x10004000  // I2C 1
-#define SYSCTL_PERIPH_TIMER0    0x10100001  // Timer 0
-#define SYSCTL_PERIPH_TIMER1    0x10100002  // Timer 1
-#define SYSCTL_PERIPH_TIMER2    0x10100004  // Timer 2
-#define SYSCTL_PERIPH_TIMER3    0x10100008  // Timer 3
-#define SYSCTL_PERIPH_COMP0     0x10100100  // Analog comparator 0
-#define SYSCTL_PERIPH_COMP1     0x10100200  // Analog comparator 1
-#define SYSCTL_PERIPH_COMP2     0x10100400  // Analog comparator 2
-#define SYSCTL_PERIPH_GPIOA     0x20000001  // GPIO A
-#define SYSCTL_PERIPH_GPIOB     0x20000002  // GPIO B
-#define SYSCTL_PERIPH_GPIOC     0x20000004  // GPIO C
-#define SYSCTL_PERIPH_GPIOD     0x20000008  // GPIO D
-#define SYSCTL_PERIPH_GPIOE     0x20000010  // GPIO E
-#define SYSCTL_PERIPH_GPIOF     0x20000020  // GPIO F
-#define SYSCTL_PERIPH_GPIOG     0x20000040  // GPIO G
-#define SYSCTL_PERIPH_GPIOH     0x20000080  // GPIO H
-#define SYSCTL_PERIPH_UDMA      0x20002000  // uDMA
-#define SYSCTL_PERIPH_USB0      0x20100001  // USB0
-#define SYSCTL_PERIPH_ETH       0x20105000  // ETH
-#define SYSCTL_PERIPH_IEEE1588  0x20100100  // IEEE1588
-#define SYSCTL_PERIPH_PLL       0x30000010  // PLL
-#define SYSCTL_PERIPH_TEMP      0x30000020  // Temperature sensor
-#define SYSCTL_PERIPH_MPU       0x30000080  // Cortex M3 MPU
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlPinPresent() API
-// as the ulPin parameter.
-//
-//*****************************************************************************
-#define SYSCTL_PIN_PWM0         0x00000001  // PWM0 pin
-#define SYSCTL_PIN_PWM1         0x00000002  // PWM1 pin
-#define SYSCTL_PIN_PWM2         0x00000004  // PWM2 pin
-#define SYSCTL_PIN_PWM3         0x00000008  // PWM3 pin
-#define SYSCTL_PIN_PWM4         0x00000010  // PWM4 pin
-#define SYSCTL_PIN_PWM5         0x00000020  // PWM5 pin
-#define SYSCTL_PIN_PWM6         0x00000040  // PWM6 pin
-#define SYSCTL_PIN_PWM7         0x00000080  // PWM7 pin
-#define SYSCTL_PIN_C0MINUS      0x00000040  // C0- pin
-#define SYSCTL_PIN_C0PLUS       0x00000080  // C0+ pin
-#define SYSCTL_PIN_C0O          0x00000100  // C0o pin
-#define SYSCTL_PIN_C1MINUS      0x00000200  // C1- pin
-#define SYSCTL_PIN_C1PLUS       0x00000400  // C1+ pin
-#define SYSCTL_PIN_C1O          0x00000800  // C1o pin
-#define SYSCTL_PIN_C2MINUS      0x00001000  // C2- pin
-#define SYSCTL_PIN_C2PLUS       0x00002000  // C2+ pin
-#define SYSCTL_PIN_C2O          0x00004000  // C2o pin
-#define SYSCTL_PIN_MC_FAULT0    0x00008000  // MC0 Fault pin
-#define SYSCTL_PIN_ADC0         0x00010000  // ADC0 pin
-#define SYSCTL_PIN_ADC1         0x00020000  // ADC1 pin
-#define SYSCTL_PIN_ADC2         0x00040000  // ADC2 pin
-#define SYSCTL_PIN_ADC3         0x00080000  // ADC3 pin
-#define SYSCTL_PIN_ADC4         0x00100000  // ADC4 pin
-#define SYSCTL_PIN_ADC5         0x00200000  // ADC5 pin
-#define SYSCTL_PIN_ADC6         0x00400000  // ADC6 pin
-#define SYSCTL_PIN_ADC7         0x00800000  // ADC7 pin
-#define SYSCTL_PIN_CCP0         0x01000000  // CCP0 pin
-#define SYSCTL_PIN_CCP1         0x02000000  // CCP1 pin
-#define SYSCTL_PIN_CCP2         0x04000000  // CCP2 pin
-#define SYSCTL_PIN_CCP3         0x08000000  // CCP3 pin
-#define SYSCTL_PIN_CCP4         0x10000000  // CCP4 pin
-#define SYSCTL_PIN_CCP5         0x20000000  // CCP5 pin
-#define SYSCTL_PIN_32KHZ        0x80000000  // 32kHz pin
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlLDOSet() API as
-// the ulVoltage value, or returned by the SysCtlLDOGet() API.
-//
-//*****************************************************************************
-#define SYSCTL_LDO_2_25V        0x00000005  // LDO output of 2.25V
-#define SYSCTL_LDO_2_30V        0x00000004  // LDO output of 2.30V
-#define SYSCTL_LDO_2_35V        0x00000003  // LDO output of 2.35V
-#define SYSCTL_LDO_2_40V        0x00000002  // LDO output of 2.40V
-#define SYSCTL_LDO_2_45V        0x00000001  // LDO output of 2.45V
-#define SYSCTL_LDO_2_50V        0x00000000  // LDO output of 2.50V
-#define SYSCTL_LDO_2_55V        0x0000001f  // LDO output of 2.55V
-#define SYSCTL_LDO_2_60V        0x0000001e  // LDO output of 2.60V
-#define SYSCTL_LDO_2_65V        0x0000001d  // LDO output of 2.65V
-#define SYSCTL_LDO_2_70V        0x0000001c  // LDO output of 2.70V
-#define SYSCTL_LDO_2_75V        0x0000001b  // LDO output of 2.75V
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlLDOConfigSet() API.
-//
-//*****************************************************************************
-#define SYSCTL_LDOCFG_ARST      0x00000001  // Allow LDO failure to reset
-#define SYSCTL_LDOCFG_NORST     0x00000000  // Do not reset on LDO failure
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlIntEnable(),
-// SysCtlIntDisable(), and SysCtlIntClear() APIs, or returned in the bit mask
-// by the SysCtlIntStatus() API.
-//
-//*****************************************************************************
-#define SYSCTL_INT_MOSC_PUP     0x00000100  // MOSC power-up interrupt
-#define SYSCTL_INT_USBPLL_LOCK  0x00000080  // USB PLL lock interrupt
-#define SYSCTL_INT_PLL_LOCK     0x00000040  // PLL lock interrupt
-#define SYSCTL_INT_CUR_LIMIT    0x00000020  // Current limit interrupt
-#define SYSCTL_INT_IOSC_FAIL    0x00000010  // Internal oscillator failure int
-#define SYSCTL_INT_MOSC_FAIL    0x00000008  // Main oscillator failure int
-#define SYSCTL_INT_POR          0x00000004  // Power on reset interrupt
-#define SYSCTL_INT_BOR          0x00000002  // Brown out interrupt
-#define SYSCTL_INT_PLL_FAIL     0x00000001  // PLL failure interrupt
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlResetCauseClear()
-// API or returned by the SysCtlResetCauseGet() API.
-//
-//*****************************************************************************
-#define SYSCTL_CAUSE_LDO        0x00000020  // LDO power not OK reset
-#define SYSCTL_CAUSE_SW         0x00000010  // Software reset
-#define SYSCTL_CAUSE_WDOG       0x00000008  // Watchdog reset
-#define SYSCTL_CAUSE_BOR        0x00000004  // Brown-out reset
-#define SYSCTL_CAUSE_POR        0x00000002  // Power on reset
-#define SYSCTL_CAUSE_EXT        0x00000001  // External reset
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlBrownOutConfigSet()
-// API as the ulConfig parameter.
-//
-//*****************************************************************************
-#define SYSCTL_BOR_RESET        0x00000002  // Reset instead of interrupting
-#define SYSCTL_BOR_RESAMPLE     0x00000001  // Resample BOR before asserting
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlPWMClockSet() API
-// as the ulConfig parameter, and can be returned by the SysCtlPWMClockGet()
-// API.
-//
-//*****************************************************************************
-#define SYSCTL_PWMDIV_1         0x00000000  // PWM clock is processor clock /1
-#define SYSCTL_PWMDIV_2         0x00100000  // PWM clock is processor clock /2
-#define SYSCTL_PWMDIV_4         0x00120000  // PWM clock is processor clock /4
-#define SYSCTL_PWMDIV_8         0x00140000  // PWM clock is processor clock /8
-#define SYSCTL_PWMDIV_16        0x00160000  // PWM clock is processor clock /16
-#define SYSCTL_PWMDIV_32        0x00180000  // PWM clock is processor clock /32
-#define SYSCTL_PWMDIV_64        0x001A0000  // PWM clock is processor clock /64
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlADCSpeedSet() API
-// as the ulSpeed parameter, and can be returned by the SyCtlADCSpeedGet()
-// API.
-//
-//*****************************************************************************
-#define SYSCTL_ADCSPEED_1MSPS   0x00000300  // 1,000,000 samples per second
-#define SYSCTL_ADCSPEED_500KSPS 0x00000200  // 500,000 samples per second
-#define SYSCTL_ADCSPEED_250KSPS 0x00000100  // 250,000 samples per second
-#define SYSCTL_ADCSPEED_125KSPS 0x00000000  // 125,000 samples per second
-
-//*****************************************************************************
-//
-// The following are values that can be passed to the SysCtlClockSet() API as
-// the ulConfig parameter.
-//
-//*****************************************************************************
-#define SYSCTL_SYSDIV_1         0x07800000  // Processor clock is osc/pll /1
-#define SYSCTL_SYSDIV_2         0x00C00000  // Processor clock is osc/pll /2
-#define SYSCTL_SYSDIV_3         0x01400000  // Processor clock is osc/pll /3
-#define SYSCTL_SYSDIV_4         0x01C00000  // Processor clock is osc/pll /4
-#define SYSCTL_SYSDIV_5         0x02400000  // Processor clock is osc/pll /5
-#define SYSCTL_SYSDIV_6         0x02C00000  // Processor clock is osc/pll /6
-#define SYSCTL_SYSDIV_7         0x03400000  // Processor clock is osc/pll /7
-#define SYSCTL_SYSDIV_8         0x03C00000  // Processor clock is osc/pll /8
-#define SYSCTL_SYSDIV_9         0x04400000  // Processor clock is osc/pll /9
-#define SYSCTL_SYSDIV_10        0x04C00000  // Processor clock is osc/pll /10
-#define SYSCTL_SYSDIV_11        0x05400000  // Processor clock is osc/pll /11
-#define SYSCTL_SYSDIV_12        0x05C00000  // Processor clock is osc/pll /12
-#define SYSCTL_SYSDIV_13        0x06400000  // Processor clock is osc/pll /13
-#define SYSCTL_SYSDIV_14        0x06C00000  // Processor clock is osc/pll /14
-#define SYSCTL_SYSDIV_15        0x07400000  // Processor clock is osc/pll /15
-#define SYSCTL_SYSDIV_16        0x07C00000  // Processor clock is osc/pll /16
-#define SYSCTL_SYSDIV_17        0x88400000  // Processor clock is osc/pll /17
-#define SYSCTL_SYSDIV_18        0x88C00000  // Processor clock is osc/pll /18
-#define SYSCTL_SYSDIV_19        0x89400000  // Processor clock is osc/pll /19
-#define SYSCTL_SYSDIV_20        0x89C00000  // Processor clock is osc/pll /20
-#define SYSCTL_SYSDIV_21        0x8A400000  // Processor clock is osc/pll /21
-#define SYSCTL_SYSDIV_22        0x8AC00000  // Processor clock is osc/pll /22
-#define SYSCTL_SYSDIV_23        0x8B400000  // Processor clock is osc/pll /23
-#define SYSCTL_SYSDIV_24        0x8BC00000  // Processor clock is osc/pll /24
-#define SYSCTL_SYSDIV_25        0x8C400000  // Processor clock is osc/pll /25
-#define SYSCTL_SYSDIV_26        0x8CC00000  // Processor clock is osc/pll /26
-#define SYSCTL_SYSDIV_27        0x8D400000  // Processor clock is osc/pll /27
-#define SYSCTL_SYSDIV_28        0x8DC00000  // Processor clock is osc/pll /28
-#define SYSCTL_SYSDIV_29        0x8E400000  // Processor clock is osc/pll /29
-#define SYSCTL_SYSDIV_30        0x8EC00000  // Processor clock is osc/pll /30
-#define SYSCTL_SYSDIV_31        0x8F400000  // Processor clock is osc/pll /31
-#define SYSCTL_SYSDIV_32        0x8FC00000  // Processor clock is osc/pll /32
-#define SYSCTL_SYSDIV_33        0x90400000  // Processor clock is osc/pll /33
-#define SYSCTL_SYSDIV_34        0x90C00000  // Processor clock is osc/pll /34
-#define SYSCTL_SYSDIV_35        0x91400000  // Processor clock is osc/pll /35
-#define SYSCTL_SYSDIV_36        0x91C00000  // Processor clock is osc/pll /36
-#define SYSCTL_SYSDIV_37        0x92400000  // Processor clock is osc/pll /37
-#define SYSCTL_SYSDIV_38        0x92C00000  // Processor clock is osc/pll /38
-#define SYSCTL_SYSDIV_39        0x93400000  // Processor clock is osc/pll /39
-#define SYSCTL_SYSDIV_40        0x93C00000  // Processor clock is osc/pll /40
-#define SYSCTL_SYSDIV_41        0x94400000  // Processor clock is osc/pll /41
-#define SYSCTL_SYSDIV_42        0x94C00000  // Processor clock is osc/pll /42
-#define SYSCTL_SYSDIV_43        0x95400000  // Processor clock is osc/pll /43
-#define SYSCTL_SYSDIV_44        0x95C00000  // Processor clock is osc/pll /44
-#define SYSCTL_SYSDIV_45        0x96400000  // Processor clock is osc/pll /45
-#define SYSCTL_SYSDIV_46        0x96C00000  // Processor clock is osc/pll /46
-#define SYSCTL_SYSDIV_47        0x97400000  // Processor clock is osc/pll /47
-#define SYSCTL_SYSDIV_48        0x97C00000  // Processor clock is osc/pll /48
-#define SYSCTL_SYSDIV_49        0x98400000  // Processor clock is osc/pll /49
-#define SYSCTL_SYSDIV_50        0x98C00000  // Processor clock is osc/pll /50
-#define SYSCTL_SYSDIV_51        0x99400000  // Processor clock is osc/pll /51
-#define SYSCTL_SYSDIV_52        0x99C00000  // Processor clock is osc/pll /52
-#define SYSCTL_SYSDIV_53        0x9A400000  // Processor clock is osc/pll /53
-#define SYSCTL_SYSDIV_54        0x9AC00000  // Processor clock is osc/pll /54
-#define SYSCTL_SYSDIV_55        0x9B400000  // Processor clock is osc/pll /55
-#define SYSCTL_SYSDIV_56        0x9BC00000  // Processor clock is osc/pll /56
-#define SYSCTL_SYSDIV_57        0x9C400000  // Processor clock is osc/pll /57
-#define SYSCTL_SYSDIV_58        0x9CC00000  // Processor clock is osc/pll /58
-#define SYSCTL_SYSDIV_59        0x9D400000  // Processor clock is osc/pll /59
-#define SYSCTL_SYSDIV_60        0x9DC00000  // Processor clock is osc/pll /60
-#define SYSCTL_SYSDIV_61        0x9E400000  // Processor clock is osc/pll /61
-#define SYSCTL_SYSDIV_62        0x9EC00000  // Processor clock is osc/pll /62
-#define SYSCTL_SYSDIV_63        0x9F400000  // Processor clock is osc/pll /63
-#define SYSCTL_SYSDIV_64        0x9FC00000  // Processor clock is osc/pll /64
-#define SYSCTL_USE_PLL          0x00000000  // System clock is the PLL clock
-#define SYSCTL_USE_OSC          0x00003800  // System clock is the osc clock
-#define SYSCTL_XTAL_1MHZ        0x00000000  // External crystal is 1MHz
-#define SYSCTL_XTAL_1_84MHZ     0x00000040  // External crystal is 1.8432MHz
-#define SYSCTL_XTAL_2MHZ        0x00000080  // External crystal is 2MHz
-#define SYSCTL_XTAL_2_45MHZ     0x000000C0  // External crystal is 2.4576MHz
-#define SYSCTL_XTAL_3_57MHZ     0x00000100  // External crystal is 3.579545MHz
-#define SYSCTL_XTAL_3_68MHZ     0x00000140  // External crystal is 3.6864MHz
-#define SYSCTL_XTAL_4MHZ        0x00000180  // External crystal is 4MHz
-#define SYSCTL_XTAL_4_09MHZ     0x000001C0  // External crystal is 4.096MHz
-#define SYSCTL_XTAL_4_91MHZ     0x00000200  // External crystal is 4.9152MHz
-#define SYSCTL_XTAL_5MHZ        0x00000240  // External crystal is 5MHz
-#define SYSCTL_XTAL_5_12MHZ     0x00000280  // External crystal is 5.12MHz
-#define SYSCTL_XTAL_6MHZ        0x000002C0  // External crystal is 6MHz
-#define SYSCTL_XTAL_6_14MHZ     0x00000300  // External crystal is 6.144MHz
-#define SYSCTL_XTAL_7_37MHZ     0x00000340  // External crystal is 7.3728MHz
-#define SYSCTL_XTAL_8MHZ        0x00000380  // External crystal is 8MHz
-#define SYSCTL_XTAL_8_19MHZ     0x000003C0  // External crystal is 8.192MHz
-#define SYSCTL_XTAL_10MHZ       0x00000400  // External crystal is 10 MHz
-#define SYSCTL_XTAL_12MHZ       0x00000440  // External crystal is 12 MHz
-#define SYSCTL_XTAL_12_2MHZ     0x00000480  // External crystal is 12.288 MHz
-#define SYSCTL_XTAL_13_5MHZ     0x000004C0  // External crystal is 13.56 MHz
-#define SYSCTL_XTAL_14_3MHZ     0x00000500  // External crystal is 14.31818 MHz
-#define SYSCTL_XTAL_16MHZ       0x00000540  // External crystal is 16 MHz
-#define SYSCTL_XTAL_16_3MHZ     0x00000580  // External crystal is 16.384 MHz
-#define SYSCTL_OSC_MAIN         0x00000000  // Osc source is main osc
-#define SYSCTL_OSC_INT          0x00000010  // Osc source is int. osc
-#define SYSCTL_OSC_INT4         0x00000020  // Osc source is int. osc /4
-#define SYSCTL_OSC_INT30        0x00000030  // Osc source is int. 30 KHz
-#define SYSCTL_OSC_EXT32        0x80000038  // Osc source is ext. 32 KHz
-#define SYSCTL_INT_OSC_DIS      0x00000002  // Disable internal oscillator
-#define SYSCTL_MAIN_OSC_DIS     0x00000001  // Disable main oscillator
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern unsigned long SysCtlSRAMSizeGet(void);
-extern unsigned long SysCtlFlashSizeGet(void);
-extern tBoolean SysCtlPinPresent(unsigned long ulPin);
-extern tBoolean SysCtlPeripheralPresent(unsigned long ulPeripheral);
-extern void SysCtlPeripheralReset(unsigned long ulPeripheral);
-extern void SysCtlPeripheralEnable(unsigned long ulPeripheral);
-extern void SysCtlPeripheralDisable(unsigned long ulPeripheral);
-extern void SysCtlPeripheralSleepEnable(unsigned long ulPeripheral);
-extern void SysCtlPeripheralSleepDisable(unsigned long ulPeripheral);
-extern void SysCtlPeripheralDeepSleepEnable(unsigned long ulPeripheral);
-extern void SysCtlPeripheralDeepSleepDisable(unsigned long ulPeripheral);
-extern void SysCtlPeripheralClockGating(tBoolean bEnable);
-extern void SysCtlIntRegister(void (*pfnHandler)(void));
-extern void SysCtlIntUnregister(void);
-extern void SysCtlIntEnable(unsigned long ulInts);
-extern void SysCtlIntDisable(unsigned long ulInts);
-extern void SysCtlIntClear(unsigned long ulInts);
-extern unsigned long SysCtlIntStatus(tBoolean bMasked);
-extern void SysCtlLDOSet(unsigned long ulVoltage);
-extern unsigned long SysCtlLDOGet(void);
-extern void SysCtlLDOConfigSet(unsigned long ulConfig);
-extern void SysCtlReset(void);
-extern void SysCtlSleep(void);
-extern void SysCtlDeepSleep(void);
-extern unsigned long SysCtlResetCauseGet(void);
-extern void SysCtlResetCauseClear(unsigned long ulCauses);
-extern void SysCtlBrownOutConfigSet(unsigned long ulConfig,
-                                    unsigned long ulDelay);
-extern void SysCtlDelay(unsigned long ulCount);
-extern void SysCtlClockSet(unsigned long ulConfig);
-extern unsigned long SysCtlClockGet(void);
-extern void SysCtlPWMClockSet(unsigned long ulConfig);
-extern unsigned long SysCtlPWMClockGet(void);
-extern void SysCtlADCSpeedSet(unsigned long ulSpeed);
-extern unsigned long SysCtlADCSpeedGet(void);
-extern void SysCtlIOSCVerificationSet(tBoolean bEnable);
-extern void SysCtlMOSCVerificationSet(tBoolean bEnable);
-extern void SysCtlPLLVerificationSet(tBoolean bEnable);
-extern void SysCtlClkVerificationClear(void);
-extern void SysCtlGPIOAHBEnable(unsigned long ulGPIOPeripheral);
-extern void SysCtlGPIOAHBDisable(unsigned long ulGPIOPeripheral);
-extern void SysCtlUSBPLLEnable(void);
-extern void SysCtlUSBPLLDisable(void);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __SYSCTL_H__
+//*****************************************************************************
+//
+// sysctl.h - Prototypes for the system control driver.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __SYSCTL_H__
+#define __SYSCTL_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the
+// SysCtlPeripheralPresent(), SysCtlPeripheralEnable(),
+// SysCtlPeripheralDisable(), and SysCtlPeripheralReset() APIs as the
+// ulPeripheral parameter.  The peripherals in the fourth group (upper nibble
+// is 3) can only be used with the SysCtlPeripheralPresent() API.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#define SYSCTL_PERIPH_WDOG      0x00000008  // Watchdog
+#endif
+#define SYSCTL_PERIPH_WDOG0     0x00000008  // Watchdog 0
+#define SYSCTL_PERIPH_HIBERNATE 0x00000040  // Hibernation module
+#ifndef DEPRECATED
+#define SYSCTL_PERIPH_ADC       0x00100001  // ADC
+#endif
+#define SYSCTL_PERIPH_ADC0      0x00100001  // ADC0
+#define SYSCTL_PERIPH_ADC1      0x00100002  // ADC1
+#define SYSCTL_PERIPH_PWM       0x00100010  // PWM
+#define SYSCTL_PERIPH_CAN0      0x00100100  // CAN 0
+#define SYSCTL_PERIPH_CAN1      0x00100200  // CAN 1
+#define SYSCTL_PERIPH_CAN2      0x00100400  // CAN 2
+#define SYSCTL_PERIPH_WDOG1     0x00101000  // Watchdog 1
+#define SYSCTL_PERIPH_UART0     0x10000001  // UART 0
+#define SYSCTL_PERIPH_UART1     0x10000002  // UART 1
+#define SYSCTL_PERIPH_UART2     0x10000004  // UART 2
+#ifndef DEPRECATED
+#define SYSCTL_PERIPH_SSI       0x10000010  // SSI
+#endif
+#define SYSCTL_PERIPH_SSI0      0x10000010  // SSI 0
+#define SYSCTL_PERIPH_SSI1      0x10000020  // SSI 1
+#ifndef DEPRECATED
+#define SYSCTL_PERIPH_QEI       0x10000100  // QEI
+#endif
+#define SYSCTL_PERIPH_QEI0      0x10000100  // QEI 0
+#define SYSCTL_PERIPH_QEI1      0x10000200  // QEI 1
+#ifndef DEPRECATED
+#define SYSCTL_PERIPH_I2C       0x10001000  // I2C
+#endif
+#define SYSCTL_PERIPH_I2C0      0x10001000  // I2C 0
+#define SYSCTL_PERIPH_I2C1      0x10004000  // I2C 1
+#define SYSCTL_PERIPH_TIMER0    0x10100001  // Timer 0
+#define SYSCTL_PERIPH_TIMER1    0x10100002  // Timer 1
+#define SYSCTL_PERIPH_TIMER2    0x10100004  // Timer 2
+#define SYSCTL_PERIPH_TIMER3    0x10100008  // Timer 3
+#define SYSCTL_PERIPH_COMP0     0x10100100  // Analog comparator 0
+#define SYSCTL_PERIPH_COMP1     0x10100200  // Analog comparator 1
+#define SYSCTL_PERIPH_COMP2     0x10100400  // Analog comparator 2
+#define SYSCTL_PERIPH_I2S0      0x10101000  // I2S0
+#define SYSCTL_PERIPH_EPI0      0x10104000  // EPI0
+#define SYSCTL_PERIPH_GPIOA     0x20000001  // GPIO A
+#define SYSCTL_PERIPH_GPIOB     0x20000002  // GPIO B
+#define SYSCTL_PERIPH_GPIOC     0x20000004  // GPIO C
+#define SYSCTL_PERIPH_GPIOD     0x20000008  // GPIO D
+#define SYSCTL_PERIPH_GPIOE     0x20000010  // GPIO E
+#define SYSCTL_PERIPH_GPIOF     0x20000020  // GPIO F
+#define SYSCTL_PERIPH_GPIOG     0x20000040  // GPIO G
+#define SYSCTL_PERIPH_GPIOH     0x20000080  // GPIO H
+#define SYSCTL_PERIPH_GPIOJ     0x20000100  // GPIO J
+#define SYSCTL_PERIPH_UDMA      0x20002000  // uDMA
+#define SYSCTL_PERIPH_USB0      0x20100001  // USB0
+#define SYSCTL_PERIPH_ETH       0x20105000  // ETH
+#define SYSCTL_PERIPH_IEEE1588  0x20100100  // IEEE1588
+#define SYSCTL_PERIPH_PLL       0x30000010  // PLL
+#define SYSCTL_PERIPH_TEMP      0x30000020  // Temperature sensor
+#define SYSCTL_PERIPH_MPU       0x30000080  // Cortex M3 MPU
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlPinPresent() API
+// as the ulPin parameter.
+//
+//*****************************************************************************
+#define SYSCTL_PIN_PWM0         0x00000001  // PWM0 pin
+#define SYSCTL_PIN_PWM1         0x00000002  // PWM1 pin
+#define SYSCTL_PIN_PWM2         0x00000004  // PWM2 pin
+#define SYSCTL_PIN_PWM3         0x00000008  // PWM3 pin
+#define SYSCTL_PIN_PWM4         0x00000010  // PWM4 pin
+#define SYSCTL_PIN_PWM5         0x00000020  // PWM5 pin
+#define SYSCTL_PIN_PWM6         0x00000040  // PWM6 pin
+#define SYSCTL_PIN_PWM7         0x00000080  // PWM7 pin
+#define SYSCTL_PIN_C0MINUS      0x00000040  // C0- pin
+#define SYSCTL_PIN_C0PLUS       0x00000080  // C0+ pin
+#define SYSCTL_PIN_C0O          0x00000100  // C0o pin
+#define SYSCTL_PIN_C1MINUS      0x00000200  // C1- pin
+#define SYSCTL_PIN_C1PLUS       0x00000400  // C1+ pin
+#define SYSCTL_PIN_C1O          0x00000800  // C1o pin
+#define SYSCTL_PIN_C2MINUS      0x00001000  // C2- pin
+#define SYSCTL_PIN_C2PLUS       0x00002000  // C2+ pin
+#define SYSCTL_PIN_C2O          0x00004000  // C2o pin
+#define SYSCTL_PIN_MC_FAULT0    0x00008000  // MC0 Fault pin
+#define SYSCTL_PIN_ADC0         0x00010000  // ADC0 pin
+#define SYSCTL_PIN_ADC1         0x00020000  // ADC1 pin
+#define SYSCTL_PIN_ADC2         0x00040000  // ADC2 pin
+#define SYSCTL_PIN_ADC3         0x00080000  // ADC3 pin
+#define SYSCTL_PIN_ADC4         0x00100000  // ADC4 pin
+#define SYSCTL_PIN_ADC5         0x00200000  // ADC5 pin
+#define SYSCTL_PIN_ADC6         0x00400000  // ADC6 pin
+#define SYSCTL_PIN_ADC7         0x00800000  // ADC7 pin
+#define SYSCTL_PIN_CCP0         0x01000000  // CCP0 pin
+#define SYSCTL_PIN_CCP1         0x02000000  // CCP1 pin
+#define SYSCTL_PIN_CCP2         0x04000000  // CCP2 pin
+#define SYSCTL_PIN_CCP3         0x08000000  // CCP3 pin
+#define SYSCTL_PIN_CCP4         0x10000000  // CCP4 pin
+#define SYSCTL_PIN_CCP5         0x20000000  // CCP5 pin
+#define SYSCTL_PIN_32KHZ        0x80000000  // 32kHz pin
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlLDOSet() API as
+// the ulVoltage value, or returned by the SysCtlLDOGet() API.
+//
+//*****************************************************************************
+#define SYSCTL_LDO_2_25V        0x00000005  // LDO output of 2.25V
+#define SYSCTL_LDO_2_30V        0x00000004  // LDO output of 2.30V
+#define SYSCTL_LDO_2_35V        0x00000003  // LDO output of 2.35V
+#define SYSCTL_LDO_2_40V        0x00000002  // LDO output of 2.40V
+#define SYSCTL_LDO_2_45V        0x00000001  // LDO output of 2.45V
+#define SYSCTL_LDO_2_50V        0x00000000  // LDO output of 2.50V
+#define SYSCTL_LDO_2_55V        0x0000001f  // LDO output of 2.55V
+#define SYSCTL_LDO_2_60V        0x0000001e  // LDO output of 2.60V
+#define SYSCTL_LDO_2_65V        0x0000001d  // LDO output of 2.65V
+#define SYSCTL_LDO_2_70V        0x0000001c  // LDO output of 2.70V
+#define SYSCTL_LDO_2_75V        0x0000001b  // LDO output of 2.75V
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlLDOConfigSet() API.
+//
+//*****************************************************************************
+#define SYSCTL_LDOCFG_ARST      0x00000001  // Allow LDO failure to reset
+#define SYSCTL_LDOCFG_NORST     0x00000000  // Do not reset on LDO failure
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlIntEnable(),
+// SysCtlIntDisable(), and SysCtlIntClear() APIs, or returned in the bit mask
+// by the SysCtlIntStatus() API.
+//
+//*****************************************************************************
+#define SYSCTL_INT_MOSC_PUP     0x00000100  // MOSC power-up interrupt
+#define SYSCTL_INT_USBPLL_LOCK  0x00000080  // USB PLL lock interrupt
+#define SYSCTL_INT_PLL_LOCK     0x00000040  // PLL lock interrupt
+#define SYSCTL_INT_CUR_LIMIT    0x00000020  // Current limit interrupt
+#define SYSCTL_INT_IOSC_FAIL    0x00000010  // Internal oscillator failure int
+#define SYSCTL_INT_MOSC_FAIL    0x00000008  // Main oscillator failure int
+#define SYSCTL_INT_POR          0x00000004  // Power on reset interrupt
+#define SYSCTL_INT_BOR          0x00000002  // Brown out interrupt
+#define SYSCTL_INT_PLL_FAIL     0x00000001  // PLL failure interrupt
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlResetCauseClear()
+// API or returned by the SysCtlResetCauseGet() API.
+//
+//*****************************************************************************
+#define SYSCTL_CAUSE_LDO        0x00000020  // LDO power not OK reset
+#define SYSCTL_CAUSE_SW         0x00000010  // Software reset
+#define SYSCTL_CAUSE_WDOG       0x00000008  // Watchdog reset
+#define SYSCTL_CAUSE_BOR        0x00000004  // Brown-out reset
+#define SYSCTL_CAUSE_POR        0x00000002  // Power on reset
+#define SYSCTL_CAUSE_EXT        0x00000001  // External reset
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlBrownOutConfigSet()
+// API as the ulConfig parameter.
+//
+//*****************************************************************************
+#define SYSCTL_BOR_RESET        0x00000002  // Reset instead of interrupting
+#define SYSCTL_BOR_RESAMPLE     0x00000001  // Resample BOR before asserting
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlPWMClockSet() API
+// as the ulConfig parameter, and can be returned by the SysCtlPWMClockGet()
+// API.
+//
+//*****************************************************************************
+#define SYSCTL_PWMDIV_1         0x00000000  // PWM clock is processor clock /1
+#define SYSCTL_PWMDIV_2         0x00100000  // PWM clock is processor clock /2
+#define SYSCTL_PWMDIV_4         0x00120000  // PWM clock is processor clock /4
+#define SYSCTL_PWMDIV_8         0x00140000  // PWM clock is processor clock /8
+#define SYSCTL_PWMDIV_16        0x00160000  // PWM clock is processor clock /16
+#define SYSCTL_PWMDIV_32        0x00180000  // PWM clock is processor clock /32
+#define SYSCTL_PWMDIV_64        0x001A0000  // PWM clock is processor clock /64
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlADCSpeedSet() API
+// as the ulSpeed parameter, and can be returned by the SyCtlADCSpeedGet()
+// API.
+//
+//*****************************************************************************
+#define SYSCTL_ADCSPEED_1MSPS   0x00000300  // 1,000,000 samples per second
+#define SYSCTL_ADCSPEED_500KSPS 0x00000200  // 500,000 samples per second
+#define SYSCTL_ADCSPEED_250KSPS 0x00000100  // 250,000 samples per second
+#define SYSCTL_ADCSPEED_125KSPS 0x00000000  // 125,000 samples per second
+
+//*****************************************************************************
+//
+// The following are values that can be passed to the SysCtlClockSet() API as
+// the ulConfig parameter.
+//
+//*****************************************************************************
+#define SYSCTL_SYSDIV_1         0x07800000  // Processor clock is osc/pll /1
+#define SYSCTL_SYSDIV_2         0x00C00000  // Processor clock is osc/pll /2
+#define SYSCTL_SYSDIV_3         0x01400000  // Processor clock is osc/pll /3
+#define SYSCTL_SYSDIV_4         0x01C00000  // Processor clock is osc/pll /4
+#define SYSCTL_SYSDIV_5         0x02400000  // Processor clock is osc/pll /5
+#define SYSCTL_SYSDIV_6         0x02C00000  // Processor clock is osc/pll /6
+#define SYSCTL_SYSDIV_7         0x03400000  // Processor clock is osc/pll /7
+#define SYSCTL_SYSDIV_8         0x03C00000  // Processor clock is osc/pll /8
+#define SYSCTL_SYSDIV_9         0x04400000  // Processor clock is osc/pll /9
+#define SYSCTL_SYSDIV_10        0x04C00000  // Processor clock is osc/pll /10
+#define SYSCTL_SYSDIV_11        0x05400000  // Processor clock is osc/pll /11
+#define SYSCTL_SYSDIV_12        0x05C00000  // Processor clock is osc/pll /12
+#define SYSCTL_SYSDIV_13        0x06400000  // Processor clock is osc/pll /13
+#define SYSCTL_SYSDIV_14        0x06C00000  // Processor clock is osc/pll /14
+#define SYSCTL_SYSDIV_15        0x07400000  // Processor clock is osc/pll /15
+#define SYSCTL_SYSDIV_16        0x07C00000  // Processor clock is osc/pll /16
+#define SYSCTL_SYSDIV_17        0x88400000  // Processor clock is osc/pll /17
+#define SYSCTL_SYSDIV_18        0x88C00000  // Processor clock is osc/pll /18
+#define SYSCTL_SYSDIV_19        0x89400000  // Processor clock is osc/pll /19
+#define SYSCTL_SYSDIV_20        0x89C00000  // Processor clock is osc/pll /20
+#define SYSCTL_SYSDIV_21        0x8A400000  // Processor clock is osc/pll /21
+#define SYSCTL_SYSDIV_22        0x8AC00000  // Processor clock is osc/pll /22
+#define SYSCTL_SYSDIV_23        0x8B400000  // Processor clock is osc/pll /23
+#define SYSCTL_SYSDIV_24        0x8BC00000  // Processor clock is osc/pll /24
+#define SYSCTL_SYSDIV_25        0x8C400000  // Processor clock is osc/pll /25
+#define SYSCTL_SYSDIV_26        0x8CC00000  // Processor clock is osc/pll /26
+#define SYSCTL_SYSDIV_27        0x8D400000  // Processor clock is osc/pll /27
+#define SYSCTL_SYSDIV_28        0x8DC00000  // Processor clock is osc/pll /28
+#define SYSCTL_SYSDIV_29        0x8E400000  // Processor clock is osc/pll /29
+#define SYSCTL_SYSDIV_30        0x8EC00000  // Processor clock is osc/pll /30
+#define SYSCTL_SYSDIV_31        0x8F400000  // Processor clock is osc/pll /31
+#define SYSCTL_SYSDIV_32        0x8FC00000  // Processor clock is osc/pll /32
+#define SYSCTL_SYSDIV_33        0x90400000  // Processor clock is osc/pll /33
+#define SYSCTL_SYSDIV_34        0x90C00000  // Processor clock is osc/pll /34
+#define SYSCTL_SYSDIV_35        0x91400000  // Processor clock is osc/pll /35
+#define SYSCTL_SYSDIV_36        0x91C00000  // Processor clock is osc/pll /36
+#define SYSCTL_SYSDIV_37        0x92400000  // Processor clock is osc/pll /37
+#define SYSCTL_SYSDIV_38        0x92C00000  // Processor clock is osc/pll /38
+#define SYSCTL_SYSDIV_39        0x93400000  // Processor clock is osc/pll /39
+#define SYSCTL_SYSDIV_40        0x93C00000  // Processor clock is osc/pll /40
+#define SYSCTL_SYSDIV_41        0x94400000  // Processor clock is osc/pll /41
+#define SYSCTL_SYSDIV_42        0x94C00000  // Processor clock is osc/pll /42
+#define SYSCTL_SYSDIV_43        0x95400000  // Processor clock is osc/pll /43
+#define SYSCTL_SYSDIV_44        0x95C00000  // Processor clock is osc/pll /44
+#define SYSCTL_SYSDIV_45        0x96400000  // Processor clock is osc/pll /45
+#define SYSCTL_SYSDIV_46        0x96C00000  // Processor clock is osc/pll /46
+#define SYSCTL_SYSDIV_47        0x97400000  // Processor clock is osc/pll /47
+#define SYSCTL_SYSDIV_48        0x97C00000  // Processor clock is osc/pll /48
+#define SYSCTL_SYSDIV_49        0x98400000  // Processor clock is osc/pll /49
+#define SYSCTL_SYSDIV_50        0x98C00000  // Processor clock is osc/pll /50
+#define SYSCTL_SYSDIV_51        0x99400000  // Processor clock is osc/pll /51
+#define SYSCTL_SYSDIV_52        0x99C00000  // Processor clock is osc/pll /52
+#define SYSCTL_SYSDIV_53        0x9A400000  // Processor clock is osc/pll /53
+#define SYSCTL_SYSDIV_54        0x9AC00000  // Processor clock is osc/pll /54
+#define SYSCTL_SYSDIV_55        0x9B400000  // Processor clock is osc/pll /55
+#define SYSCTL_SYSDIV_56        0x9BC00000  // Processor clock is osc/pll /56
+#define SYSCTL_SYSDIV_57        0x9C400000  // Processor clock is osc/pll /57
+#define SYSCTL_SYSDIV_58        0x9CC00000  // Processor clock is osc/pll /58
+#define SYSCTL_SYSDIV_59        0x9D400000  // Processor clock is osc/pll /59
+#define SYSCTL_SYSDIV_60        0x9DC00000  // Processor clock is osc/pll /60
+#define SYSCTL_SYSDIV_61        0x9E400000  // Processor clock is osc/pll /61
+#define SYSCTL_SYSDIV_62        0x9EC00000  // Processor clock is osc/pll /62
+#define SYSCTL_SYSDIV_63        0x9F400000  // Processor clock is osc/pll /63
+#define SYSCTL_SYSDIV_64        0x9FC00000  // Processor clock is osc/pll /64
+#define SYSCTL_SYSDIV_2_5       0xC1000000  // Processor clock is pll / 2.5
+#define SYSCTL_SYSDIV_3_5       0xC1800000  // Processor clock is pll / 3.5
+#define SYSCTL_SYSDIV_4_5       0xC2000000  // Processor clock is pll / 4.5
+#define SYSCTL_SYSDIV_5_5       0xC2800000  // Processor clock is pll / 5.5
+#define SYSCTL_SYSDIV_6_5       0xC3000000  // Processor clock is pll / 6.5
+#define SYSCTL_SYSDIV_7_5       0xC3800000  // Processor clock is pll / 7.5
+#define SYSCTL_SYSDIV_8_5       0xC4000000  // Processor clock is pll / 8.5
+#define SYSCTL_SYSDIV_9_5       0xC4800000  // Processor clock is pll / 9.5
+#define SYSCTL_SYSDIV_10_5      0xC5000000  // Processor clock is pll / 10.5
+#define SYSCTL_SYSDIV_11_5      0xC5800000  // Processor clock is pll / 11.5
+#define SYSCTL_SYSDIV_12_5      0xC6000000  // Processor clock is pll / 12.5
+#define SYSCTL_SYSDIV_13_5      0xC6800000  // Processor clock is pll / 13.5
+#define SYSCTL_SYSDIV_14_5      0xC7000000  // Processor clock is pll / 14.5
+#define SYSCTL_SYSDIV_15_5      0xC7800000  // Processor clock is pll / 15.5
+#define SYSCTL_SYSDIV_16_5      0xC8000000  // Processor clock is pll / 16.5
+#define SYSCTL_SYSDIV_17_5      0xC8800000  // Processor clock is pll / 17.5
+#define SYSCTL_SYSDIV_18_5      0xC9000000  // Processor clock is pll / 18.5
+#define SYSCTL_SYSDIV_19_5      0xC9800000  // Processor clock is pll / 19.5
+#define SYSCTL_SYSDIV_20_5      0xCA000000  // Processor clock is pll / 20.5
+#define SYSCTL_SYSDIV_21_5      0xCA800000  // Processor clock is pll / 21.5
+#define SYSCTL_SYSDIV_22_5      0xCB000000  // Processor clock is pll / 22.5
+#define SYSCTL_SYSDIV_23_5      0xCB800000  // Processor clock is pll / 23.5
+#define SYSCTL_SYSDIV_24_5      0xCC000000  // Processor clock is pll / 24.5
+#define SYSCTL_SYSDIV_25_5      0xCC800000  // Processor clock is pll / 25.5
+#define SYSCTL_SYSDIV_26_5      0xCD000000  // Processor clock is pll / 26.5
+#define SYSCTL_SYSDIV_27_5      0xCD800000  // Processor clock is pll / 27.5
+#define SYSCTL_SYSDIV_28_5      0xCE000000  // Processor clock is pll / 28.5
+#define SYSCTL_SYSDIV_29_5      0xCE800000  // Processor clock is pll / 29.5
+#define SYSCTL_SYSDIV_30_5      0xCF000000  // Processor clock is pll / 30.5
+#define SYSCTL_SYSDIV_31_5      0xCF800000  // Processor clock is pll / 31.5
+#define SYSCTL_SYSDIV_32_5      0xD0000000  // Processor clock is pll / 32.5
+#define SYSCTL_SYSDIV_33_5      0xD0800000  // Processor clock is pll / 33.5
+#define SYSCTL_SYSDIV_34_5      0xD1000000  // Processor clock is pll / 34.5
+#define SYSCTL_SYSDIV_35_5      0xD1800000  // Processor clock is pll / 35.5
+#define SYSCTL_SYSDIV_36_5      0xD2000000  // Processor clock is pll / 36.5
+#define SYSCTL_SYSDIV_37_5      0xD2800000  // Processor clock is pll / 37.5
+#define SYSCTL_SYSDIV_38_5      0xD3000000  // Processor clock is pll / 38.5
+#define SYSCTL_SYSDIV_39_5      0xD3800000  // Processor clock is pll / 39.5
+#define SYSCTL_SYSDIV_40_5      0xD4000000  // Processor clock is pll / 40.5
+#define SYSCTL_SYSDIV_41_5      0xD4800000  // Processor clock is pll / 41.5
+#define SYSCTL_SYSDIV_42_5      0xD5000000  // Processor clock is pll / 42.5
+#define SYSCTL_SYSDIV_43_5      0xD5800000  // Processor clock is pll / 43.5
+#define SYSCTL_SYSDIV_44_5      0xD6000000  // Processor clock is pll / 44.5
+#define SYSCTL_SYSDIV_45_5      0xD6800000  // Processor clock is pll / 45.5
+#define SYSCTL_SYSDIV_46_5      0xD7000000  // Processor clock is pll / 46.5
+#define SYSCTL_SYSDIV_47_5      0xD7800000  // Processor clock is pll / 47.5
+#define SYSCTL_SYSDIV_48_5      0xD8000000  // Processor clock is pll / 48.5
+#define SYSCTL_SYSDIV_49_5      0xD8800000  // Processor clock is pll / 49.5
+#define SYSCTL_SYSDIV_50_5      0xD9000000  // Processor clock is pll / 50.5
+#define SYSCTL_SYSDIV_51_5      0xD9800000  // Processor clock is pll / 51.5
+#define SYSCTL_SYSDIV_52_5      0xDA000000  // Processor clock is pll / 52.5
+#define SYSCTL_SYSDIV_53_5      0xDA800000  // Processor clock is pll / 53.5
+#define SYSCTL_SYSDIV_54_5      0xDB000000  // Processor clock is pll / 54.5
+#define SYSCTL_SYSDIV_55_5      0xDB800000  // Processor clock is pll / 55.5
+#define SYSCTL_SYSDIV_56_5      0xDC000000  // Processor clock is pll / 56.5
+#define SYSCTL_SYSDIV_57_5      0xDC800000  // Processor clock is pll / 57.5
+#define SYSCTL_SYSDIV_58_5      0xDD000000  // Processor clock is pll / 58.5
+#define SYSCTL_SYSDIV_59_5      0xDD800000  // Processor clock is pll / 59.5
+#define SYSCTL_SYSDIV_60_5      0xDE000000  // Processor clock is pll / 60.5
+#define SYSCTL_SYSDIV_61_5      0xDE800000  // Processor clock is pll / 61.5
+#define SYSCTL_SYSDIV_62_5      0xDF000000  // Processor clock is pll / 62.5
+#define SYSCTL_SYSDIV_63_5      0xDF800000  // Processor clock is pll / 63.5
+#define SYSCTL_USE_PLL          0x00000000  // System clock is the PLL clock
+#define SYSCTL_USE_OSC          0x00003800  // System clock is the osc clock
+#define SYSCTL_XTAL_1MHZ        0x00000000  // External crystal is 1MHz
+#define SYSCTL_XTAL_1_84MHZ     0x00000040  // External crystal is 1.8432MHz
+#define SYSCTL_XTAL_2MHZ        0x00000080  // External crystal is 2MHz
+#define SYSCTL_XTAL_2_45MHZ     0x000000C0  // External crystal is 2.4576MHz
+#define SYSCTL_XTAL_3_57MHZ     0x00000100  // External crystal is 3.579545MHz
+#define SYSCTL_XTAL_3_68MHZ     0x00000140  // External crystal is 3.6864MHz
+#define SYSCTL_XTAL_4MHZ        0x00000180  // External crystal is 4MHz
+#define SYSCTL_XTAL_4_09MHZ     0x000001C0  // External crystal is 4.096MHz
+#define SYSCTL_XTAL_4_91MHZ     0x00000200  // External crystal is 4.9152MHz
+#define SYSCTL_XTAL_5MHZ        0x00000240  // External crystal is 5MHz
+#define SYSCTL_XTAL_5_12MHZ     0x00000280  // External crystal is 5.12MHz
+#define SYSCTL_XTAL_6MHZ        0x000002C0  // External crystal is 6MHz
+#define SYSCTL_XTAL_6_14MHZ     0x00000300  // External crystal is 6.144MHz
+#define SYSCTL_XTAL_7_37MHZ     0x00000340  // External crystal is 7.3728MHz
+#define SYSCTL_XTAL_8MHZ        0x00000380  // External crystal is 8MHz
+#define SYSCTL_XTAL_8_19MHZ     0x000003C0  // External crystal is 8.192MHz
+#define SYSCTL_XTAL_10MHZ       0x00000400  // External crystal is 10 MHz
+#define SYSCTL_XTAL_12MHZ       0x00000440  // External crystal is 12 MHz
+#define SYSCTL_XTAL_12_2MHZ     0x00000480  // External crystal is 12.288 MHz
+#define SYSCTL_XTAL_13_5MHZ     0x000004C0  // External crystal is 13.56 MHz
+#define SYSCTL_XTAL_14_3MHZ     0x00000500  // External crystal is 14.31818 MHz
+#define SYSCTL_XTAL_16MHZ       0x00000540  // External crystal is 16 MHz
+#define SYSCTL_XTAL_16_3MHZ     0x00000580  // External crystal is 16.384 MHz
+#define SYSCTL_OSC_MAIN         0x00000000  // Osc source is main osc
+#define SYSCTL_OSC_INT          0x00000010  // Osc source is int. osc
+#define SYSCTL_OSC_INT4         0x00000020  // Osc source is int. osc /4
+#define SYSCTL_OSC_INT30        0x00000030  // Osc source is int. 30 KHz
+#define SYSCTL_OSC_EXT4_19      0x80000028  // Osc source is ext. 4.19 MHz
+#define SYSCTL_OSC_EXT32        0x80000038  // Osc source is ext. 32 KHz
+#define SYSCTL_INT_PIOSC_DIS    0x00000004  // Disable interal precision osc.
+#define SYSCTL_INT_OSC_DIS      0x00000002  // Disable internal oscillator
+#define SYSCTL_MAIN_OSC_DIS     0x00000001  // Disable main oscillator
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern unsigned long SysCtlSRAMSizeGet(void);
+extern unsigned long SysCtlFlashSizeGet(void);
+extern tBoolean SysCtlPinPresent(unsigned long ulPin);
+extern tBoolean SysCtlPeripheralPresent(unsigned long ulPeripheral);
+extern void SysCtlPeripheralReset(unsigned long ulPeripheral);
+extern void SysCtlPeripheralEnable(unsigned long ulPeripheral);
+extern void SysCtlPeripheralDisable(unsigned long ulPeripheral);
+extern void SysCtlPeripheralSleepEnable(unsigned long ulPeripheral);
+extern void SysCtlPeripheralSleepDisable(unsigned long ulPeripheral);
+extern void SysCtlPeripheralDeepSleepEnable(unsigned long ulPeripheral);
+extern void SysCtlPeripheralDeepSleepDisable(unsigned long ulPeripheral);
+extern void SysCtlPeripheralClockGating(tBoolean bEnable);
+extern void SysCtlIntRegister(void (*pfnHandler)(void));
+extern void SysCtlIntUnregister(void);
+extern void SysCtlIntEnable(unsigned long ulInts);
+extern void SysCtlIntDisable(unsigned long ulInts);
+extern void SysCtlIntClear(unsigned long ulInts);
+extern unsigned long SysCtlIntStatus(tBoolean bMasked);
+extern void SysCtlLDOSet(unsigned long ulVoltage);
+extern unsigned long SysCtlLDOGet(void);
+extern void SysCtlLDOConfigSet(unsigned long ulConfig);
+extern void SysCtlReset(void);
+extern void SysCtlSleep(void);
+extern void SysCtlDeepSleep(void);
+extern unsigned long SysCtlResetCauseGet(void);
+extern void SysCtlResetCauseClear(unsigned long ulCauses);
+extern void SysCtlBrownOutConfigSet(unsigned long ulConfig,
+                                    unsigned long ulDelay);
+extern void SysCtlDelay(unsigned long ulCount);
+extern void SysCtlClockSet(unsigned long ulConfig);
+extern unsigned long SysCtlClockGet(void);
+extern void SysCtlPWMClockSet(unsigned long ulConfig);
+extern unsigned long SysCtlPWMClockGet(void);
+extern void SysCtlADCSpeedSet(unsigned long ulSpeed);
+extern unsigned long SysCtlADCSpeedGet(void);
+extern void SysCtlIOSCVerificationSet(tBoolean bEnable);
+extern void SysCtlMOSCVerificationSet(tBoolean bEnable);
+extern void SysCtlPLLVerificationSet(tBoolean bEnable);
+extern void SysCtlClkVerificationClear(void);
+extern void SysCtlGPIOAHBEnable(unsigned long ulGPIOPeripheral);
+extern void SysCtlGPIOAHBDisable(unsigned long ulGPIOPeripheral);
+extern void SysCtlUSBPLLEnable(void);
+extern void SysCtlUSBPLLDisable(void);
+extern unsigned long SysCtlI2SMClkSet(unsigned long ulInputClock,
+                                      unsigned long ulMClk);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __SYSCTL_H__


Property changes on: trunk/src/platform/lm3s/sysctl.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/systick.c
===================================================================
--- trunk/src/platform/lm3s/systick.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/systick.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,262 +1,262 @@
-//*****************************************************************************
-//
-// systick.c - Driver for the SysTick timer in NVIC.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup systick_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_nvic.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-#include &quot;systick.h&quot;
-
-//*****************************************************************************
-//
-//! Enables the SysTick counter.
-//!
-//! This will start the SysTick counter.  If an interrupt handler has been
-//! registered, it will be called when the SysTick counter rolls over.
-//!
-//! \note Calling this function will cause the SysTick counter to (re)commence
-//! counting from its current value.  The counter is not automatically reloaded
-//! with the period as specified in a previous call to SysTickPeriodSet().  If
-//! an immediate reload is required, the \b NVIC_ST_CURRENT register must be
-//! written to force this.  Any write to this register clears the SysTick
-//! counter to 0 and will cause a reload with the supplied period on the next
-//! clock.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysTickEnable(void)
-{
-    //
-    // Enable SysTick.
-    //
-    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_CLK_SRC | NVIC_ST_CTRL_ENABLE;
-}
-
-//*****************************************************************************
-//
-//! Disables the SysTick counter.
-//!
-//! This will stop the SysTick counter.  If an interrupt handler has been
-//! registered, it will no longer be called until SysTick is restarted.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysTickDisable(void)
-{
-    //
-    // Disable SysTick.
-    //
-    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_ENABLE);
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for the SysTick interrupt.
-//!
-//! \param pfnHandler is a pointer to the function to be called when the
-//! SysTick interrupt occurs.
-//!
-//! This sets the handler to be called when a SysTick interrupt occurs.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysTickIntRegister(void (*pfnHandler)(void))
-{
-    //
-    // Register the interrupt handler, returning an error if an error occurs.
-    //
-    IntRegister(FAULT_SYSTICK, pfnHandler);
-
-    //
-    // Enable the SysTick interrupt.
-    //
-    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
-}
-
-//*****************************************************************************
-//
-//! Unregisters the interrupt handler for the SysTick interrupt.
-//!
-//! This function will clear the handler to be called when a SysTick interrupt
-//! occurs.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysTickIntUnregister(void)
-{
-    //
-    // Disable the SysTick interrupt.
-    //
-    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
-
-    //
-    // Unregister the interrupt handler.
-    //
-    IntUnregister(FAULT_SYSTICK);
-}
-
-//*****************************************************************************
-//
-//! Enables the SysTick interrupt.
-//!
-//! This function will enable the SysTick interrupt, allowing it to be
-//! reflected to the processor.
-//!
-//! \note The SysTick interrupt handler does not need to clear the SysTick
-//! interrupt source as this is done automatically by NVIC when the interrupt
-//! handler is called.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysTickIntEnable(void)
-{
-    //
-    // Enable the SysTick interrupt.
-    //
-    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
-}
-
-//*****************************************************************************
-//
-//! Disables the SysTick interrupt.
-//!
-//! This function will disable the SysTick interrupt, preventing it from being
-//! reflected to the processor.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysTickIntDisable(void)
-{
-    //
-    // Disable the SysTick interrupt.
-    //
-    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
-}
-
-//*****************************************************************************
-//
-//! Sets the period of the SysTick counter.
-//!
-//! \param ulPeriod is the number of clock ticks in each period of the SysTick
-//! counter; must be between 1 and 16,777,216, inclusive.
-//!
-//! This function sets the rate at which the SysTick counter wraps; this
-//! equates to the number of processor clocks between interrupts.
-//!
-//! \note Calling this function does not cause the SysTick counter to reload
-//! immediately.  If an immediate reload is required, the \b NVIC_ST_CURRENT
-//! register must be written.  Any write to this register clears the SysTick
-//! counter to 0 and will cause a reload with the \e ulPeriod supplied here on
-//! the next clock after the SysTick is enabled.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-SysTickPeriodSet(unsigned long ulPeriod)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT((ulPeriod &gt; 0) &amp;&amp; (ulPeriod &lt;= 16777216));
-
-    //
-    // Set the period of the SysTick counter.
-    //
-    HWREG(NVIC_ST_RELOAD) = ulPeriod - 1;
-}
-
-//*****************************************************************************
-//
-//! Gets the period of the SysTick counter.
-//!
-//! This function returns the rate at which the SysTick counter wraps; this
-//! equates to the number of processor clocks between interrupts.
-//!
-//! \return Returns the period of the SysTick counter.
-//
-//*****************************************************************************
-unsigned long
-SysTickPeriodGet(void)
-{
-    //
-    // Return the period of the SysTick counter.
-    //
-    return(HWREG(NVIC_ST_RELOAD) + 1);
-}
-
-//*****************************************************************************
-//
-//! Gets the current value of the SysTick counter.
-//!
-//! This function returns the current value of the SysTick counter; this will
-//! be a value between the period - 1 and zero, inclusive.
-//!
-//! \return Returns the current value of the SysTick counter.
-//
-//*****************************************************************************
-unsigned long
-SysTickValueGet(void)
-{
-    //
-    // Return the current value of the SysTick counter.
-    //
-    return(HWREG(NVIC_ST_CURRENT));
-}
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// systick.c - Driver for the SysTick timer in NVIC.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup systick_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_nvic.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;systick.h&quot;
+
+//*****************************************************************************
+//
+//! Enables the SysTick counter.
+//!
+//! This will start the SysTick counter.  If an interrupt handler has been
+//! registered, it will be called when the SysTick counter rolls over.
+//!
+//! \note Calling this function will cause the SysTick counter to (re)commence
+//! counting from its current value.  The counter is not automatically reloaded
+//! with the period as specified in a previous call to SysTickPeriodSet().  If
+//! an immediate reload is required, the \b NVIC_ST_CURRENT register must be
+//! written to force this.  Any write to this register clears the SysTick
+//! counter to 0 and will cause a reload with the supplied period on the next
+//! clock.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickEnable(void)
+{
+    //
+    // Enable SysTick.
+    //
+    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_CLK_SRC | NVIC_ST_CTRL_ENABLE;
+}
+
+//*****************************************************************************
+//
+//! Disables the SysTick counter.
+//!
+//! This will stop the SysTick counter.  If an interrupt handler has been
+//! registered, it will no longer be called until SysTick is restarted.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickDisable(void)
+{
+    //
+    // Disable SysTick.
+    //
+    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_ENABLE);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the SysTick interrupt.
+//!
+//! \param pfnHandler is a pointer to the function to be called when the
+//! SysTick interrupt occurs.
+//!
+//! This sets the handler to be called when a SysTick interrupt occurs.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntRegister(void (*pfnHandler)(void))
+{
+    //
+    // Register the interrupt handler, returning an error if an error occurs.
+    //
+    IntRegister(FAULT_SYSTICK, pfnHandler);
+
+    //
+    // Enable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
+}
+
+//*****************************************************************************
+//
+//! Unregisters the interrupt handler for the SysTick interrupt.
+//!
+//! This function will clear the handler to be called when a SysTick interrupt
+//! occurs.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntUnregister(void)
+{
+    //
+    // Disable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(FAULT_SYSTICK);
+}
+
+//*****************************************************************************
+//
+//! Enables the SysTick interrupt.
+//!
+//! This function will enable the SysTick interrupt, allowing it to be
+//! reflected to the processor.
+//!
+//! \note The SysTick interrupt handler does not need to clear the SysTick
+//! interrupt source as this is done automatically by NVIC when the interrupt
+//! handler is called.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntEnable(void)
+{
+    //
+    // Enable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
+}
+
+//*****************************************************************************
+//
+//! Disables the SysTick interrupt.
+//!
+//! This function will disable the SysTick interrupt, preventing it from being
+//! reflected to the processor.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntDisable(void)
+{
+    //
+    // Disable the SysTick interrupt.
+    //
+    HWREG(NVIC_ST_CTRL) &amp;= ~(NVIC_ST_CTRL_INTEN);
+}
+
+//*****************************************************************************
+//
+//! Sets the period of the SysTick counter.
+//!
+//! \param ulPeriod is the number of clock ticks in each period of the SysTick
+//! counter; must be between 1 and 16,777,216, inclusive.
+//!
+//! This function sets the rate at which the SysTick counter wraps; this
+//! equates to the number of processor clocks between interrupts.
+//!
+//! \note Calling this function does not cause the SysTick counter to reload
+//! immediately.  If an immediate reload is required, the \b NVIC_ST_CURRENT
+//! register must be written.  Any write to this register clears the SysTick
+//! counter to 0 and will cause a reload with the \e ulPeriod supplied here on
+//! the next clock after the SysTick is enabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickPeriodSet(unsigned long ulPeriod)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulPeriod &gt; 0) &amp;&amp; (ulPeriod &lt;= 16777216));
+
+    //
+    // Set the period of the SysTick counter.
+    //
+    HWREG(NVIC_ST_RELOAD) = ulPeriod - 1;
+}
+
+//*****************************************************************************
+//
+//! Gets the period of the SysTick counter.
+//!
+//! This function returns the rate at which the SysTick counter wraps; this
+//! equates to the number of processor clocks between interrupts.
+//!
+//! \return Returns the period of the SysTick counter.
+//
+//*****************************************************************************
+unsigned long
+SysTickPeriodGet(void)
+{
+    //
+    // Return the period of the SysTick counter.
+    //
+    return(HWREG(NVIC_ST_RELOAD) + 1);
+}
+
+//*****************************************************************************
+//
+//! Gets the current value of the SysTick counter.
+//!
+//! This function returns the current value of the SysTick counter; this will
+//! be a value between the period - 1 and zero, inclusive.
+//!
+//! \return Returns the current value of the SysTick counter.
+//
+//*****************************************************************************
+unsigned long
+SysTickValueGet(void)
+{
+    //
+    // Return the current value of the SysTick counter.
+    //
+    return(HWREG(NVIC_ST_CURRENT));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/systick.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/systick.h
===================================================================
--- trunk/src/platform/lm3s/systick.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/systick.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,66 +1,66 @@
-//*****************************************************************************
-//
-// systick.h - Prototypes for the SysTick driver.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __SYSTICK_H__
-#define __SYSTICK_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern void SysTickEnable(void);
-extern void SysTickDisable(void);
-extern void SysTickIntRegister(void (*pfnHandler)(void));
-extern void SysTickIntUnregister(void);
-extern void SysTickIntEnable(void);
-extern void SysTickIntDisable(void);
-extern void SysTickPeriodSet(unsigned long ulPeriod);
-extern unsigned long SysTickPeriodGet(void);
-extern unsigned long SysTickValueGet(void);
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __SYSTICK_H__
+//*****************************************************************************
+//
+// systick.h - Prototypes for the SysTick driver.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __SYSTICK_H__
+#define __SYSTICK_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern void SysTickEnable(void);
+extern void SysTickDisable(void);
+extern void SysTickIntRegister(void (*pfnHandler)(void));
+extern void SysTickIntUnregister(void);
+extern void SysTickIntEnable(void);
+extern void SysTickIntDisable(void);
+extern void SysTickPeriodSet(unsigned long ulPeriod);
+extern unsigned long SysTickPeriodGet(void);
+extern unsigned long SysTickValueGet(void);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __SYSTICK_H__


Property changes on: trunk/src/platform/lm3s/systick.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/timer.c
===================================================================
--- trunk/src/platform/lm3s/timer.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/timer.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,1007 +1,1007 @@
-//*****************************************************************************
-//
-// timer.c - Driver for the timer module.
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-//*****************************************************************************
-//
-//! \addtogroup timer_api
-//! @{
-//
-//*****************************************************************************
-
-#include &quot;hw_ints.h&quot;
-#include &quot;hw_memmap.h&quot;
-#include &quot;hw_timer.h&quot;
-#include &quot;hw_types.h&quot;
-#include &quot;debug.h&quot;
-#include &quot;interrupt.h&quot;
-#include &quot;timer.h&quot;
-
-//*****************************************************************************
-//
-//! \internal
-//! Checks a timer base address.
-//!
-//! \param ulBase is the base address of the timer module.
-//!
-//! This function determines if a timer module base address is valid.
-//!
-//! \return Returns \b true if the base address is valid and \b false
-//! otherwise.
-//
-//*****************************************************************************
-#ifdef DEBUG
-static tBoolean
-TimerBaseValid(unsigned long ulBase)
-{
-    return((ulBase == TIMER0_BASE) || (ulBase == TIMER1_BASE) ||
-           (ulBase == TIMER2_BASE) || (ulBase == TIMER3_BASE));
-}
-#endif
-
-//*****************************************************************************
-//
-//! Enables the timer(s).
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to enable; must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.
-//!
-//! This will enable operation of the timer module.  The timer must be
-//! configured before it is enabled.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerEnable(unsigned long ulBase, unsigned long ulTimer)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Enable the timer(s) module.
-    //
-    HWREG(ulBase + TIMER_O_CTL) |= ulTimer &amp; (TIMER_CTL_TAEN | TIMER_CTL_TBEN);
-}
-
-//*****************************************************************************
-//
-//! Disables the timer(s).
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to disable; must be one of
-//! \b TIMER_A, \b TIMER_B, or \b TIMER_BOTH.
-//!
-//! This will disable operation of the timer module.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerDisable(unsigned long ulBase, unsigned long ulTimer)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Disable the timer module.
-    //
-    HWREG(ulBase + TIMER_O_CTL) &amp;= ~(ulTimer &amp;
-                                     (TIMER_CTL_TAEN | TIMER_CTL_TBEN));
-}
-
-//*****************************************************************************
-//
-//! Configures the timer(s).
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulConfig is the configuration for the timer.
-//!
-//! This function configures the operating mode of the timer(s).  The timer
-//! module is disabled before being configured, and is left in the disabled
-//! state.  The configuration is specified in \e ulConfig as one of the
-//! following values:
-//!
-//! - \b TIMER_CFG_32_BIT_OS - 32-bit one shot timer
-//! - \b TIMER_CFG_32_BIT_PER - 32-bit periodic timer
-//! - \b TIMER_CFG_32_RTC - 32-bit real time clock timer
-//! - \b TIMER_CFG_16_BIT_PAIR - Two 16-bit timers
-//!
-//! When configured for a pair of 16-bit timers, each timer is separately
-//! configured.  The first timer is configured by setting \e ulConfig to
-//! the result of a logical OR operation between one of the following values
-//! and \e ulConfig:
-//!
-//! - \b TIMER_CFG_A_ONE_SHOT - 16-bit one shot timer
-//! - \b TIMER_CFG_A_PERIODIC - 16-bit periodic timer
-//! - \b TIMER_CFG_A_CAP_COUNT - 16-bit edge count capture
-//! - \b TIMER_CFG_A_CAP_TIME - 16-bit edge time capture
-//! - \b TIMER_CFG_A_PWM - 16-bit PWM output
-//!
-//! Similarly, the second timer is configured by setting \e ulConfig to
-//! the result of a logical OR operation between one of the corresponding
-//! \b TIMER_CFG_B_* values and \e ulConfig.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerConfigure(unsigned long ulBase, unsigned long ulConfig)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulConfig == TIMER_CFG_32_BIT_OS) ||
-           (ulConfig == TIMER_CFG_32_BIT_PER) ||
-           (ulConfig == TIMER_CFG_32_RTC) ||
-           ((ulConfig &amp; 0xff000000) == TIMER_CFG_16_BIT_PAIR));
-    ASSERT(((ulConfig &amp; 0xff000000) != TIMER_CFG_16_BIT_PAIR) ||
-           ((((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_ONE_SHOT) ||
-             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_PERIODIC) ||
-             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_CAP_COUNT) ||
-             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_CAP_TIME) ||
-             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_PWM)) &amp;&amp;
-            (((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_ONE_SHOT) ||
-             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_PERIODIC) ||
-             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_CAP_COUNT) ||
-             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_CAP_TIME) ||
-             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_PWM))));
-
-    //
-    // Disable the timers.
-    //
-    HWREG(ulBase + TIMER_O_CTL) &amp;= ~(TIMER_CTL_TAEN | TIMER_CTL_TBEN);
-
-    //
-    // Set the global timer configuration.
-    //
-    HWREG(ulBase + TIMER_O_CFG) = ulConfig &gt;&gt; 24;
-
-    //
-    // Set the configuration of the A and B timers.  Note that the B timer
-    // configuration is ignored by the hardware in 32-bit modes.
-    //
-    HWREG(ulBase + TIMER_O_TAMR) = ulConfig &amp; 255;
-    HWREG(ulBase + TIMER_O_TBMR) = (ulConfig &gt;&gt; 8) &amp; 255;
-}
-
-//*****************************************************************************
-//
-//! Controls the output level.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.
-//! \param bInvert specifies the output level.
-//!
-//! This function sets the PWM output level for the specified timer.  If the
-//! \e bInvert parameter is \b true, then the timer's output will be made
-//! active low; otherwise, it will be made active high.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerControlLevel(unsigned long ulBase, unsigned long ulTimer,
-                  tBoolean bInvert)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Set the output levels as requested.
-    //
-    ulTimer &amp;= TIMER_CTL_TAPWML | TIMER_CTL_TBPWML;
-    HWREG(ulBase + TIMER_O_CTL) = (bInvert ?
-                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :
-                                   (HWREG(ulBase + TIMER_O_CTL) &amp; ~(ulTimer)));
-}
-
-//*****************************************************************************
-//
-//! Enables or disables the trigger output.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer to adjust; must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.
-//! \param bEnable specifies the desired trigger state.
-//!
-//! This function controls the trigger output for the specified timer.  If the
-//! \e bEnable parameter is \b true, then the timer's output trigger is
-//! enabled; otherwise it is disabled.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerControlTrigger(unsigned long ulBase, unsigned long ulTimer,
-                    tBoolean bEnable)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Set the trigger output as requested.
-    //
-    ulTimer &amp;= TIMER_CTL_TAOTE | TIMER_CTL_TBOTE;
-    HWREG(ulBase + TIMER_O_CTL) = (bEnable ?
-                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :
-                                   (HWREG(ulBase + TIMER_O_CTL) &amp; ~(ulTimer)));
-}
-
-//*****************************************************************************
-//
-//! Controls the event type.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to be adjusted; must be one of
-//! \b TIMER_A, \b TIMER_B, or \b TIMER_BOTH.
-//! \param ulEvent specifies the type of event; must be one of
-//! \b TIMER_EVENT_POS_EDGE, \b TIMER_EVENT_NEG_EDGE, or
-//! \b TIMER_EVENT_BOTH_EDGES.
-//!
-//! This function sets the signal edge(s) that will trigger the timer when in
-//! capture mode.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerControlEvent(unsigned long ulBase, unsigned long ulTimer,
-                  unsigned long ulEvent)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Set the event type.
-    //
-    ulEvent &amp;= ulTimer &amp; (TIMER_CTL_TAEVENT_M | TIMER_CTL_TBEVENT_M);
-    HWREG(ulBase + TIMER_O_CTL) = ((HWREG(ulBase + TIMER_O_CTL) &amp;
-                                    ~(TIMER_CTL_TAEVENT_M |
-                                      TIMER_CTL_TBEVENT_M)) | ulEvent);
-}
-
-//*****************************************************************************
-//
-//! Controls the stall handling.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to be adjusted; must be one of
-//! \b TIMER_A, \b TIMER_B, or \b TIMER_BOTH.
-//! \param bStall specifies the response to a stall signal.
-//!
-//! This function controls the stall response for the specified timer.  If the
-//! \e bStall parameter is \b true, then the timer will stop counting if the
-//! processor enters debug mode; otherwise the timer will keep running while in
-//! debug mode.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerControlStall(unsigned long ulBase, unsigned long ulTimer,
-                  tBoolean  bStall)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Set the stall mode.
-    //
-    ulTimer &amp;= TIMER_CTL_TASTALL | TIMER_CTL_TBSTALL;
-    HWREG(ulBase + TIMER_O_CTL) = (bStall ?
-                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :
-                                   (HWREG(ulBase + TIMER_O_CTL) &amp; ~(ulTimer)));
-}
-
-//*****************************************************************************
-//
-//! Enable RTC counting.
-//!
-//! \param ulBase is the base address of the timer module.
-//!
-//! This function causes the timer to start counting when in RTC mode.  If not
-//! configured for RTC mode, this will do nothing.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerRTCEnable(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-
-    //
-    // Enable RTC counting.
-    //
-    HWREG(ulBase + TIMER_O_CTL) |= TIMER_CTL_RTCEN;
-}
-
-//*****************************************************************************
-//
-//! Disable RTC counting.
-//!
-//! \param ulBase is the base address of the timer module.
-//!
-//! This function causes the timer to stop counting when in RTC mode.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerRTCDisable(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-
-    //
-    // Disable RTC counting.
-    //
-    HWREG(ulBase + TIMER_O_CTL) &amp;= ~(TIMER_CTL_RTCEN);
-}
-
-//*****************************************************************************
-//
-//! Set the timer prescale value.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.
-//! \param ulValue is the timer prescale value; must be between 0 and 255,
-//! inclusive.
-//!
-//! This function sets the value of the input clock prescaler.  The prescaler
-//! is only operational when in 16-bit mode and is used to extend the range of
-//! the 16-bit timer modes.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerPrescaleSet(unsigned long ulBase, unsigned long ulTimer,
-                 unsigned long ulValue)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-    ASSERT(ulValue &lt; 256);
-
-    //
-    // Set the timer A prescaler if requested.
-    //
-    if(ulTimer &amp; TIMER_A)
-    {
-        HWREG(ulBase + TIMER_O_TAPR) = ulValue;
-    }
-
-    //
-    // Set the timer B prescaler if requested.
-    //
-    if(ulTimer &amp; TIMER_B)
-    {
-        HWREG(ulBase + TIMER_O_TBPR) = ulValue;
-    }
-}
-
-//*****************************************************************************
-//
-//! Get the timer prescale value.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
-//! \b TIMER_B.
-//!
-//! This function gets the value of the input clock prescaler.  The prescaler
-//! is only operational when in 16-bit mode and is used to extend the range of
-//! the 16-bit timer modes.
-//!
-//! \return The value of the timer prescaler.
-//
-//*****************************************************************************
-unsigned long
-TimerPrescaleGet(unsigned long ulBase, unsigned long ulTimer)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Return the appropriate prescale value.
-    //
-    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAPR) :
-           HWREG(ulBase + TIMER_O_TBPR));
-}
-
-//*****************************************************************************
-//
-//! Sets the timer load value.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.  Only \b TIMER_A should be used when the
-//! timer is configured for 32-bit operation.
-//! \param ulValue is the load value.
-//!
-//! This function sets the timer load value; if the timer is running then the
-//! value will be immediately loaded into the timer.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerLoadSet(unsigned long ulBase, unsigned long ulTimer,
-             unsigned long ulValue)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Set the timer A load value if requested.
-    //
-    if(ulTimer &amp; TIMER_A)
-    {
-        HWREG(ulBase + TIMER_O_TAILR) = ulValue;
-    }
-
-    //
-    // Set the timer B load value if requested.
-    //
-    if(ulTimer &amp; TIMER_B)
-    {
-        HWREG(ulBase + TIMER_O_TBILR) = ulValue;
-    }
-}
-
-//*****************************************************************************
-//
-//! Gets the timer load value.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
-//! \b TIMER_B.  Only \b TIMER_A should be used when the timer is configured
-//! for 32-bit operation.
-//!
-//! This function gets the currently programmed interval load value for the
-//! specified timer.
-//!
-//! \return Returns the load value for the timer.
-//
-//*****************************************************************************
-unsigned long
-TimerLoadGet(unsigned long ulBase, unsigned long ulTimer)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));
-
-    //
-    // Return the appropriate load value.
-    //
-    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAILR) :
-           HWREG(ulBase + TIMER_O_TBILR));
-}
-
-//*****************************************************************************
-//
-//! Gets the current timer value.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
-//! \b TIMER_B.  Only \b TIMER_A should be used when the timer is configured
-//! for 32-bit operation.
-//!
-//! This function reads the current value of the specified timer.
-//!
-//! \return Returns the current value of the timer.
-//
-//*****************************************************************************
-unsigned long
-TimerValueGet(unsigned long ulBase, unsigned long ulTimer)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));
-
-    //
-    // Return the appropriate timer value.
-    //
-    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAR) :
-           HWREG(ulBase + TIMER_O_TBR));
-}
-
-//*****************************************************************************
-//
-//! Sets the timer match value.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.  Only \b TIMER_A should be used when the
-//! timer is configured for 32-bit operation.
-//! \param ulValue is the match value.
-//!
-//! This function sets the match value for a timer.  This is used in capture
-//! count mode to determine when to interrupt the processor and in PWM mode to
-//! determine the duty cycle of the output signal.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerMatchSet(unsigned long ulBase, unsigned long ulTimer,
-              unsigned long ulValue)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Set the timer A match value if requested.
-    //
-    if(ulTimer &amp; TIMER_A)
-    {
-        HWREG(ulBase + TIMER_O_TAMATCHR) = ulValue;
-    }
-
-    //
-    // Set the timer B match value if requested.
-    //
-    if(ulTimer &amp; TIMER_B)
-    {
-        HWREG(ulBase + TIMER_O_TBMATCHR) = ulValue;
-    }
-}
-
-//*****************************************************************************
-//
-//! Gets the timer match value.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
-//! \b TIMER_B.  Only \b TIMER_A should be used when the timer is configured
-//! for 32-bit operation.
-//!
-//! This function gets the match value for the specified timer.
-//!
-//! \return Returns the match value for the timer.
-//
-//*****************************************************************************
-unsigned long
-TimerMatchGet(unsigned long ulBase, unsigned long ulTimer)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));
-
-    //
-    // Return the appropriate match value.
-    //
-    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAMATCHR) :
-           HWREG(ulBase + TIMER_O_TBMATCHR));
-}
-
-//*****************************************************************************
-//
-//! Registers an interrupt handler for the timer interrupt.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s); must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.
-//! \param pfnHandler is a pointer to the function to be called when the timer
-//! interrupt occurs.
-//!
-//! This sets the handler to be called when a timer interrupt occurs.  This
-//! will enable the global interrupt in the interrupt controller; specific
-//! timer interrupts must be enabled via TimerIntEnable().  It is the interrupt
-//! handler's responsibility to clear the interrupt source via TimerIntClear().
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerIntRegister(unsigned long ulBase, unsigned long ulTimer,
-                 void (*pfnHandler)(void))
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Get the interrupt number for this timer module.
-    //
-    ulBase = ((ulBase == TIMER0_BASE) ? INT_TIMER0A :
-              ((ulBase == TIMER1_BASE) ? INT_TIMER1A :
-               ((ulBase == TIMER2_BASE) ? INT_TIMER2A : INT_TIMER3A)));
-
-    //
-    // Register an interrupt handler for timer A if requested.
-    //
-    if(ulTimer &amp; TIMER_A)
-    {
-        //
-        // Register the interrupt handler.
-        //
-        IntRegister(ulBase, pfnHandler);
-
-        //
-        // Enable the interrupt.
-        //
-        IntEnable(ulBase);
-    }
-
-    //
-    // Register an interrupt handler for timer B if requested.
-    //
-    if(ulTimer &amp; TIMER_B)
-    {
-        //
-        // Register the interrupt handler.
-        //
-        IntRegister(ulBase + 1, pfnHandler);
-
-        //
-        // Enable the interrupt.
-        //
-        IntEnable(ulBase + 1);
-    }
-}
-
-//*****************************************************************************
-//
-//! Unregisters an interrupt handler for the timer interrupt.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulTimer specifies the timer(s); must be one of \b TIMER_A,
-//! \b TIMER_B, or \b TIMER_BOTH.
-//!
-//! This function will clear the handler to be called when a timer interrupt
-//! occurs.  This will also mask off the interrupt in the interrupt controller
-//! so that the interrupt handler no longer is called.
-//!
-//! \sa IntRegister() for important information about registering interrupt
-//! handlers.
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerIntUnregister(unsigned long ulBase, unsigned long ulTimer)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
-           (ulTimer == TIMER_BOTH));
-
-    //
-    // Get the interrupt number for this timer module.
-    //
-    ulBase = ((ulBase == TIMER0_BASE) ? INT_TIMER0A :
-              ((ulBase == TIMER1_BASE) ? INT_TIMER1A :
-               ((ulBase == TIMER2_BASE) ? INT_TIMER2A : INT_TIMER3A)));
-
-    //
-    // Unregister the interrupt handler for timer A if requested.
-    //
-    if(ulTimer &amp; TIMER_A)
-    {
-        //
-        // Disable the interrupt.
-        //
-        IntDisable(ulBase);
-
-        //
-        // Unregister the interrupt handler.
-        //
-        IntUnregister(ulBase);
-    }
-
-    //
-    // Unregister the interrupt handler for timer B if requested.
-    //
-    if(ulTimer &amp; TIMER_B)
-    {
-        //
-        // Disable the interrupt.
-        //
-        IntDisable(ulBase + 1);
-
-        //
-        // Unregister the interrupt handler.
-        //
-        IntUnregister(ulBase + 1);
-    }
-}
-
-//*****************************************************************************
-//
-//! Enables individual timer interrupt sources.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
-//!
-//! Enables the indicated timer interrupt sources.  Only the sources that are
-//! enabled can be reflected to the processor interrupt; disabled sources have
-//! no effect on the processor.
-//!
-//! The \e ulIntFlags parameter must be the logical OR of any combination of
-//! the following:
-//!
-//! - \b TIMER_CAPB_EVENT  - Capture B event interrupt
-//! - \b TIMER_CAPB_MATCH  - Capture B match interrupt
-//! - \b TIMER_TIMB_TIMEOUT  - Timer B timeout interrupt
-//! - \b TIMER_RTC_MATCH  - RTC interrupt mask
-//! - \b TIMER_CAPA_EVENT  - Capture A event interrupt
-//! - \b TIMER_CAPA_MATCH  - Capture A match interrupt
-//! - \b TIMER_TIMA_TIMEOUT  - Timer A timeout interrupt
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-
-    //
-    // Enable the specified interrupts.
-    //
-    HWREG(ulBase + TIMER_O_IMR) |= ulIntFlags;
-}
-
-//*****************************************************************************
-//
-//! Disables individual timer interrupt sources.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
-//!
-//! Disables the indicated timer interrupt sources.  Only the sources that are
-//! enabled can be reflected to the processor interrupt; disabled sources have
-//! no effect on the processor.
-//!
-//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
-//! parameter to TimerIntEnable().
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-
-    //
-    // Disable the specified interrupts.
-    //
-    HWREG(ulBase + TIMER_O_IMR) &amp;= ~(ulIntFlags);
-}
-
-//*****************************************************************************
-//
-//! Gets the current interrupt status.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param bMasked is false if the raw interrupt status is required and true if
-//! the masked interrupt status is required.
-//!
-//! This returns the interrupt status for the timer module.  Either the raw
-//! interrupt status or the status of interrupts that are allowed to reflect to
-//! the processor can be returned.
-//!
-//! \return The current interrupt status, enumerated as a bit field of
-//! values described in TimerIntEnable().
-//
-//*****************************************************************************
-unsigned long
-TimerIntStatus(unsigned long ulBase, tBoolean bMasked)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-
-    //
-    // Return either the interrupt status or the raw interrupt status as
-    // requested.
-    //
-    return(bMasked ? HWREG(ulBase + TIMER_O_MIS) :
-           HWREG(ulBase + TIMER_O_RIS));
-}
-
-//*****************************************************************************
-//
-//! Clears timer interrupt sources.
-//!
-//! \param ulBase is the base address of the timer module.
-//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
-//!
-//! The specified timer interrupt sources are cleared, so that they no longer
-//! assert.  This must be done in the interrupt handler to keep it from being
-//! called again immediately upon exit.
-//!
-//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
-//! parameter to TimerIntEnable().
-//!
-//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
-//! several clock cycles before the interrupt source is actually cleared.
-//! Therefore, it is recommended that the interrupt source be cleared early in
-//! the interrupt handler (as opposed to the very last action) to avoid
-//! returning from the interrupt handler before the interrupt source is
-//! actually cleared.  Failure to do so may result in the interrupt handler
-//! being immediately reentered (since NVIC still sees the interrupt source
-//! asserted).
-//!
-//! \return None.
-//
-//*****************************************************************************
-void
-TimerIntClear(unsigned long ulBase, unsigned long ulIntFlags)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-
-    //
-    // Clear the requested interrupt sources.
-    //
-    HWREG(ulBase + TIMER_O_ICR) = ulIntFlags;
-}
-
-//*****************************************************************************
-//
-// Puts the timer into its reset state.
-//
-// \param ulBase is the base address of the timer module.
-//
-// The specified timer is disabled, and all its interrupts are disabled,
-// cleared, and unregistered.  Then the timer registers are set to their reset
-// value.
-//
-// \return None.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-void
-TimerQuiesce(unsigned long ulBase)
-{
-    //
-    // Check the arguments.
-    //
-    ASSERT(TimerBaseValid(ulBase));
-
-    //
-    // Disable the timer.
-    //
-    HWREG(ulBase + TIMER_O_CTL) = TIMER_RV_CTL;
-
-    //
-    // Disable all the timer interrupts.
-    //
-    HWREG(ulBase + TIMER_O_IMR) = TIMER_RV_IMR;
-
-    //
-    // Clear all the timer interrupts.
-    //
-    HWREG(ulBase + TIMER_O_ICR) = 0xFFFFFFFF;
-
-    //
-    // Unregister the interrupt handler.  This also disables interrupts to the
-    // core.
-    //
-    TimerIntUnregister(ulBase, TIMER_BOTH);
-
-    //
-    // Set all the registers to their reset value.
-    //
-    HWREG(ulBase + TIMER_O_CFG) = TIMER_RV_CFG;
-    HWREG(ulBase + TIMER_O_TAMR) = TIMER_RV_TAMR;
-    HWREG(ulBase + TIMER_O_TBMR) = TIMER_RV_TBMR;
-    HWREG(ulBase + TIMER_O_RIS) = TIMER_RV_RIS;
-    HWREG(ulBase + TIMER_O_MIS) = TIMER_RV_MIS;
-    HWREG(ulBase + TIMER_O_TAILR) = TIMER_RV_TAILR;
-    HWREG(ulBase + TIMER_O_TBILR) = TIMER_RV_TBILR;
-    HWREG(ulBase + TIMER_O_TAMATCHR) = TIMER_RV_TAMATCHR;
-    HWREG(ulBase + TIMER_O_TBMATCHR) = TIMER_RV_TBMATCHR;
-    HWREG(ulBase + TIMER_O_TAPR) = TIMER_RV_TAPR;
-    HWREG(ulBase + TIMER_O_TBPR) = TIMER_RV_TBPR;
-    HWREG(ulBase + TIMER_O_TAPMR) = TIMER_RV_TAPMR;
-    HWREG(ulBase + TIMER_O_TBPMR) = TIMER_RV_TBPMR;
-    HWREG(ulBase + TIMER_O_TAR) = TIMER_RV_TAR;
-    HWREG(ulBase + TIMER_O_TBR) = TIMER_RV_TBR;
-}
-#endif // DEPRECATED
-
-//*****************************************************************************
-//
-// Close the Doxygen group.
-//! @}
-//
-//*****************************************************************************
+//*****************************************************************************
+//
+// timer.c - Driver for the timer module.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup timer_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_timer.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;timer.h&quot;
+
+//*****************************************************************************
+//
+//! \internal
+//! Checks a timer base address.
+//!
+//! \param ulBase is the base address of the timer module.
+//!
+//! This function determines if a timer module base address is valid.
+//!
+//! \return Returns \b true if the base address is valid and \b false
+//! otherwise.
+//
+//*****************************************************************************
+#ifdef DEBUG
+static tBoolean
+TimerBaseValid(unsigned long ulBase)
+{
+    return((ulBase == TIMER0_BASE) || (ulBase == TIMER1_BASE) ||
+           (ulBase == TIMER2_BASE) || (ulBase == TIMER3_BASE));
+}
+#endif
+
+//*****************************************************************************
+//
+//! Enables the timer(s).
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to enable; must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.
+//!
+//! This will enable operation of the timer module.  The timer must be
+//! configured before it is enabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerEnable(unsigned long ulBase, unsigned long ulTimer)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Enable the timer(s) module.
+    //
+    HWREG(ulBase + TIMER_O_CTL) |= ulTimer &amp; (TIMER_CTL_TAEN | TIMER_CTL_TBEN);
+}
+
+//*****************************************************************************
+//
+//! Disables the timer(s).
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to disable; must be one of
+//! \b TIMER_A, \b TIMER_B, or \b TIMER_BOTH.
+//!
+//! This will disable operation of the timer module.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerDisable(unsigned long ulBase, unsigned long ulTimer)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Disable the timer module.
+    //
+    HWREG(ulBase + TIMER_O_CTL) &amp;= ~(ulTimer &amp;
+                                     (TIMER_CTL_TAEN | TIMER_CTL_TBEN));
+}
+
+//*****************************************************************************
+//
+//! Configures the timer(s).
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulConfig is the configuration for the timer.
+//!
+//! This function configures the operating mode of the timer(s).  The timer
+//! module is disabled before being configured, and is left in the disabled
+//! state.  The configuration is specified in \e ulConfig as one of the
+//! following values:
+//!
+//! - \b TIMER_CFG_32_BIT_OS - 32-bit one shot timer
+//! - \b TIMER_CFG_32_BIT_PER - 32-bit periodic timer
+//! - \b TIMER_CFG_32_RTC - 32-bit real time clock timer
+//! - \b TIMER_CFG_16_BIT_PAIR - Two 16-bit timers
+//!
+//! When configured for a pair of 16-bit timers, each timer is separately
+//! configured.  The first timer is configured by setting \e ulConfig to
+//! the result of a logical OR operation between one of the following values
+//! and \e ulConfig:
+//!
+//! - \b TIMER_CFG_A_ONE_SHOT - 16-bit one shot timer
+//! - \b TIMER_CFG_A_PERIODIC - 16-bit periodic timer
+//! - \b TIMER_CFG_A_CAP_COUNT - 16-bit edge count capture
+//! - \b TIMER_CFG_A_CAP_TIME - 16-bit edge time capture
+//! - \b TIMER_CFG_A_PWM - 16-bit PWM output
+//!
+//! Similarly, the second timer is configured by setting \e ulConfig to
+//! the result of a logical OR operation between one of the corresponding
+//! \b TIMER_CFG_B_* values and \e ulConfig.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerConfigure(unsigned long ulBase, unsigned long ulConfig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulConfig == TIMER_CFG_32_BIT_OS) ||
+           (ulConfig == TIMER_CFG_32_BIT_PER) ||
+           (ulConfig == TIMER_CFG_32_RTC) ||
+           ((ulConfig &amp; 0xff000000) == TIMER_CFG_16_BIT_PAIR));
+    ASSERT(((ulConfig &amp; 0xff000000) != TIMER_CFG_16_BIT_PAIR) ||
+           ((((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_ONE_SHOT) ||
+             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_PERIODIC) ||
+             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_CAP_COUNT) ||
+             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_CAP_TIME) ||
+             ((ulConfig &amp; 0x000000ff) == TIMER_CFG_A_PWM)) &amp;&amp;
+            (((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_ONE_SHOT) ||
+             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_PERIODIC) ||
+             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_CAP_COUNT) ||
+             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_CAP_TIME) ||
+             ((ulConfig &amp; 0x0000ff00) == TIMER_CFG_B_PWM))));
+
+    //
+    // Disable the timers.
+    //
+    HWREG(ulBase + TIMER_O_CTL) &amp;= ~(TIMER_CTL_TAEN | TIMER_CTL_TBEN);
+
+    //
+    // Set the global timer configuration.
+    //
+    HWREG(ulBase + TIMER_O_CFG) = ulConfig &gt;&gt; 24;
+
+    //
+    // Set the configuration of the A and B timers.  Note that the B timer
+    // configuration is ignored by the hardware in 32-bit modes.
+    //
+    HWREG(ulBase + TIMER_O_TAMR) = ulConfig &amp; 255;
+    HWREG(ulBase + TIMER_O_TBMR) = (ulConfig &gt;&gt; 8) &amp; 255;
+}
+
+//*****************************************************************************
+//
+//! Controls the output level.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.
+//! \param bInvert specifies the output level.
+//!
+//! This function sets the PWM output level for the specified timer.  If the
+//! \e bInvert parameter is \b true, then the timer's output will be made
+//! active low; otherwise, it will be made active high.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerControlLevel(unsigned long ulBase, unsigned long ulTimer,
+                  tBoolean bInvert)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Set the output levels as requested.
+    //
+    ulTimer &amp;= TIMER_CTL_TAPWML | TIMER_CTL_TBPWML;
+    HWREG(ulBase + TIMER_O_CTL) = (bInvert ?
+                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :
+                                   (HWREG(ulBase + TIMER_O_CTL) &amp; ~(ulTimer)));
+}
+
+//*****************************************************************************
+//
+//! Enables or disables the trigger output.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer to adjust; must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.
+//! \param bEnable specifies the desired trigger state.
+//!
+//! This function controls the trigger output for the specified timer.  If the
+//! \e bEnable parameter is \b true, then the timer's output trigger is
+//! enabled; otherwise it is disabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerControlTrigger(unsigned long ulBase, unsigned long ulTimer,
+                    tBoolean bEnable)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Set the trigger output as requested.
+    //
+    ulTimer &amp;= TIMER_CTL_TAOTE | TIMER_CTL_TBOTE;
+    HWREG(ulBase + TIMER_O_CTL) = (bEnable ?
+                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :
+                                   (HWREG(ulBase + TIMER_O_CTL) &amp; ~(ulTimer)));
+}
+
+//*****************************************************************************
+//
+//! Controls the event type.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to be adjusted; must be one of
+//! \b TIMER_A, \b TIMER_B, or \b TIMER_BOTH.
+//! \param ulEvent specifies the type of event; must be one of
+//! \b TIMER_EVENT_POS_EDGE, \b TIMER_EVENT_NEG_EDGE, or
+//! \b TIMER_EVENT_BOTH_EDGES.
+//!
+//! This function sets the signal edge(s) that will trigger the timer when in
+//! capture mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerControlEvent(unsigned long ulBase, unsigned long ulTimer,
+                  unsigned long ulEvent)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Set the event type.
+    //
+    ulEvent &amp;= ulTimer &amp; (TIMER_CTL_TAEVENT_M | TIMER_CTL_TBEVENT_M);
+    HWREG(ulBase + TIMER_O_CTL) = ((HWREG(ulBase + TIMER_O_CTL) &amp;
+                                    ~(TIMER_CTL_TAEVENT_M |
+                                      TIMER_CTL_TBEVENT_M)) | ulEvent);
+}
+
+//*****************************************************************************
+//
+//! Controls the stall handling.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to be adjusted; must be one of
+//! \b TIMER_A, \b TIMER_B, or \b TIMER_BOTH.
+//! \param bStall specifies the response to a stall signal.
+//!
+//! This function controls the stall response for the specified timer.  If the
+//! \e bStall parameter is \b true, then the timer will stop counting if the
+//! processor enters debug mode; otherwise the timer will keep running while in
+//! debug mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerControlStall(unsigned long ulBase, unsigned long ulTimer,
+                  tBoolean  bStall)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Set the stall mode.
+    //
+    ulTimer &amp;= TIMER_CTL_TASTALL | TIMER_CTL_TBSTALL;
+    HWREG(ulBase + TIMER_O_CTL) = (bStall ?
+                                   (HWREG(ulBase + TIMER_O_CTL) | ulTimer) :
+                                   (HWREG(ulBase + TIMER_O_CTL) &amp; ~(ulTimer)));
+}
+
+//*****************************************************************************
+//
+//! Enable RTC counting.
+//!
+//! \param ulBase is the base address of the timer module.
+//!
+//! This function causes the timer to start counting when in RTC mode.  If not
+//! configured for RTC mode, this will do nothing.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerRTCEnable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+
+    //
+    // Enable RTC counting.
+    //
+    HWREG(ulBase + TIMER_O_CTL) |= TIMER_CTL_RTCEN;
+}
+
+//*****************************************************************************
+//
+//! Disable RTC counting.
+//!
+//! \param ulBase is the base address of the timer module.
+//!
+//! This function causes the timer to stop counting when in RTC mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerRTCDisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+
+    //
+    // Disable RTC counting.
+    //
+    HWREG(ulBase + TIMER_O_CTL) &amp;= ~(TIMER_CTL_RTCEN);
+}
+
+//*****************************************************************************
+//
+//! Set the timer prescale value.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.
+//! \param ulValue is the timer prescale value; must be between 0 and 255,
+//! inclusive.
+//!
+//! This function sets the value of the input clock prescaler.  The prescaler
+//! is only operational when in 16-bit mode and is used to extend the range of
+//! the 16-bit timer modes.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerPrescaleSet(unsigned long ulBase, unsigned long ulTimer,
+                 unsigned long ulValue)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+    ASSERT(ulValue &lt; 256);
+
+    //
+    // Set the timer A prescaler if requested.
+    //
+    if(ulTimer &amp; TIMER_A)
+    {
+        HWREG(ulBase + TIMER_O_TAPR) = ulValue;
+    }
+
+    //
+    // Set the timer B prescaler if requested.
+    //
+    if(ulTimer &amp; TIMER_B)
+    {
+        HWREG(ulBase + TIMER_O_TBPR) = ulValue;
+    }
+}
+
+//*****************************************************************************
+//
+//! Get the timer prescale value.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
+//! \b TIMER_B.
+//!
+//! This function gets the value of the input clock prescaler.  The prescaler
+//! is only operational when in 16-bit mode and is used to extend the range of
+//! the 16-bit timer modes.
+//!
+//! \return The value of the timer prescaler.
+//
+//*****************************************************************************
+unsigned long
+TimerPrescaleGet(unsigned long ulBase, unsigned long ulTimer)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Return the appropriate prescale value.
+    //
+    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAPR) :
+           HWREG(ulBase + TIMER_O_TBPR));
+}
+
+//*****************************************************************************
+//
+//! Sets the timer load value.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.  Only \b TIMER_A should be used when the
+//! timer is configured for 32-bit operation.
+//! \param ulValue is the load value.
+//!
+//! This function sets the timer load value; if the timer is running then the
+//! value will be immediately loaded into the timer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerLoadSet(unsigned long ulBase, unsigned long ulTimer,
+             unsigned long ulValue)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Set the timer A load value if requested.
+    //
+    if(ulTimer &amp; TIMER_A)
+    {
+        HWREG(ulBase + TIMER_O_TAILR) = ulValue;
+    }
+
+    //
+    // Set the timer B load value if requested.
+    //
+    if(ulTimer &amp; TIMER_B)
+    {
+        HWREG(ulBase + TIMER_O_TBILR) = ulValue;
+    }
+}
+
+//*****************************************************************************
+//
+//! Gets the timer load value.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
+//! \b TIMER_B.  Only \b TIMER_A should be used when the timer is configured
+//! for 32-bit operation.
+//!
+//! This function gets the currently programmed interval load value for the
+//! specified timer.
+//!
+//! \return Returns the load value for the timer.
+//
+//*****************************************************************************
+unsigned long
+TimerLoadGet(unsigned long ulBase, unsigned long ulTimer)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));
+
+    //
+    // Return the appropriate load value.
+    //
+    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAILR) :
+           HWREG(ulBase + TIMER_O_TBILR));
+}
+
+//*****************************************************************************
+//
+//! Gets the current timer value.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
+//! \b TIMER_B.  Only \b TIMER_A should be used when the timer is configured
+//! for 32-bit operation.
+//!
+//! This function reads the current value of the specified timer.
+//!
+//! \return Returns the current value of the timer.
+//
+//*****************************************************************************
+unsigned long
+TimerValueGet(unsigned long ulBase, unsigned long ulTimer)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));
+
+    //
+    // Return the appropriate timer value.
+    //
+    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAR) :
+           HWREG(ulBase + TIMER_O_TBR));
+}
+
+//*****************************************************************************
+//
+//! Sets the timer match value.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s) to adjust; must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.  Only \b TIMER_A should be used when the
+//! timer is configured for 32-bit operation.
+//! \param ulValue is the match value.
+//!
+//! This function sets the match value for a timer.  This is used in capture
+//! count mode to determine when to interrupt the processor and in PWM mode to
+//! determine the duty cycle of the output signal.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerMatchSet(unsigned long ulBase, unsigned long ulTimer,
+              unsigned long ulValue)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Set the timer A match value if requested.
+    //
+    if(ulTimer &amp; TIMER_A)
+    {
+        HWREG(ulBase + TIMER_O_TAMATCHR) = ulValue;
+    }
+
+    //
+    // Set the timer B match value if requested.
+    //
+    if(ulTimer &amp; TIMER_B)
+    {
+        HWREG(ulBase + TIMER_O_TBMATCHR) = ulValue;
+    }
+}
+
+//*****************************************************************************
+//
+//! Gets the timer match value.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer; must be one of \b TIMER_A or
+//! \b TIMER_B.  Only \b TIMER_A should be used when the timer is configured
+//! for 32-bit operation.
+//!
+//! This function gets the match value for the specified timer.
+//!
+//! \return Returns the match value for the timer.
+//
+//*****************************************************************************
+unsigned long
+TimerMatchGet(unsigned long ulBase, unsigned long ulTimer)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B));
+
+    //
+    // Return the appropriate match value.
+    //
+    return((ulTimer == TIMER_A) ? HWREG(ulBase + TIMER_O_TAMATCHR) :
+           HWREG(ulBase + TIMER_O_TBMATCHR));
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for the timer interrupt.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s); must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.
+//! \param pfnHandler is a pointer to the function to be called when the timer
+//! interrupt occurs.
+//!
+//! This sets the handler to be called when a timer interrupt occurs.  This
+//! will enable the global interrupt in the interrupt controller; specific
+//! timer interrupts must be enabled via TimerIntEnable().  It is the interrupt
+//! handler's responsibility to clear the interrupt source via TimerIntClear().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerIntRegister(unsigned long ulBase, unsigned long ulTimer,
+                 void (*pfnHandler)(void))
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Get the interrupt number for this timer module.
+    //
+    ulBase = ((ulBase == TIMER0_BASE) ? INT_TIMER0A :
+              ((ulBase == TIMER1_BASE) ? INT_TIMER1A :
+               ((ulBase == TIMER2_BASE) ? INT_TIMER2A : INT_TIMER3A)));
+
+    //
+    // Register an interrupt handler for timer A if requested.
+    //
+    if(ulTimer &amp; TIMER_A)
+    {
+        //
+        // Register the interrupt handler.
+        //
+        IntRegister(ulBase, pfnHandler);
+
+        //
+        // Enable the interrupt.
+        //
+        IntEnable(ulBase);
+    }
+
+    //
+    // Register an interrupt handler for timer B if requested.
+    //
+    if(ulTimer &amp; TIMER_B)
+    {
+        //
+        // Register the interrupt handler.
+        //
+        IntRegister(ulBase + 1, pfnHandler);
+
+        //
+        // Enable the interrupt.
+        //
+        IntEnable(ulBase + 1);
+    }
+}
+
+//*****************************************************************************
+//
+//! Unregisters an interrupt handler for the timer interrupt.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulTimer specifies the timer(s); must be one of \b TIMER_A,
+//! \b TIMER_B, or \b TIMER_BOTH.
+//!
+//! This function will clear the handler to be called when a timer interrupt
+//! occurs.  This will also mask off the interrupt in the interrupt controller
+//! so that the interrupt handler no longer is called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerIntUnregister(unsigned long ulBase, unsigned long ulTimer)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+    ASSERT((ulTimer == TIMER_A) || (ulTimer == TIMER_B) ||
+           (ulTimer == TIMER_BOTH));
+
+    //
+    // Get the interrupt number for this timer module.
+    //
+    ulBase = ((ulBase == TIMER0_BASE) ? INT_TIMER0A :
+              ((ulBase == TIMER1_BASE) ? INT_TIMER1A :
+               ((ulBase == TIMER2_BASE) ? INT_TIMER2A : INT_TIMER3A)));
+
+    //
+    // Unregister the interrupt handler for timer A if requested.
+    //
+    if(ulTimer &amp; TIMER_A)
+    {
+        //
+        // Disable the interrupt.
+        //
+        IntDisable(ulBase);
+
+        //
+        // Unregister the interrupt handler.
+        //
+        IntUnregister(ulBase);
+    }
+
+    //
+    // Unregister the interrupt handler for timer B if requested.
+    //
+    if(ulTimer &amp; TIMER_B)
+    {
+        //
+        // Disable the interrupt.
+        //
+        IntDisable(ulBase + 1);
+
+        //
+        // Unregister the interrupt handler.
+        //
+        IntUnregister(ulBase + 1);
+    }
+}
+
+//*****************************************************************************
+//
+//! Enables individual timer interrupt sources.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
+//!
+//! Enables the indicated timer interrupt sources.  Only the sources that are
+//! enabled can be reflected to the processor interrupt; disabled sources have
+//! no effect on the processor.
+//!
+//! The \e ulIntFlags parameter must be the logical OR of any combination of
+//! the following:
+//!
+//! - \b TIMER_CAPB_EVENT  - Capture B event interrupt
+//! - \b TIMER_CAPB_MATCH  - Capture B match interrupt
+//! - \b TIMER_TIMB_TIMEOUT  - Timer B timeout interrupt
+//! - \b TIMER_RTC_MATCH  - RTC interrupt mask
+//! - \b TIMER_CAPA_EVENT  - Capture A event interrupt
+//! - \b TIMER_CAPA_MATCH  - Capture A match interrupt
+//! - \b TIMER_TIMA_TIMEOUT  - Timer A timeout interrupt
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(ulBase + TIMER_O_IMR) |= ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Disables individual timer interrupt sources.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
+//!
+//! Disables the indicated timer interrupt sources.  Only the sources that are
+//! enabled can be reflected to the processor interrupt; disabled sources have
+//! no effect on the processor.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to TimerIntEnable().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(ulBase + TIMER_O_IMR) &amp;= ~(ulIntFlags);
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param bMasked is false if the raw interrupt status is required and true if
+//! the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the timer module.  Either the raw
+//! interrupt status or the status of interrupts that are allowed to reflect to
+//! the processor can be returned.
+//!
+//! \return The current interrupt status, enumerated as a bit field of
+//! values described in TimerIntEnable().
+//
+//*****************************************************************************
+unsigned long
+TimerIntStatus(unsigned long ulBase, tBoolean bMasked)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    return(bMasked ? HWREG(ulBase + TIMER_O_MIS) :
+           HWREG(ulBase + TIMER_O_RIS));
+}
+
+//*****************************************************************************
+//
+//! Clears timer interrupt sources.
+//!
+//! \param ulBase is the base address of the timer module.
+//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
+//!
+//! The specified timer interrupt sources are cleared, so that they no longer
+//! assert.  This must be done in the interrupt handler to keep it from being
+//! called again immediately upon exit.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to TimerIntEnable().
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+TimerIntClear(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+
+    //
+    // Clear the requested interrupt sources.
+    //
+    HWREG(ulBase + TIMER_O_ICR) = ulIntFlags;
+}
+
+//*****************************************************************************
+//
+// Puts the timer into its reset state.
+//
+// \param ulBase is the base address of the timer module.
+//
+// The specified timer is disabled, and all its interrupts are disabled,
+// cleared, and unregistered.  Then the timer registers are set to their reset
+// value.
+//
+// \return None.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+void
+TimerQuiesce(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(TimerBaseValid(ulBase));
+
+    //
+    // Disable the timer.
+    //
+    HWREG(ulBase + TIMER_O_CTL) = TIMER_RV_CTL;
+
+    //
+    // Disable all the timer interrupts.
+    //
+    HWREG(ulBase + TIMER_O_IMR) = TIMER_RV_IMR;
+
+    //
+    // Clear all the timer interrupts.
+    //
+    HWREG(ulBase + TIMER_O_ICR) = 0xFFFFFFFF;
+
+    //
+    // Unregister the interrupt handler.  This also disables interrupts to the
+    // core.
+    //
+    TimerIntUnregister(ulBase, TIMER_BOTH);
+
+    //
+    // Set all the registers to their reset value.
+    //
+    HWREG(ulBase + TIMER_O_CFG) = TIMER_RV_CFG;
+    HWREG(ulBase + TIMER_O_TAMR) = TIMER_RV_TAMR;
+    HWREG(ulBase + TIMER_O_TBMR) = TIMER_RV_TBMR;
+    HWREG(ulBase + TIMER_O_RIS) = TIMER_RV_RIS;
+    HWREG(ulBase + TIMER_O_MIS) = TIMER_RV_MIS;
+    HWREG(ulBase + TIMER_O_TAILR) = TIMER_RV_TAILR;
+    HWREG(ulBase + TIMER_O_TBILR) = TIMER_RV_TBILR;
+    HWREG(ulBase + TIMER_O_TAMATCHR) = TIMER_RV_TAMATCHR;
+    HWREG(ulBase + TIMER_O_TBMATCHR) = TIMER_RV_TBMATCHR;
+    HWREG(ulBase + TIMER_O_TAPR) = TIMER_RV_TAPR;
+    HWREG(ulBase + TIMER_O_TBPR) = TIMER_RV_TBPR;
+    HWREG(ulBase + TIMER_O_TAPMR) = TIMER_RV_TAPMR;
+    HWREG(ulBase + TIMER_O_TBPMR) = TIMER_RV_TBPMR;
+    HWREG(ulBase + TIMER_O_TAR) = TIMER_RV_TAR;
+    HWREG(ulBase + TIMER_O_TBR) = TIMER_RV_TBR;
+}
+#endif // DEPRECATED
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/timer.c
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/platform/lm3s/timer.h
===================================================================
--- trunk/src/platform/lm3s/timer.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/timer.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -1,153 +1,153 @@
-//*****************************************************************************
-//
-// timer.h - Prototypes for the timer module
-//
-// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
-// Software License Agreement
-// 
-// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
-// exclusively on LMI's microcontroller products.
-// 
-// The software is owned by LMI and/or its suppliers, and is protected under
-// applicable copyright laws.  All rights are reserved.  You may not combine
-// this software with &quot;viral&quot; open-source software in order to form a larger
-// program.  Any use in violation of the foregoing restrictions may subject
-// the user to criminal sanctions under applicable laws, as well as to civil
-// liability for the breach of the terms and conditions of this license.
-// 
-// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
-// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
-// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
-// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
-// 
-// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
-//
-//*****************************************************************************
-
-#ifndef __TIMER_H__
-#define __TIMER_H__
-
-//*****************************************************************************
-//
-// If building with a C++ compiler, make all of the definitions in this header
-// have a C binding.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-//*****************************************************************************
-//
-// Values that can be passed to TimerConfigure as the ulConfig parameter.
-//
-//*****************************************************************************
-#define TIMER_CFG_32_BIT_OS     0x00000001  // 32-bit one-shot timer
-#define TIMER_CFG_32_BIT_PER    0x00000002  // 32-bit periodic timer
-#define TIMER_CFG_32_RTC        0x01000000  // 32-bit RTC timer
-#define TIMER_CFG_16_BIT_PAIR   0x04000000  // Two 16-bit timers
-#define TIMER_CFG_A_ONE_SHOT    0x00000001  // Timer A one-shot timer
-#define TIMER_CFG_A_PERIODIC    0x00000002  // Timer A periodic timer
-#define TIMER_CFG_A_CAP_COUNT   0x00000003  // Timer A event counter
-#define TIMER_CFG_A_CAP_TIME    0x00000007  // Timer A event timer
-#define TIMER_CFG_A_PWM         0x0000000A  // Timer A PWM output
-#define TIMER_CFG_B_ONE_SHOT    0x00000100  // Timer B one-shot timer
-#define TIMER_CFG_B_PERIODIC    0x00000200  // Timer B periodic timer
-#define TIMER_CFG_B_CAP_COUNT   0x00000300  // Timer B event counter
-#define TIMER_CFG_B_CAP_TIME    0x00000700  // Timer B event timer
-#define TIMER_CFG_B_PWM         0x00000A00  // Timer B PWM output
-
-//*****************************************************************************
-//
-// Values that can be passed to TimerIntEnable, TimerIntDisable, and
-// TimerIntClear as the ulIntFlags parameter, and returned from TimerIntStatus.
-//
-//*****************************************************************************
-#define TIMER_CAPB_EVENT        0x00000400  // CaptureB event interrupt
-#define TIMER_CAPB_MATCH        0x00000200  // CaptureB match interrupt
-#define TIMER_TIMB_TIMEOUT      0x00000100  // TimerB time out interrupt
-#define TIMER_RTC_MATCH         0x00000008  // RTC interrupt mask
-#define TIMER_CAPA_EVENT        0x00000004  // CaptureA event interrupt
-#define TIMER_CAPA_MATCH        0x00000002  // CaptureA match interrupt
-#define TIMER_TIMA_TIMEOUT      0x00000001  // TimerA time out interrupt
-
-//*****************************************************************************
-//
-// Values that can be passed to TimerControlEvent as the ulEvent parameter.
-//
-//*****************************************************************************
-#define TIMER_EVENT_POS_EDGE    0x00000000  // Count positive edges
-#define TIMER_EVENT_NEG_EDGE    0x00000404  // Count negative edges
-#define TIMER_EVENT_BOTH_EDGES  0x00000C0C  // Count both edges
-
-//*****************************************************************************
-//
-// Values that can be passed to most of the timer APIs as the ulTimer
-// parameter.
-//
-//*****************************************************************************
-#define TIMER_A                 0x000000ff  // Timer A
-#define TIMER_B                 0x0000ff00  // Timer B
-#define TIMER_BOTH              0x0000ffff  // Timer Both
-
-//*****************************************************************************
-//
-// Prototypes for the APIs.
-//
-//*****************************************************************************
-extern void TimerEnable(unsigned long ulBase, unsigned long ulTimer);
-extern void TimerDisable(unsigned long ulBase, unsigned long ulTimer);
-extern void TimerConfigure(unsigned long ulBase, unsigned long ulConfig);
-extern void TimerControlLevel(unsigned long ulBase, unsigned long ulTimer,
-                              tBoolean bInvert);
-extern void TimerControlTrigger(unsigned long ulBase, unsigned long ulTimer,
-                                tBoolean bEnable);
-extern void TimerControlEvent(unsigned long ulBase, unsigned long ulTimer,
-                              unsigned long ulEvent);
-extern void TimerControlStall(unsigned long ulBase, unsigned long ulTimer,
-                              tBoolean bStall);
-extern void TimerRTCEnable(unsigned long ulBase);
-extern void TimerRTCDisable(unsigned long ulBase);
-extern void TimerPrescaleSet(unsigned long ulBase, unsigned long ulTimer,
-                             unsigned long ulValue);
-extern unsigned long TimerPrescaleGet(unsigned long ulBase,
-                                      unsigned long ulTimer);
-extern void TimerLoadSet(unsigned long ulBase, unsigned long ulTimer,
-                         unsigned long ulValue);
-extern unsigned long TimerLoadGet(unsigned long ulBase, unsigned long ulTimer);
-extern unsigned long TimerValueGet(unsigned long ulBase,
-                                   unsigned long ulTimer);
-extern void TimerMatchSet(unsigned long ulBase, unsigned long ulTimer,
-                          unsigned long ulValue);
-extern unsigned long TimerMatchGet(unsigned long ulBase,
-                                   unsigned long ulTimer);
-extern void TimerIntRegister(unsigned long ulBase, unsigned long ulTimer,
-                             void (*pfnHandler)(void));
-extern void TimerIntUnregister(unsigned long ulBase, unsigned long ulTimer);
-extern void TimerIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
-extern void TimerIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
-extern unsigned long TimerIntStatus(unsigned long ulBase, tBoolean bMasked);
-extern void TimerIntClear(unsigned long ulBase, unsigned long ulIntFlags);
-
-//*****************************************************************************
-//
-// TimerQuiesce() has been deprecated.  SysCtlPeripheralReset() should be used
-// instead to return the timer to its reset state.
-//
-//*****************************************************************************
-#ifndef DEPRECATED
-extern void TimerQuiesce(unsigned long ulBase);
-#endif
-
-//*****************************************************************************
-//
-// Mark the end of the C bindings section for C++ compilers.
-//
-//*****************************************************************************
-#ifdef __cplusplus
-}
-#endif
-
-#endif // __TIMER_H__
+//*****************************************************************************
+//
+// timer.h - Prototypes for the timer module
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to TimerConfigure as the ulConfig parameter.
+//
+//*****************************************************************************
+#define TIMER_CFG_32_BIT_OS     0x00000001  // 32-bit one-shot timer
+#define TIMER_CFG_32_BIT_PER    0x00000002  // 32-bit periodic timer
+#define TIMER_CFG_32_RTC        0x01000000  // 32-bit RTC timer
+#define TIMER_CFG_16_BIT_PAIR   0x04000000  // Two 16-bit timers
+#define TIMER_CFG_A_ONE_SHOT    0x00000001  // Timer A one-shot timer
+#define TIMER_CFG_A_PERIODIC    0x00000002  // Timer A periodic timer
+#define TIMER_CFG_A_CAP_COUNT   0x00000003  // Timer A event counter
+#define TIMER_CFG_A_CAP_TIME    0x00000007  // Timer A event timer
+#define TIMER_CFG_A_PWM         0x0000000A  // Timer A PWM output
+#define TIMER_CFG_B_ONE_SHOT    0x00000100  // Timer B one-shot timer
+#define TIMER_CFG_B_PERIODIC    0x00000200  // Timer B periodic timer
+#define TIMER_CFG_B_CAP_COUNT   0x00000300  // Timer B event counter
+#define TIMER_CFG_B_CAP_TIME    0x00000700  // Timer B event timer
+#define TIMER_CFG_B_PWM         0x00000A00  // Timer B PWM output
+
+//*****************************************************************************
+//
+// Values that can be passed to TimerIntEnable, TimerIntDisable, and
+// TimerIntClear as the ulIntFlags parameter, and returned from TimerIntStatus.
+//
+//*****************************************************************************
+#define TIMER_CAPB_EVENT        0x00000400  // CaptureB event interrupt
+#define TIMER_CAPB_MATCH        0x00000200  // CaptureB match interrupt
+#define TIMER_TIMB_TIMEOUT      0x00000100  // TimerB time out interrupt
+#define TIMER_RTC_MATCH         0x00000008  // RTC interrupt mask
+#define TIMER_CAPA_EVENT        0x00000004  // CaptureA event interrupt
+#define TIMER_CAPA_MATCH        0x00000002  // CaptureA match interrupt
+#define TIMER_TIMA_TIMEOUT      0x00000001  // TimerA time out interrupt
+
+//*****************************************************************************
+//
+// Values that can be passed to TimerControlEvent as the ulEvent parameter.
+//
+//*****************************************************************************
+#define TIMER_EVENT_POS_EDGE    0x00000000  // Count positive edges
+#define TIMER_EVENT_NEG_EDGE    0x00000404  // Count negative edges
+#define TIMER_EVENT_BOTH_EDGES  0x00000C0C  // Count both edges
+
+//*****************************************************************************
+//
+// Values that can be passed to most of the timer APIs as the ulTimer
+// parameter.
+//
+//*****************************************************************************
+#define TIMER_A                 0x000000ff  // Timer A
+#define TIMER_B                 0x0000ff00  // Timer B
+#define TIMER_BOTH              0x0000ffff  // Timer Both
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern void TimerEnable(unsigned long ulBase, unsigned long ulTimer);
+extern void TimerDisable(unsigned long ulBase, unsigned long ulTimer);
+extern void TimerConfigure(unsigned long ulBase, unsigned long ulConfig);
+extern void TimerControlLevel(unsigned long ulBase, unsigned long ulTimer,
+                              tBoolean bInvert);
+extern void TimerControlTrigger(unsigned long ulBase, unsigned long ulTimer,
+                                tBoolean bEnable);
+extern void TimerControlEvent(unsigned long ulBase, unsigned long ulTimer,
+                              unsigned long ulEvent);
+extern void TimerControlStall(unsigned long ulBase, unsigned long ulTimer,
+                              tBoolean bStall);
+extern void TimerRTCEnable(unsigned long ulBase);
+extern void TimerRTCDisable(unsigned long ulBase);
+extern void TimerPrescaleSet(unsigned long ulBase, unsigned long ulTimer,
+                             unsigned long ulValue);
+extern unsigned long TimerPrescaleGet(unsigned long ulBase,
+                                      unsigned long ulTimer);
+extern void TimerLoadSet(unsigned long ulBase, unsigned long ulTimer,
+                         unsigned long ulValue);
+extern unsigned long TimerLoadGet(unsigned long ulBase, unsigned long ulTimer);
+extern unsigned long TimerValueGet(unsigned long ulBase,
+                                   unsigned long ulTimer);
+extern void TimerMatchSet(unsigned long ulBase, unsigned long ulTimer,
+                          unsigned long ulValue);
+extern unsigned long TimerMatchGet(unsigned long ulBase,
+                                   unsigned long ulTimer);
+extern void TimerIntRegister(unsigned long ulBase, unsigned long ulTimer,
+                             void (*pfnHandler)(void));
+extern void TimerIntUnregister(unsigned long ulBase, unsigned long ulTimer);
+extern void TimerIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void TimerIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
+extern unsigned long TimerIntStatus(unsigned long ulBase, tBoolean bMasked);
+extern void TimerIntClear(unsigned long ulBase, unsigned long ulIntFlags);
+
+//*****************************************************************************
+//
+// TimerQuiesce() has been deprecated.  SysCtlPeripheralReset() should be used
+// instead to return the timer to its reset state.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+extern void TimerQuiesce(unsigned long ulBase);
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __TIMER_H__


Property changes on: trunk/src/platform/lm3s/timer.h
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/uart.c
===================================================================
--- trunk/src/platform/lm3s/uart.c	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/uart.c	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,1621 @@
+//*****************************************************************************
+//
+// uart.c - Driver for the UART.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup uart_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_sysctl.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;hw_uart.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+#include &quot;uart.h&quot;
+
+//*****************************************************************************
+//
+// The system clock divider defining the maximum baud rate supported by the
+// UART.
+//
+//*****************************************************************************
+#define UART_CLK_DIVIDER        ((CLASS_IS_SANDSTORM ||                       \
+                                  (CLASS_IS_FURY &amp;&amp; REVISION_IS_A2) ||        \
+                                  (CLASS_IS_DUSTDEVIL &amp;&amp; REVISION_IS_A0)) ?   \
+                                 16 : 8)
+
+//*****************************************************************************
+//
+//! \internal
+//! Checks a UART base address.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function determines if a UART port base address is valid.
+//!
+//! \return Returns \b true if the base address is valid and \b false
+//! otherwise.
+//
+//*****************************************************************************
+#ifdef DEBUG
+static tBoolean
+UARTBaseValid(unsigned long ulBase)
+{
+    return((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
+           (ulBase == UART2_BASE));
+}
+#endif
+
+//*****************************************************************************
+//
+//! Sets the type of parity.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulParity specifies the type of parity to use.
+//!
+//! Sets the type of parity to use for transmitting and expect when receiving.
+//! The \e ulParity parameter must be one of \b UART_CONFIG_PAR_NONE,
+//! \b UART_CONFIG_PAR_EVEN, \b UART_CONFIG_PAR_ODD, \b UART_CONFIG_PAR_ONE,
+//! or \b UART_CONFIG_PAR_ZERO.  The last two allow direct control of the
+//! parity bit; it will always be either be one or zero based on the mode.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTParityModeSet(unsigned long ulBase, unsigned long ulParity)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+    ASSERT((ulParity == UART_CONFIG_PAR_NONE) ||
+           (ulParity == UART_CONFIG_PAR_EVEN) ||
+           (ulParity == UART_CONFIG_PAR_ODD) ||
+           (ulParity == UART_CONFIG_PAR_ONE) ||
+           (ulParity == UART_CONFIG_PAR_ZERO));
+
+    //
+    // Set the parity mode.
+    //
+    HWREG(ulBase + UART_O_LCRH) = ((HWREG(ulBase + UART_O_LCRH) &amp;
+                                    ~(UART_LCRH_SPS | UART_LCRH_EPS |
+                                      UART_LCRH_PEN)) | ulParity);
+}
+
+//*****************************************************************************
+//
+//! Gets the type of parity currently being used.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function gets the type of parity used for transmitting data, and
+//! expected when receiving data.
+//!
+//! \return Returns the current parity settings, specified as one of
+//! \b UART_CONFIG_PAR_NONE, \b UART_CONFIG_PAR_EVEN, \b UART_CONFIG_PAR_ODD,
+//! \b UART_CONFIG_PAR_ONE, or \b UART_CONFIG_PAR_ZERO.
+//
+//*****************************************************************************
+unsigned long
+UARTParityModeGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Return the current parity setting.
+    //
+    return(HWREG(ulBase + UART_O_LCRH) &amp;
+           (UART_LCRH_SPS | UART_LCRH_EPS | UART_LCRH_PEN));
+}
+
+//*****************************************************************************
+//
+//! Sets the FIFO level at which interrupts are generated.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulTxLevel is the transmit FIFO interrupt level, specified as one of
+//! \b UART_FIFO_TX1_8, \b UART_FIFO_TX2_8, \b UART_FIFO_TX4_8,
+//! \b UART_FIFO_TX6_8, or \b UART_FIFO_TX7_8.
+//! \param ulRxLevel is the receive FIFO interrupt level, specified as one of
+//! \b UART_FIFO_RX1_8, \b UART_FIFO_RX2_8, \b UART_FIFO_RX4_8,
+//! \b UART_FIFO_RX6_8, or \b UART_FIFO_RX7_8.
+//!
+//! This function sets the FIFO level at which transmit and receive interrupts
+//! will be generated.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTFIFOLevelSet(unsigned long ulBase, unsigned long ulTxLevel,
+                 unsigned long ulRxLevel)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+    ASSERT((ulTxLevel == UART_FIFO_TX1_8) ||
+           (ulTxLevel == UART_FIFO_TX2_8) ||
+           (ulTxLevel == UART_FIFO_TX4_8) ||
+           (ulTxLevel == UART_FIFO_TX6_8) ||
+           (ulTxLevel == UART_FIFO_TX7_8));
+    ASSERT((ulRxLevel == UART_FIFO_RX1_8) ||
+           (ulRxLevel == UART_FIFO_RX2_8) ||
+           (ulRxLevel == UART_FIFO_RX4_8) ||
+           (ulRxLevel == UART_FIFO_RX6_8) ||
+           (ulRxLevel == UART_FIFO_RX7_8));
+
+    //
+    // Set the FIFO interrupt levels.
+    //
+    HWREG(ulBase + UART_O_IFLS) = ulTxLevel | ulRxLevel;
+}
+
+//*****************************************************************************
+//
+//! Gets the FIFO level at which interrupts are generated.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param pulTxLevel is a pointer to storage for the transmit FIFO level,
+//! returned as one of \b UART_FIFO_TX1_8, \b UART_FIFO_TX2_8,
+//! \b UART_FIFO_TX4_8, \b UART_FIFO_TX6_8, or UART_FIFO_TX7_8.
+//! \param pulRxLevel is a pointer to storage for the receive FIFO level,
+//! returned as one of \b UART_FIFO_RX1_8, \b UART_FIFO_RX2_8,
+//! \b UART_FIFO_RX4_8, \b UART_FIFO_RX6_8, or \b UART_FIFO_RX7_8.
+//!
+//! This function gets the FIFO level at which transmit and receive interrupts
+//! will be generated.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTFIFOLevelGet(unsigned long ulBase, unsigned long *pulTxLevel,
+                 unsigned long *pulRxLevel)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Read the FIFO level register.
+    //
+    ulTemp = HWREG(ulBase + UART_O_IFLS);
+
+    //
+    // Extract the transmit and receive FIFO levels.
+    //
+    *pulTxLevel = ulTemp &amp; UART_IFLS_TX_M;
+    *pulRxLevel = ulTemp &amp; UART_IFLS_RX_M;
+}
+
+//*****************************************************************************
+//
+//! Sets the configuration of a UART.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulUARTClk is the rate of the clock supplied to the UART module.
+//! \param ulBaud is the desired baud rate.
+//! \param ulConfig is the data format for the port (number of data bits,
+//! number of stop bits, and parity).
+//!
+//! This function will configure the UART for operation in the specified data
+//! format.  The baud rate is provided in the \e ulBaud parameter and the data
+//! format in the \e ulConfig parameter.
+//!
+//! The \e ulConfig parameter is the logical OR of three values: the number of
+//! data bits, the number of stop bits, and the parity.  \b UART_CONFIG_WLEN_8,
+//! \b UART_CONFIG_WLEN_7, \b UART_CONFIG_WLEN_6, and \b UART_CONFIG_WLEN_5
+//! select from eight to five data bits per byte (respectively).
+//! \b UART_CONFIG_STOP_ONE and \b UART_CONFIG_STOP_TWO select one or two stop
+//! bits (respectively).  \b UART_CONFIG_PAR_NONE, \b UART_CONFIG_PAR_EVEN,
+//! \b UART_CONFIG_PAR_ODD, \b UART_CONFIG_PAR_ONE, and \b UART_CONFIG_PAR_ZERO
+//! select the parity mode (no parity bit, even parity bit, odd parity bit,
+//! parity bit always one, and parity bit always zero, respectively).
+//!
+//! The peripheral clock will be the same as the processor clock.  This will be
+//! the value returned by SysCtlClockGet(), or it can be explicitly hard coded
+//! if it is constant and known (to save the code/execution overhead of a call
+//! to SysCtlClockGet()).
+//!
+//! This function replaces the original UARTConfigSet() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;uart.h&lt;/tt&gt; to map the original
+//! API to this API.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTConfigSetExpClk(unsigned long ulBase, unsigned long ulUARTClk,
+                    unsigned long ulBaud, unsigned long ulConfig)
+{
+    unsigned long ulDiv;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+    ASSERT(ulBaud != 0);
+    ASSERT(ulUARTClk &gt;= (ulBaud * UART_CLK_DIVIDER));
+
+    //
+    // Stop the UART.
+    //
+    UARTDisable(ulBase);
+
+    //
+    // Is the required baud rate greater than the maximum rate supported
+    // without the use of high speed mode?
+    //
+    if((ulBaud * 16) &gt; ulUARTClk)
+    {
+        //
+        // Enable high speed mode.
+        //
+        HWREG(ulBase + UART_O_CTL) |= UART_CTL_HSE;
+
+        //
+        // Half the supplied baud rate to compensate for enabling high speed
+        // mode.  This allows the following code to be common to both cases.
+        //
+        ulBaud /= 2;
+    }
+    else
+    {
+        //
+        // Disable high speed mode.
+        //
+        HWREG(ulBase + UART_O_CTL) &amp;= ~(UART_CTL_HSE);
+    }
+
+    //
+    // Compute the fractional baud rate divider.
+    //
+    ulDiv = (((ulUARTClk * 8) / ulBaud) + 1) / 2;
+
+    //
+    // Set the baud rate.
+    //
+    HWREG(ulBase + UART_O_IBRD) = ulDiv / 64;
+    HWREG(ulBase + UART_O_FBRD) = ulDiv % 64;
+
+    //
+    // Set parity, data length, and number of stop bits.
+    //
+    HWREG(ulBase + UART_O_LCRH) = ulConfig;
+
+    //
+    // Clear the flags register.
+    //
+    HWREG(ulBase + UART_O_FR) = 0;
+
+    //
+    // Start the UART.
+    //
+    UARTEnable(ulBase);
+}
+
+//*****************************************************************************
+//
+//! Gets the current configuration of a UART.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulUARTClk is the rate of the clock supplied to the UART module.
+//! \param pulBaud is a pointer to storage for the baud rate.
+//! \param pulConfig is a pointer to storage for the data format.
+//!
+//! The baud rate and data format for the UART is determined, given an
+//! explicitly provided peripheral clock (hence the ExpClk suffix).  The
+//! returned baud rate is the actual baud rate; it may not be the exact baud
+//! rate requested or an ``official'' baud rate.  The data format returned in
+//! \e pulConfig is enumerated the same as the \e ulConfig parameter of
+//! UARTConfigSetExpClk().
+//!
+//! The peripheral clock will be the same as the processor clock.  This will be
+//! the value returned by SysCtlClockGet(), or it can be explicitly hard coded
+//! if it is constant and known (to save the code/execution overhead of a call
+//! to SysCtlClockGet()).
+//!
+//! This function replaces the original UARTConfigGet() API and performs the
+//! same actions.  A macro is provided in &lt;tt&gt;uart.h&lt;/tt&gt; to map the original
+//! API to this API.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTConfigGetExpClk(unsigned long ulBase, unsigned long ulUARTClk,
+                    unsigned long *pulBaud, unsigned long *pulConfig)
+{
+    unsigned long ulInt, ulFrac;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Compute the baud rate.
+    //
+    ulInt = HWREG(ulBase + UART_O_IBRD);
+    ulFrac = HWREG(ulBase + UART_O_FBRD);
+    *pulBaud = (ulUARTClk * 4) / ((64 * ulInt) + ulFrac);
+
+    //
+    // See if high speed mode enabled.
+    //
+    if(HWREG(ulBase + UART_O_CTL) &amp; UART_CTL_HSE)
+    {
+        //
+        // High speed mode is enabled so the actual baud rate is actually
+        // double what was just calculated.
+        //
+        *pulBaud *= 2;
+    }
+
+    //
+    // Get the parity, data length, and number of stop bits.
+    //
+    *pulConfig = (HWREG(ulBase + UART_O_LCRH) &amp;
+                  (UART_LCRH_SPS | UART_LCRH_WLEN_M | UART_LCRH_STP2 |
+                   UART_LCRH_EPS | UART_LCRH_PEN));
+}
+
+//*****************************************************************************
+//
+//! Enables transmitting and receiving.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Sets the UARTEN, TXE, and RXE bits, and enables the transmit and receive
+//! FIFOs.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTEnable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Enable the FIFO.
+    //
+    HWREG(ulBase + UART_O_LCRH) |= UART_LCRH_FEN;
+
+    //
+    // Enable RX, TX, and the UART.
+    //
+    HWREG(ulBase + UART_O_CTL) |= (UART_CTL_UARTEN | UART_CTL_TXE |
+                                   UART_CTL_RXE);
+}
+
+//*****************************************************************************
+//
+//! Disables transmitting and receiving.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Clears the UARTEN, TXE, and RXE bits, then waits for the end of
+//! transmission of the current character, and flushes the transmit FIFO.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTDisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Wait for end of TX.
+    //
+    while(HWREG(ulBase + UART_O_FR) &amp; UART_FR_BUSY)
+    {
+    }
+
+    //
+    // Disable the FIFO.
+    //
+    HWREG(ulBase + UART_O_LCRH) &amp;= ~(UART_LCRH_FEN);
+
+    //
+    // Disable the UART.
+    //
+    HWREG(ulBase + UART_O_CTL) &amp;= ~(UART_CTL_UARTEN | UART_CTL_TXE |
+                                    UART_CTL_RXE);
+}
+
+//*****************************************************************************
+//
+//! Enables the transmit and receive FIFOs.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This functions enables the transmit and receive FIFOs in the UART.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTFIFOEnable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Enable the FIFO.
+    //
+    HWREG(ulBase + UART_O_LCRH) |= UART_LCRH_FEN;
+}
+
+//*****************************************************************************
+//
+//! Disables the transmit and receive FIFOs.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This functions disables the transmit and receive FIFOs in the UART.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTFIFODisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Disable the FIFO.
+    //
+    HWREG(ulBase + UART_O_LCRH) &amp;= ~(UART_LCRH_FEN);
+}
+
+//*****************************************************************************
+//
+//! Enables SIR (IrDA) mode on the specified UART.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param bLowPower indicates if SIR Low Power Mode is to be used.
+//!
+//! Enables the SIREN control bit for IrDA mode on the UART.  If the
+//! \e bLowPower flag is set, then SIRLP bit will also be set.
+//!
+//! \note SIR (IrDA) operation is not supported on Sandstorm-class devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTEnableSIR(unsigned long ulBase, tBoolean bLowPower)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Enable SIR and SIRLP (if appropriate).
+    //
+    if(bLowPower)
+    {
+        HWREG(ulBase + UART_O_CTL) |= (UART_CTL_SIREN | UART_CTL_SIRLP);
+    }
+    else
+    {
+        HWREG(ulBase + UART_O_CTL) |= (UART_CTL_SIREN);
+    }
+}
+
+//*****************************************************************************
+//
+//! Disables SIR (IrDA) mode on the specified UART.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Clears the SIREN (IrDA) and SIRLP (Low Power) bits.
+//!
+//! \note SIR (IrDA) operation is not supported on Sandstorm-class devices.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTDisableSIR(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Disable SIR and SIRLP (if appropriate).
+    //
+    HWREG(ulBase + UART_O_CTL) &amp;= ~(UART_CTL_SIREN | UART_CTL_SIRLP);
+}
+
+//*****************************************************************************
+//
+//! Enables ISO 7816 smart card mode on the specified UART.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Enables the SMART control bit for ISO 7816 smart card mode on the UART.
+//! This call also sets 8 bit word length and even parity as required by ISO
+//! 7816.
+//!
+//! \note The availability of ISO 7816 smart card mode varies with the
+//! Stellaris part and UART in use.  Please consult the datasheet for the part
+//! you are using to determine whether this support is available.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTSmartCardEnable(unsigned long ulBase)
+{
+    unsigned long ulVal;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
+           (ulBase == UART2_BASE));
+
+    //
+    // Set 8 bit word length, even parity, 2 stop bits (even though the STP2
+    // bit is ignored when in smartcard mode, this lets the caller read back
+    // the actual setting in use).
+    //
+    ulVal = HWREG(ulBase + UART_O_LCRH);
+    ulVal &amp;= ~(UART_LCRH_SPS | UART_LCRH_EPS | UART_LCRH_PEN |
+               UART_LCRH_WLEN_M);
+    ulVal |= UART_LCRH_WLEN_8 | UART_LCRH_PEN | UART_LCRH_EPS | UART_LCRH_STP2;
+    HWREG(ulBase + UART_O_LCRH) = ulVal;
+
+    //
+    // Enable SMART mode.
+    //
+    HWREG(ulBase + UART_O_CTL) |= UART_CTL_SMART;
+}
+
+//*****************************************************************************
+//
+//! Disables ISO 7816 smart card mode on the specified UART.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Clears the SMART (ISO 7816 smart card) bits in the UART control register.
+//!
+//! \note The availability of ISO 7816 smart card mode varies with the
+//! Stellaris part and UART in use.  Please consult the datasheet for the part
+//! you are using to determine whether this support is available.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTSmartCardDisable(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
+           (ulBase == UART2_BASE));
+
+    //
+    // Disable the SMART bit.
+    //
+    HWREG(ulBase + UART_O_CTL) &amp;= ~UART_CTL_SMART;
+}
+
+//*****************************************************************************
+//
+//! Sets the states of the DTR and/or RTS modem control signals.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulControl is a bit-mapped flag indicating which modem control bits
+//! should be set.
+//!
+//! Sets the states of the DTR or RTS modem handshake outputs from the UART.
+//!
+//! The \e ulControl parameter is the logical OR of any of the following:
+//!
+//! - \b UART_OUTPUT_DTR - The Modem Control DTR signal
+//! - \b UART_OUTPUT_RTS - The Modem Control RTS signal
+//!
+//! \note The availability of hardware modem handshake signals varies with the
+//! Stellaris part and UART in use.  Please consult the datasheet for the part
+//! you are using to determine whether this support is available.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTModemControlSet(unsigned long ulBase, unsigned long ulControl)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT(ulBase == UART1_BASE);
+    ASSERT((ulControl &amp; ~(UART_OUTPUT_RTS | UART_OUTPUT_DTR)) == 0);
+
+    //
+    // Set the appropriate modem control output bits.
+    //
+    ulTemp = HWREG(ulBase + UART_O_CTL);
+    ulTemp |= (ulControl &amp; (UART_OUTPUT_RTS | UART_OUTPUT_DTR));
+    HWREG(ulBase + UART_O_CTL) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Clears the states of the DTR and/or RTS modem control signals.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulControl is a bit-mapped flag indicating which modem control bits
+//! should be set.
+//!
+//! Clears the states of the DTR or RTS modem handshake outputs from the UART.
+//!
+//! The \e ulControl parameter is the logical OR of any of the following:
+//!
+//! - \b UART_OUTPUT_DTR - The Modem Control DTR signal
+//! - \b UART_OUTPUT_RTS - The Modem Control RTS signal
+//!
+//! \note The availability of hardware modem handshake signals varies with the
+//! Stellaris part and UART in use.  Please consult the datasheet for the part
+//! you are using to determine whether this support is available.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTModemControlClear(unsigned long ulBase, unsigned long ulControl)
+{
+    unsigned long ulTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT(ulBase == UART1_BASE);
+    ASSERT((ulControl &amp; ~(UART_OUTPUT_RTS | UART_OUTPUT_DTR)) == 0);
+
+    //
+    // Set the appropriate modem control output bits.
+    //
+    ulTemp = HWREG(ulBase + UART_O_CTL);
+    ulTemp &amp;= ~(ulControl &amp; (UART_OUTPUT_RTS | UART_OUTPUT_DTR));
+    HWREG(ulBase + UART_O_CTL) = ulTemp;
+}
+
+//*****************************************************************************
+//
+//! Gets the states of the DTR and RTS modem control signals.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Returns the current states of each of the two UART modem control signals,
+//! DTR and RTS.
+//!
+//! \note The availability of hardware modem handshake signals varies with the
+//! Stellaris part and UART in use.  Please consult the datasheet for the part
+//! you are using to determine whether this support is available.
+//!
+//! \return Returns the states of the handshake output signals.  This will be a
+//! logical logical OR combination of values \b UART_OUTPUT_RTS and
+//! \b UART_OUTPUT_DTR where the presence of each flag indicates that the
+//! associated signal is asserted.
+//
+//*****************************************************************************
+unsigned long
+UARTModemControlGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT(ulBase == UART1_BASE);
+
+    return(HWREG(ulBase + UART_O_CTL) &amp; (UART_OUTPUT_RTS | UART_OUTPUT_DTR));
+}
+
+//*****************************************************************************
+//
+//! Gets the states of the RI, DCD, DSR and CTS modem status signals.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Returns the current states of each of the four UART modem status signals,
+//! RI, DCD, DSR and CTS.
+//!
+//! \note The availability of hardware modem handshake signals varies with the
+//! Stellaris part and UART in use.  Please consult the datasheet for the part
+//! you are using to determine whether this support is available.
+//!
+//! \return Returns the states of the handshake output signals.  This will be a
+//! logical logical OR combination of values \b UART_INPUT_RI, \b
+//! UART_INPUT_DCD, \b UART_INPUT_CTS and \b UART_INPUT_DSR where the
+//! presence of each flag indicates that the associated signal is asserted.
+//
+//*****************************************************************************
+unsigned long
+UARTModemStatusGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT(ulBase == UART1_BASE);
+
+    return(HWREG(ulBase + UART_O_FR) &amp; (UART_INPUT_RI | UART_INPUT_DCD |
+           UART_INPUT_CTS | UART_INPUT_DSR));
+}
+
+//*****************************************************************************
+//
+//! Sets the UART hardware flow control mode to be used.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulMode indicates the flow control modes to be used.  This is a
+//! logical OR combination of values \b UART_FLOWCONTROL_TX and \b
+//! UART_FLOWCONTROL_RX to enable hardware transmit (CTS) and receive (RTS)
+//! flow control or \b UART_FLOWCONTROL_NONE to disable hardware flow control.
+//!
+//! Sets the required hardware flow control modes.  If \e ulMode contains
+//! flag \b UART_FLOWCONTROL_TX, data is only transmitted if the incoming CTS
+//! signal is asserted. If \e ulMode contains flag \b UART_FLOWCONTROL_RX,
+//! the RTS output is controlled by the hardware and is asserted only when
+//! there is space available in the receive FIFO.  If no hardware flow control
+//! is required, UART_FLOWCONTROL_NONE should be passed.
+//!
+//! \note The availability of hardware flow control varies with the Stellaris
+//! part and UART in use.  Please consult the datasheet for the part you are
+//! using to determine whether this support is available.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTFlowControlSet(unsigned long ulBase, unsigned long ulMode)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
+           (ulBase == UART2_BASE));
+    ASSERT((ulMode &amp; ~(UART_FLOWCONTROL_TX | UART_FLOWCONTROL_RX)) == 0);
+
+    //
+    // Set the flow control mode as requested.
+    //
+    HWREG(ulBase + UART_O_CTL) = ((HWREG(ulBase + UART_O_CTL) &amp;
+                                 ~(UART_FLOWCONTROL_TX |
+                                   UART_FLOWCONTROL_RX)) | ulMode);
+}
+
+//*****************************************************************************
+//
+//! Returns the UART hardware flow control mode currently in use.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Returns the current hardware flow control mode.
+//!
+//! \note The availability of hardware flow control varies with the Stellaris
+//! part and UART in use.  Please consult the datasheet for the part you are
+//! using to determine whether this support is available.
+//!
+//! \return Returns the current flow control mode in use.  This is a
+//! logical OR combination of values \b UART_FLOWCONTROL_TX if transmit
+//! (CTS) flow control is enabled and \b UART_FLOWCONTROL_RX if receive (RTS)
+//! flow control is in use.  If hardware flow control is disabled, \b
+//! UART_FLOWCONTROL_NONE will be returned.
+//
+//*****************************************************************************
+unsigned long
+UARTFlowControlGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(!CLASS_IS_SANDSTORM &amp;&amp; !CLASS_IS_FURY &amp;&amp; !CLASS_IS_DUSTDEVIL);
+    ASSERT((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
+           (ulBase == UART2_BASE));
+
+    return(HWREG(ulBase + UART_O_CTL) &amp; (UART_FLOWCONTROL_TX |
+                                         UART_FLOWCONTROL_RX));
+}
+
+//*****************************************************************************
+//
+//! Sets the operating mode for the UART transmit interrupt.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulMode is the operating mode for the transmit interrupt.  It may be
+//! \b UART_TXINT_MODE_EOT to trigger interrupts when the transmitter is idle
+//! or \b UART_TXINT_MODE_FIFO to trigger based on the current transmit FIFO
+//! level.
+//!
+//! This function allows the mode of the UART transmit interrupt to be set.  By
+//! default, the transmit interrupt is asserted when the FIFO level falls past
+//! a threshold set via a call to UARTFIFOLevelSet().  Alternatively, if this
+//! function is called with \e ulMode set to \b UART_TXINT_MODE_EOT, the
+//! transmit interrupt will only be asserted once the transmitter is completely
+//! idle - the transmit FIFO is empty and all bits, including any stop bits,
+//! have cleared the transmitter.
+//!
+//! \note The availability of end-of-transmission mode varies with the
+//! Stellaris part in use.  Please consult the datasheet for the part you are
+//! using to determine whether this support is available.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTTxIntModeSet(unsigned long ulBase, unsigned long ulMode)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
+           (ulBase == UART2_BASE));
+    ASSERT((ulMode == UART_TXINT_MODE_EOT) ||
+           (ulMode == UART_TXINT_MODE_FIFO));
+
+    //
+    // Set or clear the EOT bit of the UART control register as appropriate.
+    //
+    HWREG(ulBase + UART_O_CTL) = ((HWREG(ulBase + UART_O_CTL) &amp;
+                                 ~(UART_TXINT_MODE_EOT |
+                                   UART_TXINT_MODE_FIFO)) | ulMode);
+}
+
+//*****************************************************************************
+//
+//! Returns the current operating mode for the UART transmit interrupt.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function returns the current operating mode for the UART transmit
+//! interrupt.  The return value will be \b UART_TXINT_MODE_EOT if the
+//! transmit interrupt is currently set to be asserted once the transmitter is
+//! completely idle - the transmit FIFO is empty and all bits, including any
+//! stop bits, have cleared the transmitter.  The return value will be \b
+//! UART_TXINT_MODE_FIFO if the interrupt is set to be asserted based upon the
+//! level of the transmit FIFO.
+//!
+//! \note The availability of end-of-transmission mode varies with the
+//! Stellaris part in use.  Please consult the datasheet for the part you are
+//! using to determine whether this support is available.
+//!
+//! \return Returns \b UART_TXINT_MODE_FIFO or \b UART_TXINT_MODE_EOT.
+//
+//*****************************************************************************
+unsigned long
+UARTTxIntModeGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT((ulBase == UART0_BASE) || (ulBase == UART1_BASE) ||
+           (ulBase == UART2_BASE));
+
+    //
+    // Return the current transmit interrupt mode.
+    //
+    return(HWREG(ulBase + UART_O_CTL) &amp; (UART_TXINT_MODE_EOT |
+                                         UART_TXINT_MODE_FIFO));
+}
+
+//*****************************************************************************
+//
+//! Determines if there are any characters in the receive FIFO.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function returns a flag indicating whether or not there is data
+//! available in the receive FIFO.
+//!
+//! \return Returns \b true if there is data in the receive FIFO, and \b false
+//! if there is no data in the receive FIFO.
+//
+//*****************************************************************************
+tBoolean
+UARTCharsAvail(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Return the availability of characters.
+    //
+    return((HWREG(ulBase + UART_O_FR) &amp; UART_FR_RXFE) ? false : true);
+}
+
+//*****************************************************************************
+//
+//! Determines if there is any space in the transmit FIFO.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function returns a flag indicating whether or not there is space
+//! available in the transmit FIFO.
+//!
+//! \return Returns \b true if there is space available in the transmit FIFO,
+//! and \b false if there is no space available in the transmit FIFO.
+//
+//*****************************************************************************
+tBoolean
+UARTSpaceAvail(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Return the availability of space.
+    //
+    return((HWREG(ulBase + UART_O_FR) &amp; UART_FR_TXFF) ? false : true);
+}
+
+//*****************************************************************************
+//
+//! Receives a character from the specified port.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Gets a character from the receive FIFO for the specified port.
+//!
+//! This function replaces the original UARTCharNonBlockingGet() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;uart.h&lt;/tt&gt; to map
+//! the original API to this API.
+//!
+//! \return Returns the character read from the specified port, cast as a
+//! \e long.  A \b -1 will be returned if there are no characters present in
+//! the receive FIFO.  The UARTCharsAvail() function should be called before
+//! attempting to call this function.
+//
+//*****************************************************************************
+long
+UARTCharGetNonBlocking(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // See if there are any characters in the receive FIFO.
+    //
+    if(!(HWREG(ulBase + UART_O_FR) &amp; UART_FR_RXFE))
+    {
+        //
+        // Read and return the next character.
+        //
+        return(HWREG(ulBase + UART_O_DR));
+    }
+    else
+    {
+        //
+        // There are no characters, so return a failure.
+        //
+        return(-1);
+    }
+}
+
+//*****************************************************************************
+//
+//! Waits for a character from the specified port.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Gets a character from the receive FIFO for the specified port.  If there
+//! are no characters available, this function will wait until a character is
+//! received before returning.
+//!
+//! \return Returns the character read from the specified port, cast as an
+//! \e long.
+//
+//*****************************************************************************
+long
+UARTCharGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Wait until a char is available.
+    //
+    while(HWREG(ulBase + UART_O_FR) &amp; UART_FR_RXFE)
+    {
+    }
+
+    //
+    // Now get the char.
+    //
+    return(HWREG(ulBase + UART_O_DR));
+}
+
+//*****************************************************************************
+//
+//! Sends a character to the specified port.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ucData is the character to be transmitted.
+//!
+//! Writes the character \e ucData to the transmit FIFO for the specified port.
+//! This function does not block, so if there is no space available, then a
+//! \b false is returned, and the application will have to retry the function
+//! later.
+//!
+//! This function replaces the original UARTCharNonBlockingPut() API and
+//! performs the same actions.  A macro is provided in &lt;tt&gt;uart.h&lt;/tt&gt; to map
+//! the original API to this API.
+//!
+//! \return Returns \b true if the character was successfully placed in the
+//! transmit FIFO, and \b false if there was no space available in the transmit
+//! FIFO.
+//
+//*****************************************************************************
+tBoolean
+UARTCharPutNonBlocking(unsigned long ulBase, unsigned char ucData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // See if there is space in the transmit FIFO.
+    //
+    if(!(HWREG(ulBase + UART_O_FR) &amp; UART_FR_TXFF))
+    {
+        //
+        // Write this character to the transmit FIFO.
+        //
+        HWREG(ulBase + UART_O_DR) = ucData;
+
+        //
+        // Success.
+        //
+        return(true);
+    }
+    else
+    {
+        //
+        // There is no space in the transmit FIFO, so return a failure.
+        //
+        return(false);
+    }
+}
+
+//*****************************************************************************
+//
+//! Waits to send a character from the specified port.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ucData is the character to be transmitted.
+//!
+//! Sends the character \e ucData to the transmit FIFO for the specified port.
+//! If there is no space available in the transmit FIFO, this function will
+//! wait until there is space available before returning.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTCharPut(unsigned long ulBase, unsigned char ucData)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Wait until space is available.
+    //
+    while(HWREG(ulBase + UART_O_FR) &amp; UART_FR_TXFF)
+    {
+    }
+
+    //
+    // Send the char.
+    //
+    HWREG(ulBase + UART_O_DR) = ucData;
+}
+
+//*****************************************************************************
+//
+//! Causes a BREAK to be sent.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param bBreakState controls the output level.
+//!
+//! Calling this function with \e bBreakState set to \b true will assert a
+//! break condition on the UART.  Calling this function with \e bBreakState set
+//! to \b false will remove the break condition.  For proper transmission of a
+//! break command, the break must be asserted for at least two complete frames.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTBreakCtl(unsigned long ulBase, tBoolean bBreakState)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Set the break condition as requested.
+    //
+    HWREG(ulBase + UART_O_LCRH) =
+        (bBreakState ?
+         (HWREG(ulBase + UART_O_LCRH) | UART_LCRH_BRK) :
+         (HWREG(ulBase + UART_O_LCRH) &amp; ~(UART_LCRH_BRK)));
+}
+
+//*****************************************************************************
+//
+//! Determines whether the UART transmitter is busy or not.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! Allows the caller to determine whether all transmitted bytes have cleared
+//! the transmitter hardware.  If \b false is returned, the transmit FIFO is
+//! empty and all bits of the last transmitted character, including all stop
+//! bits, have left the hardware shift register.
+//!
+//! \return Returns \b true if the UART is transmitting or \b false if all
+//! transmissions are complete.
+//
+//*****************************************************************************
+tBoolean
+UARTBusy(unsigned long ulBase)
+{
+    //
+    // Check the argument.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Determine if the UART is busy.
+    //
+    return((HWREG(ulBase + UART_O_FR) &amp; UART_FR_BUSY) ? true : false);
+}
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for a UART interrupt.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param pfnHandler is a pointer to the function to be called when the
+//! UART interrupt occurs.
+//!
+//! This function does the actual registering of the interrupt handler.  This
+//! will enable the global interrupt in the interrupt controller; specific UART
+//! interrupts must be enabled via UARTIntEnable().  It is the interrupt
+//! handler's responsibility to clear the interrupt source.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTIntRegister(unsigned long ulBase, void (*pfnHandler)(void))
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Determine the interrupt number based on the UART port.
+    //
+    ulInt = ((ulBase == UART0_BASE) ? INT_UART0 :
+             ((ulBase == UART1_BASE) ? INT_UART1 : INT_UART2));
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(ulInt, pfnHandler);
+
+    //
+    // Enable the UART interrupt.
+    //
+    IntEnable(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Unregisters an interrupt handler for a UART interrupt.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function does the actual unregistering of the interrupt handler.  It
+//! will clear the handler to be called when a UART interrupt occurs.  This
+//! will also mask off the interrupt in the interrupt controller so that the
+//! interrupt handler no longer is called.
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTIntUnregister(unsigned long ulBase)
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Determine the interrupt number based on the UART port.
+    //
+    ulInt = ((ulBase == UART0_BASE) ? INT_UART0 :
+             ((ulBase == UART1_BASE) ? INT_UART1 : INT_UART2));
+
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(ulInt);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Enables individual UART interrupt sources.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be enabled.
+//!
+//! Enables the indicated UART interrupt sources.  Only the sources that are
+//! enabled can be reflected to the processor interrupt; disabled sources have
+//! no effect on the processor.
+//!
+//! The \e ulIntFlags parameter is the logical OR of any of the following:
+//!
+//! - \b UART_INT_OE - Overrun Error interrupt
+//! - \b UART_INT_BE - Break Error interrupt
+//! - \b UART_INT_PE - Parity Error interrupt
+//! - \b UART_INT_FE - Framing Error interrupt
+//! - \b UART_INT_RT - Receive Timeout interrupt
+//! - \b UART_INT_TX - Transmit interrupt
+//! - \b UART_INT_RX - Receive interrupt
+//! - \b UART_INT_DSR - DSR interrupt
+//! - \b UART_INT_DCD - DCD interrupt
+//! - \b UART_INT_CTS - CTS interrupt
+//! - \b UART_INT_RI - RI interrupt
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTIntEnable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Enable the specified interrupts.
+    //
+    HWREG(ulBase + UART_O_IM) |= ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Disables individual UART interrupt sources.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulIntFlags is the bit mask of the interrupt sources to be disabled.
+//!
+//! Disables the indicated UART interrupt sources.  Only the sources that are
+//! enabled can be reflected to the processor interrupt; disabled sources have
+//! no effect on the processor.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to UARTIntEnable().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTIntDisable(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Disable the specified interrupts.
+    //
+    HWREG(ulBase + UART_O_IM) &amp;= ~(ulIntFlags);
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param bMasked is false if the raw interrupt status is required and true
+//! if the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the specified UART.  Either the raw
+//! interrupt status or the status of interrupts that are allowed to reflect to
+//! the processor can be returned.
+//!
+//! \return Returns the current interrupt status, enumerated as a bit field of
+//! values described in UARTIntEnable().
+//
+//*****************************************************************************
+unsigned long
+UARTIntStatus(unsigned long ulBase, tBoolean bMasked)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    if(bMasked)
+    {
+        return(HWREG(ulBase + UART_O_MIS));
+    }
+    else
+    {
+        return(HWREG(ulBase + UART_O_RIS));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears UART interrupt sources.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulIntFlags is a bit mask of the interrupt sources to be cleared.
+//!
+//! The specified UART interrupt sources are cleared, so that they no longer
+//! assert.  This must be done in the interrupt handler to keep it from being
+//! called again immediately upon exit.
+//!
+//! The \e ulIntFlags parameter has the same definition as the \e ulIntFlags
+//! parameter to UARTIntEnable().
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTIntClear(unsigned long ulBase, unsigned long ulIntFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Clear the requested interrupt sources.
+    //
+    HWREG(ulBase + UART_O_ICR) = ulIntFlags;
+}
+
+//*****************************************************************************
+//
+//! Enable UART DMA operation.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulDMAFlags is a bit mask of the DMA features to enable.
+//!
+//! The specified UART DMA features are enabled.  The UART can be
+//! configured to use DMA for transmit or receive, and to disable
+//! receive if an error occurs.  The \e ulDMAFlags parameter is the
+//! logical OR of any of the following values:
+//!
+//! - UART_DMA_RX - enable DMA for receive
+//! - UART_DMA_TX - enable DMA for transmit
+//! - UART_DMA_ERR_RXSTOP - disable DMA receive on UART error
+//!
+//! \note The uDMA controller must also be set up before DMA can be used
+//! with the UART.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTDMAEnable(unsigned long ulBase, unsigned long ulDMAFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Set the requested bits in the UART DMA control register.
+    //
+    HWREG(ulBase + UART_O_DMACTL) |= ulDMAFlags;
+}
+
+//*****************************************************************************
+//
+//! Disable UART DMA operation.
+//!
+//! \param ulBase is the base address of the UART port.
+//! \param ulDMAFlags is a bit mask of the DMA features to disable.
+//!
+//! This function is used to disable UART DMA features that were enabled
+//! by UARTDMAEnable().  The specified UART DMA features are disabled.  The
+//! \e ulDMAFlags parameter is the logical OR of any of the following values:
+//!
+//! - UART_DMA_RX - disable DMA for receive
+//! - UART_DMA_TX - disable DMA for transmit
+//! - UART_DMA_ERR_RXSTOP - do not disable DMA receive on UART error
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTDMADisable(unsigned long ulBase, unsigned long ulDMAFlags)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Clear the requested bits in the UART DMA control register.
+    //
+    HWREG(ulBase + UART_O_DMACTL) &amp;= ~ulDMAFlags;
+}
+
+//*****************************************************************************
+//
+//! Gets current receiver errors.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function returns the current state of each of the 4 receiver error
+//! sources.  The returned errors are equivalent to the four error bits
+//! returned via the previous call to UARTCharGet() or UARTCharGetNonBlocking()
+//! with the exception that the overrun error is set immediately the overrun
+//! occurs rather than when a character is next read.
+//!
+//! \return Returns a logical OR combination of the receiver error flags,
+//! \b UART_RXERROR_FRAMING, \b UART_RXERROR_PARITY, \b UART_RXERROR_BREAK
+//! and \b UART_RXERROR_OVERRUN.
+//
+//*****************************************************************************
+unsigned long
+UARTRxErrorGet(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Return the current value of the receive status register.
+    //
+    return(HWREG(ulBase + UART_O_RSR) &amp; 0x0000000F);
+}
+
+//*****************************************************************************
+//
+//! Clears all reported receiver errors.
+//!
+//! \param ulBase is the base address of the UART port.
+//!
+//! This function is used to clear all receiver error conditions reported via
+//! UARTRxErrorGet().  If using the overrun, framing error, parity error or
+//! break interrupts, this function must be called after clearing the interrupt
+//! to ensure that later errors of the same type trigger another interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTRxErrorClear(unsigned long ulBase)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(UARTBaseValid(ulBase));
+
+    //
+    // Any write to the Error Clear Register will clear all bits which are
+    // currently set.
+    //
+    HWREG(ulBase + UART_O_ECR) = 0;
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************


Property changes on: trunk/src/platform/lm3s/uart.c
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/src/platform/lm3s/uart.h
===================================================================
--- trunk/src/platform/lm3s/uart.h	2009-07-31 14:24:52 UTC (rev 379)
+++ trunk/src/platform/lm3s/uart.h	2009-08-03 18:37:38 UTC (rev 380)
@@ -0,0 +1,246 @@
+//*****************************************************************************
+//
+// uart.h - Defines and Macros for the UART.
+//
+// Copyright (c) 2005-2009 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 4781 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __UART_H__
+#define __UART_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTIntEnable, UARTIntDisable, and UARTIntClear
+// as the ulIntFlags parameter, and returned from UARTIntStatus.
+//
+//*****************************************************************************
+#define UART_INT_OE             0x400       // Overrun Error Interrupt Mask
+#define UART_INT_BE             0x200       // Break Error Interrupt Mask
+#define UART_INT_PE             0x100       // Parity Error Interrupt Mask
+#define UART_INT_FE             0x080       // Framing Error Interrupt Mask
+#define UART_INT_RT             0x040       // Receive Timeout Interrupt Mask
+#define UART_INT_TX             0x020       // Transmit Interrupt Mask
+#define UART_INT_RX             0x010       // Receive Interrupt Mask
+#define UART_INT_DSR            0x008       // DSR Modem Interrupt Mask
+#define UART_INT_DCD            0x004       // DCD Modem Interrupt Mask
+#define UART_INT_CTS            0x002       // CTS Modem Interrupt Mask
+#define UART_INT_RI             0x001       // RI Modem Interrupt Mask
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTConfigSetExpClk as the ulConfig parameter
+// and returned by UARTConfigGetExpClk in the pulConfig parameter.
+// Additionally, the UART_CONFIG_PAR_* subset can be passed to
+// UARTParityModeSet as the ulParity parameter, and are returned by
+// UARTParityModeGet.
+//
+//*****************************************************************************
+#define UART_CONFIG_WLEN_MASK   0x00000060  // Mask for extracting word length
+#define UART_CONFIG_WLEN_8      0x00000060  // 8 bit data
+#define UART_CONFIG_WLEN_7      0x00000040  // 7 bit data
+#define UART_CONFIG_WLEN_6      0x00000020  // 6 bit data
+#define UART_CONFIG_WLEN_5      0x00000000  // 5 bit data
+#define UART_CONFIG_STOP_MASK   0x00000008  // Mask for extracting stop bits
+#define UART_CONFIG_STOP_ONE    0x00000000  // One stop bit
+#define UART_CONFIG_STOP_TWO    0x00000008  // Two stop bits
+#define UART_CONFIG_PAR_MASK    0x00000086  // Mask for extracting parity
+#define UART_CONFIG_PAR_NONE    0x00000000  // No parity
+#define UART_CONFIG_PAR_EVEN    0x00000006  // Even parity
+#define UART_CONFIG_PAR_ODD     0x00000002  // Odd parity
+#define UART_CONFIG_PAR_ONE     0x00000082  // Parity bit is one
+#define UART_CONFIG_PAR_ZERO    0x00000086  // Parity bit is zero
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTFIFOLevelSet as the ulTxLevel parameter and
+// returned by UARTFIFOLevelGet in the pulTxLevel.
+//
+//*****************************************************************************
+#define UART_FIFO_TX1_8         0x00000000  // Transmit interrupt at 1/8 Full
+#define UART_FIFO_TX2_8         0x00000001  // Transmit interrupt at 1/4 Full
+#define UART_FIFO_TX4_8         0x00000002  // Transmit interrupt at 1/2 Full
+#define UART_FIFO_TX6_8         0x00000003  // Transmit interrupt at 3/4 Full
+#define UART_FIFO_TX7_8         0x00000004  // Transmit interrupt at 7/8 Full
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTFIFOLevelSet as the ulRxLevel parameter and
+// returned by UARTFIFOLevelGet in the pulRxLevel.
+//
+//*****************************************************************************
+#define UART_FIFO_RX1_8         0x00000000  // Receive interrupt at 1/8 Full
+#define UART_FIFO_RX2_8         0x00000008  // Receive interrupt at 1/4 Full
+#define UART_FIFO_RX4_8         0x00000010  // Receive interrupt at 1/2 Full
+#define UART_FIFO_RX6_8         0x00000018  // Receive interrupt at 3/4 Full
+#define UART_FIFO_RX7_8         0x00000020  // Receive interrupt at 7/8 Full
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTDMAEnable() and UARTDMADisable().
+//
+//*****************************************************************************
+#define UART_DMA_ERR_RXSTOP     0x00000004  // Stop DMA receive if UART error
+#define UART_DMA_TX             0x00000002  // Enable DMA for transmit
+#define UART_DMA_RX             0x00000001  // Enable DMA for receive
+
+//*****************************************************************************
+//
+// Values returned from UARTRxErrorGet().
+//
+//*****************************************************************************
+#define UART_RXERROR_OVERRUN    0x00000008
+#define UART_RXERROR_BREAK      0x00000004
+#define UART_RXERROR_PARITY     0x00000002
+#define UART_RXERROR_FRAMING    0x00000001
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTHandshakeOutputsSet() or returned from
+// UARTHandshakeOutputGet().
+//
+//*****************************************************************************
+#define UART_OUTPUT_RTS         0x00000800
+#define UART_OUTPUT_DTR         0x00000400
+
+//*****************************************************************************
+//
+// Values that can be returned from UARTHandshakeInputsGet().
+//
+//*****************************************************************************
+#define UART_INPUT_RI           0x00000100
+#define UART_INPUT_DCD          0x00000004
+#define UART_INPUT_DSR          0x00000002
+#define UART_INPUT_CTS          0x00000001
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTFlowControl() or returned from
+// UARTFlowControlGet().
+//
+//*****************************************************************************
+#define UART_FLOWCONTROL_TX     0x00008000
+#define UART_FLOWCONTROL_RX     0x00004000
+#define UART_FLOWCONTROL_NONE   0x00000000
+
+//*****************************************************************************
+//
+// Values that can be passed to UARTTxIntModeSet() or returned from
+// UARTTxIntModeGet().
+//
+//*****************************************************************************
+#define UART_TXINT_MODE_FIFO    0x00000000
+#define UART_TXINT_MODE_EOT     0x00000010
+
+//*****************************************************************************
+//
+// API Function prototypes
+//
+//*****************************************************************************
+extern void UARTParityModeSet(unsigned long ulBase, unsigned long ulParity);
+extern unsigned long UARTParityModeGet(unsigned long ulBase);
+extern void UARTFIFOLevelSet(unsigned long ulBase, unsigned long ulTxLevel,
+                             unsigned long ulRxLevel);
+extern void UARTFIFOLevelGet(unsigned long ulBase, unsigned long *pulTxLevel,
+                             unsigned long *pulRxLevel);
+extern void UARTConfigSetExpClk(unsigned long ulBase, unsigned long ulUARTClk,
+                                unsigned long ulBaud, unsigned long ulConfig);
+extern void UARTConfigGetExpClk(unsigned long ulBase, unsigned long ulUARTClk,
+                                unsigned long *pulBaud,
+                                unsigned long *pulConfig);
+extern void UARTEnable(unsigned long ulBase);
+extern void UARTDisable(unsigned long ulBase);
+extern void UARTFIFOEnable(unsigned long ulBase);
+extern void UARTFIFODisable(unsigned long ulBase);
+extern void UARTEnableSIR(unsigned long ulBase, tBoolean bLowPower);
+extern void UARTDisableSIR(unsigned long ulBase);
+extern tBoolean UARTCharsAvail(unsigned long ulBase);
+extern tBoolean UARTSpaceAvail(unsigned long ulBase);
+extern long UARTCharGetNonBlocking(unsigned long ulBase);
+extern long UARTCharGet(unsigned long ulBase);
+extern tBoolean UARTCharPutNonBlocking(unsigned long ulBase,
+                                       unsigned char ucData);
+extern void UARTCharPut(unsigned long ulBase, unsigned char ucData);
+extern void UARTBreakCtl(unsigned long ulBase, tBoolean bBreakState);
+extern tBoolean UARTBusy(unsigned long ulBase);
+extern void UARTIntRegister(unsigned long ulBase, void(*pfnHandler)(void));
+extern void UARTIntUnregister(unsigned long ulBase);
+extern void UARTIntEnable(unsigned long ulBase, unsigned long ulIntFlags);
+extern void UARTIntDisable(unsigned long ulBase, unsigned long ulIntFlags);
+extern unsigned long UARTIntStatus(unsigned long ulBase, tBoolean bMasked);
+extern void UARTIntClear(unsigned long ulBase, unsigned long ulIntFlags);
+extern void UARTDMAEnable(unsigned long ulBase, unsigned long ulDMAFlags);
+extern void UARTDMADisable(unsigned long ulBase, unsigned long ulDMAFlags);
+extern unsigned long UARTRxErrorGet(unsigned long ulBase);
+extern void UARTRxErrorClear(unsigned long ulBase);
+extern void UARTSmartCardEnable(unsigned long ulBase);
+extern void UARTSmartCardDisable(unsigned long ulBase);
+extern void UARTModemControlSet(unsigned long ulBase,
+                                unsigned long ulControl);
+extern void UARTModemControlClear(unsigned long ulBase,
+                                  unsigned long ulControl);
+extern unsigned long UARTModemControlGet(unsigned long ulBase);
+extern unsigned long UARTModemStatusGet(unsigned long ulBase);
+extern void UARTFlowControlSet(unsigned long ulBase, unsigned long ulMode);
+extern unsigned long UARTFlowControlGet(unsigned long ulBase);
+extern void UARTTxIntModeSet(unsigned long ulBase, unsigned long ulMode);
+extern unsigned long UARTTxIntModeGet(unsigned long ulBase);
+
+//*****************************************************************************
+//
+// Several UART APIs have been renamed, with the original function name being
+// deprecated.  These defines provide backward compatibility.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+#include &quot;sysctl.h&quot;
+#define UARTConfigSet(a, b, c)                         \
+        UARTConfigSetExpClk(a, SysCtlClockGet(), b, c)
+#define UARTConfigGet(a, b, c)                         \
+        UARTConfigGetExpClk(a, SysCtlClockGet(), b, c)
+#define UARTCharNonBlockingGet(a) \
+        UARTCharGetNonBlocking(a)
+#define UARTCharNonBlockingPut(a, b) \
+        UARTCharPutNonBlocking(a, b)
+#endif
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif //  __UART_H__


Property changes on: trunk/src/platform/lm3s/uart.h
___________________________________________________________________
Name: svn:executable
   + *


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000336.html">[Elua-svn] r381 - trunk/src/platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#342">[ date ]</a>
              <a href="thread.html#342">[ thread ]</a>
              <a href="subject.html#342">[ subject ]</a>
              <a href="author.html#342">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
