<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r284 - in trunk: . src src/platform src/platform/sim
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r284%20-%20in%20trunk%3A%20.%20src%20src/platform%20src/platform/sim&In-Reply-To=%3C200905121409.n4CE9Ure019849%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000239.html">
   <LINK REL="Next"  HREF="000241.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r284 - in trunk: . src src/platform src/platform/sim</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r284%20-%20in%20trunk%3A%20.%20src%20src/platform%20src/platform/sim&In-Reply-To=%3C200905121409.n4CE9Ure019849%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r284 - in trunk: . src src/platform src/platform/sim">bogdanm at mail.berlios.de
       </A><BR>
    <I>Tue May 12 16:09:30 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000239.html">[Elua-svn] r283 - in trunk: . src/platform src/platform/linux
</A></li>
        <LI>Next message: <A HREF="000241.html">[Elua-svn] r285 - in tags/pre0.6/doc: . arch_platform en wb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#240">[ date ]</a>
              <a href="thread.html#240">[ thread ]</a>
              <a href="subject.html#240">[ subject ]</a>
              <a href="author.html#240">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2009-05-12 16:09:29 +0200 (Tue, 12 May 2009)
New Revision: 284

Added:
   trunk/run_elua_sim.sh
   trunk/src/platform/sim/
   trunk/src/platform/sim/hostif.h
   trunk/src/platform/sim/hostif_linux.c
Removed:
   trunk/src/platform/linux/
   trunk/src/platform/sim/common.c
   trunk/src/platform/sim/common.h
   trunk/src/platform/sim/descriptor_tables.c
   trunk/src/platform/sim/descriptor_tables.h
   trunk/src/platform/sim/isr.c
   trunk/src/platform/sim/isr.h
   trunk/src/platform/sim/kb.c
   trunk/src/platform/sim/kb.h
   trunk/src/platform/sim/monitor.c
   trunk/src/platform/sim/monitor.h
   trunk/src/platform/sim/multiboot.h
   trunk/src/platform/sim/timer.c
   trunk/src/platform/sim/timer.h
Modified:
   trunk/SConstruct
   trunk/src/main.c
   trunk/src/platform/sim/boot.s
   trunk/src/platform/sim/conf.py
   trunk/src/platform/sim/host.c
   trunk/src/platform/sim/host.h
   trunk/src/platform/sim/platform.c
Log:
Modified Robert's 'linux' platform:

- code cleanup
- the platform is now named 'sim'. You build it like this:

  $ scons cpu=linux

  The idea is to support more than one host OS by changing the &quot;cpu&quot; variable
  above (for example cpu=osx, or cpu=win32). Also, a crude &quot;host interface&quot; was
  defined in hostif.h. In theory, a host OS should only implement that interface
  in order to run the eLua simulator. The implementation must reside in a file
  called hostif_{os}.c (in this case hostif_linux.c). Too bad I don't have a MAC,
  I would've loved to try this :)
  REMEMBER: whem implementing a host interface, you CAN NOT rely on your regular
  libc! You'll have to rewrite the syscalls (see host.c for an example on how to
  do this in Linux).

- after you build it, don't start it directly, use the new &quot;run_elua_sim.sh&quot;
  script to run it. It will set the terminal to raw mode, no echo, so it will
  behave more like &quot;traditional&quot; eLua (even hangman.lua will run in this mode :) ).
  Remember to run in on an ANSI capable terminal (although most of them support
  ANSI emulation nowadays). 

- you can exit from the simulator with &quot;exit&quot;. You can't do this with CTRL+C if
  you run it with &quot;run_elua_sim.sh&quot;. 

All in all, this looks pretty good and it's an excellent test platform. It will
do wonders when we integrate our own libc and we won't be able to figure out why
it doesn't work :)



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/SConstruct	2009-05-12 14:09:29 UTC (rev 284)
@@ -57,7 +57,7 @@
   'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'str9' : { 'cpus' : [ 'STR912FAW44' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'i386' : { 'cpus' : [ 'I386' ], 'toolchains' : [ 'i686-gcc' ] },
-  'linux' : { 'cpus' : [ 'LINUX' ], 'toolchains' : [ 'i686-gcc' ] },
+  'sim' : { 'cpus' : [ 'LINUX' ], 'toolchains' : [ 'i686-gcc' ] },
   'lpc288x' : { 'cpus' : [ 'LPC2888' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'str7' : { 'cpus' : [ 'STR711FR2' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'stm32' : { 'cpus' : [ 'STM32F103ZE', 'STM32F103RE' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
@@ -70,7 +70,7 @@
                'EK-LM3S6965' : [ 'LM3S6965' ],
                'STR9-COMSTICK' : [ 'STR912FAW44' ],
                'PC' : [ 'I386' ],
-               'LINUX' : [ 'LINUX' ],
+               'SIM' : [ 'LINUX' ],
                'LPC-H2888' : [ 'LPC2888' ],
                'MOD711' : [ 'STR711FR2' ],
                'STM3210E-EVAL' : [ 'STM32F103ZE' ],
@@ -106,7 +106,7 @@
               'EK-LM3S6965' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope','adcpoll' ],
               'STR9-COMSTICK' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
               'PC' : [ 'bisect', 'hello', 'info', 'life', 'hangman' ],
-              'LINUX' : [ 'bisect', 'hello', 'info', 'life', 'hangman' ],
+              'SIM' : [ 'bisect', 'hello', 'info', 'life', 'hangman' ],
               'LPC-H2888' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
               'MOD711' : [ 'bisect', 'hangman', 'led', 'hello', 'info', 'dualpwm' ],
               'STM3210E-EVAL' : [ 'bisect', 'hello', 'info' ],
@@ -206,6 +206,10 @@
 elif allocator == 'simple':
   cdefs = cdefs + &quot; -DUSE_SIMPLE_ALLOCATOR&quot;
 
+# Special macro definitions for the SYM target
+if platform == 'sim':
+  cdefs = cdefs + &quot; -DELUA_SIMULATOR -DELUA_SIM_%s&quot; % cputype
+
 # Lua source files and include path
 lua_files = &quot;&quot;&quot;lapi.c lcode.c ldebug.c ldo.c ldump.c lfunc.c lgc.c llex.c lmem.c lobject.c lopcodes.c
    lparser.c lstate.c lstring.c ltable.c ltm.c lundump.c lvm.c lzio.c lauxlib.c lbaselib.c

Added: trunk/run_elua_sim.sh
===================================================================
--- trunk/run_elua_sim.sh	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/run_elua_sim.sh	2009-05-12 14:09:29 UTC (rev 284)
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+stty -echo raw -igncr
+./elua_lua_linux.elf
+stty echo cooked


Property changes on: trunk/run_elua_sim.sh
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/src/main.c
===================================================================
--- trunk/src/main.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/main.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -11,6 +11,9 @@
 #include &quot;lua.h&quot;
 #include &quot;term.h&quot;
 #include &quot;platform_conf.h&quot;
+#ifdef ELUA_SIMULATOR
+#include &quot;hostif.h&quot;
+#endif
 
 // Validate eLua configuratin options
 #include &quot;validate.h&quot;
@@ -56,5 +59,11 @@
   else
     shell_start();
 
+#ifdef ELUA_SIMULATOR
+  hostif_exit(0);
+  return 0;
+#else
   while( 1 );
+#endif
 }
+

Copied: trunk/src/platform/sim (from rev 283, trunk/src/platform/linux)


Property changes on: trunk/src/platform/sim
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/src/platform/sim/boot.s
===================================================================
--- trunk/src/platform/linux/boot.s	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/boot.s	2009-05-12 14:09:29 UTC (rev 284)
@@ -5,11 +5,6 @@
 
 [BITS 32]                       ; All instructions should be 32-bit.
 
-[EXTERN code]                   ; Start of the '.text' section.
-[EXTERN bss]                    ; Start of the .bss section.
-[EXTERN end]                    ; End of the last loadable section.
-[SECTION .header]
-
 [GLOBAL start]                  ; Kernel entry point.
 [EXTERN main]                   ; This is the entry point of our C code
 [EXTERN platform_ll_init]       ; Low level initializatin function

Deleted: trunk/src/platform/sim/common.c
===================================================================
--- trunk/src/platform/linux/common.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/common.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,33 +0,0 @@
-// common.c -- Defines some global functions.
-//             From JamesM's kernel development tutorials.
-
-#include &quot;common.h&quot;
-
-// Write a byte out to the specified port.
-void outb(u16int port, u8int value)
-{
-#if 0
-    asm volatile (&quot;outb %1, %0&quot; : : &quot;dN&quot; (port), &quot;a&quot; (value));
-#endif
-}
-
-u8int inb(u16int port)
-{
-#if 0
-    u8int ret;
-    asm volatile(&quot;inb %1, %0&quot; : &quot;=a&quot; (ret) : &quot;dN&quot; (port));
-    return ret;
-#endif
-	return 0;
-}
-
-u16int inw(u16int port)
-{
-#if 0
-    u16int ret;
-    asm volatile (&quot;inw %1, %0&quot; : &quot;=a&quot; (ret) : &quot;dN&quot; (port));
-    return ret;
-#endif
-	return 0;
-}
-

Deleted: trunk/src/platform/sim/common.h
===================================================================
--- trunk/src/platform/linux/common.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/common.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,22 +0,0 @@
-// common.h -- Defines typedefs and some global functions.
-//             From JamesM's kernel development tutorials.
-
-#ifndef COMMON_H
-#define COMMON_H
-
-#include &quot;multiboot.h&quot;
-
-// Some nice typedefs, to standardise sizes across platforms.
-// These typedefs are written for 32-bit X86.
-typedef unsigned int   u32int;
-typedef          int   s32int;
-typedef unsigned short u16int;
-typedef          short s16int;
-typedef unsigned char  u8int;
-typedef          char  s8int;
-
-void outb(u16int port, u8int value);
-u8int inb(u16int port);
-u16int inw(u16int port);
-
-#endif // COMMON_H

Modified: trunk/src/platform/sim/conf.py
===================================================================
--- trunk/src/platform/linux/conf.py	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/conf.py	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,6 +1,6 @@
-# Configuration file for the i386 backend
+# Configuration file for the linux backend
 
-specific_files = &quot;boot.s utils.s common.c descriptor_tables.c isr.c kb.c monitor.c timer.c platform.c host.c&quot;
+specific_files = &quot;boot.s utils.s hostif_%s.c platform.c host.c&quot; % cputype.lower()
 ldscript = &quot;i386.ld&quot;
   
 # override default optimize settings (-Os is broken right now)
@@ -11,15 +11,14 @@
 ldscript = &quot;src/platform/%s/%s&quot; % ( platform, ldscript )
 
 # Toolset data
-tools[ 'linux' ] = {}
-tools[ 'linux' ][ 'cccom' ] = &quot;%s %s $_CPPINCFLAGS -march=i386 -mfpmath=387 -m32 -ffunction-sections -fdata-sections -fno-builtin -fno-stack-protector %s -Wall -c $SOURCE -o $TARGET&quot; % ( toolset[ 'compile' ], opt, cdefs )
-tools[ 'linux' ][ 'linkcom' ] = &quot;%s -nostartfiles -nostdlib -march=i386 -mfpmath=387 -m32 -T %s -Wl,--gc-sections -Wl,-e,start -Wl,--allow-multiple-definition -o $TARGET $SOURCES -lc -lgcc -lm %s&quot; % ( toolset[ 'compile' ], ldscript, local_libs )
-tools[ 'linux' ][ 'ascom' ] = &quot;%s -felf $SOURCE&quot; % toolset[ 'asm' ]
+tools[ 'sim' ] = {}
+tools[ 'sim' ][ 'cccom' ] = &quot;%s %s $_CPPINCFLAGS -march=i386 -mfpmath=387 -m32 -ffunction-sections -fdata-sections -fno-builtin -fno-stack-protector %s -Wall -c $SOURCE -o $TARGET&quot; % ( toolset[ 'compile' ], opt, cdefs )
+tools[ 'sim' ][ 'linkcom' ] = &quot;%s -nostartfiles -nostdlib -march=i386 -mfpmath=387 -m32 -T %s -Wl,--gc-sections -Wl,-e,start -Wl,--allow-multiple-definition -Wl,-static -o $TARGET $SOURCES -lc -lgcc -lm %s&quot; % ( toolset[ 'compile' ], ldscript, local_libs )
+tools[ 'sim' ][ 'ascom' ] = &quot;%s -felf $SOURCE&quot; % toolset[ 'asm' ]
 
 # Programming function for i386 (not needed, empty function)
-def progfunc_i386( target, source, env ):
-  outname = output + &quot;.elf&quot;
-  os.system( &quot;%s %s&quot; % ( toolset[ 'size' ], outname ) )
-  print &quot;Visit <A HREF="http://www.eluaproject.net">http://www.eluaproject.net</A> for instructions on how to use your eLua ELF file&quot;
+def progfunc_dummy( target, source, env ):
+  print &quot;Run the simulator and enjoy :)&quot;
   
-tools[ 'linux' ][ 'progfunc' ] = progfunc_i386
+tools[ 'sim' ][ 'progfunc' ] = progfunc_dummy
+

Deleted: trunk/src/platform/sim/descriptor_tables.c
===================================================================
--- trunk/src/platform/linux/descriptor_tables.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/descriptor_tables.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,158 +0,0 @@
-//
-// descriptor_tables.c - Initialises the GDT and IDT, and defines the 
-//                       default ISR and IRQ handler.
-//                       Based on code from Bran's kernel development tutorials.
-//                       Rewritten for JamesM's kernel development tutorials.
-//
-
-#include &quot;common.h&quot;
-#include &quot;descriptor_tables.h&quot;
-#include &quot;isr.h&quot;
-#include &lt;string.h&gt;
-
-#if 0
-// Lets us access our ASM functions from our C code.
-extern void gdt_flush(u32int);
-extern void idt_flush(u32int);
-
-// Internal function prototypes.
-static void init_gdt();
-static void init_idt();
-static void gdt_set_gate(s32int,u32int,u32int,u8int,u8int);
-static void idt_set_gate(u8int,u32int,u16int,u8int);
-
-gdt_entry_t gdt_entries[5];
-gdt_ptr_t   gdt_ptr;
-idt_entry_t idt_entries[256];
-idt_ptr_t   idt_ptr;
-
-// Extern the ISR handler array so we can nullify them on startup.
-extern isr_t interrupt_handlers[];
-#endif
-
-// Initialisation routine - zeroes all the interrupt service routines,
-// initialises the GDT and IDT.
-void init_descriptor_tables()
-{
-#if 0
-    // Initialise the global descriptor table.
-    init_gdt();
-    // Initialise the interrupt descriptor table.
-    init_idt();
-    // Nullify all the interrupt handlers.
-    memset(&amp;interrupt_handlers, 0, sizeof(isr_t)*256);
-#endif
-}
-
-#if 0
-static void init_gdt()
-{
-    gdt_ptr.limit = (sizeof(gdt_entry_t) * 5) - 1;
-    gdt_ptr.base  = (u32int)&amp;gdt_entries;
-
-    gdt_set_gate(0, 0, 0, 0, 0);                // Null segment
-    gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF); // Code segment
-    gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF); // Data segment
-    gdt_set_gate(3, 0, 0xFFFFFFFF, 0xFA, 0xCF); // User mode code segment
-    gdt_set_gate(4, 0, 0xFFFFFFFF, 0xF2, 0xCF); // User mode data segment
-
-    gdt_flush((u32int)&amp;gdt_ptr);
-}
-
-// Set the value of one GDT entry.
-static void gdt_set_gate(s32int num, u32int base, u32int limit, u8int access, u8int gran)
-{
-    gdt_entries[num].base_low    = (base &amp; 0xFFFF);
-    gdt_entries[num].base_middle = (base &gt;&gt; 16) &amp; 0xFF;
-    gdt_entries[num].base_high   = (base &gt;&gt; 24) &amp; 0xFF;
-
-    gdt_entries[num].limit_low   = (limit &amp; 0xFFFF);
-    gdt_entries[num].granularity = (limit &gt;&gt; 16) &amp; 0x0F;
-    
-    gdt_entries[num].granularity |= gran &amp; 0xF0;
-    gdt_entries[num].access      = access;
-}
-
-static void init_idt()
-{
-    idt_ptr.limit = sizeof(idt_entry_t) * 256 -1;
-    idt_ptr.base  = (u32int)&amp;idt_entries;
-
-    memset(&amp;idt_entries, 0, sizeof(idt_entry_t)*256);
-
-    // Remap the irq table.
-    outb(0x20, 0x11);
-    outb(0xA0, 0x11);
-    outb(0x21, 0x20);
-    outb(0xA1, 0x28);
-    outb(0x21, 0x04);
-    outb(0xA1, 0x02);
-    outb(0x21, 0x01);
-    outb(0xA1, 0x01);
-    outb(0x21, 0x0);
-    outb(0xA1, 0x0);
-
-    idt_set_gate( 0, (u32int)isr0 , 0x08, 0x8E);
-    idt_set_gate( 1, (u32int)isr1 , 0x08, 0x8E);
-    idt_set_gate( 2, (u32int)isr2 , 0x08, 0x8E);
-    idt_set_gate( 3, (u32int)isr3 , 0x08, 0x8E);
-    idt_set_gate( 4, (u32int)isr4 , 0x08, 0x8E);
-    idt_set_gate( 5, (u32int)isr5 , 0x08, 0x8E);
-    idt_set_gate( 6, (u32int)isr6 , 0x08, 0x8E);
-    idt_set_gate( 7, (u32int)isr7 , 0x08, 0x8E);
-    idt_set_gate( 8, (u32int)isr8 , 0x08, 0x8E);
-    idt_set_gate( 9, (u32int)isr9 , 0x08, 0x8E);
-    idt_set_gate(10, (u32int)isr10, 0x08, 0x8E);
-    idt_set_gate(11, (u32int)isr11, 0x08, 0x8E);
-    idt_set_gate(12, (u32int)isr12, 0x08, 0x8E);
-    idt_set_gate(13, (u32int)isr13, 0x08, 0x8E);
-    idt_set_gate(14, (u32int)isr14, 0x08, 0x8E);
-    idt_set_gate(15, (u32int)isr15, 0x08, 0x8E);
-    idt_set_gate(16, (u32int)isr16, 0x08, 0x8E);
-    idt_set_gate(17, (u32int)isr17, 0x08, 0x8E);
-    idt_set_gate(18, (u32int)isr18, 0x08, 0x8E);
-    idt_set_gate(19, (u32int)isr19, 0x08, 0x8E);
-    idt_set_gate(20, (u32int)isr20, 0x08, 0x8E);
-    idt_set_gate(21, (u32int)isr21, 0x08, 0x8E);
-    idt_set_gate(22, (u32int)isr22, 0x08, 0x8E);
-    idt_set_gate(23, (u32int)isr23, 0x08, 0x8E);
-    idt_set_gate(24, (u32int)isr24, 0x08, 0x8E);
-    idt_set_gate(25, (u32int)isr25, 0x08, 0x8E);
-    idt_set_gate(26, (u32int)isr26, 0x08, 0x8E);
-    idt_set_gate(27, (u32int)isr27, 0x08, 0x8E);
-    idt_set_gate(28, (u32int)isr28, 0x08, 0x8E);
-    idt_set_gate(29, (u32int)isr29, 0x08, 0x8E);
-    idt_set_gate(30, (u32int)isr30, 0x08, 0x8E);
-    idt_set_gate(31, (u32int)isr31, 0x08, 0x8E);
-    idt_set_gate(32, (u32int)irq0, 0x08, 0x8E);
-    idt_set_gate(33, (u32int)irq1, 0x08, 0x8E);
-    idt_set_gate(34, (u32int)irq2, 0x08, 0x8E);
-    idt_set_gate(35, (u32int)irq3, 0x08, 0x8E);
-    idt_set_gate(36, (u32int)irq4, 0x08, 0x8E);
-    idt_set_gate(37, (u32int)irq5, 0x08, 0x8E);
-    idt_set_gate(38, (u32int)irq6, 0x08, 0x8E);
-    idt_set_gate(39, (u32int)irq7, 0x08, 0x8E);
-    idt_set_gate(40, (u32int)irq8, 0x08, 0x8E);
-    idt_set_gate(41, (u32int)irq9, 0x08, 0x8E);
-    idt_set_gate(42, (u32int)irq10, 0x08, 0x8E);
-    idt_set_gate(43, (u32int)irq11, 0x08, 0x8E);
-    idt_set_gate(44, (u32int)irq12, 0x08, 0x8E);
-    idt_set_gate(45, (u32int)irq13, 0x08, 0x8E);
-    idt_set_gate(46, (u32int)irq14, 0x08, 0x8E);
-    idt_set_gate(47, (u32int)irq15, 0x08, 0x8E);
-
-    idt_flush((u32int)&amp;idt_ptr);
-}
-
-static void idt_set_gate(u8int num, u32int base, u16int sel, u8int flags)
-{
-    idt_entries[num].base_lo = base &amp; 0xFFFF;
-    idt_entries[num].base_hi = (base &gt;&gt; 16) &amp; 0xFFFF;
-
-    idt_entries[num].sel     = sel;
-    idt_entries[num].always0 = 0;
-    // We must uncomment the OR below when we get to using user-mode.
-    // It sets the interrupt gate's privilege level to 3.
-    idt_entries[num].flags   = flags /* | 0x60 */;
-}
-#endif

Deleted: trunk/src/platform/sim/descriptor_tables.h
===================================================================
--- trunk/src/platform/linux/descriptor_tables.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/descriptor_tables.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,113 +0,0 @@
-// 
-// descriptor_tables.h - Defines the interface for initialising the GDT and IDT.
-//                       Also defines needed structures.
-//                       Based on code from Bran's kernel development tutorials.
-//                       Rewritten for JamesM's kernel development tutorials.
-//
-
-#include &quot;common.h&quot;
-
-// Initialisation function is publicly accessible.
-void init_descriptor_tables();
-
-#if 0
-// This structure contains the value of one GDT entry.
-// We use the attribute 'packed' to tell GCC not to change
-// any of the alignment in the structure.
-struct gdt_entry_struct
-{
-    u16int limit_low;           // The lower 16 bits of the limit.
-    u16int base_low;            // The lower 16 bits of the base.
-    u8int  base_middle;         // The next 8 bits of the base.
-    u8int  access;              // Access flags, determine what ring this segment can be used in.
-    u8int  granularity;
-    u8int  base_high;           // The last 8 bits of the base.
-} __attribute__((packed));
-
-typedef struct gdt_entry_struct gdt_entry_t;
-
-// This struct describes a GDT pointer. It points to the start of
-// our array of GDT entries, and is in the format required by the
-// lgdt instruction.
-struct gdt_ptr_struct
-{
-    u16int limit;               // The upper 16 bits of all selector limits.
-    u32int base;                // The address of the first gdt_entry_t struct.
-} __attribute__((packed));
-
-typedef struct gdt_ptr_struct gdt_ptr_t;
-
-// A struct describing an interrupt gate.
-struct idt_entry_struct
-{
-    u16int base_lo;             // The lower 16 bits of the address to jump to when this interrupt fires.
-    u16int sel;                 // Kernel segment selector.
-    u8int  always0;             // This must always be zero.
-    u8int  flags;               // More flags. See documentation.
-    u16int base_hi;             // The upper 16 bits of the address to jump to.
-} __attribute__((packed));
-
-typedef struct idt_entry_struct idt_entry_t;
-
-// A struct describing a pointer to an array of interrupt handlers.
-// This is in a format suitable for giving to 'lidt'.
-struct idt_ptr_struct
-{
-    u16int limit;
-    u32int base;                // The address of the first element in our idt_entry_t array.
-} __attribute__((packed));
-
-typedef struct idt_ptr_struct idt_ptr_t;
-
-// These extern directives let us access the addresses of our ASM ISR handlers.
-extern void isr0 ();
-extern void isr1 ();
-extern void isr2 ();
-extern void isr3 ();
-extern void isr4 ();
-extern void isr5 ();
-extern void isr6 ();
-extern void isr7 ();
-extern void isr8 ();
-extern void isr9 ();
-extern void isr10();
-extern void isr11();
-extern void isr12();
-extern void isr13();
-extern void isr14();
-extern void isr15();
-extern void isr16();
-extern void isr17();
-extern void isr18();
-extern void isr19();
-extern void isr20();
-extern void isr21();
-extern void isr22();
-extern void isr23();
-extern void isr24();
-extern void isr25();
-extern void isr26();
-extern void isr27();
-extern void isr28();
-extern void isr29();
-extern void isr30();
-extern void isr31();
-extern void irq0 ();
-extern void irq1 ();
-extern void irq2 ();
-extern void irq3 ();
-extern void irq4 ();
-extern void irq5 ();
-extern void irq6 ();
-extern void irq7 ();
-extern void irq8 ();
-extern void irq9 ();
-extern void irq10();
-extern void irq11();
-extern void irq12();
-extern void irq13();
-extern void irq14();
-extern void irq15();
-
-
-#endif

Modified: trunk/src/platform/sim/host.c
===================================================================
--- trunk/src/platform/linux/host.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/host.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,8 +1,9 @@
 #include &quot;host.h&quot;
 
 #define __NR_read     3
-#define __NR_write      4
+#define __NR_write    4
 #define __NR_mmap2    192
+#define __NR_exit     1
 
 int host_errno = 0;
 
@@ -14,6 +15,17 @@
 	return (type) (res); \
 } while(0)
 
+#define _syscall1(type,name,type1,arg1) \
+type host_##name(type1 arg1) \
+{ \
+long __res; \
+__asm__ volatile (&quot;int $0x80&quot; \
+        : &quot;=a&quot; (__res) \
+        : &quot;0&quot; (__NR_##name),&quot;b&quot; ((long)(arg1))); \
+__syscall_return(type,__res); \
+}
+
+
 #define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
 type host_##name(type1 arg1,type2 arg2,type3 arg3) \
 { \
@@ -41,37 +53,5 @@
 _syscall3(ssize_t, read, int, fd, void *, buf, size_t, count);
 _syscall3(ssize_t, write, int, fd, const void *, buf, size_t, count);
 _syscall6(void *,mmap2, void *,addr, size_t, length, int, prot, int, flags, int, fd, off_t, offset);
+_syscall1(void, exit, int, status);
 
-#if 0
-void *host_mmap2(void *addr, size_t length, int prot, int flags, int fd, off_t pgoffset) {
-	long res;
-	__asm__ __volatile__ (
-		&quot;  push %%ebp\n&quot;
-		&quot;  movl %%eax, %%ebp\n&quot;
-		&quot;  movl %1, %%eax\n&quot;
-  	&quot;  int  $0x80\n&quot;
-  	&quot;  pop %%ebp\n&quot;
-		: &quot;=a&quot; (res)
-		: &quot;i&quot; (__NR_mmap2), &quot;b&quot; (addr), &quot;c&quot; (length), &quot;d&quot; (prot), &quot;S&quot; (flags),
-		&quot;D&quot; (fd), &quot;0&quot; (pgoffset)
-	);
-	return (void *)res;
-}
-#endif
-
-int host_putchar(int c) {
-	unsigned char ch = (unsigned char)c;
-	if(host_write(STDOUT_FILENO, &amp;ch, 1) != 1) {
-		return EOF;
-	}
-	return (int)ch;
-}
-
-int host_getchar() {
-	unsigned char ch = 0;
-	if(host_read(STDIN_FILENO, &amp;ch, 1) != 1) {
-		return EOF;
-	}
-	return (int)ch;
-}
-

Modified: trunk/src/platform/sim/host.h
===================================================================
--- trunk/src/platform/linux/host.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/host.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -8,14 +8,8 @@
 
 extern int host_errno;
 
-#define EOF (-1)
-#define STDIN_FILENO 0
-#define STDOUT_FILENO 1
-
 ssize_t host_read( int fd, void * buf, size_t count);
 ssize_t host_write( int fd, const void * buf, size_t count);
-int host_putchar(int c);
-int host_getchar();
 
 #define PROT_READ 0x1   /* Page can be read.  */
 #define PROT_WRITE  0x2   /* Page can be written.  */
@@ -30,5 +24,7 @@
 #define MAP_FAILED (void *)(-1)
 
 void *host_mmap2(void *addr, size_t length, int prot, int flags, int fd, off_t pgoffset);
+void host_exit(int status);
 
 #endif // _HOST_H
+

Copied: trunk/src/platform/sim/hostif.h (from rev 283, trunk/src/platform/linux/monitor.h)
===================================================================
--- trunk/src/platform/linux/monitor.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/hostif.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -0,0 +1,22 @@
+// Host I/O operations for eLua 'simulator'
+
+#ifndef __HOSTIO_H__
+#define __HOSTIO_H__
+
+// Write a single character out to the screen.
+void hostif_put(char c);
+
+// Output a null-terminated ASCII string to the monitor.
+void hostif_write(const char *c);
+
+// Get a char from keyboard
+int hostif_getch();
+
+// Get memory
+void *hostif_getmem( unsigned size );
+
+// Terminate the simulator (exit program)
+void hostif_exit();
+
+#endif // __HOSTIO_H__
+


Property changes on: trunk/src/platform/sim/hostif.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/src/platform/sim/hostif_linux.c (from rev 283, trunk/src/platform/linux/monitor.c)
===================================================================
--- trunk/src/platform/linux/monitor.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/hostif_linux.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -0,0 +1,46 @@
+// Host I/O operations for eLua 'simulator'
+
+#include &lt;ctype.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &quot;term.h&quot;
+#include &quot;host.h&quot;
+#include &quot;hostif.h&quot;
+
+#define EOF (-1)
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+
+void hostif_put(char c)
+{
+	host_write(STDOUT_FILENO, &amp;c, 1);
+}
+
+void hostif_write(const char *c)
+{
+  int i = 0;
+  while (c[i])
+    hostif_put(c[i++]);
+}
+
+int hostif_getch()
+{
+ 	unsigned char ch = 0;
+	if(host_read(STDIN_FILENO, &amp;ch, 1) != 1) {
+		return EOF;
+	}
+	return (int)ch;
+ 
+}
+
+void* hostif_getmem( unsigned size )
+{
+  void *pmem = host_mmap2( 0, size, (PROT_READ|PROT_WRITE), (MAP_PRIVATE|MAP_ANONYMOUS), -1, 0 );
+  return pmem == MAP_FAILED ? NULL : pmem;
+}
+
+void hostif_exit()
+{
+  host_exit( 0 );
+}
+


Property changes on: trunk/src/platform/sim/hostif_linux.c
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/src/platform/sim/isr.c
===================================================================
--- trunk/src/platform/linux/isr.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/isr.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,58 +0,0 @@
-//
-// isr.c -- High level interrupt service routines and interrupt request handlers.
-//          Part of this code is modified from Bran's kernel development tutorials.
-//          Rewritten for JamesM's kernel development tutorials.
-//
-
-#include &quot;common.h&quot;
-#include &quot;isr.h&quot;
-#include &quot;monitor.h&quot;
-
-#if 0
-isr_t interrupt_handlers[256];
-extern void monitor_write_dec(u32int n);
-#endif
-
-void register_interrupt_handler(u8int n, isr_t handler)
-{
-#if 0
-    interrupt_handlers[n] = handler;
-#endif
-}
-
-#if 0
-// This gets called from our ASM interrupt handler stub.
-void isr_handler(registers_t regs)
-{
-    monitor_write(&quot;recieved interrupt: &quot;);
-    monitor_write_dec(regs.int_no);
-    monitor_put('\n');
-
-    if (interrupt_handlers[regs.int_no] != 0)
-    {
-        isr_t handler = interrupt_handlers[regs.int_no];
-        handler(regs);
-    }
-}
-
-// This gets called from our ASM interrupt handler stub.
-void irq_handler(registers_t regs)
-{
-    // Send an EOI (end of interrupt) signal to the PICs.
-    // If this interrupt involved the slave.
-    if (regs.int_no &gt;= 40)
-    {
-        // Send reset signal to slave.
-        outb(0xA0, 0x20);
-    }
-    // Send reset signal to master. (As well as slave, if necessary).
-    outb(0x20, 0x20);
-
-    if (interrupt_handlers[regs.int_no] != 0)
-    {
-        isr_t handler = interrupt_handlers[regs.int_no];
-        handler(regs);
-    }
-
-}
-#endif

Deleted: trunk/src/platform/sim/isr.h
===================================================================
--- trunk/src/platform/linux/isr.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/isr.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,39 +0,0 @@
-//
-// isr.h -- Interface and structures for high level interrupt service routines.
-//          Part of this code is modified from Bran's kernel development tutorials.
-//          Rewritten for JamesM's kernel development tutorials.
-//
-
-#include &quot;common.h&quot;
-
-// A few defines to make life a little easier
-#define IRQ0 32
-#define IRQ1 33
-#define IRQ2 34
-#define IRQ3 35
-#define IRQ4 36
-#define IRQ5 37
-#define IRQ6 38
-#define IRQ7 39
-#define IRQ8 40
-#define IRQ9 41
-#define IRQ10 42
-#define IRQ11 43
-#define IRQ12 44
-#define IRQ13 45
-#define IRQ14 46
-#define IRQ15 47
-
-typedef struct registers
-{
-    u32int ds;                  // Data segment selector
-    u32int edi, esi, ebp, esp, ebx, edx, ecx, eax; // Pushed by pusha.
-    u32int int_no, err_code;    // Interrupt number and error code (if applicable)
-    u32int eip, cs, eflags, useresp, ss; // Pushed by the processor automatically.
-} registers_t;
-
-// Enables registration of callbacks for interrupts or IRQs.
-// For IRQs, to ease confusion, use the #defines above as the
-// first parameter.
-typedef void (*isr_t)(registers_t);
-void register_interrupt_handler(u8int n, isr_t handler);

Deleted: trunk/src/platform/sim/kb.c
===================================================================
--- trunk/src/platform/linux/kb.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/kb.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,205 +0,0 @@
-/* bkerndev - Bran's Kernel Development Tutorial
-*  By:   Brandon F. (<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">friesenb at gmail.com</A>)
-*  Desc: Keyboard driver
-*
-*  Notes: No warranty expressed or implied. Use at own risk. */
-#include &quot;common.h&quot;
-#include &quot;monitor.h&quot;
-#include &quot;isr.h&quot;
-#include &quot;type.h&quot;
-#include &quot;utils.h&quot;
-#include &quot;term.h&quot;
-#include &quot;host.h&quot;
-#include &lt;stdio.h&gt;
-
-#if 0
-#define RSHIFT 0x36
-#define LSHIFT 0x2A
-#define CTRL   0x1D
-static int shift_pressed, ctrl_pressed;
-
-/* KBDUS means US Keyboard Layout. This is a scancode table
-*  used to layout a standard US keyboard. I have left some
-*  comments in to give you an idea of what key is what, even
-*  though I set it's array index to 0. You can change that to
-*  whatever you want using a macro, if you wish! */
-const unsigned char kbdus[128] =
-{
-    0,  27, '1', '2', '3', '4', '5', '6', '7', '8', /* 9 */
-  '9', '0', '-', '=', '\b', /* Backspace */
-  '\t',     /* Tab */
-  'q', 'w', 'e', 'r', /* 19 */
-  't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n',   /* Enter key */
-    0,      /* 29   - Control */
-  'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', /* 39 */
- '\'', '`',   0,    /* Left shift */
- '\\', 'z', 'x', 'c', 'v', 'b', 'n',      /* 49 */
-  'm', ',', '.', '/',   0,          /* Right shift */
-  '*',
-    0,  /* Alt */
-  ' ',  /* Space bar */
-    0,  /* Caps lock */
-    0,  /* 59 - F1 key ... &gt; */
-    0,   0,   0,   0,   0,   0,   0,   0,
-    0,  /* &lt; ... F10 */
-    0,  /* 69 - Num lock*/
-    0,  /* Scroll Lock */
-    0,  /* Home key */
-    0,  /* Up Arrow */
-    0,  /* Page Up */
-  '-',
-    0,  /* Left Arrow */
-    0,
-    0,  /* Right Arrow */
-  '+',
-    0,  /* 79 - End key*/
-    0,  /* Down Arrow */
-    0,  /* Page Down */
-    0,  /* Insert Key */
-    0,  /* Delete Key */
-    0,   0,   0,
-    0,  /* F11 Key */
-    0,  /* F12 Key */
-    0,  /* All other keys are undefined */
-};
-
-const unsigned char shift_kbdus[128] =
-{
-  0,  27, '!', '@', '#', '$', '%', '^', '&amp;', '*', /* 9 */
-  '(', ')', '_', '+', '\b', /* Backspace */
-  '\t',     /* Tab */
-  'Q', 'W', 'E', 'R', /* 19 */
-  'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', '\n',   /* Enter key */
-  0,      /* 29   - Control */
-  'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', /* 39 */
-  '&quot;', '~',   0,    /* Left shift */
-  '|', 'Z', 'X', 'C', 'V', 'B', 'N',      /* 49 */
-  'M', '&lt;', '&gt;', '?',   0,          /* Right shift */
-  '*',
-  0,  /* Alt */
-  ' ',  /* Space bar */
-  0,  /* Caps lock */
-  0,  /* 59 - F1 key ... &gt; */
-  0,   0,   0,   0,   0,   0,   0,   0,
-  0,  /* &lt; ... F10 */
-  0,  /* 69 - Num lock*/
-  0,  /* Scroll Lock */
-  0,  /* Home key */
-  0,  /* Up Arrow */
-  0,  /* Page Up */
-  '-',
-  0,  /* Left Arrow */
-  0,
-  0,  /* Right Arrow */
-  '+',
-  0,  /* 79 - End key*/
-  0,  /* Down Arrow */
-  0,  /* Page Down */
-  0,  /* Insert Key */
-  0,  /* Delete Key */
-  0,   0,   0,
-  0,  /* F11 Key */
-  0,  /* F12 Key */
-  0,  /* All other keys are undefined */
-};
-
-// Keyboard buffer
-#define KBUF_SIZE     64
-static int kb_buffer[ KBUF_SIZE ];
-static u8 r_ptr;
-static volatile u8 w_ptr;
-
-// Special keys lookup
-static const unsigned char skeys[] = { 0x48, 0x50, 0x4b, 0x4d, 0x47, 0x4f, 0x49, 0x51, 0, 0, 0, 1 };
-
-/* Handles the keyboard interrupt */
-void keyboard_handler(registers_t regs)
-{
-    unsigned char scancode;
-    int i;
-
-    /* Read from the keyboard's data buffer */
-    /* Ignore 0xE0 (extended indication) */
-    if( ( scancode = inb( 0x60 ) ) == 0xE0 )
-     return;
-
-    /* If the top bit of the byte we read from the keyboard is
-    *  set, that means that a key has just been released */
-    if (scancode &amp; 0x80)
-    {
-        /* You can use this one to see if the user released the
-        *  shift, alt, or control keys... */
-      scancode &amp;= 0x7F;
-      if( ( scancode == RSHIFT ) || ( scancode == LSHIFT ) )
-        shift_pressed = 0;
-      else if ( scancode == CTRL )
-        ctrl_pressed = 0;
-    }
-    else
-    {
-
-      /* Check if this is a special key (will be used by the term module) */    
-      for( i = 0; i &lt; sizeof( skeys ) / sizeof( unsigned char ); i ++ )
-        if( skeys[ i ] == scancode )
-        {
-            kb_buffer[ w_ptr ] = TERM_FIRST_KEY + i;
-            w_ptr = ( w_ptr + 1 ) % KBUF_SIZE;
-            return;
-        }
-
-      /* Here, a key was just pressed. Please note that if you
-      *  hold a key down, you will get repeated key press
-      *  interrupts. */
-
-      /* Just to show you how this works, we simply translate
-      *  the keyboard scancode into an ASCII value, and then
-      *  display it to the screen. You can get creative and
-      *  use some flags to see if a shift is pressed and use a
-      *  different layout, or you can add another 128 entries
-      *  to the above layout to correspond to 'shift' being
-      *  held. If shift is held using the larger lookup table,
-      *  you would add 128 to the scancode when you look for it */
-      if( ( scancode == RSHIFT ) || ( scancode == LSHIFT ) )
-        shift_pressed = 1;
-      else if( scancode == CTRL )
-        ctrl_pressed = 1;
-      else      
-      {
-        if( ( ( w_ptr + 1 ) % KBUF_SIZE ) != r_ptr )
-        {
-          unsigned char thechar = shift_pressed ? shift_kbdus[scancode] : kbdus[scancode];
-          if( ctrl_pressed ) // Look for CTRL+Z (EOF)
-            thechar = ( thechar == 'z' || thechar == 'Z' ) ? STD_CTRLZ_CODE : 0;
-          if( thechar != 0 )
-          {
-            kb_buffer[ w_ptr ] = thechar;
-            w_ptr = ( w_ptr + 1 ) % KBUF_SIZE;
-          }
-        }
-      }
-    }
-}
-#endif
-
-/* Installs the keyboard handler into IRQ1 */
-void keyboard_install()
-{
-#if 0
-  register_interrupt_handler(IRQ1, keyboard_handler);
-#endif
-}
-
-// Return a key from the keyboard (blocking!)
-int keyboard_getch()
-{
-	return host_getchar();
-#if 0
-  int c;
-  
-  while( r_ptr == w_ptr );
-  c = kb_buffer[ r_ptr ];
-  r_ptr = ( r_ptr + 1 ) % KBUF_SIZE;
-  return c; 
-#endif
-}
-

Deleted: trunk/src/platform/sim/kb.h
===================================================================
--- trunk/src/platform/linux/kb.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/kb.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,9 +0,0 @@
-// Keyboard handler
-
-#ifndef __KB_H__
-#define __KB_H__
-
-void keyboard_install();
-int keyboard_getch();
-
-#endif

Deleted: trunk/src/platform/sim/monitor.c
===================================================================
--- trunk/src/platform/linux/monitor.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/monitor.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,358 +0,0 @@
-// monitor.c -- Defines functions for writing to the monitor.
-//             heavily based on Bran's kernel development tutorials,
-//             but rewritten for JamesM's kernel tutorials.
-
-#include &quot;monitor.h&quot;
-#include &lt;ctype.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-#include &quot;term.h&quot;
-#include &quot;utils.h&quot;
-#include &quot;host.h&quot;
-
-#if 0
-// The VGA framebuffer starts at 0xB8000.
-u16int *video_memory = (u16int *)0xB8000;
-// Stores the cursor position.
-u8int cursor_x = 0;
-u8int cursor_y = 0;
-#endif
-
-// Updates the hardware cursor.
-#if 0
-static void move_cursor()
-{
-    cursor_y = UMIN( cursor_y, 24 );
-    cursor_x = UMIN( cursor_x, 79 );
-    // The screen is 80 characters wide...
-    u16int cursorLocation = cursor_y * 80 + cursor_x;
-    outb(0x3D4, 14);                  // Tell the VGA board we are setting the high cursor byte.
-    outb(0x3D5, cursorLocation &gt;&gt; 8); // Send the high cursor byte.
-    outb(0x3D4, 15);                  // Tell the VGA board we are setting the low cursor byte.
-    outb(0x3D5, cursorLocation);      // Send the low cursor byte.
-}
-#endif
-
-#if 0
-// Scrolls the text on the screen up by one line.
-static void scroll()
-{
-    // Get a space character with the default colour attributes.
-    u8int attributeByte = (0 /*black*/ &lt;&lt; 4) | (15 /*white*/ &amp; 0x0F);
-    u16int blank = 0x20 /* space */ | (attributeByte &lt;&lt; 8);
-
-    // Row 25 is the end, this means we need to scroll up
-    if(cursor_y &gt;= 25)
-    {
-        // Move the current text chunk that makes up the screen
-        // back in the buffer by a line
-        int i;
-        for (i = 0*80; i &lt; 24*80; i++)
-        {
-            video_memory[i] = video_memory[i+80];
-        }
-
-        // The last line should now be blank. Do this by writing
-        // 80 spaces to it.
-        for (i = 24*80; i &lt; 25*80; i++)
-        {
-            video_memory[i] = blank;
-        }
-        // The cursor should now be on the last line.
-        cursor_y = 24;
-    }
-}
-#endif
-
-#if 0
-// ANSI 'state machine'
-static int monitor_reading_ansi;
-static int monitor_ansi_count;
-static char monitor_ansi_inbuf[ TERM_MAX_ANSI_SIZE + 1 ];
-
-// ANSI operations and structure data
-enum
-{
-  ANSI_SEQ_CLRSCR,
-  ANSI_SEQ_CLREOL,
-  ANSI_SEQ_GOTOXY,
-  ANSI_SEQ_UP,
-  ANSI_SEQ_DOWN,
-  ANSI_SEQ_RIGHT,
-  ANSI_SEQ_LEFT
-};
-
-typedef struct
-{
-  int op;
-  int p1, p2; 
-} ansi_op;
-
-// Convert an ASCII escape sequence to an operation we can understand
-static int monitor_cvt_escape( const char* inbuf, ansi_op* res )
-{
-  const char *p = inbuf;
-  char last = inbuf[ strlen( inbuf ) - 1 ];
-
-  if( *p++ != '\x1B' )
-    return 0;
-  if( *p++ != '[' )
-    return 0;
-  res-&gt;op = res-&gt;p1 = res-&gt;p2 = 0;
-  switch( last )
-  {
-    case 'J': // clrscr
-      if( *p != '2' )
-        return 0;
-      res-&gt;op = ANSI_SEQ_CLRSCR;
-      break;
-
-    case 'K': // clreol
-      res-&gt;op = ANSI_SEQ_CLREOL;
-      break;
-
-    case 'H': // gotoxy
-      res-&gt;op = ANSI_SEQ_GOTOXY;
-      if( *p != 'H' )
-        sscanf( p, &quot;%d;%d&quot;, &amp;res-&gt;p1, &amp;res-&gt;p2 );
-      break;
-
-    case 'A': // up
-    case 'B': // down
-    case 'C': // right
-    case 'D': // left
-      res-&gt;op = last - 'A' + ANSI_SEQ_UP;
-      sscanf( p, &quot;%d&quot;, &amp;res-&gt;p1 );
-      break;
-  }
-  return 1;
-}
-#endif
-
-void monitor_clear();
-// Writes a single character out to the screen.
-void monitor_put(char c)
-{
-	host_putchar(c);
-#if 0
-    // The background colour is black (0), the foreground is white (15).
-    u8int backColour = 0;
-    u8int foreColour = 15;
-
-    // Take care of the ANSI state machine
-    if( c == '\x1B' )
-    {
-      monitor_reading_ansi = 1;
-      monitor_ansi_count = 0;
-      monitor_ansi_inbuf[ monitor_ansi_count ++ ] = c; 
-      return;
-    }
-
-    // The attribute byte is made up of two nibbles - the lower being the 
-    // foreground colour, and the upper the background colour.
-    u8int  attributeByte = (backColour &lt;&lt; 4) | (foreColour &amp; 0x0F);
-    // The attribute byte is the top 8 bits of the word we have to send to the
-    // VGA board.
-    u16int attribute = attributeByte &lt;&lt; 8;
-    u16int *location;
-    u8int prev;
-
-    if( monitor_reading_ansi )
-    {
-      monitor_ansi_inbuf[ monitor_ansi_count ++ ] = c;
-      if( isalpha( c ) )
-      {
-        monitor_ansi_inbuf[ monitor_ansi_count ] = '\0';
-        ansi_op op;
-        if( monitor_cvt_escape( monitor_ansi_inbuf, &amp;op ) )
-        {
-          // Interpret out sequence
-          switch( op.op )
-          {
-            case ANSI_SEQ_CLRSCR:
-              monitor_clear();
-              break;
-
-            case ANSI_SEQ_CLREOL:
-              prev = cursor_x;
-              while( cursor_x++ &lt; 80 )
-              {
-                location = video_memory + (cursor_y*80 + cursor_x);      
-                *location = ' ' | attribute;
-              }
-              cursor_x = prev;
-              break;
-
-            case ANSI_SEQ_GOTOXY:
-              cursor_y = ( u8int )op.p1 - 1;
-              cursor_x = ( u8int )op.p2 - 1;
-              move_cursor();
-              break;
-
-            case ANSI_SEQ_UP:
-            case ANSI_SEQ_LEFT:
-            case ANSI_SEQ_RIGHT:
-            case ANSI_SEQ_DOWN:
-              {
-                int xm = op.op == ANSI_SEQ_LEFT ? -1 : op.op == ANSI_SEQ_RIGHT ? 1 : 0;
-                int ym = op.op == ANSI_SEQ_UP ? -1 : op.op == ANSI_SEQ_DOWN ? 1 : 0;
-                cursor_x += xm * op.p1;
-                cursor_y += ym * op.p1;
-                move_cursor();
-                break;
-              }
-           }
-        }
-        monitor_reading_ansi = 0;
-      }
-      return;
-    }
-
-    // Handle a backspace, by moving the cursor back one space
-    if (c == 0x08 &amp;&amp; cursor_x)
-    {
-        cursor_x--;
-    }
-
-    // Handle a tab by increasing the cursor's X, but only to a point
-    // where it is divisible by 2.
-    else if (c == 0x09)
-    {
-        cursor_x = (cursor_x+2) &amp; ~(2-1);
-    }
-
-    // Handle carriage return
-    else if (c == '\r')
-    {
-        cursor_x = 0;
-    }
-
-    // Handle newline by moving cursor back to left and increasing the row
-    else if (c == '\n')
-    {
-        cursor_x = 0;
-        cursor_y++;
-    }
-    // Handle any other printable character.
-    else if(c &gt;= ' ')
-    {
-        location = video_memory + (cursor_y*80 + cursor_x);
-        *location = c | attribute;
-        cursor_x++;
-    }
-
-    // Check if we need to insert a new line because we have reached the end
-    // of the screen.
-    if (cursor_x &gt;= 80)
-    {
-        cursor_x = 0;
-        cursor_y ++;
-    }
-
-    // Scroll the screen if needed.
-    scroll();
-    // Move the hardware cursor.
-    move_cursor();
-#endif
-}
-
-// Clears the screen, by copying lots of spaces to the framebuffer.
-void monitor_clear()
-{
-#if 0
-    // Make an attribute byte for the default colours
-    u8int attributeByte = (0 /*black*/ &lt;&lt; 4) | (15 /*white*/ &amp; 0x0F);
-    u16int blank = 0x20 /* space */ | (attributeByte &lt;&lt; 8);
-
-    int i;
-    for (i = 0; i &lt; 80*25; i++)
-    {
-        video_memory[i] = blank;
-    }
-
-    // Move the hardware cursor back to the start.
-    cursor_x = 0;
-    cursor_y = 0;
-    move_cursor();
-#endif
-}
-
-// Outputs a null-terminated ASCII string to the monitor.
-void monitor_write(char *c)
-{
-    int i = 0;
-    while (c[i])
-    {
-        monitor_put(c[i++]);
-    }
-}
-
-void monitor_write_hex(u32int n)
-{
-    s32int tmp;
-
-    char noZeroes = 1;
-
-    int i;
-    for (i = 28; i &gt; 0; i -= 4)
-    {
-        tmp = (n &gt;&gt; i) &amp; 0xF;
-        if (tmp == 0 &amp;&amp; noZeroes != 0)
-        {
-            continue;
-        }
-    
-        if (tmp &gt;= 0xA)
-        {
-            noZeroes = 0;
-            monitor_put (tmp-0xA+'a' );
-        }
-        else
-        {
-            noZeroes = 0;
-            monitor_put( tmp+'0' );
-        }
-    }
-  
-    tmp = n &amp; 0xF;
-    if (tmp &gt;= 0xA)
-    {
-        monitor_put (tmp-0xA+'a');
-    }
-    else
-    {
-        monitor_put (tmp+'0');
-    }
-
-}
-
-void monitor_write_dec(u32int n)
-{
-
-    if (n == 0)
-    {
-        monitor_put('0');
-        return;
-    }
-
-    s32int acc = n;
-    char c[32];
-    int i = 0;
-    while (acc &gt; 0)
-    {
-        c[i] = '0' + acc%10;
-        acc /= 10;
-        i++;
-    }
-    c[i] = 0;
-
-    char c2[32];
-    c2[i--] = 0;
-    int j = 0;
-    while(i &gt;= 0)
-    {
-        c2[i--] = c[j++];
-    }
-    monitor_write(c2);
-
-}

Deleted: trunk/src/platform/sim/monitor.h
===================================================================
--- trunk/src/platform/linux/monitor.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/monitor.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,18 +0,0 @@
-// monitor.h -- Defines the interface for monitor.h
-//              From JamesM's kernel development tutorials.
-
-#ifndef MONITOR_H
-#define MONITOR_H
-
-#include &quot;common.h&quot;
-
-// Write a single character out to the screen.
-void monitor_put(char c);
-
-// Clear the screen to all black.
-void monitor_clear();
-
-// Output a null-terminated ASCII string to the monitor.
-void monitor_write(char *c);
-
-#endif // MONITOR_H

Deleted: trunk/src/platform/sim/multiboot.h
===================================================================
--- trunk/src/platform/linux/multiboot.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/multiboot.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,123 +0,0 @@
-/* multiboot.h - the header for Multiboot */
-/* Copyright (C) 1999, 2001  Free Software Foundation, Inc.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
-
-/* Macros. */
-
-#if 0
-
-/* The magic number for the Multiboot header. */
-#define MULTIBOOT_HEADER_MAGIC          0x1BADB002
-
-/* The flags for the Multiboot header. */
-#ifdef __ELF__
-# define MULTIBOOT_HEADER_FLAGS         0x00000003
-#else
-# define MULTIBOOT_HEADER_FLAGS         0x00010003
-#endif
-
-/* The magic number passed by a Multiboot-compliant boot loader. */
-#define MULTIBOOT_BOOTLOADER_MAGIC      0x2BADB002
-
-/* The size of our stack (16KB). */
-#define STACK_SIZE                      0x4000
-
-/* C symbol format. HAVE_ASM_USCORE is defined by configure. */
-#ifdef HAVE_ASM_USCORE
-# define EXT_C(sym)                     _ ## sym
-#else
-# define EXT_C(sym)                     sym
-#endif
-
-#ifndef ASM
-/* Do not include here in boot.S. */
-
-/* Types. */
-
-/* The Multiboot header. */
-typedef struct multiboot_header
-{
-  unsigned long magic;
-  unsigned long flags;
-  unsigned long checksum;
-  unsigned long header_addr;
-  unsigned long load_addr;
-  unsigned long load_end_addr;
-  unsigned long bss_end_addr;
-  unsigned long entry_addr;
-} multiboot_header_t;
-
-/* The symbol table for a.out. */
-typedef struct aout_symbol_table
-{
-  unsigned long tabsize;
-  unsigned long strsize;
-  unsigned long addr;
-  unsigned long reserved;
-} aout_symbol_table_t;
-
-/* The section header table for ELF. */
-typedef struct elf_section_header_table
-{
-  unsigned long num;
-  unsigned long size;
-  unsigned long addr;
-  unsigned long shndx;
-} elf_section_header_table_t;
-
-/* The Multiboot information. */
-typedef struct multiboot_info
-{
-  unsigned long flags;
-  unsigned long mem_lower;
-  unsigned long mem_upper;
-  unsigned long boot_device;
-  unsigned long cmdline;
-  unsigned long mods_count;
-  unsigned long mods_addr;
-  union
-  {
-    aout_symbol_table_t aout_sym;
-    elf_section_header_table_t elf_sec;
-  } u;
-  unsigned long mmap_length;
-  unsigned long mmap_addr;
-} multiboot_info_t;
-
-/* The module structure. */
-typedef struct module
-{
-  unsigned long mod_start;
-  unsigned long mod_end;
-  unsigned long string;
-  unsigned long reserved;
-} module_t;
-
-/* The memory map. Be careful that the offset 0 is base_addr_low
-  but no size. */
-typedef struct memory_map
-{
-  unsigned long size;
-  unsigned long base_addr_low;
-  unsigned long base_addr_high;
-  unsigned long length_low;
-  unsigned long length_high;
-  unsigned long type;
-} memory_map_t;
-
-#endif /* ! ASM */
-
-#endif

Modified: trunk/src/platform/sim/platform.c
===================================================================
--- trunk/src/platform/linux/platform.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/platform.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -12,10 +12,7 @@
 #include &quot;term.h&quot;
 
 // Platform specific includes
-#include &quot;monitor.h&quot;
-#include &quot;descriptor_tables.h&quot;
-#include &quot;kb.h&quot;
-#include &quot;host.h&quot;
+#include &quot;hostif.h&quot;
 
 // ****************************************************************************
 // Terminal support code
@@ -24,7 +21,7 @@
 
 static void i386_term_out( u8 data )
 {
-  monitor_put( data );
+  hostif_put( data );
 }
 
 static int i386_term_in( int mode )
@@ -32,7 +29,7 @@
   if( mode == TERM_INPUT_DONT_WAIT )
     return -1;
   else
-    return keyboard_getch();
+    return hostif_getch();
 }
 
 static int i386_term_translate( int data )
@@ -54,6 +51,10 @@
     case '\b':
       newdata = KC_BACKSPACE;
       break;
+
+    case 0x1B:
+      newdata = KC_ESC;
+      break;
   }
   return newdata;
 }
@@ -65,7 +66,7 @@
 static void scr_write( int fd, char c )
 {
   fd = fd;
-  monitor_put( c );
+  hostif_put( c );
 }
 
 static int kb_read( s32 to )
@@ -76,7 +77,7 @@
     return -1;
   else
   {
-    while( ( res = keyboard_getch() ) &gt;= TERM_FIRST_KEY );
+    while( ( res = hostif_getch() ) &gt;= TERM_FIRST_KEY );
     return res;
   }
 }
@@ -89,34 +90,19 @@
 
 void platform_ll_init()
 {
-#if 0
-  // Initialise all the ISRs and segmentation
-  init_descriptor_tables();
-#endif
-    
-  // Initialise the screen (by clearing it)
-  monitor_clear();        
-
 	// Initialise heap memory region.
-	memory_start_address =
-		host_mmap2(0, MEM_LENGTH, (PROT_READ|PROT_WRITE), (MAP_PRIVATE|MAP_ANONYMOUS), -1, 0);
+	memory_start_address = hostif_getmem( MEM_LENGTH ); 
 	memory_end_address = memory_start_address + MEM_LENGTH;
 }
 
 int platform_init()
 { 
-#if 0
-  // We can start interrupts now
-  asm volatile(&quot;sti&quot;);    
-  
-  // And install the keyboard handler
-  keyboard_install();
-#endif
-
-	if(memory_start_address == MAP_FAILED) {
-    monitor_write( &quot;platform_init(): mmap failed\n&quot; );
+	if( memory_start_address == NULL ) 
+  {
+    hostif_write( &quot;platform_init(): mmap failed\n&quot; );
 		return PLATFORM_ERR;
 	}
+
   // Set the std input/output functions
   // Set the send/recv functions                          
   std_set_send_func( scr_write );
@@ -126,6 +112,9 @@
 #ifdef BUILD_TERM  
   term_init( TERM_LINES, TERM_COLS, i386_term_out, i386_term_in, i386_term_translate );
 #endif
+
+  term_clrscr();
+  term_gotoxy( 1, 1 );
  
   // All done
   return PLATFORM_OK;
@@ -160,12 +149,3 @@
   return 0;
 }
 
-// ****************************************************************************
-// Allocator support
-
-#if 0
-u32 platform_get_lastmem()
-{
-  return lastmem;
-}
-#endif

Deleted: trunk/src/platform/sim/timer.c
===================================================================
--- trunk/src/platform/linux/timer.c	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/timer.c	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,42 +0,0 @@
-// timer.c -- Initialises the PIT, and handles clock updates.
-//            Written for JamesM's kernel development tutorials.
-
-#include &quot;timer.h&quot;
-#include &quot;isr.h&quot;
-#include &quot;monitor.h&quot;
-
-#if 0
-u32int tick = 0;
-
-static void timer_callback(registers_t regs)
-{
-    tick++;
-    monitor_write(&quot;Tick: &quot;);
-    monitor_write_dec(tick);
-    monitor_write(&quot;\n&quot;);
-}
-#endif
-
-void init_timer(u32int frequency)
-{
-#if 0
-    // Firstly, register our timer callback.
-    register_interrupt_handler(IRQ0, &amp;timer_callback);
-
-    // The value we send to the PIT is the value to divide it's input clock
-    // (1193180 Hz) by, to get our required frequency. Important to note is
-    // that the divisor must be small enough to fit into 16-bits.
-    u32int divisor = 1193180 / frequency;
-
-    // Send the command byte.
-    outb(0x43, 0x36);
-
-    // Divisor has to be sent byte-wise, so split here into upper/lower bytes.
-    u8int l = (u8int)(divisor &amp; 0xFF);
-    u8int h = (u8int)( (divisor&gt;&gt;8) &amp; 0xFF );
-
-    // Send the frequency divisor.
-    outb(0x40, l);
-    outb(0x40, h);
-#endif
-}

Deleted: trunk/src/platform/sim/timer.h
===================================================================
--- trunk/src/platform/linux/timer.h	2009-05-11 21:35:42 UTC (rev 283)
+++ trunk/src/platform/sim/timer.h	2009-05-12 14:09:29 UTC (rev 284)
@@ -1,11 +0,0 @@
-// timer.h -- Defines the interface for all PIT-related functions.
-//            Written for JamesM's kernel development tutorials.
-
-#ifndef TIMER_H
-#define TIMER_H
-
-#include &quot;common.h&quot;
-
-void init_timer(u32int frequency);
-
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000239.html">[Elua-svn] r283 - in trunk: . src/platform src/platform/linux
</A></li>
	<LI>Next message: <A HREF="000241.html">[Elua-svn] r285 - in tags/pre0.6/doc: . arch_platform en wb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#240">[ date ]</a>
              <a href="thread.html#240">[ thread ]</a>
              <a href="subject.html#240">[ subject ]</a>
              <a href="author.html#240">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
