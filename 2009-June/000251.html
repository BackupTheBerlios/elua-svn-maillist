<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r295 - in branches/luarpc: . inc src src/modules
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r295%20-%20in%20branches/luarpc%3A%20.%20inc%20src%20src/modules&In-Reply-To=%3C200906150330.n5F3U3rx022974%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000250.html">
   <LINK REL="Next"  HREF="000252.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r295 - in branches/luarpc: . inc src src/modules</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r295%20-%20in%20branches/luarpc%3A%20.%20inc%20src%20src/modules&In-Reply-To=%3C200906150330.n5F3U3rx022974%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r295 - in branches/luarpc: . inc src src/modules">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Mon Jun 15 05:30:03 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000250.html">[Elua-svn] r294 - in branches/coco: . src/lua
</A></li>
        <LI>Next message: <A HREF="000252.html">[Elua-svn] r296 - in branches/luarpc: . src/lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#251">[ date ]</a>
              <a href="thread.html#251">[ thread ]</a>
              <a href="subject.html#251">[ subject ]</a>
              <a href="author.html#251">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-06-15 05:30:01 +0200 (Mon, 15 Jun 2009)
New Revision: 295

Added:
   branches/luarpc/src/luarpc_elua_uart.c
Removed:
   branches/luarpc/src/luarpc_elua.c
Modified:
   branches/luarpc/SConstruct
   branches/luarpc/inc/luarpc_rpc.h
   branches/luarpc/src/modules/luarpc.c
Log:
Bring up to parity with github LuaRPC sources.

Modified: branches/luarpc/SConstruct
===================================================================
--- branches/luarpc/SConstruct	2009-06-09 20:15:05 UTC (rev 294)
+++ branches/luarpc/SConstruct	2009-06-15 03:30:01 UTC (rev 295)
@@ -230,7 +230,7 @@
 local_libs = ''
 
 # Application files
-app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/common.c src/buf.c src/elua_adc.c src/dlmalloc.c src/salloc.c src/luarpc_elua.c &quot;
+app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/common.c src/buf.c src/elua_adc.c src/dlmalloc.c src/salloc.c src/luarpc_elua_uart.c &quot;
 
 # Newlib related files
 newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c src/newlib/stdtcp.c&quot;

Modified: branches/luarpc/inc/luarpc_rpc.h
===================================================================
--- branches/luarpc/inc/luarpc_rpc.h	2009-06-09 20:15:05 UTC (rev 294)
+++ branches/luarpc/inc/luarpc_rpc.h	2009-06-15 03:30:01 UTC (rev 295)
@@ -87,13 +87,15 @@
 /* Transport Connection Structure */
 
 /* FIXME: should be cleaner */
+typedef struct _Transport Transport;
 struct _Transport 
 {
   int fd;      /* INVALID_TRANSPORT if socket is closed */
 };
-typedef struct _Transport Transport;
 
+#define LUARPC_MODE &quot;elua&quot;
 
+typedef struct _Handle Handle;
 struct _Handle 
 {
   Transport tpt;      /* the handle socket */
@@ -101,23 +103,23 @@
   int async;      /* nonzero if async mode being used */
   int read_reply_count;   /* number of async call return values to read */
 };
-typedef struct _Handle Handle;
 
 
+typedef struct _Helper Helper;
 struct _Helper {
   Handle *handle;     /* pointer to handle object */
+	Helper *parent; /* parent helper */
+	u8 nparents; /* number of parents */
   char funcname[NUM_FUNCNAME_CHARS];  /* name of the function */
-	char *lname; /* last name appended */
 };
-typedef struct _Helper Helper;
 
 
+typedef struct _ServerHandle ServerHandle;
 struct _ServerHandle {
   Transport ltpt;   /* listening socket, always valid if no error */
   Transport atpt;   /* accepting socket, valid if connection established */
 	int link_errs;
 };
-typedef struct _ServerHandle ServerHandle;
 
 /* Maximum number of framing errors before connection reset */
 #define MAX_LINK_ERRS ( 2 )

Deleted: branches/luarpc/src/luarpc_elua.c
===================================================================
--- branches/luarpc/src/luarpc_elua.c	2009-06-09 20:15:05 UTC (rev 294)
+++ branches/luarpc/src/luarpc_elua.c	2009-06-15 03:30:01 UTC (rev 295)
@@ -1,141 +0,0 @@
-#include &quot;lua.h&quot;
-#include &quot;lualib.h&quot;
-#include &quot;lauxlib.h&quot;
-#include &quot;platform.h&quot;
-#include &quot;platform_conf.h&quot;
-#include &quot;luarpc_rpc.h&quot;
-
-#ifdef BUILD_LUARPC
-
-int uart_timeout = PLATFORM_UART_INFINITE_TIMEOUT;
-
-/* Setup Transport */
-void transport_init (Transport *tpt)
-{
-	tpt-&gt;fd = INVALID_TRANSPORT;
-}
-
-/* Open Listener / Server */
-void transport_open_listener(lua_State *L, ServerHandle *handle)
-{
-	/* Get args &amp; Set up connection */
-	
-	handle-&gt;ltpt.fd = CON_UART_ID;
-}
-
-/* Open Connection / Client */
-int transport_open_connection(lua_State *L, Handle *handle)
-{
-	handle-&gt;tpt.fd = CON_UART_ID;
-	return 0;
-}
-
-/* Accept Connection */
-void transport_accept (Transport *tpt, Transport *atpt)
-{
-	struct exception e;
-	TRANSPORT_VERIFY_OPEN;
-	atpt-&gt;fd = tpt-&gt;fd;
-}
-
-/* Read &amp; Write to Transport */
-void transport_read_buffer_low (Transport *tpt, u8 *buffer, int length)
-{
-	int n = 0;
-	int c;
-	struct exception e;
-	
-	while( n &lt; length )
-	{
-		TRANSPORT_VERIFY_OPEN;
-		c = platform_uart_recv( CON_UART_ID, CON_TIMER_ID, uart_timeout );
-				
-    if( c &lt; 0 )
-		{
-			e.errnum = ERR_NODATA;
-			e.type = nonfatal;
-			Throw( e );
-		}
-		else
-		{
-			buffer[ n ] = ( u8 ) c;
-			n++;
-		}
-  }
-}
-
-void transport_read_buffer (Transport *tpt, u8 *buffer, int length)
-{
-	u8 tmp;
-	struct exception e;
-	TRANSPORT_VERIFY_OPEN;
-	
-	/* Read Header */
-	transport_read_buffer_low( tpt, &amp;tmp, 1);
-	if ( tmp != HEAD_BYTE )
-	{
-		uart_timeout = 1000000;
-		e.errnum = ERR_PROTOCOL;
-		e.type = nonfatal;
-		Throw( e );
-	}
-	
-	/* Read Data */
-	transport_read_buffer_low( tpt, buffer, length);
-	
-	/* Read Trailer */
-	transport_read_buffer_low( tpt, &amp;tmp, 1);
-	if ( tmp != TAIL_BYTE )
-	{
-		uart_timeout = 1000000;
-		e.errnum = ERR_PROTOCOL;
-		e.type = nonfatal;
-		Throw( e );
-	}
-	
-	uart_timeout = PLATFORM_UART_INFINITE_TIMEOUT;
-}
-
-void transport_write_buffer_low (Transport *tpt, const u8 *buffer, int length)
-{
-	int i;
-	for( i = 0; i &lt; length; i ++ )
-    platform_uart_send( CON_UART_ID, buffer[ i ] );
-}
-
-void transport_write_buffer( Transport *tpt, const u8 *buffer, int length )
-{
-	u8 tmp;
-	struct exception e;
-	TRANSPORT_VERIFY_OPEN;
-	
-	tmp = HEAD_BYTE;
-	transport_write_buffer_low( tpt, (const u8 *)&amp;tmp, 1 );
-	
-	transport_write_buffer_low( tpt, buffer, length );
-	
-	tmp = TAIL_BYTE;
-	transport_write_buffer_low( tpt, (const u8 *)&amp;tmp, 1 );
-}
-
-/* Check if data is available on connection without reading:
- 		- 1 = data available, 0 = no data available */
-int transport_readable (Transport *tpt)
-{
-	return 1;
-}
-
-/* Check if transport is open:
-		- 1 = connection open, 0 = connection closed */
-int transport_is_open (Transport *tpt)
-{
-	return (tpt-&gt;fd != INVALID_TRANSPORT);
-}
-
-/* Shut down connection */
-void transport_close (Transport *tpt)
-{
-	tpt-&gt;fd = INVALID_TRANSPORT;
-}
-
-#endif
\ No newline at end of file

Copied: branches/luarpc/src/luarpc_elua_uart.c (from rev 292, branches/luarpc/src/luarpc_elua.c)
===================================================================
--- branches/luarpc/src/luarpc_elua.c	2009-06-09 20:12:00 UTC (rev 292)
+++ branches/luarpc/src/luarpc_elua_uart.c	2009-06-15 03:30:01 UTC (rev 295)
@@ -0,0 +1,106 @@
+#include &quot;lua.h&quot;
+#include &quot;lualib.h&quot;
+#include &quot;lauxlib.h&quot;
+#include &quot;platform.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;luarpc_rpc.h&quot;
+
+#ifdef BUILD_LUARPC
+
+int uart_timeout = PLATFORM_UART_INFINITE_TIMEOUT;
+
+/* Setup Transport */
+void transport_init (Transport *tpt)
+{
+	tpt-&gt;fd = INVALID_TRANSPORT;
+}
+
+/* Open Listener / Server */
+void transport_open_listener(lua_State *L, ServerHandle *handle)
+{
+	/* Get args &amp; Set up connection */
+	
+	handle-&gt;ltpt.fd = CON_UART_ID;
+}
+
+/* Open Connection / Client */
+int transport_open_connection(lua_State *L, Handle *handle)
+{
+	handle-&gt;tpt.fd = CON_UART_ID;
+	return 0;
+}
+
+/* Accept Connection */
+void transport_accept (Transport *tpt, Transport *atpt)
+{
+	struct exception e;
+	TRANSPORT_VERIFY_OPEN;
+	atpt-&gt;fd = tpt-&gt;fd;
+}
+
+
+
+void transport_read_buffer (Transport *tpt, u8 *buffer, int length)
+{
+	int n = 0;
+	int c;
+	struct exception e;
+	
+	while( n &lt; length )
+	{
+		TRANSPORT_VERIFY_OPEN;
+		c = platform_uart_recv( CON_UART_ID, CON_TIMER_ID, uart_timeout );
+				
+    if( c &lt; 0 )
+		{
+		  uart_timeout = 1000000;
+			e.errnum = ERR_NODATA;
+			e.type = nonfatal;
+			Throw( e );
+		}
+		else
+		{
+			buffer[ n ] = ( u8 ) c;
+			n++;
+		}
+  }
+	
+	uart_timeout = PLATFORM_UART_INFINITE_TIMEOUT;
+}
+
+void transport_write_buffer_low (Transport *tpt, const u8 *buffer, int length)
+{
+
+}
+
+void transport_write_buffer( Transport *tpt, const u8 *buffer, int length )
+{
+	int i;
+	struct exception e;
+	TRANSPORT_VERIFY_OPEN;
+	
+	for( i = 0; i &lt; length; i ++ )
+    platform_uart_send( CON_UART_ID, buffer[ i ] );
+}
+
+/* Check if data is available on connection without reading:
+ 		- 1 = data available, 0 = no data available */
+int transport_readable (Transport *tpt)
+{
+	return 1;
+}
+
+/* Check if transport is open:
+		- 1 = connection open, 0 = connection closed */
+int transport_is_open (Transport *tpt)
+{
+	return (tpt-&gt;fd != INVALID_TRANSPORT);
+}
+
+/* Shut down connection */
+void transport_close (Transport *tpt)
+{
+	tpt-&gt;fd = INVALID_TRANSPORT;
+}
+
+#endif
\ No newline at end of file

Modified: branches/luarpc/src/modules/luarpc.c
===================================================================
--- branches/luarpc/src/modules/luarpc.c	2009-06-09 20:15:05 UTC (rev 294)
+++ branches/luarpc/src/modules/luarpc.c	2009-06-15 03:30:01 UTC (rev 295)
@@ -14,13 +14,9 @@
 #include &quot;lualib.h&quot;
 #include &quot;lauxlib.h&quot;
 
-#ifndef LUARPC_STANDALONE
 #include &quot;platform.h&quot;
 #include &quot;platform_conf.h&quot;
 #include &quot;lrotable.h&quot;
-#else
-#include &quot;config.h&quot;
-#endif
 
 #include &quot;luarpc_rpc.h&quot;
 
@@ -75,8 +71,8 @@
   case ERR_EOF: return &quot;connection closed unexpectedly (\&quot;end of file\&quot;)&quot;;
   case ERR_CLOSED: return &quot;operation requested on a closed transport&quot;;
   case ERR_PROTOCOL: return &quot;error in the received LuaRPC protocol&quot;;
-	case ERR_COMMAND: return &quot;undefined RPC command&quot;;
-	case ERR_DATALINK: return &quot;transmission error at data link level&quot;;
+  case ERR_COMMAND: return &quot;undefined RPC command&quot;;
+  case ERR_DATALINK: return &quot;transmission error at data link level&quot;;
   case ERR_NODATA: return &quot;no data received when attempting to read&quot;;
   case ERR_BADFNAME: return &quot;function name is too long&quot;;
   default: return transport_strerror (n);
@@ -108,7 +104,7 @@
 static u8 transport_read_u8( Transport *tpt )
 {
   u8 b;
-	struct exception e;
+  struct exception e;
   TRANSPORT_VERIFY_OPEN;
   transport_read_buffer( tpt, &amp;b, 1 );
   return b;
@@ -119,7 +115,7 @@
 
 static void transport_write_u8( Transport *tpt, u8 x )
 {
-	struct exception e;
+  struct exception e;
   TRANSPORT_VERIFY_OPEN;
   transport_write_buffer (tpt,&amp;x,1);
 }
@@ -131,7 +127,7 @@
 {
   u8 b[4];
   u32 i;
-	struct exception e;
+  struct exception e;
   TRANSPORT_VERIFY_OPEN;
   transport_read_buffer ( tpt, b, 4 );
   i = ( b[ 0 ] &lt;&lt; 24 ) | (b[ 1 ] &lt;&lt; 16 ) | ( b[ 2 ] &lt;&lt; 8) | b[ 3 ];
@@ -144,13 +140,13 @@
 static void transport_write_u32 (Transport *tpt, u32 x)
 {
   u8 b[4];
-	struct exception e;
+  struct exception e;
   TRANSPORT_VERIFY_OPEN;
   b[0] = x &gt;&gt; 24;
   b[1] = x &gt;&gt; 16;
   b[2] = x &gt;&gt; 8;
   b[3] = x;
-  transport_write_buffer (tpt,b,4);
+  transport_write_buffer( tpt, b, 4 );
 }
 
 
@@ -165,7 +161,7 @@
 static double transport_read_double (Transport *tpt)
 {
   union DoubleBytes double_bytes;
-	struct exception e;
+  struct exception e;
   TRANSPORT_VERIFY_OPEN;
   /* @@@ handle endianness */
   transport_read_buffer ( tpt,double_bytes.b, sizeof( double ) );
@@ -177,9 +173,8 @@
 
 static void transport_write_double (Transport *tpt, double x)
 {
-  int n;
   union DoubleBytes double_bytes;
-	struct exception e;
+  struct exception e;
   TRANSPORT_VERIFY_OPEN;
   /* @@@ handle endianness */
   double_bytes.d = x;
@@ -204,8 +199,9 @@
 int check_num_args( lua_State *L, int desired_n )
 {
   int n = lua_gettop( L );   /* number of arguments on stack */
-  if ( n != desired_n ) {
-    char s[ 100 ];
+  if ( n != desired_n )
+  {
+    char s[ 100 ]; /* @@@ can we cut this down? */
     sprintf( s, &quot;must have %d argument%c&quot;, desired_n,
        ( desired_n == 1 ) ? '\0' : 's' );
     my_lua_error( L, s );
@@ -247,9 +243,10 @@
 
 enum
 {
-	RPC_CMD_CALL = 1,
-	RPC_CMD_GET,
-	RPC_CMD_CON
+  RPC_CMD_CALL = 1,
+  RPC_CMD_GET,
+  RPC_CMD_CON,
+  RPC_CMD_NEWINDEX
 };
 
 enum { RPC_PROTOCOL_VERSION = 3 };
@@ -265,7 +262,7 @@
 {
   lua_pushnil( L );  /* push first key */
   while ( lua_next( L, table_index ) ) 
-	{
+  {
     /* next key and value were pushed on the stack */
     write_variable( tpt, L, lua_gettop( L ) - 1 );
     write_variable( tpt, L, lua_gettop( L ) );
@@ -273,37 +270,30 @@
     lua_pop( L, 1 );
   }
 }
-/* STARTING POINT FOR SENDING FUNCTIONS OVER THE WIRE
-static int function_writer (lua_State *L, const void* b, size_t size, void* B) {
+
+static int writer( lua_State *L, const void* b, size_t size, void* B ) {
   (void)L;
   luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
   return 0;
 }
 
-
-static void str_dump (lua_State *L) {
+static void write_function( Transport *tpt, lua_State *L, int var_index )
+{
   luaL_Buffer b;
-  luaL_checktype(L, 1, LUA_TFUNCTION);
-  lua_settop(L, 1);
-  luaL_buffinit(L,&amp;b);
-  if (lua_dump(L, function_writer, &amp;b) != 0)
-    luaL_error(L, &quot;unable to dump given function&quot;);
-  luaL_pushresult(&amp;b);
-  return 1;
+  
+  /* push function onto stack, serialize to string */
+  lua_pushvalue( L, var_index );
+  luaL_buffinit( L, &amp;b );
+  lua_dump( L, writer, &amp;b ); /* deal with errors thrown at this level? */
+  /* put string representation on stack and send it */
+  luaL_pushresult( &amp;b );
+  write_variable( tpt, L, lua_gettop( L ) );
+  
+  /* Remove function &amp; dumped string from stack*/
+  lua_pop( L, 2 );
 }
 
 
-static void write_function (Transport *tpt, lua_State *L, int table_index)
-{
-  luaL_Buffer b;
-  luaL_checktype(L, table_index, LUA_TFUNCTION);
-  lua_settop(L, table_index);
-  luaL_buffinit(L,&amp;b);
-  if (lua_dump(L, function_writer, &amp;b) != 0)
-    luaL_error(L, &quot;unable to dump given function&quot;);
-  //int lua_dump (lua_State *L, lua_Writer writer, void *data);
-}
-*/
 
 /* write a variable at the given index in the stack. the index must be absolute
  * (i.e. positive).
@@ -312,60 +302,59 @@
 static void write_variable( Transport *tpt, lua_State *L, int var_index )
 {
   int stack_at_start = lua_gettop( L );
-
+  
   switch( lua_type( L, var_index ) )
-	{
-  	case LUA_TNUMBER:
-	    transport_write_u8( tpt, RPC_NUMBER );
-	    transport_write_double( tpt, lua_tonumber( L, var_index ) );
-	    break;
+  {
+    case LUA_TNUMBER:
+      transport_write_u8( tpt, RPC_NUMBER );
+      transport_write_double( tpt, lua_tonumber( L, var_index ) );
+      break;
 
-	  case LUA_TSTRING:
-		{
-	    const char *s;
-	    u32 len;
-	    transport_write_u8( tpt, RPC_STRING );
-	    s = lua_tostring( L, var_index );
-	    len = lua_strlen( L, var_index );
-	    transport_write_u32( tpt, len );
-	    transport_write_string( tpt, s, len );
-	    break;
-	  }
+    case LUA_TSTRING:
+    {
+      const char *s;
+      u32 len;
+      transport_write_u8( tpt, RPC_STRING );
+      s = lua_tostring( L, var_index );
+      len = lua_strlen( L, var_index );
+      transport_write_u32( tpt, len );
+      transport_write_string( tpt, s, len );
+      break;
+    }
 
-	  case LUA_TTABLE:
-	    transport_write_u8( tpt, RPC_TABLE );
-	    write_table( tpt, L, var_index );
-	    transport_write_u8( tpt, RPC_TABLE_END );
-	    break;
+    case LUA_TTABLE:
+      transport_write_u8( tpt, RPC_TABLE );
+      write_table( tpt, L, var_index );
+      transport_write_u8( tpt, RPC_TABLE_END );
+      break;
 
-	  case LUA_TNIL:
-	    transport_write_u8( tpt, RPC_NIL );
-	    break;
+    case LUA_TNIL:
+      transport_write_u8( tpt, RPC_NIL );
+      break;
 
-	  case LUA_TBOOLEAN:
-	    transport_write_u8( tpt,RPC_BOOLEAN );
-	    transport_write_u8( tpt, ( u8 )lua_toboolean( L, var_index ) );
-	    break;
+    case LUA_TBOOLEAN:
+      transport_write_u8( tpt,RPC_BOOLEAN );
+      transport_write_u8( tpt, ( u8 )lua_toboolean( L, var_index ) );
+      break;
 
-	  case LUA_TFUNCTION:
-	 /* transport_write_u8 (tpt,RPC_FUNCTION);
-	    write_function (tpt,L,var_index);
-	    transport_write_u8 (tpt,RPC_FUNCTION_END); */
-	    my_lua_error( L, &quot;can't pass functions to a remote function&quot; );
-	    break;
+    case LUA_TFUNCTION:
+      transport_write_u8( tpt, RPC_FUNCTION );
+      write_function( tpt, L, var_index );
+      transport_write_u8( tpt, RPC_FUNCTION_END );
+      break;
 
-	  case LUA_TUSERDATA:
-	    my_lua_error( L, &quot;can't pass user data to a remote function&quot; );
-	    break;
+    case LUA_TUSERDATA:
+      my_lua_error( L, &quot;can't pass user data to a remote function&quot; );
+      break;
 
-	  case LUA_TTHREAD:
-	    my_lua_error( L, &quot;can't pass threads to a remote function&quot; );
-	    break;
+    case LUA_TTHREAD:
+      my_lua_error( L, &quot;can't pass threads to a remote function&quot; );
+      break;
 
-	  case LUA_TLIGHTUSERDATA:
-	    my_lua_error( L, &quot;can't pass light user data to a remote function&quot; );
-	    break;
-	}
+    case LUA_TLIGHTUSERDATA:
+      my_lua_error( L, &quot;can't pass light user data to a remote function&quot; );
+      break;
+  }
   MYASSERT( lua_gettop( L ) == stack_at_start );
 }
 
@@ -378,15 +367,32 @@
   lua_newtable( L );
   table_index = lua_gettop( L );
   for ( ;; ) 
-	{
+  {
     if( !read_variable( tpt, L ) )
-			return;
+      return;
     read_variable( tpt, L );
     lua_rawset( L, table_index );
   }
 }
 
+static void read_function( Transport *tpt, lua_State *L )
+{
+  const char *b;
+  size_t len;
+  
+  for( ;; )
+  {
+    if( !read_variable( tpt, L ) )
+      return;
 
+    b = luaL_checklstring( L, -1, &amp;len );
+    luaL_loadbuffer( L, b, len, b );
+    lua_insert( L, -2 );
+    lua_pop( L, 1 );
+  }
+}
+
+
 /* read a variable and push in onto the stack. this returns 1 if a &quot;normal&quot;
  * variable was read, or 0 if an end-table marker was read (in which case
  * nothing is pushed onto the stack).
@@ -394,7 +400,7 @@
 
 static int read_variable( Transport *tpt, lua_State *L )
 {
-	struct exception e;
+  struct exception e;
   u8 type = transport_read_u8( tpt );
 
   switch( type )
@@ -412,14 +418,14 @@
       break;
 
     case RPC_STRING:
-		{
+    {
       u32 len = transport_read_u32( tpt );
       char *s = ( char * )alloca( len + 1 );
       transport_read_string( tpt, s, len );
       s[ len ] = 0;
       lua_pushlstring( L, s, len );
       break;
-		}
+    }
 
     case RPC_TABLE:
       read_table( tpt, L );
@@ -428,9 +434,16 @@
     case RPC_TABLE_END:
       return 0;
 
+    case RPC_FUNCTION:
+      read_function( tpt, L );
+      break;
+    
+    case RPC_FUNCTION_END:
+      return 0;
+
     default:
-			e.errnum = ERR_PROTOCOL;
-			e.type = fatal;
+      e.errnum = ERR_PROTOCOL;
+      e.type = fatal;
       Throw( e );
   }
   return 1;
@@ -445,7 +458,7 @@
 
 static void write_header( Transport *tpt )
 {
-	char header[ 5 ];
+  char header[ 5 ];
 
   /* write the protocol header */
   header[0] = 'L';
@@ -459,9 +472,9 @@
 
 static void read_header( Transport *tpt )
 {
-	struct exception e;
-	char header[ 5 ];
-	
+  struct exception e;
+  char header[ 5 ];
+  
   /* check that the header is ok */
   transport_read_string( tpt, header, sizeof( header ) );
   if( header[0] != 'L' ||
@@ -469,11 +482,11 @@
       header[2] != 'P' ||
       header[3] != 'C' ||
       header[4] != RPC_PROTOCOL_VERSION )
-	{
-		e.errnum = ERR_PROTOCOL;
-		e.type = nonfatal;
-		Throw( e );
-	}
+  {
+    e.errnum = ERR_PROTOCOL;
+    e.type = nonfatal;
+    Throw( e );
+  }
 }
 
 /****************************************************************************/
@@ -508,7 +521,7 @@
 }
 
 
-Handle * handle_create( lua_State *L )
+Handle *handle_create( lua_State *L )
 {
   Handle *h = ( Handle * )lua_newuserdata( L, sizeof( Handle ) );
   luaL_getmetatable( L, &quot;rpc.handle&quot; );
@@ -519,13 +532,14 @@
   return h;
 }
 
-static Helper * helper_create( lua_State *L, Handle *handle, const char *funcname )
+static Helper *helper_create( lua_State *L, Handle *handle, const char *funcname )
 {
-	Helper *h = ( Helper * )lua_newuserdata( L, sizeof( Helper ) );
+  Helper *h = ( Helper * )lua_newuserdata( L, sizeof( Helper ) );
   luaL_getmetatable( L, &quot;rpc.helper&quot; );
   lua_setmetatable( L, -2 );
   h-&gt;handle = handle;
-	h-&gt;lname = h-&gt;funcname;
+  h-&gt;parent = NULL;
+  h-&gt;nparents = 0;
   strncpy ( h-&gt;funcname, funcname, NUM_FUNCNAME_CHARS );
   return h;
 }
@@ -543,65 +557,115 @@
   if( lua_type( L, 2 ) != LUA_TSTRING )
     my_lua_error( L, &quot;can't index a handle with a non-string&quot; );
   s = lua_tostring( L, 2 );
-	if ( strlen( s ) &gt; NUM_FUNCNAME_CHARS - 1 )
-		my_lua_error( L, &quot;function name is too long&quot; );
-		
+  if ( strlen( s ) &gt; NUM_FUNCNAME_CHARS - 1 )
+    my_lua_error( L, &quot;function name is too long&quot; );
+    
   h = helper_create( L, ( Handle * )lua_touserdata( L, 1 ), s );
 
   /* return the helper object */
   return 1;
 }
 
+static int helper_newindex( lua_State *L );
 
-static int helper_get( lua_State *L )
+/* indexing a handle returns a helper */
+static int handle_newindex( lua_State *L )
 {
+  const char *s;
+  Helper *h;
+
+  MYASSERT( lua_gettop( L ) == 3 );
+  MYASSERT( lua_isuserdata( L, 1 ) &amp;&amp; ismetatable_type( L, 1, &quot;rpc.handle&quot; ) );
+
+  if( lua_type( L, 2 ) != LUA_TSTRING )
+    my_lua_error( L, &quot;can't index a handle with a non-string&quot; );
+  s = lua_tostring( L, 2 );
+  if ( strlen( s ) &gt; NUM_FUNCNAME_CHARS - 1 )
+    my_lua_error( L, &quot;function name is too long&quot; );
+  
+  h = helper_create( L, ( Handle * )lua_touserdata( L, 1 ), &quot;&quot; );
+	lua_replace(L, 1);
+
+  helper_newindex( L );
+
+  return 0;
+}
+
+/* replays series of indexes to remote side as a string */
+static void helper_remote_index( Helper *helper )
+{
+  int i, len;
+  Helper **hstack;
+  Transport *tpt = &amp;helper-&gt;handle-&gt;tpt;
+  
+  /* get length of name &amp; make stack of helpers */
+  len = strlen( helper-&gt;funcname );
+  if( helper-&gt;nparents &gt; 0 )
+  {
+    hstack = ( Helper ** )alloca( sizeof( Helper * ) * helper-&gt;nparents );
+    hstack[ helper-&gt;nparents - 1 ] = helper-&gt;parent;
+    len += strlen( hstack[ helper-&gt;nparents - 1 ]-&gt;funcname ) + 1;
+  
+    for(i = helper-&gt;nparents - 1 ; i &gt; 0 ; i -- )
+    {
+      hstack[ i - 1 ] = hstack[ i ]-&gt;parent;
+      len += strlen( hstack[ i ]-&gt;funcname ) + 1;
+    }
+  }
+  
+  transport_write_u32( tpt, len );
+  /* replay helper key names */     
+  if( helper-&gt;nparents &gt; 0)
+  {
+    for( i = 0 ; i &lt; helper-&gt;nparents ; i ++ )
+    {
+     transport_write_string( tpt, hstack[ i ]-&gt;funcname, strlen( hstack[ i ]-&gt;funcname ) );
+     transport_write_string( tpt, &quot;.&quot;, 1 ); 
+    }
+  }
+  transport_write_string( tpt, helper-&gt;funcname, strlen( helper-&gt;funcname ) );
+}
+
+
+static int helper_get(lua_State *L, Helper *helper )
+{
   struct exception e;
   int freturn = 0;
-  Helper *h;
-  Transport *tpt;
-  MYASSERT( lua_gettop( L ) &gt;= 1 );
-  MYASSERT( lua_isuserdata( L, 1 ) &amp;&amp; ismetatable_type( L, 1, &quot;rpc.helper&quot; ) );
+  Transport *tpt = &amp;helper-&gt;handle-&gt;tpt;
   
-  /* get helper object and its transport */
-  h = ( Helper * )lua_touserdata( L, 1 );
-  tpt = &amp;h-&gt;handle-&gt;tpt;
-
   Try
   {
-    int i,len,n;
-    u32 nret,ret_code;
-				
+    int len;        
     /* write function name */
-    len = strlen( h-&gt;funcname );
-		transport_write_u8( tpt, RPC_CMD_GET );
-    transport_write_u32 ( tpt, len );
-    transport_write_string( tpt, h-&gt;funcname, len );
+    len = strlen( helper-&gt;funcname );
+    transport_write_u8( tpt, RPC_CMD_GET );
+    helper_remote_index( helper );
 
-		/* read variable back */
+    /* read variable back */
     read_variable( tpt, L );
 
     freturn = 1;
   }
   Catch( e )
   {
-		switch( e.type )
-		{
-			case fatal:
-				if ( e.errnum == ERR_CLOSED )
-		      my_lua_error( L, &quot;can't refer to a remote function after the handle has been closed&quot; );
-				deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
-				transport_close( tpt );
-				break;
-			case nonfatal:
-				deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
-				lua_pushnil( L );
-				return 1;
-				break;
-			default:
-        deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
-				transport_close( tpt );
-				break;
-		}
+    switch( e.type )
+    {
+      case fatal:
+        if ( e.errnum == ERR_CLOSED )
+          my_lua_error( L, &quot;can't refer to a remote function after the handle has been closed&quot; );
+        deal_with_error( L, helper-&gt;handle, errorString( e.errnum ) );
+        transport_close( tpt );
+        break;
+      case nonfatal:
+        deal_with_error( L, helper-&gt;handle, errorString( e.errnum ) );
+        lua_pushnil( L );
+        return 1;
+        break;
+      default:
+        deal_with_error( L, helper-&gt;handle, errorString( e.errnum ) );
+        transport_close( tpt );
+        break;
+    }
   }
   return freturn;
 }
@@ -619,133 +683,180 @@
   /* get helper object and its transport */
   h = ( Helper * )lua_touserdata( L, 1 );
   tpt = &amp;h-&gt;handle-&gt;tpt;
-	
-	
-	/* @@@ ugly way to capture get calls, should find another way */
-	if( strcmp(&quot;get&quot;, h-&gt;lname ) == 0 )
-	{
-		*(h-&gt;lname - 1) = '\0'; /* scrub .get */
-		helper_get( L );
-		freturn = 1;
-	}
-	else
-	{
-  	Try
-	  {
-	    int i,len,n;
-	    u32 nret,ret_code;
+  
+  
+  /* @@@ ugly way to capture get calls, should find another way */
+  if( strcmp(&quot;get&quot;, h-&gt;funcname ) == 0 )
+  {
+    helper_get( L, h-&gt;parent );
+    freturn = 1;
+  }
+  else
+  {
+    Try
+    {
+      int i,len,n;
+      u32 nret,ret_code;
 
-	    /* first read out any pending return values for old async calls */
-	    for (; h-&gt;handle-&gt;read_reply_count &gt; 0; h-&gt;handle-&gt;read_reply_count--) {
-	      ret_code = transport_read_u8 (tpt);   /* return code */
-	      if( ret_code == 0 )
-	      {
-	        /* read return arguments, ignore everything we read */
-	        nret = transport_read_u32( tpt );
+      /* first read out any pending return values for old async calls */
+      for (; h-&gt;handle-&gt;read_reply_count &gt; 0; h-&gt;handle-&gt;read_reply_count--) {
+        ret_code = transport_read_u8 (tpt);   /* return code */
+        if( ret_code == 0 )
+        {
+          /* read return arguments, ignore everything we read */
+          nret = transport_read_u32( tpt );
         
-	        for (i=0; i &lt; ( ( int ) nret ); i++)
-	          read_variable (tpt,L);
+          for (i=0; i &lt; ( ( int ) nret ); i++)
+            read_variable (tpt,L);
         
-	        lua_pop (L,nret);
-	      }
-	      else
-	      {
-	        /* read error and handle it */
-	        u32 code = transport_read_u32 (tpt);
-	        u32 len = transport_read_u32 (tpt);
-	        char *err_string = (char*) alloca (len+1);
-	        transport_read_string( tpt, err_string, len );
-	        err_string[ len ] = 0;
+          lua_pop (L,nret);
+        }
+        else
+        {
+          /* read error and handle it */
+          u32 code = transport_read_u32( tpt );
+          u32 len = transport_read_u32( tpt );
+          char *err_string = ( char * )alloca( len + 1 );
+          transport_read_string( tpt, err_string, len );
+          err_string[ len ] = 0;
 
-	        deal_with_error( L, h-&gt;handle, err_string );
-	        freturn = 0;
-	      }
-	    }
+          deal_with_error( L, h-&gt;handle, err_string );
+          freturn = 0;
+        }
+      }
 
-	    /* write function name */
-	    len = strlen( h-&gt;funcname );
-			transport_write_u8( tpt, RPC_CMD_CALL );
-	    transport_write_u32 ( tpt, len );
-	    transport_write_string( tpt, h-&gt;funcname, len );
+      /* write function name */
+      transport_write_u8( tpt, RPC_CMD_CALL );
+      helper_remote_index( h );
 
-	    /* write number of arguments */
-	    n = lua_gettop( L );
-	    transport_write_u32( tpt, n - 1 );
+      /* write number of arguments */
+      n = lua_gettop( L );
+      transport_write_u32( tpt, n - 1 );
     
-	    /* write each argument */
-	    for( i = 2; i &lt;= n; i ++ )
-	      write_variable( tpt, L, i );
+      /* write each argument */
+      for( i = 2; i &lt;= n; i ++ )
+        write_variable( tpt, L, i );
 
-	    /* if we're in async mode, we're done */
-	    if ( h-&gt;handle-&gt;async )
-	    {
-	      h-&gt;handle-&gt;read_reply_count++;
-	      freturn = 0;
-	    }
+      /* if we're in async mode, we're done */
+      if ( h-&gt;handle-&gt;async )
+      {
+        h-&gt;handle-&gt;read_reply_count++;
+        freturn = 0;
+      }
 
-	    /* read return code */
-	    ret_code = transport_read_u8( tpt );
+      /* read return code */
+      ret_code = transport_read_u8( tpt );
 
-	    if ( ret_code== 0 )
-	    {
-	      /* read return arguments */
-	      nret = transport_read_u32( tpt );
+      if ( ret_code== 0 )
+      {
+        /* read return arguments */
+        nret = transport_read_u32( tpt );
       
-	      for ( i = 0; i &lt; ( (int ) nret ); i ++ )
-	        read_variable( tpt, L );
+        for ( i = 0; i &lt; ( (int ) nret ); i ++ )
+          read_variable( tpt, L );
       
-	      freturn = ( int )nret;
-	    }
-	    else
-	    {
-	      /* read error and handle it */
-	      u32 code = transport_read_u32( tpt );
-	      u32 len = transport_read_u32( tpt );
-	      char *err_string = ( char * )alloca( len + 1 );
-	      transport_read_string( tpt, err_string, len );
-	      err_string[ len ] = 0;
+        freturn = ( int )nret;
+      }
+      else
+      {
+        /* read error and handle it */
+        u32 code = transport_read_u32( tpt );
+        u32 len = transport_read_u32( tpt );
+        char *err_string = ( char * )alloca( len + 1 );
+        transport_read_string( tpt, err_string, len );
+        err_string[ len ] = 0;
 
-	      deal_with_error( L, h-&gt;handle, err_string );
-	      freturn = 0;
-	    }
-	  }
-	  Catch( e )
-	  {
-			switch( e.type )
-			{
-				case fatal:
-					if ( e.errnum == ERR_CLOSED )
-			      my_lua_error( L, &quot;can't refer to a remote function after the handle has been closed&quot; );
-					deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
-					transport_close( tpt );
-					break;
-				case nonfatal:
-					deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
-					lua_pushnil( L );
-					return 1;
-					break;
-				default:
-	        deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
-					transport_close( tpt );
-					break;
-			}
-	  }
-	}
+        deal_with_error( L, h-&gt;handle, err_string );
+        freturn = 0;
+      }
+    }
+    Catch( e )
+    {
+      switch( e.type )
+      {
+        case fatal:
+          if ( e.errnum == ERR_CLOSED )
+            my_lua_error( L, &quot;can't refer to a remote function after the handle has been closed&quot; );
+          deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
+          transport_close( tpt );
+          break;
+        case nonfatal:
+          deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
+          lua_pushnil( L );
+          return 1;
+          break;
+        default:
+          deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
+          transport_close( tpt );
+          break;
+      }
+    }
+  }
   return freturn;
 }
 
-static Helper * helper_append( lua_State *L, Helper *helper, const char *funcname )
+
+static int helper_newindex( lua_State *L )
 {
-	size_t plen;
-	Helper *h = ( Helper * )lua_newuserdata( L, sizeof( Helper ) );
+  struct exception e;
+  int freturn = 0;
+  Helper *h;
+  Transport *tpt;
+  MYASSERT( lua_isuserdata( L, -3 ) &amp;&amp; ismetatable_type( L, -3, &quot;rpc.helper&quot; ) );
+  MYASSERT( lua_isstring( L, -2 ) );
+  
+  /* get helper object and its transport */
+  h = ( Helper * )lua_touserdata( L, -3 );
+  tpt = &amp;h-&gt;handle-&gt;tpt;
+  
+  Try
+  {
+    int len;
+        
+    /* write function name */
+    len = strlen( h-&gt;funcname );
+    transport_write_u8( tpt, RPC_CMD_NEWINDEX );
+    helper_remote_index( h );
+
+    write_variable( tpt, L, lua_gettop( L ) - 1 );
+    write_variable( tpt, L, lua_gettop( L ) );
+
+    freturn = 0;
+  }
+  Catch( e )
+  {
+    switch( e.type )
+    {
+      case fatal:
+        if ( e.errnum == ERR_CLOSED )
+          my_lua_error( L, &quot;can't refer to a remote function after the handle has been closed&quot; );
+        deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
+        transport_close( tpt );
+        break;
+      case nonfatal:
+        deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
+        lua_pushnil( L );
+        return 1;
+        break;
+      default:
+        deal_with_error( L, h-&gt;handle, errorString( e.errnum ) );
+        transport_close( tpt );
+        break;
+    }
+  }
+  return freturn;
+}
+
+
+static Helper *helper_append( lua_State *L, Helper *helper, const char *funcname )
+{
+  Helper *h = ( Helper * )lua_newuserdata( L, sizeof( Helper ) );
   luaL_getmetatable( L, &quot;rpc.helper&quot; );
   lua_setmetatable( L, -2 );
   h-&gt;handle = helper-&gt;handle;
-  strncpy( h-&gt;funcname, helper-&gt;funcname, NUM_FUNCNAME_CHARS );
-	plen = strlen( h-&gt;funcname );
-	h-&gt;lname = &amp;h-&gt;funcname[ plen + 1 ];
-	strncat( h-&gt;funcname, &quot;.&quot;, NUM_FUNCNAME_CHARS - plen );
-	strncat( h-&gt;funcname, funcname, NUM_FUNCNAME_CHARS - ( plen + 1 ) );
+  h-&gt;parent = helper;
+  h-&gt;nparents = helper-&gt;nparents + 1;
+  strncpy ( h-&gt;funcname, funcname, NUM_FUNCNAME_CHARS );
   return h;
 }
 
@@ -761,16 +872,14 @@
   if( lua_type( L, 2 ) != LUA_TSTRING )
     my_lua_error( L, &quot;can't index a handle with a non-string&quot; );
   s = lua_tostring( L, 2 );
-	if ( strlen( s ) &gt; NUM_FUNCNAME_CHARS - 1 )
-		my_lua_error( L, &quot;function name is too long&quot; );
-	
-	h = helper_append( L, ( Helper * )lua_touserdata( L, 1 ), s );
+  if ( strlen( s ) &gt; NUM_FUNCNAME_CHARS - 1 )
+    my_lua_error( L, &quot;function name is too long&quot; );
+  
+  h = helper_append( L, ( Helper * )lua_touserdata( L, 1 ), s );
 
   return 1;
 }
 
-
-
 /****************************************************************************/
 /* server side handle userdata objects. */
 
@@ -780,7 +889,7 @@
   luaL_getmetatable( L, &quot;rpc.server_handle&quot; );
   lua_setmetatable( L, -2 );
 
-	h-&gt;link_errs = 0;
+  h-&gt;link_errs = 0;
 
   transport_init( &amp;h-&gt;ltpt );
   transport_init( &amp;h-&gt;atpt );
@@ -815,12 +924,12 @@
   
   Try
   {
-		handle = handle_create ( L );
-	  transport_open_connection( L, handle );
-		
-		transport_write_u8( &amp;handle-&gt;tpt, RPC_CMD_CON );
-		write_header( &amp;handle-&gt;tpt );
-		read_header( &amp;handle-&gt;tpt );
+    handle = handle_create ( L );
+    transport_open_connection( L, handle );
+    
+    transport_write_u8( &amp;handle-&gt;tpt, RPC_CMD_CON );
+    write_header( &amp;handle-&gt;tpt );
+    read_header( &amp;handle-&gt;tpt );
   }
   Catch( e )
   {     
@@ -863,12 +972,11 @@
 }
 
 
-
 /* rpc_async (handle,)
  *     this sets a handle's asynchronous calling mode (0/nil=off, other=on).
  *     (this is for the client only).
  */
-
+/* @@@ This should probably be adjusted to be in line with our new multiple command architecture */
 static int rpc_async (lua_State *L)
 {
   Handle *handle;
@@ -900,27 +1008,27 @@
   int i, stackpos, good_function, nargs;
   u32 len;
   char *funcname;
-	char *token = NULL;
+  char *token = NULL;
 
   /* read function name */
   len = transport_read_u32( tpt ); /* function name string length */ 
   funcname = ( char * )alloca( len + 1 );
   transport_read_string( tpt, funcname, len );
   funcname[ len ] = 0;
-
+    
   /* get function */
-	/* @@@ perhaps handle more like variables instead of using a long string? */
-	/* @@@ also strtok is not thread safe */
-	token = strtok( funcname, &quot;.&quot; );
-	lua_getglobal( L, token );
-	token = strtok( NULL, &quot;.&quot; );
-	while( token != NULL )
-	{
-		lua_getfield( L, -1, token );
-		token = strtok( NULL, &quot;.&quot; );
-	}
-	stackpos = lua_gettop( L ) - 1;
-	good_function = LUA_ISCALLABLE( L, -1 );
+  /* @@@ perhaps handle more like variables instead of using a long string? */
+  /* @@@ also strtok is not thread safe */
+  token = strtok( funcname, &quot;.&quot; );
+  lua_getglobal( L, token );
+  token = strtok( NULL, &quot;.&quot; );
+  while( token != NULL )
+  {
+    lua_getfield( L, -1, token );
+    token = strtok( NULL, &quot;.&quot; );
+  }
+  stackpos = lua_gettop( L ) - 1;
+  good_function = LUA_ISCALLABLE( L, -1 );
 
   /* read number of arguments */
   nargs = transport_read_u32( tpt );
@@ -934,17 +1042,17 @@
   {
     int nret, error_code;
     error_code = lua_pcall( L, nargs, LUA_MULTRET, 0 );
-		
+    
     /* handle errors */
     if ( error_code )
     {
-			size_t len;
-			const char *errmsg;
-			errmsg = lua_tolstring (L, -1, &amp;len);
-			transport_write_u8( tpt, 1 );
-			transport_write_u32( tpt, error_code );
-			transport_write_u32( tpt, len );
-			transport_write_string( tpt, errmsg, len );
+      size_t len;
+      const char *errmsg;
+      errmsg = lua_tolstring (L, -1, &amp;len);
+      transport_write_u8( tpt, 1 );
+      transport_write_u32( tpt, error_code );
+      transport_write_u32( tpt, len );
+      transport_write_string( tpt, errmsg, len );
     }
     else
     {
@@ -974,10 +1082,9 @@
 
 static void read_cmd_get( Transport *tpt, lua_State *L )
 {
-  int i;
   u32 len;
   char *funcname;
-	char *token = NULL;
+  char *token = NULL;
 
   /* read function name */
   len = transport_read_u32( tpt ); /* function name string length */ 
@@ -986,16 +1093,16 @@
   funcname[ len ] = 0;
 
   /* get function */
-	/* @@@ perhaps handle more like variables instead of using a long string? */
-	/* @@@ also strtok is not thread safe */
-	token = strtok( funcname, &quot;.&quot; );
-	lua_getglobal( L, token );
-	token = strtok( NULL, &quot;.&quot; );
-	while( token != NULL )
-	{
-		lua_getfield( L, -1, token );
-		token = strtok( NULL, &quot;.&quot; );
-	}
+  /* @@@ perhaps handle more like variables instead of using a long string? */
+  /* @@@ also strtok is not thread safe */
+  token = strtok( funcname, &quot;.&quot; );
+  lua_getglobal( L, token );
+  token = strtok( NULL, &quot;.&quot; );
+  while( token != NULL )
+  {
+    lua_getfield( L, -1, token );
+    token = strtok( NULL, &quot;.&quot; );
+  }
 
   /* return top value on stack */
   write_variable( tpt, L, lua_gettop( L ) );
@@ -1005,6 +1112,49 @@
 }
 
 
+static void read_cmd_newindex( Transport *tpt, lua_State *L )
+{
+  u32 len;
+  char *funcname;
+  char *token = NULL;
+
+  /* read function name */
+  len = transport_read_u32( tpt ); /* function name string length */ 
+  funcname = ( char * )alloca( len + 1 );
+  transport_read_string( tpt, funcname, len );
+  funcname[ len ] = 0;
+
+  /* get function */
+  /* @@@ perhaps handle more like variables instead of using a long string? */
+  /* @@@ also strtok is not thread safe */
+  if( strlen( funcname ) &gt; 0 ) /*  */
+  {
+    token = strtok( funcname, &quot;.&quot; );
+    lua_getglobal( L, token );
+    token = strtok( NULL, &quot;.&quot; );
+    while( token != NULL )
+    {
+      lua_getfield( L, -1, token );
+      token = strtok( NULL, &quot;.&quot; );
+    }
+    read_variable( tpt, L ); /* key */
+    read_variable( tpt, L ); /* value */  
+    lua_settable( L, -3 ); /* set key to value on indexed table */
+  }
+  else
+  {
+    read_variable( tpt, L ); /* key */
+    read_variable( tpt, L ); /* value */  
+    lua_setglobal( L, lua_tostring( L, -2 ) );
+  }
+  
+
+
+  /* empty the stack */
+  lua_settop ( L, 0 );
+}
+
+
 static ServerHandle *rpc_listen_helper( lua_State *L )
 {
   struct exception e;
@@ -1031,7 +1181,6 @@
 
 
 /* rpc_listen (port) --&gt; server_handle */
-
 static int rpc_listen( lua_State *L )
 {
   ServerHandle *handle;
@@ -1045,7 +1194,6 @@
 
 
 /* rpc_peek (server_handle) --&gt; 0 or 1 */
-
 static int rpc_peek( lua_State *L )
 {
   ServerHandle *handle;
@@ -1094,25 +1242,28 @@
     {
       Try
       {
-				switch ( transport_read_u8( &amp;handle-&gt;atpt ) )
-				{
-					case RPC_CMD_CALL:
-						read_cmd_call( &amp;handle-&gt;atpt, L );
-						break;
-					case RPC_CMD_GET:
-						read_cmd_get( &amp;handle-&gt;atpt, L );
-						break;
-					case RPC_CMD_CON: /*  @@@ allow client to &quot;reconnect&quot;, should support better mechanism */
-						read_header( &amp;handle-&gt;atpt );
-						write_header( &amp;handle-&gt;atpt );
-						break;
-					default:
-						e.type = nonfatal;
-						e.errnum = ERR_COMMAND;
-						Throw( e );
-				}
-				
-				handle-&gt;link_errs = 0;
+        switch ( transport_read_u8( &amp;handle-&gt;atpt ) )
+        {
+          case RPC_CMD_CALL:
+            read_cmd_call( &amp;handle-&gt;atpt, L );
+            break;
+          case RPC_CMD_GET:
+            read_cmd_get( &amp;handle-&gt;atpt, L );
+            break;
+          case RPC_CMD_CON: /*  @@@ allow client to &quot;reconnect&quot;, should support better mechanism */
+            read_header( &amp;handle-&gt;atpt );
+            write_header( &amp;handle-&gt;atpt );
+            break;
+          case RPC_CMD_NEWINDEX:
+            read_cmd_newindex( &amp;handle-&gt;atpt, L );
+            break;
+          default:
+            e.type = nonfatal;
+            e.errnum = ERR_COMMAND;
+            Throw( e );
+        }
+        
+        handle-&gt;link_errs = 0;
       }
       Catch( e )
       {
@@ -1121,23 +1272,23 @@
          */
         transport_close( &amp;handle-&gt;atpt );
 
-				switch( e.type )
-				{
-					case fatal:
-						Throw( e );
-						
-					case nonfatal:
-						handle-&gt;link_errs++;
-						if ( handle-&gt;link_errs &gt; MAX_LINK_ERRS )
-						{
-							handle-&gt;link_errs = 0;
-							Throw( e );
-						}
-						break;
-						
-					default: 
-						Throw( e );
-				}
+        switch( e.type )
+        {
+          case fatal:
+            Throw( e );
+            
+          case nonfatal:
+            handle-&gt;link_errs++;
+            if ( handle-&gt;link_errs &gt; MAX_LINK_ERRS )
+            {
+              handle-&gt;link_errs = 0;
+              Throw( e );
+            }
+            break;
+            
+          default: 
+            Throw( e );
+        }
       }
     }
     else
@@ -1145,35 +1296,35 @@
       /* if accepting transport is not open, accept a new connection from the
        * listening transport.
        */
-			transport_accept( &amp;handle-&gt;ltpt, &amp;handle-&gt;atpt );
-			
-			switch ( transport_read_u8( &amp;handle-&gt;atpt ) )
-			{
-				case RPC_CMD_CON:
-					read_header( &amp;handle-&gt;atpt );
-					write_header( &amp;handle-&gt;atpt );
-					break;
-				default: /* connection must be established to issue any other commands */
-					e.type = nonfatal;
-					e.errnum = ERR_COMMAND;
-					Throw( e );
-			}
+      transport_accept( &amp;handle-&gt;ltpt, &amp;handle-&gt;atpt );
+      
+      switch ( transport_read_u8( &amp;handle-&gt;atpt ) )
+      {
+        case RPC_CMD_CON:
+          read_header( &amp;handle-&gt;atpt );
+          write_header( &amp;handle-&gt;atpt );
+          break;
+        default: /* connection must be established to issue any other commands */
+          e.type = nonfatal;
+          e.errnum = ERR_COMMAND;
+          Throw( e );
+      }
     }
   }
   Catch( e )
   {
-		switch( e.type )
-		{
-			case fatal:
-				server_handle_shutdown( handle );
-				deal_with_error( L, 0, errorString( e.errnum ) );
-				break;
-			case nonfatal:
-				transport_close( &amp;handle-&gt;atpt );
-				break;
-			default:
+    switch( e.type )
+    {
+      case fatal:
+        server_handle_shutdown( handle );
+        deal_with_error( L, 0, errorString( e.errnum ) );
+        break;
+      case nonfatal:
+        transport_close( &amp;handle-&gt;atpt );
+        break;
+      default:
         Throw( e );
-		}
+    }
   }
 }
 
@@ -1251,6 +1402,7 @@
 const LUA_REG_TYPE rpc_handle[] =
 {
   { LSTRKEY( &quot;__index&quot; ), LFUNCVAL( handle_index ) },
+  { LSTRKEY( &quot;__newindex&quot;), LFUNCVAL( handle_newindex )},
   { LNILKEY, LNILVAL }
 };
 
@@ -1258,6 +1410,7 @@
 {
   { LSTRKEY( &quot;__call&quot; ), LFUNCVAL( helper_call ) },
   { LSTRKEY( &quot;__index&quot; ), LFUNCVAL( helper_index ) },
+  { LSTRKEY( &quot;__newindex&quot; ), LFUNCVAL( helper_newindex ) },
   { LNILKEY, LNILVAL }
 };
 
@@ -1276,6 +1429,9 @@
   {  LSTRKEY( &quot;peek&quot; ), LFUNCVAL( rpc_peek ) },
   {  LSTRKEY( &quot;dispatch&quot; ), LFUNCVAL( rpc_dispatch ) },
   {  LSTRKEY( &quot;rpc_async&quot; ), LFUNCVAL( rpc_async ) },
+#if LUA_OPTIMIZE_MEMORY &gt; 0
+/*  {  LSTRKEY(&quot;mode&quot;), LSTRVAL( LUARPC_MODE ) }, */
+#endif // #if LUA_OPTIMIZE_MEMORY &gt; 0
   { LNILKEY, LNILVAL }
 };
 
@@ -1283,11 +1439,13 @@
 LUALIB_API int luaopen_luarpc(lua_State *L)
 {
 #if LUA_OPTIMIZE_MEMORY &gt; 0
-	luaL_rometatable(L, &quot;rpc.helper&quot;, (void*)rpc_helper);
-	luaL_rometatable(L, &quot;rpc.handle&quot;, (void*)rpc_handle);
-	luaL_rometatable(L, &quot;rpc.server_handle&quot;, (void*)rpc_server_handle);
+  luaL_rometatable(L, &quot;rpc.helper&quot;, (void*)rpc_helper);
+  luaL_rometatable(L, &quot;rpc.handle&quot;, (void*)rpc_handle);
+  luaL_rometatable(L, &quot;rpc.server_handle&quot;, (void*)rpc_server_handle);
 #else
   luaL_register( L, &quot;rpc&quot;, rpc_map );
+  lua_pushstring( L, LUARPC_MODE );
+  lua_setfield(L, -2, &quot;mode&quot;);
 
   luaL_newmetatable( L, &quot;rpc.helper&quot; );
   luaL_register( L, NULL, rpc_helper );
@@ -1305,6 +1463,7 @@
 static const luaL_reg rpc_handle[] =
 {
   { &quot;__index&quot;, handle_index },
+  { &quot;__newindex&quot;, handle_newindex },
   { NULL, NULL }
 };
 
@@ -1312,6 +1471,7 @@
 {
   { &quot;__call&quot;, helper_call },
   { &quot;__index&quot;, helper_index },
+  { &quot;__newindex&quot;, helper_newindex },
   { NULL, NULL }
 };
 
@@ -1337,6 +1497,8 @@
 LUALIB_API int luaopen_luarpc(lua_State *L)
 {
   luaL_register( L, &quot;rpc&quot;, rpc_map );
+  lua_pushstring(L, LUARPC_MODE);
+  lua_setfield(L, -2, &quot;mode&quot;);
 
   luaL_newmetatable( L, &quot;rpc.helper&quot; );
   luaL_register( L, NULL, rpc_helper );
@@ -1351,4 +1513,4 @@
 
 #endif
 
-#endif
\ No newline at end of file
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000250.html">[Elua-svn] r294 - in branches/coco: . src/lua
</A></li>
	<LI>Next message: <A HREF="000252.html">[Elua-svn] r296 - in branches/luarpc: . src/lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#251">[ date ]</a>
              <a href="thread.html#251">[ thread ]</a>
              <a href="subject.html#251">[ subject ]</a>
              <a href="author.html#251">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
