<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r334 - in trunk/doc: . arch_platform en luadoc wb
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r334%20-%20in%20trunk/doc%3A%20.%20arch_platform%20en%20luadoc%20wb&In-Reply-To=%3C200906291643.n5TGh534028457%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000289.html">
   <LINK REL="Next"  HREF="000291.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r334 - in trunk/doc: . arch_platform en luadoc wb</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r334%20-%20in%20trunk/doc%3A%20.%20arch_platform%20en%20luadoc%20wb&In-Reply-To=%3C200906291643.n5TGh534028457%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r334 - in trunk/doc: . arch_platform en luadoc wb">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Mon Jun 29 18:43:05 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000289.html">[Elua-svn] r333 - in trunk/doc: . wb_img wb_img/index_en_files	wb_img/index_en_files/news_data wb_img/index_en_files/wb_bar_en_data	wb_img/index_en_files/wb_title_en_data	wb_img/index_en_files/wb_tree_en_data
</A></li>
        <LI>Next message: <A HREF="000291.html">[Elua-svn] r335 - in trunk/doc: . en luadoc wb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#290">[ date ]</a>
              <a href="thread.html#290">[ thread ]</a>
              <a href="subject.html#290">[ subject ]</a>
              <a href="author.html#290">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-06-29 18:42:56 +0200 (Mon, 29 Jun 2009)
New Revision: 334

Added:
   trunk/doc/luadoc/
   trunk/doc/luadoc/arch_platform_cpu.lua
   trunk/doc/luadoc/arch_platform_eth.lua
   trunk/doc/luadoc/arch_platform_ll.lua
   trunk/doc/luadoc/arch_platform_pio.lua
   trunk/doc/luadoc/arch_platform_pwm.lua
   trunk/doc/luadoc/arch_platform_spi.lua
   trunk/doc/luadoc/arch_platform_timers.lua
   trunk/doc/luadoc/arch_platform_uart.lua
   trunk/doc/luadoc/template.lua
Removed:
   trunk/doc/arch_platform/arch_platform_cpu.lua
   trunk/doc/arch_platform/arch_platform_eth.lua
   trunk/doc/arch_platform/arch_platform_ll.lua
   trunk/doc/arch_platform/arch_platform_pio.lua
   trunk/doc/arch_platform/arch_platform_pwm.lua
   trunk/doc/arch_platform/arch_platform_spi.lua
   trunk/doc/arch_platform/arch_platform_template.lua
   trunk/doc/arch_platform/arch_platform_timers.lua
   trunk/doc/arch_platform/arch_platform_uart.lua
Modified:
   trunk/doc/build_dist_doc.sh
   trunk/doc/builddoc.lua
   trunk/doc/en/building.html
   trunk/doc/en/refman.html
   trunk/doc/wb/wb_usr_template.lua
Log:
working on the docs, still

Deleted: trunk/doc/arch_platform/arch_platform_cpu.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_cpu.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_cpu.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,31 +0,0 @@
--- eLua platform interface - CPU
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - CPU&quot;,
-
-  -- Menu name
-  menu_name = &quot;CPU&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the CPU and its functional modules (interrupt controller, memory controller and others).&quot;,
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;void #platform_cpu_enable_interrupts#();&quot;,
-      desc = &quot;Enable global interrupt on the CPU.&quot;
-    },
-
-    { sig = &quot;void #platform_cpu_disable_interrupts#();&quot;,
-      desc = &quot;Disable global interrupts on the CPU.&quot;
-    },
-
-    { sig = &quot;u32 #platform_cpu_get_frequency#();&quot;,
-      desc = &quot;Get the CPU frequency.&quot;,
-      ret = &quot;the CPU $core$ frequency (in hertz).&quot;
-    },
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_eth.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_eth.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_eth.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,98 +0,0 @@
--- eLua platform interface - Ethernet support
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - Ethernet support&quot;,
-
-  -- Menu name
-  menu_name = &quot;Ethernet&quot;,
-
-  -- Overview
-  overview = [[&lt;font color=&quot;red&quot;&gt;$NOTE$: TCP/IP support is experimental in eLua. Although functional, it's quite incomplete at the moment.&lt;/font&gt;&lt;/p&gt;
-  &lt;p&gt;This part of the platform interface groups functions related to accessing the Ethernet interface (internal or external) of the CPU. Note that unlike the
-  other parts of the platform interface this one is dedicated for TCP/IP support and thus it does not correspond directly to an eLua module, although
-  the @##@net module@ is implemented with functions that rely on this part of the platform interface. Currently only
-  the ^<A HREF="http://www.sics.se/~~adam/uip/index.php/Main_Page^uIP^">http://www.sics.se/~~adam/uip/index.php/Main_Page^uIP^</A> TCP/IP stack is supported by eLua.&lt;/p&gt;
-  &lt;p&gt;uIP is implemented in eLua using two hardware interrupts (that should be available on your platform): the Ethernet receive interrupt (to handle
-  incoming packets) and a timer interrupt (timers are used internally by uIP). However, the uIP main loop is only called from the Ethernet interrupt handler
-  in eLua, so in order to acknowledge the timer interrupt (as well as to provide some optimizations) a function that &quot;forces&quot; an Ethernet interrupt
-  must also be provided by the platform interface (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_eth_force_interrupt at here</A>@ for details).&lt;/p&gt;
-  &lt;p&gt;To put everything together, part of the Ethernet platform interface for the $m3s$ platform is given below:&lt;/p&gt;
-  ~u32 platform_eth_get_elapsed_time()
-  {
-    if( eth_timer_fired )
-    {
-      eth_timer_fired = 0;
-      return SYSTICKMS;
-    }
-    else
-      return 0;
-  }
-
-  void SysTickIntHandler()
-  {
-    // Handle virtual timers
-    cmn_virtual_timer_cb();
-
-    // Indicate that a SysTick interrupt has occurred.
-    eth_timer_fired = 1;
-
-    // Generate a fake Ethernet interrupt.  This will perform the actual work
-    // of incrementing the timers and taking the appropriate actions.
-    &lt;b&gt;platform_eth_force_interrupt();&lt;/b&gt;
-  }
-
-  void EthernetIntHandler()
-  {
-    u32 temp;
-
-    // Read and Clear the interrupt.
-    temp = EthernetIntStatus( ETH_BASE, false );
-    EthernetIntClear( ETH_BASE, temp );
-
-    // Call the UIP main loop
-    &lt;b&gt;elua_uip_mainloop();&lt;/b&gt;
-  }~&lt;p&gt;]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;void #platform_eth_send_packet#( const void* src, u32 size )&quot;,
-      desc = &quot;Sends an Ethernet packet to the network&quot;,
-      args = 
-      {
-        { name = &quot;src&quot;, desc = &quot;start address of the Ethernet packet&quot; },
-        { name = &quot;size&quot;, desc = &quot;size of the Ethernet packet&quot; }
-      },
-    },
-
-    { sig = &quot;u32 #platform_eth_get_packet_nb#( void* buf, u32 maxlen );&quot;,
-      desc = &quot;Non-blocking read of an Ethernet packet from the network&quot;,
-      args = 
-      {
-        { name = &quot;buf&quot;, desc = &quot;start address of the receive buffer&quot; },
-        { name = &quot;maxlen&quot;, desc = &quot;maximum length of the Ethernet packet&quot; },
-      },
-      ret = 
-      {
-        &quot;the size of the read packet or 0 if no packet is available&quot;
-      }
-    },
-
-    { sig = &quot;void #platform_eth_force_interrupt#();&quot;,
-      desc = &quot;Force the Ethernet interrupt on the platform (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at overview</A>@ above for details)&quot;,
-    },
-
-    { sig = &quot;u32 #platform_eth_get_elapsed_time#();&quot;,
-      desc = [[Get the elapsed time (in ms) since the last invocation of the uIP main loop ($elua_uip_mainloop$, from which this function is called). See @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at overview</A>@ for a possible 
-  implementation of this function).]], 
-      ret = 
-      { 
-        &quot;0 if the uIP loop was called because of Ethernet activity, not because a timer expired&quot;,
-        &quot;the Ethernet timer perios in ms (which indicates timer activity)&quot;
-      },
-    }
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_ll.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_ll.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_ll.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,92 +0,0 @@
--- eLua platform interface - low level functions
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - low level functions&quot;,
-
-  -- Menu title
-  menu_name = &quot;Low-level&quot;,
-
-  -- Overview
-  overview = [[
-  This part of the platform interface deals contains a small set of &quot;low level functions&quot; that are used to &quot;couple&quot; the eLua port with the
-  target system. No eLua module exposes these functions, as they are strictly used for porting and do not provide any other functionality.
-  ]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// Error / status codes
-enum
-{
-  PLATFORM_ERR,
-  PLATFORM_OK,
-  PLATFORM_UNDERFLOW = -1
-};]],
-      name = &quot;Status codes&quot;,
-      desc = [[
-  This enum defines the possible return values of the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_init at platform_init</A>@ function (although only $PLATFORM_ERR$ and $PLATFORM_OK$ should be 
-  returned from $platform_init$).
-  ]]
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_init#();&quot;,
-      desc = [[This is the platform-specific initialization code. It is the first function called from %main()% ($src/main.c$) and it should handle
-  all the platform initialization sequence, included (but not limited to) setting up the proper clocks, initializing the interrupt subsystem,
-  setting up various peripherals and so on. Although platform specific, this function has a common part named %cmn_platform_init% (implemented 
-  in $src/common.c$) that initializes terminal support over serial connections, as well as the XMODEM and TERM components 
-  (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at here</A>@ for details). If you need any of these, you need to call %cmn_platform_init% at the end of your 
-  %platform_init% function, $after$ initializing all the peripherals (in particular the UART used for the serial connection).&lt;br&gt;
-  An implementation skeleton for this function is given below:&lt;/p&gt;
-  ~int platform_init()
-  {
-    ............. // perform all your initializations here
-    cmn_platform_init(); // call the common initialiation code
-    return PLATFORM_OK;
-  }~&lt;p&gt;]],
-      ret = 
-      {
-         &quot;$PLATFORM_OK$ for success&quot;,
-         [[$PLATFORM_ERR$ if an error occured. If $PLATFORM_ERR$ is returned,  %main% will block in an infinite loop right 
-  after calling this function, so you should return $PLATFORM_ERR$ only for serious errors]],
-      }, 
-    },
-
-    { sig = &quot;void* #platform_get_last_free_ram#( unsigned id );&quot;,
-      desc = [[Returns the start address of a free RAM area in the system (this is the RAM that will be used by any part of the code that uses malloc(), 
-  a good example being the Lua interpreter itself). There can be multiple free RAM areas in the system (for example the internal MCU RAM and external 
-  RAM chips).  Implemented in $src/common.c$, it uses the the $MEM_START_ADDRESS$ macro that must be defined in the platform's $platform_conf.h$
-  file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). This macro must be defined as an array that contains all the start addresses of 
-  free RAM in the system. For internal RAM, this is generally handled by a linker exported symbol (named $end$ in many eLua ports) which 
-  points to the firs RAM address after all the constant and non-constant program data. An example is given below:&lt;/p&gt;
-  ~#define MEM_START_ADDRESS     { ( void* )end }~&lt;p&gt;]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the identifier of the RAM area&quot; },
-      },
-      ret = &quot;the start address of the given memory area&quot;,   
-    },
-
-    { sig = &quot;void* #platform_get_last_free_ram#( unsigned id );&quot;,
-      desc = [[Returns the last address of a free RAM area in the system (this is the RAM that will be used by any part of the code that uses malloc(), 
-  a good example being the Lua interpreter itself). There can be multiple free RAM areas in the system (for example the internal MCU RAM and external 
-  RAM chips). Implemented in $src/common.c$, it uses the the $MEM_END_ADDRESS$ macro that must be defined in the platform's $platform_conf.h$
-  file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). This macro must be defined as an array that contains all the end addresses of 
-  free RAM in the system. For internal RAM, this is generally set as the last RAM memory address minus the size of the system stack(s). An example is 
-  given below:&lt;/p&gt;
-  ~#define MEM_END_ADDRESS       { ( void* )( SRAM_BASE + 0x10000 - STACK_SIZE_TOTAL - 1 ) }~&lt;p&gt;]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the identifier of the RAM area&quot; },
-      },
-      ret = &quot;the end address of the given memory area&quot;,   
-    },
-
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_pio.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_pio.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_pio.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,113 +0,0 @@
--- eLua platform interface - PIO
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - PIO&quot;,
-
-  -- Menu name
-  menu_name = &quot;PIO&quot;,
-
-  -- OverviewA
-  overview = &quot;This part of the platform interface deals with PIO (Programmable Input Output) operations, thus letting the user access the low level input/output facilities of the host MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[enum
-{
-  // Pin operations
-  PLATFORM_IO_PIN_SET,                  $// Set the pin to 1$
-  PLATFORM_IO_PIN_CLEAR,                $// Clear the pin (set it to 0)$
-  PLATFORM_IO_PIN_GET,                  $// Get the value of the pin$
-  PLATFORM_IO_PIN_DIR_INPUT,            $// Make the pin an input$
-  PLATFORM_IO_PIN_DIR_OUTPUT,           $// Make the pin an output$
-  PLATFORM_IO_PIN_PULLUP,               $// Activate the pullup on the pin$
-  PLATFORM_IO_PIN_PULLDOWN,             $// Activate the pulldown on the pin$
-  PLATFORM_IO_PIN_NOPULL,               $// Disable all pullups/pulldowns on the pin$
-  // Port operations
-  PLATFORM_IO_PORT_SET_VALUE,           $// Set port value$
-  PLATFORM_IO_PORT_GET_VALUE,           $// Get port value$
-  PLATFORM_IO_PORT_DIR_INPUT,           $// Set port as input$
-  PLATFORM_IO_PORT_DIR_OUTPUT           $// Set port as output$
-}; ]],
-      name = &quot;PIO operations&quot;,
-      desc = [[These are the operations that can be executed by the PIO subsystem on both ports and pins. They are given as arguments to the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_pio_op at platform_pio_op</A>@ function 
-  shown below. ##TODO: document read in/read out if we keep that]]
-    },
-
-    { text = &quot;typedef u32 pio_type;&quot;,
-      name = &quot;PIO data type&quot;,
-      desc = [[This is the type used for the actual I/O operations. Currently defined as an unsigned 32-bit type, thus no port can have more than 32 pins. If this happens, it is possible to split 
-  it in two or more parts and adding the new parts as &quot;virtual ports&quot; (logical ports that don't have a direct hardware equivalent). The &quot;virtual port&quot; technique is used in the AVR32 backend.]]
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_pio_has_port#( unsigned port );&quot;,
-      desc = [[Checks if the platform has the hardware port specified as argument. Implemented in %src/common.c%, it uses the $NUM_PIO$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_PIO   4      $// The platform has 4 hardware PIO ports$~&lt;p&gt; ]],
-      args = 
-      {
-        { name = &quot;port&quot;, desc = &quot;the port ID&quot; },
-      },
-      ret = &quot;1 if the port exists, 0 otherwise&quot;,
-    },
-
-    { sig = &quot;int #platform_pio_has_pin#( unsigned port, unsigned pin );&quot;,
-      desc = [[Checks if the platform has the hardware port and pin specified as arguments. Implemented in %src/common.c%, it uses the $NUM_PIO$ macro to check the validity
-  of the port and the $PIO_PINS_PER_PORT$ or $PIO_PIN_ARRAY$ macros to check the validity of the pin. The macros must be defined in the platform's $platform_conf.h$ file
-  (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details).
-  &lt;ul&gt;
-    &lt;li&gt;use $PIO_PINS_PER_PORT$ when all the ports of the MCU have the same number of pins. For example:
-      ~#define PIO_PINS_PER_PORT    8   $// Each port has 8 pins$~&lt;/li&gt;
-    &lt;li&gt;use $PIO_PIN_ARRAY$ when different ports of the MCU have different number of pins. For example:
-      ~#define PIO_PIN_ARRAY    { 4, 4, 2, 6 } $// Port 0 has 4 pins, port 1 has 4 pins, port 2 has 2 pins, port 3 has 6 pins$~&lt;/li&gt;
-  &lt;/ul&gt;]],
-      args = 
-      {
-        { name = &quot;port&quot;, desc = &quot;the port ID&quot; },
-        { name = &quot;pin&quot;, desc = &quot;the pin number&quot; },
-      },
-      ret = &quot;1 if the pin exists, 0 otherwise&quot;,
-    },
-
-    { sig = &quot;const char* #platform_pio_get_prefix#( unsigned port );&quot;,
-      desc = [[Get the port prefix. Used to establish if the port notation uses numbers (P0, P1, P2...) or letters (PA, PB, PC...). Implemented in %src/common.c%, it uses the 
-  $PIO_PREFIX$ macro that must be defined in the platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). The value of this macro can be either '0' (for
-  numeric notation) or 'A' (for letter notation). For example:
-  ~#define PIO_PREFIX    'A'   $// Use PA, PB, PC ... for port notation$~&lt;p&gt;]],
-      args = 
-      {
-        { name = &quot;port&quot;, desc = &quot;the port ID&quot; }
-      },
-      ret = &quot;the port prefix (either '0' or 'A')&quot;,  
-    },
-
-    { sig = &quot;pio_type #platform_pio_op#( unsigned port, pio_type pinmask, int op );&quot;,
-      link = &quot;platform_pio_op&quot;,
-      desc = &quot;This is the function that does the actual I/O work. It is implemented in the platform's own porting layer (%platform.c%, see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ports at here</A>@ for more details).&quot;,
-      args = 
-      {
-        { name = &quot;port&quot;, desc = &quot;the port number&quot; },
-        { name = &quot;pinmask&quot;, desc = [[has different meanings:
-  &lt;ul&gt;
-    &lt;li&gt;for $pin operations$ it is the mask of pins in the operation. Each pin on which the function action is executed is encoded with an 1 in the corresponding bit position 
-        of the pinmask.&lt;/li&gt;
-    &lt;li&gt;for $port operations$ it is only meaningful for $PLATFORM_IO_PORT_SET_VALUE$ and in this case it specifies the new value of the port.&lt;/li&gt;
-  &lt;/ul&gt;]]},
-       { name = &quot;op&quot;, desc = &quot;specifies the I/O operations, as specified @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pio_operations at here</A>@.&quot; },
-      },
-     ret = 
-     {
-       &quot;an actual value for $PLATFORM_IO_PIN_GET$ (0 or 1) and $PLATFORM_IO_PORT_GET$ (the value of the port).&quot;,
-       [[an error flag for all the other operations: 1 if the operation succeeded, 0 otherwise. For example, a platform that doesn't have pulldowns on its ports will always return a 0
-        when caled with the $PLATFORM_IO_PIN_PULLDOWN$ operation.]]
-     }
-    },
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_pwm.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_pwm.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_pwm.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,79 +0,0 @@
--- eLua platform interface - PWM
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - PWM&quot;,
-
-  -- Menu name
-  menu_name = &quot;PWM&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the PWM channel(s) of the MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// PWM operations
-enum
-{
-  PLATFORM_PWM_OP_START,
-  PLATFORM_PWM_OP_STOP,
-  PLATFORM_PWM_OP_SET_CLOCK,
-  PLATFORM_PWM_OP_GET_CLOCK
-} ]],
-      name = &quot;PWM operations&quot;,
-      desc = &quot;This enum lists all the operations that can be executed on a given PWM channel.&quot;
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_pwm_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the PWM channel specified as argument. Implemented in %src/common.c%, it uses the $NUM_PWM$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_PWM   4      $// The platform has 4 PWM channels$~&lt;p&gt; ]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;PWM channel ID&quot; },
-      },
-      ret = &quot;1 if the specified PWM channel exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;u32 #platform_pwm_setup#( unsigned id, u32 frequency, unsigned duty );&quot;,
-      desc = &quot;Sets up a PWM channel&quot;,
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;PWM channel ID&quot; },
-        { name = &quot;frequency&quot;, desc = &quot;PWM channel frequency (in hertz)&quot; },
-        { name = &quot;duty&quot;, desc = &quot;PWM channel duty cycle, specified as percent (from 0 to 100). Note that some platform don't allow the full 0%-100% duty cycle&quot; }
-      },
-      ret = &quot;The actual frequency set on the PWM channel, which might differ from the $frequency$ parameter, depeding on the hardware&quot;,
-    },
-
-    { sig = &quot;u32 #platform_pwm_op#( unsigned id, int op, u32 data );&quot;,
-      desc = &quot;Executes an operation on a PWM channel&quot;,
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;PWM channel ID&quot; },
-        { name = &quot;op&quot;, desc = [[the operation that must be executed. It can take any value from @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pwm_operations at this</A> enum@, as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$PLATFORM_PWM_OP_START$: starts PWM generation on the specified channel.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_PWM_OP_STOP$: stops PWM generation on the specified channel.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_PWM_OP_SET_CLOCK$: sets the $base$ clock of the specified PWM channel (which will be used to generate the frequencies requested by 
-        @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_pwm_setup at platform_pwm_setup</A>@) to $data$ hertz.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_PWM_OP_GET_CLOCK$: get the $base$ clock of the specified PWM channel.&lt;/liA&gt;
-  &lt;/ul&gt;]],},
-        { name = &quot;data&quot;, desc = &quot;When used with $op$ == $PLATFORM_PWM_OP_SET_CLOCK$ it is used to specify the value of the base clock. Not used with other operations.&quot;}
-      },
-      ret = 
-      {
-        &quot;the actual value of the base clock when $op$ == $PLATFORM_PWM_OP_SET_CLOCK$, which might be different than $data$ depending on the hardware&quot;,
-        &quot;the value of the base clock when $op$ == $PLATFORM_PWM_OP_GET_CLOCK$&quot;,
-        &quot;irellevant for other operations&quot;
-      }  
-    }
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_spi.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_spi.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_spi.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,87 +0,0 @@
--- eLua platform interface - SPI
--- Make a full description for each language
-
-data_en = 
-{
-  -- Menu name
-  menu_name = &quot;SPI&quot;,
-
-  -- Title
-  title = &quot;eLua platform interface - SPI&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the SPI interface(s) of the MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// SPI mode
-#define PLATFORM_SPI_MASTER                   1
-#define PLATFORM_SPI_SLAVE                    0 ]],
-      name = &quot;Chip select&quot;,
-      desc = &quot;Constants used to select/deselect the SPI SS pin (if applicable).&quot;
-    },
-
-    { text = [[// SS values
-#define PLATFORM_SPI_SELECT_ON                1
-#define PLATFORM_SPI_SELECT_OFF               0]],
-      name = &quot;SPI mode&quot;,
-      desc = &quot;Constants used to select/deselect the SPI SS pin (if applicable).&quot;
-    }, 
-
-    { text = &quot;typedef u32 spi_data_type;&quot;,
-      name = &quot;SPI data type&quot;,
-      desc = &quot;This is the type of a SPI data word, thus limiting the maximum size of a SPI data work to 32 bits (which should be enough for all practical purposes).&quot;
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_spi_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the hardware SPI specified as argument. Implemented in %src/common.c%, it uses the $NUM_SPI$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_SPI   1      $// The platform has 1 SPI interface$~&lt;/p&gt; ]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;SPI interface ID&quot; },
-      },
-      ret = &quot;1 if the SPI interface exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;u32 #platform_spi_setup#( unsigned id, int mode, u32 clock, unsigned cpol, unsigned cpha, unsigned databits );&quot;,
-      desc = [[This function is used to initialize the parameters of the SPI interface. &lt;br&gt;&lt;font color=&quot;red&quot;&gt;$NOTE$&lt;/font&gt;: currently, only master SPI mode is implemented in eLua.]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;SPI interface ID&quot; },
-        { name = &quot;mode&quot;, desc = &quot;SPI port mode ($PLATFORM_SPI_MASTER$ or $PLATFORM_SPI_SLAVE$, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">spi_mode at here</A>@.&quot; },
-        { name = &quot;clock&quot;, desc = &quot;clock speed for the SPI interface in master mode.&quot; },
-        { name = &quot;cpol&quot;, desc = &quot;SPI clock polarity&quot; },
-        { name = &quot;cpha&quot;, desc = &quot;SPI clock phase&quot; },
-        { name = &quot;databits&quot;, desc = &quot;length of the SPI data word in bits (usually 8, but configurable on some platforms).&quot; }
-      },
-      ret = &quot;the actual clock set for the SPI interface. Depending on the hardware, this may have a different value than the $clock$ argument.&quot;
-    },
-
-    {  sig = &quot;spi_data_type #platform_spi_send_recv#( unsigned id, spi_data_type data );&quot;,
-       desc = &quot;Executes a SPI read/write cycle&quot;,
-       args = 
-       {
-         { name = &quot;id&quot;, desc = &quot;SPI interface ID&quot; },
-         { name = &quot;data&quot;, desc = &quot;data to be sent to the SPI interface&quot; },
-       },
-       ret = &quot;data read from the SPI interface&quot;
-    },
-
-    { sig = &quot;void #platform_spi_select#( unsigned id, int is_select );&quot;,
-      desc = [[For platforms that have a dedicates SS (Slave Select) pin in master SPI mode that can be controlled manually, this function should enable/disable this pin. If this functionality
-  does not exist in hardware this function does nothing.]],
-      args =
-      {
-        { name = &quot;id&quot;, desc = &quot;SPI interface ID.&quot; },
-        { name = &quot;is_select&quot;, desc = &quot;$PLATFORM_SPI_SELECT_ON$ to select, $PLATFORM_SPI_SELECT_OFF$ to deselect , see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">chip_select at here</A>@.&quot; }
-      },
-    }
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_template.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_template.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_template.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,52 +0,0 @@
--- eLua platform interface - name
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua platform interface - name&quot;,
-
-  -- Menu name
-  menu_name = &quot;name&quot;
-
-  -- Overview
-  overview = [[
-  ]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[ ]],
-      name = &quot;&quot;, 
-      desc = [[ ]]
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;void #functionname#( void )&quot;,
-      desc = [[ ]],
-      args = 
-      {
-        { name = &quot;&quot;, desc = &quot;&quot; },
-        { name = &quot;&quot;, desc = &quot;&quot; }
-      },
-      ret = 
-      {
-         &quot;&quot;,
-         [[ ]],
-      }, 
-    },
-
-  },
-
-  -- Aux data
-  auxdata = 
-  {
-    { title = &quot;&quot;,
-      desc = [[]]
-    }
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_timers.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_timers.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_timers.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,190 +0,0 @@
--- eLua platform interface - timers
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - timers&quot;,
-
-  -- Menu name
-  menu_name = &quot;Timers&quot;,
-
-  -- Overview
-  overview = [[This part of the platform interface groups functions related to the timers of the MCU. It also makes provisions for using $virtual timers$ on any platform, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">virtual at this</A> section@
-  for details. Keep in mind that in the following paragraphs a $timer id$ can reffer to both a hardware timer or a virtual timer.]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = &quot;typedef u32 timer_data_type;&quot;,
-      name = &quot;Timer data type&quot;,
-      desc = &quot;This defines the data type used to specify delays and time intervals (which are always specifide in $microseconds$).&quot;
-    },
-
-    { text = [[// Timer operations
-enum
-{
-  PLATFORM_TIMER_OP_START,
-  PLATFORM_TIMER_OP_READ,
-  PLATFORM_TIMER_OP_SET_CLOCK,
-  PLATFORM_TIMER_OP_GET_CLOCK,
-  PLATFORM_TIMER_OP_GET_MAX_DELAY,
-  PLATFORM_TIMER_OP_GET_MIN_DELAY
-};]], 
-      name = &quot;Timer operations&quot;,
-      desc = &quot;This enum lists all the operations that can be executed on a given timer.&quot;
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_timer_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the timer specified as argument. Implemented in %src/common.c%, it uses the $NUM_TIMER$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details) and the virtual timer configuration (@#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">virtual at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_TIMER   2      $// The platform has 2 hardware timers$~&lt;p&gt;]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
-      },
-      ret = &quot;1 if the timer exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;void #platform_timer_delay#( unsigned id, u32 delay_us );&quot;,
-      desc = [[Waits on a timer, then returns. This function is &quot;split&quot; in two parts: a platform-independent part implemented in %src/common.c% (that
-  handles virtual timers) and a platform-dependent part that must be implemented by each platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_timer_delay at platform_s_timer_delay</A>@. This function handles both
-  hardware timer IDs and virtual timer IDs.&lt;br&gt;
-  &lt;font color=&quot;red&quot;&gt;&lt;a name=&quot;limitations&quot;&gt;$IMPORTANT NOTE$&lt;/font&gt;&lt;/a&gt;: the real delay after executing this functions depends a number of variables, most notably the base clock of the timer 
-  and the size of the timer counter register (32 bits on some platforms, 16 bits on most platforms, other values are less common). To ensure that the delay you're requesting is achievable, use 
-  @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_op at platform_timer_op</A>@ with $PLATFORM_TIMER_OP_GET_MAX_DELAY$ and $PLATFORM_TIMER_OP_GET_MIN_DELAY$ to obtain the maximum and the minimum 
-  achievable wait times on your timer, respectively. Even if your delay is within these limits, the $precision$ of this function still varies a lot, mainly as a function of 
-  the timer base clock.]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
-        { name = &quot;delay_us&quot;, desc = &quot;the delay time (in microseconds)&quot; }
-      }
-    },
-
-    { sig = &quot;void #platform_s_timer_delay#( unsigned id, u32 delay_us );&quot;,
-      desc = [[This function is identical in functionality to @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_delay at platform_timer_delay</A>@, but this is the function that must actually be implemented by a platform port, 
-  and it must never handle virtual timer IDs, only hardware timer IDs. It has the same @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">limitations at limitations</A>@ as @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_delay at platform_timer_delay</A>@.]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
-        { name = &quot;delay_us&quot;, desc = &quot;the delay time (in microseconds)&quot; }
-      }
-    },
-
-    { sig = &quot;u32 #platform_timer_op#( unsigned id, int op, u32 data );&quot;,
-      desc = [[Executes an operation on a timer. This function is &quot;split&quot; in two parts: a platform-independent part implemented in %src/common.c% (that handles virtual timers) and a 
-  platform-dependent part that must be implemented by each platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_timer_op at platform_s_timer_op</A>@. This function handles both hardware timer IDs and virtual 
-  timer IDs.]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
-        { name = &quot;op&quot;, desc = [[the operation. $op$ can take any value from the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">timer_operations at this</A> enum@, as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_START$: start the specified timer by setting its counter register to a predefined value.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_READ$: get the value of the specified timer's counter register.&lt;/li&gt; 
-    &lt;li&gt;$PLATFORM_TIMER_SET_CLOCK$: set the clock of the specified timer to $data$ (in hertz). You can never set the clock of a virtual timer, which is set at compile time.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_GET_CLOCK$: get the clock of the specified timer.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MAX_DELAY$: get the maximum achievable timeout on the specified timer (in us).&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MIN_DELAY$: get the minimum achievable timeout on the specified timer (in us).&lt;/li&gt;
-  &lt;/ul&gt;]] },
-        { name = &quot;data&quot;, desc = &quot;used to specify the timer clock value when $op = PLATFORM_TIMER_SET_CLOCK$, ignored otherwise&quot; },
-      },
-      ret = 
-      {
-        &quot;the predefined value used when starting the clock if $op = PLATFORM_TIMER_OP_START$&quot;,
-        &quot;the timer's counter register if $op = PLATFORM_TIMER_OP_READ$&quot;,
-        &quot;the actual clock set on the timer, which might be different than the request clock depending on the hardware if $op = PLATFORM_TIMER_SET_CLOCK$&quot;,
-        &quot;the timer clock if $op = PLATFORM_TIMER_GET_CLOCK$&quot;, 
-        &quot;the maximum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MAX_DELAY$&quot;,
-        &quot;the minimum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MIN_DELAY$&quot;
-      }
-    }, 
-
-    { sig = &quot;u32 #platform_s_timer_op#( unsigned id, int op, u32 data );&quot;,
-      desc = [[This function is identical in functionality to @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_op at platform_timer_op</A>@, but this is the function that must actually be implemented by a platform port, and it must 
-  never handle virtual timer IDs, only hardware timer IDs.]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
-        { name = &quot;op&quot;, desc = [[the operation. $op$ can take any value from the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">opval at this</A> enum@, as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_START$: start the specified timer by setting its counter register to a predefined value.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_READ$: get the value of the specified timer's counter register.&lt;/li&gt; 
-    &lt;li&gt;$PLATFORM_TIMER_SET_CLOCK$: set the clock of the specified timer to $data$ (in hertz). You can never set the clock of a virtual timer, which is set at compile time.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_GET_CLOCK$: get the clock of the specified timer.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MAX_DELAY$: get the maximum achievable timeout on the specified timer (in us).&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MIN_DELAY$: get the minimum achievable timeout on the specified timer (in us).&lt;/li&gt;
-  &lt;/ul&gt;]] },
-        { name = &quot;data&quot;, desc = &quot;used to specify the timer clock value when $op = PLATFORM_TIMER_SET_CLOCK$, ignored otherwise&quot; },
-      },
-      ret = 
-      {
-        &quot;the predefined value used when starting the clock if $op = PLATFORM_TIMER_OP_START$&quot;,
-        &quot;the timer's counter register if $op = PLATFORM_TIMER_OP_READ$&quot;,
-        &quot;the actual clock set on the timer, which might be different than the request clock depending on the hardware if $op = PLATFORM_TIMER_SET_CLOCK$&quot;,
-        &quot;the timer clock if $op = PLATFORM_TIMER_GET_CLOCK$&quot;, 
-        &quot;the maximum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MAX_DELAY$&quot;,
-        &quot;the minimum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MIN_DELAY$&quot;
-      }
-    }, 
-
-    { sig = &quot;u32 #platform_timer_get_diff_us#( unsigned id, timer_data_type end, timer_data_type start );&quot;,
-      desc = [[Return the time difference (in us) betweeen two timer values. This function is generic for all platforms, thus it is implemented in %src/common.c%.]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
-        { name = &quot;end&quot;, desc = &quot;the first timer value&quot; },
-        { name = &quot;start&quot;, desc = &quot;the second timer value&quot; },
-      },
-      ret = &quot;the time difference (in microseconds)&quot;
-    }
-  },
-
-  auxdata = 
-  {
-    { title = &quot;Virtual timers&quot;,
-      desc = 
-  [[$Virtual timers$ were added to eLua to overcome some limitations:
-  &lt;ul&gt;
-    &lt;li&gt;there are generally few hardware timers available, some of which might be dedicated (thus not usable directly by eLua).&lt;/li&gt;
-    &lt;li&gt;many times it is difficult to share a hardware timer between different parts of an application because of conflicting requirements. Generally it's not possible to have timers that can
-        achieve long delays and high accuracy at the same time (this is especially true for systems that have 16 bit or even smaller timers).&lt;/li&gt;
-  &lt;/ul&gt;&lt;/p&gt;
-  &lt;p&gt;In this respect, $virtual timers$ are a set of timers that share a single hardware timer. It is possible, in this way, to have a hardware timer that can implement 4, 8 or more hardware
-  timers. There are a few drawbacks to this approach:
-  &lt;ul&gt;
-    &lt;li&gt;the hardware timer used to implement the virtual timers must generally be dedicated. In fact in cat be still used in &quot;read only mode&quot;, which means that the only operations that can
-        be executed on it are $PLATFORM_TIMER_OP_READ$, $PLATFORM_TIMER_GET_CLOCK$, $PLATFORM_TIMER_OP_GET_MAX_DELAY$ and $PLATFORM_TIMER_OP_GET_MIN_DELAY$. However,
-        since the &quot;read only mode&quot; is not enforced by the code, it is advisable to treat this timer as a dedicated resource and thus make it invisible to eLua by not associating it with 
-        an ID.&lt;/li&gt;
-    &lt;li&gt;the number of virtual timers and their base frequency are fixed at compile time.&lt;/li&gt;
-    &lt;li&gt;virtual timers are generally used for large delays with low accuracy, since their base frequency should be fairly low (see below).&lt;/li&gt;
-  &lt;/ul&gt;&lt;/p&gt;
-  &lt;p&gt;To $enable$ virtual timers:
-  &lt;ol&gt;
-    &lt;li&gt;edit $platform_conf.h$ (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details) and set $VTMR_NUM_TIMERS$ to the number of desired virtual timers and 
-       $VTMR_FREQ_HZ$ to the base frequency of the virtual timers (in hertz). For example:
-  ~#define VTMR_NUM_TIMERS       4 // we need 4 virtual timers
-#define VTMR_FREQ_HZ          4 // the base clock for the virtual timers is 4Hz~&lt;/li&gt;
-    &lt;li&gt;in your platform port setup a hardware timer to fire an interrupt at $VTMR_FREQ_HZ$ and call the $cmn_virtual_timer_cb$ function (defined in %src/common.c%) in the 
-       timer interrupt handler. For example, if the the interrupt handler is called $timer_int_handler$, do this:
-  ~void timer_int_handler( void )
-{
-  // add code to clear the timer interrupt flag here if needed
-  cmn_virtual_timer_cb();
-}~&lt;/li&gt;
-  &lt;/ol&gt;&lt;/p&gt;
-  &lt;p&gt;Note that because of step 2 above you are limited by practical constraints on the value of $VTMR_FREQ_HZ$. If set too high, the timer interrupt will fire too often, thus taking too much
-  CPU time. The maximum value depends largely on the hardware and the desired behaviour of the virtual timers, but in practice values larger than 10 might visibly change the behaviour of your 
-  system.&lt;/p&gt;
-  &lt;p&gt;To $use$ a virtual timer, identify it with the constant $VTMR_FIRST_ID$ (defined in %inc/common.h%) plus an offset. For example, $VTMR_FIRST_ID+0$ (or simply
-  $VTMR_FIRST_ID$) is the ID of the first virtual timer in the system, and $VTMR_FIRST_ID+2$ is the ID of the third virtual timer in the system.&lt;/p&gt;
-  ]]
-    }
-  }
-}
-

Deleted: trunk/doc/arch_platform/arch_platform_uart.lua
===================================================================
--- trunk/doc/arch_platform/arch_platform_uart.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/arch_platform/arch_platform_uart.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,129 +0,0 @@
--- eLua platform interface - UART
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - UART&quot;,
-
-  -- Menu name
-  menu_name = &quot;UART&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the UART interface(s) of the MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// Parity
-enum
-{
-  PLATFORM_UART_PARITY_EVEN,
-  PLATFORM_UART_PARITY_ODD,
-  PLATFORM_UART_PARITY_NONE
-};]],
-      name = &quot;UART parity&quot;,
-      desc = &quot;Constants used to specify the UART parity mode.&quot;
-    },
-
-    { text = [[// Stop bits
-enum
-{
-  PLATFORM_UART_STOPBITS_1,
-  PLATFORM_UART_STOPBITS_1_5,
-  PLATFORM_UART_STOPBITS_2
-};]],
-      name = &quot;UART stop bits&quot;,
-      desc = &quot;Constants used to specify the number of UART stop bits.&quot;,
-    },
-
-    { text = [[// &quot;Infinite timeout&quot; constant for recv
-#define PLATFORM_UART_INFINITE_TIMEOUT        (-1)]],
-      name = &quot;UART timeout&quot;,
-      desc = &quot;This constant is used as a special timeout value (infinite timeout) in the UART functions that expect a timeout as argument.&quot;,
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_uart_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the hardware UART specified as argument. Implemented in %src/common.c%, it uses the $NUM_UART$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_UART   2      $// The platform has 2 UART interfaces$~&lt;p&gt;]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;UART interface ID&quot; },
-      },
-      ret = &quot;1 if the specified UART exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;u32 #platform_uart_setup#( unsigned id, u32 baud, int databits, int parity, int stopbits );&quot;,
-      desc = &quot;This function is used to initialize the parameters of the UART interface.&quot;,
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
-        { name = &quot;baud&quot;, desc = &quot;baud rate.&quot; },
-        { name = &quot;databits&quot;, desc = &quot;number of databits (maximum 8).&quot; },
-        { name = &quot;parity&quot;, desc = &quot;parity type (can be either $PLATFORM_UART_PARITY_EVEN$, $PLATFORM_UART_PARITY_ODD$ or $PLATFORM_UART_PARITY_NONE$, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_parity at here</A>@).&quot; },
-        { name = &quot;stopbits&quot;, desc = [[number of stop bits (can be either $PLATFORM_UART_STOPBITS_1$, $PLATFORM_UART_STOPBITS_1_5$ or $PLATFORM_UART_STOPBITS_2$, see
-           @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_stop_bits at here</A>@).]] },
-      },
-      ret = &quot;the actual baud rate. Depending on the hardware, this may have a different value than the $baud$ argument.&quot;,
-    },
-
-    { sig = &quot;void #platform_uart_send#( unsigned id, u8 data );&quot;,
-      desc = &quot;Send data to an UART interface.&quot;,
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
-        { name = &quot;data&quot;, desc = &quot;data to be sent.&quot; },
-      },
-    },
-
-    { sig = &quot;int #platform_uart_recv#( unsigned id, unsigned timer_id, s32 timeout );&quot;,
-      link = &quot;platform_uart_recv&quot;,
-      desc = [[Receive data from the UART interface (blocking/non blocking with timeout/immediate).&lt;br&gt;
-  This function is &quot;split&quot; in two parts: a platform-independent part that is implemented in %src/common.c%, and a platform-dependent part that must be implemented by each
-  platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_uart_recv at platform_s_uart_recv</A>@.]],
-      args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
-        { name = &quot;timer_id&quot;, desc = &quot;the ID of the timer used in this operation (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">arch_platform_timers.html at here</A>@ for details). See also the description of the $timeout$ argument.&quot; },
-        { name = &quot;timeout&quot;, desc = [[specifies a timeout for the receive operation as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$timeout &gt; 0$: the timer with the specified $timer_id$ will be used to timeout the receive operation after $timeout$ microseconds.&lt;/li&gt;
-    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not. $timer_id$ is ignored.&lt;/li&gt;
-    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it. In this mode the function doesn't 
-        time out, so $timer_id$ is ignored.&lt;/li&gt;
-  &lt;/ul&gt;]] },
-      },
-      ret = 
-      {
-        &quot;if $timeout &gt; 0$ and data from the UART is available in $timeout$ microseconds of less it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
-      }
-    },
-
-    { sig = &quot;int #platform_s_uart_recv#( unsigned id, s32 timeout );&quot;,
-      link = &quot;platform_s_uart_recv&quot;,
-      desc = [[This is the platform-dependent part of the UART receive function @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@, and is in fact a &quot;subset&quot; of the full function 
-  (thus being easier to implement by each platform in part). In particular, it never needs to deal with the $timeout &gt; 0$ case, which is handled by @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@.]],
-       args = 
-      {
-        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
-        { name = &quot;timeout&quot;, desc = [[specifies a timeout for the receive operation as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not.&lt;/li&gt;
-    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it.&lt;/li&gt;
-  &lt;/ul&gt;]] },
-      },
-      ret = 
-      {
-        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
-      }
-    }
-  }
-}
-

Modified: trunk/doc/build_dist_doc.sh
===================================================================
--- trunk/doc/build_dist_doc.sh	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/build_dist_doc.sh	2009-06-29 16:42:56 UTC (rev 334)
@@ -7,6 +7,10 @@
 
 # Build platform docs
 lua builddoc.lua
+if [ $? -ne 0 ]
+then
+  exit
+fi
 cd wb
 lua wb_build.lua
 cd ..
@@ -27,15 +31,21 @@
 # Remove all version data from dist
 find dist/ -name &quot;.svn&quot; | xargs rm -rf
 
-# Remove unneeded files from base dir
-echo
-echo &quot;Cleaning up...&quot;
-for lang in en pt
-do
-  rm -f $lang/arch_platform_*.html
-done
-rm -f index_*.html wb/wb_usr.lua ssSearch*.html wb_bar_*.html
-rm -f wb_search*.txt wb_title*.html wb_tree*.html
+if [ &quot;$1&quot; != &quot;noclean&quot; ]
+then
+  # Remove unneeded files from base dir
+  echo
+  echo &quot;Cleaning up...&quot;
+  for lang in en pt
+  do
+    rm -f $lang/arch_platform_*.html
+  done
+  rm -f index_*.html wb/wb_usr.lua ssSearch*.html wb_bar_*.html
+  rm -f wb_search*.txt wb_title*.html wb_tree*.html
+else
+  echo
+  echo &quot;NOT cleaning base directory!&quot;
+fi
 
 # All done
 echo

Modified: trunk/doc/builddoc.lua
===================================================================
--- trunk/doc/builddoc.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/builddoc.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,16 +1,21 @@
 -- eLua doc builder tool 
 
--- List here all the components of the platform interface
-local arch_platform_components = { &quot;ll&quot;, &quot;pio&quot;, &quot;spi&quot;, &quot;uart&quot;, &quot;timers&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;eth&quot; }
--- local arch_platform_components = { &quot;cpu&quot; }
+-- List here all the sections for which we're generating the documentation
+local doc_sections = { &quot;arch_platform&quot;, &quot;refman_gen&quot; }
 
+-- List here all the components of each section
+local components = 
+{ 
+  arch_platform = { &quot;ll&quot;, &quot;pio&quot;, &quot;spi&quot;, &quot;uart&quot;, &quot;timers&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;eth&quot; },
+  refman_gen = { &quot;cpu&quot; }
+}
+
 -- List here all languages for the documentation (make sure to keep English (&quot;en&quot;) the first one)
 local languages = { &quot;en&quot;, &quot;pt&quot; }
 -- Also list here the translation for a bunch of fixed strings
 local overview_tr = { en = &quot;Overview&quot;, pt = &quot;##Overview&quot; }
 local structures_tr = { en = &quot;Data structures&quot;, pt = &quot;##Data structures&quot; }
 local functions_tr = { en = &quot;Functions&quot;, pt = &quot;##Functions&quot; }
-local pi_tr = { en = &quot;Platform interface&quot;, pt = &quot;##Platform interface&quot; }
 
 -- Format a name to a link by changing all the spaces to &quot;_&quot; and
 -- making all letters lowercase
@@ -245,9 +250,9 @@
   return str .. &quot; }&quot;
 end
 
--- Transform the data from the wb dictionary (in 'fulldata') for module 'modname' to a wb string
-local function wb2str( fulldata, modname )
-  local relfname = &quot;arch_platform_&quot; .. modname .. &quot;.html&quot;
+-- Transform the data from the wb dictionary (in 'fulldata') for module 'modname' to a wb string, for section 'sect'
+local function wb2str( fulldata, modname, sect )
+  local relfname = sect .. &quot;_&quot; .. modname .. &quot;.html&quot;
   local res = fulldata[ modname ]
   local wbstr = string.format( '    { %s,\n      link = &quot;%s&quot;,\n      folder =\n      {\n', alllangs( function( x ) return res[ x ].wb.name end ), relfname )
 
@@ -294,12 +299,6 @@
 end
 local wbdata = wbf:read( &quot;*a&quot; )
 wbf:close()
--- Check that our template has the required pattern
-local pattern = &quot;%$%$ARCH_PLATFORM%$%$&quot;
-if not wbdata:find( pattern ) then
-  print( string.format( &quot;$$arch_platform$$ not found in wb_usr_template.lua&quot;, modname ) )
-  return 1
-end
 -- Open the actual wb_usr.lua in write mode
 local realwbf = io.open( realwbloc, &quot;wb&quot; )
 if not realwbf then
@@ -307,44 +306,55 @@
   return 1
 end
 
--- Generate documentation for each module in turn
-local fulldata = {}
-for _, modname in pairs( arch_platform_components ) do
-  local descfname = string.format( &quot;arch_platform/arch_platform_%s.lua&quot;, modname )
-  local res, err = build_file( descfname )
-  if res then
-    fulldata[ modname ] = res
-    -- Write doc for each language
-    for _, lang in pairs( languages ) do
-      local fname = string.format( &quot;%s/arch_platform_%s.html&quot;, lang, modname )
-      local f = io.open( fname, &quot;wb&quot; )
-      if not f then
-        print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
-        return 1
-      else
-        f:write( res[ lang ].page )
-        f:close()
-        print( ( &quot;Wrote %s&quot; ):format( fname ) )
+-- Generate documentation for each section in part
+for _, section in pairs( doc_sections ) do 
+
+  -- Check for pattern in wb_usr_template.lua
+  local pattern = &quot;%$%$&quot; .. section:upper() .. &quot;%$%$&quot;
+  if not wbdata:find( pattern ) then
+    print( string.format( &quot;$$%s$$ not found in wb_usr_template.lua&quot;, section:upper(), modname ) )
+    return 1
+  end
+
+  -- Generate documentation for each module in turn
+  local fulldata = {}
+  for _, modname in pairs( components[ section ] ) do
+    local descfname = string.format( &quot;luadoc/%s_%s.lua&quot;, section, modname )
+    local res, err = build_file( descfname )
+    if res then
+      fulldata[ modname ] = res
+      -- Write doc for each language
+      for _, lang in pairs( languages ) do
+        local fname = string.format( &quot;%s/%s_%s.html&quot;, lang, section, modname )
+        local f = io.open( fname, &quot;wb&quot; )
+        if not f then
+          print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
+          return 1
+        else
+          f:write( res[ lang ].page )
+          f:close()
+          print( ( &quot;Wrote %s&quot; ):format( fname ) )
+        end
       end
+    else
+      print( string.format( &quot;Error processing module '%s': %s&quot;, modname, err ) )
+      return 1
     end
-  else
-    print( string.format( &quot;Error processing module '%s': %s&quot;, modname, err ) )
-    return 1
+    print &quot;&quot;
+  end 
+
+  -- Now it's finally time to get our wb/wb_usr.lua
+  local fullwb = ''
+  for _, modname in pairs( components[ section ] ) do
+    local wbstr = wb2str( fulldata, modname, section )
+    fullwb = fullwb .. wbstr
   end
-  print &quot;&quot;
-end 
 
--- Now it's finally time to get our wb/wb_usr.lua
-local fullwb = ''
-for _, modname in pairs( arch_platform_components ) do
-  local wbstr = wb2str( fulldata, modname )
-  fullwb = fullwb .. wbstr
+  -- Substitute our pattern and write everything back to disk
+  wbdata = wbdata:gsub( pattern, fullwb )
 end
--- Add beginning and end to fullwb
-fullwb = string.format( '{ %s,\n  link = &quot;arch_platform.html&quot;,\n  folder = \n  {\n%s  }\n}\n', alllangs( function( x ) return pi_tr[ x ] end ), fullwb )
 
--- Substitute our pattern and write everything back to disk
-wbdata = wbdata:gsub( pattern, fullwb )
+-- Write wb_usr.lua to disk (finally)
 realwbf:write( wbdata )
 realwbf:close()
 

Modified: trunk/doc/en/building.html
===================================================================
--- trunk/doc/en/building.html	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/en/building.html	2009-06-29 16:42:56 UTC (rev 334)
@@ -193,7 +193,7 @@
 &lt;/tr&gt;
 &lt;/tbody&gt;
 &lt;/table&gt;
-&lt;h2&gt;Configuring modules&lt;/h2&gt;
+&lt;a name=&quot;confmodules&quot;&gt;&lt;h2&gt;Configuring modules&lt;/h2&gt;&lt;/a&gt;
 &lt;p&gt;You can also choose the modules that are going to be part of
 the &lt;b&gt;eLua&lt;/b&gt; image. Unlike components, the modules have
 a direct impact on the &lt;b&gt;eLua&lt;/b&gt; API, so choose them

Modified: trunk/doc/en/refman.html
===================================================================
--- trunk/doc/en/refman.html	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/en/refman.html	2009-06-29 16:42:56 UTC (rev 334)
@@ -1,733 +1,22 @@
-&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;
-&lt;html&gt;
-	&lt;head&gt;
-		&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
-		&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en-us&quot;&gt;
-		&lt;title&gt;
-			Product
-		&lt;/title&gt;
-		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;
-	&lt;/head&gt;
-	&lt;body&gt;
-		&lt;h3&gt;
-			eLua Modules Reference Manual
-		&lt;/h3&gt;
-		&lt;h2&gt;
-			&lt;a name=&quot;genericmodules&quot; id=&quot;genericmodules&quot;&gt;&lt;/a&gt;eLua Generic Modules
-		&lt;/h2&gt;
-		&lt;p&gt;
-			A Generic eLua Module is a module that can be used by a Lua program running on any of the &lt;a href=&quot;status.html#platforms&quot;&gt;supported eLua platforms&lt;/a&gt;.&lt;br&gt;
-			Write your code once and it is already automatically ported to the main platforms of theembedded world.&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;bitmodule&quot; id=&quot;bitmodule&quot;&gt;&lt;/a&gt;bit
-		&lt;/h3&gt;
-		&lt;p&gt;
-			Bitwise operations in eLua is implemented thru the BitLib library, from Reuben Thomas.&lt;br&gt;
-			BitLib project is hosted at LuaForge on &lt;a href=&quot;<A HREF="http://luaforge.net/projects/bitlib">http://luaforge.net/projects/bitlib</A>&quot; target=&quot;_top&quot;&gt;<A HREF="http://luaforge.net/projects/bitlib&lt;/a">http://luaforge.net/projects/bitlib&lt;/a</A>&gt;&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_bnot&quot; id=&quot;bit_bnot&quot;&gt;&lt;/a&gt;Res = bit.bnot( value )
-		&lt;/p&gt;
-		&lt;p&gt;
-			unary negation
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_band&quot; id=&quot;bit_band&quot;&gt;&lt;/a&gt; Res = bit.band( v1, v2, ... )
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;b&gt;bitwise&lt;/b&gt; &quot;and&quot;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_bor&quot; id=&quot;bit_bor&quot;&gt;&lt;/a&gt; Res = bit.bor( v1, v2, ... )
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;b class=&quot;info&quot;&gt;bitwise&lt;/b&gt; &lt;span class=&quot;info&quot;&gt;&quot;or&quot;&lt;/span&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_bxor&quot; id=&quot;bit_bxor&quot;&gt;&lt;/a&gt; Res = bit.bxor( v1, v2, ... )
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;b&gt;bitwise&lt;/b&gt; &quot;exclusive or&quot;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_lshift&quot; id=&quot;bit_lshift&quot;&gt;&lt;/a&gt; Res = bit.lshift( value, pos )
-		&lt;/p&gt;
-		&lt;p&gt;
-			shift &quot;value&quot; left &quot;pos&quot; positions.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_rshift&quot; id=&quot;bit_rshift&quot;&gt;&lt;/a&gt; Res = bit.rshift( value, pos )
-		&lt;/p&gt;
-		&lt;p&gt;
-			shift &quot;value&quot; right &quot;pos&quot; positions. The sign is not propagated.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_arshift&quot; id=&quot;bit_arshift&quot;&gt;&lt;/a&gt; Res = bit.arshift( value, pos )
-		&lt;/p&gt;
-		&lt;p&gt;
-			shift &quot;value&quot; right &quot;pos&quot; positions. The sign is propagated (&quot;arithmetic shift&quot;).
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_bit&quot; id=&quot;bit_bit&quot;&gt;&lt;/a&gt; Res = bit.bit( bitno )
-		&lt;/p&gt;
-		&lt;p&gt;
-			a shortcut for bit.lshift( 1, bitno )
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_set&quot; id=&quot;bit_set&quot;&gt;&lt;/a&gt; Res1, Res2, ... = bit.set( bitno, v1, v2, ... )
-		&lt;/p&gt;
-		&lt;p&gt;
-			set the bit at position &quot;bitno&quot; in v1, v2, ... to 1.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_clear&quot; id=&quot;bit_clear&quot;&gt;&lt;/a&gt; Res1, Res2, ... = bit.clear( bitno, v1, v2, ... )
-		&lt;/p&gt;
-		&lt;p&gt;
-			set the bit at position &quot;bitno&quot;in v1, v2, ... to 0.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_isset&quot; id=&quot;bit_isset&quot;&gt;&lt;/a&gt; Res = bit.isset( value, bitno )
-		&lt;/p&gt;
-		&lt;p&gt;
-			returns true if bit at position &quot;bitno&quot; in &quot;value&quot; is 1, false otherwise.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;bit_isclear&quot; id=&quot;bit_isclear&quot;&gt;&lt;/a&gt; Res = bit.isclear( value, bitno )
-		&lt;/p&gt;
-		&lt;p&gt;
-			returns true if bit at position &quot;bitno&quot; in &quot;value&quot; is 0, false otherwise.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;cpumodule&quot; id=&quot;cpumodule&quot;&gt;&lt;/a&gt;cpu
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_write32&quot; id=&quot;cpu_write32&quot;&gt;&lt;/a&gt;write32( address, data ) : write the 32-bit data at the specified address
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_write16&quot; id=&quot;cpu_write16&quot;&gt;&lt;/a&gt;write16( address, data ) : write the 16-bit data at the specified address
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_write8&quot; id=&quot;cpu_write8&quot;&gt;&lt;/a&gt;write8( address, data ) : write the 8-bit data at the specified address&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;cpu_read32&quot; id=&quot;cpu_read32&quot;&gt;&lt;/a&gt;Data = read32( address ) : reads 32-bit data from the specified address
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_read16&quot; id=&quot;cpu_read16&quot;&gt;&lt;/a&gt;Data = read16( address ) : reads 16-bit data from the specified address
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_read8&quot; id=&quot;cpu_read8&quot;&gt;&lt;/a&gt;Data = read8( address ) : reads 8-bit data from the specified address
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_disableinterrupts&quot; id=&quot;cpu_disableinterrupts&quot;&gt;&lt;/a&gt; [cpu.disableinterrupts()] cli(): disable CPU interrupts
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_enableinterrupts&quot; id=&quot;cpu_enableinterrupts&quot;&gt;&lt;/a&gt; [cpu.enableinterrupts()] sei(): enable CPU interrupts
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;cpu_clockfrequency&quot; id=&quot;cpu_clockfrequency&quot;&gt;&lt;/a&gt;[cpu.clockfrequency()] Clock = clock(): returns the CPU frequency
-		&lt;/p&gt;
-		&lt;p&gt;
-			Also, you can expose as many CPU constants (for example memory mapped registers)
-		&lt;/p&gt;
-		&lt;p&gt;
-			as you want to this module. You might want to use this feature to access some
-		&lt;/p&gt;
-		&lt;p&gt;
-			CPU memory areas (as defined in the CPU header files from the CPU support
-		&lt;/p&gt;
-		&lt;p&gt;
-			package) directly from Lua. To do this, you'll need to define the
-		&lt;/p&gt;
-		&lt;p&gt;
-			PLATFORM_CPU_CONSTANTS macro in the platform's platform_conf.h file
-		&lt;/p&gt;
-		&lt;p&gt;
-			(src/platform/&lt;platform name&gt;/platform_conf.h). Include all your constants in a
-		&lt;/p&gt;
-		&lt;p&gt;
-			_C( &lt;constant name&gt; ) definition, and then build your project.
-		&lt;/p&gt;
-		&lt;p&gt;
-			For example, let's suppose that your CPU's interrupt controler has 3 memory
-		&lt;/p&gt;
-		&lt;p&gt;
-			mapped registers: INT_REG_ENABLE, INT_REG_DISABLE and INT_REG_MASK. If you want
-		&lt;/p&gt;
-		&lt;p&gt;
-			to access them from Lua, locate the header that defines the values of these
-		&lt;/p&gt;
-		&lt;p&gt;
-			registers (I'll assume its name is &quot;cpu.h&quot;) and add these lines to the
-		&lt;/p&gt;
-		&lt;p&gt;
-			platform_conf.h:
-		&lt;/p&gt;
-		&lt;p&gt;
-			#include &quot;cpu.h&quot;
-		&lt;/p&gt;
-		&lt;p&gt;
-			#define PLATFORM_CPU_CONSTANTS\
-		&lt;/p&gt;
-		&lt;p&gt;
-			_C( INT_REG_ENABLE ),\
-		&lt;/p&gt;
-		&lt;p&gt;
-			_C( INT_REG_DISABLE ),\
-		&lt;/p&gt;
-		&lt;p&gt;
-			_C( INT_REG_MASK )
-		&lt;/p&gt;
-		&lt;p&gt;
-			After this you'll be able to access the regs directly from Lua, like this:
-		&lt;/p&gt;
-		&lt;p&gt;
-			data = cpu.r32( cpu.INT_REG_ENABLE )
-		&lt;/p&gt;
-		&lt;p&gt;
-			cpu.w32( cpu.INT_REG_ENABLE, data )
-		&lt;/p&gt;
-		&lt;p&gt;
-			For a &quot;real-life&quot; example, see the src/platform/lm3s/platform_conf.h file.
-		&lt;/p&gt;
-		&lt;p&gt;
-			[uart.sendstring] uart.sendstr( id, str1, str2, ... ): this is similar to &quot;uart.send&quot;, but its parameters are string.
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;gpiomodule&quot; id=&quot;gpiomodule&quot;&gt;pio&lt;/a&gt;
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;b&gt;pio&lt;/b&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Programable Input Output Module
-		&lt;/p&gt;
-		&lt;p&gt;
-			Some notes on PIO:
-		&lt;/p&gt;
-		&lt;ul&gt;
-			&lt;li&gt;pio: only some platform have internal pullups for the pio pins, while Cortex is the only platform that also provides pulldowns for its pios. However, in this case you're safe, as eLua will signal an error if you try to execute a pullup operatin on a platform that does not support it.
-			&lt;/li&gt;
-		&lt;/ul&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_setpinvalue&quot; id=&quot;gpio_setpinvalue&quot;&gt;&lt;/a&gt; [pio.setpinvalue] pio.setpin( value, Pin1, Pin2 ... ): set the value to all the pins in the list
-		&lt;/p&gt;
-		&lt;p&gt;
-			to &quot;value&quot; (0 or 1).
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_setpinhigh&quot; id=&quot;gpio_setpinhigh&quot;&gt;&lt;/a&gt; [pio.setpinhigh] pio.set( Pin1, Pin2, ... ): set the value of all the pins in the list to 1.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_getpinvalue&quot; id=&quot;gpio_getpinvalue&quot;&gt;&lt;/a&gt; [pio.getpinvalue] Val1, Val2, ... = pio.get( Pin1, Pin2, ... ): reads one or more pins and returns
-		&lt;/p&gt;
-		&lt;p&gt;
-			their values (0 or 1).
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_setpinlow&quot; id=&quot;gpio_setpinlow&quot;&gt;&lt;/a&gt; [pio.setpinlow] pio.clear( Pin1, Pin2, ... ): set the value of all the pins in the list to 0.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_configpin&quot; id=&quot;gpio_configpin&quot;&gt;&lt;/a&gt; [pio.configpin(pio.DIR, pio.DIR_INPUT)] pio.input( Pin1, Pin2, ... ): set the specified pin(s) as input(s).
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configpin(pio.DIR, pio.DIR_OUTPUT)] pio.output( Pin1, Pin2, ... ): set the specified pin(s) as output(s).
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_setportvalue&quot; id=&quot;gpio_setportvalue&quot;&gt;&lt;/a&gt; [pio.setportvalue] pio.setport( value, Port1, Port2, ... ): set the value of all the ports in the
-		&lt;/p&gt;
-		&lt;p&gt;
-			list to &quot;value&quot;.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_getportvalue&quot; id=&quot;gpio_getportvalue&quot;&gt;&lt;/a&gt; [pio.getportvalue] Val1, Val2, ... = pio.getport( Port1, Port2, ... ): reads one or more ports and
-		&lt;/p&gt;
-		&lt;p&gt;
-			returns their values.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_getportname&quot; id=&quot;gpio_getportname&quot;&gt;&lt;/a&gt; [pio.getportname] Port = pio.port( code ): return the physical port number associated with the given code. For example, &quot;pio.port( pio.P0_20 )&quot; will return 0.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;gpio_getpinnumber&quot; id=&quot;gpio_getpinnumber&quot;&gt;&lt;/a&gt; [pio.getpinnumber] Pin = pio.pin( code ): return the physical pin number associated with the
-		&lt;/p&gt;
-		&lt;p&gt;
-			given code. For example, &quot;pio.pin( pio.P0_20 )&quot; will return 20.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;gpio_togglepin&quot; id=&quot;gpio_togglepin&quot;&gt;&lt;/a&gt;[pio.togglepin([Pin1], [Pin2], ...)]&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;gpio_toogleport&quot; id=&quot;gpio_toogleport&quot;&gt;&lt;/a&gt;[pio.toggleport([Port1], [Port2], ...)]&lt;br&gt;
-			&lt;br&gt;
-			Another idea (can be added to the above ?)&lt;br&gt;
-			[pio.configport(pio.[FUNCTION], pio.MASK, [MASK])]&lt;br&gt;
-			Ex:&lt;br&gt;
-			pio.configpin(pio.DIR, pio.DIR_INPUT) (.DIR_OUTPUT)&lt;br&gt;
-			pio.configpin(pio.PULL, pio.PULL_UP) (.PULL_DOWN, PULL_NO)&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configport(pio.DIR, pio.DIR_INPUT, [Port1], [Port2], ...)] pio.port_input( Port1, Port2, ... ): set the specified port(s) as input(s).
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configport(pio.DIR, pio.DIR_OUTPUT, [Port1], [Port2], ...)] pio.port_output( Port1, Port2, ... ): set the specified port(s) as output(s).
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configpin(pio.PULL, pio.PULL_UP, [Pin1], [Pin2], ...)] pio.pullup( Pin1, Pin2, ... ): enable internal pullups on the specified pins.Note that some CPUs might not provide this feature.
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configpin(pio.PULL, pio.PULL_DOWN, [Pin1], [Pin2], ...)] pio.pulldown( Pin1, Pin2, ... ): enable internal pulldowns on the specified pins. Note that some CPUs might not provide this feature.
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configpin(pio.PULL, pio.PULL_NO, [Pin1], [Pin2], ...)] pio.nopull( Pin1, Pin2, ... ): disable the pullups/pulldowns on the specifiedpins. Note that some CPUs might not provide this feature.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;netmodule&quot; id=&quot;netmodule&quot;&gt;&lt;/a&gt;net
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;pwmmodule&quot; id=&quot;pwmmodule&quot;&gt;&lt;/a&gt;pwm
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			It allows Lua to use the PWM blocks on the target CPU.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;strike&gt;&lt;a name=&quot;pwm_setup&quot; id=&quot;pwm_setup&quot;&gt;&lt;/a&gt;[pwm.setup]&lt;/strike&gt;(pwm.setup( id, frequency, Active Cycle ) Data = pwm.setup( id, frequency, duty ): sets the PWM block 'id' to generate the specified frequency with the specified duty cycle (duty is an integer number from 0 to 100, specifying the duty cycle in percents). It returns the actual frequency set on the PWM block.
-		&lt;/p&gt;
-		&lt;p&gt;
-			Here there is a bigger change on the proposal.
-		&lt;/p&gt;
-		&lt;p&gt;
-			The Timer Clock and the PWM &quot;frame&quot; frequency would be set up in the same function (.setup)
-		&lt;/p&gt;
-		&lt;p&gt;
-			The normal control function would only set the active cicle (.setcycle)
-		&lt;/p&gt;
-		&lt;p&gt;
-			The original .setup function would then be replaced by:
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pwm.setup( id, tmrclock, pwm_frequency ) ]&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;pwm_setcycle&quot; id=&quot;pwm_setcycle&quot;&gt;&lt;/a&gt;[pwm.setcycle( id, active_cycle )]
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;pwm_start&quot; id=&quot;pwm_start&quot;&gt;&lt;/a&gt;[pwm.start()] pwm.start( id ): start the PWM block 'id'.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;pwm_stop&quot; id=&quot;pwm_stop&quot;&gt;&lt;/a&gt;[pwm.stop()] pwm.stop( id ): stop the PWM block 'id'.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;pwm_setclock&quot; id=&quot;pwm_setclock&quot;&gt;&lt;/a&gt;Data = pwm.setclock( id, clock ): set the base clock of the PWM block 'id' to
-		&lt;/p&gt;
-		&lt;p&gt;
-			the given clock. In returns the actual clock set on the PWM block.
-		&lt;/p&gt;
-		&lt;p&gt;
-			[&lt;strike&gt;pwm.getclock&lt;/strike&gt;] Data = pwm.getclock( id ): returns the base clock of the PWM block 'id'.
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;spimodule&quot; id=&quot;spimodule&quot;&gt;&lt;/a&gt;spi
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-			Actual_clock = spi.setup( id, spi.MASTER | spi.SLAVE, clock, cpol, cpha,&lt;br&gt;
-			databits): set the SPI interface with the given parameters, returns the clock&lt;br&gt;
-			that was set for the interface.&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;spi_select&quot; id=&quot;spi_select&quot;&gt;&lt;/a&gt;spi.select( id ): sets the selected spi as active (sets the SS line of the given interface).&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;spi_unselect&quot; id=&quot;spi_unselect&quot;&gt;&lt;/a&gt;spi.unselect( id ): clears the SS line of the given interface.&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;spi_send&quot; id=&quot;spi_send&quot;&gt;&lt;/a&gt;spi.send( id, Data1, Data2, ... ): sends all the data to the specified SPI&lt;br&gt;
-			interface.&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;spi_sendrecv&quot; id=&quot;spi_sendrecv&quot;&gt;&lt;/a&gt;[spi.sendrecv(id, Out1, Out2, ...)] In1, In2, ... = spi.send_recv( id, Out1, Out2, ... ): sends all the &quot;out&quot; bytes to the specified SPI interface and returts the data read after each sent byte.&lt;br&gt;
-			&lt;br&gt;
-			Returning several values in this blocking way would not complicate some queued send implementations ? (ok, this could be another function :)&lt;br&gt;
-			&lt;br&gt;
-			Sending multiple data/chars in a single call and not in a table argument does not allow the data to be built in run time (without some string massage, of course :)&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;sysmodule&quot; id=&quot;sysmodule&quot;&gt;&lt;/a&gt;sys
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;sys_platform&quot; id=&quot;sys_platform&quot;&gt;&lt;/a&gt;[sys.platform()] pd.platform(): returns the platform name (f.e. LM3S)
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;sys_mcu&quot; id=&quot;sys_mcu&quot;&gt;&lt;/a&gt;[sys.mcu()] pd.cpu(): returns the CPU name (f.e. LM3S8962)
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;sys_cpu&quot; id=&quot;sys_cpu&quot;&gt;&lt;/a&gt;[sys.cpu()] would return ARM Cortex M3 in this case.....
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;sys_board&quot; id=&quot;sys_board&quot;&gt;&lt;/a&gt;[sys.board()] pd.board(): returns the CPU board (f.e. EK-LM3S8962)
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;term_termmodule&quot; id=&quot;term_termmodule&quot;&gt;term&lt;/a&gt;
-		&lt;/h3&gt;
-		&lt;p&gt;
-			Terminal support
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_clear&quot; id=&quot;term_clear&quot;&gt;&lt;/a&gt;[term.clear] term.clrscr(): clear the screen
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;term_cleareol&quot; id=&quot;term_cleareol&quot;&gt;&lt;/a&gt;[term.cleareol] term.clreol(): clear from the current cursor position to the end of the line
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_moveto&quot; id=&quot;term_moveto&quot;&gt;&lt;/a&gt; [term.moveto] term.gotoxy( x, y ): position the cursor at the given coordinates&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_moveup&quot; id=&quot;term_moveup&quot;&gt;&lt;/a&gt; [term.moveup] term.up( delta ): move the cursor up &quot;delta&quot; lines
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_movedown&quot; id=&quot;term_movedown&quot;&gt;&lt;/a&gt; [term.movedown] term.down( delta ): move the cursor down &quot;delta&quot; lines
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_moveleft&quot; id=&quot;term_moveleft&quot;&gt;&lt;/a&gt; [term.moveleft] term.left( delta ): move the cursor left &quot;delta&quot; lines
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;term_moveright&quot; id=&quot;term_moveright&quot;&gt;&lt;/a&gt;[term.moveright] term.right( delta ): move the cursor right &quot;delta&quot; lines
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_getlinecount&quot; id=&quot;term_getlinecount&quot;&gt;&lt;/a&gt; [term.getlinecount] Lines = term.lines(): returns the number of lines
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_getcolcount&quot; id=&quot;term_getcolcount&quot;&gt;&lt;/a&gt; [term.getcolcount] Cols = term.cols(): returns the number of columns
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_printstr&quot; id=&quot;term_printstr&quot;&gt;&lt;/a&gt; [term.printstr] term.putstr( s1, s2, ... ): writes the specified string(s) to the terminal&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			[term.printchar] term.put( c1, c2, ... ): writes the specified character(s) to the terminal
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_getx&quot; id=&quot;term_getx&quot;&gt;&lt;/a&gt; [term.getx] Cx = term.cursorx(): return the cursor X position
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_gety&quot; id=&quot;term_gety&quot;&gt;&lt;/a&gt;[term.gety] Cy = term.cursory(): return the cursor Y position
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;term_inputchar&quot; id=&quot;term_inputchar&quot;&gt;&lt;/a&gt;[term.inputchar] c = term.getch( term.WAIT | term.NOWAIT ): returns a char read from the
-		&lt;/p&gt;
-		&lt;p&gt;
-			terminal.&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;tmr_tmrmodule&quot; id=&quot;tmr_tmrmodule&quot;&gt;&lt;/a&gt;tmr
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;big&gt;&lt;br&gt;&lt;/big&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			It allows Lua to execute timer specific operations (delay, read timer value,
-		&lt;/p&gt;
-		&lt;p&gt;
-			start timer, get time difference).
-		&lt;/p&gt;
-		&lt;p&gt;
-			Some notes on timers:
-		&lt;/p&gt;
-		&lt;ul&gt;
-			&lt;li&gt;timers: from all the platforms on which eLua runs, only the Luminary Cortex CPUs has rock solid 32-bit timers. You can do pretty much everything you need with them. All the other platforms have 16-bit timers, which imposes some limits on the range of delays you can achieve with them. Make sure to use tmr.mindelay(id) and tmr.maxdelay(id) to check the actual resolution of your timers, and adapt your code accordingly. To 'compensate' for this, it's not possible to change the base timer frequency on the Cortex CPUs, but it is possible on most other platforms :) So be sure to also check the result of tmr.setclock(id)
-			&lt;/li&gt;
-			&lt;li&gt;also, when using timers, remember that if you're using XMODEM and/or the &quot;term&quot; module, TMR0 is used by both of them. So, if you change the TMR0 base clock in your code, be sure to restore the original setting before returning to the shell. You can change this static timer assignment by modifying src/main.c. It might also be possible to change it dynamically in the future, although I see little use for this.
-			&lt;/li&gt;
-			&lt;li&gt;PWM: the Cortex CPUs have 6 PWM channels, but channels 0/1, 2/3 and 4/5 respectively share the same base clock setting. So, when you're changing the base clock for channel 1, you're also changing the base clock for channel 0; if channel 0 was already running, you won't like what will happen next. This time no eLua function can save you, you simply need you know your CPU architecture.
-			&lt;/li&gt;
-		&lt;/ul&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_delay&quot; id=&quot;tmr_delay&quot;&gt;&lt;/a&gt;tmr.delay( id, delay ): uses timer 'id' to wait for 'delay' us.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_read&quot; id=&quot;tmr_read&quot;&gt;&lt;/a&gt;Data = tmr.read( id ): reads the value of timer 'id'. The returned value is
-		&lt;/p&gt;
-		&lt;p&gt;
-			platform dependent.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_start&quot; id=&quot;tmr_start&quot;&gt;&lt;/a&gt;Data = tmr.start( id ): start the timer 'id', and also returns its value at
-		&lt;/p&gt;
-		&lt;p&gt;
-			the moment of start. The returned value is platform dependent.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_diff&quot; id=&quot;tmr_diff&quot;&gt;&lt;/a&gt;diff = tmr.diff( id, end, start ): returns the time difference (in us) between
-		&lt;/p&gt;
-		&lt;p&gt;
-			the timer values 'end' and 'start' (obtained from calling tmr.start or
-		&lt;/p&gt;
-		&lt;p&gt;
-			tmr.read). The order of end/start is irrelevant.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_mindelay&quot; id=&quot;tmr_mindelay&quot;&gt;&lt;/a&gt;Data = tmr.mindelay( id ): returns the minimum delay (in us ) that can be
-		&lt;/p&gt;
-		&lt;p&gt;
-			achieved by calling the tmr.delay function. If the return value is 0, the
-		&lt;/p&gt;
-		&lt;p&gt;
-			platform layer is capable of executing sub-microsecond delays.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_maxdelay&quot; id=&quot;tmr_maxdelay&quot;&gt;&lt;/a&gt;Data = tmr.maxdelay( id ): returns the maximum delay (in us) that can be
-		&lt;/p&gt;
-		&lt;p&gt;
-			achieved by calling the tmr.delay function.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_setclock&quot; id=&quot;tmr_setclock&quot;&gt;&lt;/a&gt;Data = tmr.setclock( id, clock ): sets the clock of the given timer. Returns the
-		&lt;/p&gt;
-		&lt;p&gt;
-			actual clock set for the timer.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;tmr_getclock&quot; id=&quot;tmr_getclock&quot;&gt;&lt;/a&gt;Data = tmr.getclock( id ): return the clock of the given timer.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;uartmodule&quot; id=&quot;uartmodule&quot;&gt;&lt;/a&gt;uart
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;uart_setup&quot; id=&quot;uart_setup&quot;&gt;&lt;/a&gt;&lt;strong&gt;uart.setup( id, baud, databits,&lt;br&gt;
-			uart.PARITY_EVEN | uart.PARITY_ODD | uart.PARITY_NONE,&lt;br&gt;
-			uart.STOPBITS_1 | uart.STOPBITS_1_5 | uart.STOPBITS_2 )&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Set the UART interface with the given parameters.
-		&lt;/p&gt;
-		&lt;p&gt;
-			Returns the actual baud rate that was set for the UART.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;uart_send&quot; id=&quot;uart_send&quot;&gt;&lt;/a&gt;&lt;strong&gt;uart.send( id, Data1, Data2, ... )&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Send all the data to the specified UART interface.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;uart_recv&quot; id=&quot;uart_recv&quot;&gt;&lt;/a&gt;uart.recv( id, uart.TIMEOUT_NO | &lt;strike&gt;uart.TIMEOUT_INFINITE&lt;/strike&gt; | timeout ) Data = uart.recv( id, uart.NO_TIMEOUT | uart.INF_TIMEOUT | timeout )
-		&lt;/p&gt;
-		&lt;p&gt;
-			Reads a byte from the specified UART interface.
-		&lt;/p&gt;
-		&lt;h2&gt;
-			&lt;a name=&quot;platdepmodules&quot; id=&quot;platdepmodules&quot;&gt;&lt;/a&gt;eLua Platform Dependent Modules
-		&lt;/h2&gt;
-		&lt;p&gt;
-			A Platform Dependent eLua Module is a module that runs only on one or on a few &lt;a href=&quot;status.html#platforms&quot;&gt;supported eLua platforms&lt;/a&gt;.&lt;br&gt;
-			These modules make use of specifical devices and features offered by some kits and allow eLua aplications to make the best use of the external hardware on your platforms.&lt;br&gt;
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;adcmodule&quot; id=&quot;adcmodule&quot;&gt;&lt;/a&gt;adc - Analog to Digital Conversion Module
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;strong&gt;Currently runs on:&lt;/strong&gt; LM3Sxxxx&lt;br&gt;
-			&lt;br&gt;
-			The ADC module handles the Analog to Digital Conversion Peripherals.&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_sample&quot; id=&quot;adc_sample&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.sample(channel_id | {channel_id1, channel_id2, ...}, count)&lt;/strong&gt;&lt;br&gt;
-			Request that &lt;em&gt;count&lt;/em&gt; samples be converted from &lt;em&gt;channel_id&lt;/em&gt;. &lt;em&gt;count&lt;/em&gt; must be greater than zero and a power of 2
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;adc_flush&quot; id=&quot;adc_flush&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.flush(channel_id)&lt;/strong&gt;&lt;br&gt;
-			Empty sample and smoothing buffers.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;adc_getsample&quot; id=&quot;adc_getsamples&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.getsample(channel_id)&lt;/strong&gt;&lt;br&gt;
-			Request a single sample from the buffer.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;adc_getsamples&quot; id=&quot;adc_getsamples&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.getsamples(channel_id, [count])&lt;/strong&gt;&lt;br&gt;
-			Request &lt;em&gt;count&lt;/em&gt; samples from the buffer, in a table. If &lt;em&gt;count&lt;/em&gt; is either zero or omitted, all available samples are returned.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;adc_maxval&quot; id=&quot;adc_maxval&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.maxval(channel_id)&lt;/strong&gt;&lt;br&gt;
-			Returns the largest integer one can expect fromr this channel on a given platform (based on bit depth).
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;adc_setclock&quot; id=&quot;adc_setclock&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setclock(channel_id, frequency, [timer_id])&lt;/strong&gt;&lt;br&gt;
-			Sets the frequency and clock source for sample collection. If &lt;em&gt;frequency&lt;/em&gt; is zero (timer_id not needed), samples on &lt;em&gt;channel_id&lt;/em&gt; are collected as fast as possible. &nbsp;If &lt;em&gt;frequency&lt;/em&gt; is non-zero, &lt;em&gt;timer_id&lt;/em&gt; is configured to trigger sampling on &lt;em&gt;channel_id&lt;/em&gt; at &lt;em&gt;frequency.&lt;/em&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;adc_samplesready&quot; id=&quot;adc_samplesready&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.isdone(channel_id)&lt;/strong&gt;&lt;br&gt;
-			Returns 1 if samples are still being collected on &lt;em&gt;channel_id&lt;/em&gt;, 0 if channel is inactive.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;adc_setmode&quot; id=&quot;adc_setmode&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setblocking(channel_id, mode)&lt;br&gt;&lt;/strong&gt; &lt;em&gt;mode&lt;/em&gt; 1 sets blocking mode (default). adc.getsample(s) will wait for requested samples to be captured before returning. &lt;em&gt;mode&lt;/em&gt; 0 sets non-blocking mode&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_setsmoothing&quot; id=&quot;adc_setsmoothing&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setsmoothing(channel_id, length)&lt;br&gt;&lt;/strong&gt; Set the &lt;em&gt;length&lt;/em&gt; of the smoothing filter on &lt;em&gt;channel_id&lt;/em&gt;. &nbsp;When greater than 1, and samples are requested, smoothing filter will fill to &lt;em&gt;length&lt;/em&gt; with samples, and then put the requested number of samples into the adc buffer.&lt;br&gt;
-			&lt;em&gt;length&lt;/em&gt; must be a power of 2 (maximum = 64)
-		&lt;/p&gt;
-		&lt;h3&gt;
-			&lt;a name=&quot;dispmodule&quot; id=&quot;dispmodule&quot;&gt;&lt;/a&gt;disp
-		&lt;/h3&gt;
-		&lt;p&gt;
-			&lt;strong&gt;Currently runs on:&lt;/strong&gt; LM3Sxxxx&lt;br&gt;
-			&lt;br&gt;
-			The disp module handles the RIT OLED display usage on Luminary Micro Cortex-M3 boards
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;strong&gt;## Following functions may change to merge init/on/enable and off/disable&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_init&quot; id=&quot;disp_init&quot;&gt;&lt;/a&gt; &lt;strong&gt;disp.init( freq )&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;em&gt;freq&lt;/em&gt; specifies the SSI Clock Frequency to be used.&lt;br&gt;
-			&lt;br&gt;
-			This function initializes the SSI interface to the OLED display and configures the SSD1329 controller on the panel.&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_enable&quot; id=&quot;disp_enable&quot;&gt;&lt;/a&gt; &lt;strong&gt;disp.enable()&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Enable the SSI component of the OLED display driver.&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;em&gt;freq&lt;/em&gt; specifies the SSI Clock Frequency to be used.&lt;br&gt;
-			This function initializes the SSI interface to the OLED display.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_disable&quot; id=&quot;disp_disable&quot;&gt;&lt;/a&gt; &lt;strong&gt;disp.disable()&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Disable the SSI component of the OLED display driver and frees the SPI channel for other uses.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_on&quot; id=&quot;disp_on&quot;&gt;&lt;/a&gt;&lt;strong&gt;disp.on()&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Turns on the OLED display.&lt;br&gt;
-			This function will turn on the OLED display, causing it to display the contents of its internal frame buffer.&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_off&quot; id=&quot;disp_off&quot;&gt;&lt;/a&gt; &lt;strong&gt;disp.off&lt;/strong&gt;()
-		&lt;/p&gt;
-		&lt;p&gt;
-			Turns off the OLED display&lt;br&gt;
-			This function will turn off the OLED display. This will stop the scanning of the panel and turn off the on-chip DC-DC converter, preventing damage to the panel due to burn-in (it has similar characters to a CRT in this respect).&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_clear&quot; id=&quot;disp_clear&quot;&gt;&lt;/a&gt; &lt;strong&gt;disp.clear()&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Clears the OLED display.&lt;br&gt;
-			This function will clear the display RAM. All pixels in the display will be turned off.
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_print&quot; id=&quot;disp_print&quot;&gt;&lt;/a&gt;&lt;strong&gt;disp.print( str, x, y, gray )&lt;/strong&gt;&lt;br&gt;
-			&lt;br&gt;
-			Writes a string on the OLED display.&lt;br&gt;
-			&lt;br&gt;
-			Calling Arguments:&lt;br&gt;
-			str is a string to be displayed.&lt;br&gt;
-			x is the horizontal position to display the string, specified in columns from the left edge of the display.&lt;br&gt;
-			y is the vertical position to display the string, specified in rows from the top edge of the display.&lt;br&gt;
-			gray is the 4-bit gray scale (intensity) value to be used for displayed text.&lt;br&gt;
-			&lt;br&gt;
-			This function will draw a string on the display. Only the ASCII characters between 32 (space) and 126 (tilde) are supported; other characters will result in random data being draw on the display (based on whatever appears before/after the font in memory). The font is mono-spaced, so characters such as ``i'' and ``l'' have more white space around them than characters such as ``m'' or ``w''.&lt;br&gt;
-			If the drawing of the string reaches the right edge of the display, no more characters will be drawn. Therefore, special care is not required to avoid supplying a string that is ``too long'' to display.&lt;br&gt;
-			&lt;br&gt;
-			Because the OLED display packs 2 pixels of data in a single byte, the&lt;br&gt;
-			parameter x must be an even column number (for example, 0, 2, 4, and&lt;br&gt;
-			so on).&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			&lt;a name=&quot;disp_draw&quot; id=&quot;disp_draw&quot;&gt;&lt;/a&gt; &lt;strong&gt;disp.draw( img, x, y, width, height, gray )&lt;/strong&gt;
-		&lt;/p&gt;
-		&lt;p&gt;
-			Displays an image on the OLED display.&lt;br&gt;
-			&lt;br&gt;
-			img a pointer to the string data representing a rit format image to display.&lt;br&gt;
-			x is the horizontal position to display the string, specified in columns from the left edge of the display.&lt;br&gt;
-			y is the vertical position to display the string, specified in rows from the top edge of the display.&lt;br&gt;
-			width is the width of the image, specified in columns.&lt;br&gt;
-			height is the height of the image, specified in rows.&lt;br&gt;
-			&lt;br&gt;
-			This function will display a bitmap graphic on the display. Because of the format of the display RAM, the starting column x and the number of columns y must be an integer multiple of two.&lt;br&gt;
-			The image data is organized with the first row of image data appearing left to right, followed immediately by the second row of image data. Each byte contains the data for two columns in the current row, with the leftmost column being contained in bits 7:4 and the rightmost column being contained in bits 3:0.&lt;br&gt;
-			For example, an image six columns wide and seven scan lines tall would be arranged as follows (showing how the twenty one bytes of the image would appear on the display):&lt;br&gt;
-			&lt;br&gt;
-			Because the OLED display packs 2 pixels of data in a single byte, the parameter x must be an even column number (for example, 0, 2, 4, and so on).
-		&lt;/p&gt;
-		&lt;pre&gt;
-+-------------------+-------------------+-------------------+&lt;br&gt;|      Byte 0       |      Byte 1       |      Byte 2       |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 3       |      Byte 4       |      Byte 5       |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 6       |      Byte 7       |      Byte 8       |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 9       |      Byte 10      |      Byte 11      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3!
  2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 12      |      Byte 13      |      Byte 14      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 15      |      Byte 16      |      Byte 17      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 18      |      Byte 19      |      Byte 20      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;
-&lt;/pre&gt;
-	&lt;/body&gt;
-&lt;/html&gt;
+&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Strict//EN&quot;&gt;
+&lt;html&gt;&lt;head&gt;
+&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;
+&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en-us&quot;&gt;&lt;title&gt;eLua reference manual&lt;/title&gt;
+
+&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;
+&lt;body style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;
+&lt;h3&gt;The reference manual&lt;/h3&gt;
+&lt;p&gt;The &lt;b&gt;eLua&lt;/b&gt; reference manual presents in details all the modules that can be used from a Lua program running inside &lt;b&gt;eLua&lt;/b&gt;. It doesn't cover the
+standard Lua libraries, as the &lt;a target=&quot;_blank&quot; href=&quot;<A HREF="http://www.lua.org/manual/5.1/">http://www.lua.org/manual/5.1/</A>&quot;&gt;Lua reference manual&lt;/a&gt; already does a very good job at this. 
+Instead, it covers &lt;b&gt;eLua&lt;/b&gt;-specific modules (most of which are linked with the &lt;a href=&quot;arch_platform.html&quot;&gt;platform interface&lt;/a&gt;) and some generic
+&quot;3rd party&quot; modules that are included in &lt;b&gt;eLua&lt;/b&gt; by default. There are two types of modules in &lt;b&gt;eLua&lt;/b&gt;, both of which are presented
+in this section:
+&lt;ul&gt;
+  &lt;li&gt;&lt;b&gt;generic modules&lt;/b&gt;: they are available on all platforms and should behave the same on all platforms.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;platform-depedent modules&lt;/b&gt;: they can be found only on specific platforms. Using them sacrifices portability, but gives access to platform 
+      internals that aren't covered by the generic modules (for example specific hardware features).&lt;/b&gt;
+&lt;/ul&gt;&lt;/p&gt;
+&lt;p&gt;Remember that in order to use a module (generic or not) in &lt;b&gt;eLua&lt;/b&gt; you must first include it in your &lt;b&gt;eLua&lt;/b&gt; binary image, check 
+&lt;a href=&quot;building.html#confmodules&quot;&gt;here&lt;/a&gt; for instructions on how to do this.&lt;/p&gt;
+&lt;p&gt;
+&lt;/body&gt;&lt;/html&gt;

Copied: trunk/doc/luadoc/arch_platform_cpu.lua (from rev 333, trunk/doc/arch_platform/arch_platform_cpu.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_cpu.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_cpu.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,31 @@
+-- eLua platform interface - CPU
+
+data_en = 
+{
+  -- Title
+  title = &quot;eLua platform interface - CPU&quot;,
+
+  -- Menu name
+  menu_name = &quot;CPU&quot;,
+
+  -- Overview
+  overview = &quot;This part of the platform interface groups functions related to the CPU and its functional modules (interrupt controller, memory controller and others).&quot;,
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;void #platform_cpu_enable_interrupts#();&quot;,
+      desc = &quot;Enable global interrupt on the CPU.&quot;
+    },
+
+    { sig = &quot;void #platform_cpu_disable_interrupts#();&quot;,
+      desc = &quot;Disable global interrupts on the CPU.&quot;
+    },
+
+    { sig = &quot;u32 #platform_cpu_get_frequency#();&quot;,
+      desc = &quot;Get the CPU frequency.&quot;,
+      ret = &quot;the CPU $core$ frequency (in hertz).&quot;
+    },
+  }
+}
+

Copied: trunk/doc/luadoc/arch_platform_eth.lua (from rev 333, trunk/doc/arch_platform/arch_platform_eth.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_eth.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_eth.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,98 @@
+-- eLua platform interface - Ethernet support
+
+data_en = 
+{
+  -- Title
+  title = &quot;eLua platform interface - Ethernet support&quot;,
+
+  -- Menu name
+  menu_name = &quot;Ethernet&quot;,
+
+  -- Overview
+  overview = [[&lt;font color=&quot;red&quot;&gt;$NOTE$: TCP/IP support is experimental in eLua. Although functional, it's quite incomplete at the moment.&lt;/font&gt;&lt;/p&gt;
+  &lt;p&gt;This part of the platform interface groups functions related to accessing the Ethernet interface (internal or external) of the CPU. Note that unlike the
+  other parts of the platform interface this one is dedicated for TCP/IP support and thus it does not correspond directly to an eLua module, although
+  the @##@net module@ is implemented with functions that rely on this part of the platform interface. Currently only
+  the ^<A HREF="http://www.sics.se/~~adam/uip/index.php/Main_Page^uIP^">http://www.sics.se/~~adam/uip/index.php/Main_Page^uIP^</A> TCP/IP stack is supported by eLua.&lt;/p&gt;
+  &lt;p&gt;uIP is implemented in eLua using two hardware interrupts (that should be available on your platform): the Ethernet receive interrupt (to handle
+  incoming packets) and a timer interrupt (timers are used internally by uIP). However, the uIP main loop is only called from the Ethernet interrupt handler
+  in eLua, so in order to acknowledge the timer interrupt (as well as to provide some optimizations) a function that &quot;forces&quot; an Ethernet interrupt
+  must also be provided by the platform interface (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_eth_force_interrupt at here</A>@ for details).&lt;/p&gt;
+  &lt;p&gt;To put everything together, part of the Ethernet platform interface for the $m3s$ platform is given below:&lt;/p&gt;
+  ~u32 platform_eth_get_elapsed_time()
+  {
+    if( eth_timer_fired )
+    {
+      eth_timer_fired = 0;
+      return SYSTICKMS;
+    }
+    else
+      return 0;
+  }
+
+  void SysTickIntHandler()
+  {
+    // Handle virtual timers
+    cmn_virtual_timer_cb();
+
+    // Indicate that a SysTick interrupt has occurred.
+    eth_timer_fired = 1;
+
+    // Generate a fake Ethernet interrupt.  This will perform the actual work
+    // of incrementing the timers and taking the appropriate actions.
+    &lt;b&gt;platform_eth_force_interrupt();&lt;/b&gt;
+  }
+
+  void EthernetIntHandler()
+  {
+    u32 temp;
+
+    // Read and Clear the interrupt.
+    temp = EthernetIntStatus( ETH_BASE, false );
+    EthernetIntClear( ETH_BASE, temp );
+
+    // Call the UIP main loop
+    &lt;b&gt;elua_uip_mainloop();&lt;/b&gt;
+  }~&lt;p&gt;]],
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;void #platform_eth_send_packet#( const void* src, u32 size )&quot;,
+      desc = &quot;Sends an Ethernet packet to the network&quot;,
+      args = 
+      {
+        { name = &quot;src&quot;, desc = &quot;start address of the Ethernet packet&quot; },
+        { name = &quot;size&quot;, desc = &quot;size of the Ethernet packet&quot; }
+      },
+    },
+
+    { sig = &quot;u32 #platform_eth_get_packet_nb#( void* buf, u32 maxlen );&quot;,
+      desc = &quot;Non-blocking read of an Ethernet packet from the network&quot;,
+      args = 
+      {
+        { name = &quot;buf&quot;, desc = &quot;start address of the receive buffer&quot; },
+        { name = &quot;maxlen&quot;, desc = &quot;maximum length of the Ethernet packet&quot; },
+      },
+      ret = 
+      {
+        &quot;the size of the read packet or 0 if no packet is available&quot;
+      }
+    },
+
+    { sig = &quot;void #platform_eth_force_interrupt#();&quot;,
+      desc = &quot;Force the Ethernet interrupt on the platform (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at overview</A>@ above for details)&quot;,
+    },
+
+    { sig = &quot;u32 #platform_eth_get_elapsed_time#();&quot;,
+      desc = [[Get the elapsed time (in ms) since the last invocation of the uIP main loop ($elua_uip_mainloop$, from which this function is called). See @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at overview</A>@ for a possible 
+  implementation of this function).]], 
+      ret = 
+      { 
+        &quot;0 if the uIP loop was called because of Ethernet activity, not because a timer expired&quot;,
+        &quot;the Ethernet timer perios in ms (which indicates timer activity)&quot;
+      },
+    }
+  }
+}
+

Copied: trunk/doc/luadoc/arch_platform_ll.lua (from rev 333, trunk/doc/arch_platform/arch_platform_ll.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_ll.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_ll.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,92 @@
+-- eLua platform interface - low level functions
+
+data_en = 
+{
+  -- Title
+  title = &quot;eLua platform interface - low level functions&quot;,
+
+  -- Menu title
+  menu_name = &quot;Low-level&quot;,
+
+  -- Overview
+  overview = [[
+  This part of the platform interface deals contains a small set of &quot;low level functions&quot; that are used to &quot;couple&quot; the eLua port with the
+  target system. No eLua module exposes these functions, as they are strictly used for porting and do not provide any other functionality.
+  ]],
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[// Error / status codes
+enum
+{
+  PLATFORM_ERR,
+  PLATFORM_OK,
+  PLATFORM_UNDERFLOW = -1
+};]],
+      name = &quot;Status codes&quot;,
+      desc = [[
+  This enum defines the possible return values of the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_init at platform_init</A>@ function (although only $PLATFORM_ERR$ and $PLATFORM_OK$ should be 
+  returned from $platform_init$).
+  ]]
+    },
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_init#();&quot;,
+      desc = [[This is the platform-specific initialization code. It is the first function called from %main()% ($src/main.c$) and it should handle
+  all the platform initialization sequence, included (but not limited to) setting up the proper clocks, initializing the interrupt subsystem,
+  setting up various peripherals and so on. Although platform specific, this function has a common part named %cmn_platform_init% (implemented 
+  in $src/common.c$) that initializes terminal support over serial connections, as well as the XMODEM and TERM components 
+  (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at here</A>@ for details). If you need any of these, you need to call %cmn_platform_init% at the end of your 
+  %platform_init% function, $after$ initializing all the peripherals (in particular the UART used for the serial connection).&lt;br&gt;
+  An implementation skeleton for this function is given below:&lt;/p&gt;
+  ~int platform_init()
+  {
+    ............. // perform all your initializations here
+    cmn_platform_init(); // call the common initialiation code
+    return PLATFORM_OK;
+  }~&lt;p&gt;]],
+      ret = 
+      {
+         &quot;$PLATFORM_OK$ for success&quot;,
+         [[$PLATFORM_ERR$ if an error occured. If $PLATFORM_ERR$ is returned,  %main% will block in an infinite loop right 
+  after calling this function, so you should return $PLATFORM_ERR$ only for serious errors]],
+      }, 
+    },
+
+    { sig = &quot;void* #platform_get_last_free_ram#( unsigned id );&quot;,
+      desc = [[Returns the start address of a free RAM area in the system (this is the RAM that will be used by any part of the code that uses malloc(), 
+  a good example being the Lua interpreter itself). There can be multiple free RAM areas in the system (for example the internal MCU RAM and external 
+  RAM chips).  Implemented in $src/common.c$, it uses the the $MEM_START_ADDRESS$ macro that must be defined in the platform's $platform_conf.h$
+  file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). This macro must be defined as an array that contains all the start addresses of 
+  free RAM in the system. For internal RAM, this is generally handled by a linker exported symbol (named $end$ in many eLua ports) which 
+  points to the firs RAM address after all the constant and non-constant program data. An example is given below:&lt;/p&gt;
+  ~#define MEM_START_ADDRESS     { ( void* )end }~&lt;p&gt;]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the identifier of the RAM area&quot; },
+      },
+      ret = &quot;the start address of the given memory area&quot;,   
+    },
+
+    { sig = &quot;void* #platform_get_last_free_ram#( unsigned id );&quot;,
+      desc = [[Returns the last address of a free RAM area in the system (this is the RAM that will be used by any part of the code that uses malloc(), 
+  a good example being the Lua interpreter itself). There can be multiple free RAM areas in the system (for example the internal MCU RAM and external 
+  RAM chips). Implemented in $src/common.c$, it uses the the $MEM_END_ADDRESS$ macro that must be defined in the platform's $platform_conf.h$
+  file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). This macro must be defined as an array that contains all the end addresses of 
+  free RAM in the system. For internal RAM, this is generally set as the last RAM memory address minus the size of the system stack(s). An example is 
+  given below:&lt;/p&gt;
+  ~#define MEM_END_ADDRESS       { ( void* )( SRAM_BASE + 0x10000 - STACK_SIZE_TOTAL - 1 ) }~&lt;p&gt;]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the identifier of the RAM area&quot; },
+      },
+      ret = &quot;the end address of the given memory area&quot;,   
+    },
+
+  }
+}
+

Copied: trunk/doc/luadoc/arch_platform_pio.lua (from rev 333, trunk/doc/arch_platform/arch_platform_pio.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_pio.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_pio.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,113 @@
+-- eLua platform interface - PIO
+
+data_en = 
+{
+  -- Title
+  title = &quot;eLua platform interface - PIO&quot;,
+
+  -- Menu name
+  menu_name = &quot;PIO&quot;,
+
+  -- OverviewA
+  overview = &quot;This part of the platform interface deals with PIO (Programmable Input Output) operations, thus letting the user access the low level input/output facilities of the host MCU.&quot;,
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[enum
+{
+  // Pin operations
+  PLATFORM_IO_PIN_SET,                  $// Set the pin to 1$
+  PLATFORM_IO_PIN_CLEAR,                $// Clear the pin (set it to 0)$
+  PLATFORM_IO_PIN_GET,                  $// Get the value of the pin$
+  PLATFORM_IO_PIN_DIR_INPUT,            $// Make the pin an input$
+  PLATFORM_IO_PIN_DIR_OUTPUT,           $// Make the pin an output$
+  PLATFORM_IO_PIN_PULLUP,               $// Activate the pullup on the pin$
+  PLATFORM_IO_PIN_PULLDOWN,             $// Activate the pulldown on the pin$
+  PLATFORM_IO_PIN_NOPULL,               $// Disable all pullups/pulldowns on the pin$
+  // Port operations
+  PLATFORM_IO_PORT_SET_VALUE,           $// Set port value$
+  PLATFORM_IO_PORT_GET_VALUE,           $// Get port value$
+  PLATFORM_IO_PORT_DIR_INPUT,           $// Set port as input$
+  PLATFORM_IO_PORT_DIR_OUTPUT           $// Set port as output$
+}; ]],
+      name = &quot;PIO operations&quot;,
+      desc = [[These are the operations that can be executed by the PIO subsystem on both ports and pins. They are given as arguments to the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_pio_op at platform_pio_op</A>@ function 
+  shown below. ##TODO: document read in/read out if we keep that]]
+    },
+
+    { text = &quot;typedef u32 pio_type;&quot;,
+      name = &quot;PIO data type&quot;,
+      desc = [[This is the type used for the actual I/O operations. Currently defined as an unsigned 32-bit type, thus no port can have more than 32 pins. If this happens, it is possible to split 
+  it in two or more parts and adding the new parts as &quot;virtual ports&quot; (logical ports that don't have a direct hardware equivalent). The &quot;virtual port&quot; technique is used in the AVR32 backend.]]
+    }
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_pio_has_port#( unsigned port );&quot;,
+      desc = [[Checks if the platform has the hardware port specified as argument. Implemented in %src/common.c%, it uses the $NUM_PIO$ macro that must be defined in the
+  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
+  ~#define NUM_PIO   4      $// The platform has 4 hardware PIO ports$~&lt;p&gt; ]],
+      args = 
+      {
+        { name = &quot;port&quot;, desc = &quot;the port ID&quot; },
+      },
+      ret = &quot;1 if the port exists, 0 otherwise&quot;,
+    },
+
+    { sig = &quot;int #platform_pio_has_pin#( unsigned port, unsigned pin );&quot;,
+      desc = [[Checks if the platform has the hardware port and pin specified as arguments. Implemented in %src/common.c%, it uses the $NUM_PIO$ macro to check the validity
+  of the port and the $PIO_PINS_PER_PORT$ or $PIO_PIN_ARRAY$ macros to check the validity of the pin. The macros must be defined in the platform's $platform_conf.h$ file
+  (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details).
+  &lt;ul&gt;
+    &lt;li&gt;use $PIO_PINS_PER_PORT$ when all the ports of the MCU have the same number of pins. For example:
+      ~#define PIO_PINS_PER_PORT    8   $// Each port has 8 pins$~&lt;/li&gt;
+    &lt;li&gt;use $PIO_PIN_ARRAY$ when different ports of the MCU have different number of pins. For example:
+      ~#define PIO_PIN_ARRAY    { 4, 4, 2, 6 } $// Port 0 has 4 pins, port 1 has 4 pins, port 2 has 2 pins, port 3 has 6 pins$~&lt;/li&gt;
+  &lt;/ul&gt;]],
+      args = 
+      {
+        { name = &quot;port&quot;, desc = &quot;the port ID&quot; },
+        { name = &quot;pin&quot;, desc = &quot;the pin number&quot; },
+      },
+      ret = &quot;1 if the pin exists, 0 otherwise&quot;,
+    },
+
+    { sig = &quot;const char* #platform_pio_get_prefix#( unsigned port );&quot;,
+      desc = [[Get the port prefix. Used to establish if the port notation uses numbers (P0, P1, P2...) or letters (PA, PB, PC...). Implemented in %src/common.c%, it uses the 
+  $PIO_PREFIX$ macro that must be defined in the platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). The value of this macro can be either '0' (for
+  numeric notation) or 'A' (for letter notation). For example:
+  ~#define PIO_PREFIX    'A'   $// Use PA, PB, PC ... for port notation$~&lt;p&gt;]],
+      args = 
+      {
+        { name = &quot;port&quot;, desc = &quot;the port ID&quot; }
+      },
+      ret = &quot;the port prefix (either '0' or 'A')&quot;,  
+    },
+
+    { sig = &quot;pio_type #platform_pio_op#( unsigned port, pio_type pinmask, int op );&quot;,
+      link = &quot;platform_pio_op&quot;,
+      desc = &quot;This is the function that does the actual I/O work. It is implemented in the platform's own porting layer (%platform.c%, see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ports at here</A>@ for more details).&quot;,
+      args = 
+      {
+        { name = &quot;port&quot;, desc = &quot;the port number&quot; },
+        { name = &quot;pinmask&quot;, desc = [[has different meanings:
+  &lt;ul&gt;
+    &lt;li&gt;for $pin operations$ it is the mask of pins in the operation. Each pin on which the function action is executed is encoded with an 1 in the corresponding bit position 
+        of the pinmask.&lt;/li&gt;
+    &lt;li&gt;for $port operations$ it is only meaningful for $PLATFORM_IO_PORT_SET_VALUE$ and in this case it specifies the new value of the port.&lt;/li&gt;
+  &lt;/ul&gt;]]},
+       { name = &quot;op&quot;, desc = &quot;specifies the I/O operations, as specified @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pio_operations at here</A>@.&quot; },
+      },
+     ret = 
+     {
+       &quot;an actual value for $PLATFORM_IO_PIN_GET$ (0 or 1) and $PLATFORM_IO_PORT_GET$ (the value of the port).&quot;,
+       [[an error flag for all the other operations: 1 if the operation succeeded, 0 otherwise. For example, a platform that doesn't have pulldowns on its ports will always return a 0
+        when caled with the $PLATFORM_IO_PIN_PULLDOWN$ operation.]]
+     }
+    },
+  }
+}
+

Copied: trunk/doc/luadoc/arch_platform_pwm.lua (from rev 333, trunk/doc/arch_platform/arch_platform_pwm.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_pwm.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_pwm.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,79 @@
+-- eLua platform interface - PWM
+
+data_en = 
+{
+  -- Title
+  title = &quot;eLua platform interface - PWM&quot;,
+
+  -- Menu name
+  menu_name = &quot;PWM&quot;,
+
+  -- Overview
+  overview = &quot;This part of the platform interface groups functions related to the PWM channel(s) of the MCU.&quot;,
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[// PWM operations
+enum
+{
+  PLATFORM_PWM_OP_START,
+  PLATFORM_PWM_OP_STOP,
+  PLATFORM_PWM_OP_SET_CLOCK,
+  PLATFORM_PWM_OP_GET_CLOCK
+} ]],
+      name = &quot;PWM operations&quot;,
+      desc = &quot;This enum lists all the operations that can be executed on a given PWM channel.&quot;
+    },
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_pwm_exists#( unsigned id );&quot;,
+      desc = [[Checks if the platform has the PWM channel specified as argument. Implemented in %src/common.c%, it uses the $NUM_PWM$ macro that must be defined in the
+  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
+  ~#define NUM_PWM   4      $// The platform has 4 PWM channels$~&lt;p&gt; ]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;PWM channel ID&quot; },
+      },
+      ret = &quot;1 if the specified PWM channel exists, 0 otherwise&quot;
+    },
+
+    { sig = &quot;u32 #platform_pwm_setup#( unsigned id, u32 frequency, unsigned duty );&quot;,
+      desc = &quot;Sets up a PWM channel&quot;,
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;PWM channel ID&quot; },
+        { name = &quot;frequency&quot;, desc = &quot;PWM channel frequency (in hertz)&quot; },
+        { name = &quot;duty&quot;, desc = &quot;PWM channel duty cycle, specified as percent (from 0 to 100). Note that some platform don't allow the full 0%-100% duty cycle&quot; }
+      },
+      ret = &quot;The actual frequency set on the PWM channel, which might differ from the $frequency$ parameter, depeding on the hardware&quot;,
+    },
+
+    { sig = &quot;u32 #platform_pwm_op#( unsigned id, int op, u32 data );&quot;,
+      desc = &quot;Executes an operation on a PWM channel&quot;,
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;PWM channel ID&quot; },
+        { name = &quot;op&quot;, desc = [[the operation that must be executed. It can take any value from @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pwm_operations at this</A> enum@, as follows:
+  &lt;ul&gt;
+    &lt;li&gt;$PLATFORM_PWM_OP_START$: starts PWM generation on the specified channel.&lt;/li&gt;
+    &lt;li&gt;$PLATFORM_PWM_OP_STOP$: stops PWM generation on the specified channel.&lt;/li&gt;  
+    &lt;li&gt;$PLATFORM_PWM_OP_SET_CLOCK$: sets the $base$ clock of the specified PWM channel (which will be used to generate the frequencies requested by 
+        @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_pwm_setup at platform_pwm_setup</A>@) to $data$ hertz.&lt;/li&gt;
+    &lt;li&gt;$PLATFORM_PWM_OP_GET_CLOCK$: get the $base$ clock of the specified PWM channel.&lt;/liA&gt;
+  &lt;/ul&gt;]],},
+        { name = &quot;data&quot;, desc = &quot;When used with $op$ == $PLATFORM_PWM_OP_SET_CLOCK$ it is used to specify the value of the base clock. Not used with other operations.&quot;}
+      },
+      ret = 
+      {
+        &quot;the actual value of the base clock when $op$ == $PLATFORM_PWM_OP_SET_CLOCK$, which might be different than $data$ depending on the hardware&quot;,
+        &quot;the value of the base clock when $op$ == $PLATFORM_PWM_OP_GET_CLOCK$&quot;,
+        &quot;irellevant for other operations&quot;
+      }  
+    }
+  }
+}
+

Copied: trunk/doc/luadoc/arch_platform_spi.lua (from rev 333, trunk/doc/arch_platform/arch_platform_spi.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_spi.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_spi.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,87 @@
+-- eLua platform interface - SPI
+-- Make a full description for each language
+
+data_en = 
+{
+  -- Menu name
+  menu_name = &quot;SPI&quot;,
+
+  -- Title
+  title = &quot;eLua platform interface - SPI&quot;,
+
+  -- Overview
+  overview = &quot;This part of the platform interface groups functions related to the SPI interface(s) of the MCU.&quot;,
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[// SPI mode
+#define PLATFORM_SPI_MASTER                   1
+#define PLATFORM_SPI_SLAVE                    0 ]],
+      name = &quot;Chip select&quot;,
+      desc = &quot;Constants used to select/deselect the SPI SS pin (if applicable).&quot;
+    },
+
+    { text = [[// SS values
+#define PLATFORM_SPI_SELECT_ON                1
+#define PLATFORM_SPI_SELECT_OFF               0]],
+      name = &quot;SPI mode&quot;,
+      desc = &quot;Constants used to select/deselect the SPI SS pin (if applicable).&quot;
+    }, 
+
+    { text = &quot;typedef u32 spi_data_type;&quot;,
+      name = &quot;SPI data type&quot;,
+      desc = &quot;This is the type of a SPI data word, thus limiting the maximum size of a SPI data work to 32 bits (which should be enough for all practical purposes).&quot;
+    }
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_spi_exists#( unsigned id );&quot;,
+      desc = [[Checks if the platform has the hardware SPI specified as argument. Implemented in %src/common.c%, it uses the $NUM_SPI$ macro that must be defined in the
+  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
+  ~#define NUM_SPI   1      $// The platform has 1 SPI interface$~&lt;/p&gt; ]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;SPI interface ID&quot; },
+      },
+      ret = &quot;1 if the SPI interface exists, 0 otherwise&quot;
+    },
+
+    { sig = &quot;u32 #platform_spi_setup#( unsigned id, int mode, u32 clock, unsigned cpol, unsigned cpha, unsigned databits );&quot;,
+      desc = [[This function is used to initialize the parameters of the SPI interface. &lt;br&gt;&lt;font color=&quot;red&quot;&gt;$NOTE$&lt;/font&gt;: currently, only master SPI mode is implemented in eLua.]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;SPI interface ID&quot; },
+        { name = &quot;mode&quot;, desc = &quot;SPI port mode ($PLATFORM_SPI_MASTER$ or $PLATFORM_SPI_SLAVE$, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">spi_mode at here</A>@.&quot; },
+        { name = &quot;clock&quot;, desc = &quot;clock speed for the SPI interface in master mode.&quot; },
+        { name = &quot;cpol&quot;, desc = &quot;SPI clock polarity&quot; },
+        { name = &quot;cpha&quot;, desc = &quot;SPI clock phase&quot; },
+        { name = &quot;databits&quot;, desc = &quot;length of the SPI data word in bits (usually 8, but configurable on some platforms).&quot; }
+      },
+      ret = &quot;the actual clock set for the SPI interface. Depending on the hardware, this may have a different value than the $clock$ argument.&quot;
+    },
+
+    {  sig = &quot;spi_data_type #platform_spi_send_recv#( unsigned id, spi_data_type data );&quot;,
+       desc = &quot;Executes a SPI read/write cycle&quot;,
+       args = 
+       {
+         { name = &quot;id&quot;, desc = &quot;SPI interface ID&quot; },
+         { name = &quot;data&quot;, desc = &quot;data to be sent to the SPI interface&quot; },
+       },
+       ret = &quot;data read from the SPI interface&quot;
+    },
+
+    { sig = &quot;void #platform_spi_select#( unsigned id, int is_select );&quot;,
+      desc = [[For platforms that have a dedicates SS (Slave Select) pin in master SPI mode that can be controlled manually, this function should enable/disable this pin. If this functionality
+  does not exist in hardware this function does nothing.]],
+      args =
+      {
+        { name = &quot;id&quot;, desc = &quot;SPI interface ID.&quot; },
+        { name = &quot;is_select&quot;, desc = &quot;$PLATFORM_SPI_SELECT_ON$ to select, $PLATFORM_SPI_SELECT_OFF$ to deselect , see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">chip_select at here</A>@.&quot; }
+      },
+    }
+  }
+}
+

Copied: trunk/doc/luadoc/arch_platform_timers.lua (from rev 333, trunk/doc/arch_platform/arch_platform_timers.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_timers.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_timers.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,190 @@
+-- eLua platform interface - timers
+
+data_en = 
+{
+  -- Title
+  title = &quot;eLua platform interface - timers&quot;,
+
+  -- Menu name
+  menu_name = &quot;Timers&quot;,
+
+  -- Overview
+  overview = [[This part of the platform interface groups functions related to the timers of the MCU. It also makes provisions for using $virtual timers$ on any platform, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">virtual at this</A> section@
+  for details. Keep in mind that in the following paragraphs a $timer id$ can reffer to both a hardware timer or a virtual timer.]],
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = &quot;typedef u32 timer_data_type;&quot;,
+      name = &quot;Timer data type&quot;,
+      desc = &quot;This defines the data type used to specify delays and time intervals (which are always specifide in $microseconds$).&quot;
+    },
+
+    { text = [[// Timer operations
+enum
+{
+  PLATFORM_TIMER_OP_START,
+  PLATFORM_TIMER_OP_READ,
+  PLATFORM_TIMER_OP_SET_CLOCK,
+  PLATFORM_TIMER_OP_GET_CLOCK,
+  PLATFORM_TIMER_OP_GET_MAX_DELAY,
+  PLATFORM_TIMER_OP_GET_MIN_DELAY
+};]], 
+      name = &quot;Timer operations&quot;,
+      desc = &quot;This enum lists all the operations that can be executed on a given timer.&quot;
+    }
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_timer_exists#( unsigned id );&quot;,
+      desc = [[Checks if the platform has the timer specified as argument. Implemented in %src/common.c%, it uses the $NUM_TIMER$ macro that must be defined in the
+  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details) and the virtual timer configuration (@#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">virtual at here</A>@ for details). For example:&lt;/p&gt;
+  ~#define NUM_TIMER   2      $// The platform has 2 hardware timers$~&lt;p&gt;]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
+      },
+      ret = &quot;1 if the timer exists, 0 otherwise&quot;
+    },
+
+    { sig = &quot;void #platform_timer_delay#( unsigned id, u32 delay_us );&quot;,
+      desc = [[Waits on a timer, then returns. This function is &quot;split&quot; in two parts: a platform-independent part implemented in %src/common.c% (that
+  handles virtual timers) and a platform-dependent part that must be implemented by each platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_timer_delay at platform_s_timer_delay</A>@. This function handles both
+  hardware timer IDs and virtual timer IDs.&lt;br&gt;
+  &lt;font color=&quot;red&quot;&gt;&lt;a name=&quot;limitations&quot;&gt;$IMPORTANT NOTE$&lt;/font&gt;&lt;/a&gt;: the real delay after executing this functions depends a number of variables, most notably the base clock of the timer 
+  and the size of the timer counter register (32 bits on some platforms, 16 bits on most platforms, other values are less common). To ensure that the delay you're requesting is achievable, use 
+  @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_op at platform_timer_op</A>@ with $PLATFORM_TIMER_OP_GET_MAX_DELAY$ and $PLATFORM_TIMER_OP_GET_MIN_DELAY$ to obtain the maximum and the minimum 
+  achievable wait times on your timer, respectively. Even if your delay is within these limits, the $precision$ of this function still varies a lot, mainly as a function of 
+  the timer base clock.]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
+        { name = &quot;delay_us&quot;, desc = &quot;the delay time (in microseconds)&quot; }
+      }
+    },
+
+    { sig = &quot;void #platform_s_timer_delay#( unsigned id, u32 delay_us );&quot;,
+      desc = [[This function is identical in functionality to @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_delay at platform_timer_delay</A>@, but this is the function that must actually be implemented by a platform port, 
+  and it must never handle virtual timer IDs, only hardware timer IDs. It has the same @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">limitations at limitations</A>@ as @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_delay at platform_timer_delay</A>@.]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
+        { name = &quot;delay_us&quot;, desc = &quot;the delay time (in microseconds)&quot; }
+      }
+    },
+
+    { sig = &quot;u32 #platform_timer_op#( unsigned id, int op, u32 data );&quot;,
+      desc = [[Executes an operation on a timer. This function is &quot;split&quot; in two parts: a platform-independent part implemented in %src/common.c% (that handles virtual timers) and a 
+  platform-dependent part that must be implemented by each platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_timer_op at platform_s_timer_op</A>@. This function handles both hardware timer IDs and virtual 
+  timer IDs.]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
+        { name = &quot;op&quot;, desc = [[the operation. $op$ can take any value from the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">timer_operations at this</A> enum@, as follows:
+  &lt;ul&gt;
+    &lt;li&gt;$PLATFORM_TIMER_OP_START$: start the specified timer by setting its counter register to a predefined value.&lt;/li&gt;
+    &lt;li&gt;$PLATFORM_TIMER_OP_READ$: get the value of the specified timer's counter register.&lt;/li&gt; 
+    &lt;li&gt;$PLATFORM_TIMER_SET_CLOCK$: set the clock of the specified timer to $data$ (in hertz). You can never set the clock of a virtual timer, which is set at compile time.&lt;/li&gt;  
+    &lt;li&gt;$PLATFORM_TIMER_GET_CLOCK$: get the clock of the specified timer.&lt;/li&gt;  
+    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MAX_DELAY$: get the maximum achievable timeout on the specified timer (in us).&lt;/li&gt;  
+    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MIN_DELAY$: get the minimum achievable timeout on the specified timer (in us).&lt;/li&gt;
+  &lt;/ul&gt;]] },
+        { name = &quot;data&quot;, desc = &quot;used to specify the timer clock value when $op = PLATFORM_TIMER_SET_CLOCK$, ignored otherwise&quot; },
+      },
+      ret = 
+      {
+        &quot;the predefined value used when starting the clock if $op = PLATFORM_TIMER_OP_START$&quot;,
+        &quot;the timer's counter register if $op = PLATFORM_TIMER_OP_READ$&quot;,
+        &quot;the actual clock set on the timer, which might be different than the request clock depending on the hardware if $op = PLATFORM_TIMER_SET_CLOCK$&quot;,
+        &quot;the timer clock if $op = PLATFORM_TIMER_GET_CLOCK$&quot;, 
+        &quot;the maximum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MAX_DELAY$&quot;,
+        &quot;the minimum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MIN_DELAY$&quot;
+      }
+    }, 
+
+    { sig = &quot;u32 #platform_s_timer_op#( unsigned id, int op, u32 data );&quot;,
+      desc = [[This function is identical in functionality to @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_op at platform_timer_op</A>@, but this is the function that must actually be implemented by a platform port, and it must 
+  never handle virtual timer IDs, only hardware timer IDs.]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
+        { name = &quot;op&quot;, desc = [[the operation. $op$ can take any value from the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">opval at this</A> enum@, as follows:
+  &lt;ul&gt;
+    &lt;li&gt;$PLATFORM_TIMER_OP_START$: start the specified timer by setting its counter register to a predefined value.&lt;/li&gt;
+    &lt;li&gt;$PLATFORM_TIMER_OP_READ$: get the value of the specified timer's counter register.&lt;/li&gt; 
+    &lt;li&gt;$PLATFORM_TIMER_SET_CLOCK$: set the clock of the specified timer to $data$ (in hertz). You can never set the clock of a virtual timer, which is set at compile time.&lt;/li&gt;  
+    &lt;li&gt;$PLATFORM_TIMER_GET_CLOCK$: get the clock of the specified timer.&lt;/li&gt;  
+    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MAX_DELAY$: get the maximum achievable timeout on the specified timer (in us).&lt;/li&gt;  
+    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MIN_DELAY$: get the minimum achievable timeout on the specified timer (in us).&lt;/li&gt;
+  &lt;/ul&gt;]] },
+        { name = &quot;data&quot;, desc = &quot;used to specify the timer clock value when $op = PLATFORM_TIMER_SET_CLOCK$, ignored otherwise&quot; },
+      },
+      ret = 
+      {
+        &quot;the predefined value used when starting the clock if $op = PLATFORM_TIMER_OP_START$&quot;,
+        &quot;the timer's counter register if $op = PLATFORM_TIMER_OP_READ$&quot;,
+        &quot;the actual clock set on the timer, which might be different than the request clock depending on the hardware if $op = PLATFORM_TIMER_SET_CLOCK$&quot;,
+        &quot;the timer clock if $op = PLATFORM_TIMER_GET_CLOCK$&quot;, 
+        &quot;the maximum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MAX_DELAY$&quot;,
+        &quot;the minimum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MIN_DELAY$&quot;
+      }
+    }, 
+
+    { sig = &quot;u32 #platform_timer_get_diff_us#( unsigned id, timer_data_type end, timer_data_type start );&quot;,
+      desc = [[Return the time difference (in us) betweeen two timer values. This function is generic for all platforms, thus it is implemented in %src/common.c%.]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;the timer ID&quot; },
+        { name = &quot;end&quot;, desc = &quot;the first timer value&quot; },
+        { name = &quot;start&quot;, desc = &quot;the second timer value&quot; },
+      },
+      ret = &quot;the time difference (in microseconds)&quot;
+    }
+  },
+
+  auxdata = 
+  {
+    { title = &quot;Virtual timers&quot;,
+      desc = 
+  [[$Virtual timers$ were added to eLua to overcome some limitations:
+  &lt;ul&gt;
+    &lt;li&gt;there are generally few hardware timers available, some of which might be dedicated (thus not usable directly by eLua).&lt;/li&gt;
+    &lt;li&gt;many times it is difficult to share a hardware timer between different parts of an application because of conflicting requirements. Generally it's not possible to have timers that can
+        achieve long delays and high accuracy at the same time (this is especially true for systems that have 16 bit or even smaller timers).&lt;/li&gt;
+  &lt;/ul&gt;&lt;/p&gt;
+  &lt;p&gt;In this respect, $virtual timers$ are a set of timers that share a single hardware timer. It is possible, in this way, to have a hardware timer that can implement 4, 8 or more hardware
+  timers. There are a few drawbacks to this approach:
+  &lt;ul&gt;
+    &lt;li&gt;the hardware timer used to implement the virtual timers must generally be dedicated. In fact in cat be still used in &quot;read only mode&quot;, which means that the only operations that can
+        be executed on it are $PLATFORM_TIMER_OP_READ$, $PLATFORM_TIMER_GET_CLOCK$, $PLATFORM_TIMER_OP_GET_MAX_DELAY$ and $PLATFORM_TIMER_OP_GET_MIN_DELAY$. However,
+        since the &quot;read only mode&quot; is not enforced by the code, it is advisable to treat this timer as a dedicated resource and thus make it invisible to eLua by not associating it with 
+        an ID.&lt;/li&gt;
+    &lt;li&gt;the number of virtual timers and their base frequency are fixed at compile time.&lt;/li&gt;
+    &lt;li&gt;virtual timers are generally used for large delays with low accuracy, since their base frequency should be fairly low (see below).&lt;/li&gt;
+  &lt;/ul&gt;&lt;/p&gt;
+  &lt;p&gt;To $enable$ virtual timers:
+  &lt;ol&gt;
+    &lt;li&gt;edit $platform_conf.h$ (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details) and set $VTMR_NUM_TIMERS$ to the number of desired virtual timers and 
+       $VTMR_FREQ_HZ$ to the base frequency of the virtual timers (in hertz). For example:
+  ~#define VTMR_NUM_TIMERS       4 // we need 4 virtual timers
+#define VTMR_FREQ_HZ          4 // the base clock for the virtual timers is 4Hz~&lt;/li&gt;
+    &lt;li&gt;in your platform port setup a hardware timer to fire an interrupt at $VTMR_FREQ_HZ$ and call the $cmn_virtual_timer_cb$ function (defined in %src/common.c%) in the 
+       timer interrupt handler. For example, if the the interrupt handler is called $timer_int_handler$, do this:
+  ~void timer_int_handler( void )
+{
+  // add code to clear the timer interrupt flag here if needed
+  cmn_virtual_timer_cb();
+}~&lt;/li&gt;
+  &lt;/ol&gt;&lt;/p&gt;
+  &lt;p&gt;Note that because of step 2 above you are limited by practical constraints on the value of $VTMR_FREQ_HZ$. If set too high, the timer interrupt will fire too often, thus taking too much
+  CPU time. The maximum value depends largely on the hardware and the desired behaviour of the virtual timers, but in practice values larger than 10 might visibly change the behaviour of your 
+  system.&lt;/p&gt;
+  &lt;p&gt;To $use$ a virtual timer, identify it with the constant $VTMR_FIRST_ID$ (defined in %inc/common.h%) plus an offset. For example, $VTMR_FIRST_ID+0$ (or simply
+  $VTMR_FIRST_ID$) is the ID of the first virtual timer in the system, and $VTMR_FIRST_ID+2$ is the ID of the third virtual timer in the system.&lt;/p&gt;
+  ]]
+    }
+  }
+}
+

Copied: trunk/doc/luadoc/arch_platform_uart.lua (from rev 333, trunk/doc/arch_platform/arch_platform_uart.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_uart.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/arch_platform_uart.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,129 @@
+-- eLua platform interface - UART
+
+data_en = 
+{
+  -- Title
+  title = &quot;eLua platform interface - UART&quot;,
+
+  -- Menu name
+  menu_name = &quot;UART&quot;,
+
+  -- Overview
+  overview = &quot;This part of the platform interface groups functions related to the UART interface(s) of the MCU.&quot;,
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[// Parity
+enum
+{
+  PLATFORM_UART_PARITY_EVEN,
+  PLATFORM_UART_PARITY_ODD,
+  PLATFORM_UART_PARITY_NONE
+};]],
+      name = &quot;UART parity&quot;,
+      desc = &quot;Constants used to specify the UART parity mode.&quot;
+    },
+
+    { text = [[// Stop bits
+enum
+{
+  PLATFORM_UART_STOPBITS_1,
+  PLATFORM_UART_STOPBITS_1_5,
+  PLATFORM_UART_STOPBITS_2
+};]],
+      name = &quot;UART stop bits&quot;,
+      desc = &quot;Constants used to specify the number of UART stop bits.&quot;,
+    },
+
+    { text = [[// &quot;Infinite timeout&quot; constant for recv
+#define PLATFORM_UART_INFINITE_TIMEOUT        (-1)]],
+      name = &quot;UART timeout&quot;,
+      desc = &quot;This constant is used as a special timeout value (infinite timeout) in the UART functions that expect a timeout as argument.&quot;,
+    }
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;int #platform_uart_exists#( unsigned id );&quot;,
+      desc = [[Checks if the platform has the hardware UART specified as argument. Implemented in %src/common.c%, it uses the $NUM_UART$ macro that must be defined in the
+  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
+  ~#define NUM_UART   2      $// The platform has 2 UART interfaces$~&lt;p&gt;]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;UART interface ID&quot; },
+      },
+      ret = &quot;1 if the specified UART exists, 0 otherwise&quot;
+    },
+
+    { sig = &quot;u32 #platform_uart_setup#( unsigned id, u32 baud, int databits, int parity, int stopbits );&quot;,
+      desc = &quot;This function is used to initialize the parameters of the UART interface.&quot;,
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
+        { name = &quot;baud&quot;, desc = &quot;baud rate.&quot; },
+        { name = &quot;databits&quot;, desc = &quot;number of databits (maximum 8).&quot; },
+        { name = &quot;parity&quot;, desc = &quot;parity type (can be either $PLATFORM_UART_PARITY_EVEN$, $PLATFORM_UART_PARITY_ODD$ or $PLATFORM_UART_PARITY_NONE$, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_parity at here</A>@).&quot; },
+        { name = &quot;stopbits&quot;, desc = [[number of stop bits (can be either $PLATFORM_UART_STOPBITS_1$, $PLATFORM_UART_STOPBITS_1_5$ or $PLATFORM_UART_STOPBITS_2$, see
+           @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_stop_bits at here</A>@).]] },
+      },
+      ret = &quot;the actual baud rate. Depending on the hardware, this may have a different value than the $baud$ argument.&quot;,
+    },
+
+    { sig = &quot;void #platform_uart_send#( unsigned id, u8 data );&quot;,
+      desc = &quot;Send data to an UART interface.&quot;,
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
+        { name = &quot;data&quot;, desc = &quot;data to be sent.&quot; },
+      },
+    },
+
+    { sig = &quot;int #platform_uart_recv#( unsigned id, unsigned timer_id, s32 timeout );&quot;,
+      link = &quot;platform_uart_recv&quot;,
+      desc = [[Receive data from the UART interface (blocking/non blocking with timeout/immediate).&lt;br&gt;
+  This function is &quot;split&quot; in two parts: a platform-independent part that is implemented in %src/common.c%, and a platform-dependent part that must be implemented by each
+  platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_uart_recv at platform_s_uart_recv</A>@.]],
+      args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
+        { name = &quot;timer_id&quot;, desc = &quot;the ID of the timer used in this operation (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">arch_platform_timers.html at here</A>@ for details). See also the description of the $timeout$ argument.&quot; },
+        { name = &quot;timeout&quot;, desc = [[specifies a timeout for the receive operation as follows:
+  &lt;ul&gt;
+    &lt;li&gt;$timeout &gt; 0$: the timer with the specified $timer_id$ will be used to timeout the receive operation after $timeout$ microseconds.&lt;/li&gt;
+    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not. $timer_id$ is ignored.&lt;/li&gt;
+    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it. In this mode the function doesn't 
+        time out, so $timer_id$ is ignored.&lt;/li&gt;
+  &lt;/ul&gt;]] },
+      },
+      ret = 
+      {
+        &quot;if $timeout &gt; 0$ and data from the UART is available in $timeout$ microseconds of less it is returned, otherwise -1 is returned&quot;,
+        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
+        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
+      }
+    },
+
+    { sig = &quot;int #platform_s_uart_recv#( unsigned id, s32 timeout );&quot;,
+      link = &quot;platform_s_uart_recv&quot;,
+      desc = [[This is the platform-dependent part of the UART receive function @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@, and is in fact a &quot;subset&quot; of the full function 
+  (thus being easier to implement by each platform in part). In particular, it never needs to deal with the $timeout &gt; 0$ case, which is handled by @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@.]],
+       args = 
+      {
+        { name = &quot;id&quot;, desc = &quot;UART interface ID.&quot; },
+        { name = &quot;timeout&quot;, desc = [[specifies a timeout for the receive operation as follows:
+  &lt;ul&gt;
+    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not.&lt;/li&gt;
+    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it.&lt;/li&gt;
+  &lt;/ul&gt;]] },
+      },
+      ret = 
+      {
+        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
+        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
+      }
+    }
+  }
+}
+

Copied: trunk/doc/luadoc/template.lua (from rev 333, trunk/doc/arch_platform/arch_platform_template.lua)
===================================================================
--- trunk/doc/arch_platform/arch_platform_template.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/luadoc/template.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -0,0 +1,52 @@
+-- eLua platform interface - name
+
+data_en = 
+{
+
+  -- Title
+  title = &quot;eLua platform interface - name&quot;,
+
+  -- Menu name
+  menu_name = &quot;name&quot;
+
+  -- Overview
+  overview = [[
+  ]],
+
+  -- Data structures, constants and types
+  structures = 
+  {
+    { text = [[ ]],
+      name = &quot;&quot;, 
+      desc = [[ ]]
+    },
+  },
+
+  -- Functions
+  funcs = 
+  {
+    { sig = &quot;void #functionname#( void )&quot;,
+      desc = [[ ]],
+      args = 
+      {
+        { name = &quot;&quot;, desc = &quot;&quot; },
+        { name = &quot;&quot;, desc = &quot;&quot; }
+      },
+      ret = 
+      {
+         &quot;&quot;,
+         [[ ]],
+      }, 
+    },
+
+  },
+
+  -- Aux data
+  auxdata = 
+  {
+    { title = &quot;&quot;,
+      desc = [[]]
+    }
+  }
+}
+

Modified: trunk/doc/wb/wb_usr_template.lua
===================================================================
--- trunk/doc/wb/wb_usr_template.lua	2009-06-29 16:42:38 UTC (rev 333)
+++ trunk/doc/wb/wb_usr_template.lua	2009-06-29 16:42:56 UTC (rev 334)
@@ -287,7 +287,12 @@
                 },
               },
             },
-$$ARCH_PLATFORM$$,
+            { name = { en = &quot;Platform interface&quot;, pt = &quot;##Platform interface&quot; },
+              link = &quot;arch_platform.html&quot;,
+              folder = {
+                $$ARCH_PLATFORM$$
+              }
+            },
             { name = { en = &quot;ROM file system&quot;, pt = &quot;##ROM file system&quot; },
               link = &quot;arch_romfs.html&quot;,
             },
@@ -350,340 +355,14 @@
 
     {
       name = { en = &quot;Reference Manual&quot;, pt = &quot;Manual de Refer&#234;ncia&quot; },
-      link = &quot;refman.html#genericmodules&quot;,
+      link = &quot;refman.html&quot;,
       folder = 
       {
         {
           name = { en = &quot;Generic Modules&quot;, pt = &quot;M&#243;dulos Gen&#233;ricos&quot; },
-          link = &quot;refman.html#genericmodules&quot;,
-          folder = 
-          {
-            {
-              name = { en = &quot;bit&quot;, pt = &quot;bit&quot; },
-              link = &quot;refman.html#bitmodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;bnot&quot;, pt = &quot;bnot&quot; },
-                  link = &quot;refman.html#bit_bnot&quot;
-                },
-                {
-                  name ={ en = &quot;band&quot;, pt = &quot;band&quot; },
-                  link = &quot;refman.html#bit_band&quot;
-                },
-                {
-                  name ={ en = &quot;bor&quot;, pt = &quot;bor&quot; },
-                  link = &quot;refman.html#bit_bor&quot;
-                },
-                {
-                  name ={ en = &quot;bxor&quot;, pt = &quot;bxor&quot; },
-                  link = &quot;refman.html#bit_bxor&quot;
-                },
-                {
-                  name ={ en = &quot;lshift&quot;, pt = &quot;lshift&quot; },
-                  link = &quot;refman.html#bit_lshift&quot;
-                },
-                {
-                  name ={ en = &quot;rshift&quot;, pt = &quot;rshift&quot; },
-                  link = &quot;refman.html#bit_rshift&quot;
-                },
-                {
-                  name ={ en = &quot;bit&quot;, pt = &quot;bit&quot; },
-                  link = &quot;refman.html#bit_bit&quot;
-                },
-                {
-                  name ={ en = &quot;set&quot;, pt = &quot;set&quot; },
-                  link = &quot;refman.html#bit_set&quot;
-                },
-                {
-                  name ={ en = &quot;clear&quot;, pt = &quot;clear&quot; },
-                  link = &quot;refman.html#bit_clear&quot;
-                },
-                {
-                  name ={ en = &quot;isset&quot;, pt = &quot;isset&quot; },
-                  link = &quot;refman.html#bit_isset&quot;
-                },
-                {
-                  name ={ en = &quot;isclear&quot;, pt = &quot;isclear&quot; },
-                  link = &quot;refman.html#bit_isclear&quot;
-                },
-              },
-            },  
-            {
-              name = { en = &quot;cpu&quot;, pt = &quot;cpu&quot; },
-              link = &quot;refman.html#cpumodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;write32&quot;, pt = &quot;write32&quot; },
-                  link = &quot;refman.html#cpu_write32&quot;
-                },
-                {
-                  name ={ en = &quot;write16&quot;, pt = &quot;write16&quot; },
-                  link = &quot;refman.html#cpu_write16&quot;
-                },
-                {
-                  name ={ en = &quot;write8&quot;, pt = &quot;write8&quot; },
-                  link = &quot;refman.html#cpu_write8&quot;
-                },
-                {
-                  name ={ en = &quot;reat32&quot;, pt = &quot;read32&quot; },
-                  link = &quot;refman.html#cpu_read32&quot;
-                },
-                {
-                  name ={ en = &quot;read16&quot;, pt = &quot;read16&quot; },
-                  link = &quot;refman.html#cpu_read16&quot;
-                },
-                {
-                  name ={ en = &quot;read8&quot;, pt = &quot;read8&quot; },
-                  link = &quot;refman.html#cpu_read8&quot;
-                },
-                {
-                  name ={ en = &quot;disableinterrupts&quot;, pt = &quot;disableinterrupts&quot; },
-                  link = &quot;refman.html#cpu_disableinterrupts&quot;
-                },
-                {
-                  name ={ en = &quot;enableinterrupts&quot;, pt = &quot;enableinterrupts&quot; },
-                  link = &quot;refman.html#cpu_enableinterrupts&quot;
-                },
-                {
-                  name ={ en = &quot;clockfrequency&quot;, pt = &quot;clockfrequency&quot; },
-                  link = &quot;refman.html#cpu_clockfrequency&quot;
-                },
-              },
-            },
-            {
-              name = { en = &quot;gpio&quot;, pt = &quot;gpio&quot; },
-              link = &quot;refman.html#gpiomodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;configpin&quot;, pt = &quot;configpin&quot; },
-                  link = &quot;refman.html#gpio_configpin&quot;
-                },
-                {
-                  name ={ en = &quot;setpinvalue&quot;, pt = &quot;setpinvalue&quot; },
-                  link = &quot;refman.html#gpio_setpinvalue&quot;
-                },
-                {
-                  name ={ en = &quot;getpinvalue&quot;, pt = &quot;getpinvalue&quot; },
-                  link = &quot;refman.html#gpio_getpinvalue&quot;
-                },
-                {
-                  name ={ en = &quot;setpinhigh&quot;, pt = &quot;setpinhigh&quot; },
-                  link = &quot;refman.html#gpio_setpinhigh&quot;
-                },
-                {
-                  name ={ en = &quot;setpinlow&quot;, pt = &quot;setpinlow&quot; },
-                  link = &quot;refman.html#gpio_setpinlow&quot;
-                },
-              },
-            },  
-            {
-              name = {en = &quot;net&quot;, pt = &quot;net&quot; },
-              link = &quot;refman.html#netmodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;to be added ...&quot;, pt = &quot;setup&quot; },
-                  link = &quot;net_ref.html#net_setup&quot;
-                },
-              },
-            },  
-            {
-              name = { en = &quot;pwm&quot;, pt = &quot;pwm&quot; },
-              link = &quot;refman.html#pwmmodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;setup&quot;, pt = &quot;setup&quot; },
-                  link = &quot;refman.html#pwm_setup&quot;
-                },
-                {
-                  name ={ en = &quot;setcycle&quot;, pt = &quot;setcycle&quot; },
-                  link = &quot;refman.html#pwm_setcycle&quot;
-                },
-                {
-                  name ={ en = &quot;start&quot;, pt = &quot;start&quot; },
-                  link = &quot;refman.html#pwm_start&quot;
-                },
-                {
-                  name ={ en = &quot;stop&quot;, pt = &quot;stop&quot; },
-                  link = &quot;refman.html#pwm_stop&quot;
-                },
-                {
-                  name ={ en = &quot;setclock&quot;, pt = &quot;setclock&quot; },
-                  link = &quot;refman.html#pwm_setclock&quot;
-                },
-                {
-                  name ={ en = &quot;getclock&quot;, pt = &quot;getclock&quot; },
-                  link = &quot;refman.html#pwm_getclock&quot;
-                },
-              },
-            },
-            {
-              name = { en = &quot;spi&quot;, pt = &quot;spi&quot; },
-              link = &quot;refman.html#spimodules&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;setup&quot;, pt = &quot;setup&quot; },
-                  link = &quot;refman.html#spi_setup&quot;
-                },
-                {
-                  name ={ en = &quot;select&quot;, pt = &quot;select&quot; },
-                  link = &quot;refman.html#spi_select&quot;
-                },
-                {
-                  name ={ en = &quot;unselect&quot;, pt = &quot;unselect&quot; },
-                  link = &quot;refman.html#spi_unselect&quot;
-                },
-                {
-                  name ={ en = &quot;send&quot;, pt = &quot;send&quot; },
-                  link = &quot;refman.html#spi_send&quot;
-                },
-                {
-                  name ={ en = &quot;sendrecv&quot;, pt = &quot;sendrecv&quot; },
-                  link = &quot;refman.html#spi_sendrecv&quot;
-                },
-              },
-            },
-            {
-              name = { en = &quot;sys&quot;, pt = &quot;sys&quot; },
-              link = &quot;refman.html#sysmodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;platform&quot;, pt = &quot;platform&quot; },
-                  link = &quot;refman.html#sys_platforms&quot;
-                },
-                {
-                  name ={ en = &quot;mcu&quot;, pt = &quot;mcu&quot; },
-                  link = &quot;refman.html#sys_mcu&quot;
-                },
-                {
-                  name ={ en = &quot;cpu&quot;, pt = &quot;cpu&quot; },
-                  link = &quot;refman.html#sys_cpu&quot;
-                },
-                {
-                  name ={ en = &quot;board&quot;, pt = &quot;board&quot; },
-                  link = &quot;refman.html#sys_board&quot;
-                },
-              },
-            },
-            {
-              name = {en = &quot;term&quot;, pt = &quot;term&quot; },
-              link = &quot;refman.html#termmodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;clear&quot;, pt = &quot;clear&quot; },
-                  link = &quot;refman.html#term_clear&quot;
-                },
-                {
-                  name ={ en = &quot;cleareol&quot;, pt = &quot;cleareol&quot; },
-                  link = &quot;refman.html#term_cleareol&quot;
-                },
-                {
-                  name ={ en = &quot;moveto&quot;, pt = &quot;moveto&quot; },
-                  link = &quot;refman.html#term_moveto&quot;
-                },
-                {
-                  name ={ en = &quot;moveup&quot;, pt = &quot;moveup&quot; },
-                  link = &quot;refman.html#term_moveup&quot;
-                },
-                {
-                  name ={ en = &quot;movedown&quot;, pt = &quot;movedown&quot; },
-                  link = &quot;refman.html#term_movedown&quot;
-                },
-                {
-                  name ={ en = &quot;moveleft&quot;, pt = &quot;moveleft&quot; },
-                  link = &quot;refman.html#term_moveleft&quot;
-                },
-                {
-                  name ={ en = &quot;moveright&quot;, pt = &quot;moveright&quot; },
-                  link = &quot;refman.html#term_moveright&quot;
-                },
-                {
-                  name ={ en = &quot;getlinecount&quot;, pt = &quot;getlinecount&quot; },
-                  link = &quot;refman.html#term_getlinecount&quot;
-                },
-                {
-                  name ={ en = &quot;getcolcount&quot;, pt = &quot;getcolcount&quot; },
-                  link = &quot;refman.html#term_getcolcount&quot;
-                },
-                {
-                  name ={ en = &quot;printstr&quot;, pt = &quot;printstr&quot; },
-                  link = &quot;refman.html#term_printstr&quot;
-                },
-                {
-                  name ={ en = &quot;getx&quot;, pt = &quot;getx&quot; },
-                  link = &quot;refman.html#term_getx&quot;
-                },
-                {
-                  name ={ en = &quot;gety&quot;, pt = &quot;gety&quot; },
-                  link = &quot;refman.html#term_gety&quot;
-                },
-                {
-                  name ={ en = &quot;inputchar&quot;, pt = &quot;inputchar&quot; },
-                  link = &quot;refman.html#term_inputchar&quot;
-                },
-              },
-            },  
-            {
-              name = { en = &quot;tmr&quot;, pt = &quot;tmr&quot; },
-              link = &quot;refman.html#tmrmodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;delay&quot;, pt = &quot;delay&quot; },
-                  link = &quot;refman.html#tmr_delay&quot;
-                },
-                {
-                  name ={ en = &quot;read&quot;, pt = &quot;read&quot; },
-                  link = &quot;refman.html#tmr_read&quot;
-                },
-                {
-                  name ={ en = &quot;start&quot;, pt = &quot;start&quot; },
-                  link = &quot;refman.html#tmr_start&quot;
-                },
-                {
-                  name ={ en = &quot;diff&quot;, pt = &quot;diff&quot; },
-                  link = &quot;refman.html#tmr_diff&quot;
-                },
-                {
-                  name ={ en = &quot;mindelay&quot;, pt = &quot;mindelay&quot; },
-                  link = &quot;refman.html#tmr_mindelay&quot;
-                },
-                {
-                  name ={ en = &quot;maxdelay&quot;, pt = &quot;maxdelay&quot; },
-                  link = &quot;refman.html#tmr_maxdelay&quot;
-                },
-                {
-                  name ={ en = &quot;setclock&quot;, pt = &quot;setclock&quot; },
-                  link = &quot;refman.html#tmr_setclock&quot;
-                },
-              },
-            },
-            {
-              name = {en = &quot;uart&quot;, pt = &quot;uart&quot; },
-              link = &quot;refman.html#uartmodule&quot;,
-              folder =
-              {
-                {
-                  name ={ en = &quot;setup&quot;, pt = &quot;setup&quot; },
-                  link = &quot;refman.html#uart_setup&quot;
-                },
-                {
-                  name ={ en = &quot;send&quot;, pt = &quot;send&quot; },
-                  link = &quot;refman.html#uart_send&quot;
-                },
-                {
-                  name ={ en = &quot;recv&quot;, pt = &quot;recv&quot; },
-                  link = &quot;refman.html#uart_recv&quot;
-                },
-              },
-            },  
+          link = &quot;refman_gen.html&quot;,
+          folder = {
+            $$REFMAN_GEN$$,        
           },
         },
         {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000289.html">[Elua-svn] r333 - in trunk/doc: . wb_img wb_img/index_en_files	wb_img/index_en_files/news_data wb_img/index_en_files/wb_bar_en_data	wb_img/index_en_files/wb_title_en_data	wb_img/index_en_files/wb_tree_en_data
</A></li>
	<LI>Next message: <A HREF="000291.html">[Elua-svn] r335 - in trunk/doc: . en luadoc wb
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#290">[ date ]</a>
              <a href="thread.html#290">[ thread ]</a>
              <a href="subject.html#290">[ subject ]</a>
              <a href="author.html#290">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
