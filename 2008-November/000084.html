<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r128 - in trunk: . inc romfs src src/modules	src/platform/lm3s
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r128%20-%20in%20trunk%3A%20.%20inc%20romfs%20src%20src/modules%0A%09src/platform/lm3s&In-Reply-To=%3C200811302230.mAUMU8EN006699%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000083.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r128 - in trunk: . inc romfs src src/modules	src/platform/lm3s</H1>
    <B>dadosutter at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r128%20-%20in%20trunk%3A%20.%20inc%20romfs%20src%20src/modules%0A%09src/platform/lm3s&In-Reply-To=%3C200811302230.mAUMU8EN006699%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r128 - in trunk: . inc romfs src src/modules	src/platform/lm3s">dadosutter at mail.berlios.de
       </A><BR>
    <I>Sun Nov 30 23:30:08 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000083.html">[Elua-svn] r127 - trunk/src
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#84">[ date ]</a>
              <a href="thread.html#84">[ thread ]</a>
              <a href="subject.html#84">[ subject ]</a>
              <a href="author.html#84">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dadosutter
Date: 2008-11-30 23:30:06 +0100 (Sun, 30 Nov 2008)
New Revision: 128

Added:
   trunk/romfs/pong.lua
   trunk/src/modules/disp.c
   trunk/src/platform/lm3s/rit128x96x4.c
   trunk/src/platform/lm3s/rit128x96x4.h
Modified:
   trunk/CHANGELOG
   trunk/SConstruct
   trunk/inc/platform.h
   trunk/src/modules/auxmods.h
   trunk/src/platform/lm3s/conf.py
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/platform_conf.h
   trunk/src/shell.c
Log:
- Added support for RIT128x96x4 OLED Display on LM3S8962 platform, on module &quot;disp&quot;
- ls shell command enhanced with column aligned file sizes and total size report
- New section on CHANGELOG for ongoing dev changes, to ease up next release
- pong.lua added to examples in romfs
- minor URL and e-mail updates, to reflect the new eluaproject.net domain
  



Modified: trunk/CHANGELOG
===================================================================
--- trunk/CHANGELOG	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/CHANGELOG	2008-11-30 22:30:06 UTC (rev 128)
@@ -1,3 +1,16 @@
+Trunk Dev  Bogdan Marinescu &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">bogdanm at eluaproject.net</A>&gt;
+           Dado Sutter      &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">dado at eluaproject.net</A>&gt;
+
+  * Added an ls (or dir) shell command
+  * Added support for STM32
+  * Examples added pong, (morse on RIT128x96x4 ?, snake ?)
+  * Documentation now in PDF format (work in progress)
+  *
+  *
+  *
+
+
+
 01.11.2008 Bogdan Marinescu &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">bogdanm at users.berlios.de</A>&gt;
            Dado Sutter &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">dadosutter at esp.puc-rio.br</A>&gt; 
 

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/SConstruct	2008-11-30 22:30:06 UTC (rev 128)
@@ -132,7 +132,7 @@
 local_include = local_include + &quot; -Isrc/uip&quot;
 
 # Lua module files
-module_names = &quot;modcommon.c pio.c spi.c tmr.c pd.c uart.c term.c pwm.c lpack.c bit.c net.c cpu.c&quot;
+module_names = &quot;disp.c modcommon.c pio.c spi.c tmr.c pd.c uart.c term.c pwm.c lpack.c bit.c net.c cpu.c&quot;
 module_files = &quot; &quot; + &quot; &quot;.join( [ &quot;src/modules/%s&quot; % name for name in module_names.split() ] )
   
 # Optimizer flags (speed or size)

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/inc/platform.h	2008-11-30 22:30:06 UTC (rev 128)
@@ -144,7 +144,34 @@
 u32 platform_timer_op( unsigned id, int op, u32 data );
 u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start );
 
+
 // *****************************************************************************
+// OLED DISP subsection
+
+
+void platform_disp_init(unsigned long freq);
+
+void platform_disp_clear(void);
+
+void platform_disp_stringDraw(const char *str, unsigned long x, unsigned long y,
+                              unsigned char level);
+                              
+void platform_disp_imageDraw(const unsigned char *img,
+                             unsigned long x, unsigned long y,
+                             unsigned long width, unsigned long height);
+                             
+void platform_disp_enable(unsigned long freq);
+
+void platform_disp_disable(void);
+
+void platform_disp_displayOn(void);
+
+void platform_disp_displayOff(void);
+
+
+ 
+
+// *****************************************************************************
 // PWM subsection
 
 // There are 16 &quot;virtual&quot; PWM channels (PWM0...PWM15)

Added: trunk/romfs/pong.lua
===================================================================
--- trunk/romfs/pong.lua	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/romfs/pong.lua	2008-11-30 22:30:06 UTC (rev 128)
@@ -0,0 +1,148 @@
+--[[ To Do
+  External Loop to play again, w/ UI msg
+  Function lm3s_init will become a separate module, require()d here
+--]]
+
+function lm3s_init()
+  btn = {}
+  btn.UP = pio.PE_0
+  btn.DOWN = pio.PE_1
+  btn.LEFT = pio.PE_2
+  btn.RIGHT = pio.PE_3
+  btn.SELECT = pio.PF_1
+  btn.LED1 = pio.PF_0
+  pio.input( btn.UP, btn.DOWN, btn.LEFT, btn.RIGHT, btn.SELECT )
+  pio.pullup( btn.UP, btn.DOWN, btn.LEFT, btn.RIGHT, btn.SELECT )
+  pio.output ( btn.LED1 )
+  btn.pressed = function( btn )
+    return ( pio.get ( btn ) == 0 )
+  end
+end
+
+function term.keypressed()
+  return( uart.recv (0, 0, 0) &gt;= 0 )
+end
+
+function drawPaddle( y, color )
+  disp.strDraw(&quot;|&quot;, 0, y,   color)
+  disp.strDraw(&quot;|&quot;, 0, y+4, color)
+  disp.strDraw(&quot;|&quot;, 0, y+8, color)
+end
+
+function updateBallPos()
+  if( bx &gt;= 121 or bx &lt;= 4) then
+    dx = -dx;
+  end
+
+  if(( by &gt;= 89 ) or ( by &lt;= 0 )) then
+    dy = -dy;
+  end
+  disp.strDraw( ball, bx, by, 0 )
+  bx, by = ( bx + dx ), ( by + dy );
+  disp.strDraw( ball, bx, by, 15 )
+end
+
+function updatePaddlePos()
+  if btn.pressed( btn.UP ) then
+    if ( py &gt; 0 ) then
+      drawPaddle( py, 0 )
+      py = py - 1
+      drawPaddle( py, 11 )
+    end
+  elseif btn.pressed( btn.DOWN ) then
+    if ( py &lt; 80 ) then
+      drawPaddle( py, 0 )
+      py = py + 1
+      drawPaddle( py, 11 )
+    end
+  else
+    tmr.delay( 0, 400 ) -- Maintain function processing time aprox the same
+  end
+end
+
+------------ MAIN ------------
+lm3s_init()
+disp.init(1000000)
+
+term.clrscr()
+--term.gotoxy( 5, 1 )
+--print( &quot;Welcome to eLua Tenis on a RIT display&quot; )
+disp.strDraw( &quot;eLua Pong&quot;, 30, 40, 11 )
+tmr.delay ( 0, 2000000 )
+
+highscore = 0
+
+while (true) do
+  play = false
+
+  bx, by = 5, 48
+  dx, dy = 1, 1
+  py = 48
+
+  score = 0
+  dscore = 1
+  ball = &quot;*&quot;
+  time = 10000
+  
+  change = 0
+  
+  disp.clear()
+  drawPaddle( py, 11 )
+
+  while ( true ) do
+    for i = 0, 1 do
+      updatePaddlePos()
+      tmr.delay ( 0, time )
+    end
+    updateBallPos()
+    if ( bx == 4 ) then
+      if (( by+8 &lt; py ) or ( by &gt; py+16 )) then
+        break
+      else
+        score = score + dscore
+      end
+    end
+    
+    if change == 0 then
+      if btn.pressed( btn.RIGHT ) and time &gt; 0 then
+        change = 1
+      elseif btn.pressed( btn.LEFT ) and dscore &gt; 1 then
+        change = -1
+      end
+    end
+    
+    if ( btn.pressed( btn.RIGHT ) ) == false and ( btn.pressed( btn.LEFT ) ) == false then
+      if change == 1 then
+        time = time - 2000
+        dscore = dscore + 1
+      elseif change == -1 then
+        time = time + 2000
+        dscore = dscore - 1
+      end      
+        change = 0
+    end
+    
+    disp.strDraw( tostring( dscore ), 118, 0, 6 )
+    
+  end
+  
+  if score &gt; highscore then
+    highscore = score
+  end
+
+  disp.clear()
+  disp.strDraw( &quot;Game Over :(&quot;, 30, 20, 11 )
+  disp.strDraw( &quot;Your score was &quot; .. tostring( score ), 15, 40, 11 )
+  disp.strDraw( &quot;High score: &quot; .. tostring( highscore ), 15, 50, 11 )
+  disp.strDraw( &quot;SELECT to restart&quot;, 6, 70, 11 )
+  for i=0, 500000 do
+    if btn.pressed( btn.SELECT ) then
+      play = true
+      break
+    end
+  end
+  if play == false then
+    disp.off()
+    break
+  end
+end

Modified: trunk/src/modules/auxmods.h
===================================================================
--- trunk/src/modules/auxmods.h	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/modules/auxmods.h	2008-11-30 22:30:06 UTC (rev 128)
@@ -42,6 +42,9 @@
 #define AUXLIB_MOD      &quot;mod&quot;
 LUALIB_API int ( luaopen_mod )( lua_State* L );
 
+#define AUXLIB_DISP     &quot;disp&quot;
+LUALIB_API int ( luaopen_disp )( lua_State* L );
+
 // Helper macros
 
 #define MOD_CHECK_ID( mod, id )\

Added: trunk/src/modules/disp.c
===================================================================
--- trunk/src/modules/disp.c	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/modules/disp.c	2008-11-30 22:30:06 UTC (rev 128)
@@ -0,0 +1,108 @@
+// Module for interfacing with Lua DISP code
+
+#include &quot;lua.h&quot;
+#include &quot;lualib.h&quot;
+#include &quot;lauxlib.h&quot;
+#include &quot;platform.h&quot;
+#include &quot;auxmods.h&quot;
+
+
+//Lua: init(frequency)
+static int disp_init(lua_State *L) {
+  unsigned long freq;
+  
+  freq = luaL_checkinteger(L, 1);
+  platform_disp_init(freq);
+  return 0;
+   
+}
+
+//Lua: enable
+static int disp_enable(lua_State *L) {
+  unsigned long freq;
+  
+  luaL_checkinteger(L, 1);
+  platform_disp_enable(freq);
+  return 0;
+}
+
+//Lua: disable   
+static int disp_disable(lua_State *L) {    
+  platform_disp_disable();
+  return 0; 
+}
+   
+//Lua: on
+static int disp_on(lua_State *L) {
+  platform_disp_displayOn();    
+  return 0; 
+}
+
+//Lua: off
+static int disp_off(lua_State *L) {    
+  platform_disp_displayOff();
+  return 0; 
+}
+   
+//Lua: clear
+static int disp_clear(lua_State *L) {    
+  platform_disp_clear();
+  return 0; 
+}
+   
+//Lua: strDraw
+static int disp_stringDraw(lua_State *L) {
+  const char *str;
+  unsigned long x; 
+  unsigned long y;
+  unsigned char lvl;
+  
+  str   = luaL_checkstring(L, 1);         
+  x     = luaL_checkinteger(L, 2);
+  y     = luaL_checkinteger(L, 3);
+  lvl   = (unsigned char) luaL_checkinteger(L, 4);    
+  platform_disp_stringDraw(str, x, y, lvl);
+  return 0; 
+}
+   
+//Lua: enable
+static int disp_imageDraw(lua_State *L) {    
+  const char *img;
+  unsigned long x;
+  unsigned long y;
+  unsigned long width;
+  unsigned long height;
+  
+  img    = luaL_checkstring(L, 1);
+  x      = luaL_checkinteger(L, 2);
+  y      = luaL_checkinteger(L, 3);
+  width  = luaL_checkinteger(L, 4);
+  height = luaL_checkinteger(L, 5);
+  platform_disp_imageDraw(img, x, y, width, height);
+  return 0; 
+}
+   
+   
+
+   
+// Module function map
+static const luaL_reg disp_map[] =
+{
+  { &quot;init&quot;,  disp_init },
+  { &quot;enable&quot;,  disp_enable },
+  { &quot;disable&quot;, disp_disable },
+  { &quot;on&quot;, disp_on },    
+  { &quot;off&quot;, disp_off },
+  { &quot;clear&quot;, disp_clear },
+  { &quot;stringdraw&quot;, disp_stringDraw },
+  { &quot;imgagedraw&quot;, disp_imageDraw },  
+  { NULL, NULL }
+};
+
+LUALIB_API int luaopen_disp( lua_State *L )
+{
+  luaL_register( L, AUXLIB_DISP, disp_map );
+  return 1;
+}  
+
+

Modified: trunk/src/platform/lm3s/conf.py
===================================================================
--- trunk/src/platform/lm3s/conf.py	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/platform/lm3s/conf.py	2008-11-30 22:30:06 UTC (rev 128)
@@ -1,6 +1,6 @@
 # Configuration file for the LM3S microcontroller
 
-specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c flash.c interrupt.c cpu.s&quot;
+specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c flash.c interrupt.c cpu.s rit128x96x4.c&quot;
 ldscript = &quot;lm3s.ld&quot;
   
 # Prepend with path

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/platform/lm3s/platform.c	2008-11-30 22:30:06 UTC (rev 128)
@@ -35,6 +35,7 @@
 #include &quot;interrupt.h&quot;
 #include &quot;elua_net.h&quot;
 #include &quot;dhcpc.h&quot;
+#include &quot;rit128x96x4.h&quot;
 
 // UIP sys tick data
 #define SYSTICKHZ               4
@@ -565,6 +566,52 @@
 }
 
 // ****************************************************************************
+// OLED Display specific functions
+// 
+// Initially immplementing the funcionalities offered by the RIT128x96x4
+// OLED display driver.
+
+void platform_disp_init(unsigned long freq) {
+  RIT128x96x4Init(freq);
+}
+    
+void platform_disp_clear(void) {  
+  RIT128x96x4Clear();
+}
+
+void platform_disp_stringDraw(const char *str, unsigned long x, unsigned long y,
+                              unsigned char level) {
+  RIT128x96x4StringDraw(str, x, y, level);
+}
+
+void platform_disp_imageDraw(const unsigned char *img, 
+                            unsigned long x, unsigned long y, 
+                            unsigned long width, unsigned long height) {
+  RIT128x96x4ImageDraw(img, x, y, width, height);
+}
+
+
+void platform_disp_enable(unsigned long freq) {
+  RIT128x96x4Enable(freq);
+}
+
+void platform_disp_disable(void) {
+  RIT128x96x4Disable();
+}
+
+void platform_disp_displayOn(void) {
+  RIT128x96x4DisplayOn();
+}
+
+void platform_disp_displayOff(void) {
+  RIT128x96x4DisplayOff();
+}
+
+
+
+
+
+// ****************************************************************************
 // Ethernet functions
 
 static void eth_init()

Modified: trunk/src/platform/lm3s/platform_conf.h
===================================================================
--- trunk/src/platform/lm3s/platform_conf.h	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/platform/lm3s/platform_conf.h	2008-11-30 22:30:06 UTC (rev 128)
@@ -13,7 +13,7 @@
 #define BUILD_ROMFS
 #define BUILD_TERM
 #define BUILD_UIP
-#define BUILD_DHCPC
+//#define BUILD_DHCPC
 #define BUILD_DNS
 #define BUILD_CON_GENERIC
 //#define BUILD_CON_TCP
@@ -44,6 +44,7 @@
   { AUXLIB_BIT, luaopen_bit },\
   { AUXLIB_NET, luaopen_net },\
   { AUXLIB_CPU, luaopen_cpu },\
+  { AUXLIB_DISP, luaopen_disp },\
   { LUA_MATHLIBNAME, luaopen_math }
   
 // *****************************************************************************

Added: trunk/src/platform/lm3s/rit128x96x4.c
===================================================================
--- trunk/src/platform/lm3s/rit128x96x4.c	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/platform/lm3s/rit128x96x4.c	2008-11-30 22:30:06 UTC (rev 128)
@@ -0,0 +1,925 @@
+//*****************************************************************************
+//
+// rit128x96x4.c - Driver for the RIT 128x96x4 graphical OLED display.
+//
+// Copyright (c) 2007-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2692 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup ek_lm3s8962_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_ssi.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_sysctl.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;gpio.h&quot;
+#include &quot;ssi.h&quot;
+#include &quot;sysctl.h&quot;
+#include &quot;rit128x96x4.h&quot;
+
+//*****************************************************************************
+//
+// Macros that define the peripheral, port, and pin used for the OLEDDC
+// panel control signal.
+//
+//*****************************************************************************
+#define SYSCTL_PERIPH_GPIO_OLEDDC   SYSCTL_PERIPH_GPIOA
+#define GPIO_OLEDDC_BASE            GPIO_PORTA_BASE
+#define GPIO_OLEDDC_PIN             GPIO_PIN_6
+#define GPIO_OLEDEN_PIN             GPIO_PIN_7
+
+//*****************************************************************************
+//
+// Flag to indicate if SSI port is enabled for display usage.
+//
+//*****************************************************************************
+static volatile tBoolean g_bSSIEnabled = false;
+
+//*****************************************************************************
+//
+// Buffer for storing sequences of command and data for the display.
+//
+//*****************************************************************************
+static unsigned char g_pucBuffer[8];
+
+//*****************************************************************************
+//
+// Define the SSD1329 128x96x4 Remap Setting(s).  This will be used in
+// several places in the code to switch between vertical and horizontal
+// address incrementing.  Note that the controller support 128 rows while
+// the RIT display only uses 96.
+//
+// The Remap Command (0xA0) takes one 8-bit parameter.  The parameter is
+// defined as follows.
+//
+// Bit 7: Reserved
+// Bit 6: Disable(0)/Enable(1) COM Split Odd Even
+//        When enabled, the COM signals are split Odd on one side, even on
+//        the other.  Otherwise, they are split 0-63 on one side, 64-127 on
+//        the other.
+// Bit 5: Reserved
+// Bit 4: Disable(0)/Enable(1) COM Remap
+//        When Enabled, ROW 0-127 map to COM 127-0 (that is, reverse row order)
+// Bit 3: Reserved
+// Bit 2: Horizontal(0)/Vertical(1) Address Increment
+//        When set, data RAM address will increment along the column rather
+//        than along the row.
+// Bit 1: Disable(0)/Enable(1) Nibble Remap
+//        When enabled, the upper and lower nibbles in the DATA bus for access
+//        to the data RAM are swapped.
+// Bit 0: Disable(0)/Enable(1) Column Address Remap
+//        When enabled, DATA RAM columns 0-63 are remapped to Segment Columns
+//        127-0.
+//
+//*****************************************************************************
+#define RIT_INIT_REMAP      0x52 // app note says 0x51
+#define RIT_INIT_OFFSET     0x00
+static const unsigned char g_pucRIT128x96x4VerticalInc[]   = { 0xA0, 0x56 };
+static const unsigned char g_pucRIT128x96x4HorizontalInc[] = { 0xA0, 0x52 };
+
+//*****************************************************************************
+//
+// A 5x7 font (in a 6x8 cell, where the sixth column is omitted from this
+// table) for displaying text on the OLED display.  The data is organized as
+// bytes from the left column to the right column, with each byte containing
+// the top row in the LSB and the bottom row in the MSB.
+//
+// Note:  This is the same font data that is used in the EK-LM3S811
+// osram96x16x1 driver.  The single bit-per-pixel is expaned in the StringDraw
+// function to the appropriate four bit-per-pixel gray scale format.
+//
+//*****************************************************************************
+static const unsigned char g_pucFont[96][5] =
+{
+    { 0x00, 0x00, 0x00, 0x00, 0x00 }, // &quot; &quot;
+    { 0x00, 0x00, 0x4f, 0x00, 0x00 }, // !
+    { 0x00, 0x07, 0x00, 0x07, 0x00 }, // &quot;
+    { 0x14, 0x7f, 0x14, 0x7f, 0x14 }, // #
+    { 0x24, 0x2a, 0x7f, 0x2a, 0x12 }, // $
+    { 0x23, 0x13, 0x08, 0x64, 0x62 }, // %
+    { 0x36, 0x49, 0x55, 0x22, 0x50 }, // &amp;
+    { 0x00, 0x05, 0x03, 0x00, 0x00 }, // '
+    { 0x00, 0x1c, 0x22, 0x41, 0x00 }, // (
+    { 0x00, 0x41, 0x22, 0x1c, 0x00 }, // )
+    { 0x14, 0x08, 0x3e, 0x08, 0x14 }, // *
+    { 0x08, 0x08, 0x3e, 0x08, 0x08 }, // +
+    { 0x00, 0x50, 0x30, 0x00, 0x00 }, // ,
+    { 0x08, 0x08, 0x08, 0x08, 0x08 }, // -
+    { 0x00, 0x60, 0x60, 0x00, 0x00 }, // .
+    { 0x20, 0x10, 0x08, 0x04, 0x02 }, // /
+    { 0x3e, 0x51, 0x49, 0x45, 0x3e }, // 0
+    { 0x00, 0x42, 0x7f, 0x40, 0x00 }, // 1
+    { 0x42, 0x61, 0x51, 0x49, 0x46 }, // 2
+    { 0x21, 0x41, 0x45, 0x4b, 0x31 }, // 3
+    { 0x18, 0x14, 0x12, 0x7f, 0x10 }, // 4
+    { 0x27, 0x45, 0x45, 0x45, 0x39 }, // 5
+    { 0x3c, 0x4a, 0x49, 0x49, 0x30 }, // 6
+    { 0x01, 0x71, 0x09, 0x05, 0x03 }, // 7
+    { 0x36, 0x49, 0x49, 0x49, 0x36 }, // 8
+    { 0x06, 0x49, 0x49, 0x29, 0x1e }, // 9
+    { 0x00, 0x36, 0x36, 0x00, 0x00 }, // :
+    { 0x00, 0x56, 0x36, 0x00, 0x00 }, // ;
+    { 0x08, 0x14, 0x22, 0x41, 0x00 }, // &lt;
+    { 0x14, 0x14, 0x14, 0x14, 0x14 }, // =
+    { 0x00, 0x41, 0x22, 0x14, 0x08 }, // &gt;
+    { 0x02, 0x01, 0x51, 0x09, 0x06 }, // ?
+    { 0x32, 0x49, 0x79, 0x41, 0x3e }, // @
+    { 0x7e, 0x11, 0x11, 0x11, 0x7e }, // A
+    { 0x7f, 0x49, 0x49, 0x49, 0x36 }, // B
+    { 0x3e, 0x41, 0x41, 0x41, 0x22 }, // C
+    { 0x7f, 0x41, 0x41, 0x22, 0x1c }, // D
+    { 0x7f, 0x49, 0x49, 0x49, 0x41 }, // E
+    { 0x7f, 0x09, 0x09, 0x09, 0x01 }, // F
+    { 0x3e, 0x41, 0x49, 0x49, 0x7a }, // G
+    { 0x7f, 0x08, 0x08, 0x08, 0x7f }, // H
+    { 0x00, 0x41, 0x7f, 0x41, 0x00 }, // I
+    { 0x20, 0x40, 0x41, 0x3f, 0x01 }, // J
+    { 0x7f, 0x08, 0x14, 0x22, 0x41 }, // K
+    { 0x7f, 0x40, 0x40, 0x40, 0x40 }, // L
+    { 0x7f, 0x02, 0x0c, 0x02, 0x7f }, // M
+    { 0x7f, 0x04, 0x08, 0x10, 0x7f }, // N
+    { 0x3e, 0x41, 0x41, 0x41, 0x3e }, // O
+    { 0x7f, 0x09, 0x09, 0x09, 0x06 }, // P
+    { 0x3e, 0x41, 0x51, 0x21, 0x5e }, // Q
+    { 0x7f, 0x09, 0x19, 0x29, 0x46 }, // R
+    { 0x46, 0x49, 0x49, 0x49, 0x31 }, // S
+    { 0x01, 0x01, 0x7f, 0x01, 0x01 }, // T
+    { 0x3f, 0x40, 0x40, 0x40, 0x3f }, // U
+    { 0x1f, 0x20, 0x40, 0x20, 0x1f }, // V
+    { 0x3f, 0x40, 0x38, 0x40, 0x3f }, // W
+    { 0x63, 0x14, 0x08, 0x14, 0x63 }, // X
+    { 0x07, 0x08, 0x70, 0x08, 0x07 }, // Y
+    { 0x61, 0x51, 0x49, 0x45, 0x43 }, // Z
+    { 0x00, 0x7f, 0x41, 0x41, 0x00 }, // [
+    { 0x02, 0x04, 0x08, 0x10, 0x20 }, // &quot;\&quot;
+    { 0x00, 0x41, 0x41, 0x7f, 0x00 }, // ]
+    { 0x04, 0x02, 0x01, 0x02, 0x04 }, // ^
+    { 0x40, 0x40, 0x40, 0x40, 0x40 }, // _
+    { 0x00, 0x01, 0x02, 0x04, 0x00 }, // `
+    { 0x20, 0x54, 0x54, 0x54, 0x78 }, // a
+    { 0x7f, 0x48, 0x44, 0x44, 0x38 }, // b
+    { 0x38, 0x44, 0x44, 0x44, 0x20 }, // c
+    { 0x38, 0x44, 0x44, 0x48, 0x7f }, // d
+    { 0x38, 0x54, 0x54, 0x54, 0x18 }, // e
+    { 0x08, 0x7e, 0x09, 0x01, 0x02 }, // f
+    { 0x0c, 0x52, 0x52, 0x52, 0x3e }, // g
+    { 0x7f, 0x08, 0x04, 0x04, 0x78 }, // h
+    { 0x00, 0x44, 0x7d, 0x40, 0x00 }, // i
+    { 0x20, 0x40, 0x44, 0x3d, 0x00 }, // j
+    { 0x7f, 0x10, 0x28, 0x44, 0x00 }, // k
+    { 0x00, 0x41, 0x7f, 0x40, 0x00 }, // l
+    { 0x7c, 0x04, 0x18, 0x04, 0x78 }, // m
+    { 0x7c, 0x08, 0x04, 0x04, 0x78 }, // n
+    { 0x38, 0x44, 0x44, 0x44, 0x38 }, // o
+    { 0x7c, 0x14, 0x14, 0x14, 0x08 }, // p
+    { 0x08, 0x14, 0x14, 0x18, 0x7c }, // q
+    { 0x7c, 0x08, 0x04, 0x04, 0x08 }, // r
+    { 0x48, 0x54, 0x54, 0x54, 0x20 }, // s
+    { 0x04, 0x3f, 0x44, 0x40, 0x20 }, // t
+    { 0x3c, 0x40, 0x40, 0x20, 0x7c }, // u
+    { 0x1c, 0x20, 0x40, 0x20, 0x1c }, // v
+    { 0x3c, 0x40, 0x30, 0x40, 0x3c }, // w
+    { 0x44, 0x28, 0x10, 0x28, 0x44 }, // x
+    { 0x0c, 0x50, 0x50, 0x50, 0x3c }, // y
+    { 0x44, 0x64, 0x54, 0x4c, 0x44 }, // z
+    { 0x00, 0x08, 0x36, 0x41, 0x00 }, // {
+    { 0x00, 0x00, 0x7f, 0x00, 0x00 }, // |
+    { 0x00, 0x41, 0x36, 0x08, 0x00 }, // }
+    { 0x02, 0x01, 0x02, 0x04, 0x02 }, // ~
+    { 0x00, 0x00, 0x00, 0x00, 0x00 }
+};
+
+//*****************************************************************************
+//
+// The sequence of commands used to initialize the SSD1329 controller.  Each
+// command is described as follows:  there is a byte specifying the number of
+// bytes in the command sequence, followed by that many bytes of command data.
+// Note:  This initialization sequence is derived from RIT App Note for
+// the P14201.  Values used are from the RIT app note, except where noted.
+//
+//*****************************************************************************
+static const unsigned char g_pucRIT128x96x4Init[] =
+{
+    //
+    // Unlock commands
+    //
+    3, 0xFD, 0x12, 0xe3,
+
+    //
+    // Display off
+    //
+    2, 0xAE, 0xe3,
+
+    //
+    // Icon off
+    //
+    3, 0x94, 0, 0xe3,
+
+    //
+    // Multiplex ratio
+    //
+    3, 0xA8, 95, 0xe3,
+
+    //
+    // Contrast
+    //
+    3, 0x81, 0xb7, 0xe3,
+
+    //
+    // Pre-charge current
+    //
+    3, 0x82, 0x3f, 0xe3,
+
+    //
+    // Display Re-map
+    //
+    3, 0xA0, RIT_INIT_REMAP, 0xe3,
+
+    //
+    // Display Start Line
+    //
+    3, 0xA1, 0, 0xe3,
+
+    //
+    // Display Offset
+    //
+    3, 0xA2, RIT_INIT_OFFSET, 0xe3,
+
+    //
+    // Display Mode Normal
+    //
+    2, 0xA4, 0xe3,
+
+    //
+    // Phase Length
+    //
+    3, 0xB1, 0x11, 0xe3,
+
+    //
+    // Frame frequency
+    //
+    3, 0xB2, 0x23, 0xe3,
+
+    //
+    // Front Clock Divider
+    //
+    3, 0xB3, 0xe2, 0xe3,
+
+    //
+    // Set gray scale table.  App note uses default command:
+    // 2, 0xB7, 0xe3
+    // This gray scale attempts some gamma correction to reduce the
+    // the brightness of the low levels.
+    //
+    17, 0xB8, 1, 2, 3, 4, 5, 6, 8, 10, 12, 14, 16, 19, 22, 26, 30, 0xe3,
+
+    //
+    // Second pre-charge period. App note uses value 0x04.
+    //
+    3, 0xBB, 0x01, 0xe3,
+
+    //
+    // Pre-charge voltage
+    //
+    3, 0xBC, 0x3f, 0xe3,
+
+    //
+    // Display ON
+    //
+    2, 0xAF, 0xe3,
+};
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Write a sequence of command bytes to the SSD1329 controller.
+//!
+//! The data is written in a polled fashion; this function will not return
+//! until the entire byte sequence has been written to the controller.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+RITWriteCommand(const unsigned char *pucBuffer, unsigned long ulCount)
+{
+    unsigned long ulTemp;
+
+    //
+    // Return if SSI port is not enabled for RIT display.
+    //
+    if(!g_bSSIEnabled)
+    {
+        return;
+    }
+
+    //
+    // Clear the command/control bit to enable command mode.
+    //
+    GPIOPinWrite(GPIO_OLEDDC_BASE, GPIO_OLEDDC_PIN, 0);
+
+    //
+    // Loop while there are more bytes left to be transferred.
+    //
+    while(ulCount != 0)
+    {
+        //
+        // Write the next byte to the controller.
+        //
+        SSIDataPut(SSI0_BASE, *pucBuffer++);
+
+        //
+        // Dummy read to drain the fifo and time the GPIO signal.
+        //
+        SSIDataGet(SSI0_BASE, &amp;ulTemp);
+
+        //
+        // Decrement the BYTE counter.
+        //
+        ulCount--;
+    }
+}
+
+//*****************************************************************************
+//
+//! \internal
+//!
+//! Write a sequence of data bytes to the SSD1329 controller.
+//!
+//! The data is written in a polled fashion; this function will not return
+//! until the entire byte sequence has been written to the controller.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+RITWriteData(const unsigned char *pucBuffer, unsigned long ulCount)
+{
+    unsigned long ulTemp;
+
+    //
+    // Return if SSI port is not enabled for RIT display.
+    //
+    if(!g_bSSIEnabled)
+    {
+        return;
+    }
+
+    //
+    // Set the command/control bit to enable data mode.
+    //
+    GPIOPinWrite(GPIO_OLEDDC_BASE, GPIO_OLEDDC_PIN, GPIO_OLEDDC_PIN);
+
+    //
+    // Loop while there are more bytes left to be transferred.
+    //
+    while(ulCount != 0)
+    {
+        //
+        // Write the next byte to the controller.
+        //
+        SSIDataPut(SSI0_BASE, *pucBuffer++);
+
+        //
+        // Dummy read to drain the fifo and time the GPIO signal.
+        //
+        SSIDataGet(SSI0_BASE, &amp;ulTemp);
+
+        //
+        // Decrement the BYTE counter.
+        //
+        ulCount--;
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears the OLED display.
+//!
+//! This function will clear the display RAM.  All pixels in the display will
+//! be turned off.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4Clear(void)
+{
+    static const unsigned char pucCommand1[] = { 0x15, 0, 63 };
+    static const unsigned char pucCommand2[] = { 0x75, 0, 127 };
+    unsigned long ulRow, ulColumn;
+
+    //
+    // Clear out the buffer used for sending bytes to the display.
+    //
+    *(unsigned long *)&amp;g_pucBuffer[0] = 0;
+    *(unsigned long *)&amp;g_pucBuffer[4] = 0;
+
+    //
+    // Set the window to fill the entire display.
+    //
+    RITWriteCommand(pucCommand1, sizeof(pucCommand1));
+    RITWriteCommand(pucCommand2, sizeof(pucCommand2));
+    RITWriteCommand(g_pucRIT128x96x4HorizontalInc,
+                    sizeof(g_pucRIT128x96x4HorizontalInc));
+
+    //
+    // Loop through the rows
+    //
+    for(ulRow = 0; ulRow &lt; 96; ulRow++)
+    {
+        //
+        // Loop through the columns.  Each byte is two pixels,
+        // and the buffer hold 8 bytes, so 16 pixels are cleared
+        // at a time.
+        //
+        for(ulColumn = 0; ulColumn &lt; 128; ulColumn += 8 * 2)
+        {
+            //
+            // Write 8 clearing bytes to the display, which will
+            // clear 16 pixels across.
+            //
+            RITWriteData(g_pucBuffer, sizeof(g_pucBuffer));
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Displays a string on the OLED display.
+//!
+//! \param pcStr is a pointer to the string to display.
+//! \param ulX is the horizontal position to display the string, specified in
+//! columns from the left edge of the display.
+//! \param ulY is the vertical position to display the string, specified in
+//! rows from the top edge of the display.
+//! \param ucLevel is the 4-bit gray scale value to be used for displayed text.
+//!
+//! This function will draw a string on the display.  Only the ASCII characters
+//! between 32 (space) and 126 (tilde) are supported; other characters will
+//! result in random data being draw on the display (based on whatever appears
+//! before/after the font in memory).  The font is mono-spaced, so characters
+//! such as ``i'' and ``l'' have more white space around them than characters
+//! such as ``m'' or ``w''.
+//!
+//! If the drawing of the string reaches the right edge of the display, no more
+//! characters will be drawn.  Therefore, special care is not required to avoid
+//! supplying a string that is ``too long'' to display.
+//!
+//! \note Because the OLED display packs 2 pixels of data in a single byte, the
+//! parameter \e ulX must be an even column number (for example, 0, 2, 4, and
+//! so on).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4StringDraw(const char *pcStr, unsigned long ulX,
+                      unsigned long ulY, unsigned char ucLevel)
+{
+    unsigned long ulIdx1, ulIdx2;
+    unsigned char ucTemp;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulX &lt; 128);
+    ASSERT((ulX &amp; 1) == 0);
+    ASSERT(ulY &lt; 96);
+    ASSERT(ucLevel &lt; 16);
+
+    //
+    // Setup a window starting at the specified column and row, ending
+    // at the right edge of the display and 8 rows down (single character row).
+    //
+    g_pucBuffer[0] = 0x15;
+    g_pucBuffer[1] = ulX / 2;
+    g_pucBuffer[2] = 63;
+    RITWriteCommand(g_pucBuffer, 3);
+    g_pucBuffer[0] = 0x75;
+    g_pucBuffer[1] = ulY;
+    g_pucBuffer[2] = ulY + 7;
+    RITWriteCommand(g_pucBuffer, 3);
+    RITWriteCommand(g_pucRIT128x96x4VerticalInc,
+                    sizeof(g_pucRIT128x96x4VerticalInc));
+
+    //
+    // Loop while there are more characters in the string.
+    //
+    while(*pcStr != 0)
+    {
+        //
+        // Get a working copy of the current character and convert to an
+        // index into the character bit-map array.
+        //
+        ucTemp = *pcStr;
+        ucTemp &amp;= 0x7F;
+        if(ucTemp &lt; ' ')
+        {
+            ucTemp = ' ';
+        }
+        else
+        {
+            ucTemp -= ' ';
+        }
+
+        //
+        // Build and display the character buffer.
+        //
+        for(ulIdx1 = 0; ulIdx1 &lt; 6; ulIdx1 += 2)
+        {
+            //
+            // Convert two columns of 1-bit font data into a single data
+            // byte column of 4-bit font data.
+            //
+            for(ulIdx2 = 0; ulIdx2 &lt; 8; ulIdx2++)
+            {
+                g_pucBuffer[ulIdx2] = 0;
+                if(g_pucFont[ucTemp][ulIdx1] &amp; (1 &lt;&lt; ulIdx2))
+                {
+                    g_pucBuffer[ulIdx2] = (ucLevel &lt;&lt; 4) &amp; 0xf0;
+                }
+                if((ulIdx1 &lt; 4) &amp;&amp;
+                   (g_pucFont[ucTemp][ulIdx1 + 1] &amp; (1 &lt;&lt; ulIdx2)))
+                {
+                    g_pucBuffer[ulIdx2] |= (ucLevel &lt;&lt; 0) &amp; 0x0f;
+                }
+            }
+
+            //
+            // Send this byte column to the display.
+            //
+            RITWriteData(g_pucBuffer, 8);
+            ulX += 2;
+
+            //
+            // Return if the right side of the display has been reached.
+            //
+            if(ulX == 128)
+            {
+                return;
+            }
+        }
+
+        //
+        // Advance to the next character.
+        //
+        pcStr++;
+    }
+}
+
+//*****************************************************************************
+//
+//! Displays an image on the OLED display.
+//!
+//! \param pucImage is a pointer to the image data.
+//! \param ulX is the horizontal position to display this image, specified in
+//! columns from the left edge of the display.
+//! \param ulY is the vertical position to display this image, specified in
+//! rows from the top of the display.
+//! \param ulWidth is the width of the image, specified in columns.
+//! \param ulHeight is the height of the image, specified in rows.
+//!
+//! This function will display a bitmap graphic on the display.  Because of the
+//! format of the display RAM, the starting column (\e ulX) and the number of
+//! columns (\e ulWidth) must be an integer multiple of two.
+//!
+//! The image data is organized with the first row of image data appearing left
+//! to right, followed immediately by the second row of image data.  Each byte
+//! contains the data for two columns in the current row, with the leftmost
+//! column being contained in bits 7:4 and the rightmost column being contained
+//! in bits 3:0.
+//!
+//! For example, an image six columns wide and seven scan lines tall would
+//! be arranged as follows (showing how the twenty one bytes of the image would
+//! appear on the display):
+//!
+//! \verbatim
+//!     +-------------------+-------------------+-------------------+
+//!     |      Byte 0       |      Byte 1       |      Byte 2       |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     |      Byte 3       |      Byte 4       |      Byte 5       |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     |      Byte 6       |      Byte 7       |      Byte 8       |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     |      Byte 9       |      Byte 10      |      Byte 11      |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     |      Byte 12      |      Byte 13      |      Byte 14      |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     |      Byte 15      |      Byte 16      |      Byte 17      |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     |      Byte 18      |      Byte 19      |      Byte 20      |
+//!     +---------+---------+---------+---------+---------+---------+
+//!     | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
+//!     +---------+---------+---------+---------+---------+---------+
+//! \endverbatim
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4ImageDraw(const unsigned char *pucImage, unsigned long ulX,
+                     unsigned long ulY, unsigned long ulWidth,
+                     unsigned long ulHeight)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulX &lt; 128);
+    ASSERT((ulX &amp; 1) == 0);
+    ASSERT(ulY &lt; 96);
+    ASSERT((ulX + ulWidth) &lt;= 128);
+    ASSERT((ulY + ulHeight) &lt;= 96);
+    ASSERT((ulWidth &amp; 1) == 0);
+
+    //
+    // Setup a window starting at the specified column and row, and ending
+    // at the column + width and row+height.
+    //
+    g_pucBuffer[0] = 0x15;
+    g_pucBuffer[1] = ulX / 2;
+    g_pucBuffer[2] = (ulX + ulWidth - 2) / 2;
+    RITWriteCommand(g_pucBuffer, 3);
+    g_pucBuffer[0] = 0x75;
+    g_pucBuffer[1] = ulY;
+    g_pucBuffer[2] = ulY + ulHeight - 1;
+    RITWriteCommand(g_pucBuffer, 3);
+    RITWriteCommand(g_pucRIT128x96x4HorizontalInc,
+                    sizeof(g_pucRIT128x96x4HorizontalInc));
+
+    //
+    // Loop while there are more rows to display.
+    //
+    while(ulHeight--)
+    {
+        //
+        // Write this row of image data.
+        //
+        RITWriteData(pucImage, (ulWidth / 2));
+
+        //
+        // Advance to the next row of the image.
+        //
+        pucImage += (ulWidth / 2);
+    }
+}
+
+//*****************************************************************************
+//
+//! Enable the SSI component of the OLED display driver.
+//!
+//! \param ulFrequency specifies the SSI Clock Frequency to be used.
+//!
+//! This function initializes the SSI interface to the OLED display.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4Enable(unsigned long ulFrequency)
+{
+    unsigned long ulTemp;
+
+    //
+    // Disable the SSI port.
+    //
+    SSIDisable(SSI0_BASE);
+
+    //
+    // Configure the SSI0 port for master mode.
+    //
+    SSIConfigSetExpClk(SSI0_BASE, SysCtlClockGet(), SSI_FRF_MOTO_MODE_2,
+                       SSI_MODE_MASTER, ulFrequency, 8);
+
+    //
+    // (Re)Enable SSI control of the FSS pin.
+    //
+    GPIOPinTypeSSI(GPIO_PORTA_BASE, GPIO_PIN_3);
+    GPIOPadConfigSet(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_STRENGTH_8MA,
+                     GPIO_PIN_TYPE_STD_WPU);
+
+    //
+    // Enable the SSI port.
+    //
+    SSIEnable(SSI0_BASE);
+
+    //
+    // Drain the receive fifo.
+    //
+    while(SSIDataGetNonBlocking(SSI0_BASE, &amp;ulTemp) != 0)
+    {
+    }
+
+    //
+    // Indicate that the RIT driver can use the SSI Port.
+    //
+    g_bSSIEnabled = true;
+}
+
+//*****************************************************************************
+//
+//! Enable the SSI component of the OLED display driver.
+//!
+//! This function initializes the SSI interface to the OLED display.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4Disable(void)
+{
+    unsigned long ulTemp;
+
+    //
+    // Indicate that the RIT driver can no longer use the SSI Port.
+    //
+    g_bSSIEnabled = false;
+
+    //
+    // Drain the receive fifo.
+    //
+    while(SSIDataGetNonBlocking(SSI0_BASE, &amp;ulTemp) != 0)
+    {
+    }
+
+    //
+    // Disable the SSI port.
+    //
+    SSIDisable(SSI0_BASE);
+
+    //
+    // Disable SSI control of the FSS pin.
+    //
+    GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, GPIO_PIN_3);
+    GPIOPadConfigSet(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_STRENGTH_8MA,
+                     GPIO_PIN_TYPE_STD_WPU);
+    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_PIN_3);
+}
+
+//*****************************************************************************
+//
+//! Initialize the OLED display.
+//!
+//! \param ulFrequency specifies the SSI Clock Frequency to be used.
+//!
+//! This function initializes the SSI interface to the OLED display and
+//! configures the SSD1329 controller on the panel.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4Init(unsigned long ulFrequency)
+{
+    unsigned long ulIdx;
+
+    //
+    // Enable the SSI0 and GPIO port blocks as they are needed by this driver.
+    //
+    SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI0);
+    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
+    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIO_OLEDDC);
+
+    //
+    // Configure the SSI0CLK and SSIOTX pins for SSI operation.
+    //
+    GPIOPinTypeSSI(GPIO_PORTA_BASE, GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_5);
+    GPIOPadConfigSet(GPIO_PORTA_BASE, GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_5,
+                     GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD_WPU);
+
+    //
+    // Configure the GPIO port pin used as a D/Cn signal for OLED device,
+    // and the port pin used to enable power to the OLED panel.
+    //
+    GPIOPinTypeGPIOOutput(GPIO_OLEDDC_BASE, GPIO_OLEDDC_PIN | GPIO_OLEDEN_PIN);
+    GPIOPadConfigSet(GPIO_OLEDDC_BASE, GPIO_OLEDDC_PIN | GPIO_OLEDEN_PIN,
+                     GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD);
+    GPIOPinWrite(GPIO_OLEDDC_BASE, GPIO_OLEDDC_PIN | GPIO_OLEDEN_PIN,
+                 GPIO_OLEDDC_PIN | GPIO_OLEDEN_PIN);
+
+    //
+    // Configure and enable the SSI0 port for master mode.
+    //
+    RIT128x96x4Enable(ulFrequency);
+
+    //
+    // Clear the frame buffer.
+    //
+    RIT128x96x4Clear();
+
+    //
+    // Initialize the SSD1329 controller.  Loop through the initialization
+    // sequence array, sending each command &quot;string&quot; to the controller.
+    //
+    for(ulIdx = 0; ulIdx &lt; sizeof(g_pucRIT128x96x4Init);
+        ulIdx += g_pucRIT128x96x4Init[ulIdx] + 1)
+    {
+        //
+        // Send this command.
+        //
+        RITWriteCommand(g_pucRIT128x96x4Init + ulIdx + 1,
+                        g_pucRIT128x96x4Init[ulIdx] - 1);
+    }
+}
+
+//*****************************************************************************
+//
+//! Turns on the OLED display.
+//!
+//! This function will turn on the OLED display, causing it to display the
+//! contents of its internal frame buffer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4DisplayOn(void)
+{
+    unsigned long ulIdx;
+
+    //
+    // Initialize the SSD1329 controller.  Loop through the initialization
+    // sequence array, sending each command &quot;string&quot; to the controller.
+    //
+    for(ulIdx = 0; ulIdx &lt; sizeof(g_pucRIT128x96x4Init);
+        ulIdx += g_pucRIT128x96x4Init[ulIdx] + 1)
+    {
+        //
+        // Send this command.
+        //
+        RITWriteCommand(g_pucRIT128x96x4Init + ulIdx + 1,
+                        g_pucRIT128x96x4Init[ulIdx] - 1);
+    }
+}
+
+//*****************************************************************************
+//
+//! Turns off the OLED display.
+//!
+//! This function will turn off the OLED display.  This will stop the scanning
+//! of the panel and turn off the on-chip DC-DC converter, preventing damage to
+//! the panel due to burn-in (it has similar characters to a CRT in this
+//! respect).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+RIT128x96x4DisplayOff(void)
+{
+    static const unsigned char pucCommand1[] =
+    {
+        0xAE, 0xe3
+    };
+
+    //
+    // Put the display to sleep.
+    //
+    RITWriteCommand(pucCommand1, sizeof(pucCommand1));
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************

Added: trunk/src/platform/lm3s/rit128x96x4.h
===================================================================
--- trunk/src/platform/lm3s/rit128x96x4.h	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/platform/lm3s/rit128x96x4.h	2008-11-30 22:30:06 UTC (rev 128)
@@ -0,0 +1,54 @@
+//*****************************************************************************
+//
+// rit128x96x4.h - Prototypes for the driver for the RITEK 128x96x4 graphical
+//                   OLED display.
+//
+// Copyright (c) 2007-2008 Luminary Micro, Inc.  All rights reserved.
+// 
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 2692 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __RIT128X96X4_H__
+#define __RIT128X96X4_H__
+
+//*****************************************************************************
+//
+// Prototypes for the driver APIs.
+//
+//*****************************************************************************
+extern void RIT128x96x4Clear(void);
+extern void RIT128x96x4StringDraw(const char *pcStr,
+                                    unsigned long ulX,
+                                    unsigned long ulY,
+                                    unsigned char ucLevel);
+extern void RIT128x96x4ImageDraw(const unsigned char *pucImage,
+                                   unsigned long ulX,
+                                   unsigned long ulY,
+                                   unsigned long ulWidth,
+                                   unsigned long ulHeight);
+extern void RIT128x96x4Init(unsigned long ulFrequency);
+extern void RIT128x96x4Enable(unsigned long ulFrequency);
+extern void RIT128x96x4Disable(void);
+extern void RIT128x96x4DisplayOn(void);
+extern void RIT128x96x4DisplayOff(void);
+
+#endif // __RIT128X96X4_H__

Modified: trunk/src/shell.c
===================================================================
--- trunk/src/shell.c	2008-11-28 02:14:15 UTC (rev 127)
+++ trunk/src/shell.c	2008-11-30 22:30:06 UTC (rev 128)
@@ -172,12 +172,21 @@
 {
   u16 offset;
   char fname[MAX_FNAME_LENGTH + 1];
-  int size;
+  int i, size;
+  int total = 0;
   
   args = args;
   offset = 0;
-  while ( offset = romfs_get_dir_entry( offset, fname, &amp;size ) )
-    printf(&quot; %s   %d bytes \n&quot;, fname, size);
+  printf( &quot;\n/rom&quot; );
+  while ( offset = romfs_get_dir_entry( offset, fname, &amp;size ))
+  {
+    printf( &quot;\n%s&quot;, fname );
+    for( i = strlen( fname ); i &lt;= MAX_FNAME_LENGTH; i++ )
+      printf( &quot; &quot; );
+    printf( &quot;%d bytes&quot;, size );
+    total = total + size;
+  }   
+  printf( &quot;\n\nTotal = %d bytes\n\n&quot;, total );
 }
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000083.html">[Elua-svn] r127 - trunk/src
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#84">[ date ]</a>
              <a href="thread.html#84">[ thread ]</a>
              <a href="subject.html#84">[ subject ]</a>
              <a href="author.html#84">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
