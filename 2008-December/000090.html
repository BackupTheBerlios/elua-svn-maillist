<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r134 - in trunk: . inc src src/newlib src/platform	src/platform/avr32 src/platform/lm3s
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r134%20-%20in%20trunk%3A%20.%20inc%20src%20src/newlib%20src/platform%0A%09src/platform/avr32%20src/platform/lm3s&In-Reply-To=%3C200812132331.mBDNVhNs018408%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000089.html">
   <LINK REL="Next"  HREF="000091.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r134 - in trunk: . inc src src/newlib src/platform	src/platform/avr32 src/platform/lm3s</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r134%20-%20in%20trunk%3A%20.%20inc%20src%20src/newlib%20src/platform%0A%09src/platform/avr32%20src/platform/lm3s&In-Reply-To=%3C200812132331.mBDNVhNs018408%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r134 - in trunk: . inc src src/newlib src/platform	src/platform/avr32 src/platform/lm3s">bogdanm at mail.berlios.de
       </A><BR>
    <I>Sun Dec 14 00:31:43 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000089.html">[Elua-svn] r133 - trunk/romfs
</A></li>
        <LI>Next message: <A HREF="000091.html">[Elua-svn] r135 - in trunk: . inc src src/lua src/newlib	src/platform/avr32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#90">[ date ]</a>
              <a href="thread.html#90">[ thread ]</a>
              <a href="subject.html#90">[ subject ]</a>
              <a href="author.html#90">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2008-12-14 00:31:40 +0100 (Sun, 14 Dec 2008)
New Revision: 134

Added:
   trunk/src/platform/avr32/
   trunk/src/platform/avr32/at32uc3a0512.ld
   trunk/src/platform/avr32/board.h
   trunk/src/platform/avr32/compiler.h
   trunk/src/platform/avr32/conf.py
   trunk/src/platform/avr32/conf_isp.h
   trunk/src/platform/avr32/crt0.s
   trunk/src/platform/avr32/evk1100.h
   trunk/src/platform/avr32/exception.s
   trunk/src/platform/avr32/flashc.c
   trunk/src/platform/avr32/flashc.h
   trunk/src/platform/avr32/gpio.c
   trunk/src/platform/avr32/gpio.h
   trunk/src/platform/avr32/intc.c
   trunk/src/platform/avr32/intc.h
   trunk/src/platform/avr32/mrepeat.h
   trunk/src/platform/avr32/platform.c
   trunk/src/platform/avr32/platform_conf.h
   trunk/src/platform/avr32/pm.c
   trunk/src/platform/avr32/pm.h
   trunk/src/platform/avr32/pm_conf_clocks.c
   trunk/src/platform/avr32/preprocessor.h
   trunk/src/platform/avr32/stacks.h
   trunk/src/platform/avr32/stringz.h
   trunk/src/platform/avr32/tpaste.h
   trunk/src/platform/avr32/trampoline.s
   trunk/src/platform/avr32/type.h
   trunk/src/platform/avr32/usart.c
   trunk/src/platform/avr32/usart.h
Modified:
   trunk/SConstruct
   trunk/inc/platform.h
   trunk/src/newlib/genstd.c
   trunk/src/newlib/stubs.c
   trunk/src/platform/lm3s/platform.c
   trunk/src/shell.c
Log:
preliminary AVR32 port

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/SConstruct	2008-12-13 23:31:40 UTC (rev 134)
@@ -1,28 +1,30 @@
-import os, sys 
-target = ARGUMENTS.get( 'target', 'lua' ).lower() 
+import os, sys
+target = ARGUMENTS.get( 'target', 'lua' ).lower()
 cputype = ARGUMENTS.get( 'cpu', '' ).upper()
 allocator = ARGUMENTS.get( 'allocator', '' ).lower()
 boardname = ARGUMENTS.get( 'board' , '').upper()
 
 # List of platform/CPU combinations
-cpu_list = { 'at91sam7x' : [ 'AT91SAM7X256', 'AT91SAM7X512' ], 
-              'lm3s' : [ 'LM3S8962', 'LM3S6965' ], 
+cpu_list = { 'at91sam7x' : [ 'AT91SAM7X256', 'AT91SAM7X512' ],
+              'lm3s' : [ 'LM3S8962', 'LM3S6965' ],
               'str9' : [ 'STR912FW44' ],
               'i386' : [ 'I386' ],
               'lpc288x' : [ 'LPC2888' ],
               'str7' : [ 'STR711FR2' ],
-              'stm32' : [ 'STM32F103ZE' ]
+              'stm32' : [ 'STM32F103ZE' ],
+              'avr32' : [ 'AT32UC3A0512' ]
             }
 
 # List of board/CPU combinations
-board_list = { 'SAM7-EX256' : [ 'AT91SAM7X256', 'AT91SAM7X512' ],        
+board_list = { 'SAM7-EX256' : [ 'AT91SAM7X256', 'AT91SAM7X512' ],
                'EK-LM3S8962' : [ 'LM3S8962' ],
                'EK-LM3S6965' : [ 'LM3S6965' ],
                'STR9-COMSTICK' : [ 'STR912FW44' ],
                'PC' : [ 'I386' ],
                'LPC-H2888' : [ 'LPC2888' ],
                'MOD711' : [ 'STR711FR2' ],
-               'STM3210E-EVAL' : [ 'STM32F103ZE' ]
+               'STM3210E-EVAL' : [ 'STM32F103ZE' ],
+               'ATEVK1100' : [ 'AT32UC3A0512' ]
             }
 
 # Variants: board = &lt;boardname&gt;
@@ -37,7 +39,7 @@
   if not board_list.has_key( boardname ):
     print &quot;Unknown board&quot;, boardname
     sys.exit( -1 )
-  if not cputype in board_list[ boardname ]: 
+  if not cputype in board_list[ boardname ]:
     print &quot;Invalid CPU %s for board %s&quot; % ( cputype, boardname )
     sys.exit( -1 )
 elif boardname != '':
@@ -45,9 +47,9 @@
   # Find CPU
   if not board_list.has_key( boardname ):
     print &quot;Unknown board&quot;, boardname
-    sys.exit( -1 )  
+    sys.exit( -1 )
   cputype = board_list[ boardname ][ 0 ]
-else:  
+else:
   # cpu = &lt;cputype&gt;
   # Find board name
   for b, v in board_list.items():
@@ -58,8 +60,8 @@
     print &quot;CPU %s not found&quot; % cputype
     sys.exit( -1 )
 
-platform = None        
-# Look for the given CPU in the list of platforms            
+platform = None
+# Look for the given CPU in the list of platforms
 for p, v in cpu_list.items():
   if cputype in v:
     platform = p
@@ -68,7 +70,7 @@
   print &quot;Unknown CPU %s&quot; % cputype
   print &quot;List of accepted CPUs: &quot;
   for p, v in cpu_list.items():
-    print &quot; &quot;, p, &quot;--&gt;&quot;, 
+    print &quot; &quot;, p, &quot;--&gt;&quot;,
     for cpu in v:
       print cpu,
     print
@@ -96,7 +98,7 @@
   print &quot;Allocator:   &quot;, allocator
   print &quot;Target:      &quot;, target
   print &quot;*********************************&quot;
-  print    
+  print
 
 output = 'elua_' + target + '_' + cputype.lower()
 cdefs = '-DELUA_CPU=%s -DELUA_BOARD=%s -DELUA_PLATFORM=%s -D__BUFSIZ__=128' % ( cputype, boardname, platform.upper() )
@@ -109,7 +111,7 @@
    ldblib.c liolib.c lmathlib.c loslib.c ltablib.c lstrlib.c loadlib.c linit.c lua.c&quot;&quot;&quot;
 if target == 'lualong' or target == 'lua':
   lua_full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;src/lua/%s&quot; % name for name in lua_files.split() ] )
-  local_include = &quot;-Iinc -Iinc/newlib -Isrc/lua&quot;  
+  local_include = &quot;-Iinc -Iinc/newlib -Isrc/lua&quot;
   if target == 'lualong':
     cdefs = cdefs + ' -DLUA_NUMBER_INTEGRAL'
 else:
@@ -119,11 +121,11 @@
 
 # Additional libraries
 local_libs = ''
-  
+
 # Application files
 app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/dlmalloc.c &quot;
-  
-# Newlib related files  
+
+# Newlib related files
 newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c src/newlib/stdtcp.c&quot;
 
 # UIP files
@@ -134,7 +136,7 @@
 # Lua module files
 module_names = &quot;disp.c modcommon.c pio.c spi.c tmr.c pd.c uart.c term.c pwm.c lpack.c bit.c net.c cpu.c&quot;
 module_files = &quot; &quot; + &quot; &quot;.join( [ &quot;src/modules/%s&quot; % name for name in module_names.split() ] )
-  
+
 # Optimizer flags (speed or size)
 #opt = &quot;-O3&quot;
 opt = &quot;-Os -fomit-frame-pointer&quot;
@@ -147,7 +149,7 @@
 
 # Complete file list
 source_files = app_files + specific_files + newlib_files + uip_files + lua_full_files + module_files
-  
+
 # Make filesystem first
 if not GetOption( 'clean' ):
   print &quot;Building filesystem...&quot;
@@ -156,12 +158,12 @@
   print
   os.system( &quot;mv -f romfiles.h inc/&quot; )
   os.system( &quot;rm -f src/fs.o&quot; )
-  
+
 # Env for building the program
-comp = Environment( CCCOM = tools[ platform ][ 'cccom' ], 
+comp = Environment( CCCOM = tools[ platform ][ 'cccom' ],
                     ASCOM = tools[ platform ][ 'ascom' ],
                     LINKCOM = tools[ platform ][ 'linkcom' ],
-                    OBJSUFFIX = &quot;.o&quot;, 
+                    OBJSUFFIX = &quot;.o&quot;,
                     PROGSUFFIX = &quot;.elf&quot;,
                     ENV = os.environ )
 # comp.TargetSignatures( 'content' )

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/inc/platform.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -149,26 +149,15 @@
 // OLED DISP subsection
 
 
-void platform_disp_init(unsigned long freq);
-
-void platform_disp_clear(void);
-
-void platform_disp_stringDraw(const char *str, unsigned long x, unsigned long y,
-                              unsigned char level);
-                              
-void platform_disp_imageDraw(const unsigned char *img,
-                             unsigned long x, unsigned long y,
-                             unsigned long width, unsigned long height);
-                             
-void platform_disp_enable(unsigned long freq);
-
-void platform_disp_disable(void);
-
-void platform_disp_displayOn(void);
-
-void platform_disp_displayOff(void);
-
-
+void platform_disp_init( unsigned long freq );
+void platform_disp_clear( void );
+void platform_disp_stringDraw( const char *str, unsigned long x, unsigned long y, unsigned char level );
+void platform_disp_imageDraw( const unsigned char *img, unsigned long x, unsigned long y,
+                              unsigned long width, unsigned long height);                             
+void platform_disp_enable( unsigned long freq );
+void platform_disp_disable( void );
+void platform_disp_displayOn( void );
+void platform_disp_displayOff( void );
  
 
 // *****************************************************************************

Modified: trunk/src/newlib/genstd.c
===================================================================
--- trunk/src/newlib/genstd.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/newlib/genstd.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -63,7 +63,10 @@
       std_send_char_func( DM_STDOUT_NUM, c );
     ptr[ i ] = c;
     if( c == '\n' )
+    {
+      std_send_char_func( DM_STDOUT_NUM, '\r' );
       return i + 1;    
+    }
     i ++;
   }
   return len;

Modified: trunk/src/newlib/stubs.c
===================================================================
--- trunk/src/newlib/stubs.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/newlib/stubs.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -303,7 +303,11 @@
 }
 
 #include &lt;sys/time.h&gt;
+#if ELUA_PLATFORM == AVR32
+int _gettimeofday_r( struct _reent *r, struct timeval *tp, struct timezone *tzp )
+#else
 int _gettimeofday_r( struct _reent *r, struct timeval *tv, void *tz )
+#endif
 {
   r-&gt;_errno = ENOSYS;
   return -1;  

Added: trunk/src/platform/avr32/at32uc3a0512.ld
===================================================================
--- trunk/src/platform/avr32/at32uc3a0512.ld	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/at32uc3a0512.ld	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,49 @@
+MEMORY
+{
+    sram (W!RX) : ORIGIN = 0x00000000, LENGTH = 0x00010000
+    flash (RX) : ORIGIN = 0x80002000, LENGTH = 0x00080000
+}
+
+SECTIONS
+{
+    .text :
+    {
+        . = ALIGN(4);
+        _text = .;
+        KEEP(*(.start))
+        *(.text .text.*)
+        *(.rodata .rodata.*)
+        *(.gnu.linkonce.t.*)
+        *(.glue_7)
+        *(.glue_7t)
+        *(.gcc_except_table)
+        *(.gnu.linkonce.r.*)
+        *(.exception .exception.*)
+        . = ALIGN(4);
+        _etext = .;
+        PROVIDE(etext = .);
+    } &gt;flash
+
+    .data : AT (_etext)
+    {
+        . = ALIGN(4);
+        _data = .;
+        *(.ramfunc .ramfunc.* .fastrun .fastrun.*)
+        *(.data .data.*)
+        *(.gnu.linkonce.d.*)
+        . = ALIGN(4);
+        _edata = .;
+    } &gt;sram
+
+    .bss (NOLOAD) : {
+        _bss = .;
+        *(.bss .bss.*)
+        *(.gnu.linkonce.b.*)
+        *(COMMON)
+        . = ALIGN(4);
+        _ebss = .;
+    } &gt;sram
+
+    end = .;
+    _sstack = 0x00010000;
+}

Added: trunk/src/platform/avr32/board.h
===================================================================
--- trunk/src/platform/avr32/board.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/board.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,83 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Standard board header file.
+ *
+ * This file includes the appropriate board header file according to the
+ * defined board.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+#include &lt;avr32/io.h&gt;
+
+/*! \name Base Boards
+ */
+//! @{
+#define EVK1100           1   //!&lt; AT32UC3A EVK1100 board.
+#define EVK1101           2   //!&lt; AT32UC3B EVK1101 board.
+#define STK1000           3   //!&lt; AT32AP7000 STK1000 board.
+#define NGW100            4   //!&lt; AT32AP7000 NGW100 board.
+#define USER_BOARD        99  //!&lt; User-reserved board (if any).
+//! @}
+
+/*! \name Extension Boards
+ */
+//! @{
+#define EXT1102           1   //!&lt; AT32UC3B EXT1102 board.
+#define MC300             2   //!&lt; AT32UC3 MC300 board.
+#define USER_EXT_BOARD    99  //!&lt; User-reserved extension board (if any).
+//! @}
+
+#include &quot;evk1100.h&quot;
+
+#ifndef FRCOSC
+  #define FRCOSC    AVR32_PM_RCOSC_FREQUENCY  //!&lt; Default RCOsc frequency.
+#endif
+
+//#define REQ_CPU_FREQ      60000000
+//#define REQ_PBA_FREQ      15000000
+
+#define REQ_CPU_FREQ      48000000
+#define REQ_PBA_FREQ      12000000
+
+#endif  // _BOARD_H_

Added: trunk/src/platform/avr32/compiler.h
===================================================================
--- trunk/src/platform/avr32/compiler.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/compiler.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,1112 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Compiler file for AVR32.
+ *
+ * This file defines commonly used types and macros.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _COMPILER_H_
+#define _COMPILER_H_
+
+#if (__GNUC__ &amp;&amp; __AVR32__) || (__ICCAVR32__ || __AAVR32__)
+#  include &lt;avr32/io.h&gt;
+#endif
+#if __ICCAVR32__
+#  include &lt;intrinsics.h&gt;
+#endif
+#include &quot;preprocessor.h&quot;
+
+
+//_____ D E C L A R A T I O N S ____________________________________________
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+#include &lt;stddef.h&gt;
+#include &lt;stdlib.h&gt;
+
+
+#if __ICCAVR32__
+
+/*! \name Compiler Keywords
+ *
+ * Port of some keywords from GNU GCC for AVR32 to IAR Embedded Workbench for Atmel AVR32.
+ */
+//! @{
+#define __asm__             asm
+#define __inline__          inline
+#define __volatile__
+//! @}
+
+#endif
+
+
+/*! \name Usual Types
+ */
+//! @{
+typedef unsigned char           Bool; //!&lt; Boolean.
+typedef signed char             S8 ;  //!&lt; 8-bit signed integer.
+typedef unsigned char           U8 ;  //!&lt; 8-bit unsigned integer.
+typedef signed short int        S16;  //!&lt; 16-bit signed integer.
+typedef unsigned short int      U16;  //!&lt; 16-bit unsigned integer.
+typedef signed long int         S32;  //!&lt; 32-bit signed integer.
+typedef unsigned long int       U32;  //!&lt; 32-bit unsigned integer.
+typedef signed long long int    S64;  //!&lt; 64-bit signed integer.
+typedef unsigned long long int  U64;  //!&lt; 64-bit unsigned integer.
+typedef float                   F32;  //!&lt; 32-bit floating-point number.
+typedef double                  F64;  //!&lt; 64-bit floating-point number.
+//! @}
+
+
+/*! \name Status Types
+ */
+//! @{
+typedef Bool                Status_bool_t;  //!&lt; Boolean status.
+typedef U8                  Status_t;       //!&lt; 8-bit-coded status.
+//! @}
+
+
+/*! \name Aliasing Aggregate Types
+ */
+//! @{
+
+//! 16-bit union.
+typedef union
+{
+  S16 s16   ;
+  U16 u16   ;
+  S8  s8 [2];
+  U8  u8 [2];
+} Union16;
+
+//! 32-bit union.
+typedef union
+{
+  S32 s32   ;
+  U32 u32   ;
+  S16 s16[2];
+  U16 u16[2];
+  S8  s8 [4];
+  U8  u8 [4];
+} Union32;
+
+//! 64-bit union.
+typedef union
+{
+  S64 s64   ;
+  U64 u64   ;
+  S32 s32[2];
+  U32 u32[2];
+  S16 s16[4];
+  U16 u16[4];
+  S8  s8 [8];
+  U8  u8 [8];
+} Union64;
+
+//! Union of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  S64 *s64ptr;
+  U64 *u64ptr;
+  S32 *s32ptr;
+  U32 *u32ptr;
+  S16 *s16ptr;
+  U16 *u16ptr;
+  S8  *s8ptr ;
+  U8  *u8ptr ;
+} UnionPtr;
+
+//! Union of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  volatile S64 *s64ptr;
+  volatile U64 *u64ptr;
+  volatile S32 *s32ptr;
+  volatile U32 *u32ptr;
+  volatile S16 *s16ptr;
+  volatile U16 *u16ptr;
+  volatile S8  *s8ptr ;
+  volatile U8  *u8ptr ;
+} UnionVPtr;
+
+//! Union of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  const S64 *s64ptr;
+  const U64 *u64ptr;
+  const S32 *s32ptr;
+  const U32 *u32ptr;
+  const S16 *s16ptr;
+  const U16 *u16ptr;
+  const S8  *s8ptr ;
+  const U8  *u8ptr ;
+} UnionCPtr;
+
+//! Union of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  const volatile S64 *s64ptr;
+  const volatile U64 *u64ptr;
+  const volatile S32 *s32ptr;
+  const volatile U32 *u32ptr;
+  const volatile S16 *s16ptr;
+  const volatile U16 *u16ptr;
+  const volatile S8  *s8ptr ;
+  const volatile U8  *u8ptr ;
+} UnionCVPtr;
+
+//! Structure of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  S64 *s64ptr;
+  U64 *u64ptr;
+  S32 *s32ptr;
+  U32 *u32ptr;
+  S16 *s16ptr;
+  U16 *u16ptr;
+  S8  *s8ptr ;
+  U8  *u8ptr ;
+} StructPtr;
+
+//! Structure of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  volatile S64 *s64ptr;
+  volatile U64 *u64ptr;
+  volatile S32 *s32ptr;
+  volatile U32 *u32ptr;
+  volatile S16 *s16ptr;
+  volatile U16 *u16ptr;
+  volatile S8  *s8ptr ;
+  volatile U8  *u8ptr ;
+} StructVPtr;
+
+//! Structure of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  const S64 *s64ptr;
+  const U64 *u64ptr;
+  const S32 *s32ptr;
+  const U32 *u32ptr;
+  const S16 *s16ptr;
+  const U16 *u16ptr;
+  const S8  *s8ptr ;
+  const U8  *u8ptr ;
+} StructCPtr;
+
+//! Structure of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  const volatile S64 *s64ptr;
+  const volatile U64 *u64ptr;
+  const volatile S32 *s32ptr;
+  const volatile U32 *u32ptr;
+  const volatile S16 *s16ptr;
+  const volatile U16 *u16ptr;
+  const volatile S8  *s8ptr ;
+  const volatile U8  *u8ptr ;
+} StructCVPtr;
+
+//! @}
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+//_____ M A C R O S ________________________________________________________
+
+/*! \name Usual Constants
+ */
+//! @{
+#define DISABLE   0
+#define ENABLE    1
+#define DISABLED  0
+#define ENABLED   1
+#define OFF       0
+#define ON        1
+#define FALSE     0
+#define TRUE      1
+#define KO        0
+#define OK        1
+#define PASS      0
+#define FAIL      1
+#define LOW       0
+#define HIGH      1
+#define CLR       0
+#define SET       1
+//! @}
+
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+/*! \name Bit-Field Handling
+ */
+//! @{
+
+/*! \brief Reads the bits of a value specified by a given bit-mask.
+ *
+ * \param value Value to read bits from.
+ * \param mask  Bit-mask indicating bits to read.
+ *
+ * \return Read bits.
+ */
+#define Rd_bits( value, mask)        ((value) &amp; (mask))
+
+/*! \brief Writes the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue to write bits to.
+ * \param mask    Bit-mask indicating bits to write.
+ * \param bits    Bits to write.
+ *
+ * \return Resulting value with written bits.
+ */
+#define Wr_bits(lvalue, mask, bits)  ((lvalue) = ((lvalue) &amp; ~(mask)) |\
+                                                 ((bits  ) &amp;  (mask)))
+
+/*! \brief Tests the bits of a value specified by a given bit-mask.
+ *
+ * \param value Value of which to test bits.
+ * \param mask  Bit-mask indicating bits to test.
+ *
+ * \return \c 1 if at least one of the tested bits is set, else \c 0.
+ */
+#define Tst_bits( value, mask)  (Rd_bits(value, mask) != 0)
+
+/*! \brief Clears the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue of which to clear bits.
+ * \param mask    Bit-mask indicating bits to clear.
+ *
+ * \return Resulting value with cleared bits.
+ */
+#define Clr_bits(lvalue, mask)  ((lvalue) &amp;= ~(mask))
+
+/*! \brief Sets the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue of which to set bits.
+ * \param mask    Bit-mask indicating bits to set.
+ *
+ * \return Resulting value with set bits.
+ */
+#define Set_bits(lvalue, mask)  ((lvalue) |=  (mask))
+
+/*! \brief Toggles the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue of which to toggle bits.
+ * \param mask    Bit-mask indicating bits to toggle.
+ *
+ * \return Resulting value with toggled bits.
+ */
+#define Tgl_bits(lvalue, mask)  ((lvalue) ^=  (mask))
+
+/*! \brief Reads the bit-field of a value specified by a given bit-mask.
+ *
+ * \param value Value to read a bit-field from.
+ * \param mask  Bit-mask indicating the bit-field to read.
+ *
+ * \return Read bit-field.
+ */
+#define Rd_bitfield( value, mask)           (Rd_bits( value, mask) &gt;&gt; ctz(mask))
+
+/*! \brief Writes the bit-field of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue    C lvalue to write a bit-field to.
+ * \param mask      Bit-mask indicating the bit-field to write.
+ * \param bitfield  Bit-field to write.
+ *
+ * \return Resulting value with written bit-field.
+ */
+#define Wr_bitfield(lvalue, mask, bitfield) (Wr_bits(lvalue, mask, (U32)(bitfield) &lt;&lt; ctz(mask)))
+
+//! @}
+
+
+/*! \brief This macro is used to test fatal errors.
+ *
+ * The macro tests if the expression is FALSE. If it is, a fatal error is
+ * detected and the application hangs up.
+ *
+ * \param expr  Expression to evaluate and supposed to be nonzero.
+ */
+#ifdef _ASSERT_ENABLE_
+  #define Assert(expr) \
+  {\
+    if (!(expr)) while (TRUE);\
+  }
+#else
+  #define Assert(expr)
+#endif
+
+
+/*! \name Zero-Bit Counting
+ *
+ * Under AVR32-GCC, __builtin_clz and __builtin_ctz behave like macros when
+ * applied to constant expressions (values known at compile time), so they are
+ * more optimized than the use of the corresponding assembly instructions and
+ * they can be used as constant expressions e.g. to initialize objects having
+ * static storage duration, and like the corresponding assembly instructions
+ * when applied to non-constant expressions (values unknown at compile time), so
+ * they are more optimized than an assembly periphrasis. Hence, clz and ctz
+ * ensure a possible and optimized behavior for both constant and non-constant
+ * expressions.
+ */
+//! @{
+
+/*! \brief Counts the leading zero bits of the given value considered as a 32-bit integer.
+ *
+ * \param u Value of which to count the leading zero bits.
+ *
+ * \return The count of leading zero bits in \a u.
+ */
+#if __GNUC__
+  #define clz(u)              __builtin_clz(u)
+#elif __ICCAVR32__
+  #define clz(u)              __count_leading_zeros(u)
+#endif
+
+/*! \brief Counts the trailing zero bits of the given value considered as a 32-bit integer.
+ *
+ * \param u Value of which to count the trailing zero bits.
+ *
+ * \return The count of trailing zero bits in \a u.
+ */
+#if __GNUC__
+  #define ctz(u)              __builtin_ctz(u)
+#elif __ICCAVR32__
+  #define ctz(u)              __count_trailing_zeros(u)
+#endif
+
+//! @}
+
+
+/*! \name Bit Reversing
+ */
+//! @{
+
+/*! \brief Reverses the bits of \a u8.
+ *
+ * \param u8  U8 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u8 with reversed bits.
+ */
+#define bit_reverse8(u8)    ((U8)(bit_reverse32((U8)(u8)) &gt;&gt; 24))
+
+/*! \brief Reverses the bits of \a u16.
+ *
+ * \param u16 U16 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u16 with reversed bits.
+ */
+#define bit_reverse16(u16)  ((U16)(bit_reverse32((U16)(u16)) &gt;&gt; 16))
+
+/*! \brief Reverses the bits of \a u32.
+ *
+ * \param u32 U32 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u32 with reversed bits.
+ */
+#if __GNUC__
+  #define bit_reverse32(u32) \
+  (\
+    {\
+      unsigned int __value = (U32)(u32);\
+      __asm__ (&quot;brev\t%0&quot; : &quot;+r&quot; (__value) :  : &quot;cc&quot;);\
+      (U32)__value;\
+    }\
+  )
+#elif __ICCAVR32__
+  #define bit_reverse32(u32)  ((U32)__bit_reverse((U32)(u32)))
+#endif
+
+/*! \brief Reverses the bits of \a u64.
+ *
+ * \param u64 U64 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u64 with reversed bits.
+ */
+#define bit_reverse64(u64)  ((U64)(((U64)bit_reverse32((U64)(u64) &gt;&gt; 32)) |\
+                                   ((U64)bit_reverse32((U64)(u64)) &lt;&lt; 32)))
+
+//! @}
+
+
+/*! \name Alignment
+ */
+//! @{
+
+/*! \brief Tests alignment of the number \a val with the \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return \c 1 if the number \a val is aligned with the \a n boundary, else \c 0.
+ */
+#define Test_align(val, n     ) (!Tst_bits( val, (n) - 1     )   )
+
+/*! \brief Gets alignment of the number \a val with respect to the \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return Alignment of the number \a val with respect to the \a n boundary.
+ */
+#define Get_align( val, n     ) (  Rd_bits( val, (n) - 1     )   )
+
+/*! \brief Sets alignment of the lvalue number \a lval to \a alg with respect to the \a n boundary.
+ *
+ * \param lval  Input/output lvalue.
+ * \param n     Boundary.
+ * \param alg   Alignment.
+ *
+ * \return New value of \a lval resulting from its alignment set to \a alg with respect to the \a n boundary.
+ */
+#define Set_align(lval, n, alg) (  Wr_bits(lval, (n) - 1, alg)   )
+
+/*! \brief Aligns the number \a val with the upper \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return Value resulting from the number \a val aligned with the upper \a n boundary.
+ */
+#define Align_up(  val, n     ) (((val) + ((n) - 1)) &amp; ~((n) - 1))
+
+/*! \brief Aligns the number \a val with the lower \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return Value resulting from the number \a val aligned with the lower \a n boundary.
+ */
+#define Align_down(val, n     ) ( (val)              &amp; ~((n) - 1))
+
+//! @}
+
+
+/*! \name Mathematics
+ *
+ * The same considerations as for clz and ctz apply here but AVR32-GCC does not
+ * provide built-in functions to access the assembly instructions abs, min and
+ * max and it does not produce them by itself in most cases, so two sets of
+ * macros are defined here:
+ *   - Abs, Min and Max to apply to constant expressions (values known at
+ *     compile time);
+ *   - abs, min and max to apply to non-constant expressions (values unknown at
+ *     compile time).
+ */
+//! @{
+
+/*! \brief Takes the absolute value of \a a.
+ *
+ * \param a Input value.
+ *
+ * \return Absolute value of \a a.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Abs(a)              (((a) &lt;  0 ) ? -(a) : (a))
+
+/*! \brief Takes the minimal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Minimal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Min(a, b)           (((a) &lt; (b)) ?  (a) : (b))
+
+/*! \brief Takes the maximal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Maximal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Max(a, b)           (((a) &gt; (b)) ?  (a) : (b))
+
+/*! \brief Takes the absolute value of \a a.
+ *
+ * \param a Input value.
+ *
+ * \return Absolute value of \a a.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if __GNUC__
+  #define abs(a) \
+  (\
+    {\
+      int __value = (a);\
+      __asm__ (&quot;abs\t%0&quot; : &quot;+r&quot; (__value) :  : &quot;cc&quot;);\
+      __value;\
+    }\
+  )
+#elif __ICCAVR32__
+  #define abs(a)      Abs(a)
+#endif
+
+/*! \brief Takes the minimal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Minimal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if __GNUC__
+  #define min(a, b) \
+  (\
+    {\
+      int __value, __arg_a = (a), __arg_b = (b);\
+      __asm__ (&quot;min\t%0, %1, %2&quot; : &quot;=r&quot; (__value) : &quot;r&quot; (__arg_a), &quot;r&quot; (__arg_b));\
+      __value;\
+    }\
+  )
+#elif __ICCAVR32__
+  #define min(a, b)   __min(a, b)
+#endif
+
+/*! \brief Takes the maximal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Maximal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if __GNUC__
+  #define max(a, b) \
+  (\
+    {\
+      int __value, __arg_a = (a), __arg_b = (b);\
+      __asm__ (&quot;max\t%0, %1, %2&quot; : &quot;=r&quot; (__value) : &quot;r&quot; (__arg_a), &quot;r&quot; (__arg_b));\
+      __value;\
+    }\
+  )
+#elif __ICCAVR32__
+  #define max(a, b)   __max(a, b)
+#endif
+
+//! @}
+
+
+/*! \brief Calls the routine at address \a addr.
+ *
+ * It generates a long call opcode.
+ *
+ * For example, `Long_call(0x80000000)' generates a software reset on a UC3 if
+ * it is invoked from the CPU supervisor mode.
+ *
+ * \param addr  Address of the routine to call.
+ *
+ * \note It may be used as a long jump opcode in some special cases.
+ */
+#define Long_call(addr)                   ((*(void (*)(void))(addr))())
+
+/*! \brief Resets the CPU by software.
+ *
+ * \warning It shall not be called from the CPU application mode.
+ */
+#if __GNUC__
+  #define Reset_CPU() \
+  (\
+    {\
+      __asm__ __volatile__ (\
+        &quot;lddpc   r9, 3f\n\t&quot;\
+        &quot;mfsr    r8, %[SR]\n\t&quot;\
+        &quot;bfextu  r8, r8, %[SR_MX_OFFSET], %[SR_MX_SIZE]\n\t&quot;\
+        &quot;cp.w    r8, 0b001\n\t&quot;\
+        &quot;breq    0f\n\t&quot;\
+        &quot;sub     r8, pc, $ - 1f\n\t&quot;\
+        &quot;pushm   r8-r9\n\t&quot;\
+        &quot;rete\n&quot;\
+        &quot;0:\n\t&quot;\
+        &quot;mtsr    %[SR], r9\n&quot;\
+        &quot;1:\n\t&quot;\
+        &quot;mov     r0, 0\n\t&quot;\
+        &quot;mov     r1, 0\n\t&quot;\
+        &quot;mov     r2, 0\n\t&quot;\
+        &quot;mov     r3, 0\n\t&quot;\
+        &quot;mov     r4, 0\n\t&quot;\
+        &quot;mov     r5, 0\n\t&quot;\
+        &quot;mov     r6, 0\n\t&quot;\
+        &quot;mov     r7, 0\n\t&quot;\
+        &quot;mov     r8, 0\n\t&quot;\
+        &quot;mov     r9, 0\n\t&quot;\
+        &quot;mov     r10, 0\n\t&quot;\
+        &quot;mov     r11, 0\n\t&quot;\
+        &quot;mov     r12, 0\n\t&quot;\
+        &quot;mov     sp, 0\n\t&quot;\
+        &quot;stdsp   sp[0], sp\n\t&quot;\
+        &quot;ldmts   sp, sp\n\t&quot;\
+        &quot;mov     lr, 0\n\t&quot;\
+        &quot;lddpc   pc, 2f\n\t&quot;\
+        &quot;.balign 4\n&quot;\
+        &quot;2:\n\t&quot;\
+        &quot;.word   _start\n&quot;\
+        &quot;3:\n\t&quot;\
+        &quot;.word   %[RESET_SR]&quot;\
+        :\
+        : [SR] &quot;i&quot; (AVR32_SR),\
+          [SR_MX_OFFSET] &quot;i&quot; (AVR32_SR_M0_OFFSET),\
+          [SR_MX_SIZE] &quot;i&quot; (AVR32_SR_M0_SIZE + AVR32_SR_M1_SIZE + AVR32_SR_M2_SIZE),\
+          [RESET_SR] &quot;i&quot; (AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | AVR32_SR_M0_MASK)\
+      );\
+    }\
+  )
+#elif __ICCAVR32__
+  #define Reset_CPU() \
+  {\
+    extern void *volatile __program_start;\
+    __asm__ __volatile__ (\
+      &quot;mov     r7, LWRD(__program_start)\n\t&quot;\
+      &quot;orh     r7, HWRD(__program_start)\n\t&quot;\
+      &quot;mov     r9, LWRD(&quot;ASTRINGZ(AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | AVR32_SR_M0_MASK)&quot;)\n\t&quot;\
+      &quot;orh     r9, HWRD(&quot;ASTRINGZ(AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | AVR32_SR_M0_MASK)&quot;)\n\t&quot;\
+      &quot;mfsr    r8, &quot;ASTRINGZ(AVR32_SR)&quot;\n\t&quot;\
+      &quot;bfextu  r8, r8, &quot;ASTRINGZ(AVR32_SR_M0_OFFSET)&quot;, &quot;ASTRINGZ(AVR32_SR_M0_SIZE + AVR32_SR_M1_SIZE + AVR32_SR_M2_SIZE)&quot;\n\t&quot;\
+      &quot;cp.w    r8, 001b\n\t&quot;\
+      &quot;breq    $ + 10\n\t&quot;\
+      &quot;sub     r8, pc, -12\n\t&quot;\
+      &quot;pushm   r8-r9\n\t&quot;\
+      &quot;rete\n\t&quot;\
+      &quot;mtsr    &quot;ASTRINGZ(AVR32_SR)&quot;, r9\n\t&quot;\
+      &quot;mov     r0, 0\n\t&quot;\
+      &quot;mov     r1, 0\n\t&quot;\
+      &quot;mov     r2, 0\n\t&quot;\
+      &quot;mov     r3, 0\n\t&quot;\
+      &quot;mov     r4, 0\n\t&quot;\
+      &quot;mov     r5, 0\n\t&quot;\
+      &quot;mov     r6, 0\n\t&quot;\
+      &quot;st.w    r0[4], r7\n\t&quot;\
+      &quot;mov     r7, 0\n\t&quot;\
+      &quot;mov     r8, 0\n\t&quot;\
+      &quot;mov     r9, 0\n\t&quot;\
+      &quot;mov     r10, 0\n\t&quot;\
+      &quot;mov     r11, 0\n\t&quot;\
+      &quot;mov     r12, 0\n\t&quot;\
+      &quot;mov     sp, 0\n\t&quot;\
+      &quot;stdsp   sp[0], sp\n\t&quot;\
+      &quot;ldmts   sp, sp\n\t&quot;\
+      &quot;mov     lr, 0\n\t&quot;\
+      &quot;ld.w    pc, lr[4]&quot;\
+    );\
+    __program_start;\
+  }
+#endif
+
+
+/*! \name System Register Access
+ */
+//! @{
+
+/*! \brief Gets the value of the \a sysreg system register.
+ *
+ * \param sysreg  Address of the system register of which to get the value.
+ *
+ * \return Value of the \a sysreg system register.
+ */
+#if __GNUC__
+  #define Get_system_register(sysreg)         __builtin_mfsr(sysreg)
+#elif __ICCAVR32__
+  #define Get_system_register(sysreg)         __get_system_register(sysreg)
+#endif
+
+/*! \brief Sets the value of the \a sysreg system register to \a value.
+ *
+ * \param sysreg  Address of the system register of which to set the value.
+ * \param value   Value to set the \a sysreg system register to.
+ */
+#if __GNUC__
+  #define Set_system_register(sysreg, value)  __builtin_mtsr(sysreg, value)
+#elif __ICCAVR32__
+  #define Set_system_register(sysreg, value)  __set_system_register(sysreg, value)
+#endif
+
+//! @}
+
+
+/*! \name CPU Status Register Access
+ */
+//! @{
+
+/*! \brief Tells whether exceptions are globally enabled.
+ *
+ * \return \c 1 if exceptions are globally enabled, else \c 0.
+ */
+#define Is_global_exception_enabled()       (!Tst_bits(Get_system_register(AVR32_SR), AVR32_SR_EM_MASK))
+
+/*! \brief Disables exceptions globally.
+ */
+#if __GNUC__
+  #define Disable_global_exception()        ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_EM_OFFSET));})
+#elif __ICCAVR32__
+  #define Disable_global_exception()        (__set_status_flag(AVR32_SR_EM_OFFSET))
+#endif
+
+/*! \brief Enables exceptions globally.
+ */
+#if __GNUC__
+  #define Enable_global_exception()         ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_EM_OFFSET));})
+#elif __ICCAVR32__
+  #define Enable_global_exception()         (__clear_status_flag(AVR32_SR_EM_OFFSET))
+#endif
+
+/*! \brief Tells whether interrupts are globally enabled.
+ *
+ * \return \c 1 if interrupts are globally enabled, else \c 0.
+ */
+#define Is_global_interrupt_enabled()       (!Tst_bits(Get_system_register(AVR32_SR), AVR32_SR_GM_MASK))
+
+/*! \brief Disables interrupts globally.
+ */
+#if __GNUC__
+  #define Disable_global_interrupt()        ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_GM_OFFSET));})
+#elif __ICCAVR32__
+  #define Disable_global_interrupt()        (__disable_interrupt())
+#endif
+
+/*! \brief Enables interrupts globally.
+ */
+#if __GNUC__
+  #define Enable_global_interrupt()         ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_GM_OFFSET));})
+#elif __ICCAVR32__
+  #define Enable_global_interrupt()         (__enable_interrupt())
+#endif
+
+/*! \brief Tells whether interrupt level \a int_lev is enabled.
+ *
+ * \param int_lev Interrupt level (0 to 3).
+ *
+ * \return \c 1 if interrupt level \a int_lev is enabled, else \c 0.
+ */
+#define Is_interrupt_level_enabled(int_lev) (!Tst_bits(Get_system_register(AVR32_SR), TPASTE3(AVR32_SR_I, int_lev, M_MASK)))
+
+/*! \brief Disables interrupt level \a int_lev.
+ *
+ * \param int_lev Interrupt level to disable (0 to 3).
+ */
+#if __GNUC__
+  #define Disable_interrupt_level(int_lev)  ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)));})
+#elif __ICCAVR32__
+  #define Disable_interrupt_level(int_lev)  (__set_status_flag(TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)))
+#endif
+
+/*! \brief Enables interrupt level \a int_lev.
+ *
+ * \param int_lev Interrupt level to enable (0 to 3).
+ */
+#if __GNUC__
+  #define Enable_interrupt_level(int_lev)   ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)));})
+#elif __ICCAVR32__
+  #define Enable_interrupt_level(int_lev)   (__clear_status_flag(TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)))
+#endif
+
+//! @}
+
+
+/*! \name Debug Register Access
+ */
+//! @{
+
+/*! \brief Gets the value of the \a dbgreg debug register.
+ *
+ * \param dbgreg  Address of the debug register of which to get the value.
+ *
+ * \return Value of the \a dbgreg debug register.
+ */
+#if __GNUC__
+  #define Get_debug_register(dbgreg)          __builtin_mfdr(dbgreg)
+#elif __ICCAVR32__
+  #define Get_debug_register(dbgreg)          __get_debug_register(dbgreg)
+#endif
+
+/*! \brief Sets the value of the \a dbgreg debug register to \a value.
+ *
+ * \param dbgreg  Address of the debug register of which to set the value.
+ * \param value   Value to set the \a dbgreg debug register to.
+ */
+#if __GNUC__
+  #define Set_debug_register(dbgreg, value)   __builtin_mtdr(dbgreg, value)
+#elif __ICCAVR32__
+  #define Set_debug_register(dbgreg, value)   __set_debug_register(dbgreg, value)
+#endif
+
+//! @}
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+//! Boolean evaluating MCU little endianism.
+#if (__GNUC__ &amp;&amp; __AVR32__) || (__ICCAVR32__ || __AAVR32__)
+  #define LITTLE_ENDIAN_MCU     FALSE
+#endif
+
+// Check that MCU endianism is correctly defined.
+#ifndef LITTLE_ENDIAN_MCU
+  #error YOU MUST define the MCU endianism with LITTLE_ENDIAN_MCU: either FALSE or TRUE
+#endif
+
+//! Boolean evaluating MCU big endianism.
+#define BIG_ENDIAN_MCU        (!LITTLE_ENDIAN_MCU)
+
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+/*! \name MCU Endianism Handling
+ */
+//! @{
+
+#if LITTLE_ENDIAN_MCU
+
+  #define LSB(u16)        (((U8  *)&amp;(u16))[0])  //!&lt; Least significant byte of \a u16.
+  #define MSB(u16)        (((U8  *)&amp;(u16))[1])  //!&lt; Most significant byte of \a u16.
+
+  #define LSH(u32)        (((U16 *)&amp;(u32))[0])  //!&lt; Least significant half-word of \a u32.
+  #define MSH(u32)        (((U16 *)&amp;(u32))[1])  //!&lt; Most significant half-word of \a u32.
+  #define LSB0W(u32)      (((U8  *)&amp;(u32))[0])  //!&lt; Least significant byte of 1st rank of \a u32.
+  #define LSB1W(u32)      (((U8  *)&amp;(u32))[1])  //!&lt; Least significant byte of 2nd rank of \a u32.
+  #define LSB2W(u32)      (((U8  *)&amp;(u32))[2])  //!&lt; Least significant byte of 3rd rank of \a u32.
+  #define LSB3W(u32)      (((U8  *)&amp;(u32))[3])  //!&lt; Least significant byte of 4th rank of \a u32.
+  #define MSB3W(u32)      LSB0W(u32)            //!&lt; Most significant byte of 4th rank of \a u32.
+  #define MSB2W(u32)      LSB1W(u32)            //!&lt; Most significant byte of 3rd rank of \a u32.
+  #define MSB1W(u32)      LSB2W(u32)            //!&lt; Most significant byte of 2nd rank of \a u32.
+  #define MSB0W(u32)      LSB3W(u32)            //!&lt; Most significant byte of 1st rank of \a u32.
+
+  #define LSW(u64)        (((U32 *)&amp;(u64))[0])  //!&lt; Least significant word of \a u64.
+  #define MSW(u64)        (((U32 *)&amp;(u64))[1])  //!&lt; Most significant word of \a u64.
+  #define LSH0(u64)       (((U16 *)&amp;(u64))[0])  //!&lt; Least significant half-word of 1st rank of \a u64.
+  #define LSH1(u64)       (((U16 *)&amp;(u64))[1])  //!&lt; Least significant half-word of 2nd rank of \a u64.
+  #define LSH2(u64)       (((U16 *)&amp;(u64))[2])  //!&lt; Least significant half-word of 3rd rank of \a u64.
+  #define LSH3(u64)       (((U16 *)&amp;(u64))[3])  //!&lt; Least significant half-word of 4th rank of \a u64.
+  #define MSH3(u64)       LSH0(u64)             //!&lt; Most significant half-word of 4th rank of \a u64.
+  #define MSH2(u64)       LSH1(u64)             //!&lt; Most significant half-word of 3rd rank of \a u64.
+  #define MSH1(u64)       LSH2(u64)             //!&lt; Most significant half-word of 2nd rank of \a u64.
+  #define MSH0(u64)       LSH3(u64)             //!&lt; Most significant half-word of 1st rank of \a u64.
+  #define LSB0D(u64)      (((U8  *)&amp;(u64))[0])  //!&lt; Least significant byte of 1st rank of \a u64.
+  #define LSB1D(u64)      (((U8  *)&amp;(u64))[1])  //!&lt; Least significant byte of 2nd rank of \a u64.
+  #define LSB2D(u64)      (((U8  *)&amp;(u64))[2])  //!&lt; Least significant byte of 3rd rank of \a u64.
+  #define LSB3D(u64)      (((U8  *)&amp;(u64))[3])  //!&lt; Least significant byte of 4th rank of \a u64.
+  #define LSB4D(u64)      (((U8  *)&amp;(u64))[4])  //!&lt; Least significant byte of 5th rank of \a u64.
+  #define LSB5D(u64)      (((U8  *)&amp;(u64))[5])  //!&lt; Least significant byte of 6th rank of \a u64.
+  #define LSB6D(u64)      (((U8  *)&amp;(u64))[6])  //!&lt; Least significant byte of 7th rank of \a u64.
+  #define LSB7D(u64)      (((U8  *)&amp;(u64))[7])  //!&lt; Least significant byte of 8th rank of \a u64.
+  #define MSB7D(u64)      LSB0D(u64)            //!&lt; Most significant byte of 8th rank of \a u64.
+  #define MSB6D(u64)      LSB1D(u64)            //!&lt; Most significant byte of 7th rank of \a u64.
+  #define MSB5D(u64)      LSB2D(u64)            //!&lt; Most significant byte of 6th rank of \a u64.
+  #define MSB4D(u64)      LSB3D(u64)            //!&lt; Most significant byte of 5th rank of \a u64.
+  #define MSB3D(u64)      LSB4D(u64)            //!&lt; Most significant byte of 4th rank of \a u64.
+  #define MSB2D(u64)      LSB5D(u64)            //!&lt; Most significant byte of 3rd rank of \a u64.
+  #define MSB1D(u64)      LSB6D(u64)            //!&lt; Most significant byte of 2nd rank of \a u64.
+  #define MSB0D(u64)      LSB7D(u64)            //!&lt; Most significant byte of 1st rank of \a u64.
+
+#else // BIG_ENDIAN_MCU
+
+  #define MSB(u16)        (((U8  *)&amp;(u16))[0])  //!&lt; Most significant byte of \a u16.
+  #define LSB(u16)        (((U8  *)&amp;(u16))[1])  //!&lt; Least significant byte of \a u16.
+
+  #define MSH(u32)        (((U16 *)&amp;(u32))[0])  //!&lt; Most significant half-word of \a u32.
+  #define LSH(u32)        (((U16 *)&amp;(u32))[1])  //!&lt; Least significant half-word of \a u32.
+  #define MSB0W(u32)      (((U8  *)&amp;(u32))[0])  //!&lt; Most significant byte of 1st rank of \a u32.
+  #define MSB1W(u32)      (((U8  *)&amp;(u32))[1])  //!&lt; Most significant byte of 2nd rank of \a u32.
+  #define MSB2W(u32)      (((U8  *)&amp;(u32))[2])  //!&lt; Most significant byte of 3rd rank of \a u32.
+  #define MSB3W(u32)      (((U8  *)&amp;(u32))[3])  //!&lt; Most significant byte of 4th rank of \a u32.
+  #define LSB3W(u32)      MSB0W(u32)            //!&lt; Least significant byte of 4th rank of \a u32.
+  #define LSB2W(u32)      MSB1W(u32)            //!&lt; Least significant byte of 3rd rank of \a u32.
+  #define LSB1W(u32)      MSB2W(u32)            //!&lt; Least significant byte of 2nd rank of \a u32.
+  #define LSB0W(u32)      MSB3W(u32)            //!&lt; Least significant byte of 1st rank of \a u32.
+
+  #define MSW(u64)        (((U32 *)&amp;(u64))[0])  //!&lt; Most significant word of \a u64.
+  #define LSW(u64)        (((U32 *)&amp;(u64))[1])  //!&lt; Least significant word of \a u64.
+  #define MSH0(u64)       (((U16 *)&amp;(u64))[0])  //!&lt; Most significant half-word of 1st rank of \a u64.
+  #define MSH1(u64)       (((U16 *)&amp;(u64))[1])  //!&lt; Most significant half-word of 2nd rank of \a u64.
+  #define MSH2(u64)       (((U16 *)&amp;(u64))[2])  //!&lt; Most significant half-word of 3rd rank of \a u64.
+  #define MSH3(u64)       (((U16 *)&amp;(u64))[3])  //!&lt; Most significant half-word of 4th rank of \a u64.
+  #define LSH3(u64)       MSH0(u64)             //!&lt; Least significant half-word of 4th rank of \a u64.
+  #define LSH2(u64)       MSH1(u64)             //!&lt; Least significant half-word of 3rd rank of \a u64.
+  #define LSH1(u64)       MSH2(u64)             //!&lt; Least significant half-word of 2nd rank of \a u64.
+  #define LSH0(u64)       MSH3(u64)             //!&lt; Least significant half-word of 1st rank of \a u64.
+  #define MSB0D(u64)      (((U8  *)&amp;(u64))[0])  //!&lt; Most significant byte of 1st rank of \a u64.
+  #define MSB1D(u64)      (((U8  *)&amp;(u64))[1])  //!&lt; Most significant byte of 2nd rank of \a u64.
+  #define MSB2D(u64)      (((U8  *)&amp;(u64))[2])  //!&lt; Most significant byte of 3rd rank of \a u64.
+  #define MSB3D(u64)      (((U8  *)&amp;(u64))[3])  //!&lt; Most significant byte of 4th rank of \a u64.
+  #define MSB4D(u64)      (((U8  *)&amp;(u64))[4])  //!&lt; Most significant byte of 5th rank of \a u64.
+  #define MSB5D(u64)      (((U8  *)&amp;(u64))[5])  //!&lt; Most significant byte of 6th rank of \a u64.
+  #define MSB6D(u64)      (((U8  *)&amp;(u64))[6])  //!&lt; Most significant byte of 7th rank of \a u64.
+  #define MSB7D(u64)      (((U8  *)&amp;(u64))[7])  //!&lt; Most significant byte of 8th rank of \a u64.
+  #define LSB7D(u64)      MSB0D(u64)            //!&lt; Least significant byte of 8th rank of \a u64.
+  #define LSB6D(u64)      MSB1D(u64)            //!&lt; Least significant byte of 7th rank of \a u64.
+  #define LSB5D(u64)      MSB2D(u64)            //!&lt; Least significant byte of 6th rank of \a u64.
+  #define LSB4D(u64)      MSB3D(u64)            //!&lt; Least significant byte of 5th rank of \a u64.
+  #define LSB3D(u64)      MSB4D(u64)            //!&lt; Least significant byte of 4th rank of \a u64.
+  #define LSB2D(u64)      MSB5D(u64)            //!&lt; Least significant byte of 3rd rank of \a u64.
+  #define LSB1D(u64)      MSB6D(u64)            //!&lt; Least significant byte of 2nd rank of \a u64.
+  #define LSB0D(u64)      MSB7D(u64)            //!&lt; Least significant byte of 1st rank of \a u64.
+
+#endif
+
+//! @}
+
+
+/*! \name Endianism Conversion
+ *
+ * The same considerations as for clz and ctz apply here but AVR32-GCC's
+ * __builtin_bswap_16 and __builtin_bswap_32 do not behave like macros when
+ * applied to constant expressions, so two sets of macros are defined here:
+ *   - Swap16, Swap32 and Swap64 to apply to constant expressions (values known
+ *     at compile time);
+ *   - swap16, swap32 and swap64 to apply to non-constant expressions (values
+ *     unknown at compile time).
+ */
+//! @{
+
+/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
+ *
+ * \param u16 U16 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u16 with toggled endianism.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Swap16(u16) ((U16)(((U16)(u16) &gt;&gt; 8) |\
+                           ((U16)(u16) &lt;&lt; 8)))
+
+/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
+ *
+ * \param u32 U32 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u32 with toggled endianism.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Swap32(u32) ((U32)(((U32)Swap16((U32)(u32) &gt;&gt; 16)) |\
+                           ((U32)Swap16((U32)(u32)) &lt;&lt; 16)))
+
+/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
+ *
+ * \param u64 U64 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u64 with toggled endianism.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Swap64(u64) ((U64)(((U64)Swap32((U64)(u64) &gt;&gt; 32)) |\
+                           ((U64)Swap32((U64)(u64)) &lt;&lt; 32)))
+
+/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
+ *
+ * \param u16 U16 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u16 with toggled endianism.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if __GNUC__
+  #define swap16(u16) ((U16)__builtin_bswap_16((U16)(u16)))
+#elif __ICCAVR32__
+  #define swap16(u16) ((U16)__swap_bytes_in_halfwords((U16)(u16)))
+#endif
+
+/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
+ *
+ * \param u32 U32 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u32 with toggled endianism.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if __GNUC__
+  #define swap32(u32) ((U32)__builtin_bswap_32((U32)(u32)))
+#elif __ICCAVR32__
+  #define swap32(u32) ((U32)__swap_bytes((U32)(u32)))
+#endif
+
+/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
+ *
+ * \param u64 U64 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u64 with toggled endianism.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#define swap64(u64) ((U64)(((U64)swap32((U64)(u64) &gt;&gt; 32)) |\
+                           ((U64)swap32((U64)(u64)) &lt;&lt; 32)))
+
+//! @}
+
+
+/*! \name Target Abstraction
+ */
+//! @{
+
+#define _GLOBEXT_           extern      //!&lt; extern storage-class specifier.
+#define _CONST_TYPE_        const       //!&lt; const type qualifier.
+#define _MEM_TYPE_SLOW_                 //!&lt; Slow memory type.
+#define _MEM_TYPE_MEDFAST_              //!&lt; Fairly fast memory type.
+#define _MEM_TYPE_FAST_                 //!&lt; Fast memory type.
+
+typedef U8                  Byte;       //!&lt; 8-bit unsigned integer.
+
+#define memcmp_ram2ram      memcmp      //!&lt; Target-specific memcmp of RAM to RAM.
+#define memcmp_code2ram     memcmp      //!&lt; Target-specific memcmp of RAM to NVRAM.
+#define memcpy_ram2ram      memcpy      //!&lt; Target-specific memcpy from RAM to RAM.
+#define memcpy_code2ram     memcpy      //!&lt; Target-specific memcpy from NVRAM to RAM.
+
+#define LSB0(u32)           LSB0W(u32)  //!&lt; Least significant byte of 1st rank of \a u32.
+#define LSB1(u32)           LSB1W(u32)  //!&lt; Least significant byte of 2nd rank of \a u32.
+#define LSB2(u32)           LSB2W(u32)  //!&lt; Least significant byte of 3rd rank of \a u32.
+#define LSB3(u32)           LSB3W(u32)  //!&lt; Least significant byte of 4th rank of \a u32.
+#define MSB3(u32)           MSB3W(u32)  //!&lt; Most significant byte of 4th rank of \a u32.
+#define MSB2(u32)           MSB2W(u32)  //!&lt; Most significant byte of 3rd rank of \a u32.
+#define MSB1(u32)           MSB1W(u32)  //!&lt; Most significant byte of 2nd rank of \a u32.
+#define MSB0(u32)           MSB0W(u32)  //!&lt; Most significant byte of 1st rank of \a u32.
+
+//! @}
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+#endif  // _COMPILER_H_

Added: trunk/src/platform/avr32/conf.py
===================================================================
--- trunk/src/platform/avr32/conf.py	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/conf.py	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,25 @@
+# Configuration file for the AVR32 microcontroller
+
+specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c&quot;
+ldscript = &quot;at32uc3a0512.ld&quot;
+
+# Prepend with path
+specific_files = &quot; &quot;.join( [ &quot;src/platform/%s/%s&quot; % ( platform, f ) for f in specific_files.split() ] )
+ldscript = &quot;src/platform/%s/%s&quot; % ( platform, ldscript )
+
+# Toolset data
+tools[ 'avr32' ] = {}
+tools[ 'avr32' ][ 'cccom' ] = &quot;avr32-gcc -mpart=uc3a0512 %s %s -ffunction-sections -fdata-sections %s -Wall -c $SOURCE -o $TARGET&quot; % ( opt, local_include, cdefs )
+tools[ 'avr32' ][ 'linkcom' ] = &quot;avr32-gcc -nostartfiles -nostdlib -T %s -Wl,--gc-sections -Wl,-e,_stext -Wl,--allow-multiple-definition -o $TARGET $SOURCES -lc -lgcc -lm %s&quot; % ( ldscript, local_libs )
+tools[ 'avr32' ][ 'ascom' ] = &quot;avr32-gcc -x assembler-with-cpp %s -mpart=uc3a0512 %s -Wall -c $SOURCE -o $TARGET&quot; % ( local_include, cdefs )
+
+# Programming function
+def progfunc_avr32( target, source, env ):
+  outname = output + &quot;.elf&quot;
+  os.system( &quot;avr32-size %s&quot; % outname )
+  print &quot;Generating binary image...&quot;
+  os.system( &quot;avr32-objcopy -O ihex %s %s.hex&quot; % ( outname, output ) )
+#  print &quot;Programming...&quot;
+#  os.system( &quot;batchisp3.sh -hardware usb -device at32uc3a0512 -operation erase f memory flash blankcheck loadbuffer %s program verify start reset 0&quot; % ( output + &quot;.hex&quot; ) )
+
+tools[ 'avr32' ][ 'progfunc' ] = progfunc_avr32

Added: trunk/src/platform/avr32/conf_isp.h
===================================================================
--- trunk/src/platform/avr32/conf_isp.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/conf_isp.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,121 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file ******************************************************************
+ *
+ * \brief ISP configuration file.
+ *
+ * This file contains the possible external configuration of the ISP.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a USB module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ***************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _CONF_ISP_H_
+#define _CONF_ISP_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+
+
+//_____ D E F I N I T I O N S ______________________________________________
+
+#define PRODUCT_MANUFACTURER_ID       0x58
+#define PRODUCT_FAMILY_ID             0x20
+
+#define ISP_VERSION                   0x02
+#define ISP_ID0                       0x00
+#define ISP_ID1                       0x00
+
+#define ISP_GPFB_FORCE                31
+#define ISP_GPFB_FORCE_MASK           0x80000000
+#define ISP_GPFB_FORCE_OFFSET         31
+#define ISP_GPFB_FORCE_SIZE           1
+
+#define ISP_GPFB_IO_COND_EN           30
+#define ISP_GPFB_IO_COND_EN_MASK      0x40000000
+#define ISP_GPFB_IO_COND_EN_OFFSET    30
+#define ISP_GPFB_IO_COND_EN_SIZE      1
+
+#define ISP_GPFB_BOD_EN               29
+#define ISP_GPFB_BOD_EN_MASK          0x20000000
+#define ISP_GPFB_BOD_EN_OFFSET        29
+#define ISP_GPFB_BOD_EN_SIZE          1
+
+#define ISP_CFG                       (*(volatile U32 *)ISP_CFG_ADDRESS)
+#define ISP_CFG_ADDRESS               (AVR32_FLASHC_USER_PAGE_ADDRESS + ISP_CFG_OFFSET)
+#define ISP_CFG_OFFSET                0x000001FC
+#define ISP_CFG_SIZE                  4
+
+#define ISP_CFG_BOOT_KEY              17
+#define ISP_CFG_BOOT_KEY_MASK         0xFFFE0000
+#define ISP_CFG_BOOT_KEY_OFFSET       17
+#define ISP_CFG_BOOT_KEY_SIZE         15
+#define ISP_CFG_BOOT_KEY_VALUE        0x494F
+
+#define ISP_CFG_IO_COND_LEVEL         16
+#define ISP_CFG_IO_COND_LEVEL_MASK    0x00010000
+#define ISP_CFG_IO_COND_LEVEL_OFFSET  16
+#define ISP_CFG_IO_COND_LEVEL_SIZE    1
+
+#define ISP_CFG_IO_COND_PIN           8
+#define ISP_CFG_IO_COND_PIN_MASK      0x0000FF00
+#define ISP_CFG_IO_COND_PIN_OFFSET    8
+#define ISP_CFG_IO_COND_PIN_SIZE      8
+
+#define ISP_CFG_CRC8                  0
+#define ISP_CFG_CRC8_MASK             0x000000FF
+#define ISP_CFG_CRC8_OFFSET           0
+#define ISP_CFG_CRC8_SIZE             8
+#define ISP_CFG_CRC8_POLYNOMIAL       0x107
+
+#define ISP_KEY                       (*(volatile U32 *)ISP_KEY_ADDRESS)
+#define ISP_KEY_ADDRESS               (AVR32_SRAM_ADDRESS + ISP_KEY_OFFSET)
+#define ISP_KEY_OFFSET                0x00000000
+#define ISP_KEY_SIZE                  4
+#define ISP_KEY_VALUE                 ('I' &lt;&lt; 24 | 'S' &lt;&lt; 16 | 'P' &lt;&lt; 8 | 'K')
+
+#ifndef ISP_OSC
+  #define ISP_OSC                     0
+#endif
+
+#define DFU_FRAME_LENGTH              2048
+
+#define PROGRAM_START_ADDRESS         (AVR32_FLASH_ADDRESS + PROGRAM_START_OFFSET)
+#define PROGRAM_START_OFFSET          0x00002000
+
+
+#endif  // _CONF_ISP_H_

Added: trunk/src/platform/avr32/crt0.s
===================================================================
--- trunk/src/platform/avr32/crt0.s	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/crt0.s	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,108 @@
+/* This file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief AVR32UC C runtime startup file.
+ *
+ * This file has been built from the Newlib crt0.S.
+ *
+ * - Compiler:           GNU GCC for AVR32
+ * - Supported devices:  All AVR32UC devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &lt;avr32/io.h&gt;
+#include &quot;stacks.h&quot;
+
+//! @{
+//! \verbatim
+
+
+  // _stext is placed outside the .reset section so that the program entry point
+  // can be changed without affecting the C runtime startup.
+  .section  .start, &quot;ax&quot;, @progbits
+
+
+  .global _stext
+  .type _stext, @function
+_stext:
+  // Set initial stack pointer.
+  lda.w   sp, _sstack
+  sub     sp, STACK_SIZE_TOTAL
+
+  // Set up EVBA so interrupts can be enabled.
+  lda.w   r0, _evba
+  mtsr    AVR32_EVBA, r0
+
+  // Enable the exception processing.
+  csrf    AVR32_SR_EM_OFFSET
+
+  // Load initialized data having a global lifetime from the data LMA.
+  lda.w   r0, _data
+  lda.w   r1, _edata
+  cp      r0, r1
+  brhs    idata_load_loop_end
+  lda.w   r2, _etext
+idata_load_loop:
+  ld.w    r4, r2++
+  st.w    r0++, r4
+  cp      r0, r1
+  brlo    idata_load_loop
+idata_load_loop_end:
+
+  // Clear uninitialized data having a global lifetime in the blank static storage section.
+  lda.w   r0, _bss
+  lda.w   r1, _ebss
+  cp      r0, r1
+  brhs    udata_clear_loop_end
+  mov     r2, 0
+  mov     r3, 0
+udata_clear_loop:
+  st.w    r0++, r2
+  cp      r0, r1
+  brlo    udata_clear_loop
+udata_clear_loop_end:
+
+  // Safety: Set the default &quot;return&quot; @ to the exit routine address.
+  lda.w   lr, _exit
+
+  // Start the show.
+  lda.w   pc, main
+
+_exit:
+  bral    _exit
+
+//! \endverbatim
+//! @}

Added: trunk/src/platform/avr32/evk1100.h
===================================================================
--- trunk/src/platform/avr32/evk1100.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/evk1100.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,354 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief AT32UC3A EVK1100 board header file.
+ *
+ * This file contains definitions and services related to the features of the
+ * EVK1100 board.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 AT32UC3A devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _EVK1100_H_
+#define _EVK1100_H_
+
+#include &quot;compiler.h&quot;
+
+//#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+//#  include &quot;led.h&quot;
+//#endif  // __AVR32_ABI_COMPILER__
+
+
+/*! \name Oscillator Definitions
+ */
+//! @{
+
+// RCOsc has no custom calibration by default. Set the following definition to
+// the appropriate value if a custom RCOsc calibration has been applied to your
+// part.
+//#define FRCOSC          AVR32_PM_RCOSC_FREQUENCY              //!&lt; RCOsc frequency: Hz.
+
+#define FOSC32          32768                                 //!&lt; Osc32 frequency: Hz.
+#define OSC32_STARTUP   AVR32_PM_OSCCTRL32_STARTUP_8192_RCOSC //!&lt; Osc32 startup time: RCOsc periods.
+
+#define FOSC0           12000000                              //!&lt; Osc0 frequency: Hz.
+#define OSC0_STARTUP    AVR32_PM_OSCCTRL0_STARTUP_2048_RCOSC  //!&lt; Osc0 startup time: RCOsc periods.
+
+// Osc1 crystal is not mounted by default. Set the following definitions to the
+// appropriate values if a custom Osc1 crystal is mounted on your board.
+//#define FOSC1           12000000                              //!&lt; Osc1 frequency: Hz.
+//#define OSC1_STARTUP    AVR32_PM_OSCCTRL1_STARTUP_2048_RCOSC  //!&lt; Osc1 startup time: RCOsc periods.
+
+//! @}
+
+
+/*! \name SDRAM Definitions
+ */
+//! @{
+
+//! Part header file of used SDRAM(s).
+#define SDRAM_PART_HDR  &quot;MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h&quot;
+
+//! Data bus width to use the SDRAM(s) with (16 or 32 bits; always 16 bits on
+//! UC3).
+#define SDRAM_DBW       16
+
+//! @}
+
+
+/*! \name USB Definitions
+ */
+//! @{
+
+//! Multiplexed pin used for USB_ID: AVR32_USBB_USB_ID_x_x.
+//! To be selected according to the AVR32_USBB_USB_ID_x_x_PIN and
+//! AVR32_USBB_USB_ID_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
+#define USB_ID                      AVR32_USBB_USB_ID_0_0
+
+//! Multiplexed pin used for USB_VBOF: AVR32_USBB_USB_VBOF_x_x.
+//! To be selected according to the AVR32_USBB_USB_VBOF_x_x_PIN and
+//! AVR32_USBB_USB_VBOF_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
+#ifdef EVK1100_REVA
+#  define USB_VBOF                    AVR32_USBB_USB_VBOF_0_0
+#else
+#  define USB_VBOF                    AVR32_USBB_USB_VBOF_0_1
+#endif
+
+//! Active level of the USB_VBOF output pin.
+#ifdef EVK1100_REVA
+#  define USB_VBOF_ACTIVE_LEVEL       HIGH
+#else
+#  define USB_VBOF_ACTIVE_LEVEL       LOW
+#endif
+
+//! USB overcurrent detection pin.
+#ifdef EVK1100_REVA
+#  define USB_OVERCURRENT_DETECT_PIN  AVR32_PIN_PB18
+#else
+#  define USB_OVERCURRENT_DETECT_PIN  AVR32_PIN_PX33
+#endif
+
+//! @}
+
+
+//! GPIO connection of the MAC PHY PWR_DOWN/INT signal.
+#ifdef EVK1100_REVA
+#  define MACB_INTERRUPT_PIN  AVR32_PIN_PX12
+#else
+#  define MACB_INTERRUPT_PIN  AVR32_PIN_PA24
+#endif
+
+
+//! Number of LEDs.
+#define LED_COUNT   8
+
+/*! \name GPIO Connections of LEDs
+ */
+//! @{
+#ifdef EVK1100_REVA
+#  define LED0_GPIO   AVR32_PIN_PX13
+#  define LED1_GPIO   AVR32_PIN_PX14
+#  define LED2_GPIO   AVR32_PIN_PX15
+#  define LED3_GPIO   AVR32_PIN_PX16
+#  define LED4_GPIO   AVR32_PIN_PB19
+#  define LED5_GPIO   AVR32_PIN_PB20
+#  define LED6_GPIO   AVR32_PIN_PB21
+#  define LED7_GPIO   AVR32_PIN_PB22
+#else
+#  define LED0_GPIO   AVR32_PIN_PB27
+#  define LED1_GPIO   AVR32_PIN_PB28
+#  define LED2_GPIO   AVR32_PIN_PB29
+#  define LED3_GPIO   AVR32_PIN_PB30
+#  define LED4_GPIO   AVR32_PIN_PB19
+#  define LED5_GPIO   AVR32_PIN_PB20
+#  define LED6_GPIO   AVR32_PIN_PB21
+#  define LED7_GPIO   AVR32_PIN_PB22
+#endif
+//! @}
+
+/*! \name PWM Channels of LEDs
+ */
+//! @{
+#define LED0_PWM    (-1)
+#define LED1_PWM    (-1)
+#define LED2_PWM    (-1)
+#define LED3_PWM    (-1)
+#define LED4_PWM      0
+#define LED5_PWM      1
+#define LED6_PWM      2
+#define LED7_PWM      3
+//! @}
+
+/*! \name PWM Functions of LEDs
+ */
+//! @{
+#define LED0_PWM_FUNCTION   (-1)
+#define LED1_PWM_FUNCTION   (-1)
+#define LED2_PWM_FUNCTION   (-1)
+#define LED3_PWM_FUNCTION   (-1)
+#define LED4_PWM_FUNCTION   AVR32_PWM_0_FUNCTION
+#define LED5_PWM_FUNCTION   AVR32_PWM_1_FUNCTION
+#define LED6_PWM_FUNCTION   AVR32_PWM_2_FUNCTION
+#define LED7_PWM_FUNCTION   AVR32_PWM_3_FUNCTION
+//! @}
+
+/*! \name Color Identifiers of LEDs to Use with LED Functions
+ */
+//! @{
+#ifdef EVK1100_REVA
+#  define LED_MONO0_GREEN   LED4
+#  define LED_MONO1_GREEN   LED5
+#  define LED_MONO2_GREEN   LED6
+#  define LED_MONO3_GREEN   LED7
+#  define LED_BI0_GREEN     LED1
+#  define LED_BI0_RED       LED0
+#  define LED_BI1_GREEN     LED3
+#  define LED_BI1_RED       LED2
+#else
+#  define LED_MONO0_GREEN   LED0
+#  define LED_MONO1_GREEN   LED1
+#  define LED_MONO2_GREEN   LED2
+#  define LED_MONO3_GREEN   LED3
+#  define LED_BI0_GREEN     LED5
+#  define LED_BI0_RED       LED4
+#  define LED_BI1_GREEN     LED7
+#  define LED_BI1_RED       LED6
+#endif
+//! @}
+
+
+/*! \name GPIO Connections of Push Buttons
+ */
+//! @{
+#ifdef EVK1100_REVA
+#  define GPIO_PUSH_BUTTON_0    AVR32_PIN_PB28
+#  define GPIO_PUSH_BUTTON_1    AVR32_PIN_PB29
+#  define GPIO_PUSH_BUTTON_2    AVR32_PIN_PB27
+#else
+#  define GPIO_PUSH_BUTTON_0    AVR32_PIN_PX16
+#  define GPIO_PUSH_BUTTON_1    AVR32_PIN_PX19
+#  define GPIO_PUSH_BUTTON_2    AVR32_PIN_PX22
+#endif
+//! @}
+
+
+/*! \name GPIO Connections of the Joystick
+ */
+//! @{
+#define GPIO_JOYSTICK_PUSH    AVR32_PIN_PA20
+#define GPIO_JOYSTICK_LEFT    AVR32_PIN_PA25
+#define GPIO_JOYSTICK_RIGHT   AVR32_PIN_PA28
+#define GPIO_JOYSTICK_UP      AVR32_PIN_PA26
+#define GPIO_JOYSTICK_DOWN    AVR32_PIN_PA27
+//! @}
+
+
+/*! \name ADC Connection of the Potentiometer
+ */
+//! @{
+#define ADC_POTENTIOMETER_CHANNEL   1
+#define ADC_POTENTIOMETER_PIN       AVR32_ADC_AD_1_PIN
+#define ADC_POTENTIOMETER_FUNCTION  AVR32_ADC_AD_1_FUNCTION
+//! @}
+
+
+/*! \name ADC Connection of the Temperature Sensor
+ */
+//! @{
+#define ADC_TEMPERATURE_CHANNEL     0
+#define ADC_TEMPERATURE_PIN         AVR32_ADC_AD_0_PIN
+#define ADC_TEMPERATURE_FUNCTION    AVR32_ADC_AD_0_FUNCTION
+//! @}
+
+
+/*! \name ADC Connection of the Light Sensor
+ */
+//! @{
+#define ADC_LIGHT_CHANNEL           2
+#define ADC_LIGHT_PIN               AVR32_ADC_AD_2_PIN
+#define ADC_LIGHT_FUNCTION          AVR32_ADC_AD_2_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the DIP204 LCD
+ */
+//! @{
+#define DIP204_SPI                  (&amp;AVR32_SPI1)
+#define DIP204_SPI_NPCS             2
+#define DIP204_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
+#define DIP204_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
+#define DIP204_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
+#define DIP204_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
+#define DIP204_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
+#define DIP204_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
+#define DIP204_SPI_NPCS_PIN         AVR32_SPI1_NPCS_2_0_PIN
+#define DIP204_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_2_0_FUNCTION
+//! @}
+
+/*! \name GPIO and PWM Connections of the DIP204 LCD Backlight
+ */
+//! @{
+#define DIP204_BACKLIGHT_PIN        AVR32_PIN_PB18
+#define DIP204_PWM_CHANNEL          6
+#define DIP204_PWM_PIN              AVR32_PWM_6_PIN
+#define DIP204_PWM_FUNCTION         AVR32_PWM_6_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the AT45DBX Data Flash Memory
+ */
+//! @{
+#define AT45DBX_SPI                 (&amp;AVR32_SPI1)
+#define AT45DBX_SPI_SCK_PIN         AVR32_SPI1_SCK_0_0_PIN
+#define AT45DBX_SPI_SCK_FUNCTION    AVR32_SPI1_SCK_0_0_FUNCTION
+#define AT45DBX_SPI_MISO_PIN        AVR32_SPI1_MISO_0_0_PIN
+#define AT45DBX_SPI_MISO_FUNCTION   AVR32_SPI1_MISO_0_0_FUNCTION
+#define AT45DBX_SPI_MOSI_PIN        AVR32_SPI1_MOSI_0_0_PIN
+#define AT45DBX_SPI_MOSI_FUNCTION   AVR32_SPI1_MOSI_0_0_FUNCTION
+#define AT45DBX_SPI_NPCS0_PIN       AVR32_SPI1_NPCS_0_0_PIN
+#define AT45DBX_SPI_NPCS0_FUNCTION  AVR32_SPI1_NPCS_0_0_FUNCTION
+//! @}
+
+
+/*! \name GPIO and SPI Connections of the SD/MMC Connector
+ */
+//! @{
+#define SD_MMC_CARD_DETECT_PIN      AVR32_PIN_PA02
+#define SD_MMC_WRITE_PROTECT_PIN    AVR32_PIN_PA07
+#define SD_MMC_SPI                  (&amp;AVR32_SPI1)
+#define SD_MMC_SPI_NPCS             1
+#define SD_MMC_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
+#define SD_MMC_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
+#define SD_MMC_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
+#define SD_MMC_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
+#define SD_MMC_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
+#define SD_MMC_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
+#define SD_MMC_SPI_NPCS_PIN         AVR32_SPI1_NPCS_1_0_PIN
+#define SD_MMC_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_1_0_FUNCTION
+//! @}
+
+
+/*! \name TWI Connections of the Spare TWI Connector
+ */
+//! @{
+#define SPARE_TWI                   (&amp;AVR32_TWI)
+#define SPARE_TWI_SCL_PIN           AVR32_TWI_SCL_0_0_PIN
+#define SPARE_TWI_SCL_FUNCTION      AVR32_TWI_SCL_0_0_FUNCTION
+#define SPARE_TWI_SDA_PIN           AVR32_TWI_SDA_0_0_PIN
+#define SPARE_TWI_SDA_FUNCTION      AVR32_TWI_SDA_0_0_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the Spare SPI Connector
+ */
+//! @{
+#define SPARE_SPI                   (&amp;AVR32_SPI0)
+#define SPARE_SPI_NPCS              0
+#define SPARE_SPI_SCK_PIN           AVR32_SPI0_SCK_0_0_PIN
+#define SPARE_SPI_SCK_FUNCTION      AVR32_SPI0_SCK_0_0_FUNCTION
+#define SPARE_SPI_MISO_PIN          AVR32_SPI0_MISO_0_0_PIN
+#define SPARE_SPI_MISO_FUNCTION     AVR32_SPI0_MISO_0_0_FUNCTION
+#define SPARE_SPI_MOSI_PIN          AVR32_SPI0_MOSI_0_0_PIN
+#define SPARE_SPI_MOSI_FUNCTION     AVR32_SPI0_MOSI_0_0_FUNCTION
+#define SPARE_SPI_NPCS_PIN          AVR32_SPI0_NPCS_0_0_PIN
+#define SPARE_SPI_NPCS_FUNCTION     AVR32_SPI0_NPCS_0_0_FUNCTION
+//! @}
+
+
+#endif  // _EVK1100_H_

Added: trunk/src/platform/avr32/exception.s
===================================================================
--- trunk/src/platform/avr32/exception.s	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/exception.s	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,242 @@
+/* This file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Exception and interrupt vectors.
+ *
+ * This file maps all events supported by an AVR32UC.
+ *
+ * - Compiler:           GNU GCC for AVR32
+ * - Supported devices:  All AVR32UC devices with an INTC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &lt;avr32/io.h&gt;
+
+
+//! @{
+//! \verbatim
+
+
+  .section  .exception, &quot;ax&quot;, @progbits
+
+
+// Start of Exception Vector Table.
+
+  // EVBA must be aligned with a power of two strictly greater than the EVBA-
+  // relative offset of the last vector.
+  .balign 0x200
+
+  // Export symbol.
+  .global _evba
+  .type _evba, @function
+_evba:
+
+        .org  0x000
+        // Unrecoverable Exception.
+_handle_Unrecoverable_Exception:
+        rjmp $
+
+        .org  0x004
+        // TLB Multiple Hit: UNUSED IN AVR32UC.
+_handle_TLB_Multiple_Hit:
+        rjmp $
+
+        .org  0x008
+        // Bus Error Data Fetch.
+_handle_Bus_Error_Data_Fetch:
+        rjmp $
+
+        .org  0x00C
+         // Bus Error Instruction Fetch.
+_handle_Bus_Error_Instruction_Fetch:
+        rjmp $
+
+        .org  0x010
+        // NMI.
+_handle_NMI:
+        rjmp $
+
+        .org  0x014
+        // Instruction Address.
+_handle_Instruction_Address:
+        rjmp $
+
+        .org  0x018
+        // ITLB Protection.
+_handle_ITLB_Protection:
+        rjmp $
+
+        .org  0x01C
+        // Breakpoint.
+_handle_Breakpoint:
+        rjmp $
+
+        .org  0x020
+        // Illegal Opcode.
+_handle_Illegal_Opcode:
+        rjmp $
+
+        .org  0x024
+        // Unimplemented Instruction.
+_handle_Unimplemented_Instruction:
+        rjmp $
+
+        .org  0x028
+        // Privilege Violation.
+_handle_Privilege_Violation:
+        rjmp $
+
+        .org  0x02C
+        // Floating-Point: UNUSED IN AVR32UC.
+_handle_Floating_Point:
+        rjmp $
+
+        .org  0x030
+        // Coprocessor Absent: UNUSED IN AVR32UC.
+_handle_Coprocessor_Absent:
+        rjmp $
+
+        .org  0x034
+        // Data Address (Read).
+_handle_Data_Address_Read:
+        rjmp $
+
+        .org  0x038
+        // Data Address (Write).
+_handle_Data_Address_Write:
+        rjmp $
+
+        .org  0x03C
+        // DTLB Protection (Read).
+_handle_DTLB_Protection_Read:
+        rjmp $
+
+        .org  0x040
+        // DTLB Protection (Write).
+_handle_DTLB_Protection_Write:
+        rjmp $
+
+        .org  0x044
+        // DTLB Modified: UNUSED IN AVR32UC.
+_handle_DTLB_Modified:
+        rjmp $
+
+        .org  0x050
+        // ITLB Miss: UNUSED IN AVR32UC.
+_handle_ITLB_Miss:
+        rjmp $
+
+        .org  0x060
+        // DTLB Miss (Read): UNUSED IN AVR32UC.
+_handle_DTLB_Miss_Read:
+        rjmp $
+
+        .org  0x070
+        // DTLB Miss (Write): UNUSED IN AVR32UC.
+_handle_DTLB_Miss_Write:
+        rjmp $
+
+        .org  0x100
+        // Supervisor Call.
+_handle_Supervisor_Call:
+        rjmp $
+
+
+// Interrupt support.
+// The interrupt controller must provide the offset address relative to EVBA.
+// Important note:
+//   All interrupts call a C function named _get_interrupt_handler.
+//   This function will read group and interrupt line number to then return in
+//   R12 a pointer to a user-provided interrupt handler.
+
+  .balign 4
+
+_int0:
+  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
+  // CPU upon interrupt entry.
+  mov     r12, 0  // Pass the int_lev parameter to the _get_interrupt_handler function.
+  call    _get_interrupt_handler
+  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
+  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
+  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
+
+_int1:
+  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
+  // CPU upon interrupt entry.
+  mov     r12, 1  // Pass the int_lev parameter to the _get_interrupt_handler function.
+  call    _get_interrupt_handler
+  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
+  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
+  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
+
+_int2:
+  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
+  // CPU upon interrupt entry.
+  mov     r12, 2  // Pass the int_lev parameter to the _get_interrupt_handler function.
+  call    _get_interrupt_handler
+  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
+  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
+  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
+
+_int3:
+  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
+  // CPU upon interrupt entry.
+  mov     r12, 3  // Pass the int_lev parameter to the _get_interrupt_handler function.
+  call    _get_interrupt_handler
+  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
+  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
+  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
+
+
+// Constant data area.
+
+  .balign 4
+
+  // Values to store in the interrupt priority registers for the various interrupt priority levels.
+  // The interrupt priority registers contain the interrupt priority level and
+  // the EVBA-relative interrupt vector offset.
+  .global ipr_val
+  .type ipr_val, @object
+ipr_val:
+  .word (AVR32_INTC_INT0 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int0 - _evba),\
+        (AVR32_INTC_INT1 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int1 - _evba),\
+        (AVR32_INTC_INT2 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int2 - _evba),\
+        (AVR32_INTC_INT3 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int3 - _evba)
+
+
+//! \endverbatim
+//! @}

Added: trunk/src/platform/avr32/flashc.c
===================================================================
--- trunk/src/platform/avr32/flashc.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/flashc.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,1057 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief FLASHC driver for AVR32 UC3.
+ *
+ * AVR32 Flash Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a FLASHC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &lt;avr32/io.h&gt;
+#include &lt;stddef.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;flashc.h&quot;
+
+
+/*! \name FLASHC Writable Bit-Field Registers
+ */
+//! @{
+
+typedef union
+{
+  unsigned long                 fcr;
+  avr32_flashc_fcr_t            FCR;
+} u_avr32_flashc_fcr_t;
+
+typedef union
+{
+  unsigned long                 fcmd;
+  avr32_flashc_fcmd_t           FCMD;
+} u_avr32_flashc_fcmd_t;
+
+//! @}
+
+
+/*! \name Flash Properties
+ */
+//! @{
+
+
+unsigned int flashc_get_flash_size(void)
+{
+  static const unsigned int FLASH_SIZE[1 &lt;&lt; AVR32_FLASHC_FSR_FSZ_SIZE] =
+  {
+      32 &lt;&lt; 10,
+      64 &lt;&lt; 10,
+     128 &lt;&lt; 10,
+     256 &lt;&lt; 10,
+     384 &lt;&lt; 10,
+     512 &lt;&lt; 10,
+     768 &lt;&lt; 10,
+    1024 &lt;&lt; 10
+  };
+  return FLASH_SIZE[(AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FSZ_MASK) &gt;&gt; AVR32_FLASHC_FSR_FSZ_OFFSET];
+}
+
+
+unsigned int flashc_get_page_count(void)
+{
+  return flashc_get_flash_size() / AVR32_FLASHC_PAGE_SIZE;
+}
+
+
+unsigned int flashc_get_page_count_per_region(void)
+{
+  return flashc_get_page_count() / AVR32_FLASHC_REGIONS;
+}
+
+
+unsigned int flashc_get_page_region(int page_number)
+{
+  return ((page_number &gt;= 0) ? page_number : flashc_get_page_number()) / flashc_get_page_count_per_region();
+}
+
+
+unsigned int flashc_get_region_first_page_number(unsigned int region)
+{
+  return region * flashc_get_page_count_per_region();
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Control
+ */
+//! @{
+
+
+unsigned int flashc_get_wait_state(void)
+{
+  return (AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FWS_MASK) &gt;&gt; AVR32_FLASHC_FCR_FWS_OFFSET;
+}
+
+
+void flashc_set_wait_state(unsigned int wait_state)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.fws = wait_state;
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+Bool flashc_is_ready_int_enabled(void)
+{
+  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FRDY_MASK) != 0);
+}
+
+
+void flashc_enable_ready_int(Bool enable)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.frdy = (enable != FALSE);
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+Bool flashc_is_lock_error_int_enabled(void)
+{
+  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_LOCKE_MASK) != 0);
+}
+
+
+void flashc_enable_lock_error_int(Bool enable)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.locke = (enable != FALSE);
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+Bool flashc_is_prog_error_int_enabled(void)
+{
+  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_PROGE_MASK) != 0);
+}
+
+
+void flashc_enable_prog_error_int(Bool enable)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.proge = (enable != FALSE);
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Status
+ */
+//! @{
+
+
+Bool flashc_is_ready(void)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FRDY_MASK) != 0);
+}
+
+
+void flashc_default_wait_until_ready(void)
+{
+  while (!flashc_is_ready());
+}
+
+
+void (*volatile flashc_wait_until_ready)(void) = flashc_default_wait_until_ready;
+
+
+/*! \brief Gets the error status of the FLASHC.
+ *
+ * \return The error status of the FLASHC built up from
+ *         \c AVR32_FLASHC_FSR_LOCKE_MASK and \c AVR32_FLASHC_FSR_PROGE_MASK.
+ *
+ * \warning This hardware error status is cleared by all functions reading the
+ *          Flash Status Register (FSR). This function is therefore not part of
+ *          the driver's API which instead presents \ref flashc_is_lock_error
+ *          and \ref flashc_is_programming_error.
+ */
+static unsigned int flashc_get_error_status(void)
+{
+  return AVR32_FLASHC.fsr &amp; (AVR32_FLASHC_FSR_LOCKE_MASK |
+                             AVR32_FLASHC_FSR_PROGE_MASK);
+}
+
+
+//! Sticky error status of the FLASHC.
+//! This variable is updated by functions that issue FLASHC commands. It
+//! contains the cumulated FLASHC error status of all the FLASHC commands issued
+//! by a function.
+static unsigned int flashc_error_status = 0;
+
+
+Bool flashc_is_lock_error(void)
+{
+  return ((flashc_error_status &amp; AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
+}
+
+
+Bool flashc_is_programming_error(void)
+{
+  return ((flashc_error_status &amp; AVR32_FLASHC_FSR_PROGE_MASK) != 0);
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Command Control
+ */
+//! @{
+
+
+unsigned int flashc_get_command(void)
+{
+  return (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_CMD_MASK) &gt;&gt; AVR32_FLASHC_FCMD_CMD_OFFSET;
+}
+
+
+unsigned int flashc_get_page_number(void)
+{
+  return (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_PAGEN_MASK) &gt;&gt; AVR32_FLASHC_FCMD_PAGEN_OFFSET;
+}
+
+
+void flashc_issue_command(unsigned int command, int page_number)
+{
+  u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;
+  flashc_wait_until_ready();
+  u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
+  u_avr32_flashc_fcmd.FCMD.cmd = command;
+  if (page_number &gt;= 0) u_avr32_flashc_fcmd.FCMD.pagen = page_number;
+  u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
+  AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
+  flashc_error_status = flashc_get_error_status();
+  flashc_wait_until_ready();
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Global Commands
+ */
+//! @{
+
+
+void flashc_no_operation(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_NOP, -1);
+}
+
+
+void flashc_erase_all(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EA, -1);
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Protection Mechanisms
+ */
+//! @{
+
+
+Bool flashc_is_security_bit_active(void)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_SECURITY_MASK) != 0);
+}
+
+
+void flashc_activate_security_bit(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_SSB, -1);
+}
+
+
+unsigned int flashc_get_bootloader_protected_size(void)
+{
+  unsigned int bootprot = (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
+                          flashc_read_gp_fuse_bitfield(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
+                                                       AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE);
+  return (bootprot) ? AVR32_FLASHC_PAGE_SIZE &lt;&lt; bootprot : 0;
+}
+
+
+unsigned int flashc_set_bootloader_protected_size(unsigned int bootprot_size)
+{
+  flashc_set_gp_fuse_bitfield(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
+                              AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE,
+                              (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
+                              ((bootprot_size) ?
+                               32 - clz((((min(max(bootprot_size, AVR32_FLASHC_PAGE_SIZE &lt;&lt; 1),
+                                               AVR32_FLASHC_PAGE_SIZE &lt;&lt;
+                                               ((1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1)) +
+                                           AVR32_FLASHC_PAGE_SIZE - 1) /
+                                          AVR32_FLASHC_PAGE_SIZE) &lt;&lt; 1) - 1) - 1 :
+                               0));
+  return flashc_get_bootloader_protected_size();
+}
+
+
+Bool flashc_is_external_privileged_fetch_locked(void)
+{
+  return (!flashc_read_gp_fuse_bit(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET));
+}
+
+
+void flashc_lock_external_privileged_fetch(Bool lock)
+{
+  flashc_set_gp_fuse_bit(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET, !lock);
+}
+
+
+Bool flashc_is_page_region_locked(int page_number)
+{
+  return flashc_is_region_locked(flashc_get_page_region(page_number));
+}
+
+
+Bool flashc_is_region_locked(unsigned int region)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_LOCK0_MASK &lt;&lt; (region &amp; (AVR32_FLASHC_REGIONS - 1))) != 0);
+}
+
+
+void flashc_lock_page_region(int page_number, Bool lock)
+{
+  flashc_issue_command((lock) ? AVR32_FLASHC_FCMD_CMD_LP : AVR32_FLASHC_FCMD_CMD_UP, page_number);
+}
+
+
+void flashc_lock_region(unsigned int region, Bool lock)
+{
+  flashc_lock_page_region(flashc_get_region_first_page_number(region), lock);
+}
+
+
+void flashc_lock_all_regions(Bool lock)
+{
+  unsigned int error_status = 0;
+  unsigned int region = AVR32_FLASHC_REGIONS;
+  while (region)
+  {
+    flashc_lock_region(--region, lock);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+//! @}
+
+
+/*! \name Access to General-Purpose Fuses
+ */
+//! @{
+
+
+Bool flashc_read_gp_fuse_bit(unsigned int gp_fuse_bit)
+{
+  return ((flashc_read_all_gp_fuses() &amp; 1ULL &lt;&lt; (gp_fuse_bit &amp; 0x3F)) != 0);
+}
+
+
+U64 flashc_read_gp_fuse_bitfield(unsigned int pos, unsigned int width)
+{
+  return flashc_read_all_gp_fuses() &gt;&gt; (pos &amp; 0x3F) &amp; ((1ULL &lt;&lt; min(width, 64)) - 1);
+}
+
+
+U8 flashc_read_gp_fuse_byte(unsigned int gp_fuse_byte)
+{
+  return flashc_read_all_gp_fuses() &gt;&gt; ((gp_fuse_byte &amp; 0x07) &lt;&lt; 3);
+}
+
+
+U64 flashc_read_all_gp_fuses(void)
+{
+  return AVR32_FLASHC.fgpfrlo | (U64)AVR32_FLASHC.fgpfrhi &lt;&lt; 32;
+}
+
+
+Bool flashc_erase_gp_fuse_bit(unsigned int gp_fuse_bit, Bool check)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EGPB, gp_fuse_bit &amp; 0x3F);
+  return (check) ? flashc_read_gp_fuse_bit(gp_fuse_bit) : TRUE;
+}
+
+
+Bool flashc_erase_gp_fuse_bitfield(unsigned int pos, unsigned int width, Bool check)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_bit;
+  pos &amp;= 0x3F;
+  width = min(width, 64);
+  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++)
+  {
+    flashc_erase_gp_fuse_bit(gp_fuse_bit, FALSE);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+  return (check) ? (flashc_read_gp_fuse_bitfield(pos, width) == (1ULL &lt;&lt; width) - 1) : TRUE;
+}
+
+
+Bool flashc_erase_gp_fuse_byte(unsigned int gp_fuse_byte, Bool check)
+{
+  unsigned int error_status;
+  unsigned int current_gp_fuse_byte;
+  U64 value = flashc_read_all_gp_fuses();
+  flashc_erase_all_gp_fuses(FALSE);
+  error_status = flashc_error_status;
+  for (current_gp_fuse_byte = 0; current_gp_fuse_byte &lt; 8; current_gp_fuse_byte++, value &gt;&gt;= 8)
+  {
+    if (current_gp_fuse_byte != gp_fuse_byte)
+    {
+      flashc_write_gp_fuse_byte(current_gp_fuse_byte, value);
+      error_status |= flashc_error_status;
+    }
+  }
+  flashc_error_status = error_status;
+  return (check) ? (flashc_read_gp_fuse_byte(gp_fuse_byte) == 0xFF) : TRUE;
+}
+
+
+Bool flashc_erase_all_gp_fuses(Bool check)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EAGPF, -1);
+  return (check) ? (flashc_read_all_gp_fuses() == 0xFFFFFFFFFFFFFFFFULL) : TRUE;
+}
+
+
+void flashc_write_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value)
+{
+  if (!value)
+    flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WGPB, gp_fuse_bit &amp; 0x3F);
+}
+
+
+void flashc_write_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_bit;
+  pos &amp;= 0x3F;
+  width = min(width, 64);
+  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
+  {
+    flashc_write_gp_fuse_bit(gp_fuse_bit, value &amp; 0x01);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+void flashc_write_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_PGPFB, (gp_fuse_byte &amp; 0x07) | value &lt;&lt; 3);
+}
+
+
+void flashc_write_all_gp_fuses(U64 value)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_byte;
+  for (gp_fuse_byte = 0; gp_fuse_byte &lt; 8; gp_fuse_byte++, value &gt;&gt;= 8)
+  {
+    flashc_write_gp_fuse_byte(gp_fuse_byte, value);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+void flashc_set_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value)
+{
+  if (value)
+    flashc_erase_gp_fuse_bit(gp_fuse_bit, FALSE);
+  else
+    flashc_write_gp_fuse_bit(gp_fuse_bit, FALSE);
+}
+
+
+void flashc_set_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_bit;
+  pos &amp;= 0x3F;
+  width = min(width, 64);
+  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
+  {
+    flashc_set_gp_fuse_bit(gp_fuse_bit, value &amp; 0x01);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+void flashc_set_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value)
+{
+  unsigned int error_status;
+  switch (value)
+  {
+  case 0xFF:
+    flashc_erase_gp_fuse_byte(gp_fuse_byte, FALSE);
+    break;
+  case 0x00:
+    flashc_write_gp_fuse_byte(gp_fuse_byte, 0x00);
+    break;
+  default:
+    flashc_erase_gp_fuse_byte(gp_fuse_byte, FALSE);
+    error_status = flashc_error_status;
+    flashc_write_gp_fuse_byte(gp_fuse_byte, value);
+    flashc_error_status |= error_status;
+  }
+}
+
+
+void flashc_set_all_gp_fuses(U64 value)
+{
+  unsigned int error_status;
+  switch (value)
+  {
+  case 0xFFFFFFFFFFFFFFFFULL:
+    flashc_erase_all_gp_fuses(FALSE);
+    break;
+  case 0x0000000000000000ULL:
+    flashc_write_all_gp_fuses(0x0000000000000000ULL);
+    break;
+  default:
+    flashc_erase_all_gp_fuses(FALSE);
+    error_status = flashc_error_status;
+    flashc_write_all_gp_fuses(value);
+    flashc_error_status |= error_status;
+  }
+}
+
+
+//! @}
+
+
+/*! \name Access to Flash Pages
+ */
+//! @{
+
+
+void flashc_clear_page_buffer(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
+}
+
+
+Bool flashc_is_page_erased(void)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_QPRR_MASK) != 0);
+}
+
+
+Bool flashc_quick_page_read(int page_number)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
+  return flashc_is_page_erased();
+}
+
+
+Bool flashc_erase_page(int page_number, Bool check)
+{
+  Bool page_erased = TRUE;
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
+  if (check)
+  {
+    unsigned int error_status = flashc_error_status;
+    page_erased = flashc_quick_page_read(-1);
+    flashc_error_status |= error_status;
+  }
+  return page_erased;
+}
+
+
+Bool flashc_erase_all_pages(Bool check)
+{
+  Bool all_pages_erased = TRUE;
+  unsigned int error_status = 0;
+  unsigned int page_number = flashc_get_page_count();
+  while (page_number)
+  {
+    all_pages_erased &amp;= flashc_erase_page(--page_number, check);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+  return all_pages_erased;
+}
+
+
+void flashc_write_page(int page_number)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
+}
+
+
+Bool flashc_quick_user_page_read(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
+  return flashc_is_page_erased();
+}
+
+
+Bool flashc_erase_user_page(Bool check)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
+  return (check) ? flashc_quick_user_page_read() : TRUE;
+}
+
+
+void flashc_write_user_page(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
+}
+
+
+volatile void *flashc_memset8(volatile void *dst, U8 src, size_t nbytes, Bool erase)
+{
+  return flashc_memset16(dst, src | (U16)src &lt;&lt; 8, nbytes, erase);
+}
+
+
+volatile void *flashc_memset16(volatile void *dst, U16 src, size_t nbytes, Bool erase)
+{
+  return flashc_memset32(dst, src | (U32)src &lt;&lt; 16, nbytes, erase);
+}
+
+
+volatile void *flashc_memset32(volatile void *dst, U32 src, size_t nbytes, Bool erase)
+{
+  return flashc_memset64(dst, src | (U64)src &lt;&lt; 32, nbytes, erase);
+}
+
+
+volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase)
+{
+  // Use aggregated pointers to have several alignments available for a same address.
+  UnionCVPtr flash_array_end;
+  UnionVPtr dest;
+  Union64 source = {0};
+  StructCVPtr dest_end;
+  UnionCVPtr flash_page_source_end;
+  Bool incomplete_flash_page_end;
+  Union64 flash_dword;
+  UnionVPtr tmp;
+  unsigned int error_status = 0;
+  unsigned int i;
+
+  // Reformat arguments.
+  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
+  dest.u8ptr = dst;
+  for (i = (Get_align((U32)dest.u8ptr, sizeof(U64)) - 1) &amp; (sizeof(U64) - 1);
+       src; i = (i - 1) &amp; (sizeof(U64) - 1))
+  {
+    source.u8[i] = src;
+    src &gt;&gt;= 8;
+  }
+  dest_end.u8ptr = dest.u8ptr + nbytes;
+
+  // If destination is outside flash, go to next flash page if any.
+  if (dest.u8ptr &lt; AVR32_FLASH)
+  {
+    dest.u8ptr = AVR32_FLASH;
+  }
+  else if (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
+  {
+    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+  }
+
+  // If end of destination is outside flash, move it to the end of the previous flash page if any.
+  if (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
+  {
+    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
+  }
+  else if (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
+  {
+    dest_end.u8ptr = flash_array_end.u8ptr;
+  }
+
+  // Align each end of destination pointer with its natural boundary.
+  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
+  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
+  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
+
+  // While end of destination is not reached...
+  while (dest.u8ptr &lt; dest_end.u8ptr)
+  {
+    // Clear the page buffer in order to prepare data for a flash page write.
+    flashc_clear_page_buffer();
+    error_status |= flashc_error_status;
+
+    // Determine where the source data will end in the current flash page.
+    flash_page_source_end.u64ptr =
+      (U64 *)min((U32)dest_end.u64ptr,
+                 Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
+
+    // Determine if the current destination page has an incomplete end.
+    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
+                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
+
+    // Use a flash double-word buffer to manage unaligned accesses.
+    flash_dword.u64 = source.u64;
+
+    // If destination does not point to the beginning of the current flash page...
+    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
+    {
+      // Fill the beginning of the page buffer with the current flash page data.
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
+           tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+           tmp.u64ptr++)
+        *tmp.u64ptr = *tmp.u64ptr;
+
+      // If destination is not 64-bit aligned...
+      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
+      {
+        // Fill the beginning of the flash double-word buffer with the current
+        // flash page data.
+        // This is required by the hardware, even if page erase is not
+        // requested, in order to be able to write successfully to erased parts
+        // of flash pages that have already been written to.
+        for (i = 0; i &lt; Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
+          flash_dword.u8[i] = *tmp.u8ptr++;
+
+        // Align the destination pointer with its 64-bit boundary.
+        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+
+        // If the current destination double-word is not the last one...
+        if (dest.u64ptr &lt; dest_end.u64ptr)
+        {
+          // Write the flash double-word buffer to the page buffer and reinitialize it.
+          *dest.u64ptr++ = flash_dword.u64;
+          flash_dword.u64 = source.u64;
+        }
+      }
+    }
+
+    // Write the source data to the page buffer with 64-bit alignment.
+    for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+      *dest.u64ptr++ = source.u64;
+
+    // If the current destination page has an incomplete end...
+    if (incomplete_flash_page_end)
+    {
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      {
+        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
+
+        // If end of destination is not 64-bit aligned...
+        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
+        {
+          // Fill the end of the flash double-word buffer with the current flash page data.
+          for (i = Get_align((U32)dest_end.u8ptr, sizeof(U64)); i &lt; sizeof(U64); i++)
+            flash_dword.u8[i] = *tmp.u8ptr++;
+
+          // Write the flash double-word buffer to the page buffer.
+          *dest.u64ptr++ = flash_dword.u64;
+        }
+
+        // Fill the end of the page buffer with the current flash page data.
+        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
+          *tmp.u64ptr = *tmp.u64ptr;
+      }
+    }
+
+    // If the current flash page is in the flash array...
+    if (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
+    {
+      // Erase the current page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_page(-1, FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_page(-1);
+      error_status |= flashc_error_status;
+
+      // If the end of the flash array is reached, go to the User page.
+      if (dest.u8ptr &gt;= flash_array_end.u8ptr)
+        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+    }
+    // If the current flash page is the User page...
+    else
+    {
+      // Erase the User page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_user_page(FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_user_page();
+      error_status |= flashc_error_status;
+    }
+  }
+
+  // Update the FLASHC error status.
+  flashc_error_status = error_status;
+
+  // Return the initial destination pointer as the standard memset function does.
+  return dst;
+}
+
+
+volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase)
+{
+  // Use aggregated pointers to have several alignments available for a same address.
+  UnionCVPtr flash_array_end;
+  UnionVPtr dest;
+  UnionCPtr source;
+  StructCVPtr dest_end;
+  UnionCVPtr flash_page_source_end;
+  Bool incomplete_flash_page_end;
+  Union64 flash_dword;
+  Bool flash_dword_pending = FALSE;
+  UnionVPtr tmp;
+  unsigned int error_status = 0;
+  unsigned int i, j;
+
+  // Reformat arguments.
+  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
+  dest.u8ptr = dst;
+  source.u8ptr = src;
+  dest_end.u8ptr = dest.u8ptr + nbytes;
+
+  // If destination is outside flash, go to next flash page if any.
+  if (dest.u8ptr &lt; AVR32_FLASH)
+  {
+    source.u8ptr += AVR32_FLASH - dest.u8ptr;
+    dest.u8ptr = AVR32_FLASH;
+  }
+  else if (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
+  {
+    source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
+    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+  }
+
+  // If end of destination is outside flash, move it to the end of the previous flash page if any.
+  if (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
+  {
+    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
+  }
+  else if (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
+  {
+    dest_end.u8ptr = flash_array_end.u8ptr;
+  }
+
+  // Align each end of destination pointer with its natural boundary.
+  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
+  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
+  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
+
+  // While end of destination is not reached...
+  while (dest.u8ptr &lt; dest_end.u8ptr)
+  {
+    // Clear the page buffer in order to prepare data for a flash page write.
+    flashc_clear_page_buffer();
+    error_status |= flashc_error_status;
+
+    // Determine where the source data will end in the current flash page.
+    flash_page_source_end.u64ptr =
+      (U64 *)min((U32)dest_end.u64ptr,
+                 Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
+
+    // Determine if the current destination page has an incomplete end.
+    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
+                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
+
+    // If destination does not point to the beginning of the current flash page...
+    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
+    {
+      // Fill the beginning of the page buffer with the current flash page data.
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
+           tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+           tmp.u64ptr++)
+        *tmp.u64ptr = *tmp.u64ptr;
+
+      // If destination is not 64-bit aligned...
+      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
+      {
+        // Fill the beginning of the flash double-word buffer with the current
+        // flash page data.
+        // This is required by the hardware, even if page erase is not
+        // requested, in order to be able to write successfully to erased parts
+        // of flash pages that have already been written to.
+        for (i = 0; i &lt; Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
+          flash_dword.u8[i] = *tmp.u8ptr++;
+
+        // Fill the end of the flash double-word buffer with the source data.
+        for (; i &lt; sizeof(U64); i++)
+          flash_dword.u8[i] = *source.u8ptr++;
+
+        // Align the destination pointer with its 64-bit boundary.
+        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+
+        // If the current destination double-word is not the last one...
+        if (dest.u64ptr &lt; dest_end.u64ptr)
+        {
+          // Write the flash double-word buffer to the page buffer.
+          *dest.u64ptr++ = flash_dword.u64;
+        }
+        // If the current destination double-word is the last one, the flash
+        // double-word buffer must be kept for later.
+        else flash_dword_pending = TRUE;
+      }
+    }
+
+    // Read the source data with the maximal possible alignment and write it to
+    // the page buffer with 64-bit alignment.
+    switch (Get_align((U32)source.u8ptr, sizeof(U32)))
+    {
+    case 0:
+      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+        *dest.u64ptr++ = *source.u64ptr++;
+      break;
+
+    case sizeof(U16):
+      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+      {
+        for (j = 0; j &lt; sizeof(U64) / sizeof(U16); j++) flash_dword.u16[j] = *source.u16ptr++;
+        *dest.u64ptr++ = flash_dword.u64;
+      }
+      break;
+
+    default:
+      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+      {
+        for (j = 0; j &lt; sizeof(U64); j++) flash_dword.u8[j] = *source.u8ptr++;
+        *dest.u64ptr++ = flash_dword.u64;
+      }
+    }
+
+    // If the current destination page has an incomplete end...
+    if (incomplete_flash_page_end)
+    {
+      // If the flash double-word buffer is in use, do not initialize it.
+      if (flash_dword_pending) i = Get_align((U32)dest_end.u8ptr, sizeof(U64));
+      // If the flash double-word buffer is free...
+      else
+      {
+        // Fill the beginning of the flash double-word buffer with the source data.
+        for (i = 0; i &lt; Get_align((U32)dest_end.u8ptr, sizeof(U64)); i++)
+          flash_dword.u8[i] = *source.u8ptr++;
+      }
+
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      {
+        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
+
+        // If end of destination is not 64-bit aligned...
+        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
+        {
+          // Fill the end of the flash double-word buffer with the current flash page data.
+          for (; i &lt; sizeof(U64); i++)
+            flash_dword.u8[i] = *tmp.u8ptr++;
+
+          // Write the flash double-word buffer to the page buffer.
+          *dest.u64ptr++ = flash_dword.u64;
+        }
+
+        // Fill the end of the page buffer with the current flash page data.
+        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
+          *tmp.u64ptr = *tmp.u64ptr;
+      }
+    }
+
+    // If the current flash page is in the flash array...
+    if (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
+    {
+      // Erase the current page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_page(-1, FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_page(-1);
+      error_status |= flashc_error_status;
+
+      // If the end of the flash array is reached, go to the User page.
+      if (dest.u8ptr &gt;= flash_array_end.u8ptr)
+      {
+        source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
+        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+      }
+    }
+    // If the current flash page is the User page...
+    else
+    {
+      // Erase the User page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_user_page(FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_user_page();
+      error_status |= flashc_error_status;
+    }
+  }
+
+  // Update the FLASHC error status.
+  flashc_error_status = error_status;
+
+  // Return the initial destination pointer as the standard memcpy function does.
+  return dst;
+}
+
+
+//! @}

Added: trunk/src/platform/avr32/flashc.h
===================================================================
--- trunk/src/platform/avr32/flashc.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/flashc.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,990 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief FLASHC driver for AVR32 UC3.
+ *
+ * AVR32 Flash Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a FLASHC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _FLASHC_H_
+#define _FLASHC_H_
+
+#include &lt;avr32/io.h&gt;
+#include &lt;stddef.h&gt;
+#include &quot;compiler.h&quot;
+
+
+//! Number of flash regions defined by the FLASHC.
+#define AVR32_FLASHC_REGIONS  (AVR32_FLASHC_FLASH_SIZE /\
+                               (AVR32_FLASHC_PAGES_PR_REGION * AVR32_FLASHC_PAGE_SIZE))
+
+
+/*! \name Flash Properties
+ */
+//! @{
+
+/*! \brief Gets the size of the whole flash array.
+ *
+ * \return The size of the whole flash array in bytes.
+ */
+extern unsigned int flashc_get_flash_size(void);
+
+/*! \brief Gets the total number of pages in the flash array.
+ *
+ * \return The total number of pages in the flash array.
+ */
+extern unsigned int flashc_get_page_count(void);
+
+/*! \brief Gets the number of pages in each flash region.
+ *
+ * \return The number of pages in each flash region.
+ */
+extern unsigned int flashc_get_page_count_per_region(void);
+
+/*! \brief Gets the region number of a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \return The region number of the specified page.
+ */
+extern unsigned int flashc_get_page_region(int page_number);
+
+/*! \brief Gets the number of the first page of a region.
+ *
+ * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
+ *
+ * \return The number of the first page of the specified region.
+ */
+extern unsigned int flashc_get_region_first_page_number(unsigned int region);
+
+//! @}
+
+
+/*! \name FLASHC Control
+ */
+//! @{
+
+/*! \brief Gets the number of wait states of flash read accesses.
+ *
+ * \return The number of wait states of flash read accesses.
+ */
+extern unsigned int flashc_get_wait_state(void);
+
+/*! \brief Sets the number of wait states of flash read accesses.
+ *
+ * \param wait_state The number of wait states of flash read accesses: \c 0 to
+ *                   \c 1.
+ */
+extern void flashc_set_wait_state(unsigned int wait_state);
+
+/*! \brief Tells whether the Flash Ready interrupt is enabled.
+ *
+ * \return Whether the Flash Ready interrupt is enabled.
+ */
+extern Bool flashc_is_ready_int_enabled(void);
+
+/*! \brief Enables or disables the Flash Ready interrupt.
+ *
+ * \param enable Whether to enable the Flash Ready interrupt: \c TRUE or
+ *               \c FALSE.
+ */
+extern void flashc_enable_ready_int(Bool enable);
+
+/*! \brief Tells whether the Lock Error interrupt is enabled.
+ *
+ * \return Whether the Lock Error interrupt is enabled.
+ */
+extern Bool flashc_is_lock_error_int_enabled(void);
+
+/*! \brief Enables or disables the Lock Error interrupt.
+ *
+ * \param enable Whether to enable the Lock Error interrupt: \c TRUE or
+ *               \c FALSE.
+ */
+extern void flashc_enable_lock_error_int(Bool enable);
+
+/*! \brief Tells whether the Programming Error interrupt is enabled.
+ *
+ * \return Whether the Programming Error interrupt is enabled.
+ */
+extern Bool flashc_is_prog_error_int_enabled(void);
+
+/*! \brief Enables or disables the Programming Error interrupt.
+ *
+ * \param enable Whether to enable the Programming Error interrupt: \c TRUE or
+ *               \c FALSE.
+ */
+extern void flashc_enable_prog_error_int(Bool enable);
+
+//! @}
+
+
+/*! \name FLASHC Status
+ */
+//! @{
+
+/*! \brief Tells whether the FLASHC is ready to run a new command.
+ *
+ * \return Whether the FLASHC is ready to run a new command.
+ */
+extern Bool flashc_is_ready(void);
+
+/*! \brief Waits actively until the FLASHC is ready to run a new command.
+ *
+ * This is the default function assigned to \ref flashc_wait_until_ready.
+ */
+extern void flashc_default_wait_until_ready(void);
+
+//! Pointer to the function used by the driver when it needs to wait until the
+//! FLASHC is ready to run a new command.
+//! The default function is \ref flashc_default_wait_until_ready.
+//! The user may change this pointer to use another implementation.
+extern void (*volatile flashc_wait_until_ready)(void);
+
+/*! \brief Tells whether a Lock Error has occurred during the last function
+ *         called that issued one or more FLASHC commands.
+ *
+ * \return Whether a Lock Error has occurred during the last function called
+ *         that issued one or more FLASHC commands.
+ */
+extern Bool flashc_is_lock_error(void);
+
+/*! \brief Tells whether a Programming Error has occurred during the last
+ *         function called that issued one or more FLASHC commands.
+ *
+ * \return Whether a Programming Error has occurred during the last function
+ *         called that issued one or more FLASHC commands.
+ */
+extern Bool flashc_is_programming_error(void);
+
+//! @}
+
+
+/*! \name FLASHC Command Control
+ */
+//! @{
+
+/*! \brief Gets the last issued FLASHC command.
+ *
+ * \return The last issued FLASHC command.
+ */
+extern unsigned int flashc_get_command(void);
+
+/*! \brief Gets the current FLASHC page number.
+ *
+ * \return The current FLASHC page number.
+ */
+extern unsigned int flashc_get_page_number(void);
+
+/*! \brief Issues a FLASHC command.
+ *
+ * \param command The command: \c AVR32_FLASHC_FCMD_CMD_x.
+ * \param page_number The page number to apply the command to:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: use this to apply the command to the current page number
+ *        or if the command does not apply to any page number;
+ *   \arg this argument may have other meanings according to the command. See
+ *        the FLASHC chapter of the MCU datasheet.
+ *
+ * \warning A Lock Error is issued if the command violates the protection
+ *          mechanism.
+ *
+ * \warning A Programming Error is issued if the command is invalid.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_issue_command(unsigned int command, int page_number);
+
+//! @}
+
+
+/*! \name FLASHC Global Commands
+ */
+//! @{
+
+/*! \brief Issues a No Operation command to the FLASHC.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_no_operation(void);
+
+/*! \brief Issues an Erase All command to the FLASHC.
+ *
+ * This command erases all bits in the flash array, the general-purpose fuse
+ * bits and the Security bit. The User page is not erased.
+ *
+ * This command also ensures that all volatile memories, such as register file
+ * and RAMs, are erased before the Security bit is erased, i.e. deactivated.
+ *
+ * \warning A Lock Error is issued if at least one region is locked or the
+ *          bootloader protection is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern void flashc_erase_all(void);
+
+//! @}
+
+
+/*! \name FLASHC Protection Mechanisms
+ */
+//! @{
+
+/*! \brief Tells whether the Security bit is active.
+ *
+ * \return Whether the Security bit is active.
+ */
+extern Bool flashc_is_security_bit_active(void);
+
+/*! \brief Activates the Security bit.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_activate_security_bit(void);
+
+/*! \brief Gets the bootloader protected size.
+ *
+ * \return The bootloader protected size in bytes.
+ */
+extern unsigned int flashc_get_bootloader_protected_size(void);
+
+/*! \brief Sets the bootloader protected size.
+ *
+ * \param bootprot_size The wanted bootloader protected size in bytes. If this
+ *                      size is not supported, the actual size will be the
+ *                      nearest greater available size or the maximal possible
+ *                      size if the requested size is too large.
+ *
+ * \return The actual bootloader protected size in bytes.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern unsigned int flashc_set_bootloader_protected_size(unsigned int bootprot_size);
+
+/*! \brief Tells whether external privileged fetch is locked.
+ *
+ * \return Whether external privileged fetch is locked.
+ */
+extern Bool flashc_is_external_privileged_fetch_locked(void);
+
+/*! \brief Locks or unlocks external privileged fetch.
+ *
+ * \param lock Whether to lock external privileged fetch: \c TRUE or \c FALSE.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_external_privileged_fetch(Bool lock);
+
+/*! \brief Tells whether the region of a page is locked.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \return Whether the region of the specified page is locked.
+ */
+extern Bool flashc_is_page_region_locked(int page_number);
+
+/*! \brief Tells whether a region is locked.
+ *
+ * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
+ *
+ * \return Whether the specified region is locked.
+ */
+extern Bool flashc_is_region_locked(unsigned int region);
+
+/*! \brief Locks or unlocks the region of a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ * \param lock Whether to lock the region of the specified page: \c TRUE or
+ *             \c FALSE.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_page_region(int page_number, Bool lock);
+
+/*! \brief Locks or unlocks a region.
+ *
+ * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
+ * \param lock Whether to lock the specified region: \c TRUE or \c FALSE.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_region(unsigned int region, Bool lock);
+
+/*! \brief Locks or unlocks all regions.
+ *
+ * \param lock Whether to lock the regions: \c TRUE or \c FALSE.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_all_regions(Bool lock);
+
+//! @}
+
+
+/*! \name Access to General-Purpose Fuses
+ */
+//! @{
+
+/*! \brief Reads a general-purpose fuse bit.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ *
+ * \return The value of the specified general-purpose fuse bit.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_read_gp_fuse_bit(unsigned int gp_fuse_bit);
+
+/*! \brief Reads a general-purpose fuse bit-field.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ *
+ * \return The value of the specified general-purpose fuse bit-field.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern U64 flashc_read_gp_fuse_bitfield(unsigned int pos, unsigned int width);
+
+/*! \brief Reads a general-purpose fuse byte.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ *
+ * \return The value of the specified general-purpose fuse byte.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern U8 flashc_read_gp_fuse_byte(unsigned int gp_fuse_byte);
+
+/*! \brief Reads all general-purpose fuses.
+ *
+ * \return The value of all general-purpose fuses as a word.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern U64 flashc_read_all_gp_fuses(void);
+
+/*! \brief Erases a general-purpose fuse bit.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_gp_fuse_bit(unsigned int gp_fuse_bit, Bool check);
+
+/*! \brief Erases a general-purpose fuse bit-field.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_gp_fuse_bitfield(unsigned int pos, unsigned int width, Bool check);
+
+/*! \brief Erases a general-purpose fuse byte.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_gp_fuse_byte(unsigned int gp_fuse_byte, Bool check);
+
+/*! \brief Erases all general-purpose fuses.
+ *
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_all_gp_fuses(Bool check);
+
+/*! \brief Writes a general-purpose fuse bit.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ * \param value The value of the specified general-purpose fuse bit.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value);
+
+/*! \brief Writes a general-purpose fuse bit-field.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ * \param value The value of the specified general-purpose fuse bit-field.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value);
+
+/*! \brief Writes a general-purpose fuse byte.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ * \param value The value of the specified general-purpose fuse byte.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value);
+
+/*! \brief Writes all general-purpose fuses.
+ *
+ * \param value The value of all general-purpose fuses as a word.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_all_gp_fuses(U64 value);
+
+/*! \brief Sets a general-purpose fuse bit with the appropriate erase and write
+ *         operations.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ * \param value The value of the specified general-purpose fuse bit.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value);
+
+/*! \brief Sets a general-purpose fuse bit-field with the appropriate erase and
+ *         write operations.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ * \param value The value of the specified general-purpose fuse bit-field.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value);
+
+/*! \brief Sets a general-purpose fuse byte with the appropriate erase and write
+ *         operations.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ * \param value The value of the specified general-purpose fuse byte.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value);
+
+/*! \brief Sets all general-purpose fuses with the appropriate erase and write
+ *         operations.
+ *
+ * \param value The value of all general-purpose fuses as a word.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_all_gp_fuses(U64 value);
+
+//! @}
+
+
+/*! \name Access to Flash Pages
+ */
+//! @{
+
+/*! \brief Clears the page buffer.
+ *
+ * This command resets all bits in the page buffer to one. Write accesses to the
+ * page buffer can only change page buffer bits from one to zero.
+ *
+ * \warning The page buffer is not automatically reset after a page write.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_clear_page_buffer(void);
+
+/*! \brief Tells whether the page to which the last Quick Page Read or Quick
+ *         Page Read User Page command was applied was erased.
+ *
+ * \return Whether the page to which the last Quick Page Read or Quick Page Read
+ *         User Page command was applied was erased.
+ */
+extern Bool flashc_is_page_erased(void);
+
+/*! \brief Applies the Quick Page Read command to a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \return Whether the specified page is erased.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern Bool flashc_quick_page_read(int page_number);
+
+/*! \brief Erases a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the command is applied to a page belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern Bool flashc_erase_page(int page_number, Bool check);
+
+/*! \brief Erases all pages within the flash array.
+ *
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if at least one region is locked or the
+ *          bootloader protection is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern Bool flashc_erase_all_pages(Bool check);
+
+/*! \brief Writes a page from the page buffer.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \warning A Lock Error is issued if the command is applied to a page belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \warning The page buffer is not automatically reset after a page write.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ */
+extern void flashc_write_page(int page_number);
+
+/*! \brief Issues a Quick Page Read User Page command to the FLASHC.
+ *
+ * \return Whether the User page is erased.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern Bool flashc_quick_user_page_read(void);
+
+/*! \brief Erases the User page.
+ *
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern Bool flashc_erase_user_page(Bool check);
+
+/*! \brief Writes the User page from the page buffer.
+ *
+ * \warning The page buffer is not automatically reset after a page write.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ */
+extern void flashc_write_user_page(void);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src source byte.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source byte.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased bytes, i.e. this function
+ *          can not be used to write only one bit of a previously written byte.
+ *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
+ *          value in flash may be different from \c 0x00.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset8(volatile void *dst, U8 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source half-word.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source half-word.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased bytes, i.e. this function
+ *          can not be used to write only one bit of a previously written byte.
+ *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
+ *          value in flash may be different from \c 0x00.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset16(volatile void *dst, U16 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source word.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source word.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased bytes, i.e. this function
+ *          can not be used to write only one bit of a previously written byte.
+ *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
+ *          value in flash may be different from \c 0x00.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset32(volatile void *dst, U32 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source double-word.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source double-word.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased bytes, i.e. this function
+ *          can not be used to write only one bit of a previously written byte.
+ *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
+ *          value in flash may be different from \c 0x00.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source pattern.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source double-word.
+ * \param src_width \a src width in bits: 8, 16, 32 or 64.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased bytes, i.e. this function
+ *          can not be used to write only one bit of a previously written byte.
+ *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
+ *          value in flash may be different from \c 0x00.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+#define flashc_memset(dst, src, src_width, nbytes, erase) \
+          TPASTE2(flashc_memset, src_width)((dst), (src), (nbytes), (erase))
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the source pointed to by \a src.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Pointer to source data.
+ * \param nbytes Number of bytes to copy.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning If copying takes place between areas that overlap, the behavior is
+ *          undefined.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased bytes, i.e. this function
+ *          can not be used to write only one bit of a previously written byte.
+ *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
+ *          value in flash may be different from \c 0x00.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase);
+
+//! @}
+
+
+#endif  // _FLASHC_H_

Added: trunk/src/platform/avr32/gpio.c
===================================================================
--- trunk/src/platform/avr32/gpio.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/gpio.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,270 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief GPIO driver for AVR32 UC3.
+ *
+ * This file defines a useful set of functions for the GPIO.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a GPIO module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &quot;gpio.h&quot;
+
+
+//! GPIO module instance.
+#define GPIO  AVR32_GPIO
+
+
+/*! \name Peripheral Bus Interface
+ */
+//! @{
+
+
+int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size)
+{
+  int status = GPIO_SUCCESS;
+  unsigned int i;
+
+  for (i = 0; i &lt; size; i++)
+  {
+    status |= gpio_enable_module_pin(gpiomap-&gt;pin, gpiomap-&gt;function);
+    gpiomap++;
+  }
+
+  return status;
+}
+
+
+int gpio_enable_module_pin(unsigned int pin, unsigned int function)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  // Enable the correct function.
+  switch (function)
+  {
+  case 0: // A function.
+    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  case 1: // B function.
+    gpio_port-&gt;pmr0s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  case 2: // C function.
+    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1s = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  default:
+    return GPIO_INVALID_ARGUMENT;
+  }
+
+  // Disable GPIO control.
+  gpio_port-&gt;gperc = 1 &lt;&lt; (pin &amp; 0x1F);
+
+  return GPIO_SUCCESS;
+}
+
+
+void gpio_enable_gpio(const gpio_map_t gpiomap, unsigned int size)
+{
+  unsigned int i;
+
+  for (i = 0; i &lt; size; i++)
+  {
+    gpio_enable_gpio_pin(gpiomap-&gt;pin);
+    gpiomap++;
+  }
+}
+
+
+void gpio_enable_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;oderc = 1 &lt;&lt; (pin &amp; 0x1F);
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+void gpio_enable_pin_open_drain(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;odmers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+void gpio_disable_pin_open_drain(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;odmerc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+void gpio_enable_pin_pull_up(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;puers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+void gpio_disable_pin_pull_up(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;puerc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+int gpio_get_pin_value(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  return (gpio_port-&gt;pvr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+
+int gpio_get_gpio_pin_output_value(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  return (gpio_port-&gt;ovr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+
+void gpio_set_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrs  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line: 1.
+  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_clr_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrc  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line: 0.
+  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_tgl_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrt  = 1 &lt;&lt; (pin &amp; 0x1F); // Toggle the I/O line.
+  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_enable_pin_glitch_filter(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;gfers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+void gpio_disable_pin_glitch_filter(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;gferc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+int gpio_enable_pin_interrupt(unsigned int pin, unsigned int mode)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  // Enable the glitch filter.
+  gpio_port-&gt;gfers = 1 &lt;&lt; (pin &amp; 0x1F);
+
+  // Configure the edge detector.
+  switch (mode)
+  {
+  case GPIO_PIN_CHANGE:
+    gpio_port-&gt;imr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;imr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  case GPIO_RISING_EDGE:
+    gpio_port-&gt;imr0s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;imr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  case GPIO_FALLING_EDGE:
+    gpio_port-&gt;imr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;imr1s = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  default:
+    return GPIO_INVALID_ARGUMENT;
+  }
+
+  // Enable interrupt.
+  gpio_port-&gt;iers = 1 &lt;&lt; (pin &amp; 0x1F);
+
+  return GPIO_SUCCESS;
+}
+
+
+void gpio_disable_pin_interrupt(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;ierc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+int gpio_get_pin_interrupt_flag(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  return (gpio_port-&gt;ifr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+
+void gpio_clear_pin_interrupt_flag(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;ifrc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+//! @}

Added: trunk/src/platform/avr32/gpio.h
===================================================================
--- trunk/src/platform/avr32/gpio.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/gpio.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,381 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief GPIO header for AVR32 UC3.
+ *
+ * This file contains basic GPIO driver functions.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a GPIO module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _GPIO_H_
+#define _GPIO_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+
+
+/*! \name Return Values of the GPIO API
+ */
+//! @{
+#define GPIO_SUCCESS            0 //!&lt; Function successfully completed.
+#define GPIO_INVALID_ARGUMENT   1 //!&lt; Input parameters are out of range.
+//! @}
+
+
+/*! \name Interrupt Trigger Modes
+ */
+//! @{
+#define GPIO_PIN_CHANGE         0 //!&lt; Interrupt triggered upon pin change.
+#define GPIO_RISING_EDGE        1 //!&lt; Interrupt triggered upon rising edge.
+#define GPIO_FALLING_EDGE       2 //!&lt; Interrupt triggered upon falling edge.
+//! @}
+
+
+//! A type definition of pins and modules connectivity.
+typedef struct
+{
+  unsigned char pin;              //!&lt; Module pin.
+  unsigned char function;         //!&lt; Module function.
+} gpio_map_t[];
+
+
+/*! \name Peripheral Bus Interface
+ *
+ * Low-speed interface with a non-deterministic number of clock cycles per
+ * access.
+ *
+ * This interface operates with lower clock frequencies (fPB &lt;= fCPU), and its
+ * timing is not deterministic since it needs to access a shared bus which may
+ * be heavily loaded.
+ *
+ * \note This interface is immediately available without initialization.
+ */
+//! @{
+
+/*! \brief Enables specific module modes for a set of pins.
+ *
+ * \param gpiomap The pin map.
+ * \param size The number of pins in \a gpiomap.
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+extern int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size);
+
+/*! \brief Enables a specific module mode for a pin.
+ *
+ * \param pin The pin number.\n
+ *            Refer to the product header file `uc3x.h' (where x is the part
+ *            number; e.g. x = a0512) for module pins. E.g., to enable a PWM
+ *            channel output, the pin number can be AVR32_PWM_3_PIN for PWM
+ *            channel 3.
+ * \param function The pin function.\n
+ *                 Refer to the product header file `uc3x.h' (where x is the
+ *                 part number; e.g. x = a0512) for module pin functions. E.g.,
+ *                 to enable a PWM channel output, the pin function can be
+ *                 AVR32_PWM_3_FUNCTION for PWM channel 3.
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+extern int gpio_enable_module_pin(unsigned int pin, unsigned int function);
+
+/*! \brief Enables the GPIO mode of a set of pins.
+ *
+ * \param gpiomap The pin map.
+ * \param size The number of pins in \a gpiomap.
+ */
+extern void gpio_enable_gpio(const gpio_map_t gpiomap, unsigned int size);
+
+/*! \brief Enables the GPIO mode of a pin.
+ *
+ * \param pin The pin number.\n
+ *            Refer to the product header file `uc3x.h' (where x is the part
+ *            number; e.g. x = a0512) for pin definitions. E.g., to enable the
+ *            GPIO mode of PX21, AVR32_PIN_PX21 can be used. Module pins such as
+ *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
+ *            module pins for GPIO.
+ */
+extern void gpio_enable_gpio_pin(unsigned int pin);
+
+/*! \brief Enables the open-drain mode of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_open_drain(unsigned int pin);
+
+/*! \brief Disables the open-drain mode of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_open_drain(unsigned int pin);
+
+/*! \brief Enables the pull-up resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_pull_up(unsigned int pin);
+
+/*! \brief Disables the pull-up resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_pull_up(unsigned int pin);
+
+/*! \brief Returns the value of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin value.
+ */
+extern int gpio_get_pin_value(unsigned int pin);
+
+/*! \brief Returns the output value set for a GPIO pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin output value.
+ */
+extern int gpio_get_gpio_pin_output_value(unsigned int pin);
+
+/*! \brief Drives a GPIO pin to 1.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_set_gpio_pin(unsigned int pin);
+
+/*! \brief Drives a GPIO pin to 0.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_clr_gpio_pin(unsigned int pin);
+
+/*! \brief Toggles a GPIO pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_tgl_gpio_pin(unsigned int pin);
+
+/*! \brief Enables the glitch filter of a pin.
+ *
+ * When the glitch filter is enabled, a glitch with duration of less than 1
+ * clock cycle is automatically rejected, while a pulse with duration of 2 clock
+ * cycles or more is accepted. For pulse durations between 1 clock cycle and 2
+ * clock cycles, the pulse may or may not be taken into account, depending on
+ * the precise timing of its occurrence. Thus for a pulse to be guaranteed
+ * visible it must exceed 2 clock cycles, whereas for a glitch to be reliably
+ * filtered out, its duration must not exceed 1 clock cycle. The filter
+ * introduces 2 clock cycles latency.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_glitch_filter(unsigned int pin);
+
+/*! \brief Disables the glitch filter of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_glitch_filter(unsigned int pin);
+
+/*! \brief Enables the interrupt of a pin with the specified settings.
+ *
+ * \param pin The pin number.
+ * \param mode The trigger mode (\ref GPIO_PIN_CHANGE, \ref GPIO_RISING_EDGE or
+ *             \ref GPIO_FALLING_EDGE).
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+extern int gpio_enable_pin_interrupt(unsigned int pin, unsigned int mode);
+
+/*! \brief Disables the interrupt of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_interrupt(unsigned int pin);
+
+/*! \brief Gets the interrupt flag of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin interrupt flag.
+ */
+extern int gpio_get_pin_interrupt_flag(unsigned int pin);
+
+/*! \brief Clears the interrupt flag of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_clear_pin_interrupt_flag(unsigned int pin);
+
+//! @}
+
+
+/*! \name Local Bus Interface
+ *
+ * High-speed interface with only one clock cycle per access.
+ *
+ * This interface operates with high clock frequency (fCPU), and its timing is
+ * deterministic since it does not need to access a shared bus which may be
+ * heavily loaded.
+ *
+ * \note This interface has to be initialized in order to be available.
+ */
+//! @{
+
+/*! \brief Enables the local bus interface for GPIO.
+ *
+ * \note This function must have been called at least once before using other
+ *       functions in this interface.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_init(void)
+{
+  Set_system_register(AVR32_CPUCR,
+                      Get_system_register(AVR32_CPUCR) | AVR32_CPUCR_LOCEN_MASK);
+}
+
+/*! \brief Enables the output driver of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin.
+ *       \ref gpio_enable_gpio_pin can be called for this purpose.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_enable_pin_output_driver(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oders = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Disables the output driver of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_disable_pin_output_driver(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oderc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Returns the value of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin value.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int gpio_local_get_pin_value(unsigned int pin)
+{
+  return (AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].pvr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+/*! \brief Drives a GPIO pin to 1.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin nor its output
+ *       driver. \ref gpio_enable_gpio_pin and
+ *       \ref gpio_local_enable_pin_output_driver can be called for this
+ *       purpose.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_set_gpio_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrs = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Drives a GPIO pin to 0.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin nor its output
+ *       driver. \ref gpio_enable_gpio_pin and
+ *       \ref gpio_local_enable_pin_output_driver can be called for this
+ *       purpose.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_clr_gpio_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Toggles a GPIO pin.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin nor its output
+ *       driver. \ref gpio_enable_gpio_pin and
+ *       \ref gpio_local_enable_pin_output_driver can be called for this
+ *       purpose.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_tgl_gpio_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrt = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+//! @}
+
+
+#endif  // _GPIO_H_

Added: trunk/src/platform/avr32/intc.c
===================================================================
--- trunk/src/platform/avr32/intc.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/intc.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,202 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief INTC driver for AVR32 UC3.
+ *
+ * AVR32 Interrupt Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an INTC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;preprocessor.h&quot;
+#include &quot;intc.h&quot;
+
+
+//! Values to store in the interrupt priority registers for the various interrupt priority levels.
+extern const unsigned int ipr_val[AVR32_INTC_NUM_INT_LEVELS];
+
+//! Creates a table of interrupt line handlers per interrupt group in order to optimize RAM space.
+//! Each line handler table contains a set of pointers to interrupt handlers.
+#if __GNUC__
+#define DECL_INT_LINE_HANDLER_TABLE(GRP, unused) \
+static volatile __int_handler _int_line_handler_table_##GRP[Max(AVR32_INTC_NUM_IRQS_PER_GRP##GRP, 1)];
+#elif __ICCAVR32__
+#define DECL_INT_LINE_HANDLER_TABLE(GRP, unused) \
+static volatile __no_init __int_handler _int_line_handler_table_##GRP[Max(AVR32_INTC_NUM_IRQS_PER_GRP##GRP, 1)];
+#endif
+MREPEAT(AVR32_INTC_NUM_INT_GRPS, DECL_INT_LINE_HANDLER_TABLE, ~);
+#undef DECL_INT_LINE_HANDLER_TABLE
+
+//! Table containing for each interrupt group the number of interrupt request
+//! lines and a pointer to the table of interrupt line handlers.
+static const struct
+{
+  unsigned int num_irqs;
+  volatile __int_handler *_int_line_handler_table;
+} _int_handler_table[AVR32_INTC_NUM_INT_GRPS] =
+{
+#define INSERT_INT_LINE_HANDLER_TABLE(GRP, unused) \
+  {AVR32_INTC_NUM_IRQS_PER_GRP##GRP, _int_line_handler_table_##GRP},
+  MREPEAT(AVR32_INTC_NUM_INT_GRPS, INSERT_INT_LINE_HANDLER_TABLE, ~)
+#undef INSERT_INT_LINE_HANDLER_TABLE
+};
+
+
+/*! \brief Default interrupt handler.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+#if __GNUC__
+__attribute__((__interrupt__))
+#elif __ICCAVR32__
+__interrupt
+#endif
+static void _unhandled_interrupt(void)
+{
+  // Catch unregistered interrupts.
+  while (TRUE);
+}
+
+
+/*! \brief Gets the interrupt handler of the current event at the \a int_lev
+ *         interrupt priority level (called from exception.S).
+ *
+ * \param int_lev Interrupt priority level to handle.
+ *
+ * \return Interrupt handler to execute.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+__int_handler _get_interrupt_handler(unsigned int int_lev)
+{
+  // ICR3 is mapped first, ICR0 last.
+  // Code in exception.S puts int_lev in R12 which is used by AVR32-GCC to pass
+  // a single argument to a function.
+  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_lev];
+  unsigned int int_req = AVR32_INTC.irr[int_grp];
+
+  // As an interrupt may disappear while it is being fetched by the CPU
+  // (spurious interrupt caused by a delayed response from an MCU peripheral to
+  // an interrupt flag clear or interrupt disable instruction), check if there
+  // are remaining interrupt lines to process.
+  // If a spurious interrupt occurs, the status register (SR) contains an
+  // execution mode and interrupt level masks corresponding to a level 0
+  // interrupt, whatever the interrupt priority level causing the spurious
+  // event. This behavior has been chosen because a spurious interrupt has not
+  // to be a priority one and because it may not cause any trouble to other
+  // interrupts.
+  // However, these spurious interrupts place the hardware in an unstable state
+  // and could give problems in other/future versions of the CPU, so the
+  // software has to be written so that they never occur. The only safe way of
+  // achieving this is to always clear or disable peripheral interrupts with the
+  // following sequence:
+  // 1: Mask the interrupt in the CPU by setting GM (or IxM) in SR.
+  // 2: Perform the bus access to the peripheral register that clears or
+  //    disables the interrupt.
+  // 3: Wait until the interrupt has actually been cleared or disabled by the
+  //    peripheral. This is usually performed by reading from a register in the
+  //    same peripheral (it DOES NOT have to be the same register that was
+  //    accessed in step 2, but it MUST be in the same peripheral), what takes
+  //    bus system latencies into account, but peripheral internal latencies
+  //    (generally 0 cycle) also have to be considered.
+  // 4: Unmask the interrupt in the CPU by clearing GM (or IxM) in SR.
+  // Note that steps 1 and 4 are useless inside interrupt handlers as the
+  // corresponding interrupt level is automatically masked by IxM (unless IxM is
+  // explicitly cleared by the software).
+  //
+  // Get the right IRQ handler.
+  //
+  // If several interrupt lines are active in the group, the interrupt line with
+  // the highest number is selected. This is to be coherent with the
+  // prioritization of interrupt groups performed by the hardware interrupt
+  // controller.
+  //
+  // If no handler has been registered for the pending interrupt,
+  // _unhandled_interrupt will be selected thanks to the initialization of
+  // _int_line_handler_table_x by INTC_init_interrupts.
+  //
+  // exception.S will provide the interrupt handler with a clean interrupt stack
+  // frame, with nothing more pushed onto the stack. The interrupt handler must
+  // manage the `rete' instruction, what can be done thanks to pure assembly,
+  // inline assembly or the `__attribute__((__interrupt__))' C function
+  // attribute.
+  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
+}
+
+
+void INTC_init_interrupts(void)
+{
+  unsigned int int_grp, int_req;
+
+  // For all interrupt groups,
+  for (int_grp = 0; int_grp &lt; AVR32_INTC_NUM_INT_GRPS; int_grp++)
+  {
+    // For all interrupt request lines of each group,
+    for (int_req = 0; int_req &lt; _int_handler_table[int_grp].num_irqs; int_req++)
+    {
+      // Assign _unhandled_interrupt as default interrupt handler.
+      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &amp;_unhandled_interrupt;
+    }
+
+    // Set the interrupt group priority register to its default value.
+    // By default, all interrupt groups are linked to the interrupt priority
+    // level 0 and to the interrupt vector _int0.
+    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
+  }
+}
+
+
+void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_lev)
+{
+  // Determine the group of the IRQ.
+  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
+
+  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
+  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
+  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
+
+  // Program the corresponding IPRX register to set the interrupt priority level
+  // and the interrupt vector offset that will be fetched by the core interrupt
+  // system.
+  // NOTE: The _intx functions are intermediate assembly functions between the
+  // core interrupt system and the user interrupt handler.
+  AVR32_INTC.ipr[int_grp] = ipr_val[int_lev &amp; (AVR32_INTC_IPR_INTLEV_MASK &gt;&gt; AVR32_INTC_IPR_INTLEV_OFFSET)];
+}

Added: trunk/src/platform/avr32/intc.h
===================================================================
--- trunk/src/platform/avr32/intc.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/intc.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,97 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief INTC driver for AVR32 UC3.
+ *
+ * AVR32 Interrupt Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an INTC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _INTC_H_
+#define _INTC_H_
+
+#include &quot;compiler.h&quot;
+
+
+//! Maximal number of interrupt request lines per group.
+#define AVR32_INTC_MAX_NUM_IRQS_PER_GRP             32
+
+//! Number of interrupt priority levels.
+#define AVR32_INTC_NUM_INT_LEVELS                   (1 &lt;&lt; AVR32_INTC_IPR_INTLEV_SIZE)
+
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+//! Pointer to interrupt handler.
+#if __GNUC__
+typedef void (*__int_handler)(void);
+#elif __ICCAVR32__
+typedef void (__interrupt *__int_handler)(void);
+#endif
+
+
+/*! \brief Initializes the hardware interrupt controller driver.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+extern void INTC_init_interrupts(void);
+
+/*! \brief Registers an interrupt handler.
+ *
+ * \param handler Interrupt handler to register.
+ * \param irq     IRQ of the interrupt handler to register.
+ * \param int_lev Interrupt priority level to assign to the group of this IRQ.
+ *
+ * \warning The interrupt handler must manage the `rete' instruction, what can
+ *          be done thanks to pure assembly, inline assembly or the
+ *          `__attribute__((__interrupt__))' C function attribute.
+ *
+ * \warning If several interrupt handlers of a same group are registered with
+ *          different priority levels, only the latest priority level set will
+ *          be effective.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+extern void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_lev);
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+#endif  // _INTC_H_

Added: trunk/src/platform/avr32/mrepeat.h
===================================================================
--- trunk/src/platform/avr32/mrepeat.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/mrepeat.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,325 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor macro repeating utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _MREPEAT_H_
+#define _MREPEAT_H_
+
+#include &quot;preprocessor.h&quot;
+
+
+//! Maximal number of repetitions supported by MREPEAT.
+#define MREPEAT_LIMIT   256
+
+/*! \brief Macro repeat.
+ *
+ * This macro represents a horizontal repetition construct.
+ *
+ * \param count  The number of repetitious calls to macro. Valid values range from 0 to MREPEAT_LIMIT.
+ * \param macro  A binary operation of the form macro(n, data). This macro is expanded by MREPEAT with
+ *               the current repetition number and the auxiliary data argument.
+ * \param data   Auxiliary data passed to macro.
+ *
+ * \return       &lt;tt&gt;macro(0, data) macro(1, data) ... macro(count - 1, data)&lt;/tt&gt;
+ */
+#define MREPEAT(count, macro, data)         TPASTE2(MREPEAT, count)(macro, data)
+
+#define MREPEAT0(  macro, data)
+#define MREPEAT1(  macro, data)       MREPEAT0(  macro, data)   macro(  0, data)
+#define MREPEAT2(  macro, data)       MREPEAT1(  macro, data)   macro(  1, data)
+#define MREPEAT3(  macro, data)       MREPEAT2(  macro, data)   macro(  2, data)
+#define MREPEAT4(  macro, data)       MREPEAT3(  macro, data)   macro(  3, data)
+#define MREPEAT5(  macro, data)       MREPEAT4(  macro, data)   macro(  4, data)
+#define MREPEAT6(  macro, data)       MREPEAT5(  macro, data)   macro(  5, data)
+#define MREPEAT7(  macro, data)       MREPEAT6(  macro, data)   macro(  6, data)
+#define MREPEAT8(  macro, data)       MREPEAT7(  macro, data)   macro(  7, data)
+#define MREPEAT9(  macro, data)       MREPEAT8(  macro, data)   macro(  8, data)
+#define MREPEAT10( macro, data)       MREPEAT9(  macro, data)   macro(  9, data)
+#define MREPEAT11( macro, data)       MREPEAT10( macro, data)   macro( 10, data)
+#define MREPEAT12( macro, data)       MREPEAT11( macro, data)   macro( 11, data)
+#define MREPEAT13( macro, data)       MREPEAT12( macro, data)   macro( 12, data)
+#define MREPEAT14( macro, data)       MREPEAT13( macro, data)   macro( 13, data)
+#define MREPEAT15( macro, data)       MREPEAT14( macro, data)   macro( 14, data)
+#define MREPEAT16( macro, data)       MREPEAT15( macro, data)   macro( 15, data)
+#define MREPEAT17( macro, data)       MREPEAT16( macro, data)   macro( 16, data)
+#define MREPEAT18( macro, data)       MREPEAT17( macro, data)   macro( 17, data)
+#define MREPEAT19( macro, data)       MREPEAT18( macro, data)   macro( 18, data)
+#define MREPEAT20( macro, data)       MREPEAT19( macro, data)   macro( 19, data)
+#define MREPEAT21( macro, data)       MREPEAT20( macro, data)   macro( 20, data)
+#define MREPEAT22( macro, data)       MREPEAT21( macro, data)   macro( 21, data)
+#define MREPEAT23( macro, data)       MREPEAT22( macro, data)   macro( 22, data)
+#define MREPEAT24( macro, data)       MREPEAT23( macro, data)   macro( 23, data)
+#define MREPEAT25( macro, data)       MREPEAT24( macro, data)   macro( 24, data)
+#define MREPEAT26( macro, data)       MREPEAT25( macro, data)   macro( 25, data)
+#define MREPEAT27( macro, data)       MREPEAT26( macro, data)   macro( 26, data)
+#define MREPEAT28( macro, data)       MREPEAT27( macro, data)   macro( 27, data)
+#define MREPEAT29( macro, data)       MREPEAT28( macro, data)   macro( 28, data)
+#define MREPEAT30( macro, data)       MREPEAT29( macro, data)   macro( 29, data)
+#define MREPEAT31( macro, data)       MREPEAT30( macro, data)   macro( 30, data)
+#define MREPEAT32( macro, data)       MREPEAT31( macro, data)   macro( 31, data)
+#define MREPEAT33( macro, data)       MREPEAT32( macro, data)   macro( 32, data)
+#define MREPEAT34( macro, data)       MREPEAT33( macro, data)   macro( 33, data)
+#define MREPEAT35( macro, data)       MREPEAT34( macro, data)   macro( 34, data)
+#define MREPEAT36( macro, data)       MREPEAT35( macro, data)   macro( 35, data)
+#define MREPEAT37( macro, data)       MREPEAT36( macro, data)   macro( 36, data)
+#define MREPEAT38( macro, data)       MREPEAT37( macro, data)   macro( 37, data)
+#define MREPEAT39( macro, data)       MREPEAT38( macro, data)   macro( 38, data)
+#define MREPEAT40( macro, data)       MREPEAT39( macro, data)   macro( 39, data)
+#define MREPEAT41( macro, data)       MREPEAT40( macro, data)   macro( 40, data)
+#define MREPEAT42( macro, data)       MREPEAT41( macro, data)   macro( 41, data)
+#define MREPEAT43( macro, data)       MREPEAT42( macro, data)   macro( 42, data)
+#define MREPEAT44( macro, data)       MREPEAT43( macro, data)   macro( 43, data)
+#define MREPEAT45( macro, data)       MREPEAT44( macro, data)   macro( 44, data)
+#define MREPEAT46( macro, data)       MREPEAT45( macro, data)   macro( 45, data)
+#define MREPEAT47( macro, data)       MREPEAT46( macro, data)   macro( 46, data)
+#define MREPEAT48( macro, data)       MREPEAT47( macro, data)   macro( 47, data)
+#define MREPEAT49( macro, data)       MREPEAT48( macro, data)   macro( 48, data)
+#define MREPEAT50( macro, data)       MREPEAT49( macro, data)   macro( 49, data)
+#define MREPEAT51( macro, data)       MREPEAT50( macro, data)   macro( 50, data)
+#define MREPEAT52( macro, data)       MREPEAT51( macro, data)   macro( 51, data)
+#define MREPEAT53( macro, data)       MREPEAT52( macro, data)   macro( 52, data)
+#define MREPEAT54( macro, data)       MREPEAT53( macro, data)   macro( 53, data)
+#define MREPEAT55( macro, data)       MREPEAT54( macro, data)   macro( 54, data)
+#define MREPEAT56( macro, data)       MREPEAT55( macro, data)   macro( 55, data)
+#define MREPEAT57( macro, data)       MREPEAT56( macro, data)   macro( 56, data)
+#define MREPEAT58( macro, data)       MREPEAT57( macro, data)   macro( 57, data)
+#define MREPEAT59( macro, data)       MREPEAT58( macro, data)   macro( 58, data)
+#define MREPEAT60( macro, data)       MREPEAT59( macro, data)   macro( 59, data)
+#define MREPEAT61( macro, data)       MREPEAT60( macro, data)   macro( 60, data)
+#define MREPEAT62( macro, data)       MREPEAT61( macro, data)   macro( 61, data)
+#define MREPEAT63( macro, data)       MREPEAT62( macro, data)   macro( 62, data)
+#define MREPEAT64( macro, data)       MREPEAT63( macro, data)   macro( 63, data)
+#define MREPEAT65( macro, data)       MREPEAT64( macro, data)   macro( 64, data)
+#define MREPEAT66( macro, data)       MREPEAT65( macro, data)   macro( 65, data)
+#define MREPEAT67( macro, data)       MREPEAT66( macro, data)   macro( 66, data)
+#define MREPEAT68( macro, data)       MREPEAT67( macro, data)   macro( 67, data)
+#define MREPEAT69( macro, data)       MREPEAT68( macro, data)   macro( 68, data)
+#define MREPEAT70( macro, data)       MREPEAT69( macro, data)   macro( 69, data)
+#define MREPEAT71( macro, data)       MREPEAT70( macro, data)   macro( 70, data)
+#define MREPEAT72( macro, data)       MREPEAT71( macro, data)   macro( 71, data)
+#define MREPEAT73( macro, data)       MREPEAT72( macro, data)   macro( 72, data)
+#define MREPEAT74( macro, data)       MREPEAT73( macro, data)   macro( 73, data)
+#define MREPEAT75( macro, data)       MREPEAT74( macro, data)   macro( 74, data)
+#define MREPEAT76( macro, data)       MREPEAT75( macro, data)   macro( 75, data)
+#define MREPEAT77( macro, data)       MREPEAT76( macro, data)   macro( 76, data)
+#define MREPEAT78( macro, data)       MREPEAT77( macro, data)   macro( 77, data)
+#define MREPEAT79( macro, data)       MREPEAT78( macro, data)   macro( 78, data)
+#define MREPEAT80( macro, data)       MREPEAT79( macro, data)   macro( 79, data)
+#define MREPEAT81( macro, data)       MREPEAT80( macro, data)   macro( 80, data)
+#define MREPEAT82( macro, data)       MREPEAT81( macro, data)   macro( 81, data)
+#define MREPEAT83( macro, data)       MREPEAT82( macro, data)   macro( 82, data)
+#define MREPEAT84( macro, data)       MREPEAT83( macro, data)   macro( 83, data)
+#define MREPEAT85( macro, data)       MREPEAT84( macro, data)   macro( 84, data)
+#define MREPEAT86( macro, data)       MREPEAT85( macro, data)   macro( 85, data)
+#define MREPEAT87( macro, data)       MREPEAT86( macro, data)   macro( 86, data)
+#define MREPEAT88( macro, data)       MREPEAT87( macro, data)   macro( 87, data)
+#define MREPEAT89( macro, data)       MREPEAT88( macro, data)   macro( 88, data)
+#define MREPEAT90( macro, data)       MREPEAT89( macro, data)   macro( 89, data)
+#define MREPEAT91( macro, data)       MREPEAT90( macro, data)   macro( 90, data)
+#define MREPEAT92( macro, data)       MREPEAT91( macro, data)   macro( 91, data)
+#define MREPEAT93( macro, data)       MREPEAT92( macro, data)   macro( 92, data)
+#define MREPEAT94( macro, data)       MREPEAT93( macro, data)   macro( 93, data)
+#define MREPEAT95( macro, data)       MREPEAT94( macro, data)   macro( 94, data)
+#define MREPEAT96( macro, data)       MREPEAT95( macro, data)   macro( 95, data)
+#define MREPEAT97( macro, data)       MREPEAT96( macro, data)   macro( 96, data)
+#define MREPEAT98( macro, data)       MREPEAT97( macro, data)   macro( 97, data)
+#define MREPEAT99( macro, data)       MREPEAT98( macro, data)   macro( 98, data)
+#define MREPEAT100(macro, data)       MREPEAT99( macro, data)   macro( 99, data)
+#define MREPEAT101(macro, data)       MREPEAT100(macro, data)   macro(100, data)
+#define MREPEAT102(macro, data)       MREPEAT101(macro, data)   macro(101, data)
+#define MREPEAT103(macro, data)       MREPEAT102(macro, data)   macro(102, data)
+#define MREPEAT104(macro, data)       MREPEAT103(macro, data)   macro(103, data)
+#define MREPEAT105(macro, data)       MREPEAT104(macro, data)   macro(104, data)
+#define MREPEAT106(macro, data)       MREPEAT105(macro, data)   macro(105, data)
+#define MREPEAT107(macro, data)       MREPEAT106(macro, data)   macro(106, data)
+#define MREPEAT108(macro, data)       MREPEAT107(macro, data)   macro(107, data)
+#define MREPEAT109(macro, data)       MREPEAT108(macro, data)   macro(108, data)
+#define MREPEAT110(macro, data)       MREPEAT109(macro, data)   macro(109, data)
+#define MREPEAT111(macro, data)       MREPEAT110(macro, data)   macro(110, data)
+#define MREPEAT112(macro, data)       MREPEAT111(macro, data)   macro(111, data)
+#define MREPEAT113(macro, data)       MREPEAT112(macro, data)   macro(112, data)
+#define MREPEAT114(macro, data)       MREPEAT113(macro, data)   macro(113, data)
+#define MREPEAT115(macro, data)       MREPEAT114(macro, data)   macro(114, data)
+#define MREPEAT116(macro, data)       MREPEAT115(macro, data)   macro(115, data)
+#define MREPEAT117(macro, data)       MREPEAT116(macro, data)   macro(116, data)
+#define MREPEAT118(macro, data)       MREPEAT117(macro, data)   macro(117, data)
+#define MREPEAT119(macro, data)       MREPEAT118(macro, data)   macro(118, data)
+#define MREPEAT120(macro, data)       MREPEAT119(macro, data)   macro(119, data)
+#define MREPEAT121(macro, data)       MREPEAT120(macro, data)   macro(120, data)
+#define MREPEAT122(macro, data)       MREPEAT121(macro, data)   macro(121, data)
+#define MREPEAT123(macro, data)       MREPEAT122(macro, data)   macro(122, data)
+#define MREPEAT124(macro, data)       MREPEAT123(macro, data)   macro(123, data)
+#define MREPEAT125(macro, data)       MREPEAT124(macro, data)   macro(124, data)
+#define MREPEAT126(macro, data)       MREPEAT125(macro, data)   macro(125, data)
+#define MREPEAT127(macro, data)       MREPEAT126(macro, data)   macro(126, data)
+#define MREPEAT128(macro, data)       MREPEAT127(macro, data)   macro(127, data)
+#define MREPEAT129(macro, data)       MREPEAT128(macro, data)   macro(128, data)
+#define MREPEAT130(macro, data)       MREPEAT129(macro, data)   macro(129, data)
+#define MREPEAT131(macro, data)       MREPEAT130(macro, data)   macro(130, data)
+#define MREPEAT132(macro, data)       MREPEAT131(macro, data)   macro(131, data)
+#define MREPEAT133(macro, data)       MREPEAT132(macro, data)   macro(132, data)
+#define MREPEAT134(macro, data)       MREPEAT133(macro, data)   macro(133, data)
+#define MREPEAT135(macro, data)       MREPEAT134(macro, data)   macro(134, data)
+#define MREPEAT136(macro, data)       MREPEAT135(macro, data)   macro(135, data)
+#define MREPEAT137(macro, data)       MREPEAT136(macro, data)   macro(136, data)
+#define MREPEAT138(macro, data)       MREPEAT137(macro, data)   macro(137, data)
+#define MREPEAT139(macro, data)       MREPEAT138(macro, data)   macro(138, data)
+#define MREPEAT140(macro, data)       MREPEAT139(macro, data)   macro(139, data)
+#define MREPEAT141(macro, data)       MREPEAT140(macro, data)   macro(140, data)
+#define MREPEAT142(macro, data)       MREPEAT141(macro, data)   macro(141, data)
+#define MREPEAT143(macro, data)       MREPEAT142(macro, data)   macro(142, data)
+#define MREPEAT144(macro, data)       MREPEAT143(macro, data)   macro(143, data)
+#define MREPEAT145(macro, data)       MREPEAT144(macro, data)   macro(144, data)
+#define MREPEAT146(macro, data)       MREPEAT145(macro, data)   macro(145, data)
+#define MREPEAT147(macro, data)       MREPEAT146(macro, data)   macro(146, data)
+#define MREPEAT148(macro, data)       MREPEAT147(macro, data)   macro(147, data)
+#define MREPEAT149(macro, data)       MREPEAT148(macro, data)   macro(148, data)
+#define MREPEAT150(macro, data)       MREPEAT149(macro, data)   macro(149, data)
+#define MREPEAT151(macro, data)       MREPEAT150(macro, data)   macro(150, data)
+#define MREPEAT152(macro, data)       MREPEAT151(macro, data)   macro(151, data)
+#define MREPEAT153(macro, data)       MREPEAT152(macro, data)   macro(152, data)
+#define MREPEAT154(macro, data)       MREPEAT153(macro, data)   macro(153, data)
+#define MREPEAT155(macro, data)       MREPEAT154(macro, data)   macro(154, data)
+#define MREPEAT156(macro, data)       MREPEAT155(macro, data)   macro(155, data)
+#define MREPEAT157(macro, data)       MREPEAT156(macro, data)   macro(156, data)
+#define MREPEAT158(macro, data)       MREPEAT157(macro, data)   macro(157, data)
+#define MREPEAT159(macro, data)       MREPEAT158(macro, data)   macro(158, data)
+#define MREPEAT160(macro, data)       MREPEAT159(macro, data)   macro(159, data)
+#define MREPEAT161(macro, data)       MREPEAT160(macro, data)   macro(160, data)
+#define MREPEAT162(macro, data)       MREPEAT161(macro, data)   macro(161, data)
+#define MREPEAT163(macro, data)       MREPEAT162(macro, data)   macro(162, data)
+#define MREPEAT164(macro, data)       MREPEAT163(macro, data)   macro(163, data)
+#define MREPEAT165(macro, data)       MREPEAT164(macro, data)   macro(164, data)
+#define MREPEAT166(macro, data)       MREPEAT165(macro, data)   macro(165, data)
+#define MREPEAT167(macro, data)       MREPEAT166(macro, data)   macro(166, data)
+#define MREPEAT168(macro, data)       MREPEAT167(macro, data)   macro(167, data)
+#define MREPEAT169(macro, data)       MREPEAT168(macro, data)   macro(168, data)
+#define MREPEAT170(macro, data)       MREPEAT169(macro, data)   macro(169, data)
+#define MREPEAT171(macro, data)       MREPEAT170(macro, data)   macro(170, data)
+#define MREPEAT172(macro, data)       MREPEAT171(macro, data)   macro(171, data)
+#define MREPEAT173(macro, data)       MREPEAT172(macro, data)   macro(172, data)
+#define MREPEAT174(macro, data)       MREPEAT173(macro, data)   macro(173, data)
+#define MREPEAT175(macro, data)       MREPEAT174(macro, data)   macro(174, data)
+#define MREPEAT176(macro, data)       MREPEAT175(macro, data)   macro(175, data)
+#define MREPEAT177(macro, data)       MREPEAT176(macro, data)   macro(176, data)
+#define MREPEAT178(macro, data)       MREPEAT177(macro, data)   macro(177, data)
+#define MREPEAT179(macro, data)       MREPEAT178(macro, data)   macro(178, data)
+#define MREPEAT180(macro, data)       MREPEAT179(macro, data)   macro(179, data)
+#define MREPEAT181(macro, data)       MREPEAT180(macro, data)   macro(180, data)
+#define MREPEAT182(macro, data)       MREPEAT181(macro, data)   macro(181, data)
+#define MREPEAT183(macro, data)       MREPEAT182(macro, data)   macro(182, data)
+#define MREPEAT184(macro, data)       MREPEAT183(macro, data)   macro(183, data)
+#define MREPEAT185(macro, data)       MREPEAT184(macro, data)   macro(184, data)
+#define MREPEAT186(macro, data)       MREPEAT185(macro, data)   macro(185, data)
+#define MREPEAT187(macro, data)       MREPEAT186(macro, data)   macro(186, data)
+#define MREPEAT188(macro, data)       MREPEAT187(macro, data)   macro(187, data)
+#define MREPEAT189(macro, data)       MREPEAT188(macro, data)   macro(188, data)
+#define MREPEAT190(macro, data)       MREPEAT189(macro, data)   macro(189, data)
+#define MREPEAT191(macro, data)       MREPEAT190(macro, data)   macro(190, data)
+#define MREPEAT192(macro, data)       MREPEAT191(macro, data)   macro(191, data)
+#define MREPEAT193(macro, data)       MREPEAT192(macro, data)   macro(192, data)
+#define MREPEAT194(macro, data)       MREPEAT193(macro, data)   macro(193, data)
+#define MREPEAT195(macro, data)       MREPEAT194(macro, data)   macro(194, data)
+#define MREPEAT196(macro, data)       MREPEAT195(macro, data)   macro(195, data)
+#define MREPEAT197(macro, data)       MREPEAT196(macro, data)   macro(196, data)
+#define MREPEAT198(macro, data)       MREPEAT197(macro, data)   macro(197, data)
+#define MREPEAT199(macro, data)       MREPEAT198(macro, data)   macro(198, data)
+#define MREPEAT200(macro, data)       MREPEAT199(macro, data)   macro(199, data)
+#define MREPEAT201(macro, data)       MREPEAT200(macro, data)   macro(200, data)
+#define MREPEAT202(macro, data)       MREPEAT201(macro, data)   macro(201, data)
+#define MREPEAT203(macro, data)       MREPEAT202(macro, data)   macro(202, data)
+#define MREPEAT204(macro, data)       MREPEAT203(macro, data)   macro(203, data)
+#define MREPEAT205(macro, data)       MREPEAT204(macro, data)   macro(204, data)
+#define MREPEAT206(macro, data)       MREPEAT205(macro, data)   macro(205, data)
+#define MREPEAT207(macro, data)       MREPEAT206(macro, data)   macro(206, data)
+#define MREPEAT208(macro, data)       MREPEAT207(macro, data)   macro(207, data)
+#define MREPEAT209(macro, data)       MREPEAT208(macro, data)   macro(208, data)
+#define MREPEAT210(macro, data)       MREPEAT209(macro, data)   macro(209, data)
+#define MREPEAT211(macro, data)       MREPEAT210(macro, data)   macro(210, data)
+#define MREPEAT212(macro, data)       MREPEAT211(macro, data)   macro(211, data)
+#define MREPEAT213(macro, data)       MREPEAT212(macro, data)   macro(212, data)
+#define MREPEAT214(macro, data)       MREPEAT213(macro, data)   macro(213, data)
+#define MREPEAT215(macro, data)       MREPEAT214(macro, data)   macro(214, data)
+#define MREPEAT216(macro, data)       MREPEAT215(macro, data)   macro(215, data)
+#define MREPEAT217(macro, data)       MREPEAT216(macro, data)   macro(216, data)
+#define MREPEAT218(macro, data)       MREPEAT217(macro, data)   macro(217, data)
+#define MREPEAT219(macro, data)       MREPEAT218(macro, data)   macro(218, data)
+#define MREPEAT220(macro, data)       MREPEAT219(macro, data)   macro(219, data)
+#define MREPEAT221(macro, data)       MREPEAT220(macro, data)   macro(220, data)
+#define MREPEAT222(macro, data)       MREPEAT221(macro, data)   macro(221, data)
+#define MREPEAT223(macro, data)       MREPEAT222(macro, data)   macro(222, data)
+#define MREPEAT224(macro, data)       MREPEAT223(macro, data)   macro(223, data)
+#define MREPEAT225(macro, data)       MREPEAT224(macro, data)   macro(224, data)
+#define MREPEAT226(macro, data)       MREPEAT225(macro, data)   macro(225, data)
+#define MREPEAT227(macro, data)       MREPEAT226(macro, data)   macro(226, data)
+#define MREPEAT228(macro, data)       MREPEAT227(macro, data)   macro(227, data)
+#define MREPEAT229(macro, data)       MREPEAT228(macro, data)   macro(228, data)
+#define MREPEAT230(macro, data)       MREPEAT229(macro, data)   macro(229, data)
+#define MREPEAT231(macro, data)       MREPEAT230(macro, data)   macro(230, data)
+#define MREPEAT232(macro, data)       MREPEAT231(macro, data)   macro(231, data)
+#define MREPEAT233(macro, data)       MREPEAT232(macro, data)   macro(232, data)
+#define MREPEAT234(macro, data)       MREPEAT233(macro, data)   macro(233, data)
+#define MREPEAT235(macro, data)       MREPEAT234(macro, data)   macro(234, data)
+#define MREPEAT236(macro, data)       MREPEAT235(macro, data)   macro(235, data)
+#define MREPEAT237(macro, data)       MREPEAT236(macro, data)   macro(236, data)
+#define MREPEAT238(macro, data)       MREPEAT237(macro, data)   macro(237, data)
+#define MREPEAT239(macro, data)       MREPEAT238(macro, data)   macro(238, data)
+#define MREPEAT240(macro, data)       MREPEAT239(macro, data)   macro(239, data)
+#define MREPEAT241(macro, data)       MREPEAT240(macro, data)   macro(240, data)
+#define MREPEAT242(macro, data)       MREPEAT241(macro, data)   macro(241, data)
+#define MREPEAT243(macro, data)       MREPEAT242(macro, data)   macro(242, data)
+#define MREPEAT244(macro, data)       MREPEAT243(macro, data)   macro(243, data)
+#define MREPEAT245(macro, data)       MREPEAT244(macro, data)   macro(244, data)
+#define MREPEAT246(macro, data)       MREPEAT245(macro, data)   macro(245, data)
+#define MREPEAT247(macro, data)       MREPEAT246(macro, data)   macro(246, data)
+#define MREPEAT248(macro, data)       MREPEAT247(macro, data)   macro(247, data)
+#define MREPEAT249(macro, data)       MREPEAT248(macro, data)   macro(248, data)
+#define MREPEAT250(macro, data)       MREPEAT249(macro, data)   macro(249, data)
+#define MREPEAT251(macro, data)       MREPEAT250(macro, data)   macro(250, data)
+#define MREPEAT252(macro, data)       MREPEAT251(macro, data)   macro(251, data)
+#define MREPEAT253(macro, data)       MREPEAT252(macro, data)   macro(252, data)
+#define MREPEAT254(macro, data)       MREPEAT253(macro, data)   macro(253, data)
+#define MREPEAT255(macro, data)       MREPEAT254(macro, data)   macro(254, data)
+#define MREPEAT256(macro, data)       MREPEAT255(macro, data)   macro(255, data)
+
+
+#endif  // _MREPEAT_H_

Added: trunk/src/platform/avr32/platform.c
===================================================================
--- trunk/src/platform/avr32/platform.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/platform.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,210 @@
+// Platform-dependent functions
+
+#include &quot;platform.h&quot;
+#include &quot;type.h&quot;
+#include &quot;devman.h&quot;
+#include &quot;genstd.h&quot;
+#include &quot;stacks.h&quot;
+#include &lt;reent.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;stdio.h&gt;
+#include &quot;utils.h&quot;
+#include &quot;platform_conf.h&quot;
+
+// Platform-specific includes
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;flashc.h&quot;
+#include &quot;pm.h&quot;
+#include &quot;board.h&quot;
+#include &quot;usart.h&quot;
+#include &quot;gpio.h&quot;
+
+// *****************************************************************************
+// std functions
+
+static void uart_send( int fd, char c )
+{
+  fd = fd;
+  platform_uart_send( CON_UART_ID, c );
+}
+
+static int uart_recv()
+{
+  return platform_uart_recv( CON_UART_ID, 0, PLATFORM_UART_INFINITE_TIMEOUT );
+}
+
+// ****************************************************************************
+// Platform initialization
+
+extern int pm_configure_clocks( pm_freq_param_t *param );
+
+int platform_init()
+{
+  pm_freq_param_t pm_freq_param =
+  {
+    REQ_CPU_FREQ,
+    REQ_PBA_FREQ,
+    FOSC0,
+    OSC0_STARTUP, 
+  };
+   
+  Disable_global_interrupt();  
+  
+  // Setup clocks
+  if( PM_FREQ_STATUS_FAIL == pm_configure_clocks( &amp;pm_freq_param ) )
+    return PLATFORM_ERR;  
+    
+  // Setup UART for eLua
+  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );  
+  
+  // Set the send/recv functions                          
+  std_set_send_func( uart_send );
+  std_set_get_func( uart_recv );  
+  
+  // All done  
+  return PLATFORM_OK;
+} 
+
+// ****************************************************************************
+// PIO functions
+
+int platform_pio_has_port( unsigned port )
+{
+  return 0;
+}
+
+const char* platform_pio_get_prefix( unsigned port )
+{
+  static char c[ 3 ];
+  
+  sprintf( c, &quot;P%c&quot;, ( char )( port + 'A' ) );
+  return c;
+}
+
+int platform_pio_has_pin( unsigned port, unsigned pin )
+{
+  return port &lt;= 1 &amp;&amp; pin &lt;= 30;
+}
+
+pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
+{
+  return 0;
+}
+
+// ****************************************************************************
+// UART functions
+
+#define NUM_UARTS     4
+
+static const u32 uart_base_addr[ NUM_UARTS ] = { AVR32_USART0_ADDRESS, AVR32_USART1_ADDRESS, AVR32_USART2_ADDRESS, AVR32_USART3_ADDRESS };
+static const gpio_map_t uart_pins = 
+{
+  // UART 0
+  { AVR32_USART0_RXD_0_0_PIN, AVR32_USART0_RXD_0_0_FUNCTION },
+  { AVR32_USART0_TXD_0_0_PIN, AVR32_USART0_TXD_0_0_FUNCTION },
+  // UART 1
+  { AVR32_USART1_RXD_0_0_PIN, AVR32_USART1_RXD_0_0_FUNCTION },
+  { AVR32_USART1_TXD_0_0_PIN, AVR32_USART1_TXD_0_0_FUNCTION },
+  // UART 2
+  { AVR32_USART2_RXD_0_0_PIN, AVR32_USART2_RXD_0_0_FUNCTION },
+  { AVR32_USART2_TXD_0_0_PIN, AVR32_USART2_TXD_0_0_FUNCTION },
+  // UART 3
+  { AVR32_USART3_RXD_0_0_PIN, AVR32_USART3_RXD_0_0_FUNCTION },
+  { AVR32_USART3_TXD_0_0_PIN, AVR32_USART3_TXD_0_0_FUNCTION }
+};
+
+// The platform UART functions
+int platform_uart_exists( unsigned id )
+{
+  return id &lt; NUM_UARTS;
+}
+
+u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
+{
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
+  usart_options_t opts;
+  
+  opts.channelmode = USART_NORMAL_CHMODE;
+  opts.charlength = databits;
+  opts.baudrate = baud;
+  
+  // Set stopbits
+  if( stopbits == PLATFORM_UART_STOPBITS_1 )
+    opts.stopbits = USART_1_STOPBIT;
+  else if( stopbits == PLATFORM_UART_STOPBITS_1_5 )
+    opts.stopbits = USART_1_5_STOPBITS;
+  else
+    opts.stopbits = USART_2_STOPBITS;    
+    
+  // Set parity
+  if( parity == PLATFORM_UART_PARITY_EVEN )
+    opts.paritytype = USART_EVEN_PARITY;
+  else if( parity == PLATFORM_UART_PARITY_ODD )
+    opts.paritytype = USART_ODD_PARITY;
+  else
+    opts.paritytype = USART_NO_PARITY;  
+    
+  // Set actual interface
+  gpio_enable_module(uart_pins + id * 2, 2 );
+  usart_init_rs232( pusart, &amp;opts, REQ_PBA_FREQ );  
+  
+  // [TODO] Return actual baud here
+  return baud;
+}
+
+void platform_uart_send( unsigned id, u8 data )
+{
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
+  
+  usart_putchar( pusart, data );
+}
+
+int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+{
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
+  int temp;
+
+  if( timeout == 0 )
+  {
+    if( usart_read_char( pusart, &amp;temp ) != USART_SUCCESS )
+      return -1;
+    else
+      return temp;
+  }
+  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
+  {
+    return usart_getchar( pusart );
+  }
+  else
+  {
+    return -1;
+  }  
+}
+
+// ****************************************************************************
+// CPU functions
+
+u32 platform_cpu_get_frequency()
+{
+  return REQ_CPU_FREQ;
+}
+
+// ****************************************************************************
+// Allocator support
+extern char end[];
+
+void* platform_get_first_free_ram( unsigned id )
+{
+  return id &gt; 0 ? NULL : ( void* )end;
+}
+
+#define SRAM_ORIGIN 0x0
+#define SRAM_SIZE 0x10000
+
+void* platform_get_last_free_ram( unsigned id )
+{
+  return id &gt; 0 ? NULL : ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 );
+}

Added: trunk/src/platform/avr32/platform_conf.h
===================================================================
--- trunk/src/platform/avr32/platform_conf.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/platform_conf.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,72 @@
+// eLua platform configuration
+
+#ifndef __PLATFORM_CONF_H__
+#define __PLATFORM_CONF_H__
+
+#include &quot;auxmods.h&quot;
+
+// *****************************************************************************
+// Define here what components you want for this platform
+
+#define BUILD_XMODEM
+#define BUILD_SHELL
+#define BUILD_ROMFS
+#define BUILD_TERM
+//#define BUILD_UIP
+//#define BUILD_DNS
+#define BUILD_CON_GENERIC
+
+// *****************************************************************************
+// UART/Timer IDs configuration data (used in main.c)
+
+// [TODO] added CON_UART_xxxx below, add it to all backends, and probably remove
+// XMODEM_UART_ID (although this isn't strictly required)
+#define CON_UART_ID           0
+#define CON_UART_SPEED        38400
+#define XMODEM_UART_ID        0
+#define XMODEM_TIMER_ID       0
+#define TERM_UART_ID          0
+#define TERM_TIMER_ID         0
+#define TERM_LINES            25
+#define TERM_COLS             80
+#define TERM_TIMEOUT          100000
+
+// *****************************************************************************
+// Auxiliary libraries that will be compiled for this platform
+
+#define LUA_PLATFORM_LIBS\
+  { AUXLIB_PD, luaopen_pd },\
+  { AUXLIB_UART, luaopen_uart },\
+  { AUXLIB_TERM, luaopen_term },\
+  { AUXLIB_PACK, luaopen_pack },\
+  { AUXLIB_BIT, luaopen_bit },\
+  { LUA_MATHLIBNAME, luaopen_math }
+
+// *****************************************************************************
+// Configuration data
+
+// Static TCP/IP configuration
+#define ELUA_CONF_IPADDR0         192
+#define ELUA_CONF_IPADDR1         168
+#define ELUA_CONF_IPADDR2         1
+#define ELUA_CONF_IPADDR3         218
+
+#define ELUA_CONF_NETMASK0        255
+#define ELUA_CONF_NETMASK1        255
+#define ELUA_CONF_NETMASK2        255
+#define ELUA_CONF_NETMASK3        0
+
+#define ELUA_CONF_DEFGW0          192
+#define ELUA_CONF_DEFGW1          168
+#define ELUA_CONF_DEFGW2          1
+#define ELUA_CONF_DEFGW3          1
+
+#define ELUA_CONF_DNS0            192
+#define ELUA_CONF_DNS1            168
+#define ELUA_CONF_DNS2            1
+#define ELUA_CONF_DNS3            1
+
+// *****************************************************************************
+// CPU constants that should be exposed to the eLua &quot;cpu&quot; module
+
+#endif // #ifndef __PLATFORM_CONF_H__

Added: trunk/src/platform/avr32/pm.c
===================================================================
--- trunk/src/platform/avr32/pm.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/pm.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,516 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Power Manager driver.
+ *
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &quot;compiler.h&quot;
+#include &quot;pm.h&quot;
+
+
+/*! \name PM Writable Bit-Field Registers
+ */
+//! @{
+
+typedef union
+{
+  unsigned long                 mcctrl;
+  avr32_pm_mcctrl_t             MCCTRL;
+} u_avr32_pm_mcctrl_t;
+
+typedef union
+{
+  unsigned long                 cksel;
+  avr32_pm_cksel_t              CKSEL;
+} u_avr32_pm_cksel_t;
+
+typedef union
+{
+  unsigned long                 pll;
+  avr32_pm_pll_t                PLL;
+} u_avr32_pm_pll_t;
+
+typedef union
+{
+  unsigned long                 oscctrl0;
+  avr32_pm_oscctrl0_t           OSCCTRL0;
+} u_avr32_pm_oscctrl0_t;
+
+typedef union
+{
+  unsigned long                 oscctrl1;
+  avr32_pm_oscctrl1_t           OSCCTRL1;
+} u_avr32_pm_oscctrl1_t;
+
+typedef union
+{
+  unsigned long                 oscctrl32;
+  avr32_pm_oscctrl32_t          OSCCTRL32;
+} u_avr32_pm_oscctrl32_t;
+
+typedef union
+{
+  unsigned long                 ier;
+  avr32_pm_ier_t                IER;
+} u_avr32_pm_ier_t;
+
+typedef union
+{
+  unsigned long                 idr;
+  avr32_pm_idr_t                IDR;
+} u_avr32_pm_idr_t;
+
+typedef union
+{
+  unsigned long                 icr;
+  avr32_pm_icr_t                ICR;
+} u_avr32_pm_icr_t;
+
+typedef union
+{
+  unsigned long                 gcctrl;
+  avr32_pm_gcctrl_t             GCCTRL;
+} u_avr32_pm_gcctrl_t;
+
+typedef union
+{
+  unsigned long                 rccr;
+  avr32_pm_rccr_t               RCCR;
+} u_avr32_pm_rccr_t;
+
+typedef union
+{
+  unsigned long                 bgcr;
+  avr32_pm_bgcr_t               BGCR;
+} u_avr32_pm_bgcr_t;
+
+typedef union
+{
+  unsigned long                 vregcr;
+  avr32_pm_vregcr_t             VREGCR;
+} u_avr32_pm_vregcr_t;
+
+typedef union
+{
+  unsigned long                 bod;
+  avr32_pm_bod_t                BOD;
+} u_avr32_pm_bod_t;
+
+//! @}
+
+
+/*! \brief Sets the mode of the oscillator 0.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
+ */
+static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
+{
+  // Read
+  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm-&gt;oscctrl0};
+  // Modify
+  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
+  // Write
+  pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
+}
+
+
+void pm_enable_osc0_ext_clock(volatile avr32_pm_t *pm)
+{
+  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
+}
+
+
+void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
+{
+  pm_set_osc0_mode(pm, (fosc0 &lt;  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
+                       (fosc0 &lt; 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
+                       (fosc0 &lt; 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
+                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
+}
+
+
+void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  pm_enable_clk0_no_wait(pm, startup);
+  pm_wait_for_clk0_ready(pm);
+}
+
+
+void pm_disable_clk0(volatile avr32_pm_t *pm)
+{
+  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
+}
+
+
+void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  // Read register
+  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm-&gt;oscctrl0};
+  // Modify
+  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
+  // Write back
+  pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
+
+  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
+}
+
+
+void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC0RDY_MASK));
+}
+
+
+/*! \brief Sets the mode of the oscillator 1.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
+ */
+static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
+{
+  // Read
+  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm-&gt;oscctrl1};
+  // Modify
+  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
+  // Write
+  pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
+}
+
+
+void pm_enable_osc1_ext_clock(volatile avr32_pm_t *pm)
+{
+  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
+}
+
+
+void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
+{
+  pm_set_osc1_mode(pm, (fosc1 &lt;  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
+                       (fosc1 &lt; 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
+                       (fosc1 &lt; 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
+                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
+}
+
+
+void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  pm_enable_clk1_no_wait(pm, startup);
+  pm_wait_for_clk1_ready(pm);
+}
+
+
+void pm_disable_clk1(volatile avr32_pm_t *pm)
+{
+  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC1EN_MASK;
+}
+
+
+void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  // Read register
+  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm-&gt;oscctrl1};
+  // Modify
+  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
+  // Write back
+  pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
+
+  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
+}
+
+
+void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC1RDY_MASK));
+}
+
+
+/*! \brief Sets the mode of the 32-kHz oscillator.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
+ */
+static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
+{
+  // Read
+  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm-&gt;oscctrl32};
+  // Modify
+  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
+  // Write
+  pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
+}
+
+
+void pm_enable_osc32_ext_clock(volatile avr32_pm_t *pm)
+{
+  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
+}
+
+
+void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
+{
+  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
+}
+
+
+void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  pm_enable_clk32_no_wait(pm, startup);
+  pm_wait_for_clk32_ready(pm);
+}
+
+
+void pm_disable_clk32(volatile avr32_pm_t *pm)
+{
+  pm-&gt;oscctrl32 &amp;= ~AVR32_PM_OSCCTRL32_OSC32EN_MASK;
+}
+
+
+void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  // Read register
+  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm-&gt;oscctrl32};
+  // Modify
+  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
+  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
+  // Write back
+  pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
+}
+
+
+void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC32RDY_MASK));
+}
+
+
+void pm_cksel(volatile avr32_pm_t *pm,
+              unsigned int pbadiv,
+              unsigned int pbasel,
+              unsigned int pbbdiv,
+              unsigned int pbbsel,
+              unsigned int hsbdiv,
+              unsigned int hsbsel)
+{
+  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
+
+  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
+  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
+  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
+  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
+  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
+  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
+  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
+  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
+
+  pm-&gt;cksel = u_avr32_pm_cksel.cksel;
+
+  // Wait for ckrdy bit and then clear it
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_CKRDY_MASK));
+}
+
+
+void pm_gc_setup(volatile avr32_pm_t *pm,
+                  unsigned int gc,
+                  unsigned int osc_or_pll, // Use Osc (=0) or PLL (=1)
+                  unsigned int pll_osc, // Sel Osc0/PLL0 or Osc1/PLL1
+                  unsigned int diven,
+                  unsigned int div)
+{
+  u_avr32_pm_gcctrl_t u_avr32_pm_gcctrl = {0};
+
+  u_avr32_pm_gcctrl.GCCTRL.oscsel = pll_osc;
+  u_avr32_pm_gcctrl.GCCTRL.pllsel = osc_or_pll;
+  u_avr32_pm_gcctrl.GCCTRL.diven  = diven;
+  u_avr32_pm_gcctrl.GCCTRL.div    = div;
+
+  pm-&gt;gcctrl[gc] = u_avr32_pm_gcctrl.gcctrl;
+}
+
+
+void pm_gc_enable(volatile avr32_pm_t *pm,
+                  unsigned int gc)
+{
+  pm-&gt;gcctrl[gc] |= AVR32_PM_GCCTRL_CEN_MASK;
+}
+
+
+void pm_gc_disable(volatile avr32_pm_t *pm,
+                   unsigned int gc)
+{
+  pm-&gt;gcctrl[gc] &amp;= ~AVR32_PM_GCCTRL_CEN_MASK;
+}
+
+
+void pm_pll_setup(volatile avr32_pm_t *pm,
+                  unsigned int pll,
+                  unsigned int mul,
+                  unsigned int div,
+                  unsigned int osc,
+                  unsigned int lockcount)
+{
+  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
+
+  u_avr32_pm_pll.PLL.pllosc   = osc;
+  u_avr32_pm_pll.PLL.plldiv   = div;
+  u_avr32_pm_pll.PLL.pllmul   = mul;
+  u_avr32_pm_pll.PLL.pllcount = lockcount;
+
+  pm-&gt;pll[pll] = u_avr32_pm_pll.pll;
+}
+
+
+void pm_pll_set_option(volatile avr32_pm_t *pm,
+                       unsigned int pll,
+                       unsigned int pll_freq,
+                       unsigned int pll_div2,
+                       unsigned int pll_wbwdisable)
+{
+  u_avr32_pm_pll_t u_avr32_pm_pll = {pm-&gt;pll[pll]};
+  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 &lt;&lt; 1) | (pll_wbwdisable &lt;&lt; 2);
+  pm-&gt;pll[pll] = u_avr32_pm_pll.pll;
+}
+
+
+unsigned int pm_pll_get_option(volatile avr32_pm_t *pm,
+                               unsigned int pll)
+{
+  return (pm-&gt;pll[pll] &amp; AVR32_PM_PLLOPT_MASK) &gt;&gt; AVR32_PM_PLLOPT_OFFSET;
+}
+
+
+void pm_pll_enable(volatile avr32_pm_t *pm,
+                  unsigned int pll)
+{
+  pm-&gt;pll[pll] |= AVR32_PM_PLLEN_MASK;
+}
+
+
+void pm_pll_disable(volatile avr32_pm_t *pm,
+                  unsigned int pll)
+{
+  pm-&gt;pll[pll] &amp;= ~AVR32_PM_PLLEN_MASK;
+}
+
+
+void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK0_MASK));
+}
+
+
+void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK1_MASK));
+}
+
+
+void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
+{
+  // Read
+  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm-&gt;mcctrl};
+  // Modify
+  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
+  // Write back
+  pm-&gt;mcctrl = u_avr32_pm_mcctrl.mcctrl;
+}
+
+
+void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
+{
+  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
+  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
+  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
+}
+
+
+void pm_bod_enable_irq(volatile avr32_pm_t *pm)
+{
+  pm-&gt;ier = AVR32_PM_IER_BODDET_MASK;
+}
+
+
+void pm_bod_disable_irq(volatile avr32_pm_t *pm)
+{
+  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
+
+  if (global_interrupt_enabled) Disable_global_interrupt();
+  pm-&gt;idr = AVR32_PM_IDR_BODDET_MASK;
+  pm-&gt;isr;
+  if (global_interrupt_enabled) Enable_global_interrupt();
+}
+
+
+void pm_bod_clear_irq(volatile avr32_pm_t *pm)
+{
+  pm-&gt;icr = AVR32_PM_ICR_BODDET_MASK;
+}
+
+
+unsigned long pm_bod_get_irq_status(volatile avr32_pm_t *pm)
+{
+  return ((pm-&gt;isr &amp; AVR32_PM_ISR_BODDET_MASK) != 0);
+}
+
+
+unsigned long pm_bod_get_irq_enable_bit(volatile avr32_pm_t *pm)
+{
+  return ((pm-&gt;imr &amp; AVR32_PM_IMR_BODDET_MASK) != 0);
+}
+
+
+unsigned long pm_bod_get_level(volatile avr32_pm_t *pm)
+{
+  return (pm-&gt;bod &amp; AVR32_PM_BOD_LEVEL_MASK) &gt;&gt; AVR32_PM_BOD_LEVEL_OFFSET;
+}
+
+
+unsigned long pm_read_gplp(volatile avr32_pm_t *pm, unsigned long gplp)
+{
+  return pm-&gt;gplp[gplp];
+}
+
+
+void pm_write_gplp(volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value)
+{
+  pm-&gt;gplp[gplp] = value;
+}

Added: trunk/src/platform/avr32/pm.h
===================================================================
--- trunk/src/platform/avr32/pm.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/pm.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,463 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Power Manager driver.
+ *
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _PM_H_
+#define _PM_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;preprocessor.h&quot;
+
+
+/*! \brief Sets the MCU in the specified sleep mode.
+ *
+ * \param mode Sleep mode:
+ *   \arg \c AVR32_PM_SMODE_IDLE: Idle;
+ *   \arg \c AVR32_PM_SMODE_FROZEN: Frozen;
+ *   \arg \c AVR32_PM_SMODE_STANDBY: Standby;
+ *   \arg \c AVR32_PM_SMODE_STOP: Stop;
+ *   \arg \c AVR32_PM_SMODE_SHUTDOWN: Shutdown (DeepStop);
+ *   \arg \c AVR32_PM_SMODE_STATIC: Static.
+ */
+#define SLEEP(mode)   {__asm__ __volatile__ (&quot;sleep &quot;STRINGZ(mode));}
+
+
+//! Input and output parameters when initializing PM clocks using pm_configure_clocks().
+typedef struct
+{
+  //! CPU frequency (input/output argument).
+  unsigned long cpu_f;
+
+  //! PBA frequency (input/output argument).
+  unsigned long pba_f;
+
+  //! Oscillator 0 frequency (board dependant) (input argument).
+  unsigned long osc0_f;
+
+  //! Oscillator 0 startup time: AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC (input argument).
+  unsigned long osc0_startup;
+} pm_freq_param_t;
+
+#define PM_FREQ_STATUS_FAIL   (-1)
+#define PM_FREQ_STATUS_OK     (0)
+
+
+/*! \brief Gets the MCU reset cause.
+ *
+ * \param pm Base address of the Power Manager instance (i.e. &amp;AVR32_PM).
+ *
+ * \return The MCU reset cause which can be masked with the
+ *         \c AVR32_PM_RCAUSE_x_MASK bit-masks to isolate specific causes.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ unsigned int pm_get_reset_cause(volatile avr32_pm_t *pm)
+{
+  return pm-&gt;rcause;
+}
+
+
+/*!
+ * \brief This function will enable the external clock mode of the oscillator 0.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc0_ext_clock(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the crystal mode of the oscillator 0.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param fosc0 Oscillator 0 crystal frequency (Hz)
+ */
+extern void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0);
+
+
+/*!
+ * \brief This function will enable the oscillator 0 to be used with a startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will disable the oscillator 0.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_disable_clk0(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 0 to be used with no startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 0 startup time, for which the function does not wait. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will wait until the Osc0 clock is ready.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the external clock mode of the oscillator 1.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc1_ext_clock(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the crystal mode of the oscillator 1.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param fosc1 Oscillator 1 crystal frequency (Hz)
+ */
+extern void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1);
+
+
+/*!
+ * \brief This function will enable the oscillator 1 to be used with a startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 1 startup time. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will disable the oscillator 1.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_disable_clk1(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 1 to be used with no startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 1 startup time, for which the function does not wait. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will wait until the Osc1 clock is ready.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the external clock mode of the 32-kHz oscillator.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc32_ext_clock(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the crystal mode of the 32-kHz oscillator.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc32_crystal(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 32 to be used with a startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 32 kHz startup time. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will disable the oscillator 32.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_disable_clk32(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 32 to be used with no startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 32 kHz startup time, for which the function does not wait. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will wait until the osc32 clock is ready.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will select all the power manager clocks.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pbadiv Peripheral Bus A clock divisor enable
+ * \param pbasel Peripheral Bus A select
+ * \param pbbdiv Peripheral Bus B clock divisor enable
+ * \param pbbsel Peripheral Bus B select
+ * \param hsbdiv High Speed Bus clock divisor enable (CPU clock = HSB clock)
+ * \param hsbsel High Speed Bus select (CPU clock = HSB clock )
+ */
+extern void pm_cksel(volatile avr32_pm_t *pm, unsigned int pbadiv, unsigned int pbasel, unsigned int pbbdiv, unsigned int pbbsel, unsigned int hsbdiv, unsigned int hsbsel);
+
+
+/*!
+ * \brief This function will setup a generic clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gc generic clock number (0 for gc0...)
+ * \param osc_or_pll Use OSC (=0) or PLL (=1)
+ * \param pll_osc Select Osc0/PLL0 or Osc1/PLL1
+ * \param diven Generic clock divisor enable
+ * \param div Generic clock divisor
+ */
+extern void pm_gc_setup(volatile avr32_pm_t *pm, unsigned int gc, unsigned int osc_or_pll, unsigned int pll_osc, unsigned int diven, unsigned int div);
+
+
+/*!
+ * \brief This function will enable a generic clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gc generic clock number (0 for gc0...)
+ */
+extern void pm_gc_enable(volatile avr32_pm_t *pm, unsigned int gc);
+
+
+/*!
+ * \brief This function will disable a generic clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gc generic clock number (0 for gc0...)
+ */
+extern void pm_gc_disable(volatile avr32_pm_t *pm, unsigned int gc);
+
+
+/*!
+ * \brief This function will setup a PLL.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ * \param mul PLL MUL in the PLL formula
+ * \param div PLL DIV in the PLL formula
+ * \param osc OSC number (0 for osc0, 1 for osc1)
+ * \param lockcount PLL lockount
+ */
+extern void pm_pll_setup(volatile avr32_pm_t *pm, unsigned int pll, unsigned int mul, unsigned int div, unsigned int osc, unsigned int lockcount);
+
+
+/*!
+ * \brief This function will set a PLL option.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ * \param pll_freq Set to 1 for VCO frequency range 80-180MHz, set to 0 for VCO frequency range 160-240Mhz.
+ * \param pll_div2 Divide the PLL output frequency by 2 (this settings does not change the FVCO value)
+ * \param pll_wbwdisable 1 Disable the Wide-Bandith Mode (Wide-Bandwith mode allow a faster startup time and out-of-lock time). 0 to enable the Wide-Bandith Mode.
+ */
+extern void pm_pll_set_option(volatile avr32_pm_t *pm, unsigned int pll, unsigned int  pll_freq, unsigned int  pll_div2, unsigned int  pll_wbwdisable);
+
+
+/*!
+ * \brief This function will get a PLL option.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ * \return       Option
+ */
+extern unsigned int pm_pll_get_option(volatile avr32_pm_t *pm, unsigned int pll);
+
+
+/*!
+ * \brief This function will enable a PLL.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ */
+extern void pm_pll_enable(volatile avr32_pm_t *pm, unsigned int pll);
+
+
+/*!
+ * \brief This function will disable a PLL.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ */
+extern void pm_pll_disable(volatile avr32_pm_t *pm, unsigned int pll);
+
+
+/*!
+ * \brief This function will wait for PLL0 locked
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will wait for PLL1 locked
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will switch the power manager main clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param clock Clock to be switched on. AVR32_PM_MCSEL_SLOW for RCOsc, AVR32_PM_MCSEL_OSC0 for Osc0, AVR32_PM_MCSEL_PLL0 for PLL0.
+ */
+extern void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock);
+
+
+/*!
+ * \brief Switch main clock to clock Osc0 (crystal mode)
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param fosc0 Oscillator 0 crystal frequency (Hz)
+ * \param startup Crystal 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
+ */
+extern void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup);
+
+
+/*! \brief Enables the Brown-Out Detector interrupt.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ */
+extern void pm_bod_enable_irq(volatile avr32_pm_t *pm);
+
+
+/*! \brief Disables the Brown-Out Detector interrupt.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ */
+extern void pm_bod_disable_irq(volatile avr32_pm_t *pm);
+
+
+/*! \brief Clears the Brown-Out Detector interrupt flag.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ */
+extern void pm_bod_clear_irq(volatile avr32_pm_t *pm);
+
+
+/*! \brief Gets the Brown-Out Detector interrupt flag.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ *
+ * \retval 0 No BOD interrupt.
+ * \retval 1 BOD interrupt pending.
+ */
+extern unsigned long pm_bod_get_irq_status(volatile avr32_pm_t *pm);
+
+
+/*! \brief Gets the Brown-Out Detector interrupt enable status.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ *
+ * \retval 0 BOD interrupt disabled.
+ * \retval 1 BOD interrupt enabled.
+ */
+extern unsigned long pm_bod_get_irq_enable_bit(volatile avr32_pm_t *pm);
+
+
+/*! \brief Gets the triggering threshold of the Brown-Out Detector.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ *
+ * \return Triggering threshold of the BOD. See the electrical characteristics
+ *         in the part datasheet for actual voltage levels.
+ */
+extern unsigned long pm_bod_get_level(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief Read the content of the PM GPLP registers
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gplp GPLP register index (0,1,... depending on the number of GPLP registers for a given part)
+ *
+ * \return The content of the chosen GPLP register.
+ */
+extern unsigned long pm_read_gplp(volatile avr32_pm_t *pm, unsigned long gplp);
+
+
+/*!
+ * \brief Write into the PM GPLP registers
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gplp GPLP register index (0,1,... depending on the number of GPLP registers for a given part)
+ * \param value Value to write
+ */
+extern void pm_write_gplp(volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value);
+
+
+/*! \brief Automatically configure the CPU, PBA, PBB, and HSB clocks
+ *         according to the user wishes.
+ *
+ * This function needs some parameters stored in a pm_freq_param_t structure:
+ *  - cpu_f and pba_f are the wanted frequencies,
+ *  - osc0_f is the oscillator 0 on-board frequency (e.g. FOSC0),
+ *  - osc0_startup is the oscillator 0 startup time (e.g. OSC0_STARTUP).
+ *
+ * The function will then configure the clocks using the following rules:
+ *  - It first try to find a valid PLL frequency (the highest possible value to avoid jitter) in order
+ *    to satisfy the CPU frequency,
+ *  - It optimizes the configuration depending the various divide stages,
+ *  - Then, the PBA frequency is configured from the CPU freq (PBA freq = CPU freq/(2 exp x)) so that
+ *    PBA max frequencies is always below 30MHz.
+ *  - Note that HSB and PBB are configured with the same frequency as CPU.
+ *  - Note also that the number of wait states of the flash read accesses is automatically set-up depending
+ *    the CPU frequency. As a consequence, the application needs the FLASHC driver to compile.
+ *
+ * The CPU, HSB and PBA frequencies programmed after configuration are stored back into cpu_f and pba_f.
+ *
+ * \param param    pointer on the configuration structure.
+ *
+ * \retval PM_FREQ_STATUS_OK    Mode successfully initialized.
+ * \retval PM_FREQ_STATUS_FAIL  The configuration can not be done.
+ */
+extern int pm_configure_clocks(pm_freq_param_t *param);
+
+
+/*! \brief Automatically configure the USB clock.
+ *
+ * USB clock is configured to 48MHz, using the PLL1 from the Oscillator0, assuming
+ * a 12 MHz crystal is connected to it.
+ */
+extern void pm_configure_usb_clock(void);
+
+
+#endif  // _PM_H_

Added: trunk/src/platform/avr32/pm_conf_clocks.c
===================================================================
--- trunk/src/platform/avr32/pm_conf_clocks.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/pm_conf_clocks.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,247 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Power Manager clocks configuration helper.
+ *
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &lt;string.h&gt;
+#if __GNUC__
+#  include &lt;sys/cpu.h&gt;
+#endif
+#include &quot;compiler.h&quot;
+#include &quot;pm.h&quot;
+
+
+extern void flashc_set_wait_state(unsigned int wait_state);
+
+
+#define PM_MAX_MUL                ((1 &lt;&lt; AVR32_PM_PLL0_PLLMUL_SIZE) - 1)
+
+
+int pm_configure_clocks(pm_freq_param_t *param)
+{
+  // Supported frequencies:
+  // Fosc0 mul div PLL div2_en cpu_f pba_f   Comment
+  //  12   15   1  192     1     12    12
+  //  12    9   3   40     1     20    20    PLL out of spec
+  //  12   15   1  192     1     24    12
+  //  12    9   1  120     1     30    15
+  //  12    9   3   40     0     40    20    PLL out of spec
+  //  12   15   1  192     1     48    12
+  //  12   15   1  192     1     48    24
+  //  12    8   1  108     1     54    27
+  //  12    9   1  120     1     60    15
+  //  12    9   1  120     1     60    30
+  //  12   10   1  132     1     66    16.5
+  //
+  unsigned long in_cpu_f  = param-&gt;cpu_f;
+  unsigned long in_osc0_f = param-&gt;osc0_f;
+  unsigned long mul, div, div2_en = 0, div2_cpu = 0, div2_pba = 0;
+  unsigned long pll_freq, rest;
+  Bool b_div2_pba, b_div2_cpu;
+
+  // Switch to external Oscillator 0
+  pm_switch_to_osc0(&amp;AVR32_PM, in_osc0_f, param-&gt;osc0_startup);
+
+  // Start with CPU freq config
+  if (in_cpu_f == in_osc0_f)
+  {
+    param-&gt;cpu_f = in_osc0_f;
+    param-&gt;pba_f = in_osc0_f;
+    return PM_FREQ_STATUS_OK;
+  }
+  else if (in_cpu_f &lt; in_osc0_f)
+  {
+    // TBD
+  }
+
+  rest = in_cpu_f % in_osc0_f;
+
+  for (div = 1; div &lt; 32; div++)
+  {
+    if ((div * rest) % in_osc0_f == 0)
+      break;
+  }
+  if (div == 32)
+    return PM_FREQ_STATUS_FAIL;
+
+  mul = (in_cpu_f * div) / in_osc0_f;
+
+  if (mul &gt; PM_MAX_MUL)
+    return PM_FREQ_STATUS_FAIL;
+
+  // export 2power from PLL div to div2_cpu
+  while (!(div % 2))
+  {
+    div /= 2;
+    div2_cpu++;
+  }
+
+  // Here we know the mul and div parameter of the PLL config.
+  // . Check out if the PLL has a valid in_cpu_f.
+  // . Try to have for the PLL frequency (VCO output) the highest possible value
+  //   to reduce jitter.
+  while (in_osc0_f * 2 * mul / div &lt; AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
+  {
+    if (2 * mul &gt; PM_MAX_MUL)
+      break;
+    mul *= 2;
+    div2_cpu++;
+  }
+
+  if (div2_cpu != 0)
+  {
+    div2_cpu--;
+    div2_en = 1;
+  }
+
+  pll_freq = in_osc0_f * mul / (div * (1 &lt;&lt; div2_en));
+
+  // Update real CPU Frequency
+  param-&gt;cpu_f = pll_freq / (1 &lt;&lt; div2_cpu);
+  mul--;
+
+  pm_pll_setup(&amp;AVR32_PM
+  , 0   // pll
+  , mul // mul
+  , div // div
+  , 0   // osc
+  , 16  // lockcount
+  );
+
+  pm_pll_set_option(&amp;AVR32_PM
+  , 0 // pll
+  // PLL clock is lower than 160MHz: need to set pllopt.
+  , (pll_freq &lt; 160000000) ? 1 : 0 // pll_freq
+  , div2_en // pll_div2
+  , 0 // pll_wbwdisable
+  );
+
+  rest = pll_freq;
+  while (rest &gt; AVR32_PM_PBA_MAX_FREQ ||
+         rest != param-&gt;pba_f)
+  {
+    div2_pba++;
+    rest = pll_freq / (1 &lt;&lt; div2_pba);
+    if (rest &lt; param-&gt;pba_f)
+      break;
+  }
+
+  // Update real PBA Frequency
+  param-&gt;pba_f = pll_freq / (1 &lt;&lt; div2_pba);
+
+#if __GNUC__
+  set_cpu_hz(param-&gt;pba_f);
+#endif
+
+  // Enable PLL0
+  pm_pll_enable(&amp;AVR32_PM, 0);
+
+  // Wait for PLL0 locked
+  pm_wait_for_pll0_locked(&amp;AVR32_PM);
+
+  if (div2_cpu)
+  {
+    b_div2_cpu = TRUE;
+    div2_cpu--;
+  }
+  else
+    b_div2_cpu = FALSE;
+
+  if (div2_pba)
+  {
+    b_div2_pba = TRUE;
+    div2_pba--;
+  }
+  else
+    b_div2_pba = FALSE;
+
+  pm_cksel(&amp;AVR32_PM
+  , b_div2_pba, div2_pba // PBA
+  , b_div2_cpu, div2_cpu // PBB
+  , b_div2_cpu, div2_cpu // HSB
+  );
+
+  if (param-&gt;cpu_f &gt; AVR32_FLASHC_FWS_0_MAX_FREQ)
+    flashc_set_wait_state(1);
+  else
+    flashc_set_wait_state(0);
+
+  pm_switch_to_clock(&amp;AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
+
+  return PM_FREQ_STATUS_OK;
+}
+
+
+void pm_configure_usb_clock(void)
+{
+  volatile avr32_pm_t *pm = &amp;AVR32_PM;
+
+  // Set PLL1 @ 96 MHz from Osc0: 12MHz*(7+1)/1 = 96MHz.
+  // In order to work, we need to go above 80MHz, then divide.
+  pm_pll_setup(pm, 1,   // pll
+                   7,   // mul
+                   1,   // div
+                   0,   // osc
+                   16); // lockcount
+
+  pm_pll_set_option(pm, 1,  // pll1
+                        1,  // Choose the range 80-180MHz.
+                        1,  // div2
+                        0); // wbwdisable
+
+  // Enable PLL1.
+  pm_pll_enable(pm, 1);
+
+  // Wait for PLL1 locked.
+  pm_wait_for_pll1_locked(pm);
+
+  // Setup USB GCLK.
+  pm_gc_setup(pm, AVR32_PM_GCLK_USBB, // gc
+                  1,                  // osc_or_pll: use Osc (if 0) or PLL (if 1)
+                  1,                  // pll_osc: select Osc0/PLL0 or Osc1/PLL1
+                  0,                  // diven
+                  0);                 // div
+
+  // Enable USB GCLK.
+  pm_gc_enable(pm, AVR32_PM_GCLK_USBB);
+}

Added: trunk/src/platform/avr32/preprocessor.h
===================================================================
--- trunk/src/platform/avr32/preprocessor.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/preprocessor.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,52 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _PREPROCESSOR_H_
+#define _PREPROCESSOR_H_
+
+#include &quot;tpaste.h&quot;
+#include &quot;stringz.h&quot;
+#include &quot;mrepeat.h&quot;
+
+
+#endif  // _PREPROCESSOR_H_

Added: trunk/src/platform/avr32/stacks.h
===================================================================
--- trunk/src/platform/avr32/stacks.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/stacks.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,9 @@
+// Stack size definitions
+
+#ifndef __STACKS_H__
+#define __STACKS_H__
+
+#define  STACK_SIZE       256
+#define  STACK_SIZE_TOTAL ( STACK_SIZE )
+
+#endif

Added: trunk/src/platform/avr32/stringz.h
===================================================================
--- trunk/src/platform/avr32/stringz.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/stringz.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,72 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor stringizing utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _STRINGZ_H_
+#define _STRINGZ_H_
+
+
+/*! \brief Stringize.
+ *
+ * Stringize a preprocessing token, this token being allowed to be \#defined.
+ *
+ * May be used only within macros with the token passed as an argument if the token is \#defined.
+ *
+ * For example, writing STRINGZ(PIN) within a macro \#defined by PIN_NAME(PIN)
+ * and invoked as PIN_NAME(PIN0) with PIN0 \#defined as A0 is equivalent to
+ * writing &quot;A0&quot;.
+ */
+#define STRINGZ(x)                                #x
+
+/*! \brief Absolute stringize.
+ *
+ * Stringize a preprocessing token, this token being allowed to be \#defined.
+ *
+ * No restriction of use if the token is \#defined.
+ *
+ * For example, writing ASTRINGZ(PIN0) anywhere with PIN0 \#defined as A0 is
+ * equivalent to writing &quot;A0&quot;.
+ */
+#define ASTRINGZ(x)                               STRINGZ(x)
+
+
+#endif  // _STRINGZ_H_

Added: trunk/src/platform/avr32/tpaste.h
===================================================================
--- trunk/src/platform/avr32/tpaste.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/tpaste.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,92 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor token pasting utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _TPASTE_H_
+#define _TPASTE_H_
+
+
+/*! \name Token Paste
+ *
+ * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
+ *
+ * May be used only within macros with the tokens passed as arguments if the tokens are \#defined.
+ *
+ * For example, writing TPASTE2(U, WIDTH) within a macro \#defined by
+ * UTYPE(WIDTH) and invoked as UTYPE(UL_WIDTH) with UL_WIDTH \#defined as 32 is
+ * equivalent to writing U32.
+ */
+//! @{
+#define TPASTE2( a, b)                            a##b
+#define TPASTE3( a, b, c)                         a##b##c
+#define TPASTE4( a, b, c, d)                      a##b##c##d
+#define TPASTE5( a, b, c, d, e)                   a##b##c##d##e
+#define TPASTE6( a, b, c, d, e, f)                a##b##c##d##e##f
+#define TPASTE7( a, b, c, d, e, f, g)             a##b##c##d##e##f##g
+#define TPASTE8( a, b, c, d, e, f, g, h)          a##b##c##d##e##f##g##h
+#define TPASTE9( a, b, c, d, e, f, g, h, i)       a##b##c##d##e##f##g##h##i
+#define TPASTE10(a, b, c, d, e, f, g, h, i, j)    a##b##c##d##e##f##g##h##i##j
+//! @}
+
+/*! \name Absolute Token Paste
+ *
+ * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
+ *
+ * No restriction of use if the tokens are \#defined.
+ *
+ * For example, writing ATPASTE2(U, UL_WIDTH) anywhere with UL_WIDTH \#defined
+ * as 32 is equivalent to writing U32.
+ */
+//! @{
+#define ATPASTE2( a, b)                           TPASTE2( a, b)
+#define ATPASTE3( a, b, c)                        TPASTE3( a, b, c)
+#define ATPASTE4( a, b, c, d)                     TPASTE4( a, b, c, d)
+#define ATPASTE5( a, b, c, d, e)                  TPASTE5( a, b, c, d, e)
+#define ATPASTE6( a, b, c, d, e, f)               TPASTE6( a, b, c, d, e, f)
+#define ATPASTE7( a, b, c, d, e, f, g)            TPASTE7( a, b, c, d, e, f, g)
+#define ATPASTE8( a, b, c, d, e, f, g, h)         TPASTE8( a, b, c, d, e, f, g, h)
+#define ATPASTE9( a, b, c, d, e, f, g, h, i)      TPASTE9( a, b, c, d, e, f, g, h, i)
+#define ATPASTE10(a, b, c, d, e, f, g, h, i, j)   TPASTE10(a, b, c, d, e, f, g, h, i, j)
+//! @}
+
+
+#endif  // _TPASTE_H_

Added: trunk/src/platform/avr32/trampoline.s
===================================================================
--- trunk/src/platform/avr32/trampoline.s	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/trampoline.s	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,74 @@
+/* This file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief AVR32 UC3 ISP trampoline.
+ *
+ * In order to be able to program a project with both BatchISP and JTAGICE mkII
+ * without having to take the general-purpose fuses into consideration, add this
+ * file to the project and change the program entry point to _trampoline.
+ *
+ * The pre-programmed ISP will be erased if JTAGICE mkII is used.
+ *
+ * - Compiler:           GNU GCC for AVR32
+ * - Supported devices:  All AVR32UC devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &quot;conf_isp.h&quot;
+
+
+//! @{
+//! \verbatim
+
+
+  // This must be linked @ 0x80000000 if it is to be run upon reset.
+  .section  .reset, &quot;ax&quot;, @progbits
+  .extern _stext
+
+  .global _trampoline
+  .type _trampoline, @function
+_trampoline:
+  // Jump to program start.
+  rjmp    program_start
+
+  .org  PROGRAM_START_OFFSET
+program_start:
+  // Jump to the C runtime startup routine.
+  lda.w   pc, _stext
+
+
+//! \endverbatim
+//! @}

Added: trunk/src/platform/avr32/type.h
===================================================================
--- trunk/src/platform/avr32/type.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/type.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,22 @@
+#ifndef __TYPE_H__
+#define __TYPE_H__
+
+#ifndef NULL
+#define NULL    ((void *)0)
+#endif
+
+typedef unsigned char  BYTE;
+typedef unsigned short WORD;
+typedef unsigned long  DWORD;
+typedef unsigned int   BOOL;
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned long u32;
+typedef signed long s32;
+typedef unsigned long long u64;
+typedef signed long long s64;
+
+#endif

Added: trunk/src/platform/avr32/usart.c
===================================================================
--- trunk/src/platform/avr32/usart.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/usart.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,839 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief USART driver for AVR32 UC3.
+ *
+ * This file contains basic functions for the AVR32 USART, with support for all
+ * modes, settings and clock speeds.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a USART module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &quot;compiler.h&quot;
+#include &quot;usart.h&quot;
+
+
+//------------------------------------------------------------------------------
+/*! \name Private Functions
+ */
+//! @{
+
+
+/*! \brief Checks if the USART is in multidrop mode.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if the USART is in multidrop mode, otherwise \c 0.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+static __inline__ int usart_mode_is_multidrop(volatile avr32_usart_t *usart)
+{
+  return ((usart-&gt;mr &gt;&gt; AVR32_USART_MR_PAR_OFFSET) &amp; AVR32_USART_MR_PAR_MULTI) == AVR32_USART_MR_PAR_MULTI;
+}
+
+
+/*! \brief Calculates a clock divider (\e CD) and a fractional part (\e FP) for
+ *         the USART asynchronous modes to generate a baud rate as close as
+ *         possible to the baud rate set point.
+ *
+ * Baud rate calculation:
+ * \f$ Baudrate = \frac{SelectedClock}{Over \times (CD + \frac{FP}{8})} \f$, \e Over being 16 or 8.
+ * The maximal oversampling is selected if it allows to generate a baud rate close to the set point.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate set point.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Baud rate successfully initialized.
+ * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
+ */
+static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
+{
+  unsigned int over = (pba_hz &gt;= 16 * baudrate) ? 16 : 8;
+  unsigned int cd = pba_hz / (over * baudrate);
+  unsigned int fp = ((1 &lt;&lt; AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate) -
+                    (1 &lt;&lt; AVR32_USART_BRGR_FP_SIZE) * cd;
+
+  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~(AVR32_USART_MR_USCLKS_MASK |
+                             AVR32_USART_MR_SYNC_MASK |
+                             AVR32_USART_MR_OVER_MASK)) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) &lt;&lt; AVR32_USART_MR_OVER_OFFSET;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET |
+                fp &lt;&lt; AVR32_USART_BRGR_FP_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Calculates a clock divider (\e CD) for the USART synchronous master
+ *         modes to generate a baud rate as close as possible to the baud rate
+ *         set point.
+ *
+ * Baud rate calculation:
+ * \f$ Baudrate = \frac{SelectedClock}{CD} \f$.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate set point.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Baud rate successfully initialized.
+ * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
+ */
+static int usart_set_sync_master_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
+{
+  unsigned int cd = (pba_hz + baudrate / 2) / baudrate;
+
+  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              AVR32_USART_MR_SYNC_MASK;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Selects the SCK pin as the source of baud rate for the USART
+ *         synchronous slave modes.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS  Baud rate successfully initialized.
+ */
+static int usart_set_sync_slave_baudrate(volatile avr32_usart_t *usart)
+{
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_SCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              AVR32_USART_MR_SYNC_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Calculates a clock divider (\e CD) for the USART ISO7816 mode to
+ *         generate an ISO7816 clock as close as possible to the clock set point.
+ *
+ * ISO7816 clock calculation:
+ * \f$ Clock = \frac{SelectedClock}{CD} \f$.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param clock   ISO7816 clock set point.
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        ISO7816 clock successfully initialized.
+ * \retval USART_INVALID_INPUT  ISO7816 clock set point is out of range for the given input clock frequency.
+ */
+static int usart_set_iso7816_clock(volatile avr32_usart_t *usart, unsigned int clock, unsigned long pba_hz)
+{
+  unsigned int cd = (pba_hz + clock / 2) / clock;
+
+  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~(AVR32_USART_MR_USCLKS_MASK |
+                             AVR32_USART_MR_SYNC_MASK |
+                             AVR32_USART_MR_OVER_MASK)) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              AVR32_USART_MR_OVER_X16 &lt;&lt; AVR32_USART_MR_OVER_OFFSET;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+#ifdef AVR32_USART_400_H_INCLUDED
+
+
+/*! \brief Calculates a clock divider (\e CD) for the USART SPI master mode to
+ *         generate a baud rate as close as possible to the baud rate set point.
+ *
+ * Baud rate calculation:
+ * \f$ Baudrate = \frac{SelectedClock}{CD} \f$.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate set point.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Baud rate successfully initialized.
+ * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
+ */
+static int usart_set_spi_master_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
+{
+  unsigned int cd = (pba_hz + baudrate / 2) / baudrate;
+
+  if (cd &lt; 4 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Selects the SCK pin as the source of baud rate for the USART SPI
+ *         slave mode.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS  Baud rate successfully initialized.
+ */
+static int usart_set_spi_slave_baudrate(volatile avr32_usart_t *usart)
+{
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_SCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+#endif
+
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+/*! \name Initialization Functions
+ */
+//! @{
+
+
+void usart_reset(volatile avr32_usart_t *usart)
+{
+  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
+
+  // Disable all USART interrupts.
+  // Interrupts needed should be set explicitly on every reset.
+  if (global_interrupt_enabled) Disable_global_interrupt();
+  usart-&gt;idr = 0xFFFFFFFF;
+  usart-&gt;csr;
+  if (global_interrupt_enabled) Enable_global_interrupt();
+
+  // Reset mode and other registers that could cause unpredictable behavior after reset.
+  usart-&gt;mr = 0;
+  usart-&gt;rtor = 0;
+  usart-&gt;ttgr = 0;
+
+  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
+  // reset status bits and turn off DTR and RTS.
+  usart-&gt;cr = AVR32_USART_CR_RSTRX_MASK   |
+              AVR32_USART_CR_RSTTX_MASK   |
+              AVR32_USART_CR_RSTSTA_MASK  |
+              AVR32_USART_CR_RSTIT_MASK   |
+              AVR32_USART_CR_RSTNACK_MASK |
+              AVR32_USART_CR_DTRDIS_MASK  |
+              AVR32_USART_CR_RTSDIS_MASK;
+}
+
+
+int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_async_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1, 1.5 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_rs232_tx_only(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_sync_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  // Setup complete; enable communication.
+  // Enable only output as input is not possible in synchronous mode without
+  // transferring clock.
+  usart-&gt;cr = AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_hw_handshaking(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set hardware handshaking mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_HARDWARE &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_modem(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set modem mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_MODEM &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_sync_master(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_sync_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+              AVR32_USART_MR_CLKO_MASK;
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_sync_slave(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_sync_slave_baudrate(usart) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_rs485(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set RS485 mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_RS485 &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_IrDA(volatile avr32_usart_t *usart, const usart_options_t *opt,
+                    long pba_hz, unsigned char irda_filter)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set IrDA filter.
+  usart-&gt;ifr = irda_filter;
+
+  // Set IrDA mode and activate filtering of input.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MODE_IRDA &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+              AVR32_USART_MR_FILTER_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_iso7816(volatile avr32_usart_t *usart, const usart_iso7816_options_t *opt, int t, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;paritytype &gt; 1)
+    return USART_INVALID_INPUT;
+
+  if (t == 0)
+  {
+    // Set USART mode to ISO7816, T=0.
+    // The T=0 protocol always uses 2 stop bits.
+    usart-&gt;mr = AVR32_USART_MR_MODE_ISO7816_T0 &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+                AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET |
+                opt-&gt;bit_order &lt;&lt; AVR32_USART_MR_MSBF_OFFSET; // Allow MSBF in T=0.
+  }
+  else if (t == 1)
+  {
+    // Only LSB first in the T=1 protocol.
+    // max_iterations field is only used in T=0 mode.
+    if (opt-&gt;bit_order != 0 ||
+        opt-&gt;max_iterations != 0)
+      return USART_INVALID_INPUT;
+
+    // Set USART mode to ISO7816, T=1.
+    // The T=1 protocol always uses 1 stop bit.
+    usart-&gt;mr = AVR32_USART_MR_MODE_ISO7816_T1 &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+                AVR32_USART_MR_NBSTOP_1 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+  }
+  else
+    return USART_INVALID_INPUT;
+
+  if (usart_set_iso7816_clock(usart, opt-&gt;iso7816_hz, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set FIDI register: bit rate = selected clock/FI_DI_ratio/16.
+  usart-&gt;fidi = opt-&gt;fidi_ratio;
+
+  // Set ISO7816 spesific options in the MODE register.
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               AVR32_USART_MR_CLKO_MASK | // Enable clock output.
+               opt-&gt;inhibit_nack &lt;&lt; AVR32_USART_MR_INACK_OFFSET |
+               opt-&gt;dis_suc_nack &lt;&lt; AVR32_USART_MR_DSNACK_OFFSET |
+               opt-&gt;max_iterations &lt;&lt; AVR32_USART_MR_MAX_ITERATION_OFFSET;
+
+  // Setup complete; enable the receiver by default.
+  usart_iso7816_enable_receiver(usart);
+
+  return USART_SUCCESS;
+}
+
+
+#ifdef AVR32_USART_400_H_INCLUDED
+
+
+int usart_init_spi_master(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;spimode &gt; 3 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_spi_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= AVR32_USART_MR_MODE_SPI_MASTER &lt;&lt; AVR32_USART_MR_MODE_OFFSET | // SPI master mode.
+               ((opt-&gt;spimode &amp; 0x1) ^ 0x1) &lt;&lt; AVR32_USART_MR_SYNC_OFFSET |   // SPI clock phase.
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET |             // Channel mode.
+               (opt-&gt;spimode &gt;&gt; 1) &lt;&lt; AVR32_USART_MR_MSBF_OFFSET |            // SPI clock polarity.
+               AVR32_USART_MR_CLKO_MASK;                                      // Drive SCK pin.
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_spi_slave(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;spimode &gt; 3 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_spi_slave_baudrate(usart) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= AVR32_USART_MR_MODE_SPI_SLAVE &lt;&lt; AVR32_USART_MR_MODE_OFFSET |  // SPI slave mode.
+               ((opt-&gt;spimode &amp; 0x1) ^ 0x1) &lt;&lt; AVR32_USART_MR_SYNC_OFFSET |   // SPI clock phase.
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET |             // Channel mode.
+               (opt-&gt;spimode &gt;&gt; 1) &lt;&lt; AVR32_USART_MR_MSBF_OFFSET;             // SPI clock polarity.
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+#endif
+
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+#ifdef AVR32_USART_400_H_INCLUDED
+
+
+/*! \name SPI Control Functions
+ */
+//! @{
+
+
+int usart_spi_selectChip(volatile avr32_usart_t *usart)
+{
+  // Force the SPI chip select.
+  usart-&gt;cr = AVR32_USART_CR_RTSEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_spi_unselectChip(volatile avr32_usart_t *usart)
+{
+  int timeout = USART_DEFAULT_TIMEOUT;
+
+  do
+  {
+    if (!timeout--) return USART_FAILURE;
+  } while (!usart_tx_empty(usart));
+
+  // Release the SPI chip select.
+  usart-&gt;cr = AVR32_USART_CR_RTSDIS_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+//! @}
+
+
+#endif
+
+
+//------------------------------------------------------------------------------
+/*! \name Transmit/Receive Functions
+ */
+//! @{
+
+
+int usart_send_address(volatile avr32_usart_t *usart, int address)
+{
+  // Check if USART is in multidrop / RS485 mode.
+  if (!usart_mode_is_multidrop(usart)) return USART_MODE_FAULT;
+
+  // Prepare to send an address.
+  usart-&gt;cr = AVR32_USART_CR_SENDA_MASK;
+
+  // Write the address to TX.
+  usart_bw_write_char(usart, address);
+
+  return USART_SUCCESS;
+}
+
+
+int usart_write_char(volatile avr32_usart_t *usart, int c)
+{
+  if (usart_tx_ready(usart))
+  {
+    usart-&gt;thr = (c &lt;&lt; AVR32_USART_THR_TXCHR_OFFSET) &amp; AVR32_USART_THR_TXCHR_MASK;
+    return USART_SUCCESS;
+  }
+  else
+    return USART_TX_BUSY;
+}
+
+
+int usart_putchar(volatile avr32_usart_t *usart, int c)
+{
+  while (usart_write_char(usart, c) != USART_SUCCESS);
+  return USART_SUCCESS;
+}
+
+
+int usart_read_char(volatile avr32_usart_t *usart, int *c)
+{
+  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
+  // would mean that an address char has been received.
+  if (usart-&gt;csr &amp; (AVR32_USART_CSR_OVRE_MASK |
+                    AVR32_USART_CSR_FRAME_MASK |
+                    AVR32_USART_CSR_PARE_MASK))
+    return USART_RX_ERROR;
+
+  // No error; if we really did receive a char, read it and return SUCCESS.
+  if (usart_test_hit(usart))
+  {
+    *c = (usart-&gt;rhr &amp; AVR32_USART_RHR_RXCHR_MASK) &gt;&gt; AVR32_USART_RHR_RXCHR_OFFSET;
+    return USART_SUCCESS;
+  }
+  else
+    return USART_RX_EMPTY;
+}
+
+
+int usart_getchar(volatile avr32_usart_t *usart)
+{
+  int c, ret;
+
+  while ((ret = usart_read_char(usart, &amp;c)) == USART_RX_EMPTY);
+
+  if (ret == USART_RX_ERROR)
+    return USART_FAILURE;
+
+  return c;
+}
+
+
+void usart_write_line(volatile avr32_usart_t *usart, const char *string)
+{
+  while (*string != '\0')
+    usart_putchar(usart, *string++);
+}
+
+
+int usart_get_echo_line(volatile avr32_usart_t *usart)
+{
+  int rx_char;
+  int retval = USART_SUCCESS;
+
+  while (1)
+  {
+    rx_char = usart_getchar(usart);
+    if (rx_char == USART_FAILURE)
+    {
+      usart_write_line(usart, &quot;Error!!!\n&quot;);
+      break;
+    }
+    if (rx_char == '\x03')
+    {
+      retval = USART_FAILURE;
+      break;
+    }
+    usart_putchar(usart, rx_char);
+    if (rx_char == '\r')
+    {
+      usart_putchar(usart, '\n');
+      break;
+    }
+  }
+
+  return retval;
+}
+
+
+//! @}

Added: trunk/src/platform/avr32/usart.h
===================================================================
--- trunk/src/platform/avr32/usart.h	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/avr32/usart.h	2008-12-13 23:31:40 UTC (rev 134)
@@ -0,0 +1,606 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief USART driver for AVR32 UC3.
+ *
+ * This file contains basic functions for the AVR32 USART, with support for all
+ * modes, settings and clock speeds.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a USART module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _USART_H_
+#define _USART_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+
+
+/*! \name Return Values
+ */
+//! @{
+#define USART_SUCCESS           0 //!&lt; Successful completion.
+#define USART_FAILURE          -1 //!&lt; Failure because of some unspecified reason.
+#define USART_INVALID_INPUT     1 //!&lt; Input value out of range.
+#define USART_INVALID_ARGUMENT -1 //!&lt; Argument value out of range.
+#define USART_TX_BUSY           2 //!&lt; Transmitter was busy.
+#define USART_RX_EMPTY          3 //!&lt; Nothing was received.
+#define USART_RX_ERROR          4 //!&lt; Transmission error occurred.
+#define USART_MODE_FAULT        5 //!&lt; USART not in the appropriate mode.
+//! @}
+
+//! Default time-out value (number of attempts).
+#define USART_DEFAULT_TIMEOUT   10000
+
+/*! \name Parity Settings
+ */
+//! @{
+#define USART_EVEN_PARITY       AVR32_USART_MR_PAR_EVEN   //!&lt; Use even parity on character transmission.
+#define USART_ODD_PARITY        AVR32_USART_MR_PAR_ODD    //!&lt; Use odd parity on character transmission.
+#define USART_SPACE_PARITY      AVR32_USART_MR_PAR_SPACE  //!&lt; Use a space as parity bit.
+#define USART_MARK_PARITY       AVR32_USART_MR_PAR_MARK   //!&lt; Use a mark as parity bit.
+#define USART_NO_PARITY         AVR32_USART_MR_PAR_NONE   //!&lt; Don't use a parity bit.
+#define USART_MULTIDROP_PARITY  AVR32_USART_MR_PAR_MULTI  //!&lt; Parity bit is used to flag address characters.
+//! @}
+
+/*! \name Stop Bits Settings
+ */
+//! @{
+#define USART_1_STOPBIT         AVR32_USART_MR_NBSTOP_1   //!&lt; Use 1 stop bit.
+#define USART_1_5_STOPBITS      AVR32_USART_MR_NBSTOP_1_5 //!&lt; Use 1.5 stop bits.
+#define USART_2_STOPBITS        AVR32_USART_MR_NBSTOP_2   //!&lt; Use 2 stop bits (for more, just give the number of bits).
+//! @}
+
+/*! \name Channel Modes
+ */
+//! @{
+#define USART_NORMAL_CHMODE     AVR32_USART_MR_CHMODE_NORMAL      //!&lt; Normal communication.
+#define USART_AUTO_ECHO         AVR32_USART_MR_CHMODE_ECHO        //!&lt; Echo data.
+#define USART_LOCAL_LOOPBACK    AVR32_USART_MR_CHMODE_LOCAL_LOOP  //!&lt; Local loopback.
+#define USART_REMOTE_LOOPBACK   AVR32_USART_MR_CHMODE_REMOTE_LOOP //!&lt; Remote loopback.
+//! @}
+
+
+//! Input parameters when initializing RS232 and similar modes.
+typedef struct
+{
+  //! Set baud rate of the USART (unused in slave modes).
+  unsigned long baudrate;
+
+  //! Number of bits to transmit as a character (5 to 9).
+  unsigned char charlength;
+
+  //! How to calculate the parity bit: \ref USART_EVEN_PARITY, \ref USART_ODD_PARITY,
+  //! \ref USART_SPACE_PARITY, \ref USART_MARK_PARITY, \ref USART_NO_PARITY or
+  //! \ref USART_MULTIDROP_PARITY.
+  unsigned char paritytype;
+
+  //! Number of stop bits between two characters: \ref USART_1_STOPBIT,
+  //! \ref USART_1_5_STOPBITS, \ref USART_2_STOPBITS or any number from 3 to 257
+  //! which will result in a time guard period of that length between characters.
+  //! \note \ref USART_1_5_STOPBITS is supported in asynchronous modes only.
+  unsigned short stopbits;
+
+  //! Run the channel in testmode: \ref USART_NORMAL_CHMODE, \ref USART_AUTO_ECHO,
+  //! \ref USART_LOCAL_LOOPBACK or \ref USART_REMOTE_LOOPBACK.
+  unsigned char channelmode;
+} usart_options_t;
+
+//! Input parameters when initializing ISO7816 mode.
+typedef struct
+{
+  //! Set the frequency of the ISO7816 clock.
+  unsigned long iso7816_hz;
+
+  //! The number of ISO7816 clock ticks in every bit period (1 to 2047, 0 = disable clock).
+  //! Bit rate = \ref iso7816_hz / \ref fidi_ratio.
+  unsigned short fidi_ratio;
+
+  //! How to calculate the parity bit: \ref USART_EVEN_PARITY for normal mode or
+  //! \ref USART_ODD_PARITY for inverse mode.
+  unsigned char paritytype;
+
+  //! Inhibit Non Acknowledge:\n
+  //!   - 0: the NACK is generated;\n
+  //!   - 1: the NACK is not generated.
+  //!
+  //! \note This bit will be used only in ISO7816 mode, protocol T = 0 receiver.
+  int inhibit_nack;
+
+  //! Disable successive NACKs.
+  //! Successive parity errors are counted up to the value in the \ref max_iterations field.
+  //! These parity errors generate a NACK on the ISO line. As soon as this value is reached,
+  //! no addititional NACK is sent on the ISO line. The ITERATION flag is asserted.
+  int dis_suc_nack;
+
+  //! Max number of repetitions (0 to 7).
+  unsigned char max_iterations;
+
+  //! Bit order in transmitted characters:\n
+  //!   - 0: LSB first;\n
+  //!   - 1: MSB first.
+  int bit_order;
+} usart_iso7816_options_t;
+
+#ifdef AVR32_USART_400_H_INCLUDED
+
+//! Input parameters when initializing SPI mode.
+typedef struct
+{
+  //! Set the frequency of the SPI clock (unused in slave mode).
+  unsigned long baudrate;
+
+  //! Number of bits to transmit as a character (5 to 9).
+  unsigned char charlength;
+
+  //! Which SPI mode to use.
+  unsigned char spimode;
+
+  //! Run the channel in testmode: \ref USART_NORMAL_CHMODE, \ref USART_AUTO_ECHO,
+  //! \ref USART_LOCAL_LOOPBACK or \ref USART_REMOTE_LOOPBACK.
+  unsigned char channelmode;
+} usart_spi_options_t;
+
+#endif
+
+
+//------------------------------------------------------------------------------
+/*! \name Initialization Functions
+ */
+//! @{
+
+/*! \brief Resets the USART and disables TX and RX.
+ *
+ * \param usart Base address of the USART instance.
+ */
+extern void usart_reset(volatile avr32_usart_t *usart);
+
+/*! \brief Sets up the USART to use the standard RS232 protocol.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the standard RS232 protocol in TX-only mode.
+ *
+ * Compared to \ref usart_init_rs232, this function allows very high baud rates
+ * (up to \a pba_hz instead of \a pba_hz / \c 8) at the expense of full duplex.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ *
+ * \note The \c 1.5 stop bit is not supported in this mode.
+ */
+extern int usart_init_rs232_tx_only(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use hardware handshaking.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ *
+ * \note \ref usart_init_rs232 does not need to be invoked before this function.
+ */
+extern int usart_init_hw_handshaking(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the modem protocol, activating dedicated inputs/outputs.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_modem(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use a synchronous RS232-like protocol in master mode.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_sync_master(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use a synchronous RS232-like protocol in slave mode.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_sync_slave(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the RS485 protocol.
+ *
+ * \param usart       Base address of the USART instance.
+ * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz      USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_rs485(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the IrDA protocol.
+ *
+ * \param usart       Base address of the USART instance.
+ * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz      USART module input clock frequency (PBA clock, Hz).
+ * \param irda_filter Counter used to distinguish received ones from zeros.
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_IrDA(volatile avr32_usart_t *usart, const usart_options_t *opt,
+                           long pba_hz, unsigned char irda_filter);
+
+/*! \brief Sets up the USART to use the ISO7816 T=0 or T=1 smartcard protocols.
+ *
+ * The receiver is enabled by default. \ref usart_iso7816_enable_receiver and
+ * \ref usart_iso7816_enable_transmitter can be called to change the half-duplex
+ * communication direction.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up ISO7816 communication (see \ref usart_iso7816_options_t).
+ * \param t       ISO7816 mode to use (T=0 or T=1).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_iso7816(volatile avr32_usart_t *usart, const usart_iso7816_options_t *opt, int t, long pba_hz);
+
+#ifdef AVR32_USART_400_H_INCLUDED
+
+/*! \brief Sets up the USART to use the SPI master mode.
+ *
+ * \ref usart_spi_selectChip and \ref usart_spi_unselectChip can be called to
+ * select or unselect the SPI slave chip.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up SPI mode (see \ref usart_spi_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_spi_master(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the SPI slave mode.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up SPI mode (see \ref usart_spi_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_spi_slave(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz);
+
+#endif
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+/*! \name Read and Reset Error Status Bits
+ */
+//! @{
+
+/*! \brief Resets the error status.
+ *
+ * This function resets the status bits indicating that a parity error,
+ * framing error or overrun has occurred. The RXBRK bit, indicating
+ * a start/end of break condition on the RX line, is also reset.
+ *
+ * \param usart Base address of the USART instance.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_reset_status(volatile avr32_usart_t *usart)
+{
+  usart-&gt;cr = AVR32_USART_CR_RSTSTA_MASK;
+}
+
+/*! \brief Checks if a parity error has occurred since last status reset.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if a parity error has been detected, otherwise \c 0.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_parity_error(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_PARE_MASK) != 0;
+}
+
+/*! \brief Checks if a framing error has occurred since last status reset.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if a framing error has been detected, otherwise \c 0.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_framing_error(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_FRAME_MASK) != 0;
+}
+
+/*! \brief Checks if an overrun error has occurred since last status reset.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if a overrun error has been detected, otherwise \c 0.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_overrun_error(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_OVRE_MASK) != 0;
+}
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+/*! \name ISO7816 Control Functions
+ */
+//! @{
+
+/*! \brief Enables the ISO7816 receiver.
+ *
+ * The ISO7816 transmitter is disabled.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_iso7816_enable_receiver(volatile avr32_usart_t *usart)
+{
+  usart-&gt;cr = AVR32_USART_CR_TXDIS_MASK | AVR32_USART_CR_RXEN_MASK;
+}
+
+/*! \brief Enables the ISO7816 transmitter.
+ *
+ * The ISO7816 receiver is disabled.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_iso7816_enable_transmitter(volatile avr32_usart_t *usart)
+{
+  usart-&gt;cr = AVR32_USART_CR_RXDIS_MASK | AVR32_USART_CR_TXEN_MASK;
+}
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+#ifdef AVR32_USART_400_H_INCLUDED
+
+/*! \name SPI Control Functions
+ */
+//! @{
+
+/*! \brief Selects SPI slave chip.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS        Success.
+ */
+extern int usart_spi_selectChip(volatile avr32_usart_t *usart);
+
+/*! \brief Unselects SPI slave chip.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS        Success.
+ * \retval USART_FAILURE        Time-out.
+ */
+extern int usart_spi_unselectChip(volatile avr32_usart_t *usart);
+
+//! @}
+
+#endif
+
+
+//------------------------------------------------------------------------------
+/*! \name Transmit/Receive Functions
+ */
+//! @{
+
+/*! \brief Addresses a receiver.
+ *
+ * While in RS485 mode, receivers only accept data addressed to them.
+ * A packet/char with the address tag set has to precede any data.
+ * This function is used to address a receiver. This receiver should read
+ * all the following data, until an address packet addresses another receiver.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param address Address of the target device.
+ *
+ * \retval USART_SUCCESS    Address successfully sent (if current mode is RS485).
+ * \retval USART_MODE_FAULT Wrong operating mode.
+ */
+extern int usart_send_address(volatile avr32_usart_t *usart, int address);
+
+/*! \brief Tests if the USART is ready to transmit a character.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_tx_ready(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_TXRDY_MASK) != 0;
+}
+
+/*! \brief Writes the given character to the TX buffer if the transmitter is ready.
+ *
+ * \param usart Base address of the USART instance.
+ * \param c     The character (up to 9 bits) to transmit.
+ *
+ * \retval USART_SUCCESS  The transmitter was ready.
+ * \retval USART_TX_BUSY  The transmitter was busy.
+ */
+extern int usart_write_char(volatile avr32_usart_t *usart, int c);
+
+/*! \brief An active wait writing a character to the USART.
+ *
+ * \param usart Base address of the USART instance.
+ * \param c     The character (up to 9 bits) to transmit.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_bw_write_char(volatile avr32_usart_t *usart, int c)
+{
+  while (usart_write_char(usart, c) != USART_SUCCESS);
+}
+
+/*! \brief Sends a character with the USART.
+ *
+ * \param usart Base address of the USART instance.
+ * \param c     Character to write.
+ *
+ * \retval USART_SUCCESS  The character was written.
+ * \retval USART_FAILURE  The function timed out before the USART transmitter became ready to send.
+ */
+extern int usart_putchar(volatile avr32_usart_t *usart, int c);
+
+/*! \brief Tests if all requested USART transmissions are over.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if the USART Transmit Shift Register and the USART Transmit
+ *         Holding Register are free, otherwise \c 0.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_tx_empty(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_TXEMPTY_MASK) != 0;
+}
+
+/*! \brief Tests if the USART contains a received character.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
+ */
+#if __GNUC__
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_test_hit(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_RXRDY_MASK) != 0;
+}
+
+/*! \brief Checks the RX buffer for a received character, and stores it at the
+ *         given memory location.
+ *
+ * \param usart Base address of the USART instance.
+ * \param c     Pointer to the where the read character should be stored
+ *              (must be at least short in order to accept 9-bit characters).
+ *
+ * \retval USART_SUCCESS  The character was read successfully.
+ * \retval USART_RX_EMPTY The RX buffer was empty.
+ * \retval USART_RX_ERROR An error was deteceted.
+ */
+extern int usart_read_char(volatile avr32_usart_t *usart, int *c);
+
+/*! \brief Waits until a character is received, and returns it.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return The received character, or \ref USART_FAILURE upon error.
+ */
+extern int usart_getchar(volatile avr32_usart_t *usart);
+
+/*! \brief Writes one character string to the USART.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param string  String to be written.
+ */
+extern void usart_write_line(volatile avr32_usart_t *usart, const char *string);
+
+/*! \brief Gets and echoes characters until end of line.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS  Success.
+ * \retval USART_FAILURE  ETX character received.
+ */
+extern int usart_get_echo_line(volatile avr32_usart_t *usart);
+
+//! @}
+
+
+#endif  // _USART_H_

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/platform/lm3s/platform.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -571,46 +571,48 @@
 // Initially immplementing the funcionalities offered by the RIT128x96x4
 // OLED display driver.
 
-void platform_disp_init(unsigned long freq) {
-  RIT128x96x4Init(freq);
+void platform_disp_init( unsigned long freq ) 
+{
+  RIT128x96x4Init( freq );
 }
     
-void platform_disp_clear(void) {  
+void platform_disp_clear() 
+{  
   RIT128x96x4Clear();
 }
 
-void platform_disp_stringDraw(const char *str, unsigned long x, unsigned long y,
-                              unsigned char level) {
-  RIT128x96x4StringDraw(str, x, y, level);
+void platform_disp_stringDraw( const char *str, unsigned long x, unsigned long y, unsigned char level ) 
+{
+  RIT128x96x4StringDraw( str, x, y, level );
 }
 
-void platform_disp_imageDraw(const unsigned char *img, 
-                            unsigned long x, unsigned long y, 
-                            unsigned long width, unsigned long height) {
-  RIT128x96x4ImageDraw(img, x, y, width, height);
+void platform_disp_imageDraw( const unsigned char *img, unsigned long x, unsigned long y, 
+                              unsigned long width, unsigned long height ) 
+{
+  RIT128x96x4ImageDraw( img, x, y, width, height );
 }
 
 
-void platform_disp_enable(unsigned long freq) {
-  RIT128x96x4Enable(freq);
+void platform_disp_enable( unsigned long freq ) 
+{
+  RIT128x96x4Enable( freq );
 }
 
-void platform_disp_disable(void) {
+void platform_disp_disable() 
+{
   RIT128x96x4Disable();
 }
 
-void platform_disp_displayOn(void) {
+void platform_disp_displayOn() 
+{
   RIT128x96x4DisplayOn();
 }
 
-void platform_disp_displayOff(void) {
+void platform_disp_displayOff() 
+{
   RIT128x96x4DisplayOff();
 }
 
-
-
-
-
 // ****************************************************************************
 // Ethernet functions
 

Modified: trunk/src/shell.c
===================================================================
--- trunk/src/shell.c	2008-12-13 21:31:20 UTC (rev 133)
+++ trunk/src/shell.c	2008-12-13 23:31:40 UTC (rev 134)
@@ -178,7 +178,7 @@
   args = args;
   offset = 0;
   printf( &quot;\n/rom&quot; );
-  while ( offset = romfs_get_dir_entry( offset, fname, &amp;size ))
+  while ( ( offset = romfs_get_dir_entry( offset, fname, &amp;size ) ) ) 
   {
     printf( &quot;\n%s&quot;, fname );
     for( i = strlen( fname ); i &lt;= MAX_FNAME_LENGTH; i++ )


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000089.html">[Elua-svn] r133 - trunk/romfs
</A></li>
	<LI>Next message: <A HREF="000091.html">[Elua-svn] r135 - in trunk: . inc src src/lua src/newlib	src/platform/avr32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#90">[ date ]</a>
              <a href="thread.html#90">[ thread ]</a>
              <a href="subject.html#90">[ subject ]</a>
              <a href="author.html#90">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
