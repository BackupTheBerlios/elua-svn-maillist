<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r136 - in trunk: romfs src/platform/avr32
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r136%20-%20in%20trunk%3A%20romfs%20src/platform/avr32&In-Reply-To=%3C200812161901.mBGJ1q6n009036%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000091.html">
   <LINK REL="Next"  HREF="000093.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r136 - in trunk: romfs src/platform/avr32</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r136%20-%20in%20trunk%3A%20romfs%20src/platform/avr32&In-Reply-To=%3C200812161901.mBGJ1q6n009036%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r136 - in trunk: romfs src/platform/avr32">bogdanm at mail.berlios.de
       </A><BR>
    <I>Tue Dec 16 20:01:52 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000091.html">[Elua-svn] r135 - in trunk: . inc src src/lua src/newlib	src/platform/avr32
</A></li>
        <LI>Next message: <A HREF="000093.html">[Elua-svn] r137 - in trunk/src: newlib platform/avr32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2008-12-16 20:01:51 +0100 (Tue, 16 Dec 2008)
New Revision: 136

Added:
   trunk/src/platform/avr32/tc.c
   trunk/src/platform/avr32/tc.h
Modified:
   trunk/romfs/led.lua
   trunk/src/platform/avr32/conf.py
   trunk/src/platform/avr32/platform.c
   trunk/src/platform/avr32/platform_conf.h
Log:
Now we have both GPIO and timer support on AVR32. led.lua sample was also modified to work with the ATEVK1100 board. More to come after I get rid of some other projects.



Modified: trunk/romfs/led.lua
===================================================================
--- trunk/romfs/led.lua	2008-12-14 21:39:51 UTC (rev 135)
+++ trunk/romfs/led.lua	2008-12-16 19:01:51 UTC (rev 136)
@@ -1,6 +1,6 @@
 -- eLua test 
 
-local uartid = 0
+local uartid, invert = 0, false
 if pd.board() == &quot;SAM7-EX256&quot; then
   ledpin = pio.PB_20
 elseif pd.board() == &quot;EK-LM3S8962&quot; or pd.board() == &quot;EK-LM3S6965&quot; then
@@ -12,15 +12,18 @@
 elseif pd.board() == &quot;MOD711&quot; then
   ledpin = pio.P1_7
   uartid = 1
+elseif pd.board() == &quot;ATEVK1100&quot; then
+  ledpin = pio.PB_27
+  invert = true
 else
   print( &quot;\nError: Unknown board &quot; .. pd.board() .. &quot; !&quot; )
   return
 end
 
 function cycle()
-  pio.set( ledpin )
+  if not invert then pio.set( ledpin ) else pio.clear( ledpin ) end
   tmr.delay( 0, 500000 )
-  pio.clear( ledpin )
+  if not invert then pio.clear( ledpin ) else pio.set( ledpin ) end
   tmr.delay( 0, 500000 )
 end
 

Modified: trunk/src/platform/avr32/conf.py
===================================================================
--- trunk/src/platform/avr32/conf.py	2008-12-14 21:39:51 UTC (rev 135)
+++ trunk/src/platform/avr32/conf.py	2008-12-16 19:01:51 UTC (rev 136)
@@ -1,6 +1,6 @@
 # Configuration file for the AVR32 microcontroller
 
-specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c&quot;
+specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c tc.c&quot;
 ldscript = &quot;at32uc3a0512.ld&quot;
 
 # Prepend with path

Modified: trunk/src/platform/avr32/platform.c
===================================================================
--- trunk/src/platform/avr32/platform.c	2008-12-14 21:39:51 UTC (rev 135)
+++ trunk/src/platform/avr32/platform.c	2008-12-16 19:01:51 UTC (rev 136)
@@ -21,6 +21,7 @@
 #include &quot;board.h&quot;
 #include &quot;usart.h&quot;
 #include &quot;gpio.h&quot;
+#include &quot;tc.h&quot;
 
 // *****************************************************************************
 // std functions
@@ -50,16 +51,54 @@
     FOSC0,
     OSC0_STARTUP, 
   };
-   
+  tc_waveform_opt_t tmropt = 
+  {
+    0,                                 // Channel selection.
+        
+    TC_EVT_EFFECT_NOOP,                // Software trigger effect on TIOB.
+    TC_EVT_EFFECT_NOOP,                // External event effect on TIOB.
+    TC_EVT_EFFECT_NOOP,                // RC compare effect on TIOB.
+    TC_EVT_EFFECT_NOOP,                // RB compare effect on TIOB.
+                        
+    TC_EVT_EFFECT_NOOP,                // Software trigger effect on TIOA.
+    TC_EVT_EFFECT_NOOP,                // External event effect on TIOA.
+    TC_EVT_EFFECT_NOOP,                // RC compare effect on TIOA: toggle.
+    TC_EVT_EFFECT_NOOP,                // RA compare effect on TIOA: toggle (other possibilities are none, set and clear).
+                                        
+    TC_WAVEFORM_SEL_UP_MODE,           // Waveform selection: Up mode
+    FALSE,                             // External event trigger enable.
+    0,                                 // External event selection.
+    TC_SEL_NO_EDGE,                    // External event edge selection.
+    FALSE,                             // Counter disable when RC compare.
+    FALSE,                             // Counter clock stopped with RC compare.
+                                                                
+    FALSE,                             // Burst signal selection.
+    FALSE,                             // Clock inversion.
+    TC_CLOCK_SOURCE_TC1                // Internal source clock 1 (32768Hz)
+  };
+  volatile avr32_tc_t *tc = &amp;AVR32_TC;
+  unsigned i;
+         
   Disable_global_interrupt();  
   
   // Setup clocks
   if( PM_FREQ_STATUS_FAIL == pm_configure_clocks( &amp;pm_freq_param ) )
     return PLATFORM_ERR;  
-    
+  // Select the 32-kHz oscillator crystal
+  pm_enable_osc32_crystal (&amp;AVR32_PM );
+  // Enable the 32-kHz clock
+  pm_enable_clk32_no_wait( &amp;AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC );    
+  
   // Setup UART for eLua
   platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );  
   
+  // Setup timers
+  for( i = 0; i &lt; 3; i ++ )
+  {
+    tmropt.channel = i;
+    tc_init_waveform( tc, &amp;tmropt );
+  }
+  
   // Set the send/recv functions                          
   std_set_send_func( uart_send );
   std_set_get_func( uart_recv );  
@@ -71,9 +110,48 @@
 // ****************************************************************************
 // PIO functions
 
+/* Note about AVR32 GPIO
+PIOs on AVR32 are a weird deal. They aren't really organized in ports, but 
+rather they are numbered from 0 to a maximum number (which also give the total
+number of GPIOs in the system) then you do operations on that pin number. 
+We need to organize this in ports though, so here's our organization:
+PA: 31 bits, direct mapping to AVR GPIO0 ... GPIO30
+PB: 32 bits, direct mapping to AVR GPIO32 ... GPIO63
+PC: 6 bits, direct mapping to AVR GPIO64 ... GPIO69
+PX: this is where all hell breaks loose. PX seems to be a quite random mapping
+between the rest of the GPIOs and some &quot;port&quot; that has 40 bits and a very 
+imaginative mapping to the GPIOs (PX0 is GPIO100, PX1 is GPIO99, PX2 is GPIO98 ...
+and PX11 is GPIO109, just to give a few examples). So let's make some sense out of
+this. We define two pseudo ports: a 32 bits one (GPIO70-GPIO101) and an 8 bits one 
+(GPIO102-GPIO109).
+PD: 32 bits, GPIO70-GPIO101
+PE:  8 bits, GPIO102-GPIO109
+(note that GPIO32 doesn't seem to exist at all in the system).
+Beceause these are pseudo-ports, operations on them will be slower than operation
+on the hardware ports (PA, PB, PC).
+*/
+
+// Port data
+#define NUM_PORTS     5
+#define PA            0
+#define PB            1
+#define PC            2
+#define PD            3
+#define PE            4
+// Reg types for our helper function
+#define PIO_REG_PVR   0
+#define PIO_REG_OVR   1
+#define PIO_REG_GPER  2
+#define PIO_REG_ODER  3
+#define PIO_REG_PUER  4
+
+#define GPIO          AVR32_GPIO
+
+static const u8 pio_port_pins[ NUM_PORTS ] = { 31, 32, 6, 32, 8 };
+
 int platform_pio_has_port( unsigned port )
 {
-  return 0;
+  return port &lt; NUM_PORTS;
 }
 
 const char* platform_pio_get_prefix( unsigned port )
@@ -86,14 +164,150 @@
 
 int platform_pio_has_pin( unsigned port, unsigned pin )
 {
-  return port &lt;= 1 &amp;&amp; pin &lt;= 30;
+  return port &lt; NUM_PORTS &amp;&amp; pin &lt; pio_port_pins[ port ];
 }
 
-pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
+// Helper function: for a given port, return the address of a specific register (value, direction, pullup ...)
+static volatile unsigned long* platform_pio_get_port_reg_addr( unsigned port, int regtype )
 {
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[ port ];
+  
+  switch( regtype )
+  {
+    case PIO_REG_PVR:
+      return ( unsigned long * )&amp;gpio_port-&gt;pvr;
+    case PIO_REG_OVR:
+      return &amp;gpio_port-&gt;ovr;
+    case PIO_REG_GPER:
+      return &amp;gpio_port-&gt;gper;
+    case PIO_REG_ODER:
+      return &amp;gpio_port-&gt;oder;
+    case PIO_REG_PUER:
+      return &amp;gpio_port-&gt;puer;
+  }
+  // Should never get here
+  return ( unsigned long* )&amp;gpio_port-&gt;pvr;
+}
+
+// Helper function: get port value, get direction, get pullup, ...
+static pio_type platform_pio_get_port_reg( unsigned port, int reg )
+{
+  pio_type v;
+  volatile unsigned long *pv = platform_pio_get_port_reg_addr( port, reg );
+  
+  switch( port )
+  {
+    case PA:   // PA - 31 bits
+      return *pv &amp; 0x7FFFFFFF;
+      
+    case PB:   // PB - 32 bits
+      return *pv;
+      
+    case PC:   // PC - 6 bits
+      return *pv &amp; 0x3F;      
+      
+    case PD:   // PD - pseudo port (70-101, has 26 bits on P2 and 6 bits on P3)
+      pv = platform_pio_get_port_reg_addr( 2, reg );
+      v = ( *pv &amp; 0xFFFFFFC0 ) &gt;&gt; 6;
+      pv = platform_pio_get_port_reg_addr( 3, reg );
+      return ( ( *pv &amp; 0x3F ) &lt;&lt; 26 ) | v;
+      
+    case PE:   // PE - pseudo port (102-109, 8 bits on P3)
+      pv = platform_pio_get_port_reg_addr( 3, reg );
+      return ( *pv &amp; 0x3FC0 ) &gt;&gt; 6;
+  }
+  // Will never get here
   return 0;
 }
 
+// Helper function: set port value, set direction, set pullup ...
+static void platform_pio_set_port_reg( unsigned port, pio_type val, int reg )
+{
+  volatile unsigned long *pv = platform_pio_get_port_reg_addr( port, reg );
+    
+  switch( port )
+  {
+    case PA:   // PA - 31 bits
+      *pv = val &amp; 0x7FFFFFFF;
+      break;
+            
+    case PB:   // PB - 32 bits
+      *pv = val;
+      break;
+      
+    case PC:   // PC - 6 bits
+      *pv = ( *pv &amp; ~0x3F ) | ( val &amp; 0x3F );
+      break;
+      
+    case PD:  // PD - pseudo port (70-101, has 26 bits on P2 and 6 bits on P3)
+      pv = platform_pio_get_port_reg_addr( 2, reg );
+      *pv = ( *pv &amp; ~0xFFFFFFC0 ) | ( val &lt;&lt; 6 );
+      pv = platform_pio_get_port_reg_addr( 3, reg );
+      *pv = ( *pv &amp; ~0x3F ) | ( val &gt;&gt; 26 );
+      break;
+    
+    case PE:  // PE - pseudo port (102-109, 8 bits on P3)
+      pv = platform_pio_get_port_reg_addr( 3, reg );
+      *pv = ( *pv &amp; ~0x3FC0 ) | ( ( val &amp; 0xFF ) &lt;&lt; 6 );   
+      break;
+  }
+}
+
+pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
+{
+  pio_type retval = 1;
+  
+  switch( op )
+  {
+    case PLATFORM_IO_PORT_SET_VALUE:    
+      platform_pio_set_port_reg( port, pinmask, PIO_REG_OVR );
+      break;
+      
+    case PLATFORM_IO_PIN_SET:
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_PVR ) | pinmask, PIO_REG_OVR );
+      break;
+      
+    case PLATFORM_IO_PIN_CLEAR:
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_PVR ) &amp; ~pinmask, PIO_REG_OVR );
+      break;
+      
+    case PLATFORM_IO_PORT_DIR_INPUT:
+      pinmask = 0xFFFFFFFF;      
+    case PLATFORM_IO_PIN_DIR_INPUT:
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_ODER ) &amp; ~pinmask, PIO_REG_ODER );
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_GPER ) | pinmask, PIO_REG_GPER );
+      break;
+      
+    case PLATFORM_IO_PORT_DIR_OUTPUT:      
+      pinmask = 0xFFFFFFFF;
+    case PLATFORM_IO_PIN_DIR_OUTPUT:
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_ODER ) | pinmask, PIO_REG_ODER );
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_GPER ) | pinmask, PIO_REG_GPER );    
+      break;      
+            
+    case PLATFORM_IO_PORT_GET_VALUE:
+      retval = platform_pio_get_port_reg( port, PIO_REG_PVR );
+      break;
+      
+    case PLATFORM_IO_PIN_GET:
+      retval = platform_pio_get_port_reg( port, PIO_REG_PVR ) &amp; pinmask ? 1 : 0;
+      break;
+      
+    case PLATFORM_IO_PIN_PULLUP:
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_PUER ) | pinmask, PIO_REG_PUER );
+      break;
+      
+    case PLATFORM_IO_PIN_NOPULL:
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_PUER ) &amp; ~pinmask, PIO_REG_PUER );    
+      break;
+      
+    default:
+      retval = 0;
+      break;
+  }
+  return retval;
+}
+
 // ****************************************************************************
 // UART functions
 
@@ -185,6 +399,110 @@
 }
 
 // ****************************************************************************
+// Timer functions
+
+#define NUM_TIMERS 3
+static const u16 clkdivs[] = { 0xFFFF, 2, 8, 32, 128 };
+
+// Helper: get timer clock
+static u32 platform_timer_get_clock( unsigned id )
+{
+  volatile avr32_tc_t *tc = &amp;AVR32_TC;
+  unsigned int clksel = tc-&gt;channel[ id ].CMR.waveform.tcclks;
+        
+  return clksel == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ clksel ];
+}
+
+// Helper: set timer clock
+static u32 platform_timer_set_clock( unsigned id, u32 clock )
+{
+  unsigned i, mini;
+  volatile avr32_tc_t *tc = &amp;AVR32_TC;
+  volatile unsigned long *pclksel = &amp;tc-&gt;channel[ id ].cmr;
+  
+  for( i = mini = 0; i &lt; 5; i ++ )
+    if( ABSDIFF( clock, i == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ i ] ) &lt; ABSDIFF( clock, mini == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ mini ] ) )
+      mini = i;
+  *pclksel = ( *pclksel &amp; ~0x07 ) | mini;
+  return mini == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ mini ];
+}
+
+int platform_timer_exists( unsigned id )
+{
+  return id &lt; NUM_TIMERS;
+}
+
+void platform_timer_delay( unsigned id, u32 delay_us )
+{
+  volatile avr32_tc_t *tc = &amp;AVR32_TC;  
+  u32 freq;
+  timer_data_type final;
+  volatile int i;
+  volatile const avr32_tc_sr_t *sr = &amp;tc-&gt;channel[ id ].SR;
+      
+  freq = platform_timer_get_clock( id );
+  final = ( ( u64 )delay_us * freq ) / 1000000;
+  if( final &gt; 0xFFFF )
+    final = 0xFFFF;
+  tc_start( tc, id );
+  i = sr-&gt;covfs;
+  for( i = 0; i &lt; 200; i ++ );
+  while( ( tc_read_tc( tc, id ) &lt; final ) &amp;&amp; !sr-&gt;covfs );  
+}
+
+u32 platform_timer_op( unsigned id, int op, u32 data )
+{
+  u32 res = 0;
+  volatile int i;
+  volatile avr32_tc_t *tc = &amp;AVR32_TC;    
+  
+  switch( op )
+  {
+    case PLATFORM_TIMER_OP_START:
+      res = 0;
+      tc_start( tc, id );
+      for( i = 0; i &lt; 200; i ++ );      
+      break;
+      
+    case PLATFORM_TIMER_OP_READ:
+      res = tc_read_tc( tc, id );
+      break;
+      
+    case PLATFORM_TIMER_OP_GET_MAX_DELAY:
+      res = platform_timer_get_diff_us( id, 0, 0xFFFF );
+      break;
+      
+    case PLATFORM_TIMER_OP_GET_MIN_DELAY:
+      res = platform_timer_get_diff_us( id, 0, 1 );
+      break;      
+      
+    case PLATFORM_TIMER_OP_SET_CLOCK:
+      res = platform_timer_set_clock( id, data );
+      break;
+      
+    case PLATFORM_TIMER_OP_GET_CLOCK:
+      res = platform_timer_get_clock( id );
+      break;
+  }
+  return res;
+}
+
+u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
+{
+  timer_data_type temp;
+  u32 freq;
+    
+  freq = platform_timer_get_clock( id );
+  if( start &lt; end )
+  {
+    temp = end;
+    end = start;
+    start = temp;
+  }
+  return ( ( u64 )( start - end ) * 1000000 ) / freq;
+}
+
+// ****************************************************************************
 // CPU functions
 
 u32 platform_cpu_get_frequency()

Modified: trunk/src/platform/avr32/platform_conf.h
===================================================================
--- trunk/src/platform/avr32/platform_conf.h	2008-12-14 21:39:51 UTC (rev 135)
+++ trunk/src/platform/avr32/platform_conf.h	2008-12-16 19:01:51 UTC (rev 136)
@@ -37,6 +37,8 @@
 #define LUA_PLATFORM_LIBS\
   { AUXLIB_PD, luaopen_pd },\
   { AUXLIB_UART, luaopen_uart },\
+  { AUXLIB_PIO, luaopen_pio },\
+  { AUXLIB_TMR, luaopen_tmr },\
   { AUXLIB_TERM, luaopen_term },\
   { AUXLIB_PACK, luaopen_pack },\
   { AUXLIB_BIT, luaopen_bit },\

Added: trunk/src/platform/avr32/tc.c
===================================================================
--- trunk/src/platform/avr32/tc.c	2008-12-14 21:39:51 UTC (rev 135)
+++ trunk/src/platform/avr32/tc.c	2008-12-16 19:01:51 UTC (rev 136)
@@ -0,0 +1,299 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief TC driver for AVR32 UC3.
+ *
+ * AVR32 Timer/Counter driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a TC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;tc.h&quot;
+
+
+int tc_get_interrupt_settings(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return tc-&gt;channel[channel].imr;
+}
+
+
+int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
+{
+  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
+
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Enable the appropriate interrupts.
+  tc-&gt;channel[channel].ier = bitfield-&gt;etrgs &lt;&lt; AVR32_TC_ETRGS_OFFSET |
+                             bitfield-&gt;ldrbs &lt;&lt; AVR32_TC_LDRBS_OFFSET |
+                             bitfield-&gt;ldras &lt;&lt; AVR32_TC_LDRAS_OFFSET |
+                             bitfield-&gt;cpcs &lt;&lt; AVR32_TC_CPCS_OFFSET |
+                             bitfield-&gt;cpbs &lt;&lt; AVR32_TC_CPBS_OFFSET |
+                             bitfield-&gt;cpas &lt;&lt; AVR32_TC_CPAS_OFFSET |
+                             bitfield-&gt;lovrs &lt;&lt; AVR32_TC_LOVRS_OFFSET |
+                             bitfield-&gt;covfs &lt;&lt; AVR32_TC_COVFS_OFFSET;
+
+  // Disable the appropriate interrupts.
+  if (global_interrupt_enabled) Disable_global_interrupt();
+  tc-&gt;channel[channel].idr = (~bitfield-&gt;etrgs &amp; 1) &lt;&lt; AVR32_TC_ETRGS_OFFSET |
+                             (~bitfield-&gt;ldrbs &amp; 1) &lt;&lt; AVR32_TC_LDRBS_OFFSET |
+                             (~bitfield-&gt;ldras &amp; 1) &lt;&lt; AVR32_TC_LDRAS_OFFSET |
+                             (~bitfield-&gt;cpcs &amp; 1) &lt;&lt; AVR32_TC_CPCS_OFFSET |
+                             (~bitfield-&gt;cpbs &amp; 1) &lt;&lt; AVR32_TC_CPBS_OFFSET |
+                             (~bitfield-&gt;cpas &amp; 1) &lt;&lt; AVR32_TC_CPAS_OFFSET |
+                             (~bitfield-&gt;lovrs &amp; 1) &lt;&lt; AVR32_TC_LOVRS_OFFSET |
+                             (~bitfield-&gt;covfs &amp; 1) &lt;&lt; AVR32_TC_COVFS_OFFSET;
+  tc-&gt;channel[channel].sr;
+  if (global_interrupt_enabled) Enable_global_interrupt();
+
+  return 0;
+}
+
+
+int tc_select_external_clock(volatile avr32_tc_t *tc, unsigned int channel, unsigned int ext_clk_sig_src)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS || ext_clk_sig_src &gt;= 1 &lt;&lt; AVR32_TC_BMR_TC0XC0S_SIZE)
+    return TC_INVALID_ARGUMENT;
+
+  // Clear bit-field and set the correct behavior.
+  tc-&gt;bmr = (tc-&gt;bmr &amp; ~(AVR32_TC_BMR_TC0XC0S_MASK &lt;&lt; (channel * AVR32_TC_BMR_TC0XC0S_SIZE))) |
+            (ext_clk_sig_src &lt;&lt; (channel * AVR32_TC_BMR_TC0XC0S_SIZE));
+
+  return 0;
+}
+
+
+int tc_init_capture(volatile avr32_tc_t *tc, const tc_capture_opt_t *opt)
+{
+  // Check for valid input.
+  if (opt-&gt;channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // MEASURE SIGNALS: Capture operating mode.
+  tc-&gt;channel[opt-&gt;channel].cmr = opt-&gt;ldrb &lt;&lt; AVR32_TC_LDRB_OFFSET |
+                                  opt-&gt;ldra &lt;&lt; AVR32_TC_LDRA_OFFSET |
+                                  0 &lt;&lt; AVR32_TC_WAVE_OFFSET |
+                                  opt-&gt;cpctrg &lt;&lt; AVR32_TC_CPCTRG_OFFSET |
+                                  opt-&gt;abetrg &lt;&lt; AVR32_TC_ABETRG_OFFSET |
+                                  opt-&gt;etrgedg &lt;&lt; AVR32_TC_ETRGEDG_OFFSET|
+                                  opt-&gt;ldbdis &lt;&lt; AVR32_TC_LDBDIS_OFFSET |
+                                  opt-&gt;ldbstop &lt;&lt; AVR32_TC_LDBSTOP_OFFSET |
+                                  opt-&gt;burst &lt;&lt; AVR32_TC_BURST_OFFSET |
+                                  opt-&gt;clki &lt;&lt; AVR32_TC_CLKI_OFFSET |
+                                  opt-&gt;tcclks &lt;&lt; AVR32_TC_TCCLKS_OFFSET;
+
+  return 0;
+}
+
+
+int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
+{
+  // Check for valid input.
+  if (opt-&gt;channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // GENERATE SIGNALS: Waveform operating mode.
+  tc-&gt;channel[opt-&gt;channel].cmr = opt-&gt;bswtrg &lt;&lt; AVR32_TC_BSWTRG_OFFSET |
+                                  opt-&gt;beevt &lt;&lt; AVR32_TC_BEEVT_OFFSET |
+                                  opt-&gt;bcpc &lt;&lt; AVR32_TC_BCPC_OFFSET |
+                                  opt-&gt;bcpb &lt;&lt; AVR32_TC_BCPB_OFFSET |
+                                  opt-&gt;aswtrg &lt;&lt; AVR32_TC_ASWTRG_OFFSET |
+                                  opt-&gt;aeevt &lt;&lt; AVR32_TC_AEEVT_OFFSET |
+                                  opt-&gt;acpc &lt;&lt; AVR32_TC_ACPC_OFFSET |
+                                  opt-&gt;acpa &lt;&lt; AVR32_TC_ACPA_OFFSET |
+                                  1 &lt;&lt; AVR32_TC_WAVE_OFFSET |
+                                  opt-&gt;wavsel &lt;&lt; AVR32_TC_WAVSEL_OFFSET |
+                                  opt-&gt;enetrg &lt;&lt; AVR32_TC_ENETRG_OFFSET |
+                                  opt-&gt;eevt &lt;&lt; AVR32_TC_EEVT_OFFSET |
+                                  opt-&gt;eevtedg &lt;&lt; AVR32_TC_EEVTEDG_OFFSET |
+                                  opt-&gt;cpcdis &lt;&lt; AVR32_TC_CPCDIS_OFFSET |
+                                  opt-&gt;cpcstop &lt;&lt; AVR32_TC_CPCSTOP_OFFSET |
+                                  opt-&gt;burst &lt;&lt; AVR32_TC_BURST_OFFSET |
+                                  opt-&gt;clki &lt;&lt; AVR32_TC_CLKI_OFFSET |
+                                  opt-&gt;tcclks &lt;&lt; AVR32_TC_TCCLKS_OFFSET;
+
+  return 0;
+}
+
+
+int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Enable, reset and start the selected timer/counter channel.
+  tc-&gt;channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
+
+  return 0;
+}
+
+
+int tc_stop(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Disable the selected timer/counter channel.
+  tc-&gt;channel[channel].ccr = AVR32_TC_CLKDIS_MASK;
+
+  return 0;
+}
+
+
+int tc_software_trigger(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Reset the selected timer/counter channel.
+  tc-&gt;channel[channel].ccr = AVR32_TC_SWTRG_MASK;
+
+  return 0;
+}
+
+
+void tc_sync_trigger(volatile avr32_tc_t *tc)
+{
+  // Reset all channels of the selected timer/counter.
+  tc-&gt;bcr = AVR32_TC_BCR_SYNC_MASK;
+}
+
+
+int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return tc-&gt;channel[channel].sr;
+}
+
+
+int tc_read_tc(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].cv, AVR32_TC_CV_MASK);
+}
+
+
+int tc_read_ra(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].ra, AVR32_TC_RA_MASK);
+}
+
+
+int tc_read_rb(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].rb, AVR32_TC_RB_MASK);
+}
+
+
+int tc_read_rc(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].rc, AVR32_TC_RC_MASK);
+}
+
+
+int tc_write_ra(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // This function is only available in WAVEFORM mode.
+  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
+    Wr_bitfield(tc-&gt;channel[channel].ra, AVR32_TC_RA_MASK, value);
+
+  return value;
+}
+
+
+int tc_write_rb(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // This function is only available in WAVEFORM mode.
+  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
+    Wr_bitfield(tc-&gt;channel[channel].rb, AVR32_TC_RB_MASK, value);
+
+  return value;
+}
+
+
+int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // This function is only available in WAVEFORM mode.
+  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
+    Wr_bitfield(tc-&gt;channel[channel].rc, AVR32_TC_RC_MASK, value);
+
+  return value;
+}

Added: trunk/src/platform/avr32/tc.h
===================================================================
--- trunk/src/platform/avr32/tc.h	2008-12-14 21:39:51 UTC (rev 135)
+++ trunk/src/platform/avr32/tc.h	2008-12-16 19:01:51 UTC (rev 136)
@@ -0,0 +1,582 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Timer/Counter driver for AVR32 UC3.
+ *
+ * AVR32 Timer/Counter driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a TC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _TC_H_
+#define _TC_H_
+
+#include &lt;avr32/io.h&gt;
+
+
+//! TC driver functions return value in case of invalid argument(s).
+#define TC_INVALID_ARGUMENT                     (-1)
+
+//! Number of timer/counter channels.
+#define TC_NUMBER_OF_CHANNELS                   (sizeof(((avr32_tc_t *)0)-&gt;channel) / sizeof(avr32_tc_channel_t))
+
+/*! \name External Clock Signal 0 Selection
+ */
+//! @{
+#define TC_CH0_EXT_CLK0_SRC_TCLK0               AVR32_TC_TC0XC0S_TCLK0
+#define TC_CH0_EXT_CLK0_SRC_NO_CLK              AVR32_TC_TC0XC0S_NO_CLK
+#define TC_CH0_EXT_CLK0_SRC_TIOA1               AVR32_TC_TC0XC0S_TIOA1
+#define TC_CH0_EXT_CLK0_SRC_TIOA2               AVR32_TC_TC0XC0S_TIOA2
+//! @}
+
+/*! \name External Clock Signal 1 Selection
+ */
+//! @{
+#define TC_CH1_EXT_CLK1_SRC_TCLK1               AVR32_TC_TC1XC1S_TCLK1
+#define TC_CH1_EXT_CLK1_SRC_NO_CLK              AVR32_TC_TC1XC1S_NO_CLK
+#define TC_CH1_EXT_CLK1_SRC_TIOA0               AVR32_TC_TC1XC1S_TIOA0
+#define TC_CH1_EXT_CLK1_SRC_TIOA2               AVR32_TC_TC1XC1S_TIOA2
+//! @}
+
+/*! \name External Clock Signal 2 Selection
+ */
+//! @{
+#define TC_CH2_EXT_CLK2_SRC_TCLK2               AVR32_TC_TC2XC2S_TCLK2
+#define TC_CH2_EXT_CLK2_SRC_NO_CLK              AVR32_TC_TC2XC2S_NO_CLK
+#define TC_CH2_EXT_CLK2_SRC_TIOA0               AVR32_TC_TC2XC2S_TIOA0
+#define TC_CH2_EXT_CLK2_SRC_TIOA1               AVR32_TC_TC2XC2S_TIOA1
+//! @}
+
+/*! \name Event/Trigger Actions on Output
+ */
+//! @{
+#define TC_EVT_EFFECT_NOOP                      AVR32_TC_NONE
+#define TC_EVT_EFFECT_SET                       AVR32_TC_SET
+#define TC_EVT_EFFECT_CLEAR                     AVR32_TC_CLEAR
+#define TC_EVT_EFFECT_TOGGLE                    AVR32_TC_TOGGLE
+//! @}
+
+/*! \name RC Compare Trigger Enable
+ */
+//! @{
+#define TC_NO_TRIGGER_COMPARE_RC                0
+#define TC_TRIGGER_COMPARE_RC                   1
+//! @}
+
+/*! \name Waveform Selection
+ */
+//! @{
+#define TC_WAVEFORM_SEL_UP_MODE                 AVR32_TC_WAVSEL_UP_NO_AUTO
+#define TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER      AVR32_TC_WAVSEL_UP_AUTO
+#define TC_WAVEFORM_SEL_UPDOWN_MODE             AVR32_TC_WAVSEL_UPDOWN_NO_AUTO
+#define TC_WAVEFORM_SEL_UPDOWN_MODE_RC_TRIGGER  AVR32_TC_WAVSEL_UPDOWN_AUTO
+//! @}
+
+/*! \name TIOA or TIOB External Trigger Selection
+ */
+//! @{
+#define TC_EXT_TRIG_SEL_TIOA                    1
+#define TC_EXT_TRIG_SEL_TIOB                    0
+//! @}
+
+/*! \name External Event Selection
+ */
+//! @{
+#define TC_EXT_EVENT_SEL_TIOB_INPUT             AVR32_TC_EEVT_TIOB_INPUT
+#define TC_EXT_EVENT_SEL_XC0_OUTPUT             AVR32_TC_EEVT_XC0_OUTPUT
+#define TC_EXT_EVENT_SEL_XC1_OUTPUT             AVR32_TC_EEVT_XC1_OUTPUT
+#define TC_EXT_EVENT_SEL_XC2_OUTPUT             AVR32_TC_EEVT_XC2_OUTPUT
+//! @}
+
+/*! \name Edge Selection
+ */
+//! @{
+#define TC_SEL_NO_EDGE                          AVR32_TC_EEVTEDG_NO_EDGE
+#define TC_SEL_RISING_EDGE                      AVR32_TC_EEVTEDG_POS_EDGE
+#define TC_SEL_FALLING_EDGE                     AVR32_TC_EEVTEDG_NEG_EDGE
+#define TC_SEL_EACH_EDGE                        AVR32_TC_EEVTEDG_BOTH_EDGES
+//! @}
+
+/*! \name Burst Signal Selection
+ */
+//! @{
+#define TC_BURST_NOT_GATED                      AVR32_TC_BURST_NOT_GATED
+#define TC_BURST_CLK_AND_XC0                    AVR32_TC_BURST_CLK_AND_XC0
+#define TC_BURST_CLK_AND_XC1                    AVR32_TC_BURST_CLK_AND_XC1
+#define TC_BURST_CLK_AND_XC2                    AVR32_TC_BURST_CLK_AND_XC2
+//! @}
+
+/*! \name Clock Invert
+ */
+//! @{
+#define TC_CLOCK_RISING_EDGE                    0
+#define TC_CLOCK_FALLING_EDGE                   1
+//! @}
+
+/*! \name Clock Selection
+ */
+//! @{
+#define TC_CLOCK_SOURCE_TC1                     AVR32_TC_TCCLKS_TIMER_DIV1_CLOCK
+#define TC_CLOCK_SOURCE_TC2                     AVR32_TC_TCCLKS_TIMER_DIV2_CLOCK
+#define TC_CLOCK_SOURCE_TC3                     AVR32_TC_TCCLKS_TIMER_DIV3_CLOCK
+#define TC_CLOCK_SOURCE_TC4                     AVR32_TC_TCCLKS_TIMER_DIV4_CLOCK
+#define TC_CLOCK_SOURCE_TC5                     AVR32_TC_TCCLKS_TIMER_DIV5_CLOCK
+#define TC_CLOCK_SOURCE_XC0                     AVR32_TC_TCCLKS_XC0
+#define TC_CLOCK_SOURCE_XC1                     AVR32_TC_TCCLKS_XC1
+#define TC_CLOCK_SOURCE_XC2                     AVR32_TC_TCCLKS_XC2
+//! @}
+
+
+//! Timer/counter interrupts.
+typedef struct
+{
+  unsigned int                 :24;
+
+  //! External trigger interrupt.
+  unsigned int etrgs           : 1;
+
+  //! RB load interrupt.
+  unsigned int ldrbs           : 1;
+
+  //! RA load interrupt.
+  unsigned int ldras           : 1;
+
+  //! RC compare interrupt.
+  unsigned int cpcs            : 1;
+
+  //! RB compare interrupt.
+  unsigned int cpbs            : 1;
+
+  //! RA compare interrupt.
+  unsigned int cpas            : 1;
+
+  //! Load overrun interrupt.
+  unsigned int lovrs           : 1;
+
+  //! Counter overflow interrupt.
+  unsigned int covfs           : 1;
+} tc_interrupt_t;
+
+//! Parameters when initializing a timer/counter in capture mode.
+typedef struct
+{
+  //! Channel to initialize.
+  unsigned int channel            ;
+
+  unsigned int                 :12;
+
+  //! RB loading selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int ldrb            : 2;
+
+  //! RA loading selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int ldra            : 2;
+
+  unsigned int                 : 1;
+
+  //! RC compare trigger enable:\n
+  //!   - \ref TC_NO_TRIGGER_COMPARE_RC;\n
+  //!   - \ref TC_TRIGGER_COMPARE_RC.
+  unsigned int cpctrg          : 1;
+
+  unsigned int                 : 3;
+
+  //! TIOA or TIOB external trigger selection:\n
+  //!   - \ref TC_EXT_TRIG_SEL_TIOA;\n
+  //!   - \ref TC_EXT_TRIG_SEL_TIOB.
+  unsigned int abetrg          : 1;
+
+  //! External trigger edge selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int etrgedg         : 2;
+
+  //! Counter clock disable with RB loading:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int ldbdis          : 1;
+
+  //! Counter clock stopped with RB loading:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int ldbstop         : 1;
+
+  //! Burst signal selection:\n
+  //!   - \ref TC_BURST_NOT_GATED;\n
+  //!   - \ref TC_BURST_CLK_AND_XC0;\n
+  //!   - \ref TC_BURST_CLK_AND_XC1;\n
+  //!   - \ref TC_BURST_CLK_AND_XC2.
+  unsigned int burst           : 2;
+
+  //! Clock invert:\n
+  //!   - \ref TC_CLOCK_RISING_EDGE;\n
+  //!   - \ref TC_CLOCK_FALLING_EDGE.
+  unsigned int clki            : 1;
+
+  //! Clock selection:\n
+  //!   - \ref TC_CLOCK_SOURCE_TC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC2;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC3;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC4;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC5;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC0;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC2.
+  unsigned int tcclks          : 3;
+} tc_capture_opt_t;
+
+//! Parameters when initializing a timer/counter in waveform mode.
+typedef struct
+{
+  //! Channel to initialize.
+  unsigned int channel            ;
+
+  //! Software trigger effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int bswtrg          : 2;
+
+  //! External event effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int beevt           : 2;
+
+  //! RC compare effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int bcpc            : 2;
+
+  //! RB compare effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int bcpb            : 2;
+
+  //! Software trigger effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int aswtrg          : 2;
+
+  //! External event effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int aeevt           : 2;
+
+  //! RC compare effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int acpc            : 2;
+
+  //! RA compare effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int acpa            : 2;
+
+  unsigned int                 : 1;
+
+  //! Waveform selection:\n
+  //!   - \ref TC_WAVEFORM_SEL_UP_MODE;\n
+  //!   - \ref TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER;\n
+  //!   - \ref TC_WAVEFORM_SEL_UPDOWN_MODE;\n
+  //!   - \ref TC_WAVEFORM_SEL_UPDOWN_MODE_RC_TRIGGER.
+  unsigned int wavsel          : 2;
+
+  //! External event trigger enable:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int enetrg          : 1;
+
+  //! External event selection:\n
+  //!   - \ref TC_EXT_EVENT_SEL_TIOB_INPUT;\n
+  //!   - \ref TC_EXT_EVENT_SEL_XC0_OUTPUT;\n
+  //!   - \ref TC_EXT_EVENT_SEL_XC1_OUTPUT;\n
+  //!   - \ref TC_EXT_EVENT_SEL_XC2_OUTPUT.
+  unsigned int eevt            : 2;
+
+  //! External event edge selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int eevtedg         : 2;
+
+  //! Counter clock disable with RC compare:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int cpcdis          : 1;
+
+  //! Counter clock stopped with RC compare:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int cpcstop         : 1;
+
+  //! Burst signal selection:\n
+  //!   - \ref TC_BURST_NOT_GATED;\n
+  //!   - \ref TC_BURST_CLK_AND_XC0;\n
+  //!   - \ref TC_BURST_CLK_AND_XC1;\n
+  //!   - \ref TC_BURST_CLK_AND_XC2.
+  unsigned int burst           : 2;
+
+  //! Clock invert:\n
+  //!   - \ref TC_CLOCK_RISING_EDGE;\n
+  //!   - \ref TC_CLOCK_FALLING_EDGE.
+  unsigned int clki            : 1;
+
+  //! Clock selection:\n
+  //!   - \ref TC_CLOCK_SOURCE_TC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC2;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC3;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC4;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC5;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC0;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC2.
+  unsigned int tcclks          : 3;
+} tc_waveform_opt_t;
+
+
+/*! \brief Reads timer/counter interrupt settings.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 The interrupt enable configuration organized according to \ref tc_interrupt_t.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_get_interrupt_settings(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Enables various timer/counter interrupts.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param bitfield        The interrupt enable configuration.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield);
+
+/*! \brief Selects which external clock to use and how to configure it.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param ext_clk_sig_src External clock signal selection:
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_TCLK0;
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_NO_CLK;
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_TIOA1;
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_TIOA2;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_TCLK1;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_NO_CLK;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_TIOA0;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_TIOA2;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_TCLK2;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_NO_CLK;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_TIOA0;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_TIOA1.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_select_external_clock(volatile avr32_tc_t *tc, unsigned int channel, unsigned int ext_clk_sig_src);
+
+/*! \brief Sets options for timer/counter capture initialization.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param opt             Options for capture mode.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_init_capture(volatile avr32_tc_t *tc, const tc_capture_opt_t *opt);
+
+/*! \brief Sets options for timer/counter waveform initialization.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param opt             Options for waveform generation.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt);
+
+/*! \brief Starts a timer/counter.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_start(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Stops a timer/counter.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_stop(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Performs a software trigger: the counter is reset and the clock is started.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_software_trigger(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Asserts a SYNC signal to generate a software trigger and reset all channels.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ */
+extern void tc_sync_trigger(volatile avr32_tc_t *tc);
+
+/*! \brief Reads the status register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 Status register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's TC counter and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 TC counter value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_tc(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's RA register and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 RA register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_ra(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's RB register and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 RB register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_rb(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's RC register and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 RC register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_rc(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Writes a value to the channel's RA register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param value           Value to write to the RA register.
+ *
+ * \retval &gt;=0 Written value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_write_ra(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
+
+/*! \brief Writes a value to the channel's RB register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param value           Value to write to the RB register.
+ *
+ * \retval &gt;=0 Written value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_write_rb(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
+
+/*! \brief Writes a value to the channel's RC register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param value           Value to write to the RC register.
+ *
+ * \retval &gt;=0 Written value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
+
+
+#endif  // _TC_H_


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000091.html">[Elua-svn] r135 - in trunk: . inc src src/lua src/newlib	src/platform/avr32
</A></li>
	<LI>Next message: <A HREF="000093.html">[Elua-svn] r137 - in trunk/src: newlib platform/avr32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
