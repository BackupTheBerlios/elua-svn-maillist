<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r696 - in trunk: . inc inc/newlib inc/remotefs	rfs_server src src/fatfs src/newlib src/platform/sim	src/platform/stm32 src/remotefs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r696%20-%20in%20trunk%3A%20.%20inc%20inc/newlib%20inc/remotefs%0A%09rfs_server%20src%20src/fatfs%20src/newlib%20src/platform/sim%0A%09src/platform/stm32%20src/remotefs&In-Reply-To=%3C201002011847.o11IlhMb012060%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000648.html">
   <LINK REL="Next"  HREF="000650.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r696 - in trunk: . inc inc/newlib inc/remotefs	rfs_server src src/fatfs src/newlib src/platform/sim	src/platform/stm32 src/remotefs</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r696%20-%20in%20trunk%3A%20.%20inc%20inc/newlib%20inc/remotefs%0A%09rfs_server%20src%20src/fatfs%20src/newlib%20src/platform/sim%0A%09src/platform/stm32%20src/remotefs&In-Reply-To=%3C201002011847.o11IlhMb012060%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r696 - in trunk: . inc inc/newlib inc/remotefs	rfs_server src src/fatfs src/newlib src/platform/sim	src/platform/stm32 src/remotefs">bogdanm at mail.berlios.de
       </A><BR>
    <I>Mon Feb  1 19:47:43 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000648.html">[Elua-svn] r695 - trunk/doc/en
</A></li>
        <LI>Next message: <A HREF="000650.html">[Elua-svn] r697 - trunk/src/platform/lpc24xx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#649">[ date ]</a>
              <a href="thread.html#649">[ thread ]</a>
              <a href="subject.html#649">[ subject ]</a>
              <a href="author.html#649">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2010-02-01 19:47:41 +0100 (Mon, 01 Feb 2010)
New Revision: 696

Added:
   trunk/inc/elua_rfs.h
   trunk/inc/remotefs/
   trunk/inc/remotefs/client.h
   trunk/inc/remotefs/os_io.h
   trunk/inc/remotefs/remotefs.h
   trunk/inc/remotefs/rtype.h
   trunk/rfs_server.py
   trunk/rfs_server/
   trunk/rfs_server/client.c
   trunk/rfs_server/client.h
   trunk/rfs_server/log.c
   trunk/rfs_server/log.h
   trunk/rfs_server/main.c
   trunk/rfs_server/main_sim.c
   trunk/rfs_server/os_io_posix.c
   trunk/rfs_server/os_io_win32.c
   trunk/rfs_server/rtype.h
   trunk/rfs_server/serial.h
   trunk/rfs_server/serial_posix.c
   trunk/rfs_server/serial_win32.c
   trunk/rfs_server/server.c
   trunk/rfs_server/server.h
   trunk/rfs_server/type.h
   trunk/src/remotefs/
   trunk/src/remotefs/client.c
   trunk/src/remotefs/elua_os_io.c
   trunk/src/remotefs/elua_rfs.c
   trunk/src/remotefs/remotefs.c
Modified:
   trunk/SConstruct
   trunk/inc/mmcfs.h
   trunk/inc/newlib/devman.h
   trunk/inc/newlib/genstd.h
   trunk/inc/romfs.h
   trunk/run_elua_sim.sh
   trunk/src/fatfs/ff.h
   trunk/src/main.c
   trunk/src/mmcfs.c
   trunk/src/newlib/devman.c
   trunk/src/newlib/genstd.c
   trunk/src/newlib/stdtcp.c
   trunk/src/newlib/stubs.c
   trunk/src/platform/sim/host.c
   trunk/src/platform/sim/host.h
   trunk/src/platform/sim/hostif.h
   trunk/src/platform/sim/hostif_linux.c
   trunk/src/platform/sim/platform.c
   trunk/src/platform/sim/platform_conf.h
   trunk/src/platform/stm32/platform.c
   trunk/src/platform/stm32/platform_conf.h
   trunk/src/romfs.c
   trunk/src/shell.c
Log:
Manual merge of remotefs/ into trunk. Tested with the simulator and (partially) on a ET-STM32 board. Other changes:

- FAT changed to support the new opendir/readdir/closedir mechanism, and to use lseek directly instead of ioctl (also fixed a bug in FAT's lseek that always returned 0 instead of file position).
- ET-STM32 console moved to <A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">UART2 at 19200bps</A> (to allow RFS to run on UART0). If UART0 is needee for console, remember to disable RFS.
- freed 700+ bytes of RAM by changing the devman implementation to keep pointers instead of actual DM_DEVICE structures
- other minor code changes and fixes



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/SConstruct	2010-02-01 18:47:41 UTC (rev 696)
@@ -284,7 +284,7 @@
    ldblib.c liolib.c lmathlib.c loslib.c ltablib.c lstrlib.c loadlib.c linit.c lua.c lrotable.c legc.c&quot;&quot;&quot;
 if target == 'lualong' or target == 'lua':
   lua_full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;src/lua/%s&quot; % name for name in lua_files.split() ] )
-  local_include = ['inc', 'inc/newlib', 'src/lua']
+  local_include = ['inc', 'inc/newlib',  'inc/remotefs', 'src/lua']
   if target == 'lualong':
     cdefs = cdefs + ' -DLUA_NUMBER_INTEGRAL'
 else:
@@ -316,6 +316,10 @@
 module_names = &quot;pio.c spi.c tmr.c pd.c uart.c term.c pwm.c lpack.c bit.c net.c cpu.c adc.c can.c luarpc.c bitarray.c elua.c&quot;
 module_files = &quot; &quot; + &quot; &quot;.join( [ &quot;src/modules/%s&quot; % name for name in module_names.split() ] )
 
+# Remote file system files
+rfs_names = &quot;remotefs.c client.c elua_os_io.c elua_rfs.c&quot;
+rfs_files = &quot; &quot; + &quot; &quot;.join( [ &quot;src/remotefs/%s&quot; % name for name in rfs_names.split() ] )
+
 # Optimizer flags (speed or size)
 #opt = &quot;-O3&quot;
 opt = &quot;-Os -fomit-frame-pointer&quot;
@@ -329,7 +333,7 @@
 execfile( &quot;src/platform/%s/conf.py&quot; % platform )
 
 # Complete file list
-source_files = app_files + specific_files + newlib_files + uip_files + lua_full_files + module_files
+source_files = app_files + specific_files + newlib_files + uip_files + lua_full_files + module_files + rfs_files
 
 # Make ROM File System first
 if not GetOption( 'clean' ):

Added: trunk/inc/elua_rfs.h
===================================================================
--- trunk/inc/elua_rfs.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/elua_rfs.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,11 @@
+// eLua remote file system 
+
+#ifndef __ELUA_RFS_H__
+#define __ELUA_RFS_H__
+
+#include &quot;devman.h&quot;
+
+DM_DEVICE* remotefs_init();
+
+#endif
+

Modified: trunk/inc/mmcfs.h
===================================================================
--- trunk/inc/mmcfs.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/mmcfs.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -5,12 +5,8 @@
 
 #include &quot;type.h&quot;
 #include &quot;devman.h&quot;
-// Maximum length of a filename in the filesystem
-#ifndef MAX_FNAME_LENGTH
-#define MAX_FNAME_LENGTH      30
-#endif
 
 // FS functions
-DM_DEVICE* mmcfs_init();
+const DM_DEVICE* mmcfs_init();
 
 #endif

Modified: trunk/inc/newlib/devman.h
===================================================================
--- trunk/inc/newlib/devman.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/newlib/devman.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -5,6 +5,7 @@
 
 #include &quot;type.h&quot;
 #include &lt;reent.h&gt;
+#include &lt;unistd.h&gt;
 
 // Maximum number of devices in the system
 #define DM_MAX_DEVICES        16
@@ -13,6 +14,9 @@
 // Maximum number of a device name
 #define DM_MAX_DEV_NAME       12
 
+// GLOBAL maximum file length (on ALL supported filesystem)
+#define DM_MAX_FNAME_LENGTH   30
+
 // Pack/unpack descriptions
 // Even if a file descriptor is an 'int', newlib treats it as a short, so we need to stuff
 // everything into 16 bits. Actually 15, since negative fd's are actually error indications
@@ -25,6 +29,17 @@
 #define DM_STDOUT_NUM             1
 #define DM_STDERR_NUM             2
 
+// Our platform independent &quot;dirent&quot; structure (for opendir/readdir)
+struct dm_dirent {
+  u32 fsize;
+  const char *fname;
+  u32 ftime;
+};
+typedef struct {
+  u8 devid;
+  void *userdata;
+} DM_DIR;
+
 // A device structure with pointers to all the device functions
 typedef struct
 {
@@ -33,7 +48,10 @@
   int ( *p_close_r )( struct _reent *r, int fd );
   _ssize_t ( *p_write_r ) ( struct _reent *r, int fd, const void *ptr, size_t len );
   _ssize_t ( *p_read_r )( struct _reent *r, int fd, void *ptr, size_t len );  
-  int ( *p_ioctl_r )( struct _reent *r, int file, unsigned long request, void *ptr );  
+  off_t ( *p_lseek_r )( struct _reent *r, int fd, off_t off, int whence );
+  void* ( *p_opendir_r )( struct _reent *r, const char* name );
+  struct dm_dirent* ( *p_readdir_r )( struct _reent *r, void *dir );  
+  int ( *p_closedir_r )( struct _reent *r, void* dir );  
 } DM_DEVICE;
 
 // Errors
@@ -41,10 +59,11 @@
 #define DM_ERR_NOT_REGISTERED       (-2)
 #define DM_ERR_NO_SPACE             (-3)
 #define DM_ERR_INVALID_NAME         (-4)
+#define DM_ERR_NO_DEVICE            (-5)
 #define DM_OK                       (0)
 
 // Add a device
-int dm_register( DM_DEVICE *pdev );
+int dm_register( const DM_DEVICE *pdev );
 // Unregister a device
 int dm_unregister( const char* name );
 // Get a device entry
@@ -54,4 +73,10 @@
 // Initialize device manager
 int dm_init();
 
+// DM specific functions (uniform over all the installed filesystems)
+DM_DIR *dm_opendir( const char* dirname );
+struct dm_dirent* dm_readdir( DM_DIR *d );
+int dm_closedir( DM_DIR *d );
+
 #endif
+

Modified: trunk/inc/newlib/genstd.h
===================================================================
--- trunk/inc/newlib/genstd.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/newlib/genstd.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -20,7 +20,7 @@
 // STD functions
 void std_set_send_func( p_std_send_char pfunc );
 void std_set_get_func( p_std_get_char pfunc );
-DM_DEVICE* std_get_desc();
+const DM_DEVICE* std_get_desc();
 
 #endif
 

Added: trunk/inc/remotefs/client.h
===================================================================
--- trunk/inc/remotefs/client.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/remotefs/client.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,29 @@
+// Remote filesystem client
+
+#ifndef __CLIENT_H__
+#define __CLIENT_H__
+
+#include &quot;type.h&quot;
+
+// Error codes
+#define CLIENT_OK   0
+#define CLIENT_ERR  1
+
+// RFS client send/receive functions
+typedef u32 ( *p_rfsc_send )( const u8 *p, u32 size );
+typedef u32 ( *p_rfsc_recv )( u8 *p, u32 size, u32 timeout );
+
+// Public interface
+void rfsc_setup( u8 *pbuf, p_rfsc_send rfsc_send_func, p_rfsc_recv rfsc_recv_func, u32 timeout );
+void rfsc_set_timeout( u32 timeout );
+int rfsc_open( const char* pathname, int flags, int mode );
+s32 rfsc_write( int fd, const void *buf, u32 count );
+s32 rfsc_read( int fd, void *buf, u32 count );
+s32 rfsc_lseek( int fd, s32 offset, int whence );
+int rfsc_close( int fd );
+u32 rfsc_opendir( const char* name );
+void rfsc_readdir( u32 d, const char **pname, u32 *psize, u32 *ptime );
+int rfsc_closedir( u32 d );
+
+#endif
+

Added: trunk/inc/remotefs/os_io.h
===================================================================
--- trunk/inc/remotefs/os_io.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/remotefs/os_io.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,29 @@
+// OS interface for file I/O manipulation
+
+#ifndef __OS_IO_H__
+#define __OS_IO_H__
+
+#include &quot;type.h&quot;
+
+#ifdef WIN32_BUILD
+#define PLATFORM_PATH_SEPARATOR     '\\'
+#define PLATFORM_MAX_FNAME_LEN      2048
+#else
+#define PLATFORM_PATH_SEPARATOR     '/'
+#define PLATFORM_MAX_FNAME_LEN      2048
+#endif
+
+int os_open( const char *pathname, int flags, int mode );
+u32 os_open_sys_flags_to_rfs_flags( int sysflags );
+s32 os_write( int fd, const void *buf, u32 count );
+s32 os_read( int fd, void *buf, u32 count );
+int os_close( int fd );
+s32 os_lseek( int fd, s32 offset, int whence );
+u32 os_lseek_sys_whence_to_rfs_whence( int syswhence );
+int os_isdir( const char *name );
+u32 os_opendir( const char* name );
+void os_readdir( u32 d, const char **pname );
+int os_closedir( u32 d );
+
+#endif
+

Added: trunk/inc/remotefs/remotefs.h
===================================================================
--- trunk/inc/remotefs/remotefs.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/remotefs/remotefs.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,120 @@
+// Remote file system implementation
+
+#ifndef __REMOTEFS_H__
+#define __REMOTEFS_H__
+
+#include &quot;type.h&quot;
+
+#define   PACKET_SIG      0x18AFC284UL
+
+// Error codes
+#define   REMOTEFS_OK     0
+#define   REMOTEFS_ERR    1
+
+// Operation IDs
+#define   RFS_OP_OPEN     0x01
+#define   RFS_OP_FIRST    RFS_OP_OPEN
+#define   RFS_OP_WRITE    0x02
+#define   RFS_OP_READ     0x03
+#define   RFS_OP_CLOSE    0x04
+#define   RFS_OP_LSEEK    0x05
+#define   RFS_OP_OPENDIR  0x06
+#define   RFS_OP_READDIR  0x07
+#define   RFS_OP_CLOSEDIR 0x08
+#define   RFS_OP_LAST     RFS_OP_CLOSEDIR
+#define   RFS_OP_RES_MOD  0x80
+
+// Protocol constants
+#define   RFS_START_OFFSET    4
+#define   RFS_START_SIZE      6
+#define   RFS_END_SIZE        6
+#define   RFS_RESPONSE_SIZE   1
+#define   RFS_PTR_HEADER_SIZE 6
+#define   RFS_U32_SIZE        5
+#define   RFS_OP_ID_SIZE      2
+#define   RFS_READ_BUF_OFFSET ( RFS_START_OFFSET + RFS_START_SIZE + RFS_RESPONSE_SIZE + RFS_PTR_HEADER_SIZE )
+#define   RFS_WRITE_REQUEST_EXTRA ( RFS_START_OFFSET + RFS_START_SIZE + RFS_OP_ID_SIZE + RFS_U32_SIZE + RFS_PTR_HEADER_SIZE + RFS_END_SIZE )
+
+// Platform independent constants for &quot;flags&quot; in &quot;open&quot;
+#define   RFS_OPEN_FLAG_APPEND      0x01
+#define   RFS_OPEN_FLAG_CREAT       0x02
+#define   RFS_OPEN_FLAG_EXCL        0x04
+#define   RFS_OPEN_FLAG_TRUNC       0x08
+#define   RFS_OPEN_FLAG_SYNC        0x10
+#define   RFS_OPEN_FLAG_RDONLY      0x20
+#define   RFS_OPEN_FLAG_WRONLY      0x40
+#define   RFS_OPEN_FLAG_RDWR        0x80
+
+// Platform independent seek modes for &quot;seek&quot;
+#define   RFS_LSEEK_SET             0x01
+#define   RFS_LSEEK_CUR             0x02
+#define   RFS_LSEEK_END             0x03
+
+// R/W pipe names (used only with the simulator)
+#define   RFS_SRV_WRITE_PIPE        &quot;/tmp/elua_srv_write&quot;
+#define   RFS_SRV_READ_PIPE         &quot;/tmp/elua_srv_read&quot;
+
+// Max filename size on a RFS instance
+#define   RFS_MAX_FNAME_SIZE        31
+
+// Public interface
+// Get request ID
+int remotefs_get_request_id( const u8 *p, u8 *pid );
+
+// Replace a flag with another flag
+u32 remotefs_replace_flag( u32 val, u32 origflag, u32 newflag );
+
+// Get packet size
+int remotefs_get_packet_size( const u8 *p, u16 *psize );
+
+// Function: int open(const char *pathname,int flags, mode_t mode)
+void remotefs_open_write_response( u8 *p, int result );
+int remotefs_open_read_response( const u8 *p, int *presult );
+void remotefs_open_write_request( u8 *p, const char* pathname, int flags, int mode );
+int remotefs_open_read_request( const u8 *p, const char **ppathname, int *pflags, int *pmode );
+
+// Function: ssize_t write(int fd, const void *buf, size_t count)
+void remotefs_write_write_response( u8 *p, u32 result );
+int remotefs_write_read_response( const u8 *p, u32 *presult );
+void remotefs_write_write_request( u8 *p, int fd, const void *buf, u32 count );
+int remotefs_write_read_request( const u8 *p, int *pfd, const void **pbuf, u32 *pcount );
+
+// Function: ssize_t read(int fd, void *buf, size_t count)
+void remotefs_read_write_response( u8 *p, u32 readbytes );
+int remotefs_read_read_response( const u8 *p, const u8 **ppdata, u32 *preadbytes );
+void remotefs_read_write_request( u8 *p, int fd, u32 count );
+int remotefs_read_read_request( const u8 *p, int *pfd, u32 *pcount );
+                                 
+// Function: int close( int fd )
+void remotefs_close_write_response( u8 *p, int result );
+int remotefs_close_read_response( const u8 *p, int *presult );
+void remotefs_close_write_request( u8 *p, int fd );
+int remotefs_close_read_request( const u8 *p, int *pfd );
+
+// Function: off_t lseek( int fd, off_t offset, int whence )
+void remotefs_lseek_write_response( u8 *p, s32 result );
+int remotefs_lseek_read_response( const u8 *p, s32 *presult );
+void remotefs_lseek_write_request( u8 *p, int fd, s32 offset, int whence );
+int remotefs_lseek_read_request( const u8 *p, int *pfd, s32 *poffset, int *pwhence );
+
+// Function: u32 opendir( const char* name )
+void remotefs_opendir_write_response( u8 *p, u32 d );
+int remotefs_opendir_read_response( const u8 *p, u32 *pd );
+void remotefs_opendir_write_request( u8 *p, const char* name );
+int remotefs_opendir_read_request( const u8 *p, const char **pname );
+
+// Function: void readdir( u32 d, const char **pname, u32 *psize, u32 *pftime );
+// Will return fname, size, ftime as side effects in response
+void remotefs_readdir_write_response( u8 *p, const char *name, u32 size, u32 ftime );
+int remotefs_readdir_read_response( const u8 *p, const char **pname, u32 *psize, u32 *pftime );
+void remotefs_readdir_write_request( u8 *p, u32 d );
+int remotefs_readdir_read_request( const u8 *p, u32 *pd );
+
+// Function: int closedir( u32 d )
+void remotefs_closedir_write_response( u8 *p, int d );
+int remotefs_closedir_read_response( const u8 *p, int *pd );
+void remotefs_closedir_write_request( u8 *p, u32 d );
+int remotefs_closedir_read_request( const u8 *p, u32 *pd );
+
+#endif
+

Added: trunk/inc/remotefs/rtype.h
===================================================================
--- trunk/inc/remotefs/rtype.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/remotefs/rtype.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,17 @@
+// Type definitions for the remote file system
+
+#ifndef __RTYPE_H__
+#define __RTYPE_H__
+
+// Type codes
+#define   TYPE_INT_8      0x01
+#define   TYPE_INT_16     0x02
+#define   TYPE_INT_32     0x03
+#define   TYPE_PTR        0x04
+#define   TYPE_START      0x05
+#define   TYPE_END        0x06
+#define   TYPE_OP_ID      0x07
+#define   TYPE_PKT_SIZE   0xA5
+                                    
+#endif
+

Modified: trunk/inc/romfs.h
===================================================================
--- trunk/inc/romfs.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/inc/romfs.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -5,14 +5,12 @@
 
 #include &quot;type.h&quot;
 #include &quot;devman.h&quot;
-// Maximum length of a filename in the filesystem
-#define MAX_FNAME_LENGTH      30
 
 /*******************************************************************************
 The Read-Only &quot;filesystem&quot; resides in a contiguous zone of memory, with the
 following structure, repeated for each file:
 
-Filename: ASCIIZ, max length is MAX_FNAME_LENGTH defined here, empty if last file
+Filename: ASCIIZ, max length is DM_MAX_FNAME_LENGTH defined here, empty if last file
 File size: (2 bytes)
 File data: (file size bytes)
 
@@ -38,8 +36,7 @@
 } FS;
   
 // FS functions
-DM_DEVICE* romfs_init();
-u32 romfs_get_dir_entry( u32 offset, char *fname, u16 *fsize );
+const DM_DEVICE* romfs_init();
 
 #endif
 

Added: trunk/rfs_server/client.c
===================================================================
--- trunk/rfs_server/client.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/client.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,139 @@
+// Remote filesystem client
+
+#include &lt;string.h&gt;
+#include &quot;remotefs.h&quot;
+#include &quot;client.h&quot;
+#include &quot;os_io.h&quot;
+
+// ****************************************************************************
+// Client local data
+
+static u8 *rfsc_buffer;
+static p_rfsc_send rfsc_send;
+static p_rfsc_recv rfsc_recv;
+static u32 rfsc_timeout;
+
+// ****************************************************************************
+// Client helpers
+
+static int rfsch_send_request_read_response()
+{
+  u16 temp16;
+
+  // Send request
+  if( remotefs_get_packet_size( rfsc_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+    return CLIENT_ERR;
+  if( rfsc_send( rfsc_buffer, temp16 ) != temp16 )
+    return CLIENT_ERR;
+  
+  // Get response
+  // First the length, then the rest of the data
+  if( rfsc_recv( rfsc_buffer, RFS_START_OFFSET, rfsc_timeout ) != RFS_START_OFFSET )
+    return CLIENT_ERR;
+  if( remotefs_get_packet_size( rfsc_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+    return CLIENT_ERR;
+  if( rfsc_recv( rfsc_buffer + RFS_START_OFFSET, temp16 - RFS_START_OFFSET, rfsc_timeout ) != temp16 - RFS_START_OFFSET )
+    return CLIENT_ERR;
+  return CLIENT_OK;
+}
+
+// ****************************************************************************
+// Client public interface
+
+void rfsc_setup( u8 *pbuf, p_rfsc_send rfsc_send_func, p_rfsc_recv rfsc_recv_func, u32 timeout )
+{
+  rfsc_buffer = pbuf;
+  rfsc_send = rfsc_send_func;
+  rfsc_recv = rfsc_recv_func;
+  rfsc_timeout = timeout;
+}
+
+void rfsc_set_timeout( u32 timeout )
+{
+  rfsc_timeout = timeout;
+}
+
+int rfsc_open( const char* pathname, int flags, int mode )
+{
+  int fd;
+
+  // Make the request
+  remotefs_open_write_request( rfsc_buffer, pathname, os_open_sys_flags_to_rfs_flags( flags ), mode );
+
+  // Send the request / get the respone
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_open_read_response( rfsc_buffer, &amp;fd ) == REMOTEFS_ERR )
+    return -1;
+  return fd;
+}
+
+s32 rfsc_write( int fd, const void *buf, u32 count )
+{
+  // Make the request
+  remotefs_write_write_request( rfsc_buffer, fd, buf, count );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+  
+  // Interpret the response
+  if( remotefs_write_read_response( rfsc_buffer, &amp;count ) == REMOTEFS_ERR )
+    return -1;
+  return ( s32 )count;
+}
+
+s32 rfsc_read( int fd, void *buf, u32 count )
+{
+  const u8 *resbuf;
+
+  // Make the request
+  remotefs_read_write_request( rfsc_buffer, fd, count );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_read_read_response( rfsc_buffer, &amp;resbuf, &amp;count ) == REMOTEFS_ERR )
+    return -1;
+  memcpy( buf, resbuf, count );
+  return ( s32 )count;
+}
+
+s32 rfsc_lseek( int fd, s32 offset, int whence )
+{
+  s32 res;
+
+  // Make the request
+  remotefs_lseek_write_request( rfsc_buffer, fd, offset, os_lseek_sys_whence_to_rfs_whence( whence ) );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_lseek_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+    return -1;
+  return res;
+}
+
+int rfsc_close( int fd )
+{
+  int res;
+
+  // Make the request
+  remotefs_close_write_request( rfsc_buffer, fd );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_close_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+    return -1;
+  return res;
+}
+

Added: trunk/rfs_server/client.h
===================================================================
--- trunk/rfs_server/client.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/client.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,26 @@
+// Remote filesystem client
+
+#ifndef __CLIENT_H__
+#define __CLIENT_H__
+
+#include &quot;type.h&quot;
+
+// Error codes
+#define CLIENT_OK   0
+#define CLIENT_ERR  1
+
+// RFS client send/receive functions
+typedef u32 ( *p_rfsc_send )( const u8 *p, u32 size );
+typedef u32 ( *p_rfsc_recv )( u8 *p, u32 size, u32 timeout );
+
+// Public interface
+void rfsc_setup( u8 *pbuf, p_rfsc_send rfsc_send_func, p_rfsc_recv rfsc_recv_func, u32 timeout );
+void rfsc_set_timeout( u32 timeout );
+int rfsc_open( const char* pathname, int flags, int mode );
+s32 rfsc_write( int fd, const void *buf, u32 count );
+s32 rfsc_read( int fd, void *buf, u32 count );
+s32 rfsc_lseek( int fd, s32 offset, int whence );
+int rfsc_close( int fd );
+
+#endif
+

Added: trunk/rfs_server/log.c
===================================================================
--- trunk/rfs_server/log.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/log.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,24 @@
+// Simple logging functions for the RFS server
+
+#include &quot;log.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+
+static int log_level;
+
+void log_init( int level )
+{
+  log_level = level;
+}
+
+void log_msg( const char *msg, ... )
+{
+  va_list va;
+  
+  if( log_level == LOG_ALL )
+  {
+    va_start( va, msg );
+    vprintf( msg, va );
+    va_end( va );  
+  }
+}

Added: trunk/rfs_server/log.h
===================================================================
--- trunk/rfs_server/log.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/log.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,13 @@
+// Simple logging functions for the RFS server
+
+#ifndef __LOG_H__
+#define __LOG_H__
+
+// Logging levels
+#define LOG_NONE        0
+#define LOG_ALL         1
+
+void log_init( int level );
+void log_msg( const char *msg, ... );
+
+#endif

Added: trunk/rfs_server/main.c
===================================================================
--- trunk/rfs_server/main.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/main.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,165 @@
+// Remote FS server
+
+#include &quot;remotefs.h&quot;
+#include &quot;serial.h&quot;
+#include &quot;server.h&quot;
+#include &quot;type.h&quot;
+#include &quot;log.h&quot;
+#include &quot;os_io.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+// ****************************************************************************
+// Local variables
+
+#define   MAX_PACKET_SIZE     4096
+
+static u8 rfs_buffer[ MAX_PACKET_SIZE + RFS_WRITE_REQUEST_EXTRA ]; 
+static ser_handler ser;
+
+// ****************************************************************************
+// Helpers
+
+static void flush_serial()
+{
+  // Flush all data in serial port
+  ser_set_timeout_ms( ser, SER_NO_TIMEOUT );
+  while( ser_read_byte( ser ) != -1 );
+  ser_set_timeout_ms( ser, SER_INF_TIMEOUT );
+}
+
+// Read a packet from the serial port
+static void read_request_packet()
+{
+  u16 temp16;
+  u32 readbytes;
+
+  while( 1 )
+  {
+    // First read the length
+    if( ( readbytes = ser_read( ser, rfs_buffer, RFS_START_OFFSET ) ) != RFS_START_OFFSET )
+    {
+      log_msg( &quot;read_request_packet: ERROR reading packet length. Requested %d bytes, got %d bytes\n&quot;, RFS_START_OFFSET, readbytes );
+      flush_serial();
+      continue;
+    }
+
+    if( remotefs_get_packet_size( rfs_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+    {
+      log_msg( &quot;read_request_packet: ERROR getting packet size.\n&quot; );
+      flush_serial();
+      continue;
+    }
+
+    // Then the rest of the data
+    if( ( readbytes = ser_read( ser, rfs_buffer + RFS_START_OFFSET, temp16 - RFS_START_OFFSET ) ) != temp16 - RFS_START_OFFSET )
+    {
+      log_msg( &quot;read_request_packet: ERROR reading full packet, got %u bytes, expected %u bytes\n&quot;, ( unsigned )readbytes, ( unsigned )temp16 - RFS_START_OFFSET );
+      flush_serial();
+      continue;
+    }
+    else
+      break;
+  }
+}
+
+// Send a packet to the serial port
+static void send_response_packet()
+{
+  u16 temp16;
+
+  // Send request
+  if( remotefs_get_packet_size( rfs_buffer, &amp;temp16 ) != REMOTEFS_ERR )
+  {
+    log_msg( &quot;send_response_packet: sending response packet of %u bytes\n&quot;, ( unsigned )temp16 );
+    ser_write( ser, rfs_buffer, temp16 );
+  }
+}
+
+// Secure atoi
+static int secure_atoi( const char *str, long *pres )
+{
+  char *end_ptr;
+  long s1;
+  
+  errno = 0;
+  s1 = strtol( str, &amp;end_ptr, 10 );
+  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
+    return 0;
+  else if( end_ptr == str )
+    return 0;
+  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
+    return 0;
+  else if( '\0' != *end_ptr )
+    return 0;
+  *pres = s1;
+  return 1;  
+}
+
+// ****************************************************************************
+// Entry point
+
+#define PORT_ARG_IDX          1
+#define SPEED_ARG_IDX         2
+#define DIRNAME_ARG_IDX       3
+#define VERBOSE_ARG_IDX       4
+
+int main( int argc, const char **argv )
+{
+  long serspeed;
+  
+  if( argc &lt; 4 )
+  {
+    fprintf( stderr, &quot;Usage: %s &lt;port&gt; &lt;speed&gt; &lt;dirname&gt; [-v]\n&quot;, argv[ 0 ] );
+    fprintf( stderr, &quot;(use -v for verbose output).\n&quot;);
+    return 1;
+  }
+  if( secure_atoi( argv[ SPEED_ARG_IDX ], &amp;serspeed ) == 0 )
+  {
+    fprintf( stderr, &quot;Invalid speed\n&quot; );
+    return 1;
+  } 
+  if( !os_isdir( argv[ DIRNAME_ARG_IDX ] ) )
+  {
+    fprintf( stderr, &quot;Invalid directory %s\n&quot;, argv[ DIRNAME_ARG_IDX ] );
+    return 1;
+  }
+  if( ( argc &gt;= 5 ) &amp;&amp; !strcmp( argv[ VERBOSE_ARG_IDX ], &quot;-v&quot; ) )
+    log_init( LOG_ALL );
+  else
+    log_init( LOG_NONE );
+
+  // Setup RFS server
+  server_setup( argv[ DIRNAME_ARG_IDX ] );
+
+  // Setup serial port
+  if( ( ser = ser_open( argv[ PORT_ARG_IDX ] ) ) == ( ser_handler )-1 )
+  {
+    fprintf( stderr, &quot;Cannot open port %s\n&quot;, argv[ PORT_ARG_IDX ] );
+    return 1;
+  }
+  if( ser_setup( ser, ( u32 )serspeed, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
+  {
+    fprintf( stderr, &quot;Unable to initialize serial port\n&quot; );
+    return 1;
+  }
+  flush_serial();
+  
+  // User report
+  printf( &quot;Running RFS server on port %s (%u baud) in directory %s\n&quot;, argv[ PORT_ARG_IDX ], ( unsigned )serspeed, argv[ DIRNAME_ARG_IDX ] );  
+
+  // Enter the server endless loop
+  while( 1 )
+  {
+    read_request_packet();
+    server_execute_request( rfs_buffer );
+    send_response_packet();
+  }
+
+  ser_close( ser );
+  return 0;
+}
+

Added: trunk/rfs_server/main_sim.c
===================================================================
--- trunk/rfs_server/main_sim.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/main_sim.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,128 @@
+// Remote FS server
+
+#include &quot;remotefs.h&quot;
+#include &quot;server.h&quot;
+#include &quot;type.h&quot;
+#include &quot;log.h&quot;
+#include &quot;os_io.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;unistd.h&gt;
+
+// ****************************************************************************
+// Local variables
+
+#define   MAX_PACKET_SIZE     4096
+
+static u8 rfs_buffer[ MAX_PACKET_SIZE + RFS_WRITE_REQUEST_EXTRA ]; 
+static int rfs_read_fd;
+static int rfs_write_fd;
+
+// ****************************************************************************
+// Helpers
+
+// Read a packet from the serial port
+static void read_request_packet()
+{
+  u16 temp16;
+  u32 readbytes;
+
+  while( 1 )
+  {
+    // First read the length
+    if( ( readbytes = read( rfs_read_fd, rfs_buffer, RFS_START_OFFSET ) ) != RFS_START_OFFSET )
+    {
+//      log_msg( &quot;read_request_packet: ERROR reading packet length. Requested %d bytes, got %d bytes\n&quot;, RFS_START_OFFSET, readbytes );
+      continue;
+    }
+
+    if( remotefs_get_packet_size( rfs_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+    {
+      // log_msg( &quot;read_request_packet: ERROR getting packet size.\n&quot; );
+      continue;
+    }
+
+    // Then the rest of the data
+    if( ( readbytes = read( rfs_read_fd, rfs_buffer + RFS_START_OFFSET, temp16 - RFS_START_OFFSET ) ) != temp16 - RFS_START_OFFSET )
+    {
+      // log_msg( &quot;read_request_packet: ERROR reading full packet, got %u bytes, expected %u bytes\n&quot;, ( unsigned )readbytes, ( unsigned )temp16 - RFS_START_OFFSET );
+      continue;
+    }
+    else
+      break;
+  }
+}
+
+// Send a packet to the serial port
+static void send_response_packet()
+{
+  u16 temp16;
+
+  // Send request
+  if( remotefs_get_packet_size( rfs_buffer, &amp;temp16 ) != REMOTEFS_ERR )
+  {
+    log_msg( &quot;send_response_packet: sending response packet of %u bytes\n&quot;, ( unsigned )temp16 );
+    write( rfs_write_fd, rfs_buffer, temp16 );
+  }
+}
+
+// ****************************************************************************
+// Entry point
+
+#define DIRNAME_ARG_IDX       1
+#define VERBOSE_ARG_IDX       2
+
+int main( int argc, const char **argv )
+{
+  if( argc &lt; 2 )
+  {
+    fprintf( stderr, &quot;Usage: %s &lt;dirname&gt; [-v]\n&quot;, argv[ 0 ] );
+    fprintf( stderr, &quot;(use -v for verbose output).\n&quot;);
+    return 1;
+  }
+  if( !os_isdir( argv[ DIRNAME_ARG_IDX ] ) )
+  {
+    fprintf( stderr, &quot;Invalid directory %s\n&quot;, argv[ DIRNAME_ARG_IDX ] );
+    return 1;
+  }
+  if( ( argc &gt;= 3 ) &amp;&amp; !strcmp( argv[ VERBOSE_ARG_IDX ], &quot;-v&quot; ) )
+    log_init( LOG_ALL );
+  else
+    log_init( LOG_NONE );
+
+  // Create and open FIFOs
+  mkfifo( RFS_SRV_READ_PIPE, 0666 );
+  mkfifo( RFS_SRV_WRITE_PIPE, 0666 );
+  rfs_write_fd = open( RFS_SRV_WRITE_PIPE, O_WRONLY, 0 );
+  rfs_read_fd = open( RFS_SRV_READ_PIPE, O_RDONLY, 0 );
+  if( rfs_read_fd == -1 || rfs_write_fd == -1 )
+  {
+    fprintf( stderr, &quot;Unable to open pipes\n&quot; );
+    return 1;
+  }
+  printf( &quot;Running in SIM mode (pipes)\n&quot; );
+
+  // Setup RFS server
+  server_setup( argv[ DIRNAME_ARG_IDX ] );
+
+  // Enter the server endless loop
+  while( 1 )
+  {
+    read_request_packet();
+    server_execute_request( rfs_buffer );
+    send_response_packet();
+  }
+
+  close( rfs_write_fd );
+  close( rfs_read_fd );
+  unlink( RFS_SRV_READ_PIPE );
+  unlink( RFS_SRV_WRITE_PIPE );
+  return 0;
+}
+

Added: trunk/rfs_server/os_io_posix.c
===================================================================
--- trunk/rfs_server/os_io_posix.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/os_io_posix.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,145 @@
+// A POSIX implementatoin of the os_io.h interface
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;string.h&gt;
+#include &quot;os_io.h&quot;
+#include &quot;remotefs.h&quot;
+
+int os_open( const char *pathname, int flags, int mode )
+{
+  int realflags = 0;
+
+  // Translate RFS flags to POSIX flags
+  realflags = remotefs_replace_flag( flags, RFS_OPEN_FLAG_APPEND, O_APPEND );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_CREAT, O_CREAT );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_EXCL, O_EXCL );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_TRUNC, O_TRUNC );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_SYNC, O_SYNC );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_RDONLY, O_RDONLY );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_WRONLY, O_WRONLY );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_RDWR, O_RDWR );
+  return open( pathname, realflags, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ); 
+}
+
+u32 os_open_sys_flags_to_rfs_flags( int sysflags )
+{
+  int rfsflags = 0;
+
+  // Translate RFS flags to POSIX flags
+  rfsflags = remotefs_replace_flag( sysflags, O_APPEND, RFS_OPEN_FLAG_APPEND );
+  rfsflags |= remotefs_replace_flag( sysflags, O_CREAT, RFS_OPEN_FLAG_CREAT );
+  rfsflags |= remotefs_replace_flag( sysflags, O_EXCL, RFS_OPEN_FLAG_EXCL );
+  rfsflags |= remotefs_replace_flag( sysflags, O_TRUNC, RFS_OPEN_FLAG_TRUNC );
+  rfsflags |= remotefs_replace_flag( sysflags, O_SYNC, RFS_OPEN_FLAG_SYNC );
+  rfsflags |= remotefs_replace_flag( sysflags, O_RDONLY, RFS_OPEN_FLAG_RDONLY );
+  rfsflags |= remotefs_replace_flag( sysflags, O_WRONLY, RFS_OPEN_FLAG_WRONLY );
+  rfsflags |= remotefs_replace_flag( sysflags, O_RDWR, RFS_OPEN_FLAG_RDWR );
+  return rfsflags;
+}
+
+s32 os_write( int fd, const void *buf, u32 count )
+{
+  return ( s32 )write( fd, buf, ( size_t )count );
+}
+
+s32 os_read( int fd, void *buf, u32 count )
+{
+  return ( s32 )read( fd, buf, ( size_t )count );
+}
+
+int os_close( int fd )
+{
+  return close( fd );
+}
+
+s32 os_lseek( int fd, s32 offset, int whence )
+{
+  int realwhence = 0;
+
+  // Translate RFS whence to POSIX whence
+  switch( whence )
+  {
+    case RFS_LSEEK_SET:
+      realwhence = SEEK_SET;
+      break;
+
+   case RFS_LSEEK_CUR:
+     realwhence = SEEK_CUR;
+     break;
+
+   case RFS_LSEEK_END:
+     realwhence = SEEK_END;
+     break;
+
+   default:
+     return -1;
+  }
+  return ( s32 )lseek( fd, ( off_t )offset, realwhence );
+}
+
+u32 os_lseek_sys_whence_to_rfs_whence( int syswhence )
+{
+  switch( syswhence )
+  {
+    case SEEK_SET:
+      return RFS_LSEEK_SET;
+
+    case SEEK_CUR:
+      return RFS_LSEEK_CUR;
+
+    case SEEK_END:
+      return RFS_LSEEK_END;
+  }
+  return 0;
+}
+
+int os_isdir( const char* name )
+{
+  struct stat res;
+
+  if( stat( name, &amp;res ) == -1 )
+    return 0;
+  else
+    return S_ISDIR( res.st_mode );
+}
+
+u32 os_opendir( const char* name )
+{
+  if( name || strlen( name ) == 0 || ( strlen( name ) == 1 &amp;&amp; !strcmp( name, &quot;/&quot; ) ) )
+    return ( u32 )opendir( name );
+  return 0;
+}
+
+void os_readdir( u32 d, const char **pname )
+{
+  struct dirent *ent;
+  static char realname[ RFS_MAX_FNAME_SIZE + 1 ]; 
+
+  while( 1 )
+  {
+    ent = readdir( ( DIR* )d );
+    if( ent == NULL )
+    {
+      *pname = NULL;
+      break;
+    }
+    if( ent-&gt;d_type &amp; DT_REG )
+    {
+      realname[ 0 ] = realname[ RFS_MAX_FNAME_SIZE ] = '\0';
+      strncpy( realname, ent-&gt;d_name, RFS_MAX_FNAME_SIZE );
+      *pname = realname;
+      break;
+    }
+  }
+}
+
+int os_closedir( u32 d )
+{
+  return closedir( ( DIR* )d );
+}
+

Added: trunk/rfs_server/os_io_win32.c
===================================================================
--- trunk/rfs_server/os_io_win32.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/os_io_win32.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,106 @@
+// A Win32 implementation of the os_io.h interface
+
+#include &lt;io.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;share.h&gt;
+#include &lt;windows.h&gt;
+#include &quot;os_io.h&quot;
+#include &quot;remotefs.h&quot;
+
+int os_open( const char *pathname, int flags, int mode )
+{
+  int realflags = 0;
+
+  // Translate RFS flags to POSIX flags                                                                                                     
+  realflags = remotefs_replace_flag( flags, RFS_OPEN_FLAG_APPEND, _O_APPEND );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_CREAT, _O_CREAT );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_EXCL, _O_EXCL );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_TRUNC, _O_TRUNC );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_RDONLY, _O_RDONLY );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_WRONLY, _O_WRONLY );
+  realflags |= remotefs_replace_flag( flags, RFS_OPEN_FLAG_RDWR, _O_RDWR );
+  return _sopen( pathname, realflags, _SH_DENYNO, _S_IREAD | _S_IWRITE ); 
+}
+
+u32 os_open_sys_flags_to_rfs_flags( int sysflags )
+{
+  int rfsflags = 0;
+
+  // Translate RFS flags to POSIX flags
+  rfsflags = remotefs_replace_flag( sysflags, _O_APPEND, RFS_OPEN_FLAG_APPEND );
+  rfsflags |= remotefs_replace_flag( sysflags, _O_CREAT, RFS_OPEN_FLAG_CREAT );
+  rfsflags |= remotefs_replace_flag( sysflags, _O_EXCL, RFS_OPEN_FLAG_EXCL );
+  rfsflags |= remotefs_replace_flag( sysflags, _O_TRUNC, RFS_OPEN_FLAG_TRUNC );
+  rfsflags |= remotefs_replace_flag( sysflags, _O_RDONLY, RFS_OPEN_FLAG_RDONLY );
+  rfsflags |= remotefs_replace_flag( sysflags, _O_WRONLY, RFS_OPEN_FLAG_WRONLY );
+  rfsflags |= remotefs_replace_flag( sysflags, _O_RDWR, RFS_OPEN_FLAG_RDWR );
+  return rfsflags;
+}
+
+s32 os_write( int fd, const void *buf, u32 count )
+{
+  return ( s32 )_write( fd, buf, ( unsigned int )count );
+}
+
+s32 os_read( int fd, void *buf, u32 count )
+{
+  return ( s32 )_read( fd, buf, ( unsigned int )count );
+}
+
+int os_close( int fd )
+{
+  return _close( fd );
+}
+
+s32 os_lseek( int fd, s32 offset, int whence )
+{
+  int realwhence = 0;
+
+  // Translate RFS whence to POSIX whence
+  switch( whence )
+  {
+    case RFS_LSEEK_SET:
+      realwhence = SEEK_SET;
+      break;
+
+   case RFS_LSEEK_CUR:
+     realwhence = SEEK_CUR;
+     break;
+
+   case RFS_LSEEK_END:
+     realwhence = SEEK_END;
+     break;
+
+   default:
+     return -1;
+  }
+  return ( s32 )_lseek( fd, ( long )offset, realwhence );
+}
+
+u32 os_lseek_sys_whence_to_rfs_whence( int syswhence )
+{
+  switch( syswhence )
+  {
+    case SEEK_SET:
+      return RFS_LSEEK_SET;
+
+    case SEEK_CUR:
+      return RFS_LSEEK_CUR;
+
+    case SEEK_END:
+      return RFS_LSEEK_END;
+  }
+  return 0;
+}
+
+int os_isdir( const char* name )
+{
+  DWORD attrs = GetFileAttributes( ( LPCTSTR )name );
+  
+  if( attrs == INVALID_FILE_ATTRIBUTES )
+    return 0;
+  else 
+    return attrs &amp; FILE_ATTRIBUTE_DIRECTORY;
+}

Added: trunk/rfs_server/rtype.h
===================================================================
--- trunk/rfs_server/rtype.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/rtype.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,17 @@
+// Type definitions for the remote file system
+
+#ifndef __RTYPE_H__
+#define __RTYPE_H__
+
+// Type codes
+#define   TYPE_INT_8      0x01
+#define   TYPE_INT_16     0x02
+#define   TYPE_INT_32     0x03
+#define   TYPE_PTR        0x04
+#define   TYPE_START      0x05
+#define   TYPE_END        0x06
+#define   TYPE_OP_ID      0x07
+#define   TYPE_PKT_SIZE   0xA5
+                                    
+#endif
+

Added: trunk/rfs_server/serial.h
===================================================================
--- trunk/rfs_server/serial.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/serial.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,41 @@
+// STM32 loader serial interface
+
+#ifndef __SERIAL_H__
+#define __SERIAL_H__
+
+#include &quot;type.h&quot;
+
+#define SER_INF_TIMEOUT         0xFFFFFFFF
+#define SER_NO_TIMEOUT          0
+#define SER_OK                  0
+#define SER_ERR                 1
+
+// Serial interface modes (blocking or non blocking)
+#define SER_MODE_BLOCKING       0
+#define SER_MODE_NONBLOCKING    1
+
+// Setup constants
+#define SER_PARITY_NONE         0
+#define SER_PARITY_EVEN         1
+#define SER_PARITY_ODD          2
+
+#define SER_STOPBITS_1          0
+#define SER_STOPBITS_1_5        1
+#define SER_STOPBITS_2          2
+
+#define SER_DATABITS_5          5
+#define SER_DATABITS_6          6
+#define SER_DATABITS_7          7
+#define SER_DATABITS_8          8
+
+// Serial access functions (to be implemented by each platform)
+ser_handler ser_open( const char *sername );
+void ser_close( ser_handler id );
+int ser_setup( ser_handler id, u32 baud, int databits, int parity, int stopbits );
+u32 ser_read( ser_handler id, u8* dest, u32 maxsize );
+int ser_read_byte( ser_handler id );
+u32 ser_write( ser_handler id, const u8 *src, u32 size );
+u32 ser_write_byte( ser_handler id, u8 data );
+void ser_set_timeout_ms( ser_handler id, u32 timeout );
+
+#endif

Added: trunk/rfs_server/serial_posix.c
===================================================================
--- trunk/rfs_server/serial_posix.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/serial_posix.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,197 @@
+// Serial inteface implementation for POSIX-compliant systems
+
+#include &quot;serial.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;termios.h&gt;
+#include &lt;sys/select.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;sys/types.h&gt;
+
+static u32 ser_timeout = SER_INF_TIMEOUT;
+
+// Open the serial port
+ser_handler ser_open( const char* sername )
+{
+  int fd;
+
+  if( ( fd = open( sername, O_RDWR | O_NOCTTY | O_NDELAY ) ) == -1 )
+    perror( &quot;ser_open: unable to open port&quot; );
+  else
+    fcntl( fd, F_SETFL, 0 );
+  return ( ser_handler )fd;
+}
+
+// Close the serial port
+void ser_close( ser_handler id )
+{
+  close( ( int )id );
+}
+
+// Helper function: get baud ID from actual baud rate
+#define BAUDCASE(x)  case x: return B##x
+static u32 ser_baud_to_id( u32 baud )
+{
+  switch( baud )
+  {
+    BAUDCASE( 1200 );
+    BAUDCASE( 1800 );
+    BAUDCASE( 2400 );
+    BAUDCASE( 4800 );
+    BAUDCASE( 9600 );
+    BAUDCASE( 19200 );
+    BAUDCASE( 38400 );
+    BAUDCASE( 57600 );
+    BAUDCASE( 115200 );
+    BAUDCASE( 230400 );
+  }
+  return 0;
+}
+
+// Helper function: get number of bits ID from actual number of bits
+#define NBCASE(x) case x: return CS##x
+static int ser_number_of_bits_to_id( int nb )
+{
+  switch( nb )
+  {
+    NBCASE( 5 );
+    NBCASE( 6 );
+    NBCASE( 7 );
+    NBCASE( 8 );
+  }
+  return 0;
+}
+
+int ser_setup( ser_handler id, u32 baud, int databits, int parity, int stopbits )
+{
+  struct termios termdata;
+  int hnd = ( int )id;
+
+  usleep( 200000 );
+  tcgetattr( hnd, &amp;termdata );
+
+  // Baud rate
+  cfsetispeed( &amp;termdata, ser_baud_to_id( baud ) );
+  cfsetospeed( &amp;termdata, ser_baud_to_id( baud ) );
+
+  // Parity / stop bits
+  termdata.c_cflag &amp;= ~CSTOPB;
+  if( parity == SER_PARITY_NONE ) // no parity
+  {
+    termdata.c_cflag &amp;= ~PARENB;
+  }
+  else if( parity == SER_PARITY_EVEN ) // even parity
+  {
+    termdata.c_cflag |= PARENB;
+    termdata.c_cflag &amp;= ~PARODD;
+  }
+  else if( parity == SER_PARITY_ODD ) // odd parity
+  {
+    termdata.c_cflag |= PARENB;
+    termdata.c_cflag |= PARODD;
+  }
+
+   // Data bits
+  termdata.c_cflag |= ( CLOCAL | CREAD );
+  termdata.c_cflag &amp;= ~CSIZE;
+  termdata.c_cflag |= ser_number_of_bits_to_id( databits );
+
+  // Disable HW and SW flow control
+  termdata.c_cflag &amp;= ~CRTSCTS;
+  termdata.c_iflag &amp;= ~( IXON | IXOFF | IXANY );
+
+  // Raw input
+  termdata.c_lflag &amp;= ~( ICANON | ECHO | ECHOE | ISIG );
+
+  // Raw output
+  termdata.c_oflag &amp;= ~OPOST;
+
+  // Check and strip parity bit
+  if( parity == SER_PARITY_NONE )
+    termdata.c_iflag &amp;= ~( INPCK | ISTRIP );
+  else
+    termdata.c_iflag |= ( INPCK | ISTRIP );
+
+  termdata.c_cc[ VMIN ] = 1;
+  termdata.c_cc[ VTIME ] = 0;
+
+  // Set the attibutes now
+  tcsetattr( hnd, TCSANOW, &amp;termdata );
+
+  // Flush everything
+  tcflush( hnd, TCIOFLUSH );
+
+  // And set blocking mode by default
+  fcntl( id, F_SETFL, 0 );
+
+  // All done
+  return SER_OK;
+}
+
+// Read up to the specified number of bytes, return bytes actually read
+u32 ser_read( ser_handler id, u8* dest, u32 maxsize )
+{
+  struct termios termdata;
+
+  tcgetattr( id, &amp;termdata );
+  if( ser_timeout == SER_INF_TIMEOUT )
+  {
+    termdata.c_cc[ VMIN ] = maxsize;
+    termdata.c_cc[ VTIME ] = 0;
+    tcsetattr( id, TCSANOW, &amp;termdata );
+    return ( u32 )read( ( int )id, dest, maxsize );
+  }
+  else
+  {
+    fd_set readfs;
+    struct timeval tv;
+    int retval;
+
+    termdata.c_cc[ VMIN ] = 1;
+    termdata.c_cc[ VTIME ] = 0;
+    tcsetattr( id, TCSANOW, &amp;termdata );
+    FD_ZERO( &amp;readfs );
+    FD_SET( ( int )id, &amp;readfs );
+    tv.tv_sec = ser_timeout / 1000000;
+    tv.tv_usec = ( ser_timeout % 1000000 ) * 1000;
+    retval = select( ( int )id + 1, &amp;readfs, NULL, NULL, &amp;tv );
+    if( retval == -1 || retval == 0 )
+      return 0;
+    else 
+      return ( u32 )read( ( int )id, dest, maxsize );
+  }
+}
+
+// Read a single byte and return it (or -1 for error)
+int ser_read_byte( ser_handler id )
+{
+  u8 data;
+  int res = ser_read( id, &amp;data, 1 );
+
+  return res == 1 ? data : -1;
+}
+
+// Write up to the specified number of bytes, return bytes actually written
+u32 ser_write( ser_handler id, const u8 *src, u32 size )
+{
+  u32 res;
+  
+  res = ( u32 )write( ( int )id, src, size );
+  return res;
+}
+
+// Write a byte to the serial port
+u32 ser_write_byte( ser_handler id, u8 data )
+{
+  return ( u32 )write( id, &amp;data, 1 );
+}
+
+// Set communication timeout
+void ser_set_timeout_ms( ser_handler id, u32 timeout )
+{
+  ser_timeout = timeout;
+}
+

Added: trunk/rfs_server/serial_win32.c
===================================================================
--- trunk/rfs_server/serial_win32.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/serial_win32.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,150 @@
+// Serial inteface implementation for POSIX-compliant systems
+
+#include &lt;windows.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &quot;type.h&quot;
+#include &quot;serial.h&quot;
+
+#define WIN_ERROR     ( HANDLE )-1
+#define WIN_MAX_PORT_NAME   1024
+
+// Helper: set timeout
+static int ser_win32_set_timeouts( HANDLE hComm, DWORD ri, DWORD rtm, DWORD rtc, DWORD wtm, DWORD wtc )
+{   
+  COMMTIMEOUTS timeouts;
+  
+  if( GetCommTimeouts( hComm, &amp;timeouts ) == FALSE )
+  {
+    CloseHandle( hComm );
+    return SER_ERR;
+  }
+  timeouts.ReadIntervalTimeout = ri;
+  timeouts.ReadTotalTimeoutConstant = rtm;
+  timeouts.ReadTotalTimeoutMultiplier = rtc;
+  timeouts.WriteTotalTimeoutConstant = wtm;
+  timeouts.WriteTotalTimeoutMultiplier = wtc;
+	if( SetCommTimeouts( hComm, &amp;timeouts ) == FALSE )
+	{
+	  CloseHandle( hComm );
+	  return SER_ERR;
+  }               
+  
+  return SER_OK;
+}
+
+// Open the serial port
+ser_handler ser_open( const char* sername )
+{
+  char portname[ WIN_MAX_PORT_NAME + 1 ];
+  HANDLE hComm;
+  
+  portname[ 0 ] = portname[ WIN_MAX_PORT_NAME ] = '\0';
+  _snprintf( portname, WIN_MAX_PORT_NAME, &quot;\\\\.\\%s&quot;, sername );
+  hComm = CreateFile( portname, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0 );
+  if( hComm == INVALID_HANDLE_VALUE )
+    return WIN_ERROR;
+  if( !SetupComm( hComm, 2048, 2048 ) )
+    return WIN_ERROR;
+  return hComm;
+}
+
+// Close the serial port
+void ser_close( ser_handler id )
+{
+  CloseHandle( id );
+}
+
+int ser_setup( ser_handler id, u32 baud, int databits, int parity, int stopbits )
+{
+  HANDLE hComm = ( HANDLE )id;
+  DCB dcb;
+  
+	if( GetCommState( hComm, &amp;dcb ) == FALSE )
+	{
+		CloseHandle( hComm );
+		return SER_ERR;
+	}
+  dcb.BaudRate = baud;
+  dcb.ByteSize = databits;
+  dcb.Parity = parity == SER_PARITY_NONE ? NOPARITY : ( parity == SER_PARITY_EVEN ? EVENPARITY : ODDPARITY );
+  dcb.StopBits = stopbits == SER_STOPBITS_1 ? ONESTOPBIT : ( stopbits == SER_STOPBITS_1_5 ? ONE5STOPBITS : TWOSTOPBITS );
+  dcb.fBinary = TRUE;
+  dcb.fDsrSensitivity = FALSE;
+  dcb.fParity = parity != SER_PARITY_NONE ? TRUE : FALSE;
+  dcb.fOutX = FALSE;
+  dcb.fInX = FALSE;
+  dcb.fNull = FALSE;
+  /**/ dcb.fAbortOnError = FALSE;
+  dcb.fOutxCtsFlow = FALSE;
+  dcb.fOutxDsrFlow = FALSE;
+  dcb.fDtrControl = DTR_CONTROL_DISABLE;
+  dcb.fDsrSensitivity = FALSE;
+  dcb.fRtsControl = RTS_CONTROL_DISABLE;
+  dcb.fOutxCtsFlow = FALSE;
+  if( SetCommState( hComm, &amp;dcb ) == 0 )
+  {
+    CloseHandle( hComm );
+    return SER_ERR;
+  }
+  
+  if( ser_win32_set_timeouts( hComm, 0, 0, 0, 0, 0 ) == SER_ERR )
+  {
+    CloseHandle( hComm );
+    return SER_ERR;
+  }
+  
+  FlushFileBuffers( hComm );
+
+  return SER_OK;
+}
+
+// Read up to the specified number of bytes, return bytes actually read
+u32 ser_read( ser_handler id, u8* dest, u32 maxsize )
+{
+  HANDLE hComm = ( HANDLE )id;
+  DWORD readbytes;
+  
+  if( ReadFile( hComm, dest, maxsize, &amp;readbytes, NULL ) == FALSE )
+    return 0;
+  return readbytes;
+}
+
+// Read a single byte and return it (or -1 for error)
+int ser_read_byte( ser_handler id )
+{
+  u8 data;
+  int res = ser_read( id, &amp;data, 1 );
+
+  //printf( &quot;READ %02X, res is %d\n&quot;, data, res );
+  return res == 1 ? data : -1;
+}
+
+// Write up to the specified number of bytes, return bytes actually written
+u32 ser_write( ser_handler id, const u8 *src, u32 size )
+{
+  HANDLE hComm = ( HANDLE )id;
+	DWORD written;
+	
+  if( WriteFile( hComm, src, size, &amp;written, NULL ) == FALSE )
+    return 0;
+  return written;
+}
+
+// Write a byte to the serial port
+u32 ser_write_byte( ser_handler id, u8 data )
+{
+  return ser_write( id, &amp;data, 1 );
+}
+
+// Set communication timeout
+void ser_set_timeout_ms( ser_handler id, u32 timeout )
+{
+  if( timeout == SER_NO_TIMEOUT )
+    ser_win32_set_timeouts( id, MAXDWORD, 0, 0, 0, 0 );
+  else if( timeout == SER_INF_TIMEOUT )
+    ser_win32_set_timeouts( id, 0, 0, 0, 0, 0 );
+  else
+    ser_win32_set_timeouts( id, 0, 0, timeout, 0, 0 );
+}
+

Added: trunk/rfs_server/server.c
===================================================================
--- trunk/rfs_server/server.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/server.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,249 @@
+// Remote filesystem server implementation
+
+#include &lt;string.h&gt;
+#include &quot;server.h&quot;
+#include &quot;remotefs.h&quot;
+#include &quot;type.h&quot;
+#include &quot;os_io.h&quot;
+#include &quot;log.h&quot;
+
+static char* server_basedir;
+static char server_fullname[ PLATFORM_MAX_FNAME_LEN + 1 ];
+
+#ifdef DEBUG
+#include &lt;stdio.h&gt;
+#define LOG0(str) printf( str&quot;\n&quot; )
+#define LOG1(str, arg1) printf( str&quot;\n&quot;, arg1 )
+#define LOG2(str, arg1, arg2) printf( str&quot;\n&quot;, arg1, arg2 )
+#define LOG3(str, arg1, arg2, arg3) printf( str&quot;\n&quot;, arg1, arg2, arg3 )
+#else
+#define LOG0(str)
+#define LOG1(str, arg1)
+#define LOG2(str, arg1, arg2)
+#define LOG3(str, arg1, arg2, arg3)
+#endif
+
+typedef int ( *p_server_handler )( u8 *p );
+
+// *****************************************************************************
+// Internal helpers: execute the given request, build the response
+
+static int server_open( u8 *p )
+{
+  const char *filename;
+  int mode, flags, fd;
+  char separator[ 2 ] = { PLATFORM_PATH_SEPARATOR, 0 };
+  
+  // Validate request
+  log_msg( &quot;server_open: request handler starting\n&quot; );
+  if( remotefs_open_read_request( p, &amp;filename, &amp;flags, &amp;mode ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_open: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  // Get real filename
+  server_fullname[ 0 ] = server_fullname[ PLATFORM_MAX_FNAME_LEN ] = 0;
+  strncpy( server_fullname, server_basedir, PLATFORM_MAX_FNAME_LEN );
+  if( filename &amp;&amp; strlen( filename ) &gt; 0 )
+  {
+    if( server_fullname[ strlen( server_fullname ) - 1 ] != PLATFORM_PATH_SEPARATOR )
+      strncat( server_fullname, separator, PLATFORM_MAX_FNAME_LEN );
+    strncat( server_fullname, filename, PLATFORM_MAX_FNAME_LEN );
+  }
+  log_msg( &quot;server_open: full file path is %s\n&quot;, server_fullname ); 
+  fd = os_open( server_fullname, flags, mode );
+  log_msg( &quot;server_open: OS file handler is %d\n&quot;, fd );
+  remotefs_open_write_response( p, fd );
+  return SERVER_OK;
+}
+
+static int server_write( u8 *p )
+{
+  int fd;
+  const void *buf;
+  u32 count;
+  
+  log_msg( &quot;server_write: request handler starting\n&quot; );
+  if( remotefs_write_read_request( p, &amp;fd, &amp;buf, &amp;count ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_write: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  log_msg( &quot;server_write: fd = %d, buf = %p, count = %u\n&quot;, fd, buf, ( unsigned )count );
+  count = ( u32 )os_write( fd, buf, count );
+  log_msg( &quot;server_write: OS response is %u\n&quot;, ( unsigned )count );
+  remotefs_write_write_response( p, count );
+  return SERVER_OK;
+}
+
+static int server_read( u8 *p )
+{
+  int fd;
+  u32 count;
+  
+  log_msg( &quot;server_read: request handler starting\n&quot; );
+  if( remotefs_read_read_request( p, &amp;fd, &amp;count ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_read: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  log_msg( &quot;server_read: fd = %d, count = %u\n&quot;, fd, ( unsigned )count );
+  count = ( u32 )os_read( fd, p + RFS_READ_BUF_OFFSET, count );
+  log_msg( &quot;server_read: OS response is %u\n&quot;, ( unsigned )count );
+  remotefs_read_write_response( p, count );
+  return SERVER_OK;
+}
+
+static int server_close( u8 *p )
+{
+  int fd;
+  
+  log_msg( &quot;server_close: request handler starting\n&quot; );
+  if( remotefs_close_read_request( p, &amp;fd ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_close: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  log_msg( &quot;server_close: fd = %d\n&quot;, fd );
+  fd = os_close( fd );
+  log_msg( &quot;server_close: OS response is %d\n&quot;, fd );
+  remotefs_close_write_response( p, fd );
+  return SERVER_OK;
+}
+
+static int server_lseek( u8 *p )
+{
+  int fd, whence;
+  s32 offset;
+
+  log_msg( &quot;server_lseek: request handler starting\n&quot; );
+  if( remotefs_lseek_read_request( p, &amp;fd, &amp;offset, &amp;whence ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_lseek: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  log_msg( &quot;server_lseek: fd = %d, offset = %d, whence = %d\n&quot;, fd, ( int )offset, whence );
+  offset = os_lseek( fd, offset, whence );
+  log_msg( &quot;server_lseek: OS response is %d\n&quot;, ( int )offset );
+  remotefs_lseek_write_response( p, offset );
+  return SERVER_OK;
+}
+
+static int server_opendir( u8 *p )
+{
+  const char* name;
+  u32 d;
+  char separator[ 2 ] = { PLATFORM_PATH_SEPARATOR, 0 };
+
+  log_msg( &quot;server_opendir: request handler starting\n&quot; );
+  if( remotefs_opendir_read_request( p, &amp;name ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_opendir: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  // Get real filename
+  server_fullname[ 0 ] = server_fullname[ PLATFORM_MAX_FNAME_LEN ] = 0;
+  strncpy( server_fullname, server_basedir, PLATFORM_MAX_FNAME_LEN );
+  if( name &amp;&amp; strlen( name ) &gt; 0 )
+  {
+    if( server_fullname[ strlen( server_fullname ) - 1 ] != PLATFORM_PATH_SEPARATOR )
+      strncat( server_fullname, separator, PLATFORM_MAX_FNAME_LEN );
+    strncat( server_fullname, name, PLATFORM_MAX_FNAME_LEN );
+  }
+  log_msg( &quot;server_opendir: full dirname is %s\n&quot;, server_fullname );
+  d = os_opendir( server_fullname );
+  log_msg( &quot;server_opendir: OS response is %08X\n&quot;, d );
+  remotefs_opendir_write_response( p, d );
+  return SERVER_OK;
+}
+
+static int server_readdir( u8 *p )
+{
+  const char* name;
+  u32 fsize, d;
+  int fd;
+  char separator[ 2 ] = { PLATFORM_PATH_SEPARATOR, 0 };
+
+  log_msg( &quot;server_readdir: request handler starting\n&quot; );
+  if( remotefs_readdir_read_request( p, &amp;d ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_readdir: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  log_msg( &quot;server_readdir: DIR = %08X\n&quot;, d );
+  os_readdir( d, &amp;name );
+  if( name )
+  {
+    // Need to compute size now
+    // Get real filename
+    server_fullname[ 0 ] = server_fullname[ PLATFORM_MAX_FNAME_LEN ] = 0;
+    strncpy( server_fullname, server_basedir, PLATFORM_MAX_FNAME_LEN );
+    if( name &amp;&amp; strlen( name ) &gt; 0 )
+    {
+      if( server_fullname[ strlen( server_fullname ) - 1 ] != PLATFORM_PATH_SEPARATOR )
+        strncat( server_fullname, separator, PLATFORM_MAX_FNAME_LEN );
+      strncat( server_fullname, name, PLATFORM_MAX_FNAME_LEN );
+    }
+    fd = os_open( server_fullname, RFS_OPEN_FLAG_RDONLY, 0 );
+    if( fd )
+    {
+      fsize = os_lseek( fd, 0, RFS_LSEEK_END );
+      os_close( fd );
+    }
+    else
+    {
+      log_msg( &quot;server_readdir: unable to open file %s\n&quot;, server_fullname );
+      name = NULL;
+    }
+  }
+  log_msg( &quot;server_readdir: OS response is fname = %s, fsize = %u\n&quot;, name, ( unsigned )fsize );
+  remotefs_readdir_write_response( p, name, fsize, 0 );
+  return SERVER_OK;
+}
+
+static int server_closedir( u8 *p )
+{
+  u32 d;
+  int res;
+
+  log_msg( &quot;server_closedir: request handler starting\n&quot; );
+  if( remotefs_closedir_read_request( p, &amp;d ) == REMOTEFS_ERR )
+  {
+    log_msg( &quot;server_closedir: unable to read request\n&quot; );
+    return SERVER_ERR;
+  }
+  log_msg( &quot;server_closedir: DIR = %08X\n&quot;, d );
+  res = os_closedir( d );
+  log_msg( &quot;server_closedir: OS response is %d\n&quot;, res );
+  remotefs_closedir_write_response( p, d );
+  return SERVER_OK;
+}
+
+// *****************************************************************************
+// Server public interface
+
+static const p_server_handler server_handlers[] = 
+{ 
+  server_open, server_write, server_read, server_close, server_lseek, server_opendir, server_readdir, server_closedir
+};
+
+void server_setup( const char* basedir )
+{
+  server_basedir = strdup( basedir );
+}
+
+int server_execute_request( u8 *pdata )
+{
+  u8 req;
+  
+  // Decode request
+  if( remotefs_get_request_id( pdata, &amp;req ) == REMOTEFS_ERR )
+    return SERVER_ERR;
+  log_msg( &quot;server_execute_request: got request with ID %d\n&quot;, req );
+  if( req &gt;= RFS_OP_FIRST &amp;&amp; req &lt;= RFS_OP_LAST ) 
+    return server_handlers[ req - RFS_OP_FIRST ]( pdata );
+  else
+    return SERVER_ERR;
+
+}
+

Added: trunk/rfs_server/server.h
===================================================================
--- trunk/rfs_server/server.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/server.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,16 @@
+// Remote filesystem server implementation
+
+#ifndef __SERVER_H__
+#define __SERVER_H__
+
+#include &quot;type.h&quot;
+
+// Error codes
+#define SERVER_OK     0
+#define SERVER_ERR    1
+
+// Server function                     
+void server_setup( const char *basedir );
+int server_execute_request( u8 *pdata );
+
+#endif

Added: trunk/rfs_server/type.h
===================================================================
--- trunk/rfs_server/type.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server/type.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,24 @@
+// Type definitions for the remote file system
+
+#ifndef __TYPE_H__
+#define __TYPE_H__
+
+typedef char s8;
+typedef unsigned char u8;
+typedef short s16;
+typedef unsigned short u16;
+typedef long s32;
+typedef unsigned long u32;
+typedef long long s64;
+typedef unsigned long long u64;
+
+// Define serial port &quot;handle&quot; type for each platform
+// [TODO] for now, only UNIX is supported
+#ifdef WIN32_BUILD
+#include &lt;windows.h&gt;
+typedef HANDLE ser_handler;
+#else // assume POSIX here
+typedef int ser_handler;
+#endif
+                                    
+#endif

Added: trunk/rfs_server.py
===================================================================
--- trunk/rfs_server.py	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/rfs_server.py	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,46 @@
+import os, sys, platform
+
+sim = ARGUMENTS.get( 'sim', '0' )
+
+flist = &quot;&quot;
+cdefs = &quot;&quot;
+if sim == '0':
+  mainname = &quot;main.c&quot;
+else:
+  mainname = 'main_sim.c'
+if platform.system() == &quot;Windows&quot;:
+  if sim == '1':
+    print &quot;SIM target not supported under Windows&quot;
+    os.exit( 1 )
+  flist = &quot;main.c server.c client.c os_io_win32.c log.c&quot;
+  cdefs = &quot;-DWIN32_BUILD&quot;
+  exeprefix = &quot;exe&quot;
+else:
+  flist = &quot;%s server.c client.c os_io_posix.c log.c&quot; % mainname
+  exeprefix = &quot;elf&quot;
+
+if sim == '0':
+  output = 'rfs_server.%s' % exeprefix
+else:
+  output = 'rfs_sim_server.%s' % exeprefix
+#endif
+
+full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;rfs_server/%s&quot; % name for name in flist.split() ] )
+full_files = full_files + &quot; src/remotefs/remotefs.c&quot;
+if platform.system() == &quot;Windows&quot;:
+  full_files = full_files + &quot; rfs_server/serial_win32.c&quot;
+else:
+  full_files = full_files + &quot; rfs_server/serial_posix.c&quot;
+local_include = &quot;-Irfs_server -Iinc/remotefs&quot;
+
+# Compiler/linker options
+cccom = &quot;gcc -O0 -g %s -Wall %s -c $SOURCE -o $TARGET&quot; % ( local_include, cdefs )
+linkcom = &quot;gcc -o $TARGET $SOURCES&quot;
+
+# Env for building the program
+comp = Environment( CCCOM = cccom,
+                    LINKCOM = linkcom,
+                    ENV = os.environ )
+Decider( 'MD5' )                  
+Default( comp.Program( output, Split( full_files ) ) )
+

Modified: trunk/run_elua_sim.sh
===================================================================
--- trunk/run_elua_sim.sh	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/run_elua_sim.sh	2010-02-01 18:47:41 UTC (rev 696)
@@ -1,5 +1,11 @@
 #!/bin/bash
 
+# Setup terminal
 stty -echo raw -igncr
+
+# Run simulator
 ./elua_lua_linux.elf
+
+# Restore terminal to default settings
 stty echo cooked
+

Modified: trunk/src/fatfs/ff.h
===================================================================
--- trunk/src/fatfs/ff.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/fatfs/ff.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -72,7 +72,7 @@
 /* To enable f_forward function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
 
 
-#define _CODE_PAGE	932
+#define _CODE_PAGE	1
 /* The _CODE_PAGE specifies the OEM code page to be used on the target system.
 /
 /   932  - Japanese Shift-JIS (DBCS, OEM, Windows)

Modified: trunk/src/main.c
===================================================================
--- trunk/src/main.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/main.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -5,6 +5,7 @@
 #include &quot;type.h&quot;
 #include &quot;devman.h&quot;
 #include &quot;platform.h&quot;
+#include &quot;romfs.h&quot;
 #include &quot;xmodem.h&quot;
 #include &quot;shell.h&quot;
 #include &quot;lua.h&quot;
@@ -12,6 +13,7 @@
 #include &quot;lualib.h&quot;
 #include &quot;term.h&quot;
 #include &quot;platform_conf.h&quot;
+#include &quot;elua_rfs.h&quot;
 #ifdef ELUA_SIMULATOR
 #include &quot;hostif.h&quot;
 #endif
@@ -82,11 +84,12 @@
   // Register the ROM filesystem
   dm_register( romfs_init() );
 
-#ifdef BUILD_MMCFS
   // Register the MMC filesystem
   dm_register( mmcfs_init() );
-#endif
 
+  // Register the remote filesystem
+  dm_register( remotefs_init() );
+
   // Autorun: if &quot;autorun.lua&quot; is found in the file system, run it first
   if( ( fp = fopen( FS_AUTORUN, &quot;r&quot; ) ) != NULL )
   {

Modified: trunk/src/mmcfs.c
===================================================================
--- trunk/src/mmcfs.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/mmcfs.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -131,56 +131,93 @@
   return (_ssize_t) bytesRead;
 }
 
-// IOCTL: only fseek
-static int mmcfs_ioctl_r( struct _reent *r, int fd, unsigned long request, void *ptr )
+// lseek
+static off_t mmcfs_lseek_r( struct _reent *r, int fd, off_t off, int whence )
 {
-  struct fd_seek *pseek = ( struct fd_seek* )ptr;
   FIL* pFile = mmcfs_fd_table + fd;
-  u16 newpos = 0;
+  u32 newpos = 0;
 
-  if (request == FDSEEK)
+  switch( whence )
   {
-    switch (pseek-&gt;dir)
-    {
-      case SEEK_SET:
-        // seek from beginning of file
-        newpos =  pseek-&gt;off;
-        break;
+    case SEEK_SET:
+      // seek from beginning of file
+      newpos = off;
+      break;
 
-      case SEEK_CUR:
-        // seek from current position
-        newpos = pFile-&gt;fptr + pseek-&gt;off;
-        break;
+    case SEEK_CUR:
+      // seek from current position
+      newpos = pFile-&gt;fptr + off;
+      break;
 
-      case SEEK_END:
-        // seek from end of file
-        newpos = pFile-&gt;fsize + pseek-&gt;off;
-        break;
+    case SEEK_END:
+      // seek from end of file
+      newpos = pFile-&gt;fsize + off;
+      break;
 
-      default:
-        return -1;
-    }
-    if (f_lseek (pFile, newpos) != FR_OK)
+    default:
       return -1;
-    pseek-&gt;off = newpos;
-    return 0;
   }
-  else
+  if (f_lseek (pFile, newpos) != FR_OK)
     return -1;
+  return newpos;
 }
 
+// opendir
+static DIR mmc_dir;
+static void* mmcfs_opendir_r( struct _reent *r, const char* dname )
+{
+  void* res = NULL;
+  if( !dname || strlen( dname ) == 0 || ( strlen( dname ) == 1 &amp;&amp; !strcmp( dname, &quot;/&quot; ) ) )
+    res = f_opendir( &amp;mmc_dir, &quot;/&quot; ) != FR_OK ? NULL : &amp;mmc_dir; 
+  return res;
+}
+
+// readdir
+extern struct dm_dirent dm_shared_dirent;
+extern char dm_shared_fname[ DM_MAX_FNAME_LENGTH + 1 ];
+static struct dm_dirent* mmcfs_readdir_r( struct _reent *r, void *d )
+{
+  DIR *pdir = ( DIR* )d;
+  FILINFO mmc_file_info;
+  struct dm_dirent* pent = &amp;dm_shared_dirent;
+  
+  while( 1 )
+  {
+    if( f_readdir( pdir, &amp;mmc_file_info ) != FR_OK )
+      return NULL;
+    if( ( mmc_file_info.fattrib &amp; AM_DIR ) == 0 )
+      break;
+  }
+  if( mmc_file_info.fname[ 0 ] == '\0' )
+    return NULL;
+  strncpy( dm_shared_fname, mmc_file_info.fname, DM_MAX_FNAME_LENGTH );
+  pent-&gt;fname = dm_shared_fname;
+  pent-&gt;fsize = mmc_file_info.fsize;
+  pent-&gt;ftime = mmc_file_info.ftime; 
+  return pent;
+}
+
+// closedir
+static int mmcfs_closedir_r( struct _reent *r, void *d )
+{
+  return 0;
+}
+
 // MMC device descriptor structure
 static DM_DEVICE mmcfs_device =
 {
   &quot;/mmc&quot;,
-  mmcfs_open_r,
-  mmcfs_close_r,
-  mmcfs_write_r,
-  mmcfs_read_r,
-  mmcfs_ioctl_r
+  mmcfs_open_r,         // open
+  mmcfs_close_r,        // close
+  mmcfs_write_r,        // write
+  mmcfs_read_r,         // read
+  mmcfs_lseek_r,        // lseek
+  mmcfs_opendir_r,      // opendir
+  mmcfs_readdir_r,      // readdir
+  mmcfs_closedir_r      // closedir
 };
 
-DM_DEVICE* mmcfs_init()
+const DM_DEVICE* mmcfs_init()
 {
   // Mount the MMC file system using logical disk 0
   if ( f_mount( 0, &amp;mmc_fs ) != FR_OK )
@@ -191,7 +228,7 @@
 
 #else // #ifdef BUILD_MMCFS
 
-DM_DEVICE* mmcfs_init()
+const DM_DEVICE* mmcfs_init()
 {
   return NULL;
 }

Modified: trunk/src/newlib/devman.c
===================================================================
--- trunk/src/newlib/devman.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/newlib/devman.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -3,26 +3,34 @@
 #include &lt;string.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;fcntl.h&gt;
+#include &lt;reent.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdlib.h&gt;
 #include &quot;devman.h&quot;
 #include &quot;genstd.h&quot;
+#include &quot;common.h&quot;
 #include &quot;platform_conf.h&quot;
 
-static DM_DEVICE dm_list[ DM_MAX_DEVICES ];           // list of devices
+static const DM_DEVICE* dm_list[ DM_MAX_DEVICES ];           // list of devices
 static int dm_num_devs;                               // number of devices
 
+// &quot;Shared&quot; variables: these can be used by any FS that implements 'ls' via opendir/readdir/closedir
+struct dm_dirent dm_shared_dirent;
+char dm_shared_fname[ DM_MAX_FNAME_LENGTH + 1 ];
+
 // Register a device
 // Returns the index of the device in the device table
-int dm_register( DM_DEVICE *pdev )
+int dm_register( const DM_DEVICE *pdev )
 {
   int i;
   
   // First char of the name must be '/'
-  if( pdev == NULL || pdev-&gt;name == NULL || *pdev-&gt;name == '\0' || *pdev-&gt;name != '/' || strlen( pdev-&gt;name ) &gt; DM_MAX_DEV_NAME )
+  if( pdev == NULL || pdev-&gt;name == NULL || *pdev-&gt;name != '/' || strlen( pdev-&gt;name ) &gt; DM_MAX_DEV_NAME )
     return DM_ERR_INVALID_NAME;
   
   // Check if the device is not already registered
   for( i = 0; i &lt; dm_num_devs; i ++ )
-    if( !strcasecmp( pdev-&gt;name, dm_list[ i ].name ) )
+    if( !strcasecmp( pdev-&gt;name, dm_list[ i ]-&gt;name ) )
       return DM_ERR_ALREADY_REGISTERED;
   
   // Check for space
@@ -30,11 +38,32 @@
     return DM_ERR_NO_SPACE;
     
   // Register it now
-  memcpy( dm_list + dm_num_devs, pdev, sizeof( DM_DEVICE ) );
-  dm_num_devs ++;
+  dm_list[ dm_num_devs ++ ] = pdev;
   return dm_num_devs - 1;
 }
 
+// Helper: get a device ID from its name
+// Also return a pointer to the remaining part of the name as side effect
+static int dm_device_id_from_name( const char* name, const char **rest )
+{
+  unsigned i, pos;
+  unsigned matchlen = 0;
+
+  if( rest )
+    *rest = NULL;
+  for( i = pos = 0; i &lt; dm_num_devs; i ++ )
+    if( !strncasecmp( name, dm_list[ i ]-&gt;name, strlen( dm_list[ i ]-&gt;name ) ) &amp;&amp; strlen( dm_list[ i ]-&gt;name ) &gt; matchlen )
+    {
+      matchlen = strlen( dm_list[ i ]-&gt;name );
+      pos = i;
+    }
+  if( matchlen == 0 )
+    return DM_ERR_NO_DEVICE;
+  if( rest )
+    *rest = name + strlen( dm_list[ pos ]-&gt;name );
+  return pos;
+}
+
 // Unregister a device
 // Returns 0 for OK or an error code if error
 int dm_unregister( const char* name )
@@ -46,14 +75,14 @@
       
   // Check if the device is already registered
   for( i = 0; i &lt; dm_num_devs; i ++ )
-    if( !strcasecmp( name, dm_list[ i ].name ) )
+    if( !strcasecmp( name, dm_list[ i ]-&gt;name ) )
       break;
   if( i == dm_num_devs )
     return DM_ERR_NOT_REGISTERED;
   
   // Remove it
   if( i != dm_num_devs - 1 )
-    memmove( dm_list + i, dm_list + i + 1, ( dm_num_devs - i - 1 ) * sizeof( DM_DEVICE ) );
+    memmove( dm_list + i, dm_list + i + 1, sizeof( DM_DEVICE* ) );
   dm_num_devs --;
   return DM_OK;
 }
@@ -63,7 +92,7 @@
 {
   if( idx &lt; 0 || idx &gt;= dm_num_devs )
     return NULL;
-  return dm_list + idx;
+  return dm_list[ idx ];
 }
 
 // Returns the number of registered devices
@@ -83,3 +112,75 @@
 #endif
   return DM_OK;
 }
+
+// Open a directory and return its descriptor
+DM_DIR* dm_opendir( const char* dirname )
+{
+  const char* rest;
+  const DM_DEVICE *pdev;
+  DM_DIR *d;
+  int pos;
+  void *data;
+
+  if( ( pos = dm_device_id_from_name( dirname, &amp;rest ) ) == DM_ERR_NO_DEVICE )
+  {
+    _REENT-&gt;_errno = ENOSYS;
+    return NULL;
+  }
+  pdev = dm_list[ pos ];
+  if( pdev-&gt;p_opendir_r == NULL )
+  {
+    _REENT-&gt;_errno = ENOSYS;
+    return NULL;
+  }
+  if( ( data = pdev-&gt;p_opendir_r( _REENT, rest ) ) == NULL )
+    return NULL;
+  if( ( d = malloc( sizeof( DM_DIR ) ) ) == NULL )
+  {
+    _REENT-&gt;_errno = ENOMEM;
+    return NULL;
+  }
+  d-&gt;devid = pos;
+  d-&gt;userdata = data;
+  return d;
+}
+
+// Read the next directory entry from the directory descriptor
+struct dm_dirent* dm_readdir( DM_DIR *d )
+{
+  const DM_DEVICE *pdev;
+
+  if( d-&gt;devid &lt; 0 || d-&gt;devid &gt;= dm_num_devs )
+  {
+    _REENT-&gt;_errno = EBADF;
+    return NULL;
+  }
+  pdev = dm_list[ d-&gt;devid ];
+  if( pdev-&gt;p_readdir_r == NULL )
+  {
+    _REENT-&gt;_errno = EBADF;
+    return NULL;
+  }
+  return pdev-&gt;p_readdir_r( _REENT, d-&gt;userdata );
+}
+
+// Close a directory descriptor
+int dm_closedir( DM_DIR *d )
+{
+  int res = -1;
+  const DM_DEVICE *pdev;
+
+  if( d-&gt;devid &lt; 0 || d-&gt;devid &gt;= dm_num_devs )
+  {
+    _REENT-&gt;_errno = EBADF;
+    return -1;
+  }
+  pdev = dm_list[ d-&gt;devid ];
+  if( pdev )
+    res = pdev-&gt;p_closedir_r( _REENT, d-&gt;userdata );
+  else
+    _REENT-&gt;_errno = EBADF;
+  free( d );
+  return res;
+}
+

Modified: trunk/src/newlib/genstd.c
===================================================================
--- trunk/src/newlib/genstd.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/newlib/genstd.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -129,17 +129,20 @@
 }
 
 // Our UART device descriptor structure
-static DM_DEVICE std_device = 
+static const DM_DEVICE std_device = 
 {
   STD_DEV_NAME,
-  NULL,                 // we don't have 'open' on std
-  NULL,                 // we don't hace 'close' on std
-  std_write,
-  std_read,
-  NULL                  // we don't have &quot;ioctl&quot; on std
+  NULL,                 // open
+  NULL,                 // close
+  std_write,            // write
+  std_read,             // read
+  NULL,                 // lseek
+  NULL,                 // opendir
+  NULL,                 // readdir
+  NULL                  // closedir
 };
 
-DM_DEVICE* std_get_desc()
+const DM_DEVICE* std_get_desc()
 {
   return &amp;std_device;
 }

Modified: trunk/src/newlib/stdtcp.c
===================================================================
--- trunk/src/newlib/stdtcp.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/newlib/stdtcp.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -83,18 +83,21 @@
 {
 }
 
-// Our UART device descriptor structure
-static DM_DEVICE std_device = 
+static const DM_DEVICE std_device = 
 {
   STD_DEV_NAME,
-  NULL,                 // we don't have 'open' on std
-  NULL,                 // we don't have 'close' on std
-  std_write,
-  std_read,
-  NULL                  // we don't have &quot;ioctl&quot; on std
+  NULL,                 // open
+  NULL,                 // close
+  std_write,            // write
+  std_read,             // read
+  NULL,                 // lseek
+  NULL,                 // opendir
+  NULL,                 // readdir
+  NULL                  // closedir
 };
 
-DM_DEVICE* std_get_desc()
+
+const DM_DEVICE* std_get_desc()
 {
   return &amp;std_device;
 }

Modified: trunk/src/newlib/stubs.c
===================================================================
--- trunk/src/newlib/stubs.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/newlib/stubs.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -6,6 +6,7 @@
 #include &lt;sys/stat.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdarg.h&gt;
+#include &lt;unistd.h&gt;
 #include &quot;devman.h&quot;
 #include &quot;ioctl.h&quot;
 #include &quot;platform.h&quot;
@@ -127,28 +128,23 @@
 }
 
 // *****************************************************************************
-// ioctl (actually our call, not newlib's)
-static int _ioctl_r( struct _reent *r, int file, unsigned long request, void *ptr )
+// _lseek_r
+off_t _lseek_r( struct _reent *r, int file, off_t off, int whence )
 {
   const DM_DEVICE* pdev;
   
-  // Find device, check ioctl function
+  // Find device, check close function
   pdev = dm_get_device_at( DM_GET_DEVID( file ) );
-  if( pdev-&gt;p_ioctl_r == NULL )
+  if( pdev-&gt;p_lseek_r == NULL )
   {
     r-&gt;_errno = ENOSYS;
     return -1; 
   }
   
-  // And call the ioctl function
-  return pdev-&gt;p_ioctl_r( r, DM_GET_FD( file ), request, ptr );  
+  // And call the close function
+  return pdev-&gt;p_lseek_r( r, DM_GET_FD( file ), off, whence );
 }
 
-int ioctl( int file, unsigned long request, void *ptr )
-{
-  return _ioctl_r( _REENT, file, request, ptr );
-}
-
 // *****************************************************************************
 // _read_r 
 _ssize_t _read_r( struct _reent *r, int file, void *ptr, size_t len )
@@ -185,21 +181,6 @@
   return pdev-&gt;p_write_r( r, DM_GET_FD( file ), ptr, len );  
 }
 
-// *****************************************************************************
-// _lseek_r
-_off_t _lseek_r( struct _reent *r, int file, _off_t ptr, int dir )
-{
-  struct fd_seek seek;
-    
-  seek.off = ptr;
-  seek.dir = dir;
-  
-  if( ioctl( file, FDSEEK, &amp;seek ) &lt; 0 ) 
-    return (_off_t)-1;
-  else
-    return seek.off;
-}
-
 // ****************************************************************************
 // Miscalenous functions
 

Modified: trunk/src/platform/sim/host.c
===================================================================
--- trunk/src/platform/sim/host.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/sim/host.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -4,6 +4,8 @@
 #define __NR_write    4
 #define __NR_mmap2    192
 #define __NR_exit     1
+#define __NR_open     5 
+#define __NR_close    6
 
 int host_errno = 0;
 
@@ -52,6 +54,8 @@
 
 _syscall3(ssize_t, read, int, fd, void *, buf, size_t, count);
 _syscall3(ssize_t, write, int, fd, const void *, buf, size_t, count);
+_syscall3(int, open, const char*, pathname, int, flags, mode_t, mode);
 _syscall6(void *,mmap2, void *,addr, size_t, length, int, prot, int, flags, int, fd, off_t, offset);
 _syscall1(void, exit, int, status);
+_syscall1(int, close, int, status);
 

Modified: trunk/src/platform/sim/host.h
===================================================================
--- trunk/src/platform/sim/host.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/sim/host.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -8,8 +8,10 @@
 
 extern int host_errno;
 
-ssize_t host_read( int fd, void * buf, size_t count);
-ssize_t host_write( int fd, const void * buf, size_t count);
+ssize_t host_read( int fd, void * buf, size_t count );
+ssize_t host_write( int fd, const void * buf, size_t count );
+int host_open( const char *name, int flags, mode_t mode );
+int host_close( int fd );
 
 #define PROT_READ 0x1   /* Page can be read.  */
 #define PROT_WRITE  0x2   /* Page can be written.  */
@@ -21,6 +23,10 @@
 #define MAP_FIXED 0x10    /* Interpret addr exactly.  */
 #define MAP_ANONYMOUS  0x20    /* Don't use a file.  */
 
+// Flags for &quot;open&quot;
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+
 #define MAP_FAILED (void *)(-1)
 
 void *host_mmap2(void *addr, size_t length, int prot, int flags, int fd, off_t pgoffset);

Modified: trunk/src/platform/sim/hostif.h
===================================================================
--- trunk/src/platform/sim/hostif.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/sim/hostif.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -4,10 +4,10 @@
 #define __HOSTIO_H__
 
 // Write a single character out to the screen.
-void hostif_put(char c);
+void hostif_putc(char c);
 
 // Output a null-terminated ASCII string to the monitor.
-void hostif_write(const char *c);
+void hostif_putstr(const char *c);
 
 // Get a char from keyboard
 int hostif_getch();
@@ -18,5 +18,17 @@
 // Terminate the simulator (exit program)
 void hostif_exit();
 
+// Open
+int hostif_open( const char* name, int flags, unsigned mode );
+
+// Read
+int hostif_read( int fd, void *buf, unsigned count );
+
+// Write
+int hostif_write( int fd, const void *buf, unsigned count );
+
+// Close
+int hostif_close( int fd );
+
 #endif // __HOSTIO_H__
 

Modified: trunk/src/platform/sim/hostif_linux.c
===================================================================
--- trunk/src/platform/sim/hostif_linux.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/sim/hostif_linux.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -11,16 +11,16 @@
 #define STDIN_FILENO 0
 #define STDOUT_FILENO 1
 
-void hostif_put(char c)
+void hostif_putc(char c)
 {
 	host_write(STDOUT_FILENO, &amp;c, 1);
 }
 
-void hostif_write(const char *c)
+void hostif_putstr(const char *c)
 {
   int i = 0;
-  while (c[i])
-    hostif_put(c[i++]);
+  while( c[ i ] )
+    hostif_putc( c[ i++ ] );
 }
 
 int hostif_getch()
@@ -44,3 +44,23 @@
   host_exit( 0 );
 }
 
+int hostif_open( const char* name, int flags, unsigned mode )
+{
+  return host_open( name, flags, ( mode_t )mode );
+}
+
+int hostif_read( int fd, void *buf, unsigned count )
+{
+  return ( int )host_read( fd, buf, ( size_t )count );
+}
+
+int hostif_write( int fd, const void *buf, unsigned count )
+{
+  return ( int )host_write( fd, buf, ( size_t )count );
+}
+
+int hostif_close( int fd )
+{
+  return host_close( fd );
+}
+

Modified: trunk/src/platform/sim/platform.c
===================================================================
--- trunk/src/platform/sim/platform.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/sim/platform.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -21,7 +21,7 @@
 
 static void i386_term_out( u8 data )
 {
-  hostif_put( data );
+  hostif_putc( data );
 }
 
 static int i386_term_in( int mode )
@@ -66,7 +66,7 @@
 static void scr_write( int fd, char c )
 {
   fd = fd;
-  hostif_put( c );
+  hostif_putc( c );
 }
 
 static int kb_read( s32 to )
@@ -99,7 +99,7 @@
 { 
 	if( memory_start_address == NULL ) 
   {
-    hostif_write( &quot;platform_init(): mmap failed\n&quot; );
+    hostif_putstr( &quot;platform_init(): mmap failed\n&quot; );
 		return PLATFORM_ERR;
 	}
 

Modified: trunk/src/platform/sim/platform_conf.h
===================================================================
--- trunk/src/platform/sim/platform_conf.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/sim/platform_conf.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -6,6 +6,7 @@
 #include &quot;auxmods.h&quot;
 #include &quot;type.h&quot;
 #include &quot;stacks.h&quot;
+#include &quot;buf.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -14,6 +15,7 @@
 #define BUILD_ROMFS
 #define BUILD_CON_GENERIC
 #define BUILD_TERM
+#define BUILD_RFS
 
 #define TERM_LINES    25
 #define TERM_COLS     80
@@ -65,4 +67,8 @@
 #define MEM_START_ADDRESS     { ( void* )memory_start_address }
 #define MEM_END_ADDRESS       { ( void* )memory_end_address }
 
+// RFS configuration
+#define RFS_TIMEOUT           0 // dummy, always blocking by implementation
+#define RFS_BUFFER_SIZE       BUF_SIZE_512
+
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/stm32/platform.c
===================================================================
--- trunk/src/platform/stm32/platform.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/stm32/platform.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -152,6 +152,11 @@
 
 #if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
   /* Enable the USART1 Interrupt */
+  // [TODO]: this is hardcoded, and it shouldn't be
+  nvic_init_structure.NVIC_IRQChannel = USART3_IRQn;
+  nvic_init_structure.NVIC_IRQChannelSubPriority = 0;
+  nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;
+  NVIC_Init(&amp;nvic_init_structure);
   nvic_init_structure.NVIC_IRQChannel = USART1_IRQn;
   nvic_init_structure.NVIC_IRQChannelSubPriority = 0;
   nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;
@@ -537,17 +542,32 @@
 static const u16 usart_gpio_tx_pin[] = { GPIO_Pin_9, GPIO_Pin_2, GPIO_Pin_10, GPIO_Pin_10, GPIO_Pin_12 };
 
 #ifdef BUF_ENABLE_UART
-void USART1_IRQHandler(void)
+static void all_usart_irqhandler( int usart_id )
 {
   int c;
 
-  if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
+  if( USART_GetITStatus( usart[ usart_id ], USART_IT_RXNE ) != RESET )
   {
     /* Read one byte from the receive data register */
-    c = USART_ReceiveData(USART1);
-    buf_write( BUF_ID_UART, CON_UART_ID, ( t_buf_data* )&amp;c );
+    c = USART_ReceiveData( usart[ usart_id ] );
+    buf_write( BUF_ID_UART, usart_id, ( t_buf_data* )&amp;c );
   }
 }
+
+void USART1_IRQHandler( void )
+{
+  all_usart_irqhandler( 0 );
+}
+
+void USART2_IRQHandler(void)
+{
+  all_usart_irqhandler( 1 );
+}
+
+void USART3_IRQHandler(void)
+{
+  all_usart_irqhandler( 2 );
+}
 #endif
 
 
@@ -590,6 +610,7 @@
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
+  RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
 
   // Configure the U(S)ART
   USART_InitStructure.USART_BaudRate = CON_UART_SPEED;

Modified: trunk/src/platform/stm32/platform_conf.h
===================================================================
--- trunk/src/platform/stm32/platform_conf.h	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/platform/stm32/platform_conf.h	2010-02-01 18:47:41 UTC (rev 696)
@@ -22,13 +22,14 @@
 #define BUILD_CON_GENERIC
 #define BUILD_ADC
 #define BUILD_RPC
+#define BUILD_RFS
 //#define BUILD_CON_TCP
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define CON_UART_ID           0
-#define CON_UART_SPEED        115200
+#define CON_UART_ID           2
+#define CON_UART_SPEED        19200
 #define CON_TIMER_ID          0
 #define TERM_LINES            25
 #define TERM_COLS             80
@@ -155,6 +156,13 @@
 // Use #define PIO_PINS_PER_PORT 0 if this isn't needed
 #define PIO_PINS_PER_PORT     16
 
+// Remote file system data
+#define RFS_BUFFER_SIZE       BUF_SIZE_512
+#define RFS_UART_ID           0
+#define RFS_TIMER_ID          0
+#define RFS_TIMEOUT           100000
+#define RFS_UART_SPEED        115200
+
 // Allocator data: define your free memory zones here in two arrays
 // (start address and end address)
 #define SRAM_SIZE             ( 64 * 1024 )

Added: trunk/src/remotefs/client.c
===================================================================
--- trunk/src/remotefs/client.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/remotefs/client.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,189 @@
+// Remote filesystem client
+
+#include &lt;string.h&gt;
+#include &quot;remotefs.h&quot;
+#include &quot;client.h&quot;
+#include &quot;os_io.h&quot;
+
+// ****************************************************************************
+// Client local data
+
+static u8 *rfsc_buffer;
+static p_rfsc_send rfsc_send;
+static p_rfsc_recv rfsc_recv;
+static u32 rfsc_timeout;
+
+// ****************************************************************************
+// Client helpers
+
+static int rfsch_send_request_read_response()
+{
+  u16 temp16;
+
+#ifndef ELUA_CPU_LINUX
+  // Empty receive buffer
+  while( rfsc_recv( rfsc_buffer, 1, 0 ) == 1 );
+#endif
+
+  // Send request
+  if( remotefs_get_packet_size( rfsc_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+    return CLIENT_ERR;
+  if( rfsc_send( rfsc_buffer, temp16 ) != temp16 )
+    return CLIENT_ERR;
+  
+  // Get response
+  // First the length, then the rest of the data
+  if( rfsc_recv( rfsc_buffer, RFS_START_OFFSET, rfsc_timeout ) != RFS_START_OFFSET )
+    return CLIENT_ERR;
+  if( remotefs_get_packet_size( rfsc_buffer, &amp;temp16 ) == REMOTEFS_ERR )
+    return CLIENT_ERR;
+  if( rfsc_recv( rfsc_buffer + RFS_START_OFFSET, temp16 - RFS_START_OFFSET, rfsc_timeout ) != temp16 - RFS_START_OFFSET )
+    return CLIENT_ERR;
+  return CLIENT_OK;
+}
+
+// ****************************************************************************
+// Client public interface
+
+void rfsc_setup( u8 *pbuf, p_rfsc_send rfsc_send_func, p_rfsc_recv rfsc_recv_func, u32 timeout )
+{
+  rfsc_buffer = pbuf;
+  rfsc_send = rfsc_send_func;
+  rfsc_recv = rfsc_recv_func;
+  rfsc_timeout = timeout;
+}
+
+void rfsc_set_timeout( u32 timeout )
+{
+  rfsc_timeout = timeout;
+}
+
+int rfsc_open( const char* pathname, int flags, int mode )
+{
+  int fd;
+
+  // Make the request
+  remotefs_open_write_request( rfsc_buffer, pathname, os_open_sys_flags_to_rfs_flags( flags ), mode );
+
+  // Send the request / get the respone
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_open_read_response( rfsc_buffer, &amp;fd ) == REMOTEFS_ERR )
+    return -1;
+  return fd;
+}
+
+s32 rfsc_write( int fd, const void *buf, u32 count )
+{
+  // Make the request
+  remotefs_write_write_request( rfsc_buffer, fd, buf, count );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+  
+  // Interpret the response
+  if( remotefs_write_read_response( rfsc_buffer, &amp;count ) == REMOTEFS_ERR )
+    return -1;
+  return ( s32 )count;
+}
+
+s32 rfsc_read( int fd, void *buf, u32 count )
+{
+  const u8 *resbuf;
+
+  // Make the request
+  remotefs_read_write_request( rfsc_buffer, fd, count );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_read_read_response( rfsc_buffer, &amp;resbuf, &amp;count ) == REMOTEFS_ERR )
+    return -1;
+  memcpy( buf, resbuf, count );
+  return ( s32 )count;
+}
+
+s32 rfsc_lseek( int fd, s32 offset, int whence )
+{
+  s32 res;
+
+  // Make the request
+  remotefs_lseek_write_request( rfsc_buffer, fd, offset, os_lseek_sys_whence_to_rfs_whence( whence ) );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_lseek_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+    return -1;
+  return res;
+}
+
+int rfsc_close( int fd )
+{
+  int res;
+
+  // Make the request
+  remotefs_close_write_request( rfsc_buffer, fd );
+
+  // Send the request / get the response
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_close_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+    return -1;
+  return res;
+}
+
+u32 rfsc_opendir( const char* name )
+{
+  u32 res;
+
+  // Make the request
+  remotefs_opendir_write_request( rfsc_buffer, name );
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return 0;
+
+  // Interpret the response
+  if( remotefs_opendir_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+    return 0;
+  return res;
+}
+
+void rfsc_readdir( u32 d, const char **pname, u32 *psize, u32 *ptime )
+{
+  // Make the request
+  remotefs_readdir_write_request( rfsc_buffer, d );
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+  {
+    *pname = NULL;
+    return;
+  }
+
+  // Interpret the response
+  if( remotefs_readdir_read_response( rfsc_buffer, pname, psize, ptime ) == REMOTEFS_ERR )
+    *pname = NULL;
+}
+
+int rfsc_closedir( u32 d )
+{
+  int res;
+
+  // Make the request
+  remotefs_closedir_write_request( rfsc_buffer, d );
+  if( rfsch_send_request_read_response() == CLIENT_ERR )
+    return -1;
+
+  // Interpret the response
+  if( remotefs_closedir_read_response( rfsc_buffer, &amp;res ) == REMOTEFS_ERR )
+    return -1;
+  return res;
+}  
+

Added: trunk/src/remotefs/elua_os_io.c
===================================================================
--- trunk/src/remotefs/elua_os_io.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/remotefs/elua_os_io.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,40 @@
+// Remote FS IO adapter for eLua
+
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;fcntl.h&gt;
+#include &quot;os_io.h&quot;
+#include &quot;remotefs.h&quot;
+
+u32 os_open_sys_flags_to_rfs_flags( int sysflags )
+{
+  int rfsflags = 0;
+
+  // Translate RFS flags to POSIX flags
+  rfsflags = remotefs_replace_flag( sysflags, O_APPEND, RFS_OPEN_FLAG_APPEND );
+  rfsflags |= remotefs_replace_flag( sysflags, O_CREAT, RFS_OPEN_FLAG_CREAT );
+  rfsflags |= remotefs_replace_flag( sysflags, O_EXCL, RFS_OPEN_FLAG_EXCL );
+  rfsflags |= remotefs_replace_flag( sysflags, O_TRUNC, RFS_OPEN_FLAG_TRUNC );
+  rfsflags |= remotefs_replace_flag( sysflags, O_SYNC, RFS_OPEN_FLAG_SYNC );
+  rfsflags |= remotefs_replace_flag( sysflags, O_RDONLY, RFS_OPEN_FLAG_RDONLY );
+  rfsflags |= remotefs_replace_flag( sysflags, O_WRONLY, RFS_OPEN_FLAG_WRONLY );
+  rfsflags |= remotefs_replace_flag( sysflags, O_RDWR, RFS_OPEN_FLAG_RDWR );
+  return rfsflags;
+}
+
+u32 os_lseek_sys_whence_to_rfs_whence( int syswhence )
+{
+  switch( syswhence )
+  {
+    case SEEK_SET:
+      return RFS_LSEEK_SET;
+
+    case SEEK_CUR:
+      return RFS_LSEEK_CUR;
+
+    case SEEK_END:
+      return RFS_LSEEK_END;
+  }
+  return 0;
+}
+

Added: trunk/src/remotefs/elua_rfs.c
===================================================================
--- trunk/src/remotefs/elua_rfs.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/remotefs/elua_rfs.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,204 @@
+// eLua remote file system support functions
+
+#include &quot;devman.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;type.h&quot;
+#include &quot;platform.h&quot;
+#include &quot;remotefs.h&quot;
+#include &quot;client.h&quot;
+#include &quot;buf.h&quot;
+#include &lt;fcntl.h&gt;
+#ifdef ELUA_SIMULATOR
+#include &quot;hostif.h&quot;
+#endif
+#include &lt;stdio.h&gt;
+
+#ifdef BUILD_RFS
+
+// Our RFS buffer
+// Compute the usable buffer size starting from RFS_BUFFER_SIZE (which is the
+// size of the serial buffer). A complete packet must fit in RFS_BUFFER_SIZE
+// bytes. Computed this to be large enough for a WRITE request.
+#define RFS_REAL_BUFFER_SIZE      ( ( 1 &lt;&lt; RFS_BUFFER_SIZE ) - RFS_WRITE_REQUEST_EXTRA )
+static u8 rfs_buffer[ 1 &lt;&lt; RFS_BUFFER_SIZE ];
+
+#ifdef ELUA_SIMULATOR
+static int rfs_read_fd, rfs_write_fd;
+#endif
+
+static int rfs_open_r( struct _reent *r, const char *path, int flags, int mode )
+{
+  return rfsc_open( path, flags, mode );
+}
+
+static int rfs_close_r( struct _reent *r, int fd )
+{
+  return rfsc_close( fd );
+}
+
+static _ssize_t rfs_write_r( struct _reent *r, int fd, const void* ptr, size_t len )
+{ 
+  s32 total = 0, res;
+  u32 towrite;
+  const u8 *p = ( const u8* )ptr;
+
+  // Write in RFS_REAL_BUFFER_SIZE increments
+//  printf( &quot;Got WRITE request for %d bytes\n&quot;, len );
+  while( len )
+  {
+    towrite = len &gt; RFS_REAL_BUFFER_SIZE ? RFS_REAL_BUFFER_SIZE : len;
+    if( ( res = rfsc_write( fd, p, towrite ) ) == -1 )
+      break;
+    total += res;
+//    printf( &quot;Wrote %d bytes\n&quot;, res );
+    if( res &lt; towrite )
+      break;
+    len -= towrite;
+    p += towrite; 
+  }
+  return ( _ssize_t )total;
+}
+
+static _ssize_t rfs_read_r( struct _reent *r, int fd, void* ptr, size_t len )
+{
+  s32 total = 0, res;
+  u32 toread;
+  u8 *p = ( u8* )ptr;
+
+  // Read in RFS_REAL_BUFFER_SIZE increments
+//  printf( &quot;Got READ request for %d bytes\n&quot;, len );
+  while( len )
+  {
+    toread = len &gt; RFS_REAL_BUFFER_SIZE ? RFS_REAL_BUFFER_SIZE : len;
+    if( ( res = rfsc_read( fd, p, toread ) ) == -1 )
+      break;
+    total += res; 
+//    printf( &quot;Read %d bytes\n&quot;, res );
+    if( res &lt; toread )
+      break;
+    len -= toread;
+    p += toread;
+  }
+  return ( _ssize_t )total;
+}
+
+// lseek
+static off_t rfs_lseek_r( struct _reent *r, int fd, off_t off, int whence )
+{
+  return ( off_t )rfsc_lseek( fd, ( s32 )off, whence );
+}
+
+// opendir
+static void* rfs_opendir_r( struct _reent *r, const char* name )
+{
+  return ( void* )rfsc_opendir( name );
+}
+
+// readdir
+static struct dm_dirent* rfs_readdir_r( struct _reent *r, void *d )
+{
+  static struct dm_dirent ent;
+
+  rfsc_readdir( ( u32 )d, &amp;ent.fname, &amp;ent.fsize, &amp;ent.ftime );
+  if( ent.fname == NULL )
+    return NULL;
+  return &ent;
+}
+
+// closedir
+static int rfs_closedir_r( struct _reent *r, void *d )
+{
+  return rfsc_closedir( ( u32 )d );
+}
+
+// ****************************************************************************
+// Remote FS serial transport functions
+
+#ifdef RFS_UART_ID
+static u32 rfs_send( const u8 *p, u32 size )
+{
+  unsigned i;
+
+  for( i = 0; i &lt; size; i ++ )
+    platform_uart_send( RFS_UART_ID, p[ i ] );
+  return size;
+}
+
+static u32 rfs_recv( u8 *p, u32 size, u32 timeout )
+{
+  u32 cnt = 0;
+  int data;
+
+  while( size )
+  {
+    if( ( data = platform_uart_recv( RFS_UART_ID, RFS_TIMER_ID, timeout ) ) == -1 )
+      break;
+    *p ++ = ( u8 )data;
+    cnt ++;
+    size --;
+  }
+  return cnt;
+}
+#endif
+
+// ****************************************************************************
+// Remote FS pipe transport functions (used only in simulator)
+
+#ifdef ELUA_CPU_LINUX
+static u32 rfs_send( const u8 *p, u32 size )
+{
+  return ( u32 )hostif_write( rfs_write_fd, p, size );
+}
+
+static u32 rfs_recv( u8 *p, u32 size, u32 timeout )
+{
+  timeout = timeout;
+  return ( u32 )hostif_read( rfs_read_fd, p, size );
+}
+#endif
+
+// Our remote file system device descriptor structure
+static const DM_DEVICE rfs_device = 
+{
+  &quot;/rfs&quot;,
+  rfs_open_r,           // open
+  rfs_close_r,          // close
+  rfs_write_r,          // write
+  rfs_read_r,           // read
+  rfs_lseek_r,          // lseek
+  rfs_opendir_r,        // opendir
+  rfs_readdir_r,        // readdir
+  rfs_closedir_r        // closedir
+};
+
+const DM_DEVICE *remotefs_init()
+{
+#if defined( RFS_UART_ID ) &amp;&amp; defined( RFS_UART_SPEED )
+  // Initialize RFS UART
+  platform_uart_setup( RFS_UART_ID, RFS_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
+  // [TODO] this isn't exactly right
+  buf_set( BUF_ID_UART, RFS_UART_ID, RFS_BUFFER_SIZE, BUF_DSIZE_U8 ); 
+#endif
+#ifdef ELUA_CPU_LINUX 
+  // Open our read/write pipes
+  rfs_read_fd = hostif_open( RFS_SRV_WRITE_PIPE, O_RDONLY, 0 );
+  rfs_write_fd = hostif_open( RFS_SRV_READ_PIPE, O_WRONLY, 0 );
+  if( rfs_read_fd == -1 || rfs_write_fd == -1 )
+  {
+    hostif_putstr( &quot;unable to open read/write pipes\n&quot; );
+    return NULL;
+  }
+#endif
+  rfsc_setup( rfs_buffer, rfs_send, rfs_recv, RFS_TIMEOUT );
+  return &amp;rfs_device;
+}
+
+#else // #ifdef BUILD_RFS
+
+const DM_DEVICE *remotefs_init()
+{
+  return NULL;
+}
+
+#endif
+

Added: trunk/src/remotefs/remotefs.c
===================================================================
--- trunk/src/remotefs/remotefs.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/remotefs/remotefs.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -0,0 +1,512 @@
+// Remote file system implementation
+
+#include &lt;string.h&gt;
+#include &lt;stdarg.h&gt;
+#include &quot;type.h&quot;
+#include &quot;remotefs.h&quot;
+#include &quot;rtype.h&quot;
+
+static u8 remotefs_err_flag;
+
+// *****************************************************************************
+// Internal functions: data serialization
+
+static u8 *remotefs_write_u8( u8 *p, u8 data )
+{
+  *p ++ = TYPE_INT_8;
+  *p ++ = data;
+  return p;  
+}
+
+static u8* remotefs_write_op_id( u8 *p, u8 data )
+{
+  *p ++ = TYPE_OP_ID;
+  *p ++ = data;
+  return p;    
+}
+
+static u8 *remotefs_write_u16( u8 *p, u16 data )
+{
+  *p ++ = TYPE_INT_16;
+  *p ++ = data &amp; 0xFF;
+  *p ++ = ( data &gt;&gt; 8 ) &amp; 0xFF;
+  return p;    
+}
+
+static u8 *remotefs_write_u32( u8 *p, u32 data )
+{
+  *p ++ = TYPE_INT_32;
+  *p ++ = data &amp; 0xFF;
+  *p ++ = ( data &gt;&gt; 8 ) &amp; 0xFF;
+  *p ++ = ( data &gt;&gt; 16 ) &amp; 0xFF;
+  *p ++ = ( data &gt;&gt; 24 ) &amp; 0xFF;
+  return p;        
+}
+
+static u8 *remotefs_write_ptr( u8 *p, const void* src, u32 srclen )
+{
+  *p ++ = TYPE_PTR;
+  p = remotefs_write_u32( p, srclen );
+  if( src )
+    memcpy( p, src, srclen );
+  return p + srclen;    
+}
+
+// *****************************************************************************
+// Internal functions: data deserialization
+
+static const u8* remotefs_read_expect( const u8 *p, u8 data )
+{
+  if( *p ++ != data )
+    remotefs_err_flag = REMOTEFS_ERR;
+  return p;
+}
+
+static const u8 *remotefs_read_u8( const u8 *p, u8 *pdata )
+{
+  p = remotefs_read_expect( p, TYPE_INT_8 );
+  *pdata = *p ++;
+  return p;  
+}
+
+static const u8 *remotefs_read_op_id( const u8 *p, u8 *pdata )
+{
+  p = remotefs_read_expect( p, TYPE_OP_ID );
+  *pdata = *p ++;
+  return p;  
+}
+
+static const u8* remotefs_expect_op_id( const u8 *p, u8 id )
+{
+  u8 temp;
+  
+  p = remotefs_read_expect( p, TYPE_OP_ID );
+  temp = *p ++;
+  if( temp != id )
+    remotefs_err_flag = REMOTEFS_ERR;
+  return p;
+}
+
+static const u8 *remotefs_read_u16( const u8 *p, u16 *pdata )
+{
+  p = remotefs_read_expect( p, TYPE_INT_16 );
+  *pdata = *p ++;
+  *pdata |= ( *p ++ ) &lt;&lt; 8;  
+  return p;    
+}
+
+static const u8 *remotefs_read_u32( const u8 *p, u32 *pdata )
+{
+  p = remotefs_read_expect( p, TYPE_INT_32 );
+  *pdata = *p ++;                         
+  *pdata |= ( *p ++ ) &lt;&lt; 8;
+  *pdata |= ( *p ++ ) &lt;&lt; 16;
+  *pdata |= ( *p ++ ) &lt;&lt; 24;      
+  return p;        
+}
+
+static const u8 *remotefs_read_ptr( const u8 *p, void* src, u32 *psrclen )
+{                                         
+  p = remotefs_read_expect( p, TYPE_PTR );
+  p = remotefs_read_u32( p, psrclen );
+  if( src &amp;&amp; p )
+    memcpy( src, p, *psrclen );
+  return p + *psrclen;    
+}
+
+// *****************************************************************************
+// Internal functions: packet handling (read and write)
+
+static u8* remotefs_packet_ptr;
+
+static u8* remotefs_start_packet( u8 *p )
+{
+  remotefs_packet_ptr = p;
+  p += RFS_START_OFFSET;
+  *p ++ = TYPE_START;
+  p = remotefs_write_u32( p, PACKET_SIG );
+  return p;
+}
+
+static u8* remotefs_end_packet( u8 *p )
+{
+  u16 len;
+  
+  *p ++ = TYPE_END;
+  p = remotefs_write_u32( p, ~PACKET_SIG );
+  len = p - remotefs_packet_ptr;
+  p = remotefs_packet_ptr;
+  *p ++ = TYPE_PKT_SIZE;
+  remotefs_write_u16( p, len );  
+  return p;  
+}
+
+static const u8* remotefs_match_packet_start( const u8 *p )
+{
+  u32 data;
+  
+  p += RFS_START_OFFSET;
+  p = remotefs_read_expect( p, TYPE_START );
+  p = remotefs_read_u32( p, &amp;data );
+  if( data != PACKET_SIG )
+    remotefs_err_flag = REMOTEFS_ERR;
+  return p;
+}
+
+static const u8* remotefs_match_packet_end( const u8 *p )
+{
+  u32 data;
+  
+  p = remotefs_read_expect( p, TYPE_END );
+  p = remotefs_read_u32( p, &amp;data );
+  if( data != ~PACKET_SIG )
+    remotefs_err_flag = REMOTEFS_ERR;
+  return p;
+}
+
+// *****************************************************************************
+// Function serialization and deserialization
+
+int remotefs_get_request_id( const u8 *p, u8 *pid )
+{ 
+  remotefs_err_flag = REMOTEFS_OK;
+  p = remotefs_match_packet_start( p );
+  p = remotefs_read_op_id( p, pid );
+  return remotefs_err_flag;
+}
+
+u32 remotefs_replace_flag( u32 val, u32 origflag, u32 newflag )
+{
+  return ( val &amp; origflag ) ? newflag : 0; 
+}
+
+int remotefs_get_packet_size( const u8 *p, u16 *psize )
+{
+  remotefs_err_flag = REMOTEFS_OK;
+  p = remotefs_read_expect( p, TYPE_PKT_SIZE );
+  p = remotefs_read_u16( p, psize );
+  return remotefs_err_flag;
+}
+
+// Generic write function
+// Specifiers: o - operation
+//             r - response
+//             c - u8
+//             h - u16
+//             l - u32
+//             i - int
+//             L - s32
+//             p - ptr (given as ptr, len, len is an u32)
+void remotefs_gen_write( u8 *p, const char *fmt, ... )
+{
+  va_list ap;
+  const void *ptr;
+  u32 ptrlen;
+  
+  va_start( ap, fmt );
+  p = remotefs_start_packet( p );
+  while( *fmt )
+    switch( *fmt ++ )
+    {
+      case 'o':
+        p = remotefs_write_op_id( p, va_arg( ap, int ) );
+        break;
+        
+      case 'r':
+        *p++ = RFS_OP_RES_MOD | ( u8 )va_arg( ap, int );
+        break;
+        
+      case 'c':
+        p = remotefs_write_u8( p, ( u8 )va_arg( ap, int ) );
+        break;
+        
+      case 'h':
+        p = remotefs_write_u16( p, ( u16 )va_arg( ap, int ) );
+        break;
+
+      case 'i':
+        p = remotefs_write_u32( p, ( u32 )va_arg( ap, int ) );
+        break;
+        
+      case 'l':
+        p = remotefs_write_u32( p, ( u32 )va_arg( ap, u32 ) );
+        break;
+
+      case 'L':
+        p = remotefs_write_u32( p, ( u32 )va_arg( ap, s32 ) );
+        break;         
+      
+      case 'p':
+        ptr = va_arg( ap, void * );
+        ptrlen = ( u32 )va_arg( ap, long );
+        p = remotefs_write_ptr( p, ptr, ptrlen );
+        break;
+    }
+  remotefs_end_packet( p );
+}
+
+// Generic read function
+// Specifiers: o - operation
+//             r - response
+//             c - u8
+//             h - u16
+//             l - u32
+//             L - s32
+//             i - int
+//             p - ptr (returned as ptr, len, len is an u32)
+int remotefs_gen_read( const u8 *p, const char *fmt, ... )
+{
+  va_list ap;
+  const void *pptr;
+  u32 *ptrlen;
+  const u8 *tempptr;
+  u32 temp32;
+  
+  va_start( ap, fmt );
+  remotefs_err_flag = REMOTEFS_OK;
+  p = remotefs_match_packet_start( p );
+  while( *fmt )
+    switch( *fmt ++ )
+    {
+      case 'o':
+        p = remotefs_expect_op_id( p, va_arg( ap, int ) );
+        break;
+        
+      case 'r':
+        p = remotefs_read_expect( p, RFS_OP_RES_MOD | ( u8 )va_arg( ap, int ) );
+        break;
+        
+      case 'c':
+        p = remotefs_read_u8( p, ( u8* )va_arg( ap, void* ) );
+        break;
+        
+      case 'h':
+        p = remotefs_read_u16( p, ( u16* )va_arg( ap, void* ) );
+        break;
+        
+      case 'l':
+        p = remotefs_read_u32( p, ( u32* )va_arg( ap, void* ) );
+        break;     
+
+      case 'L':
+        p = remotefs_read_u32( p, &amp;temp32 );        
+        *( s32 *)va_arg( ap, void* ) = ( s32 )temp32;
+        break;     
+        
+      case 'i':
+        p = remotefs_read_u32( p, &amp;temp32 );
+        *( int* )va_arg( ap, void* ) = ( int )temp32;        
+        break;     
+      
+      case 'p':
+        pptr = va_arg( ap, void** );
+        ptrlen = va_arg( ap, void* );
+        tempptr = p;
+        p = remotefs_read_ptr( p, NULL, &amp;temp32 );
+        if( p == tempptr + RFS_PTR_HEADER_SIZE )
+          *( const u8** )pptr = NULL;
+        else
+          *( const u8** )pptr = tempptr + RFS_PTR_HEADER_SIZE;
+        if( ptrlen )
+          *ptrlen = temp32;        
+        break;
+    }
+  remotefs_match_packet_end( p );  
+  return remotefs_err_flag;
+}
+
+
+// *****************************************************************************
+// Operation: open
+// open: int open( const char *pathname,int flags, mode_t mode )
+
+void remotefs_open_write_response( u8 *p, int result )
+{
+  remotefs_gen_write( p, &quot;ri&quot;, RFS_OP_OPEN, result );
+}
+
+int remotefs_open_read_response( const u8 *p, int *presult )
+{
+  return remotefs_gen_read( p, &quot;ri&quot;, RFS_OP_OPEN, presult );  
+}
+
+void remotefs_open_write_request( u8 *p, const char* pathname, int flags, int mode )
+{
+  remotefs_gen_write( p, &quot;opii&quot;, RFS_OP_OPEN, pathname, strlen( pathname ) + 1, flags, mode );
+}
+
+int remotefs_open_read_request( const u8 *p, const char **ppathname, int *pflags, int *pmode )
+{  
+  return remotefs_gen_read( p, &quot;opii&quot;, RFS_OP_OPEN, ppathname, NULL, pflags, pmode );  
+}  
+
+// *****************************************************************************
+// Operation: write
+// write: ssize_t write( int fd, const void *buf, size_t count )
+ 
+void remotefs_write_write_response( u8 *p, u32 result )
+{                                                   
+  remotefs_gen_write( p, &quot;rl&quot;, RFS_OP_WRITE, result );  
+}
+
+int remotefs_write_read_response( const u8 *p, u32 *presult )
+{
+  return remotefs_gen_read( p, &quot;rl&quot;, RFS_OP_WRITE, presult );  
+}
+
+void remotefs_write_write_request( u8 *p, int fd, const void *buf, u32 count )
+{
+  remotefs_gen_write( p, &quot;oip&quot;, RFS_OP_WRITE, fd, buf, count ); 
+}
+
+int remotefs_write_read_request( const u8 *p, int *pfd, const void **pbuf, u32 *pcount )
+{
+  return remotefs_gen_read( p, &quot;oip&quot;, RFS_OP_WRITE, pfd, pbuf, pcount );  
+}
+
+// *****************************************************************************
+// Operation: read
+// read: ssize_t read( int fd, void *buf, size_t count )
+
+void remotefs_read_write_response( u8 *p, u32 readbytes )
+{
+  remotefs_gen_write( p, &quot;rp&quot;, RFS_OP_READ, NULL, readbytes );  
+}
+
+int remotefs_read_read_response( const u8 *p, const u8 **ppdata, u32 *preadbytes )
+{
+  return remotefs_gen_read( p, &quot;rp&quot;, RFS_OP_READ, ppdata, preadbytes );  
+}
+
+void remotefs_read_write_request( u8 *p, int fd, u32 count )
+{
+  remotefs_gen_write( p, &quot;oil&quot;, RFS_OP_READ, fd, count ); 
+}
+
+int remotefs_read_read_request( const u8 *p, int *pfd, u32 *pcount )
+{
+  return remotefs_gen_read( p, &quot;oil&quot;, RFS_OP_READ, pfd, pcount );    
+}
+  
+// *****************************************************************************
+// Operation: close  
+// close: int close( int fd )
+  
+void remotefs_close_write_response( u8 *p, int result )
+{
+  remotefs_gen_write( p, &quot;ri&quot;, RFS_OP_CLOSE, result );  
+}
+
+int remotefs_close_read_response( const u8 *p, int *presult )
+{
+  return remotefs_gen_read( p, &quot;ri&quot;, RFS_OP_CLOSE, presult );   
+}
+
+void remotefs_close_write_request( u8 *p, int fd )
+{
+  remotefs_gen_write( p, &quot;oi&quot;, RFS_OP_CLOSE, fd ); 
+}
+
+int remotefs_close_read_request( const u8 *p, int *pfd )
+{
+  return remotefs_gen_read( p, &quot;oi&quot;, RFS_OP_CLOSE, pfd );  
+}
+
+// *****************************************************************************
+// Operation: lseek
+// lseek: lseek( int fd, off_t offset, int whence )
+
+void remotefs_lseek_write_response( u8 *p, s32 result )
+{
+  remotefs_gen_write( p, &quot;rL&quot;, RFS_OP_LSEEK, result );
+}
+
+int remotefs_lseek_read_response( const u8 *p, s32 *presult )
+{
+  return remotefs_gen_read( p, &quot;rL&quot;, RFS_OP_LSEEK, presult );   
+}
+
+void remotefs_lseek_write_request( u8 *p, int fd, s32 offset, int whence )
+{
+  remotefs_gen_write( p, &quot;oiLi&quot;, RFS_OP_LSEEK, fd, offset, whence ); 
+}
+
+int remotefs_lseek_read_request( const u8 *p, int *pfd, s32 *poffset, int *pwhence )
+{
+  return remotefs_gen_read( p, &quot;oiLi&quot;, RFS_OP_LSEEK, pfd, poffset, pwhence );
+}
+
+// ****************************************************************************
+// Operation: opendir
+// opendir: u32 opendir( const char* name )
+
+void remotefs_opendir_write_response( u8 *p, u32 d )
+{
+  remotefs_gen_write( p, &quot;rl&quot;, RFS_OP_OPENDIR, d );
+}
+
+int remotefs_opendir_read_response( const u8 *p, u32 *pd )
+{
+  return remotefs_gen_read( p, &quot;rl&quot;, RFS_OP_OPENDIR, pd );
+}
+
+void remotefs_opendir_write_request( u8 *p, const char* name )
+{
+  remotefs_gen_write( p, &quot;op&quot;, RFS_OP_OPENDIR, name, strlen( name ) + 1 );
+}
+
+int remotefs_opendir_read_request( const u8 *p, const char **pname )
+{
+  return remotefs_gen_read( p, &quot;op&quot;, RFS_OP_OPENDIR, pname, NULL );
+}
+
+// ****************************************************************************
+// Operation: readdir
+// readdir: readdir( u32 d, const char **pname, u32 *psize, u32 *pftime );
+// Will return fname, size, ftime as side effects in response
+
+void remotefs_readdir_write_response( u8 *p, const char *name, u32 size, u32 ftime )
+{
+  remotefs_gen_write( p, &quot;rpll&quot;, RFS_OP_READDIR, name, name ? strlen( name ) + 1 : 0, size, ftime );
+}
+
+int remotefs_readdir_read_response( const u8 *p, const char **pname, u32 *psize, u32 *pftime )
+{
+  return remotefs_gen_read( p, &quot;rpll&quot;,  RFS_OP_READDIR, pname, NULL, psize, pftime );
+}
+
+void remotefs_readdir_write_request( u8 *p, u32 d )
+{
+  remotefs_gen_write( p, &quot;ol&quot;, RFS_OP_READDIR, d );
+}
+
+int remotefs_readdir_read_request( const u8 *p, u32 *pd )
+{
+  return remotefs_gen_read( p, &quot;ol&quot;, RFS_OP_READDIR, pd );
+}
+
+// ****************************************************************************
+// Operation: closedir
+// closedir: int closedir( u32 d )
+
+void remotefs_closedir_write_response( u8 *p, int d )
+{
+  remotefs_gen_write( p, &quot;ri&quot;, RFS_OP_CLOSEDIR, d );
+}
+
+int remotefs_closedir_read_response( const u8 *p, int *pd )
+{
+  return remotefs_gen_read( p, &quot;ri&quot;, RFS_OP_CLOSEDIR, pd );
+}
+
+void remotefs_closedir_write_request( u8 *p, u32 d )
+{
+  remotefs_gen_write( p, &quot;ol&quot;, RFS_OP_CLOSEDIR, d );
+}
+
+int remotefs_closedir_read_request( const u8 *p, u32 *pd )
+{
+  return remotefs_gen_read( p, &quot;ol&quot;, RFS_OP_CLOSEDIR, pd );
+}
+
+

Modified: trunk/src/romfs.c
===================================================================
--- trunk/src/romfs.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/romfs.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -4,12 +4,12 @@
 #include &lt;string.h&gt;
 #include &lt;errno.h&gt;
 #include &quot;devman.h&quot;
+#include &quot;romfiles.h&quot;
 #include &lt;stdio.h&gt;
 #include &quot;ioctl.h&quot;
 
 #include &quot;platform_conf.h&quot;
 #ifdef BUILD_ROMFS
-#include &quot;romfiles.h&quot;
 
 #define ROMFS_MAX_FDS   4
 #define fsmin( x , y ) ( ( x ) &lt; ( y ) ? ( x ) : ( y ) )
@@ -42,7 +42,7 @@
 u8 romfs_open_file( const char* fname, p_read_fs_byte p_read_func, FS* pfs )
 {
   u32 i, j;
-  char fsname[ MAX_FNAME_LENGTH + 1 ];
+  char fsname[ DM_MAX_FNAME_LENGTH + 1 ];
   u16 fsize;
   
   // Look for the file
@@ -50,7 +50,7 @@
   while( 1 )
   {
     // Read file name
-    for( j = 0; j &lt; MAX_FNAME_LENGTH; j ++ )
+    for( j = 0; j &lt; DM_MAX_FNAME_LENGTH; j ++ )
     {
       fsname[ j ] = p_read_func( i + j );
       if( fsname[ j ] == 0 )
@@ -65,7 +65,7 @@
     j = i + j + 1;
     // And read the size   
     fsize = p_read_func( j ) + ( p_read_func( j + 1 ) &lt;&lt; 8 );
-    if( !strncasecmp( fname, fsname, MAX_FNAME_LENGTH ) )
+    if( !strncasecmp( fname, fsname, DM_MAX_FNAME_LENGTH ) )
     {
       // Found the file
       pfs-&gt;baseaddr = j + 2;
@@ -124,78 +124,97 @@
   return actlen;
 }
 
-// IOCTL: only fseek
-static int romfs_ioctl_r( struct _reent *r, int fd, unsigned long request, void *ptr )
+// lseek
+static off_t romfs_lseek_r( struct _reent *r, int fd, off_t off, int whence )
 {
-  struct fd_seek *pseek = ( struct fd_seek* )ptr;
   FS* pfs = romfs_fd_table + fd;   
   u32 newpos = 0;
   
-  if( request == FDSEEK )
+  switch( whence )
   {
-    switch( pseek-&gt;dir )
-    {
-      case SEEK_SET:
-        newpos = pseek-&gt;off;
-        break;
-        
-      case SEEK_CUR:
-        newpos = pfs-&gt;offset + pseek-&gt;off;
-        break;
-        
-      case SEEK_END:
-        newpos = pfs-&gt;size + pseek-&gt;off;
-        break;
-        
-      default:
-        return -1;
-    }    
-    if( newpos &gt; pfs-&gt;size )
+    case SEEK_SET:
+      newpos = off;
+      break;
+      
+    case SEEK_CUR:
+      newpos = pfs-&gt;offset + off;
+      break;
+      
+    case SEEK_END:
+      newpos = pfs-&gt;size + off;
+      break;
+      
+    default:
       return -1;
-    pfs-&gt;offset = newpos;      
-    pseek-&gt;off = newpos;
-    return 0;
+  }    
+  if( newpos &gt; pfs-&gt;size )
+    return -1;
+  pfs-&gt;offset = newpos;      
+  return newpos;
+}
+
+// Directory operations
+static u32 romfs_dir_data = 0;
+
+// opendir
+static void* romfs_opendir_r( struct _reent *r, const char* dname )
+{
+  if( !dname || strlen( dname ) == 0 || ( strlen( dname ) == 1 &amp;&amp; !strcmp( dname, &quot;/&quot; ) ) )
+  {
+    romfs_dir_data = 0;
+    return &amp;romfs_dir_data;
   }
-  else
-    return -1;  
+  return NULL;
 }
 
-// Our UART device descriptor structure
-static DM_DEVICE romfs_device = 
+// readdir
+extern struct dm_dirent dm_shared_dirent;
+extern char dm_shared_fname[ DM_MAX_FNAME_LENGTH + 1 ];
+static struct dm_dirent* romfs_readdir_r( struct _reent *r, void *d )
 {
+  u32 off = *( u32* )d;
+  struct dm_dirent *pent = &amp;dm_shared_dirent;
+  unsigned j = 0;
+  
+  if( romfs_read( off ) == 0 )
+    return NULL;
+  while( ( dm_shared_fname[ j ++ ] = romfs_read( off ++ ) ) != '\0' );
+  pent-&gt;fname = dm_shared_fname;
+  pent-&gt;fsize = romfs_read( off ) + ( romfs_read( off + 1 ) &lt;&lt; 8 );
+  pent-&gt;ftime = 0;
+  *( u32* )d = off + 2 + pent-&gt;fsize;
+  return pent;
+}
+
+// closedir
+static int romfs_closedir_r( struct _reent *r, void *d )
+{
+  *( u32* )d = 0;
+  return 0;
+}
+
+// Our ROMFS device descriptor structure
+static const DM_DEVICE romfs_device = 
+{
   &quot;/rom&quot;,
-  romfs_open_r,  
-  romfs_close_r, 
-  romfs_write_r,
-  romfs_read_r,
-  romfs_ioctl_r
+  romfs_open_r,         // open
+  romfs_close_r,        // close
+  romfs_write_r,        // write
+  romfs_read_r,         // read
+  romfs_lseek_r,        // lseek
+  romfs_opendir_r,      // opendir
+  romfs_readdir_r,      // readdir
+  romfs_closedir_r      // closedir
 };
 
-DM_DEVICE* romfs_init()
+const DM_DEVICE* romfs_init()
 {
   return &amp;romfs_device;
 }
 
-// Retrieves file name and size from ROMFS entry at romfiles[offset]
-// Returns the next file entry offset or null on last entry
-u32 romfs_get_dir_entry( u32 offset, char *fname, u16 *fsize )
-{
-  u32 i = offset;
-  unsigned j = 0;
-  
-  if ( romfs_read( i ) != 0 )
-  {
-    while( ( fname[ j++ ] = romfs_read( i++ ) ) );
-    *fsize = romfs_read( i ) + ( romfs_read( i + 1 ) &lt;&lt; 8 );
-    return i + 2 + *fsize;
-  }
-  else
-    return 0;  
-}
-
 #else // #ifdef BUILD_ROMFS
 
-DM_DEVICE* romfs_init()
+const DM_DEVICE* romfs_init()
 {
   return NULL;
 }

Modified: trunk/src/shell.c
===================================================================
--- trunk/src/shell.c	2010-02-01 15:31:37 UTC (rev 695)
+++ trunk/src/shell.c	2010-02-01 18:47:41 UTC (rev 696)
@@ -11,6 +11,7 @@
 #include &lt;stdlib.h&gt;
 #include &quot;platform.h&quot;
 #include &quot;elua_net.h&quot;
+#include &quot;devman.h&quot;
 
 #include &quot;platform_conf.h&quot;
 #ifdef BUILD_SHELL
@@ -25,16 +26,6 @@
   #define SHELL_EOF_STRING        &quot;CTRL+D&quot;
 #endif
 
-#if defined(BUILD_ROMFS)
-  #include &quot;romfs.h&quot;
-#endif
-#if defined(BUILD_MMCFS)
-  #include &quot;mmcfs.h&quot;
-  #include &quot;ff.h&quot;
-  static DIR mmc_dir;
-  static FILINFO mmc_fileInfo;
-#endif
-
 // Shell command handler function
 typedef void( *p_shell_handler )( char* args );
 
@@ -146,7 +137,6 @@
   while( *p == '\x1A' )
     p --;
   p ++;
-  
   printf( &quot;done, got %u bytes\n&quot;, ( unsigned )( p - shell_prog ) );          
   
   // Execute
@@ -180,50 +170,38 @@
 // 'ls' and 'dir' handler
 static void shell_ls( char* args )
 {
-  u32 offset = 0;
-  char fname[ MAX_FNAME_LENGTH + 1 ];
-  unsigned i;
-  u16 size;
-  u32 total = 0;
-  
-  args = args;
-  printf( &quot;\n/rom&quot; );
-  while ( ( offset = romfs_get_dir_entry( offset, fname, &amp;size ) ) )
-  {
-    printf( &quot;\n%s&quot;, fname );
-    for( i = strlen( fname ); i &lt;= MAX_FNAME_LENGTH; i++ )
-      printf( &quot; &quot; );
-    printf( &quot;%u bytes&quot;, ( unsigned )size );
-    total = total + size;
-  }
-  printf( &quot;\n\nTotal = %u bytes\n\n&quot;, ( unsigned )total );
+  const DM_DEVICE *pdev;
+  unsigned dev, i;
+  DM_DIR *d;
+  struct dm_dirent *ent;
+  u32 total;
 
-#if defined(BUILD_MMCFS)
-  total = 0;
-  printf( &quot;\n/mmc&quot; );
-  if (f_opendir(&amp;mmc_dir, &quot;/&quot;) != FR_OK)
-  {
-    printf( &quot;\n\nTotal = %u bytes\n\n&quot;, ( unsigned )total );
-    return;
-  }
-
-  while (f_readdir(&amp;mmc_dir, &amp;mmc_fileInfo) == FR_OK)
-  {
-    if (!mmc_fileInfo.fname[0])
-      break;
-    strcpy(fname, mmc_fileInfo.fname);
-    size = mmc_fileInfo.fsize;
-    printf( &quot;\n%s&quot;, fname );
-    for( i = strlen( fname ); i &lt;= MAX_FNAME_LENGTH; i++ )
-      printf( &quot; &quot; );
-    printf( &quot;%d bytes&quot;, size );
-    total = total + size;
-  }
-  printf( &quot;\n\nTotal = %d bytes\n\n&quot;, ( unsigned )total );
-#endif
+  // Iterate through all devices, looking for the ones that can do &quot;opendir&quot;
+  for( dev = 0; dev &lt; dm_get_num_devices(); dev ++ )
+  {  
+    pdev = dm_get_device_at( dev );
+    if( pdev-&gt;p_opendir_r == NULL || pdev-&gt;p_readdir_r == NULL || pdev-&gt;p_closedir_r == NULL )
+      continue;
+    d = dm_opendir( pdev-&gt;name );
+    if( d )
+    {
+      total = 0;
+      printf( &quot;\n%s&quot;, pdev-&gt;name );
+      while( ( ent = dm_readdir( d ) ) != NULL )
+      {
+        printf( &quot;\n%s&quot;, ent-&gt;fname );
+        for( i = strlen( ent-&gt;fname ); i &lt;= DM_MAX_FNAME_LENGTH; i++ )
+          printf( &quot; &quot; );
+        printf( &quot;%u bytes&quot;, ( unsigned )ent-&gt;fsize );
+        total = total + ent-&gt;fsize;
+      }
+      printf( &quot;\n\nTotal on %s: %u bytes\n&quot;, pdev-&gt;name, ( unsigned )total );
+      dm_closedir( d );
+    }
+  }   
+  printf( &quot;\n&quot; );
 }
 
-
 // 'cat' and 'type' handler
 static void shell_cat( char *args )
 {
@@ -234,12 +212,15 @@
 // *args has an appended space. Replace it with the string terminator.
 //  *(strchr( args, ' ' )) = 0;
   if ( *args )
-    while ( *args ) {
+    while ( *args ) 
+    {
       p = strchr( args, ' ' );
       *p = 0;
-      if( ( fp = fopen( args , &quot;rb&quot; ) ) != NULL ) {
+      if( ( fp = fopen( args , &quot;rb&quot; ) ) != NULL ) 
+      {
         c = fgetc( fp );
-        while( c != EOF ) {
+        while( c != EOF ) 
+        {
           printf(&quot;%c&quot;, (char) c );  
           c = fgetc( fp );
         }
@@ -253,9 +234,6 @@
       printf( &quot;Usage: cat (or type) &lt;filename1&gt; [&lt;filename2&gt; ...]\n&quot; );
 }    
 
-
-
-
 // Insert shell commands here
 static const SHELL_COMMAND shell_commands[] =
 {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000648.html">[Elua-svn] r695 - trunk/doc/en
</A></li>
	<LI>Next message: <A HREF="000650.html">[Elua-svn] r697 - trunk/src/platform/lpc24xx
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#649">[ date ]</a>
              <a href="thread.html#649">[ thread ]</a>
              <a href="subject.html#649">[ subject ]</a>
              <a href="author.html#649">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
