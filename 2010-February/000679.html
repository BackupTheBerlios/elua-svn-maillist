<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r726 - in trunk/src: fatfs newlib platform/avr32	platform/avr32/EVK1100 platform/avr32/MT48LC16M16A2TG7E
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r726%20-%20in%20trunk/src%3A%20fatfs%20newlib%20platform/avr32%0A%09platform/avr32/EVK1100%20platform/avr32/MT48LC16M16A2TG7E&In-Reply-To=%3C201002241946.o1OJkOxE028385%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000678.html">
   <LINK REL="Next"  HREF="000680.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r726 - in trunk/src: fatfs newlib platform/avr32	platform/avr32/EVK1100 platform/avr32/MT48LC16M16A2TG7E</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r726%20-%20in%20trunk/src%3A%20fatfs%20newlib%20platform/avr32%0A%09platform/avr32/EVK1100%20platform/avr32/MT48LC16M16A2TG7E&In-Reply-To=%3C201002241946.o1OJkOxE028385%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r726 - in trunk/src: fatfs newlib platform/avr32	platform/avr32/EVK1100 platform/avr32/MT48LC16M16A2TG7E">bogdanm at mail.berlios.de
       </A><BR>
    <I>Wed Feb 24 20:46:24 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000678.html">[Elua-svn] r725 - trunk/inc
</A></li>
        <LI>Next message: <A HREF="000680.html">[Elua-svn] r727 - in trunk/src/platform/lpc17xx: . drivers/inc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#679">[ date ]</a>
              <a href="thread.html#679">[ thread ]</a>
              <a href="subject.html#679">[ subject ]</a>
              <a href="author.html#679">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2010-02-24 20:45:50 +0100 (Wed, 24 Feb 2010)
New Revision: 726

Added:
   trunk/src/platform/avr32/EVK1100/
   trunk/src/platform/avr32/EVK1100/evk1100.h
   trunk/src/platform/avr32/EVK1100/evk1100_revA.h
   trunk/src/platform/avr32/MT48LC16M16A2TG7E/
   trunk/src/platform/avr32/MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h
Removed:
   trunk/src/platform/avr32/evk1100.h
   trunk/src/platform/avr32/mt48lc16m16a2tg7e.h
Modified:
   trunk/src/fatfs/ff.c
   trunk/src/newlib/stubs.c
   trunk/src/platform/avr32/board.h
   trunk/src/platform/avr32/compiler.h
   trunk/src/platform/avr32/conf_isp.h
   trunk/src/platform/avr32/exception.s
   trunk/src/platform/avr32/flashc.c
   trunk/src/platform/avr32/flashc.h
   trunk/src/platform/avr32/gpio.c
   trunk/src/platform/avr32/gpio.h
   trunk/src/platform/avr32/intc.c
   trunk/src/platform/avr32/intc.h
   trunk/src/platform/avr32/mrepeat.h
   trunk/src/platform/avr32/pm.c
   trunk/src/platform/avr32/pm.h
   trunk/src/platform/avr32/pm_conf_clocks.c
   trunk/src/platform/avr32/preprocessor.h
   trunk/src/platform/avr32/sdramc.c
   trunk/src/platform/avr32/sdramc.h
   trunk/src/platform/avr32/stringz.h
   trunk/src/platform/avr32/tc.c
   trunk/src/platform/avr32/tc.h
   trunk/src/platform/avr32/tpaste.h
   trunk/src/platform/avr32/usart.c
   trunk/src/platform/avr32/usart.h
Log:
modified AVR32 port to work with AVR32 toolchain 2.4.2, tested only under Windows, shouldn't have no issues in Linux either

Modified: trunk/src/fatfs/ff.c
===================================================================
--- trunk/src/fatfs/ff.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/fatfs/ff.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -78,7 +78,10 @@
 
 #include &quot;ff.h&quot;			/* FatFs configurations and declarations */
 #include &quot;diskio.h&quot;		/* Declarations of low level disk I/O functions */
+#include &quot;platform_conf.h&quot;
 
+#ifdef BUILD_MMCFS
+
 /*--------------------------------------------------------------------------
 
    Module Private Definitions
@@ -3151,3 +3154,5 @@
 
 #endif /* !_FS_READONLY */
 #endif /* _USE_STRFUNC */
+
+#endif // #ifdef BUILD_MMCFS

Modified: trunk/src/newlib/stubs.c
===================================================================
--- trunk/src/newlib/stubs.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/newlib/stubs.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -228,11 +228,7 @@
 }
 
 #include &lt;sys/time.h&gt;
-#ifdef FORAVR32
-int _gettimeofday_r( struct _reent *r, struct timeval *tp, struct timezone *tzp )
-#else
 int _gettimeofday_r( struct _reent *r, struct timeval *tv, void *tz )
-#endif
 {
   r-&gt;_errno = ENOSYS;
   return -1;  

Added: trunk/src/platform/avr32/EVK1100/evk1100.h
===================================================================
--- trunk/src/platform/avr32/EVK1100/evk1100.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/EVK1100/evk1100.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -0,0 +1,330 @@
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief AT32UC3A EVK1100 board header file.
+ *
+ * This file contains definitions and services related to the features of the
+ * EVK1100 board rev. B and C.
+ *
+ * To use this board, define BOARD=EVK1100.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 AT32UC3A devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _EVK1100_H_
+#define _EVK1100_H_
+
+#ifdef EVK1100_REVA
+#  include &quot;evk1100_revA.h&quot;
+#else
+
+#include &quot;compiler.h&quot;
+
+//#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+//#  include &quot;led.h&quot;
+//#endif  // __AVR32_ABI_COMPILER__
+
+
+/*! \name Oscillator Definitions
+ */
+//! @{
+
+// RCOsc has no custom calibration by default. Set the following definition to
+// the appropriate value if a custom RCOsc calibration has been applied to your
+// part.
+//#define FRCOSC          AVR32_PM_RCOSC_FREQUENCY              //!&lt; RCOsc frequency: Hz.
+
+#define FOSC32          32768                                 //!&lt; Osc32 frequency: Hz.
+#define OSC32_STARTUP   AVR32_PM_OSCCTRL32_STARTUP_8192_RCOSC //!&lt; Osc32 startup time: RCOsc periods.
+
+#define FOSC0           12000000                              //!&lt; Osc0 frequency: Hz.
+#define OSC0_STARTUP    AVR32_PM_OSCCTRL0_STARTUP_2048_RCOSC  //!&lt; Osc0 startup time: RCOsc periods.
+
+// Osc1 crystal is not mounted by default. Set the following definitions to the
+// appropriate values if a custom Osc1 crystal is mounted on your board.
+//#define FOSC1           12000000                              //!&lt; Osc1 frequency: Hz.
+//#define OSC1_STARTUP    AVR32_PM_OSCCTRL1_STARTUP_2048_RCOSC  //!&lt; Osc1 startup time: RCOsc periods.
+
+//! @}
+
+
+/*! \name SDRAM Definitions
+ */
+//! @{
+
+//! Part header file of used SDRAM(s).
+#define SDRAM_PART_HDR  &quot;MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h&quot;
+
+//! Data bus width to use the SDRAM(s) with (16 or 32 bits; always 16 bits on
+//! UC3).
+#define SDRAM_DBW       16
+
+//! @}
+
+
+/*! \name USB Definitions
+ */
+//! @{
+
+//! Multiplexed pin used for USB_ID: AVR32_USBB_USB_ID_x_x.
+//! To be selected according to the AVR32_USBB_USB_ID_x_x_PIN and
+//! AVR32_USBB_USB_ID_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
+#define USB_ID                      AVR32_USBB_USB_ID_0_0
+
+//! Multiplexed pin used for USB_VBOF: AVR32_USBB_USB_VBOF_x_x.
+//! To be selected according to the AVR32_USBB_USB_VBOF_x_x_PIN and
+//! AVR32_USBB_USB_VBOF_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
+#define USB_VBOF                    AVR32_USBB_USB_VBOF_0_1
+
+//! Active level of the USB_VBOF output pin.
+#define USB_VBOF_ACTIVE_LEVEL       LOW
+
+//! USB overcurrent detection pin.
+#define USB_OVERCURRENT_DETECT_PIN  AVR32_PIN_PX33
+
+//! @}
+
+
+//! GPIO connection of the MAC PHY PWR_DOWN/INT signal.
+#define MACB_INTERRUPT_PIN  AVR32_PIN_PA24
+
+
+//! Number of LEDs.
+#define LED_COUNT   8
+
+/*! \name GPIO Connections of LEDs
+ */
+//! @{
+#define LED0_GPIO   AVR32_PIN_PB27
+#define LED1_GPIO   AVR32_PIN_PB28
+#define LED2_GPIO   AVR32_PIN_PB29
+#define LED3_GPIO   AVR32_PIN_PB30
+#define LED4_GPIO   AVR32_PIN_PB19
+#define LED5_GPIO   AVR32_PIN_PB20
+#define LED6_GPIO   AVR32_PIN_PB21
+#define LED7_GPIO   AVR32_PIN_PB22
+//! @}
+
+/*! \name PWM Channels of LEDs
+ */
+//! @{
+#define LED0_PWM    (-1)
+#define LED1_PWM    (-1)
+#define LED2_PWM    (-1)
+#define LED3_PWM    (-1)
+#define LED4_PWM      0
+#define LED5_PWM      1
+#define LED6_PWM      2
+#define LED7_PWM      3
+//! @}
+
+/*! \name PWM Functions of LEDs
+ */
+//! @{
+#define LED0_PWM_FUNCTION   (-1)
+#define LED1_PWM_FUNCTION   (-1)
+#define LED2_PWM_FUNCTION   (-1)
+#define LED3_PWM_FUNCTION   (-1)
+#define LED4_PWM_FUNCTION   AVR32_PWM_0_FUNCTION
+#define LED5_PWM_FUNCTION   AVR32_PWM_1_FUNCTION
+#define LED6_PWM_FUNCTION   AVR32_PWM_2_FUNCTION
+#define LED7_PWM_FUNCTION   AVR32_PWM_3_FUNCTION
+//! @}
+
+/*! \name Color Identifiers of LEDs to Use with LED Functions
+ */
+//! @{
+#define LED_MONO0_GREEN   LED0
+#define LED_MONO1_GREEN   LED1
+#define LED_MONO2_GREEN   LED2
+#define LED_MONO3_GREEN   LED3
+#define LED_BI0_GREEN     LED5
+#define LED_BI0_RED       LED4
+#define LED_BI1_GREEN     LED7
+#define LED_BI1_RED       LED6
+//! @}
+
+
+/*! \name GPIO Connections of Push Buttons
+ */
+//! @{
+#define GPIO_PUSH_BUTTON_0            AVR32_PIN_PX16
+#define GPIO_PUSH_BUTTON_0_PRESSED    0
+#define GPIO_PUSH_BUTTON_1            AVR32_PIN_PX19
+#define GPIO_PUSH_BUTTON_1_PRESSED    0
+#define GPIO_PUSH_BUTTON_2            AVR32_PIN_PX22
+#define GPIO_PUSH_BUTTON_2_PRESSED    0
+//! @}
+
+
+/*! \name GPIO Connections of the Joystick
+ */
+//! @{
+#define GPIO_JOYSTICK_PUSH            AVR32_PIN_PA20
+#define GPIO_JOYSTICK_PUSH_PRESSED    0
+#define GPIO_JOYSTICK_LEFT            AVR32_PIN_PA25
+#define GPIO_JOYSTICK_LEFT_PRESSED    0
+#define GPIO_JOYSTICK_RIGHT           AVR32_PIN_PA28
+#define GPIO_JOYSTICK_RIGHT_PRESSED   0
+#define GPIO_JOYSTICK_UP              AVR32_PIN_PA26
+#define GPIO_JOYSTICK_UP_PRESSED      0
+#define GPIO_JOYSTICK_DOWN            AVR32_PIN_PA27
+#define GPIO_JOYSTICK_DOWN_PRESSED    0
+//! @}
+
+
+/*! \name ADC Connection of the Potentiometer
+ */
+//! @{
+#define ADC_POTENTIOMETER_CHANNEL   1
+#define ADC_POTENTIOMETER_PIN       AVR32_ADC_AD_1_PIN
+#define ADC_POTENTIOMETER_FUNCTION  AVR32_ADC_AD_1_FUNCTION
+//! @}
+
+
+/*! \name ADC Connection of the Temperature Sensor
+ */
+//! @{
+#define ADC_TEMPERATURE_CHANNEL     0
+#define ADC_TEMPERATURE_PIN         AVR32_ADC_AD_0_PIN
+#define ADC_TEMPERATURE_FUNCTION    AVR32_ADC_AD_0_FUNCTION
+//! @}
+
+
+/*! \name ADC Connection of the Light Sensor
+ */
+//! @{
+#define ADC_LIGHT_CHANNEL           2
+#define ADC_LIGHT_PIN               AVR32_ADC_AD_2_PIN
+#define ADC_LIGHT_FUNCTION          AVR32_ADC_AD_2_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the DIP204 LCD
+ */
+//! @{
+#define DIP204_SPI                  (&amp;AVR32_SPI1)
+#define DIP204_SPI_NPCS             2
+#define DIP204_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
+#define DIP204_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
+#define DIP204_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
+#define DIP204_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
+#define DIP204_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
+#define DIP204_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
+#define DIP204_SPI_NPCS_PIN         AVR32_SPI1_NPCS_2_0_PIN
+#define DIP204_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_2_0_FUNCTION
+//! @}
+
+/*! \name GPIO and PWM Connections of the DIP204 LCD Backlight
+ */
+//! @{
+#define DIP204_BACKLIGHT_PIN        AVR32_PIN_PB18
+#define DIP204_PWM_CHANNEL          6
+#define DIP204_PWM_PIN              AVR32_PWM_6_PIN
+#define DIP204_PWM_FUNCTION         AVR32_PWM_6_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the AT45DBX Data Flash Memory
+ */
+//! @{
+#define AT45DBX_SPI                 (&amp;AVR32_SPI1)
+#define AT45DBX_SPI_NPCS            0
+#define AT45DBX_SPI_SCK_PIN         AVR32_SPI1_SCK_0_0_PIN
+#define AT45DBX_SPI_SCK_FUNCTION    AVR32_SPI1_SCK_0_0_FUNCTION
+#define AT45DBX_SPI_MISO_PIN        AVR32_SPI1_MISO_0_0_PIN
+#define AT45DBX_SPI_MISO_FUNCTION   AVR32_SPI1_MISO_0_0_FUNCTION
+#define AT45DBX_SPI_MOSI_PIN        AVR32_SPI1_MOSI_0_0_PIN
+#define AT45DBX_SPI_MOSI_FUNCTION   AVR32_SPI1_MOSI_0_0_FUNCTION
+#define AT45DBX_SPI_NPCS0_PIN       AVR32_SPI1_NPCS_0_0_PIN
+#define AT45DBX_SPI_NPCS0_FUNCTION  AVR32_SPI1_NPCS_0_0_FUNCTION
+//! @}
+
+
+/*! \name GPIO and SPI Connections of the SD/MMC Connector
+ */
+//! @{
+#define SD_MMC_CARD_DETECT_PIN      AVR32_PIN_PA02
+#define SD_MMC_WRITE_PROTECT_PIN    AVR32_PIN_PA07
+#define SD_MMC_SPI                  (&amp;AVR32_SPI1)
+#define SD_MMC_SPI_NPCS             1
+#define SD_MMC_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
+#define SD_MMC_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
+#define SD_MMC_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
+#define SD_MMC_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
+#define SD_MMC_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
+#define SD_MMC_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
+#define SD_MMC_SPI_NPCS_PIN         AVR32_SPI1_NPCS_1_0_PIN
+#define SD_MMC_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_1_0_FUNCTION
+//! @}
+
+
+/*! \name TWI Connections of the Spare TWI Connector
+ */
+//! @{
+#define SPARE_TWI                   (&amp;AVR32_TWI)
+#define SPARE_TWI_SCL_PIN           AVR32_TWI_SCL_0_0_PIN
+#define SPARE_TWI_SCL_FUNCTION      AVR32_TWI_SCL_0_0_FUNCTION
+#define SPARE_TWI_SDA_PIN           AVR32_TWI_SDA_0_0_PIN
+#define SPARE_TWI_SDA_FUNCTION      AVR32_TWI_SDA_0_0_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the Spare SPI Connector
+ */
+//! @{
+#define SPARE_SPI                   (&amp;AVR32_SPI0)
+#define SPARE_SPI_NPCS              0
+#define SPARE_SPI_SCK_PIN           AVR32_SPI0_SCK_0_0_PIN
+#define SPARE_SPI_SCK_FUNCTION      AVR32_SPI0_SCK_0_0_FUNCTION
+#define SPARE_SPI_MISO_PIN          AVR32_SPI0_MISO_0_0_PIN
+#define SPARE_SPI_MISO_FUNCTION     AVR32_SPI0_MISO_0_0_FUNCTION
+#define SPARE_SPI_MOSI_PIN          AVR32_SPI0_MOSI_0_0_PIN
+#define SPARE_SPI_MOSI_FUNCTION     AVR32_SPI0_MOSI_0_0_FUNCTION
+#define SPARE_SPI_NPCS_PIN          AVR32_SPI0_NPCS_0_0_PIN
+#define SPARE_SPI_NPCS_FUNCTION     AVR32_SPI0_NPCS_0_0_FUNCTION
+//! @}
+
+
+#endif  // !EVK1100_REVA
+
+#endif  // _EVK1100_H_

Added: trunk/src/platform/avr32/EVK1100/evk1100_revA.h
===================================================================
--- trunk/src/platform/avr32/EVK1100/evk1100_revA.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/EVK1100/evk1100_revA.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -0,0 +1,324 @@
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief AT32UC3A EVK1100 board header file.
+ *
+ * This file contains definitions and services related to the features of the
+ * EVK1100 board rev. A.
+ *
+ * To use this board, define BOARD=EVK1100 and EVK1100_REVA.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 AT32UC3A devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _EVK1100_REVA_H_
+#define _EVK1100_REVA_H_
+
+#include &quot;compiler.h&quot;
+
+//#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+//#  include &quot;led.h&quot;
+//#endif  // __AVR32_ABI_COMPILER__
+
+
+/*! \name Oscillator Definitions
+ */
+//! @{
+
+// RCOsc has no custom calibration by default. Set the following definition to
+// the appropriate value if a custom RCOsc calibration has been applied to your
+// part.
+//#define FRCOSC          AVR32_PM_RCOSC_FREQUENCY              //!&lt; RCOsc frequency: Hz.
+
+#define FOSC32          32768                                 //!&lt; Osc32 frequency: Hz.
+#define OSC32_STARTUP   AVR32_PM_OSCCTRL32_STARTUP_8192_RCOSC //!&lt; Osc32 startup time: RCOsc periods.
+
+#define FOSC0           12000000                              //!&lt; Osc0 frequency: Hz.
+#define OSC0_STARTUP    AVR32_PM_OSCCTRL0_STARTUP_2048_RCOSC  //!&lt; Osc0 startup time: RCOsc periods.
+
+// Osc1 crystal is not mounted by default. Set the following definitions to the
+// appropriate values if a custom Osc1 crystal is mounted on your board.
+//#define FOSC1           12000000                              //!&lt; Osc1 frequency: Hz.
+//#define OSC1_STARTUP    AVR32_PM_OSCCTRL1_STARTUP_2048_RCOSC  //!&lt; Osc1 startup time: RCOsc periods.
+
+//! @}
+
+
+/*! \name SDRAM Definitions
+ */
+//! @{
+
+//! Part header file of used SDRAM(s).
+#define SDRAM_PART_HDR  &quot;MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h&quot;
+
+//! Data bus width to use the SDRAM(s) with (16 or 32 bits; always 16 bits on
+//! UC3).
+#define SDRAM_DBW       16
+
+//! @}
+
+
+/*! \name USB Definitions
+ */
+//! @{
+
+//! Multiplexed pin used for USB_ID: AVR32_USBB_USB_ID_x_x.
+//! To be selected according to the AVR32_USBB_USB_ID_x_x_PIN and
+//! AVR32_USBB_USB_ID_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
+#define USB_ID                      AVR32_USBB_USB_ID_0_0
+
+//! Multiplexed pin used for USB_VBOF: AVR32_USBB_USB_VBOF_x_x.
+//! To be selected according to the AVR32_USBB_USB_VBOF_x_x_PIN and
+//! AVR32_USBB_USB_VBOF_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
+#define USB_VBOF                    AVR32_USBB_USB_VBOF_0_0
+
+//! Active level of the USB_VBOF output pin.
+#define USB_VBOF_ACTIVE_LEVEL       HIGH
+
+//! USB overcurrent detection pin.
+#define USB_OVERCURRENT_DETECT_PIN  AVR32_PIN_PB18
+
+//! @}
+
+
+//! GPIO connection of the MAC PHY PWR_DOWN/INT signal.
+#define MACB_INTERRUPT_PIN  AVR32_PIN_PX12
+
+
+//! Number of LEDs.
+#define LED_COUNT   8
+
+/*! \name GPIO Connections of LEDs
+ */
+//! @{
+#define LED0_GPIO   AVR32_PIN_PX13
+#define LED1_GPIO   AVR32_PIN_PX14
+#define LED2_GPIO   AVR32_PIN_PX15
+#define LED3_GPIO   AVR32_PIN_PX16
+#define LED4_GPIO   AVR32_PIN_PB19
+#define LED5_GPIO   AVR32_PIN_PB20
+#define LED6_GPIO   AVR32_PIN_PB21
+#define LED7_GPIO   AVR32_PIN_PB22
+//! @}
+
+/*! \name PWM Channels of LEDs
+ */
+//! @{
+#define LED0_PWM    (-1)
+#define LED1_PWM    (-1)
+#define LED2_PWM    (-1)
+#define LED3_PWM    (-1)
+#define LED4_PWM      0
+#define LED5_PWM      1
+#define LED6_PWM      2
+#define LED7_PWM      3
+//! @}
+
+/*! \name PWM Functions of LEDs
+ */
+//! @{
+#define LED0_PWM_FUNCTION   (-1)
+#define LED1_PWM_FUNCTION   (-1)
+#define LED2_PWM_FUNCTION   (-1)
+#define LED3_PWM_FUNCTION   (-1)
+#define LED4_PWM_FUNCTION   AVR32_PWM_0_FUNCTION
+#define LED5_PWM_FUNCTION   AVR32_PWM_1_FUNCTION
+#define LED6_PWM_FUNCTION   AVR32_PWM_2_FUNCTION
+#define LED7_PWM_FUNCTION   AVR32_PWM_3_FUNCTION
+//! @}
+
+/*! \name Color Identifiers of LEDs to Use with LED Functions
+ */
+//! @{
+#define LED_MONO0_GREEN   LED4
+#define LED_MONO1_GREEN   LED5
+#define LED_MONO2_GREEN   LED6
+#define LED_MONO3_GREEN   LED7
+#define LED_BI0_GREEN     LED1
+#define LED_BI0_RED       LED0
+#define LED_BI1_GREEN     LED3
+#define LED_BI1_RED       LED2
+//! @}
+
+
+/*! \name GPIO Connections of Push Buttons
+ */
+//! @{
+#define GPIO_PUSH_BUTTON_0            AVR32_PIN_PB28
+#define GPIO_PUSH_BUTTON_0_PRESSED    0
+#define GPIO_PUSH_BUTTON_1            AVR32_PIN_PB29
+#define GPIO_PUSH_BUTTON_1_PRESSED    0
+#define GPIO_PUSH_BUTTON_2            AVR32_PIN_PB27
+#define GPIO_PUSH_BUTTON_2_PRESSED    0
+//! @}
+
+
+/*! \name GPIO Connections of the Joystick
+ */
+//! @{
+#define GPIO_JOYSTICK_PUSH            AVR32_PIN_PA20
+#define GPIO_JOYSTICK_PUSH_PRESSED    0
+#define GPIO_JOYSTICK_LEFT            AVR32_PIN_PA25
+#define GPIO_JOYSTICK_LEFT_PRESSED    0
+#define GPIO_JOYSTICK_RIGHT           AVR32_PIN_PA28
+#define GPIO_JOYSTICK_RIGHT_PRESSED   0
+#define GPIO_JOYSTICK_UP              AVR32_PIN_PA26
+#define GPIO_JOYSTICK_UP_PRESSED      0
+#define GPIO_JOYSTICK_DOWN            AVR32_PIN_PA27
+#define GPIO_JOYSTICK_DOWN_PRESSED    0
+//! @}
+
+
+/*! \name ADC Connection of the Potentiometer
+ */
+//! @{
+#define ADC_POTENTIOMETER_CHANNEL   1
+#define ADC_POTENTIOMETER_PIN       AVR32_ADC_AD_1_PIN
+#define ADC_POTENTIOMETER_FUNCTION  AVR32_ADC_AD_1_FUNCTION
+//! @}
+
+
+/*! \name ADC Connection of the Temperature Sensor
+ */
+//! @{
+#define ADC_TEMPERATURE_CHANNEL     0
+#define ADC_TEMPERATURE_PIN         AVR32_ADC_AD_0_PIN
+#define ADC_TEMPERATURE_FUNCTION    AVR32_ADC_AD_0_FUNCTION
+//! @}
+
+
+/*! \name ADC Connection of the Light Sensor
+ */
+//! @{
+#define ADC_LIGHT_CHANNEL           2
+#define ADC_LIGHT_PIN               AVR32_ADC_AD_2_PIN
+#define ADC_LIGHT_FUNCTION          AVR32_ADC_AD_2_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the DIP204 LCD
+ */
+//! @{
+#define DIP204_SPI                  (&amp;AVR32_SPI1)
+#define DIP204_SPI_NPCS             2
+#define DIP204_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
+#define DIP204_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
+#define DIP204_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
+#define DIP204_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
+#define DIP204_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
+#define DIP204_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
+#define DIP204_SPI_NPCS_PIN         AVR32_SPI1_NPCS_2_0_PIN
+#define DIP204_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_2_0_FUNCTION
+//! @}
+
+/*! \name GPIO and PWM Connections of the DIP204 LCD Backlight
+ */
+//! @{
+#define DIP204_BACKLIGHT_PIN        AVR32_PIN_PB18
+#define DIP204_PWM_CHANNEL          6
+#define DIP204_PWM_PIN              AVR32_PWM_6_PIN
+#define DIP204_PWM_FUNCTION         AVR32_PWM_6_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the AT45DBX Data Flash Memory
+ */
+//! @{
+#define AT45DBX_SPI                 (&amp;AVR32_SPI1)
+#define AT45DBX_SPI_NPCS            0
+#define AT45DBX_SPI_SCK_PIN         AVR32_SPI1_SCK_0_0_PIN
+#define AT45DBX_SPI_SCK_FUNCTION    AVR32_SPI1_SCK_0_0_FUNCTION
+#define AT45DBX_SPI_MISO_PIN        AVR32_SPI1_MISO_0_0_PIN
+#define AT45DBX_SPI_MISO_FUNCTION   AVR32_SPI1_MISO_0_0_FUNCTION
+#define AT45DBX_SPI_MOSI_PIN        AVR32_SPI1_MOSI_0_0_PIN
+#define AT45DBX_SPI_MOSI_FUNCTION   AVR32_SPI1_MOSI_0_0_FUNCTION
+#define AT45DBX_SPI_NPCS0_PIN       AVR32_SPI1_NPCS_0_0_PIN
+#define AT45DBX_SPI_NPCS0_FUNCTION  AVR32_SPI1_NPCS_0_0_FUNCTION
+//! @}
+
+
+/*! \name GPIO and SPI Connections of the SD/MMC Connector
+ */
+//! @{
+#define SD_MMC_CARD_DETECT_PIN      AVR32_PIN_PA02
+#define SD_MMC_WRITE_PROTECT_PIN    AVR32_PIN_PA07
+#define SD_MMC_SPI                  (&amp;AVR32_SPI1)
+#define SD_MMC_SPI_NPCS             1
+#define SD_MMC_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
+#define SD_MMC_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
+#define SD_MMC_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
+#define SD_MMC_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
+#define SD_MMC_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
+#define SD_MMC_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
+#define SD_MMC_SPI_NPCS_PIN         AVR32_SPI1_NPCS_1_0_PIN
+#define SD_MMC_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_1_0_FUNCTION
+//! @}
+
+
+/*! \name TWI Connections of the Spare TWI Connector
+ */
+//! @{
+#define SPARE_TWI                   (&amp;AVR32_TWI)
+#define SPARE_TWI_SCL_PIN           AVR32_TWI_SCL_0_0_PIN
+#define SPARE_TWI_SCL_FUNCTION      AVR32_TWI_SCL_0_0_FUNCTION
+#define SPARE_TWI_SDA_PIN           AVR32_TWI_SDA_0_0_PIN
+#define SPARE_TWI_SDA_FUNCTION      AVR32_TWI_SDA_0_0_FUNCTION
+//! @}
+
+
+/*! \name SPI Connections of the Spare SPI Connector
+ */
+//! @{
+#define SPARE_SPI                   (&amp;AVR32_SPI0)
+#define SPARE_SPI_NPCS              0
+#define SPARE_SPI_SCK_PIN           AVR32_SPI0_SCK_0_0_PIN
+#define SPARE_SPI_SCK_FUNCTION      AVR32_SPI0_SCK_0_0_FUNCTION
+#define SPARE_SPI_MISO_PIN          AVR32_SPI0_MISO_0_0_PIN
+#define SPARE_SPI_MISO_FUNCTION     AVR32_SPI0_MISO_0_0_FUNCTION
+#define SPARE_SPI_MOSI_PIN          AVR32_SPI0_MOSI_0_0_PIN
+#define SPARE_SPI_MOSI_FUNCTION     AVR32_SPI0_MOSI_0_0_FUNCTION
+#define SPARE_SPI_NPCS_PIN          AVR32_SPI0_NPCS_0_0_PIN
+#define SPARE_SPI_NPCS_FUNCTION     AVR32_SPI0_NPCS_0_0_FUNCTION
+//! @}
+
+
+#endif  // _EVK1100_REVA_H_

Added: trunk/src/platform/avr32/MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h
===================================================================
--- trunk/src/platform/avr32/MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -0,0 +1,120 @@
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief MT48LC16M16A2TG-7E SDRAM driver for AVR32 UC3 SDRAMC on EBI.
+ *
+ * \note The values defined in this file are device-specific. See the device
+ *       datasheet for further information.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _MT48LC16M16A2TG7E_H_
+#define _MT48LC16M16A2TG7E_H_
+
+
+//! The number of bank bits for this SDRAM (1 or 2).
+#define SDRAM_BANK_BITS                 2
+
+//! The number of row bits for this SDRAM (11 to 13).
+#define SDRAM_ROW_BITS                  13
+
+//! The number of column bits for this SDRAM (8 to 11).
+#define SDRAM_COL_BITS                  9
+
+//! The minimal column address select (READ) latency for this SDRAM (1 to 3 SDRAM cycles).
+//! Unit: tCK (SDRAM cycle period).
+#define SDRAM_CAS                       2
+
+//! The minimal write recovery time for this SDRAM (0 to 15 SDRAM cycles).
+//! Unit: ns.
+#define SDRAM_TWR                       14
+
+//! The minimal row cycle time for this SDRAM (0 to 15 SDRAM cycles).
+//! ACTIVE-to-ACTIVE command delay.
+//! Unit: ns.
+#define SDRAM_TRC                       60
+
+//! The minimal row precharge time for this SDRAM (0 to 15 SDRAM cycles).
+//! PRECHARGE command period.
+//! Unit: ns.
+#define SDRAM_TRP                       15
+
+//! The minimal row to column delay time for this SDRAM (0 to 15 SDRAM cycles).
+//! ACTIVE-to-READ/WRITE command delay.
+//! Unit: ns.
+#define SDRAM_TRCD                      15
+
+//! The minimal row address select time for this SDRAM (0 to 15 SDRAM cycles).
+//! ACTIVE-to-PRECHARGE command delay.
+//! Unit: ns.
+#define SDRAM_TRAS                      37
+
+//! The minimal exit self refresh time for this SDRAM (0 to 15 SDRAM cycles).
+//! Exit SELF REFRESH to ACTIVE command delay.
+//! Unit: ns.
+#define SDRAM_TXSR                      67
+
+//! The maximal refresh time for this SDRAM (0 to 4095 SDRAM cycles).
+//! Refresh period.
+//! Unit: ns.
+#define SDRAM_TR                        7812
+
+//! The minimal refresh cycle time for this SDRAM.
+//! AUTO REFRESH command period.
+//! Unit: ns.
+#define SDRAM_TRFC                      66
+
+//! The minimal mode register delay time for this SDRAM.
+//! LOAD MODE REGISTER command to ACTIVE or REFRESH command delay.
+//! Unit: tCK (SDRAM cycle period).
+#define SDRAM_TMRD                      2
+
+//! The minimal stable-clock initialization delay for this SDRAM.
+//! Unit: us.
+#define SDRAM_STABLE_CLOCK_INIT_DELAY   100
+
+//! The minimal number of AUTO REFRESH commands required during initialization for this SDRAM.
+#define SDRAM_INIT_AUTO_REFRESH_COUNT   2
+
+
+#endif  // _MT48LC16M16A2TG7E_H_

Modified: trunk/src/platform/avr32/board.h
===================================================================
--- trunk/src/platform/avr32/board.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/board.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,77 +1,120 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Standard board header file.
- *
- * This file includes the appropriate board header file according to the
- * defined board.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _BOARD_H_
-#define _BOARD_H_
-
-#include &lt;avr32/io.h&gt;
-
-/*! \name Base Boards
- */
-//! @{
-#define EVK1100           1   //!&lt; AT32UC3A EVK1100 board.
-#define EVK1101           2   //!&lt; AT32UC3B EVK1101 board.
-#define STK1000           3   //!&lt; AT32AP7000 STK1000 board.
-#define NGW100            4   //!&lt; AT32AP7000 NGW100 board.
-#define USER_BOARD        99  //!&lt; User-reserved board (if any).
-//! @}
-
-/*! \name Extension Boards
- */
-//! @{
-#define EXT1102           1   //!&lt; AT32UC3B EXT1102 board.
-#define MC300             2   //!&lt; AT32UC3 MC300 board.
-#define USER_EXT_BOARD    99  //!&lt; User-reserved extension board (if any).
-//! @}
-
-#include &quot;evk1100.h&quot;
-
-#ifndef FRCOSC
-  #define FRCOSC    AVR32_PM_RCOSC_FREQUENCY  //!&lt; Default RCOsc frequency.
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Standard board header file.
+ *
+ * This file includes the appropriate board header file according to the
+ * defined board.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+#include &lt;avr32/io.h&gt;
+
+/*! \name Base Boards
+ */
+//! @{
+#define EVK1100           1   //!&lt; AT32UC3A EVK1100 board.
+#define EVK1101           2   //!&lt; AT32UC3B EVK1101 board.
+#define UC3C_EK           3   //!&lt; AT32UC3C UC3C_EK board.
+#define EVK1104           4   //!&lt; AT32UC3A3 EVK1104 board.
+#define EVK1105           5   //!&lt; AT32UC3A EVK1105 board.
+#define STK1000           6   //!&lt; AT32AP7000 STK1000 board.
+#define NGW100            7   //!&lt; AT32AP7000 NGW100 board.
+#define STK600_RCUC3L0    8   //!&lt; STK600 RCUC3L0 board.
+#define UC3L_EK           9   //!&lt; AT32UC3L-EK board.
+#define USER_BOARD        99  //!&lt; User-reserved board (if any).
+//! @}
+
+/*! \name Extension Boards
+ */
+//! @{
+#define EXT1102           1   //!&lt; AT32UC3B EXT1102 board.
+#define MC300             2   //!&lt; AT32UC3 MC300 board.
+#define USER_EXT_BOARD    99  //!&lt; User-reserved extension board (if any).
+//! @}
+
+#if BOARD == EVK1100
+  #include &quot;EVK1100/evk1100.h&quot;
+#elif BOARD == EVK1101
+  #include &quot;EVK1101/evk1101.h&quot;
+#elif BOARD == UC3C_EK
+  #include &quot;UC3C_EK/uc3c_ek.h&quot;
+#elif BOARD == EVK1104
+  #include &quot;EVK1104/evk1104.h&quot;
+#elif BOARD == EVK1105
+  #include &quot;EVK1105/evk1105.h&quot;
+#elif BOARD == STK1000
+  #include &quot;STK1000/stk1000.h&quot;
+#elif BOARD == NGW100
+  #include &quot;NGW100/ngw100.h&quot;
+#elif BOARD == STK600_RCUC3L0
+  #include &quot;STK600/RCUC3L0/stk600_rcuc3l0.h&quot;
+#elif BOARD == UC3L_EK
+  #include &quot;UC3L_EK/uc3l_ek.h&quot;
+#elif BOARD == USER_BOARD
+  // User-reserved area: #include the header file of your board here (if any).
+  #include &quot;user_board.h&quot;
+#else
+  #error No known AVR32 board defined
+#endif
+
+#if (defined EXT_BOARD)
+  #if EXT_BOARD == EXT1102
+    #include &quot;EXT1102/ext1102.h&quot;
+  #elif EXT_BOARD == MC300
+    #include &quot;MC300/mc300.h&quot;
+  #elif EXT_BOARD == USER_EXT_BOARD
+    // User-reserved area: #include the header file of your extension board here
+    // (if any).
+  #endif
+#endif
+
+
+#ifndef FRCOSC
+  #define FRCOSC    AVR32_PM_RCOSC_FREQUENCY  //!&lt; Default RCOsc frequency.
 #endif
 
 #define REQ_CPU_FREQ      60000000

Modified: trunk/src/platform/avr32/compiler.h
===================================================================
--- trunk/src/platform/avr32/compiler.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/compiler.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,1112 +1,1143 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Compiler file for AVR32.
- *
- * This file defines commonly used types and macros.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _COMPILER_H_
-#define _COMPILER_H_
-
-#if (__GNUC__ &amp;&amp; __AVR32__) || (__ICCAVR32__ || __AAVR32__)
-#  include &lt;avr32/io.h&gt;
-#endif
-#if __ICCAVR32__
-#  include &lt;intrinsics.h&gt;
-#endif
-#include &quot;preprocessor.h&quot;
-
-
-//_____ D E C L A R A T I O N S ____________________________________________
-
-#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
-
-#include &lt;stddef.h&gt;
-#include &lt;stdlib.h&gt;
-
-
-#if __ICCAVR32__
-
-/*! \name Compiler Keywords
- *
- * Port of some keywords from GNU GCC for AVR32 to IAR Embedded Workbench for Atmel AVR32.
- */
-//! @{
-#define __asm__             asm
-#define __inline__          inline
-#define __volatile__
-//! @}
-
-#endif
-
-
-/*! \name Usual Types
- */
-//! @{
-typedef unsigned char           Bool; //!&lt; Boolean.
-typedef signed char             S8 ;  //!&lt; 8-bit signed integer.
-typedef unsigned char           U8 ;  //!&lt; 8-bit unsigned integer.
-typedef signed short int        S16;  //!&lt; 16-bit signed integer.
-typedef unsigned short int      U16;  //!&lt; 16-bit unsigned integer.
-typedef signed long int         S32;  //!&lt; 32-bit signed integer.
-typedef unsigned long int       U32;  //!&lt; 32-bit unsigned integer.
-typedef signed long long int    S64;  //!&lt; 64-bit signed integer.
-typedef unsigned long long int  U64;  //!&lt; 64-bit unsigned integer.
-typedef float                   F32;  //!&lt; 32-bit floating-point number.
-typedef double                  F64;  //!&lt; 64-bit floating-point number.
-//! @}
-
-
-/*! \name Status Types
- */
-//! @{
-typedef Bool                Status_bool_t;  //!&lt; Boolean status.
-typedef U8                  Status_t;       //!&lt; 8-bit-coded status.
-//! @}
-
-
-/*! \name Aliasing Aggregate Types
- */
-//! @{
-
-//! 16-bit union.
-typedef union
-{
-  S16 s16   ;
-  U16 u16   ;
-  S8  s8 [2];
-  U8  u8 [2];
-} Union16;
-
-//! 32-bit union.
-typedef union
-{
-  S32 s32   ;
-  U32 u32   ;
-  S16 s16[2];
-  U16 u16[2];
-  S8  s8 [4];
-  U8  u8 [4];
-} Union32;
-
-//! 64-bit union.
-typedef union
-{
-  S64 s64   ;
-  U64 u64   ;
-  S32 s32[2];
-  U32 u32[2];
-  S16 s16[4];
-  U16 u16[4];
-  S8  s8 [8];
-  U8  u8 [8];
-} Union64;
-
-//! Union of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  S64 *s64ptr;
-  U64 *u64ptr;
-  S32 *s32ptr;
-  U32 *u32ptr;
-  S16 *s16ptr;
-  U16 *u16ptr;
-  S8  *s8ptr ;
-  U8  *u8ptr ;
-} UnionPtr;
-
-//! Union of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  volatile S64 *s64ptr;
-  volatile U64 *u64ptr;
-  volatile S32 *s32ptr;
-  volatile U32 *u32ptr;
-  volatile S16 *s16ptr;
-  volatile U16 *u16ptr;
-  volatile S8  *s8ptr ;
-  volatile U8  *u8ptr ;
-} UnionVPtr;
-
-//! Union of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  const S64 *s64ptr;
-  const U64 *u64ptr;
-  const S32 *s32ptr;
-  const U32 *u32ptr;
-  const S16 *s16ptr;
-  const U16 *u16ptr;
-  const S8  *s8ptr ;
-  const U8  *u8ptr ;
-} UnionCPtr;
-
-//! Union of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef union
-{
-  const volatile S64 *s64ptr;
-  const volatile U64 *u64ptr;
-  const volatile S32 *s32ptr;
-  const volatile U32 *u32ptr;
-  const volatile S16 *s16ptr;
-  const volatile U16 *u16ptr;
-  const volatile S8  *s8ptr ;
-  const volatile U8  *u8ptr ;
-} UnionCVPtr;
-
-//! Structure of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  S64 *s64ptr;
-  U64 *u64ptr;
-  S32 *s32ptr;
-  U32 *u32ptr;
-  S16 *s16ptr;
-  U16 *u16ptr;
-  S8  *s8ptr ;
-  U8  *u8ptr ;
-} StructPtr;
-
-//! Structure of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  volatile S64 *s64ptr;
-  volatile U64 *u64ptr;
-  volatile S32 *s32ptr;
-  volatile U32 *u32ptr;
-  volatile S16 *s16ptr;
-  volatile U16 *u16ptr;
-  volatile S8  *s8ptr ;
-  volatile U8  *u8ptr ;
-} StructVPtr;
-
-//! Structure of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  const S64 *s64ptr;
-  const U64 *u64ptr;
-  const S32 *s32ptr;
-  const U32 *u32ptr;
-  const S16 *s16ptr;
-  const U16 *u16ptr;
-  const S8  *s8ptr ;
-  const U8  *u8ptr ;
-} StructCPtr;
-
-//! Structure of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
-typedef struct
-{
-  const volatile S64 *s64ptr;
-  const volatile U64 *u64ptr;
-  const volatile S32 *s32ptr;
-  const volatile U32 *u32ptr;
-  const volatile S16 *s16ptr;
-  const volatile U16 *u16ptr;
-  const volatile S8  *s8ptr ;
-  const volatile U8  *u8ptr ;
-} StructCVPtr;
-
-//! @}
-
-#endif  // __AVR32_ABI_COMPILER__
-
-
-//_____ M A C R O S ________________________________________________________
-
-/*! \name Usual Constants
- */
-//! @{
-#define DISABLE   0
-#define ENABLE    1
-#define DISABLED  0
-#define ENABLED   1
-#define OFF       0
-#define ON        1
-#define FALSE     0
-#define TRUE      1
-#define KO        0
-#define OK        1
-#define PASS      0
-#define FAIL      1
-#define LOW       0
-#define HIGH      1
-#define CLR       0
-#define SET       1
-//! @}
-
-
-#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
-
-/*! \name Bit-Field Handling
- */
-//! @{
-
-/*! \brief Reads the bits of a value specified by a given bit-mask.
- *
- * \param value Value to read bits from.
- * \param mask  Bit-mask indicating bits to read.
- *
- * \return Read bits.
- */
-#define Rd_bits( value, mask)        ((value) &amp; (mask))
-
-/*! \brief Writes the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue to write bits to.
- * \param mask    Bit-mask indicating bits to write.
- * \param bits    Bits to write.
- *
- * \return Resulting value with written bits.
- */
-#define Wr_bits(lvalue, mask, bits)  ((lvalue) = ((lvalue) &amp; ~(mask)) |\
-                                                 ((bits  ) &amp;  (mask)))
-
-/*! \brief Tests the bits of a value specified by a given bit-mask.
- *
- * \param value Value of which to test bits.
- * \param mask  Bit-mask indicating bits to test.
- *
- * \return \c 1 if at least one of the tested bits is set, else \c 0.
- */
-#define Tst_bits( value, mask)  (Rd_bits(value, mask) != 0)
-
-/*! \brief Clears the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue of which to clear bits.
- * \param mask    Bit-mask indicating bits to clear.
- *
- * \return Resulting value with cleared bits.
- */
-#define Clr_bits(lvalue, mask)  ((lvalue) &amp;= ~(mask))
-
-/*! \brief Sets the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue of which to set bits.
- * \param mask    Bit-mask indicating bits to set.
- *
- * \return Resulting value with set bits.
- */
-#define Set_bits(lvalue, mask)  ((lvalue) |=  (mask))
-
-/*! \brief Toggles the bits of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue  C lvalue of which to toggle bits.
- * \param mask    Bit-mask indicating bits to toggle.
- *
- * \return Resulting value with toggled bits.
- */
-#define Tgl_bits(lvalue, mask)  ((lvalue) ^=  (mask))
-
-/*! \brief Reads the bit-field of a value specified by a given bit-mask.
- *
- * \param value Value to read a bit-field from.
- * \param mask  Bit-mask indicating the bit-field to read.
- *
- * \return Read bit-field.
- */
-#define Rd_bitfield( value, mask)           (Rd_bits( value, mask) &gt;&gt; ctz(mask))
-
-/*! \brief Writes the bit-field of a C lvalue specified by a given bit-mask.
- *
- * \param lvalue    C lvalue to write a bit-field to.
- * \param mask      Bit-mask indicating the bit-field to write.
- * \param bitfield  Bit-field to write.
- *
- * \return Resulting value with written bit-field.
- */
-#define Wr_bitfield(lvalue, mask, bitfield) (Wr_bits(lvalue, mask, (U32)(bitfield) &lt;&lt; ctz(mask)))
-
-//! @}
-
-
-/*! \brief This macro is used to test fatal errors.
- *
- * The macro tests if the expression is FALSE. If it is, a fatal error is
- * detected and the application hangs up.
- *
- * \param expr  Expression to evaluate and supposed to be nonzero.
- */
-#ifdef _ASSERT_ENABLE_
-  #define Assert(expr) \
-  {\
-    if (!(expr)) while (TRUE);\
-  }
-#else
-  #define Assert(expr)
-#endif
-
-
-/*! \name Zero-Bit Counting
- *
- * Under AVR32-GCC, __builtin_clz and __builtin_ctz behave like macros when
- * applied to constant expressions (values known at compile time), so they are
- * more optimized than the use of the corresponding assembly instructions and
- * they can be used as constant expressions e.g. to initialize objects having
- * static storage duration, and like the corresponding assembly instructions
- * when applied to non-constant expressions (values unknown at compile time), so
- * they are more optimized than an assembly periphrasis. Hence, clz and ctz
- * ensure a possible and optimized behavior for both constant and non-constant
- * expressions.
- */
-//! @{
-
-/*! \brief Counts the leading zero bits of the given value considered as a 32-bit integer.
- *
- * \param u Value of which to count the leading zero bits.
- *
- * \return The count of leading zero bits in \a u.
- */
-#if __GNUC__
-  #define clz(u)              __builtin_clz(u)
-#elif __ICCAVR32__
-  #define clz(u)              __count_leading_zeros(u)
-#endif
-
-/*! \brief Counts the trailing zero bits of the given value considered as a 32-bit integer.
- *
- * \param u Value of which to count the trailing zero bits.
- *
- * \return The count of trailing zero bits in \a u.
- */
-#if __GNUC__
-  #define ctz(u)              __builtin_ctz(u)
-#elif __ICCAVR32__
-  #define ctz(u)              __count_trailing_zeros(u)
-#endif
-
-//! @}
-
-
-/*! \name Bit Reversing
- */
-//! @{
-
-/*! \brief Reverses the bits of \a u8.
- *
- * \param u8  U8 of which to reverse the bits.
- *
- * \return Value resulting from \a u8 with reversed bits.
- */
-#define bit_reverse8(u8)    ((U8)(bit_reverse32((U8)(u8)) &gt;&gt; 24))
-
-/*! \brief Reverses the bits of \a u16.
- *
- * \param u16 U16 of which to reverse the bits.
- *
- * \return Value resulting from \a u16 with reversed bits.
- */
-#define bit_reverse16(u16)  ((U16)(bit_reverse32((U16)(u16)) &gt;&gt; 16))
-
-/*! \brief Reverses the bits of \a u32.
- *
- * \param u32 U32 of which to reverse the bits.
- *
- * \return Value resulting from \a u32 with reversed bits.
- */
-#if __GNUC__
-  #define bit_reverse32(u32) \
-  (\
-    {\
-      unsigned int __value = (U32)(u32);\
-      __asm__ (&quot;brev\t%0&quot; : &quot;+r&quot; (__value) :  : &quot;cc&quot;);\
-      (U32)__value;\
-    }\
-  )
-#elif __ICCAVR32__
-  #define bit_reverse32(u32)  ((U32)__bit_reverse((U32)(u32)))
-#endif
-
-/*! \brief Reverses the bits of \a u64.
- *
- * \param u64 U64 of which to reverse the bits.
- *
- * \return Value resulting from \a u64 with reversed bits.
- */
-#define bit_reverse64(u64)  ((U64)(((U64)bit_reverse32((U64)(u64) &gt;&gt; 32)) |\
-                                   ((U64)bit_reverse32((U64)(u64)) &lt;&lt; 32)))
-
-//! @}
-
-
-/*! \name Alignment
- */
-//! @{
-
-/*! \brief Tests alignment of the number \a val with the \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return \c 1 if the number \a val is aligned with the \a n boundary, else \c 0.
- */
-#define Test_align(val, n     ) (!Tst_bits( val, (n) - 1     )   )
-
-/*! \brief Gets alignment of the number \a val with respect to the \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return Alignment of the number \a val with respect to the \a n boundary.
- */
-#define Get_align( val, n     ) (  Rd_bits( val, (n) - 1     )   )
-
-/*! \brief Sets alignment of the lvalue number \a lval to \a alg with respect to the \a n boundary.
- *
- * \param lval  Input/output lvalue.
- * \param n     Boundary.
- * \param alg   Alignment.
- *
- * \return New value of \a lval resulting from its alignment set to \a alg with respect to the \a n boundary.
- */
-#define Set_align(lval, n, alg) (  Wr_bits(lval, (n) - 1, alg)   )
-
-/*! \brief Aligns the number \a val with the upper \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return Value resulting from the number \a val aligned with the upper \a n boundary.
- */
-#define Align_up(  val, n     ) (((val) + ((n) - 1)) &amp; ~((n) - 1))
-
-/*! \brief Aligns the number \a val with the lower \a n boundary.
- *
- * \param val Input value.
- * \param n   Boundary.
- *
- * \return Value resulting from the number \a val aligned with the lower \a n boundary.
- */
-#define Align_down(val, n     ) ( (val)              &amp; ~((n) - 1))
-
-//! @}
-
-
-/*! \name Mathematics
- *
- * The same considerations as for clz and ctz apply here but AVR32-GCC does not
- * provide built-in functions to access the assembly instructions abs, min and
- * max and it does not produce them by itself in most cases, so two sets of
- * macros are defined here:
- *   - Abs, Min and Max to apply to constant expressions (values known at
- *     compile time);
- *   - abs, min and max to apply to non-constant expressions (values unknown at
- *     compile time).
- */
-//! @{
-
-/*! \brief Takes the absolute value of \a a.
- *
- * \param a Input value.
- *
- * \return Absolute value of \a a.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Abs(a)              (((a) &lt;  0 ) ? -(a) : (a))
-
-/*! \brief Takes the minimal value of \a a and \a b.
- *
- * \param a Input value.
- * \param b Input value.
- *
- * \return Minimal value of \a a and \a b.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Min(a, b)           (((a) &lt; (b)) ?  (a) : (b))
-
-/*! \brief Takes the maximal value of \a a and \a b.
- *
- * \param a Input value.
- * \param b Input value.
- *
- * \return Maximal value of \a a and \a b.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Max(a, b)           (((a) &gt; (b)) ?  (a) : (b))
-
-/*! \brief Takes the absolute value of \a a.
- *
- * \param a Input value.
- *
- * \return Absolute value of \a a.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#if __GNUC__
-  #define abs(a) \
-  (\
-    {\
-      int __value = (a);\
-      __asm__ (&quot;abs\t%0&quot; : &quot;+r&quot; (__value) :  : &quot;cc&quot;);\
-      __value;\
-    }\
-  )
-#elif __ICCAVR32__
-  #define abs(a)      Abs(a)
-#endif
-
-/*! \brief Takes the minimal value of \a a and \a b.
- *
- * \param a Input value.
- * \param b Input value.
- *
- * \return Minimal value of \a a and \a b.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#if __GNUC__
-  #define min(a, b) \
-  (\
-    {\
-      int __value, __arg_a = (a), __arg_b = (b);\
-      __asm__ (&quot;min\t%0, %1, %2&quot; : &quot;=r&quot; (__value) : &quot;r&quot; (__arg_a), &quot;r&quot; (__arg_b));\
-      __value;\
-    }\
-  )
-#elif __ICCAVR32__
-  #define min(a, b)   __min(a, b)
-#endif
-
-/*! \brief Takes the maximal value of \a a and \a b.
- *
- * \param a Input value.
- * \param b Input value.
- *
- * \return Maximal value of \a a and \a b.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#if __GNUC__
-  #define max(a, b) \
-  (\
-    {\
-      int __value, __arg_a = (a), __arg_b = (b);\
-      __asm__ (&quot;max\t%0, %1, %2&quot; : &quot;=r&quot; (__value) : &quot;r&quot; (__arg_a), &quot;r&quot; (__arg_b));\
-      __value;\
-    }\
-  )
-#elif __ICCAVR32__
-  #define max(a, b)   __max(a, b)
-#endif
-
-//! @}
-
-
-/*! \brief Calls the routine at address \a addr.
- *
- * It generates a long call opcode.
- *
- * For example, `Long_call(0x80000000)' generates a software reset on a UC3 if
- * it is invoked from the CPU supervisor mode.
- *
- * \param addr  Address of the routine to call.
- *
- * \note It may be used as a long jump opcode in some special cases.
- */
-#define Long_call(addr)                   ((*(void (*)(void))(addr))())
-
-/*! \brief Resets the CPU by software.
- *
- * \warning It shall not be called from the CPU application mode.
- */
-#if __GNUC__
-  #define Reset_CPU() \
-  (\
-    {\
-      __asm__ __volatile__ (\
-        &quot;lddpc   r9, 3f\n\t&quot;\
-        &quot;mfsr    r8, %[SR]\n\t&quot;\
-        &quot;bfextu  r8, r8, %[SR_MX_OFFSET], %[SR_MX_SIZE]\n\t&quot;\
-        &quot;cp.w    r8, 0b001\n\t&quot;\
-        &quot;breq    0f\n\t&quot;\
-        &quot;sub     r8, pc, $ - 1f\n\t&quot;\
-        &quot;pushm   r8-r9\n\t&quot;\
-        &quot;rete\n&quot;\
-        &quot;0:\n\t&quot;\
-        &quot;mtsr    %[SR], r9\n&quot;\
-        &quot;1:\n\t&quot;\
-        &quot;mov     r0, 0\n\t&quot;\
-        &quot;mov     r1, 0\n\t&quot;\
-        &quot;mov     r2, 0\n\t&quot;\
-        &quot;mov     r3, 0\n\t&quot;\
-        &quot;mov     r4, 0\n\t&quot;\
-        &quot;mov     r5, 0\n\t&quot;\
-        &quot;mov     r6, 0\n\t&quot;\
-        &quot;mov     r7, 0\n\t&quot;\
-        &quot;mov     r8, 0\n\t&quot;\
-        &quot;mov     r9, 0\n\t&quot;\
-        &quot;mov     r10, 0\n\t&quot;\
-        &quot;mov     r11, 0\n\t&quot;\
-        &quot;mov     r12, 0\n\t&quot;\
-        &quot;mov     sp, 0\n\t&quot;\
-        &quot;stdsp   sp[0], sp\n\t&quot;\
-        &quot;ldmts   sp, sp\n\t&quot;\
-        &quot;mov     lr, 0\n\t&quot;\
-        &quot;lddpc   pc, 2f\n\t&quot;\
-        &quot;.balign 4\n&quot;\
-        &quot;2:\n\t&quot;\
-        &quot;.word   _start\n&quot;\
-        &quot;3:\n\t&quot;\
-        &quot;.word   %[RESET_SR]&quot;\
-        :\
-        : [SR] &quot;i&quot; (AVR32_SR),\
-          [SR_MX_OFFSET] &quot;i&quot; (AVR32_SR_M0_OFFSET),\
-          [SR_MX_SIZE] &quot;i&quot; (AVR32_SR_M0_SIZE + AVR32_SR_M1_SIZE + AVR32_SR_M2_SIZE),\
-          [RESET_SR] &quot;i&quot; (AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | AVR32_SR_M0_MASK)\
-      );\
-    }\
-  )
-#elif __ICCAVR32__
-  #define Reset_CPU() \
-  {\
-    extern void *volatile __program_start;\
-    __asm__ __volatile__ (\
-      &quot;mov     r7, LWRD(__program_start)\n\t&quot;\
-      &quot;orh     r7, HWRD(__program_start)\n\t&quot;\
-      &quot;mov     r9, LWRD(&quot;ASTRINGZ(AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | AVR32_SR_M0_MASK)&quot;)\n\t&quot;\
-      &quot;orh     r9, HWRD(&quot;ASTRINGZ(AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | AVR32_SR_M0_MASK)&quot;)\n\t&quot;\
-      &quot;mfsr    r8, &quot;ASTRINGZ(AVR32_SR)&quot;\n\t&quot;\
-      &quot;bfextu  r8, r8, &quot;ASTRINGZ(AVR32_SR_M0_OFFSET)&quot;, &quot;ASTRINGZ(AVR32_SR_M0_SIZE + AVR32_SR_M1_SIZE + AVR32_SR_M2_SIZE)&quot;\n\t&quot;\
-      &quot;cp.w    r8, 001b\n\t&quot;\
-      &quot;breq    $ + 10\n\t&quot;\
-      &quot;sub     r8, pc, -12\n\t&quot;\
-      &quot;pushm   r8-r9\n\t&quot;\
-      &quot;rete\n\t&quot;\
-      &quot;mtsr    &quot;ASTRINGZ(AVR32_SR)&quot;, r9\n\t&quot;\
-      &quot;mov     r0, 0\n\t&quot;\
-      &quot;mov     r1, 0\n\t&quot;\
-      &quot;mov     r2, 0\n\t&quot;\
-      &quot;mov     r3, 0\n\t&quot;\
-      &quot;mov     r4, 0\n\t&quot;\
-      &quot;mov     r5, 0\n\t&quot;\
-      &quot;mov     r6, 0\n\t&quot;\
-      &quot;st.w    r0[4], r7\n\t&quot;\
-      &quot;mov     r7, 0\n\t&quot;\
-      &quot;mov     r8, 0\n\t&quot;\
-      &quot;mov     r9, 0\n\t&quot;\
-      &quot;mov     r10, 0\n\t&quot;\
-      &quot;mov     r11, 0\n\t&quot;\
-      &quot;mov     r12, 0\n\t&quot;\
-      &quot;mov     sp, 0\n\t&quot;\
-      &quot;stdsp   sp[0], sp\n\t&quot;\
-      &quot;ldmts   sp, sp\n\t&quot;\
-      &quot;mov     lr, 0\n\t&quot;\
-      &quot;ld.w    pc, lr[4]&quot;\
-    );\
-    __program_start;\
-  }
-#endif
-
-
-/*! \name System Register Access
- */
-//! @{
-
-/*! \brief Gets the value of the \a sysreg system register.
- *
- * \param sysreg  Address of the system register of which to get the value.
- *
- * \return Value of the \a sysreg system register.
- */
-#if __GNUC__
-  #define Get_system_register(sysreg)         __builtin_mfsr(sysreg)
-#elif __ICCAVR32__
-  #define Get_system_register(sysreg)         __get_system_register(sysreg)
-#endif
-
-/*! \brief Sets the value of the \a sysreg system register to \a value.
- *
- * \param sysreg  Address of the system register of which to set the value.
- * \param value   Value to set the \a sysreg system register to.
- */
-#if __GNUC__
-  #define Set_system_register(sysreg, value)  __builtin_mtsr(sysreg, value)
-#elif __ICCAVR32__
-  #define Set_system_register(sysreg, value)  __set_system_register(sysreg, value)
-#endif
-
-//! @}
-
-
-/*! \name CPU Status Register Access
- */
-//! @{
-
-/*! \brief Tells whether exceptions are globally enabled.
- *
- * \return \c 1 if exceptions are globally enabled, else \c 0.
- */
-#define Is_global_exception_enabled()       (!Tst_bits(Get_system_register(AVR32_SR), AVR32_SR_EM_MASK))
-
-/*! \brief Disables exceptions globally.
- */
-#if __GNUC__
-  #define Disable_global_exception()        ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_EM_OFFSET));})
-#elif __ICCAVR32__
-  #define Disable_global_exception()        (__set_status_flag(AVR32_SR_EM_OFFSET))
-#endif
-
-/*! \brief Enables exceptions globally.
- */
-#if __GNUC__
-  #define Enable_global_exception()         ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_EM_OFFSET));})
-#elif __ICCAVR32__
-  #define Enable_global_exception()         (__clear_status_flag(AVR32_SR_EM_OFFSET))
-#endif
-
-/*! \brief Tells whether interrupts are globally enabled.
- *
- * \return \c 1 if interrupts are globally enabled, else \c 0.
- */
-#define Is_global_interrupt_enabled()       (!Tst_bits(Get_system_register(AVR32_SR), AVR32_SR_GM_MASK))
-
-/*! \brief Disables interrupts globally.
- */
-#if __GNUC__
-  #define Disable_global_interrupt()        ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_GM_OFFSET));})
-#elif __ICCAVR32__
-  #define Disable_global_interrupt()        (__disable_interrupt())
-#endif
-
-/*! \brief Enables interrupts globally.
- */
-#if __GNUC__
-  #define Enable_global_interrupt()         ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_GM_OFFSET));})
-#elif __ICCAVR32__
-  #define Enable_global_interrupt()         (__enable_interrupt())
-#endif
-
-/*! \brief Tells whether interrupt level \a int_lev is enabled.
- *
- * \param int_lev Interrupt level (0 to 3).
- *
- * \return \c 1 if interrupt level \a int_lev is enabled, else \c 0.
- */
-#define Is_interrupt_level_enabled(int_lev) (!Tst_bits(Get_system_register(AVR32_SR), TPASTE3(AVR32_SR_I, int_lev, M_MASK)))
-
-/*! \brief Disables interrupt level \a int_lev.
- *
- * \param int_lev Interrupt level to disable (0 to 3).
- */
-#if __GNUC__
-  #define Disable_interrupt_level(int_lev)  ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)));})
-#elif __ICCAVR32__
-  #define Disable_interrupt_level(int_lev)  (__set_status_flag(TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)))
-#endif
-
-/*! \brief Enables interrupt level \a int_lev.
- *
- * \param int_lev Interrupt level to enable (0 to 3).
- */
-#if __GNUC__
-  #define Enable_interrupt_level(int_lev)   ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)));})
-#elif __ICCAVR32__
-  #define Enable_interrupt_level(int_lev)   (__clear_status_flag(TPASTE3(AVR32_SR_I, int_lev, M_OFFSET)))
-#endif
-
-//! @}
-
-
-/*! \name Debug Register Access
- */
-//! @{
-
-/*! \brief Gets the value of the \a dbgreg debug register.
- *
- * \param dbgreg  Address of the debug register of which to get the value.
- *
- * \return Value of the \a dbgreg debug register.
- */
-#if __GNUC__
-  #define Get_debug_register(dbgreg)          __builtin_mfdr(dbgreg)
-#elif __ICCAVR32__
-  #define Get_debug_register(dbgreg)          __get_debug_register(dbgreg)
-#endif
-
-/*! \brief Sets the value of the \a dbgreg debug register to \a value.
- *
- * \param dbgreg  Address of the debug register of which to set the value.
- * \param value   Value to set the \a dbgreg debug register to.
- */
-#if __GNUC__
-  #define Set_debug_register(dbgreg, value)   __builtin_mtdr(dbgreg, value)
-#elif __ICCAVR32__
-  #define Set_debug_register(dbgreg, value)   __set_debug_register(dbgreg, value)
-#endif
-
-//! @}
-
-#endif  // __AVR32_ABI_COMPILER__
-
-
-//! Boolean evaluating MCU little endianism.
-#if (__GNUC__ &amp;&amp; __AVR32__) || (__ICCAVR32__ || __AAVR32__)
-  #define LITTLE_ENDIAN_MCU     FALSE
-#endif
-
-// Check that MCU endianism is correctly defined.
-#ifndef LITTLE_ENDIAN_MCU
-  #error YOU MUST define the MCU endianism with LITTLE_ENDIAN_MCU: either FALSE or TRUE
-#endif
-
-//! Boolean evaluating MCU big endianism.
-#define BIG_ENDIAN_MCU        (!LITTLE_ENDIAN_MCU)
-
-
-#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
-
-/*! \name MCU Endianism Handling
- */
-//! @{
-
-#if LITTLE_ENDIAN_MCU
-
-  #define LSB(u16)        (((U8  *)&amp;(u16))[0])  //!&lt; Least significant byte of \a u16.
-  #define MSB(u16)        (((U8  *)&amp;(u16))[1])  //!&lt; Most significant byte of \a u16.
-
-  #define LSH(u32)        (((U16 *)&amp;(u32))[0])  //!&lt; Least significant half-word of \a u32.
-  #define MSH(u32)        (((U16 *)&amp;(u32))[1])  //!&lt; Most significant half-word of \a u32.
-  #define LSB0W(u32)      (((U8  *)&amp;(u32))[0])  //!&lt; Least significant byte of 1st rank of \a u32.
-  #define LSB1W(u32)      (((U8  *)&amp;(u32))[1])  //!&lt; Least significant byte of 2nd rank of \a u32.
-  #define LSB2W(u32)      (((U8  *)&amp;(u32))[2])  //!&lt; Least significant byte of 3rd rank of \a u32.
-  #define LSB3W(u32)      (((U8  *)&amp;(u32))[3])  //!&lt; Least significant byte of 4th rank of \a u32.
-  #define MSB3W(u32)      LSB0W(u32)            //!&lt; Most significant byte of 4th rank of \a u32.
-  #define MSB2W(u32)      LSB1W(u32)            //!&lt; Most significant byte of 3rd rank of \a u32.
-  #define MSB1W(u32)      LSB2W(u32)            //!&lt; Most significant byte of 2nd rank of \a u32.
-  #define MSB0W(u32)      LSB3W(u32)            //!&lt; Most significant byte of 1st rank of \a u32.
-
-  #define LSW(u64)        (((U32 *)&amp;(u64))[0])  //!&lt; Least significant word of \a u64.
-  #define MSW(u64)        (((U32 *)&amp;(u64))[1])  //!&lt; Most significant word of \a u64.
-  #define LSH0(u64)       (((U16 *)&amp;(u64))[0])  //!&lt; Least significant half-word of 1st rank of \a u64.
-  #define LSH1(u64)       (((U16 *)&amp;(u64))[1])  //!&lt; Least significant half-word of 2nd rank of \a u64.
-  #define LSH2(u64)       (((U16 *)&amp;(u64))[2])  //!&lt; Least significant half-word of 3rd rank of \a u64.
-  #define LSH3(u64)       (((U16 *)&amp;(u64))[3])  //!&lt; Least significant half-word of 4th rank of \a u64.
-  #define MSH3(u64)       LSH0(u64)             //!&lt; Most significant half-word of 4th rank of \a u64.
-  #define MSH2(u64)       LSH1(u64)             //!&lt; Most significant half-word of 3rd rank of \a u64.
-  #define MSH1(u64)       LSH2(u64)             //!&lt; Most significant half-word of 2nd rank of \a u64.
-  #define MSH0(u64)       LSH3(u64)             //!&lt; Most significant half-word of 1st rank of \a u64.
-  #define LSB0D(u64)      (((U8  *)&amp;(u64))[0])  //!&lt; Least significant byte of 1st rank of \a u64.
-  #define LSB1D(u64)      (((U8  *)&amp;(u64))[1])  //!&lt; Least significant byte of 2nd rank of \a u64.
-  #define LSB2D(u64)      (((U8  *)&amp;(u64))[2])  //!&lt; Least significant byte of 3rd rank of \a u64.
-  #define LSB3D(u64)      (((U8  *)&amp;(u64))[3])  //!&lt; Least significant byte of 4th rank of \a u64.
-  #define LSB4D(u64)      (((U8  *)&amp;(u64))[4])  //!&lt; Least significant byte of 5th rank of \a u64.
-  #define LSB5D(u64)      (((U8  *)&amp;(u64))[5])  //!&lt; Least significant byte of 6th rank of \a u64.
-  #define LSB6D(u64)      (((U8  *)&amp;(u64))[6])  //!&lt; Least significant byte of 7th rank of \a u64.
-  #define LSB7D(u64)      (((U8  *)&amp;(u64))[7])  //!&lt; Least significant byte of 8th rank of \a u64.
-  #define MSB7D(u64)      LSB0D(u64)            //!&lt; Most significant byte of 8th rank of \a u64.
-  #define MSB6D(u64)      LSB1D(u64)            //!&lt; Most significant byte of 7th rank of \a u64.
-  #define MSB5D(u64)      LSB2D(u64)            //!&lt; Most significant byte of 6th rank of \a u64.
-  #define MSB4D(u64)      LSB3D(u64)            //!&lt; Most significant byte of 5th rank of \a u64.
-  #define MSB3D(u64)      LSB4D(u64)            //!&lt; Most significant byte of 4th rank of \a u64.
-  #define MSB2D(u64)      LSB5D(u64)            //!&lt; Most significant byte of 3rd rank of \a u64.
-  #define MSB1D(u64)      LSB6D(u64)            //!&lt; Most significant byte of 2nd rank of \a u64.
-  #define MSB0D(u64)      LSB7D(u64)            //!&lt; Most significant byte of 1st rank of \a u64.
-
-#else // BIG_ENDIAN_MCU
-
-  #define MSB(u16)        (((U8  *)&amp;(u16))[0])  //!&lt; Most significant byte of \a u16.
-  #define LSB(u16)        (((U8  *)&amp;(u16))[1])  //!&lt; Least significant byte of \a u16.
-
-  #define MSH(u32)        (((U16 *)&amp;(u32))[0])  //!&lt; Most significant half-word of \a u32.
-  #define LSH(u32)        (((U16 *)&amp;(u32))[1])  //!&lt; Least significant half-word of \a u32.
-  #define MSB0W(u32)      (((U8  *)&amp;(u32))[0])  //!&lt; Most significant byte of 1st rank of \a u32.
-  #define MSB1W(u32)      (((U8  *)&amp;(u32))[1])  //!&lt; Most significant byte of 2nd rank of \a u32.
-  #define MSB2W(u32)      (((U8  *)&amp;(u32))[2])  //!&lt; Most significant byte of 3rd rank of \a u32.
-  #define MSB3W(u32)      (((U8  *)&amp;(u32))[3])  //!&lt; Most significant byte of 4th rank of \a u32.
-  #define LSB3W(u32)      MSB0W(u32)            //!&lt; Least significant byte of 4th rank of \a u32.
-  #define LSB2W(u32)      MSB1W(u32)            //!&lt; Least significant byte of 3rd rank of \a u32.
-  #define LSB1W(u32)      MSB2W(u32)            //!&lt; Least significant byte of 2nd rank of \a u32.
-  #define LSB0W(u32)      MSB3W(u32)            //!&lt; Least significant byte of 1st rank of \a u32.
-
-  #define MSW(u64)        (((U32 *)&amp;(u64))[0])  //!&lt; Most significant word of \a u64.
-  #define LSW(u64)        (((U32 *)&amp;(u64))[1])  //!&lt; Least significant word of \a u64.
-  #define MSH0(u64)       (((U16 *)&amp;(u64))[0])  //!&lt; Most significant half-word of 1st rank of \a u64.
-  #define MSH1(u64)       (((U16 *)&amp;(u64))[1])  //!&lt; Most significant half-word of 2nd rank of \a u64.
-  #define MSH2(u64)       (((U16 *)&amp;(u64))[2])  //!&lt; Most significant half-word of 3rd rank of \a u64.
-  #define MSH3(u64)       (((U16 *)&amp;(u64))[3])  //!&lt; Most significant half-word of 4th rank of \a u64.
-  #define LSH3(u64)       MSH0(u64)             //!&lt; Least significant half-word of 4th rank of \a u64.
-  #define LSH2(u64)       MSH1(u64)             //!&lt; Least significant half-word of 3rd rank of \a u64.
-  #define LSH1(u64)       MSH2(u64)             //!&lt; Least significant half-word of 2nd rank of \a u64.
-  #define LSH0(u64)       MSH3(u64)             //!&lt; Least significant half-word of 1st rank of \a u64.
-  #define MSB0D(u64)      (((U8  *)&amp;(u64))[0])  //!&lt; Most significant byte of 1st rank of \a u64.
-  #define MSB1D(u64)      (((U8  *)&amp;(u64))[1])  //!&lt; Most significant byte of 2nd rank of \a u64.
-  #define MSB2D(u64)      (((U8  *)&amp;(u64))[2])  //!&lt; Most significant byte of 3rd rank of \a u64.
-  #define MSB3D(u64)      (((U8  *)&amp;(u64))[3])  //!&lt; Most significant byte of 4th rank of \a u64.
-  #define MSB4D(u64)      (((U8  *)&amp;(u64))[4])  //!&lt; Most significant byte of 5th rank of \a u64.
-  #define MSB5D(u64)      (((U8  *)&amp;(u64))[5])  //!&lt; Most significant byte of 6th rank of \a u64.
-  #define MSB6D(u64)      (((U8  *)&amp;(u64))[6])  //!&lt; Most significant byte of 7th rank of \a u64.
-  #define MSB7D(u64)      (((U8  *)&amp;(u64))[7])  //!&lt; Most significant byte of 8th rank of \a u64.
-  #define LSB7D(u64)      MSB0D(u64)            //!&lt; Least significant byte of 8th rank of \a u64.
-  #define LSB6D(u64)      MSB1D(u64)            //!&lt; Least significant byte of 7th rank of \a u64.
-  #define LSB5D(u64)      MSB2D(u64)            //!&lt; Least significant byte of 6th rank of \a u64.
-  #define LSB4D(u64)      MSB3D(u64)            //!&lt; Least significant byte of 5th rank of \a u64.
-  #define LSB3D(u64)      MSB4D(u64)            //!&lt; Least significant byte of 4th rank of \a u64.
-  #define LSB2D(u64)      MSB5D(u64)            //!&lt; Least significant byte of 3rd rank of \a u64.
-  #define LSB1D(u64)      MSB6D(u64)            //!&lt; Least significant byte of 2nd rank of \a u64.
-  #define LSB0D(u64)      MSB7D(u64)            //!&lt; Least significant byte of 1st rank of \a u64.
-
-#endif
-
-//! @}
-
-
-/*! \name Endianism Conversion
- *
- * The same considerations as for clz and ctz apply here but AVR32-GCC's
- * __builtin_bswap_16 and __builtin_bswap_32 do not behave like macros when
- * applied to constant expressions, so two sets of macros are defined here:
- *   - Swap16, Swap32 and Swap64 to apply to constant expressions (values known
- *     at compile time);
- *   - swap16, swap32 and swap64 to apply to non-constant expressions (values
- *     unknown at compile time).
- */
-//! @{
-
-/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
- *
- * \param u16 U16 of which to toggle the endianism.
- *
- * \return Value resulting from \a u16 with toggled endianism.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Swap16(u16) ((U16)(((U16)(u16) &gt;&gt; 8) |\
-                           ((U16)(u16) &lt;&lt; 8)))
-
-/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
- *
- * \param u32 U32 of which to toggle the endianism.
- *
- * \return Value resulting from \a u32 with toggled endianism.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Swap32(u32) ((U32)(((U32)Swap16((U32)(u32) &gt;&gt; 16)) |\
-                           ((U32)Swap16((U32)(u32)) &lt;&lt; 16)))
-
-/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
- *
- * \param u64 U64 of which to toggle the endianism.
- *
- * \return Value resulting from \a u64 with toggled endianism.
- *
- * \note More optimized if only used with values known at compile time.
- */
-#define Swap64(u64) ((U64)(((U64)Swap32((U64)(u64) &gt;&gt; 32)) |\
-                           ((U64)Swap32((U64)(u64)) &lt;&lt; 32)))
-
-/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
- *
- * \param u16 U16 of which to toggle the endianism.
- *
- * \return Value resulting from \a u16 with toggled endianism.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#if __GNUC__
-  #define swap16(u16) ((U16)__builtin_bswap_16((U16)(u16)))
-#elif __ICCAVR32__
-  #define swap16(u16) ((U16)__swap_bytes_in_halfwords((U16)(u16)))
-#endif
-
-/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
- *
- * \param u32 U32 of which to toggle the endianism.
- *
- * \return Value resulting from \a u32 with toggled endianism.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#if __GNUC__
-  #define swap32(u32) ((U32)__builtin_bswap_32((U32)(u32)))
-#elif __ICCAVR32__
-  #define swap32(u32) ((U32)__swap_bytes((U32)(u32)))
-#endif
-
-/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
- *
- * \param u64 U64 of which to toggle the endianism.
- *
- * \return Value resulting from \a u64 with toggled endianism.
- *
- * \note More optimized if only used with values unknown at compile time.
- */
-#define swap64(u64) ((U64)(((U64)swap32((U64)(u64) &gt;&gt; 32)) |\
-                           ((U64)swap32((U64)(u64)) &lt;&lt; 32)))
-
-//! @}
-
-
-/*! \name Target Abstraction
- */
-//! @{
-
-#define _GLOBEXT_           extern      //!&lt; extern storage-class specifier.
-#define _CONST_TYPE_        const       //!&lt; const type qualifier.
-#define _MEM_TYPE_SLOW_                 //!&lt; Slow memory type.
-#define _MEM_TYPE_MEDFAST_              //!&lt; Fairly fast memory type.
-#define _MEM_TYPE_FAST_                 //!&lt; Fast memory type.
-
-typedef U8                  Byte;       //!&lt; 8-bit unsigned integer.
-
-#define memcmp_ram2ram      memcmp      //!&lt; Target-specific memcmp of RAM to RAM.
-#define memcmp_code2ram     memcmp      //!&lt; Target-specific memcmp of RAM to NVRAM.
-#define memcpy_ram2ram      memcpy      //!&lt; Target-specific memcpy from RAM to RAM.
-#define memcpy_code2ram     memcpy      //!&lt; Target-specific memcpy from NVRAM to RAM.
-
-#define LSB0(u32)           LSB0W(u32)  //!&lt; Least significant byte of 1st rank of \a u32.
-#define LSB1(u32)           LSB1W(u32)  //!&lt; Least significant byte of 2nd rank of \a u32.
-#define LSB2(u32)           LSB2W(u32)  //!&lt; Least significant byte of 3rd rank of \a u32.
-#define LSB3(u32)           LSB3W(u32)  //!&lt; Least significant byte of 4th rank of \a u32.
-#define MSB3(u32)           MSB3W(u32)  //!&lt; Most significant byte of 4th rank of \a u32.
-#define MSB2(u32)           MSB2W(u32)  //!&lt; Most significant byte of 3rd rank of \a u32.
-#define MSB1(u32)           MSB1W(u32)  //!&lt; Most significant byte of 2nd rank of \a u32.
-#define MSB0(u32)           MSB0W(u32)  //!&lt; Most significant byte of 1st rank of \a u32.
-
-//! @}
-
-#endif  // __AVR32_ABI_COMPILER__
-
-
-#endif  // _COMPILER_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Compiler file for AVR32.
+ *
+ * This file defines commonly used types and macros.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _COMPILER_H_
+#define _COMPILER_H_
+
+#if ((defined __GNUC__) &amp;&amp; (defined __AVR32__)) || (defined __ICCAVR32__ || defined __AAVR32__)
+#  include &lt;avr32/io.h&gt;
+#endif
+#if (defined __ICCAVR32__)
+#  include &lt;intrinsics.h&gt;
+#endif
+#include &quot;preprocessor.h&quot;
+
+
+//_____ D E C L A R A T I O N S ____________________________________________
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+#include &lt;stddef.h&gt;
+#include &lt;stdlib.h&gt;
+
+
+#if (defined __ICCAVR32__)
+
+/*! \name Compiler Keywords
+ *
+ * Port of some keywords from GNU GCC for AVR32 to IAR Embedded Workbench for Atmel AVR32.
+ */
+//! @{
+#define __asm__             asm
+#define __inline__          inline
+#define __volatile__
+//! @}
+
+#endif
+
+
+/*! \name Usual Types
+ */
+//! @{
+typedef unsigned char           Bool; //!&lt; Boolean.
+#ifndef __cplusplus
+#if !defined(__bool_true_false_are_defined)
+typedef unsigned char           bool; //!&lt; Boolean.
+#endif
+#endif
+typedef signed char             S8 ;  //!&lt; 8-bit signed integer.
+typedef unsigned char           U8 ;  //!&lt; 8-bit unsigned integer.
+typedef signed short int        S16;  //!&lt; 16-bit signed integer.
+typedef unsigned short int      U16;  //!&lt; 16-bit unsigned integer.
+typedef signed long int         S32;  //!&lt; 32-bit signed integer.
+typedef unsigned long int       U32;  //!&lt; 32-bit unsigned integer.
+typedef signed long long int    S64;  //!&lt; 64-bit signed integer.
+typedef unsigned long long int  U64;  //!&lt; 64-bit unsigned integer.
+typedef float                   F32;  //!&lt; 32-bit floating-point number.
+typedef double                  F64;  //!&lt; 64-bit floating-point number.
+//! @}
+
+
+/*! \name Status Types
+ */
+//! @{
+typedef Bool                Status_bool_t;  //!&lt; Boolean status.
+typedef U8                  Status_t;       //!&lt; 8-bit-coded status.
+//! @}
+
+
+/*! \name Aliasing Aggregate Types
+ */
+//! @{
+
+//! 16-bit union.
+typedef union
+{
+  S16 s16   ;
+  U16 u16   ;
+  S8  s8 [2];
+  U8  u8 [2];
+} Union16;
+
+//! 32-bit union.
+typedef union
+{
+  S32 s32   ;
+  U32 u32   ;
+  S16 s16[2];
+  U16 u16[2];
+  S8  s8 [4];
+  U8  u8 [4];
+} Union32;
+
+//! 64-bit union.
+typedef union
+{
+  S64 s64   ;
+  U64 u64   ;
+  S32 s32[2];
+  U32 u32[2];
+  S16 s16[4];
+  U16 u16[4];
+  S8  s8 [8];
+  U8  u8 [8];
+} Union64;
+
+//! Union of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  S64 *s64ptr;
+  U64 *u64ptr;
+  S32 *s32ptr;
+  U32 *u32ptr;
+  S16 *s16ptr;
+  U16 *u16ptr;
+  S8  *s8ptr ;
+  U8  *u8ptr ;
+} UnionPtr;
+
+//! Union of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  volatile S64 *s64ptr;
+  volatile U64 *u64ptr;
+  volatile S32 *s32ptr;
+  volatile U32 *u32ptr;
+  volatile S16 *s16ptr;
+  volatile U16 *u16ptr;
+  volatile S8  *s8ptr ;
+  volatile U8  *u8ptr ;
+} UnionVPtr;
+
+//! Union of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  const S64 *s64ptr;
+  const U64 *u64ptr;
+  const S32 *s32ptr;
+  const U32 *u32ptr;
+  const S16 *s16ptr;
+  const U16 *u16ptr;
+  const S8  *s8ptr ;
+  const U8  *u8ptr ;
+} UnionCPtr;
+
+//! Union of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef union
+{
+  const volatile S64 *s64ptr;
+  const volatile U64 *u64ptr;
+  const volatile S32 *s32ptr;
+  const volatile U32 *u32ptr;
+  const volatile S16 *s16ptr;
+  const volatile U16 *u16ptr;
+  const volatile S8  *s8ptr ;
+  const volatile U8  *u8ptr ;
+} UnionCVPtr;
+
+//! Structure of pointers to 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  S64 *s64ptr;
+  U64 *u64ptr;
+  S32 *s32ptr;
+  U32 *u32ptr;
+  S16 *s16ptr;
+  U16 *u16ptr;
+  S8  *s8ptr ;
+  U8  *u8ptr ;
+} StructPtr;
+
+//! Structure of pointers to volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  volatile S64 *s64ptr;
+  volatile U64 *u64ptr;
+  volatile S32 *s32ptr;
+  volatile U32 *u32ptr;
+  volatile S16 *s16ptr;
+  volatile U16 *u16ptr;
+  volatile S8  *s8ptr ;
+  volatile U8  *u8ptr ;
+} StructVPtr;
+
+//! Structure of pointers to constant 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  const S64 *s64ptr;
+  const U64 *u64ptr;
+  const S32 *s32ptr;
+  const U32 *u32ptr;
+  const S16 *s16ptr;
+  const U16 *u16ptr;
+  const S8  *s8ptr ;
+  const U8  *u8ptr ;
+} StructCPtr;
+
+//! Structure of pointers to constant volatile 64-, 32-, 16- and 8-bit unsigned integers.
+typedef struct
+{
+  const volatile S64 *s64ptr;
+  const volatile U64 *u64ptr;
+  const volatile S32 *s32ptr;
+  const volatile U32 *u32ptr;
+  const volatile S16 *s16ptr;
+  const volatile U16 *u16ptr;
+  const volatile S8  *s8ptr ;
+  const volatile U8  *u8ptr ;
+} StructCVPtr;
+
+//! @}
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+//_____ M A C R O S ________________________________________________________
+
+/*! \name Usual Constants
+ */
+//! @{
+#define DISABLE   0
+#define ENABLE    1
+#define DISABLED  0
+#define ENABLED   1
+#define OFF       0
+#define ON        1
+#define FALSE     0
+#define TRUE      1
+#ifndef __cplusplus
+#if !defined(__bool_true_false_are_defined)
+#define false     FALSE
+#define true      TRUE
+#endif
+#endif
+#define KO        0
+#define OK        1
+#define PASS      0
+#define FAIL      1
+#define LOW       0
+#define HIGH      1
+#define CLR       0
+#define SET       1
+//! @}
+
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+/*! \name Bit-Field Handling
+ */
+//! @{
+
+/*! \brief Reads the bits of a value specified by a given bit-mask.
+ *
+ * \param value Value to read bits from.
+ * \param mask  Bit-mask indicating bits to read.
+ *
+ * \return Read bits.
+ */
+#define Rd_bits( value, mask)        ((value) &amp; (mask))
+
+/*! \brief Writes the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue to write bits to.
+ * \param mask    Bit-mask indicating bits to write.
+ * \param bits    Bits to write.
+ *
+ * \return Resulting value with written bits.
+ */
+#define Wr_bits(lvalue, mask, bits)  ((lvalue) = ((lvalue) &amp; ~(mask)) |\
+                                                 ((bits  ) &amp;  (mask)))
+
+/*! \brief Tests the bits of a value specified by a given bit-mask.
+ *
+ * \param value Value of which to test bits.
+ * \param mask  Bit-mask indicating bits to test.
+ *
+ * \return \c 1 if at least one of the tested bits is set, else \c 0.
+ */
+#define Tst_bits( value, mask)  (Rd_bits(value, mask) != 0)
+
+/*! \brief Clears the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue of which to clear bits.
+ * \param mask    Bit-mask indicating bits to clear.
+ *
+ * \return Resulting value with cleared bits.
+ */
+#define Clr_bits(lvalue, mask)  ((lvalue) &amp;= ~(mask))
+
+/*! \brief Sets the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue of which to set bits.
+ * \param mask    Bit-mask indicating bits to set.
+ *
+ * \return Resulting value with set bits.
+ */
+#define Set_bits(lvalue, mask)  ((lvalue) |=  (mask))
+
+/*! \brief Toggles the bits of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue  C lvalue of which to toggle bits.
+ * \param mask    Bit-mask indicating bits to toggle.
+ *
+ * \return Resulting value with toggled bits.
+ */
+#define Tgl_bits(lvalue, mask)  ((lvalue) ^=  (mask))
+
+/*! \brief Reads the bit-field of a value specified by a given bit-mask.
+ *
+ * \param value Value to read a bit-field from.
+ * \param mask  Bit-mask indicating the bit-field to read.
+ *
+ * \return Read bit-field.
+ */
+#define Rd_bitfield( value, mask)           (Rd_bits( value, mask) &gt;&gt; ctz(mask))
+
+/*! \brief Writes the bit-field of a C lvalue specified by a given bit-mask.
+ *
+ * \param lvalue    C lvalue to write a bit-field to.
+ * \param mask      Bit-mask indicating the bit-field to write.
+ * \param bitfield  Bit-field to write.
+ *
+ * \return Resulting value with written bit-field.
+ */
+#define Wr_bitfield(lvalue, mask, bitfield) (Wr_bits(lvalue, mask, (U32)(bitfield) &lt;&lt; ctz(mask)))
+
+//! @}
+
+
+/*! \brief This macro is used to test fatal errors.
+ *
+ * The macro tests if the expression is FALSE. If it is, a fatal error is
+ * detected and the application hangs up.
+ *
+ * \param expr  Expression to evaluate and supposed to be nonzero.
+ */
+#ifdef _ASSERT_ENABLE_
+  #define Assert(expr) \
+  {\
+    if (!(expr)) while (TRUE);\
+  }
+#else
+  #define Assert(expr)
+#endif
+
+
+/*! \name Zero-Bit Counting
+ *
+ * Under AVR32-GCC, __builtin_clz and __builtin_ctz behave like macros when
+ * applied to constant expressions (values known at compile time), so they are
+ * more optimized than the use of the corresponding assembly instructions and
+ * they can be used as constant expressions e.g. to initialize objects having
+ * static storage duration, and like the corresponding assembly instructions
+ * when applied to non-constant expressions (values unknown at compile time), so
+ * they are more optimized than an assembly periphrasis. Hence, clz and ctz
+ * ensure a possible and optimized behavior for both constant and non-constant
+ * expressions.
+ */
+//! @{
+
+/*! \brief Counts the leading zero bits of the given value considered as a 32-bit integer.
+ *
+ * \param u Value of which to count the leading zero bits.
+ *
+ * \return The count of leading zero bits in \a u.
+ */
+#if (defined __GNUC__)
+  #define clz(u)              __builtin_clz(u)
+#elif (defined __ICCAVR32__)
+  #define clz(u)              __count_leading_zeros(u)
+#endif
+
+/*! \brief Counts the trailing zero bits of the given value considered as a 32-bit integer.
+ *
+ * \param u Value of which to count the trailing zero bits.
+ *
+ * \return The count of trailing zero bits in \a u.
+ */
+#if (defined __GNUC__)
+  #define ctz(u)              __builtin_ctz(u)
+#elif (defined __ICCAVR32__)
+  #define ctz(u)              __count_trailing_zeros(u)
+#endif
+
+//! @}
+
+
+/*! \name Bit Reversing
+ */
+//! @{
+
+/*! \brief Reverses the bits of \a u8.
+ *
+ * \param u8  U8 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u8 with reversed bits.
+ */
+#define bit_reverse8(u8)    ((U8)(bit_reverse32((U8)(u8)) &gt;&gt; 24))
+
+/*! \brief Reverses the bits of \a u16.
+ *
+ * \param u16 U16 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u16 with reversed bits.
+ */
+#define bit_reverse16(u16)  ((U16)(bit_reverse32((U16)(u16)) &gt;&gt; 16))
+
+/*! \brief Reverses the bits of \a u32.
+ *
+ * \param u32 U32 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u32 with reversed bits.
+ */
+#if (defined __GNUC__)
+  #define bit_reverse32(u32) \
+  (\
+    {\
+      unsigned int __value = (U32)(u32);\
+      __asm__ (&quot;brev\t%0&quot; : &quot;+r&quot; (__value) :  : &quot;cc&quot;);\
+      (U32)__value;\
+    }\
+  )
+#elif (defined __ICCAVR32__)
+  #define bit_reverse32(u32)  ((U32)__bit_reverse((U32)(u32)))
+#endif
+
+/*! \brief Reverses the bits of \a u64.
+ *
+ * \param u64 U64 of which to reverse the bits.
+ *
+ * \return Value resulting from \a u64 with reversed bits.
+ */
+#define bit_reverse64(u64)  ((U64)(((U64)bit_reverse32((U64)(u64) &gt;&gt; 32)) |\
+                                   ((U64)bit_reverse32((U64)(u64)) &lt;&lt; 32)))
+
+//! @}
+
+
+/*! \name Alignment
+ */
+//! @{
+
+/*! \brief Tests alignment of the number \a val with the \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return \c 1 if the number \a val is aligned with the \a n boundary, else \c 0.
+ */
+#define Test_align(val, n     ) (!Tst_bits( val, (n) - 1     )   )
+
+/*! \brief Gets alignment of the number \a val with respect to the \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return Alignment of the number \a val with respect to the \a n boundary.
+ */
+#define Get_align( val, n     ) (  Rd_bits( val, (n) - 1     )   )
+
+/*! \brief Sets alignment of the lvalue number \a lval to \a alg with respect to the \a n boundary.
+ *
+ * \param lval  Input/output lvalue.
+ * \param n     Boundary.
+ * \param alg   Alignment.
+ *
+ * \return New value of \a lval resulting from its alignment set to \a alg with respect to the \a n boundary.
+ */
+#define Set_align(lval, n, alg) (  Wr_bits(lval, (n) - 1, alg)   )
+
+/*! \brief Aligns the number \a val with the upper \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return Value resulting from the number \a val aligned with the upper \a n boundary.
+ */
+#define Align_up(  val, n     ) (((val) + ((n) - 1)) &amp; ~((n) - 1))
+
+/*! \brief Aligns the number \a val with the lower \a n boundary.
+ *
+ * \param val Input value.
+ * \param n   Boundary.
+ *
+ * \return Value resulting from the number \a val aligned with the lower \a n boundary.
+ */
+#define Align_down(val, n     ) ( (val)              &amp; ~((n) - 1))
+
+//! @}
+
+
+/*! \name Mathematics
+ *
+ * The same considerations as for clz and ctz apply here but AVR32-GCC does not
+ * provide built-in functions to access the assembly instructions abs, min and
+ * max and it does not produce them by itself in most cases, so two sets of
+ * macros are defined here:
+ *   - Abs, Min and Max to apply to constant expressions (values known at
+ *     compile time);
+ *   - abs, min and max to apply to non-constant expressions (values unknown at
+ *     compile time).
+ */
+//! @{
+
+/*! \brief Takes the absolute value of \a a.
+ *
+ * \param a Input value.
+ *
+ * \return Absolute value of \a a.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Abs(a)              (((a) &lt;  0 ) ? -(a) : (a))
+
+/*! \brief Takes the minimal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Minimal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Min(a, b)           (((a) &lt; (b)) ?  (a) : (b))
+
+/*! \brief Takes the maximal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Maximal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Max(a, b)           (((a) &gt; (b)) ?  (a) : (b))
+
+/*! \brief Takes the absolute value of \a a.
+ *
+ * \param a Input value.
+ *
+ * \return Absolute value of \a a.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if (defined __GNUC__)
+  #define abs(a) \
+  (\
+    {\
+      int __value = (a);\
+      __asm__ (&quot;abs\t%0&quot; : &quot;+r&quot; (__value) :  : &quot;cc&quot;);\
+      __value;\
+    }\
+  )
+#elif (defined __ICCAVR32__)
+  #define abs(a)      Abs(a)
+#endif
+
+/*! \brief Takes the minimal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Minimal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if (defined __GNUC__)
+  #define min(a, b) \
+  (\
+    {\
+      int __value, __arg_a = (a), __arg_b = (b);\
+      __asm__ (&quot;min\t%0, %1, %2&quot; : &quot;=r&quot; (__value) : &quot;r&quot; (__arg_a), &quot;r&quot; (__arg_b));\
+      __value;\
+    }\
+  )
+#elif (defined __ICCAVR32__)
+  #define min(a, b)   __min(a, b)
+#endif
+
+/*! \brief Takes the maximal value of \a a and \a b.
+ *
+ * \param a Input value.
+ * \param b Input value.
+ *
+ * \return Maximal value of \a a and \a b.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if (defined __GNUC__)
+  #define max(a, b) \
+  (\
+    {\
+      int __value, __arg_a = (a), __arg_b = (b);\
+      __asm__ (&quot;max\t%0, %1, %2&quot; : &quot;=r&quot; (__value) : &quot;r&quot; (__arg_a), &quot;r&quot; (__arg_b));\
+      __value;\
+    }\
+  )
+#elif (defined __ICCAVR32__)
+  #define max(a, b)   __max(a, b)
+#endif
+
+//! @}
+
+
+/*! \brief Calls the routine at address \a addr.
+ *
+ * It generates a long call opcode.
+ *
+ * For example, `Long_call(0x80000000)' generates a software reset on a UC3 if
+ * it is invoked from the CPU supervisor mode.
+ *
+ * \param addr  Address of the routine to call.
+ *
+ * \note It may be used as a long jump opcode in some special cases.
+ */
+#define Long_call(addr)                   ((*(void (*)(void))(addr))())
+
+/*! \brief Resets the CPU by software.
+ *
+ * \warning It shall not be called from the CPU application mode.
+ */
+#if (defined __GNUC__)
+  #define Reset_CPU() \
+  (\
+    {\
+      __asm__ __volatile__ (\
+        &quot;lddpc   r9, 3f\n\t&quot;\
+        &quot;mfsr    r8, %[SR]\n\t&quot;\
+        &quot;bfextu  r8, r8, %[SR_M_OFFSET], %[SR_M_SIZE]\n\t&quot;\
+        &quot;cp.w    r8, 0b001\n\t&quot;\
+        &quot;breq    0f\n\t&quot;\
+        &quot;sub     r8, pc, $ - 1f\n\t&quot;\
+        &quot;pushm   r8-r9\n\t&quot;\
+        &quot;rete\n&quot;\
+        &quot;0:\n\t&quot;\
+        &quot;mtsr    %[SR], r9\n&quot;\
+        &quot;1:\n\t&quot;\
+        &quot;mov     r0, 0\n\t&quot;\
+        &quot;mov     r1, 0\n\t&quot;\
+        &quot;mov     r2, 0\n\t&quot;\
+        &quot;mov     r3, 0\n\t&quot;\
+        &quot;mov     r4, 0\n\t&quot;\
+        &quot;mov     r5, 0\n\t&quot;\
+        &quot;mov     r6, 0\n\t&quot;\
+        &quot;mov     r7, 0\n\t&quot;\
+        &quot;mov     r8, 0\n\t&quot;\
+        &quot;mov     r9, 0\n\t&quot;\
+        &quot;mov     r10, 0\n\t&quot;\
+        &quot;mov     r11, 0\n\t&quot;\
+        &quot;mov     r12, 0\n\t&quot;\
+        &quot;mov     sp, 0\n\t&quot;\
+        &quot;stdsp   sp[0], sp\n\t&quot;\
+        &quot;ldmts   sp, sp\n\t&quot;\
+        &quot;mov     lr, 0\n\t&quot;\
+        &quot;lddpc   pc, 2f\n\t&quot;\
+        &quot;.balign 4\n&quot;\
+        &quot;2:\n\t&quot;\
+        &quot;.word   _start\n&quot;\
+        &quot;3:\n\t&quot;\
+        &quot;.word   %[RESET_SR]&quot;\
+        :\
+        : [SR] &quot;i&quot; (AVR32_SR),\
+          [SR_M_OFFSET] &quot;i&quot; (AVR32_SR_M_OFFSET),\
+          [SR_M_SIZE] &quot;i&quot; (AVR32_SR_M_SIZE),\
+          [RESET_SR] &quot;i&quot; (AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | (AVR32_SR_M_SUP &lt;&lt; AVR32_SR_M_OFFSET))\
+      );\
+    }\
+  )
+#elif (defined __ICCAVR32__)
+  #define Reset_CPU() \
+  {\
+    extern void *volatile __program_start;\
+    __asm__ __volatile__ (\
+      &quot;mov     r7, LWRD(__program_start)\n\t&quot;\
+      &quot;orh     r7, HWRD(__program_start)\n\t&quot;\
+      &quot;mov     r9, LWRD(&quot;ASTRINGZ(AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | (AVR32_SR_M_SUP &lt;&lt; AVR32_SR_M_OFFSET))&quot;)\n\t&quot;\
+      &quot;orh     r9, HWRD(&quot;ASTRINGZ(AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | (AVR32_SR_M_SUP &lt;&lt; AVR32_SR_M_OFFSET))&quot;)\n\t&quot;\
+      &quot;mfsr    r8, &quot;ASTRINGZ(AVR32_SR)&quot;\n\t&quot;\
+      &quot;bfextu  r8, r8, &quot;ASTRINGZ(AVR32_SR_M_OFFSET)&quot;, &quot;ASTRINGZ(AVR32_SR_M_SIZE)&quot;\n\t&quot;\
+      &quot;cp.w    r8, 001b\n\t&quot;\
+      &quot;breq    $ + 10\n\t&quot;\
+      &quot;sub     r8, pc, -12\n\t&quot;\
+      &quot;pushm   r8-r9\n\t&quot;\
+      &quot;rete\n\t&quot;\
+      &quot;mtsr    &quot;ASTRINGZ(AVR32_SR)&quot;, r9\n\t&quot;\
+      &quot;mov     r0, 0\n\t&quot;\
+      &quot;mov     r1, 0\n\t&quot;\
+      &quot;mov     r2, 0\n\t&quot;\
+      &quot;mov     r3, 0\n\t&quot;\
+      &quot;mov     r4, 0\n\t&quot;\
+      &quot;mov     r5, 0\n\t&quot;\
+      &quot;mov     r6, 0\n\t&quot;\
+      &quot;st.w    r0[4], r7\n\t&quot;\
+      &quot;mov     r7, 0\n\t&quot;\
+      &quot;mov     r8, 0\n\t&quot;\
+      &quot;mov     r9, 0\n\t&quot;\
+      &quot;mov     r10, 0\n\t&quot;\
+      &quot;mov     r11, 0\n\t&quot;\
+      &quot;mov     r12, 0\n\t&quot;\
+      &quot;mov     sp, 0\n\t&quot;\
+      &quot;stdsp   sp[0], sp\n\t&quot;\
+      &quot;ldmts   sp, sp\n\t&quot;\
+      &quot;mov     lr, 0\n\t&quot;\
+      &quot;ld.w    pc, lr[4]&quot;\
+    );\
+    __program_start;\
+  }
+#endif
+
+
+/*! \name System Register Access
+ */
+//! @{
+
+/*! \brief Gets the value of the \a sysreg system register.
+ *
+ * \param sysreg  Address of the system register of which to get the value.
+ *
+ * \return Value of the \a sysreg system register.
+ */
+#if (defined __GNUC__)
+  #define Get_system_register(sysreg)         __builtin_mfsr(sysreg)
+#elif (defined __ICCAVR32__)
+  #define Get_system_register(sysreg)         __get_system_register(sysreg)
+#endif
+
+/*! \brief Sets the value of the \a sysreg system register to \a value.
+ *
+ * \param sysreg  Address of the system register of which to set the value.
+ * \param value   Value to set the \a sysreg system register to.
+ */
+#if (defined __GNUC__)
+  #define Set_system_register(sysreg, value)  __builtin_mtsr(sysreg, value)
+#elif (defined __ICCAVR32__)
+  #define Set_system_register(sysreg, value)  __set_system_register(sysreg, value)
+#endif
+
+//! @}
+
+
+/*! \name CPU Status Register Access
+ */
+//! @{
+
+/*! \brief Tells whether exceptions are globally enabled.
+ *
+ * \return \c 1 if exceptions are globally enabled, else \c 0.
+ */
+#define Is_global_exception_enabled()         (!Tst_bits(Get_system_register(AVR32_SR), AVR32_SR_EM_MASK))
+
+/*! \brief Disables exceptions globally.
+ */
+#if (defined __GNUC__)
+  #define Disable_global_exception()          ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_EM_OFFSET));})
+#elif (defined __ICCAVR32__)
+  #define Disable_global_exception()          (__set_status_flag(AVR32_SR_EM_OFFSET))
+#endif
+
+/*! \brief Enables exceptions globally.
+ */
+#if (defined __GNUC__)
+  #define Enable_global_exception()           ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_EM_OFFSET));})
+#elif (defined __ICCAVR32__)
+  #define Enable_global_exception()           (__clear_status_flag(AVR32_SR_EM_OFFSET))
+#endif
+
+/*! \brief Tells whether interrupts are globally enabled.
+ *
+ * \return \c 1 if interrupts are globally enabled, else \c 0.
+ */
+#define Is_global_interrupt_enabled()         (!Tst_bits(Get_system_register(AVR32_SR), AVR32_SR_GM_MASK))
+
+/*! \brief Disables interrupts globally.
+ */
+#if (defined __GNUC__)
+  #define Disable_global_interrupt()          ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_GM_OFFSET));})
+#elif (defined __ICCAVR32__)
+  #define Disable_global_interrupt()          (__disable_interrupt())
+#endif
+
+/*! \brief Enables interrupts globally.
+ */
+#if (defined __GNUC__)
+  #define Enable_global_interrupt()           ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (AVR32_SR_GM_OFFSET));})
+#elif (defined __ICCAVR32__)
+  #define Enable_global_interrupt()           (__enable_interrupt())
+#endif
+
+/*! \brief Tells whether interrupt level \a int_level is enabled.
+ *
+ * \param int_level Interrupt level (0 to 3).
+ *
+ * \return \c 1 if interrupt level \a int_level is enabled, else \c 0.
+ */
+#define Is_interrupt_level_enabled(int_level) (!Tst_bits(Get_system_register(AVR32_SR), TPASTE3(AVR32_SR_I, int_level, M_MASK)))
+
+/*! \brief Disables interrupt level \a int_level.
+ *
+ * \param int_level Interrupt level to disable (0 to 3).
+ */
+#if (defined __GNUC__)
+  #define Disable_interrupt_level(int_level)  ({__asm__ __volatile__ (&quot;ssrf\t%0&quot; :  : &quot;i&quot; (TPASTE3(AVR32_SR_I, int_level, M_OFFSET)));})
+#elif (defined __ICCAVR32__)
+  #define Disable_interrupt_level(int_level)  (__set_status_flag(TPASTE3(AVR32_SR_I, int_level, M_OFFSET)))
+#endif
+
+/*! \brief Enables interrupt level \a int_level.
+ *
+ * \param int_level Interrupt level to enable (0 to 3).
+ */
+#if (defined __GNUC__)
+  #define Enable_interrupt_level(int_level)   ({__asm__ __volatile__ (&quot;csrf\t%0&quot; :  : &quot;i&quot; (TPASTE3(AVR32_SR_I, int_level, M_OFFSET)));})
+#elif (defined __ICCAVR32__)
+  #define Enable_interrupt_level(int_level)   (__clear_status_flag(TPASTE3(AVR32_SR_I, int_level, M_OFFSET)))
+#endif
+
+/*! \brief Protects subsequent code from interrupts.
+ */
+#define AVR32_ENTER_CRITICAL_REGION( ) \
+  { \
+  Bool global_interrupt_enabled = Is_global_interrupt_enabled(); \
+  Disable_global_interrupt(); // Disable the appropriate interrupts.
+
+/*! \brief This macro must always be used in conjunction with AVR32_ENTER_CRITICAL_REGION
+ *         so that interrupts are enabled again.
+ */
+#define AVR32_LEAVE_CRITICAL_REGION( ) \
+  if (global_interrupt_enabled) Enable_global_interrupt(); \
+  }
+
+//! @}
+
+
+/*! \name Debug Register Access
+ */
+//! @{
+
+/*! \brief Gets the value of the \a dbgreg debug register.
+ *
+ * \param dbgreg  Address of the debug register of which to get the value.
+ *
+ * \return Value of the \a dbgreg debug register.
+ */
+#if (defined __GNUC__)
+  #define Get_debug_register(dbgreg)          __builtin_mfdr(dbgreg)
+#elif (defined __ICCAVR32__)
+  #define Get_debug_register(dbgreg)          __get_debug_register(dbgreg)
+#endif
+
+/*! \brief Sets the value of the \a dbgreg debug register to \a value.
+ *
+ * \param dbgreg  Address of the debug register of which to set the value.
+ * \param value   Value to set the \a dbgreg debug register to.
+ */
+#if (defined __GNUC__)
+  #define Set_debug_register(dbgreg, value)   __builtin_mtdr(dbgreg, value)
+#elif (defined __ICCAVR32__)
+  #define Set_debug_register(dbgreg, value)   __set_debug_register(dbgreg, value)
+#endif
+
+//! @}
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+//! Boolean evaluating MCU little endianism.
+#if ((defined __GNUC__) &amp;&amp; (defined __AVR32__)) || ((defined __ICCAVR32__) || (defined __AAVR32__))
+  #define LITTLE_ENDIAN_MCU     FALSE
+#else
+  #error If you are here, you should check what is exactly the processor you are using...
+  #define LITTLE_ENDIAN_MCU     FALSE
+#endif
+
+// Check that MCU endianism is correctly defined.
+#ifndef LITTLE_ENDIAN_MCU
+  #error YOU MUST define the MCU endianism with LITTLE_ENDIAN_MCU: either FALSE or TRUE
+#endif
+
+//! Boolean evaluating MCU big endianism.
+#define BIG_ENDIAN_MCU        (!LITTLE_ENDIAN_MCU)
+
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+/*! \name MCU Endianism Handling
+ */
+//! @{
+
+#if (LITTLE_ENDIAN_MCU==TRUE)
+  #define LSB(u16)        (((U8  *)&amp;(u16))[0])  //!&lt; Least significant byte of \a u16.
+  #define MSB(u16)        (((U8  *)&amp;(u16))[1])  //!&lt; Most significant byte of \a u16.
+
+  #define LSH(u32)        (((U16 *)&amp;(u32))[0])  //!&lt; Least significant half-word of \a u32.
+  #define MSH(u32)        (((U16 *)&amp;(u32))[1])  //!&lt; Most significant half-word of \a u32.
+  #define LSB0W(u32)      (((U8  *)&amp;(u32))[0])  //!&lt; Least significant byte of 1st rank of \a u32.
+  #define LSB1W(u32)      (((U8  *)&amp;(u32))[1])  //!&lt; Least significant byte of 2nd rank of \a u32.
+  #define LSB2W(u32)      (((U8  *)&amp;(u32))[2])  //!&lt; Least significant byte of 3rd rank of \a u32.
+  #define LSB3W(u32)      (((U8  *)&amp;(u32))[3])  //!&lt; Least significant byte of 4th rank of \a u32.
+  #define MSB3W(u32)      LSB0W(u32)            //!&lt; Most significant byte of 4th rank of \a u32.
+  #define MSB2W(u32)      LSB1W(u32)            //!&lt; Most significant byte of 3rd rank of \a u32.
+  #define MSB1W(u32)      LSB2W(u32)            //!&lt; Most significant byte of 2nd rank of \a u32.
+  #define MSB0W(u32)      LSB3W(u32)            //!&lt; Most significant byte of 1st rank of \a u32.
+
+  #define LSW(u64)        (((U32 *)&amp;(u64))[0])  //!&lt; Least significant word of \a u64.
+  #define MSW(u64)        (((U32 *)&amp;(u64))[1])  //!&lt; Most significant word of \a u64.
+  #define LSH0(u64)       (((U16 *)&amp;(u64))[0])  //!&lt; Least significant half-word of 1st rank of \a u64.
+  #define LSH1(u64)       (((U16 *)&amp;(u64))[1])  //!&lt; Least significant half-word of 2nd rank of \a u64.
+  #define LSH2(u64)       (((U16 *)&amp;(u64))[2])  //!&lt; Least significant half-word of 3rd rank of \a u64.
+  #define LSH3(u64)       (((U16 *)&amp;(u64))[3])  //!&lt; Least significant half-word of 4th rank of \a u64.
+  #define MSH3(u64)       LSH0(u64)             //!&lt; Most significant half-word of 4th rank of \a u64.
+  #define MSH2(u64)       LSH1(u64)             //!&lt; Most significant half-word of 3rd rank of \a u64.
+  #define MSH1(u64)       LSH2(u64)             //!&lt; Most significant half-word of 2nd rank of \a u64.
+  #define MSH0(u64)       LSH3(u64)             //!&lt; Most significant half-word of 1st rank of \a u64.
+  #define LSB0D(u64)      (((U8  *)&amp;(u64))[0])  //!&lt; Least significant byte of 1st rank of \a u64.
+  #define LSB1D(u64)      (((U8  *)&amp;(u64))[1])  //!&lt; Least significant byte of 2nd rank of \a u64.
+  #define LSB2D(u64)      (((U8  *)&amp;(u64))[2])  //!&lt; Least significant byte of 3rd rank of \a u64.
+  #define LSB3D(u64)      (((U8  *)&amp;(u64))[3])  //!&lt; Least significant byte of 4th rank of \a u64.
+  #define LSB4D(u64)      (((U8  *)&amp;(u64))[4])  //!&lt; Least significant byte of 5th rank of \a u64.
+  #define LSB5D(u64)      (((U8  *)&amp;(u64))[5])  //!&lt; Least significant byte of 6th rank of \a u64.
+  #define LSB6D(u64)      (((U8  *)&amp;(u64))[6])  //!&lt; Least significant byte of 7th rank of \a u64.
+  #define LSB7D(u64)      (((U8  *)&amp;(u64))[7])  //!&lt; Least significant byte of 8th rank of \a u64.
+  #define MSB7D(u64)      LSB0D(u64)            //!&lt; Most significant byte of 8th rank of \a u64.
+  #define MSB6D(u64)      LSB1D(u64)            //!&lt; Most significant byte of 7th rank of \a u64.
+  #define MSB5D(u64)      LSB2D(u64)            //!&lt; Most significant byte of 6th rank of \a u64.
+  #define MSB4D(u64)      LSB3D(u64)            //!&lt; Most significant byte of 5th rank of \a u64.
+  #define MSB3D(u64)      LSB4D(u64)            //!&lt; Most significant byte of 4th rank of \a u64.
+  #define MSB2D(u64)      LSB5D(u64)            //!&lt; Most significant byte of 3rd rank of \a u64.
+  #define MSB1D(u64)      LSB6D(u64)            //!&lt; Most significant byte of 2nd rank of \a u64.
+  #define MSB0D(u64)      LSB7D(u64)            //!&lt; Most significant byte of 1st rank of \a u64.
+
+#elif (BIG_ENDIAN_MCU==TRUE) 
+  #define MSB(u16)        (((U8  *)&amp;(u16))[0])  //!&lt; Most significant byte of \a u16.
+  #define LSB(u16)        (((U8  *)&amp;(u16))[1])  //!&lt; Least significant byte of \a u16.
+
+  #define MSH(u32)        (((U16 *)&amp;(u32))[0])  //!&lt; Most significant half-word of \a u32.
+  #define LSH(u32)        (((U16 *)&amp;(u32))[1])  //!&lt; Least significant half-word of \a u32.
+  #define MSB0W(u32)      (((U8  *)&amp;(u32))[0])  //!&lt; Most significant byte of 1st rank of \a u32.
+  #define MSB1W(u32)      (((U8  *)&amp;(u32))[1])  //!&lt; Most significant byte of 2nd rank of \a u32.
+  #define MSB2W(u32)      (((U8  *)&amp;(u32))[2])  //!&lt; Most significant byte of 3rd rank of \a u32.
+  #define MSB3W(u32)      (((U8  *)&amp;(u32))[3])  //!&lt; Most significant byte of 4th rank of \a u32.
+  #define LSB3W(u32)      MSB0W(u32)            //!&lt; Least significant byte of 4th rank of \a u32.
+  #define LSB2W(u32)      MSB1W(u32)            //!&lt; Least significant byte of 3rd rank of \a u32.
+  #define LSB1W(u32)      MSB2W(u32)            //!&lt; Least significant byte of 2nd rank of \a u32.
+  #define LSB0W(u32)      MSB3W(u32)            //!&lt; Least significant byte of 1st rank of \a u32.
+
+  #define MSW(u64)        (((U32 *)&amp;(u64))[0])  //!&lt; Most significant word of \a u64.
+  #define LSW(u64)        (((U32 *)&amp;(u64))[1])  //!&lt; Least significant word of \a u64.
+  #define MSH0(u64)       (((U16 *)&amp;(u64))[0])  //!&lt; Most significant half-word of 1st rank of \a u64.
+  #define MSH1(u64)       (((U16 *)&amp;(u64))[1])  //!&lt; Most significant half-word of 2nd rank of \a u64.
+  #define MSH2(u64)       (((U16 *)&amp;(u64))[2])  //!&lt; Most significant half-word of 3rd rank of \a u64.
+  #define MSH3(u64)       (((U16 *)&amp;(u64))[3])  //!&lt; Most significant half-word of 4th rank of \a u64.
+  #define LSH3(u64)       MSH0(u64)             //!&lt; Least significant half-word of 4th rank of \a u64.
+  #define LSH2(u64)       MSH1(u64)             //!&lt; Least significant half-word of 3rd rank of \a u64.
+  #define LSH1(u64)       MSH2(u64)             //!&lt; Least significant half-word of 2nd rank of \a u64.
+  #define LSH0(u64)       MSH3(u64)             //!&lt; Least significant half-word of 1st rank of \a u64.
+  #define MSB0D(u64)      (((U8  *)&amp;(u64))[0])  //!&lt; Most significant byte of 1st rank of \a u64.
+  #define MSB1D(u64)      (((U8  *)&amp;(u64))[1])  //!&lt; Most significant byte of 2nd rank of \a u64.
+  #define MSB2D(u64)      (((U8  *)&amp;(u64))[2])  //!&lt; Most significant byte of 3rd rank of \a u64.
+  #define MSB3D(u64)      (((U8  *)&amp;(u64))[3])  //!&lt; Most significant byte of 4th rank of \a u64.
+  #define MSB4D(u64)      (((U8  *)&amp;(u64))[4])  //!&lt; Most significant byte of 5th rank of \a u64.
+  #define MSB5D(u64)      (((U8  *)&amp;(u64))[5])  //!&lt; Most significant byte of 6th rank of \a u64.
+  #define MSB6D(u64)      (((U8  *)&amp;(u64))[6])  //!&lt; Most significant byte of 7th rank of \a u64.
+  #define MSB7D(u64)      (((U8  *)&amp;(u64))[7])  //!&lt; Most significant byte of 8th rank of \a u64.
+  #define LSB7D(u64)      MSB0D(u64)            //!&lt; Least significant byte of 8th rank of \a u64.
+  #define LSB6D(u64)      MSB1D(u64)            //!&lt; Least significant byte of 7th rank of \a u64.
+  #define LSB5D(u64)      MSB2D(u64)            //!&lt; Least significant byte of 6th rank of \a u64.
+  #define LSB4D(u64)      MSB3D(u64)            //!&lt; Least significant byte of 5th rank of \a u64.
+  #define LSB3D(u64)      MSB4D(u64)            //!&lt; Least significant byte of 4th rank of \a u64.
+  #define LSB2D(u64)      MSB5D(u64)            //!&lt; Least significant byte of 3rd rank of \a u64.
+  #define LSB1D(u64)      MSB6D(u64)            //!&lt; Least significant byte of 2nd rank of \a u64.
+  #define LSB0D(u64)      MSB7D(u64)            //!&lt; Least significant byte of 1st rank of \a u64.
+
+#else
+  #error  Unknown endianism.
+#endif
+
+//! @}
+
+
+/*! \name Endianism Conversion
+ *
+ * The same considerations as for clz and ctz apply here but AVR32-GCC's
+ * __builtin_bswap_16 and __builtin_bswap_32 do not behave like macros when
+ * applied to constant expressions, so two sets of macros are defined here:
+ *   - Swap16, Swap32 and Swap64 to apply to constant expressions (values known
+ *     at compile time);
+ *   - swap16, swap32 and swap64 to apply to non-constant expressions (values
+ *     unknown at compile time).
+ */
+//! @{
+
+/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
+ *
+ * \param u16 U16 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u16 with toggled endianism.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Swap16(u16) ((U16)(((U16)(u16) &gt;&gt; 8) |\
+                           ((U16)(u16) &lt;&lt; 8)))
+
+/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
+ *
+ * \param u32 U32 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u32 with toggled endianism.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Swap32(u32) ((U32)(((U32)Swap16((U32)(u32) &gt;&gt; 16)) |\
+                           ((U32)Swap16((U32)(u32)) &lt;&lt; 16)))
+
+/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
+ *
+ * \param u64 U64 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u64 with toggled endianism.
+ *
+ * \note More optimized if only used with values known at compile time.
+ */
+#define Swap64(u64) ((U64)(((U64)Swap32((U64)(u64) &gt;&gt; 32)) |\
+                           ((U64)Swap32((U64)(u64)) &lt;&lt; 32)))
+
+/*! \brief Toggles the endianism of \a u16 (by swapping its bytes).
+ *
+ * \param u16 U16 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u16 with toggled endianism.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if (defined __GNUC__)
+  #define swap16(u16) ((U16)__builtin_bswap_16((U16)(u16)))
+#elif (defined __ICCAVR32__)
+  #define swap16(u16) ((U16)__swap_bytes_in_halfwords((U16)(u16)))
+#endif
+
+/*! \brief Toggles the endianism of \a u32 (by swapping its bytes).
+ *
+ * \param u32 U32 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u32 with toggled endianism.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#if (defined __GNUC__)
+  #define swap32(u32) ((U32)__builtin_bswap_32((U32)(u32)))
+#elif (defined __ICCAVR32__)
+  #define swap32(u32) ((U32)__swap_bytes((U32)(u32)))
+#endif
+
+/*! \brief Toggles the endianism of \a u64 (by swapping its bytes).
+ *
+ * \param u64 U64 of which to toggle the endianism.
+ *
+ * \return Value resulting from \a u64 with toggled endianism.
+ *
+ * \note More optimized if only used with values unknown at compile time.
+ */
+#define swap64(u64) ((U64)(((U64)swap32((U64)(u64) &gt;&gt; 32)) |\
+                           ((U64)swap32((U64)(u64)) &lt;&lt; 32)))
+
+//! @}
+
+
+/*! \name Target Abstraction
+ */
+//! @{
+
+#define _GLOBEXT_           extern      //!&lt; extern storage-class specifier.
+#define _CONST_TYPE_        const       //!&lt; const type qualifier.
+#define _MEM_TYPE_SLOW_                 //!&lt; Slow memory type.
+#define _MEM_TYPE_MEDFAST_              //!&lt; Fairly fast memory type.
+#define _MEM_TYPE_FAST_                 //!&lt; Fast memory type.
+
+typedef U8                  Byte;       //!&lt; 8-bit unsigned integer.
+
+#define memcmp_ram2ram      memcmp      //!&lt; Target-specific memcmp of RAM to RAM.
+#define memcmp_code2ram     memcmp      //!&lt; Target-specific memcmp of RAM to NVRAM.
+#define memcpy_ram2ram      memcpy      //!&lt; Target-specific memcpy from RAM to RAM.
+#define memcpy_code2ram     memcpy      //!&lt; Target-specific memcpy from NVRAM to RAM.
+
+#define LSB0(u32)           LSB0W(u32)  //!&lt; Least significant byte of 1st rank of \a u32.
+#define LSB1(u32)           LSB1W(u32)  //!&lt; Least significant byte of 2nd rank of \a u32.
+#define LSB2(u32)           LSB2W(u32)  //!&lt; Least significant byte of 3rd rank of \a u32.
+#define LSB3(u32)           LSB3W(u32)  //!&lt; Least significant byte of 4th rank of \a u32.
+#define MSB3(u32)           MSB3W(u32)  //!&lt; Most significant byte of 4th rank of \a u32.
+#define MSB2(u32)           MSB2W(u32)  //!&lt; Most significant byte of 3rd rank of \a u32.
+#define MSB1(u32)           MSB1W(u32)  //!&lt; Most significant byte of 2nd rank of \a u32.
+#define MSB0(u32)           MSB0W(u32)  //!&lt; Most significant byte of 1st rank of \a u32.
+
+//! @}
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+#endif  // _COMPILER_H_

Modified: trunk/src/platform/avr32/conf_isp.h
===================================================================
--- trunk/src/platform/avr32/conf_isp.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/conf_isp.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,121 +1,124 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file ******************************************************************
- *
- * \brief ISP configuration file.
- *
- * This file contains the possible external configuration of the ISP.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a USB module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ***************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _CONF_ISP_H_
-#define _CONF_ISP_H_
-
-#include &lt;avr32/io.h&gt;
-#include &quot;compiler.h&quot;
-
-
-//_____ D E F I N I T I O N S ______________________________________________
-
-#define PRODUCT_MANUFACTURER_ID       0x58
-#define PRODUCT_FAMILY_ID             0x20
-
-#define ISP_VERSION                   0x02
-#define ISP_ID0                       0x00
-#define ISP_ID1                       0x00
-
-#define ISP_GPFB_FORCE                31
-#define ISP_GPFB_FORCE_MASK           0x80000000
-#define ISP_GPFB_FORCE_OFFSET         31
-#define ISP_GPFB_FORCE_SIZE           1
-
-#define ISP_GPFB_IO_COND_EN           30
-#define ISP_GPFB_IO_COND_EN_MASK      0x40000000
-#define ISP_GPFB_IO_COND_EN_OFFSET    30
-#define ISP_GPFB_IO_COND_EN_SIZE      1
-
-#define ISP_GPFB_BOD_EN               29
-#define ISP_GPFB_BOD_EN_MASK          0x20000000
-#define ISP_GPFB_BOD_EN_OFFSET        29
-#define ISP_GPFB_BOD_EN_SIZE          1
-
-#define ISP_CFG                       (*(volatile U32 *)ISP_CFG_ADDRESS)
-#define ISP_CFG_ADDRESS               (AVR32_FLASHC_USER_PAGE_ADDRESS + ISP_CFG_OFFSET)
-#define ISP_CFG_OFFSET                0x000001FC
-#define ISP_CFG_SIZE                  4
-
-#define ISP_CFG_BOOT_KEY              17
-#define ISP_CFG_BOOT_KEY_MASK         0xFFFE0000
-#define ISP_CFG_BOOT_KEY_OFFSET       17
-#define ISP_CFG_BOOT_KEY_SIZE         15
-#define ISP_CFG_BOOT_KEY_VALUE        0x494F
-
-#define ISP_CFG_IO_COND_LEVEL         16
-#define ISP_CFG_IO_COND_LEVEL_MASK    0x00010000
-#define ISP_CFG_IO_COND_LEVEL_OFFSET  16
-#define ISP_CFG_IO_COND_LEVEL_SIZE    1
-
-#define ISP_CFG_IO_COND_PIN           8
-#define ISP_CFG_IO_COND_PIN_MASK      0x0000FF00
-#define ISP_CFG_IO_COND_PIN_OFFSET    8
-#define ISP_CFG_IO_COND_PIN_SIZE      8
-
-#define ISP_CFG_CRC8                  0
-#define ISP_CFG_CRC8_MASK             0x000000FF
-#define ISP_CFG_CRC8_OFFSET           0
-#define ISP_CFG_CRC8_SIZE             8
-#define ISP_CFG_CRC8_POLYNOMIAL       0x107
-
-#define ISP_KEY                       (*(volatile U32 *)ISP_KEY_ADDRESS)
-#define ISP_KEY_ADDRESS               (AVR32_SRAM_ADDRESS + ISP_KEY_OFFSET)
-#define ISP_KEY_OFFSET                0x00000000
-#define ISP_KEY_SIZE                  4
-#define ISP_KEY_VALUE                 ('I' &lt;&lt; 24 | 'S' &lt;&lt; 16 | 'P' &lt;&lt; 8 | 'K')
-
-#ifndef ISP_OSC
-  #define ISP_OSC                     0
-#endif
-
-#define DFU_FRAME_LENGTH              2048
-
-#define PROGRAM_START_ADDRESS         (AVR32_FLASH_ADDRESS + PROGRAM_START_OFFSET)
-#define PROGRAM_START_OFFSET          0x00002000
-
-
-#endif  // _CONF_ISP_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file ******************************************************************
+ *
+ * \brief ISP configuration file.
+ *
+ * This file contains the possible external configuration of the ISP.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a USB module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ***************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _CONF_ISP_H_
+#define _CONF_ISP_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+
+
+//_____ D E F I N I T I O N S ______________________________________________
+
+#define PRODUCT_MANUFACTURER_ID       0x58
+#define PRODUCT_FAMILY_ID             0x20
+
+#define ISP_VERSION                   0x03
+#define ISP_ID0                       0x00
+#define ISP_ID1                       0x00
+
+#define ISP_GPFB_FORCE                31
+#define ISP_GPFB_FORCE_MASK           0x80000000
+#define ISP_GPFB_FORCE_OFFSET         31
+#define ISP_GPFB_FORCE_SIZE           1
+
+#define ISP_GPFB_IO_COND_EN           30
+#define ISP_GPFB_IO_COND_EN_MASK      0x40000000
+#define ISP_GPFB_IO_COND_EN_OFFSET    30
+#define ISP_GPFB_IO_COND_EN_SIZE      1
+
+#define ISP_GPFB_BOD_EN               29
+#define ISP_GPFB_BOD_EN_MASK          0x20000000
+#define ISP_GPFB_BOD_EN_OFFSET        29
+#define ISP_GPFB_BOD_EN_SIZE          1
+
+#define ISP_CFG                       (*(volatile U32 *)ISP_CFG_ADDRESS)
+#define ISP_CFG_ADDRESS               (AVR32_FLASHC_USER_PAGE_ADDRESS + ISP_CFG_OFFSET)
+#define ISP_CFG_OFFSET                0x000001FC
+#define ISP_CFG_SIZE                  4
+
+#define ISP_CFG_BOOT_KEY              17
+#define ISP_CFG_BOOT_KEY_MASK         0xFFFE0000
+#define ISP_CFG_BOOT_KEY_OFFSET       17
+#define ISP_CFG_BOOT_KEY_SIZE         15
+#define ISP_CFG_BOOT_KEY_VALUE        0x494F
+
+#define ISP_CFG_IO_COND_LEVEL         16
+#define ISP_CFG_IO_COND_LEVEL_MASK    0x00010000
+#define ISP_CFG_IO_COND_LEVEL_OFFSET  16
+#define ISP_CFG_IO_COND_LEVEL_SIZE    1
+
+#define ISP_CFG_IO_COND_PIN           8
+#define ISP_CFG_IO_COND_PIN_MASK      0x0000FF00
+#define ISP_CFG_IO_COND_PIN_OFFSET    8
+#define ISP_CFG_IO_COND_PIN_SIZE      8
+
+#define ISP_CFG_CRC8                  0
+#define ISP_CFG_CRC8_MASK             0x000000FF
+#define ISP_CFG_CRC8_OFFSET           0
+#define ISP_CFG_CRC8_SIZE             8
+#define ISP_CFG_CRC8_POLYNOMIAL       0x107
+
+#define ISP_KEY                       (*(volatile U32 *)ISP_KEY_ADDRESS)
+#define ISP_KEY_ADDRESS               (AVR32_SRAM_ADDRESS + ISP_KEY_OFFSET)
+#define ISP_KEY_OFFSET                0x00000000
+#define ISP_KEY_SIZE                  4
+#define ISP_KEY_VALUE                 ('I' &lt;&lt; 24 | 'S' &lt;&lt; 16 | 'P' &lt;&lt; 8 | 'K')
+
+#ifndef ISP_OSC
+  #define ISP_OSC                     0
+#endif
+
+#define DFU_FRAME_LENGTH              2048
+
+#define PROGRAM_START_ADDRESS         (AVR32_FLASH_ADDRESS + PROGRAM_START_OFFSET)
+#define PROGRAM_START_OFFSET          0x00002000
+
+
+#endif  // _CONF_ISP_H_

Deleted: trunk/src/platform/avr32/evk1100.h
===================================================================
--- trunk/src/platform/avr32/evk1100.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/evk1100.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,354 +0,0 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
-
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief AT32UC3A EVK1100 board header file.
- *
- * This file contains definitions and services related to the features of the
- * EVK1100 board.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 AT32UC3A devices can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _EVK1100_H_
-#define _EVK1100_H_
-
-#include &quot;compiler.h&quot;
-
-//#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
-//#  include &quot;led.h&quot;
-//#endif  // __AVR32_ABI_COMPILER__
-
-
-/*! \name Oscillator Definitions
- */
-//! @{
-
-// RCOsc has no custom calibration by default. Set the following definition to
-// the appropriate value if a custom RCOsc calibration has been applied to your
-// part.
-//#define FRCOSC          AVR32_PM_RCOSC_FREQUENCY              //!&lt; RCOsc frequency: Hz.
-
-#define FOSC32          32768                                 //!&lt; Osc32 frequency: Hz.
-#define OSC32_STARTUP   AVR32_PM_OSCCTRL32_STARTUP_8192_RCOSC //!&lt; Osc32 startup time: RCOsc periods.
-
-#define FOSC0           12000000                              //!&lt; Osc0 frequency: Hz.
-#define OSC0_STARTUP    AVR32_PM_OSCCTRL0_STARTUP_2048_RCOSC  //!&lt; Osc0 startup time: RCOsc periods.
-
-// Osc1 crystal is not mounted by default. Set the following definitions to the
-// appropriate values if a custom Osc1 crystal is mounted on your board.
-//#define FOSC1           12000000                              //!&lt; Osc1 frequency: Hz.
-//#define OSC1_STARTUP    AVR32_PM_OSCCTRL1_STARTUP_2048_RCOSC  //!&lt; Osc1 startup time: RCOsc periods.
-
-//! @}
-
-
-/*! \name SDRAM Definitions
- */
-//! @{
-
-//! Part header file of used SDRAM(s).
-#define SDRAM_PART_HDR  &quot;mt48lc16m16a2tg7e.h&quot;
-
-//! Data bus width to use the SDRAM(s) with (16 or 32 bits; always 16 bits on
-//! UC3).
-#define SDRAM_DBW       16
-
-//! @}
-
-
-/*! \name USB Definitions
- */
-//! @{
-
-//! Multiplexed pin used for USB_ID: AVR32_USBB_USB_ID_x_x.
-//! To be selected according to the AVR32_USBB_USB_ID_x_x_PIN and
-//! AVR32_USBB_USB_ID_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
-#define USB_ID                      AVR32_USBB_USB_ID_0_0
-
-//! Multiplexed pin used for USB_VBOF: AVR32_USBB_USB_VBOF_x_x.
-//! To be selected according to the AVR32_USBB_USB_VBOF_x_x_PIN and
-//! AVR32_USBB_USB_VBOF_x_x_FUNCTION definitions from &lt;avr32/uc3axxxx.h&gt;.
-#ifdef EVK1100_REVA
-#  define USB_VBOF                    AVR32_USBB_USB_VBOF_0_0
-#else
-#  define USB_VBOF                    AVR32_USBB_USB_VBOF_0_1
-#endif
-
-//! Active level of the USB_VBOF output pin.
-#ifdef EVK1100_REVA
-#  define USB_VBOF_ACTIVE_LEVEL       HIGH
-#else
-#  define USB_VBOF_ACTIVE_LEVEL       LOW
-#endif
-
-//! USB overcurrent detection pin.
-#ifdef EVK1100_REVA
-#  define USB_OVERCURRENT_DETECT_PIN  AVR32_PIN_PB18
-#else
-#  define USB_OVERCURRENT_DETECT_PIN  AVR32_PIN_PX33
-#endif
-
-//! @}
-
-
-//! GPIO connection of the MAC PHY PWR_DOWN/INT signal.
-#ifdef EVK1100_REVA
-#  define MACB_INTERRUPT_PIN  AVR32_PIN_PX12
-#else
-#  define MACB_INTERRUPT_PIN  AVR32_PIN_PA24
-#endif
-
-
-//! Number of LEDs.
-#define LED_COUNT   8
-
-/*! \name GPIO Connections of LEDs
- */
-//! @{
-#ifdef EVK1100_REVA
-#  define LED0_GPIO   AVR32_PIN_PX13
-#  define LED1_GPIO   AVR32_PIN_PX14
-#  define LED2_GPIO   AVR32_PIN_PX15
-#  define LED3_GPIO   AVR32_PIN_PX16
-#  define LED4_GPIO   AVR32_PIN_PB19
-#  define LED5_GPIO   AVR32_PIN_PB20
-#  define LED6_GPIO   AVR32_PIN_PB21
-#  define LED7_GPIO   AVR32_PIN_PB22
-#else
-#  define LED0_GPIO   AVR32_PIN_PB27
-#  define LED1_GPIO   AVR32_PIN_PB28
-#  define LED2_GPIO   AVR32_PIN_PB29
-#  define LED3_GPIO   AVR32_PIN_PB30
-#  define LED4_GPIO   AVR32_PIN_PB19
-#  define LED5_GPIO   AVR32_PIN_PB20
-#  define LED6_GPIO   AVR32_PIN_PB21
-#  define LED7_GPIO   AVR32_PIN_PB22
-#endif
-//! @}
-
-/*! \name PWM Channels of LEDs
- */
-//! @{
-#define LED0_PWM    (-1)
-#define LED1_PWM    (-1)
-#define LED2_PWM    (-1)
-#define LED3_PWM    (-1)
-#define LED4_PWM      0
-#define LED5_PWM      1
-#define LED6_PWM      2
-#define LED7_PWM      3
-//! @}
-
-/*! \name PWM Functions of LEDs
- */
-//! @{
-#define LED0_PWM_FUNCTION   (-1)
-#define LED1_PWM_FUNCTION   (-1)
-#define LED2_PWM_FUNCTION   (-1)
-#define LED3_PWM_FUNCTION   (-1)
-#define LED4_PWM_FUNCTION   AVR32_PWM_0_FUNCTION
-#define LED5_PWM_FUNCTION   AVR32_PWM_1_FUNCTION
-#define LED6_PWM_FUNCTION   AVR32_PWM_2_FUNCTION
-#define LED7_PWM_FUNCTION   AVR32_PWM_3_FUNCTION
-//! @}
-
-/*! \name Color Identifiers of LEDs to Use with LED Functions
- */
-//! @{
-#ifdef EVK1100_REVA
-#  define LED_MONO0_GREEN   LED4
-#  define LED_MONO1_GREEN   LED5
-#  define LED_MONO2_GREEN   LED6
-#  define LED_MONO3_GREEN   LED7
-#  define LED_BI0_GREEN     LED1
-#  define LED_BI0_RED       LED0
-#  define LED_BI1_GREEN     LED3
-#  define LED_BI1_RED       LED2
-#else
-#  define LED_MONO0_GREEN   LED0
-#  define LED_MONO1_GREEN   LED1
-#  define LED_MONO2_GREEN   LED2
-#  define LED_MONO3_GREEN   LED3
-#  define LED_BI0_GREEN     LED5
-#  define LED_BI0_RED       LED4
-#  define LED_BI1_GREEN     LED7
-#  define LED_BI1_RED       LED6
-#endif
-//! @}
-
-
-/*! \name GPIO Connections of Push Buttons
- */
-//! @{
-#ifdef EVK1100_REVA
-#  define GPIO_PUSH_BUTTON_0    AVR32_PIN_PB28
-#  define GPIO_PUSH_BUTTON_1    AVR32_PIN_PB29
-#  define GPIO_PUSH_BUTTON_2    AVR32_PIN_PB27
-#else
-#  define GPIO_PUSH_BUTTON_0    AVR32_PIN_PX16
-#  define GPIO_PUSH_BUTTON_1    AVR32_PIN_PX19
-#  define GPIO_PUSH_BUTTON_2    AVR32_PIN_PX22
-#endif
-//! @}
-
-
-/*! \name GPIO Connections of the Joystick
- */
-//! @{
-#define GPIO_JOYSTICK_PUSH    AVR32_PIN_PA20
-#define GPIO_JOYSTICK_LEFT    AVR32_PIN_PA25
-#define GPIO_JOYSTICK_RIGHT   AVR32_PIN_PA28
-#define GPIO_JOYSTICK_UP      AVR32_PIN_PA26
-#define GPIO_JOYSTICK_DOWN    AVR32_PIN_PA27
-//! @}
-
-
-/*! \name ADC Connection of the Potentiometer
- */
-//! @{
-#define ADC_POTENTIOMETER_CHANNEL   1
-#define ADC_POTENTIOMETER_PIN       AVR32_ADC_AD_1_PIN
-#define ADC_POTENTIOMETER_FUNCTION  AVR32_ADC_AD_1_FUNCTION
-//! @}
-
-
-/*! \name ADC Connection of the Temperature Sensor
- */
-//! @{
-#define ADC_TEMPERATURE_CHANNEL     0
-#define ADC_TEMPERATURE_PIN         AVR32_ADC_AD_0_PIN
-#define ADC_TEMPERATURE_FUNCTION    AVR32_ADC_AD_0_FUNCTION
-//! @}
-
-
-/*! \name ADC Connection of the Light Sensor
- */
-//! @{
-#define ADC_LIGHT_CHANNEL           2
-#define ADC_LIGHT_PIN               AVR32_ADC_AD_2_PIN
-#define ADC_LIGHT_FUNCTION          AVR32_ADC_AD_2_FUNCTION
-//! @}
-
-
-/*! \name SPI Connections of the DIP204 LCD
- */
-//! @{
-#define DIP204_SPI                  (&amp;AVR32_SPI1)
-#define DIP204_SPI_NPCS             2
-#define DIP204_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
-#define DIP204_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
-#define DIP204_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
-#define DIP204_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
-#define DIP204_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
-#define DIP204_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
-#define DIP204_SPI_NPCS_PIN         AVR32_SPI1_NPCS_2_0_PIN
-#define DIP204_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_2_0_FUNCTION
-//! @}
-
-/*! \name GPIO and PWM Connections of the DIP204 LCD Backlight
- */
-//! @{
-#define DIP204_BACKLIGHT_PIN        AVR32_PIN_PB18
-#define DIP204_PWM_CHANNEL          6
-#define DIP204_PWM_PIN              AVR32_PWM_6_PIN
-#define DIP204_PWM_FUNCTION         AVR32_PWM_6_FUNCTION
-//! @}
-
-
-/*! \name SPI Connections of the AT45DBX Data Flash Memory
- */
-//! @{
-#define AT45DBX_SPI                 (&amp;AVR32_SPI1)
-#define AT45DBX_SPI_SCK_PIN         AVR32_SPI1_SCK_0_0_PIN
-#define AT45DBX_SPI_SCK_FUNCTION    AVR32_SPI1_SCK_0_0_FUNCTION
-#define AT45DBX_SPI_MISO_PIN        AVR32_SPI1_MISO_0_0_PIN
-#define AT45DBX_SPI_MISO_FUNCTION   AVR32_SPI1_MISO_0_0_FUNCTION
-#define AT45DBX_SPI_MOSI_PIN        AVR32_SPI1_MOSI_0_0_PIN
-#define AT45DBX_SPI_MOSI_FUNCTION   AVR32_SPI1_MOSI_0_0_FUNCTION
-#define AT45DBX_SPI_NPCS0_PIN       AVR32_SPI1_NPCS_0_0_PIN
-#define AT45DBX_SPI_NPCS0_FUNCTION  AVR32_SPI1_NPCS_0_0_FUNCTION
-//! @}
-
-
-/*! \name GPIO and SPI Connections of the SD/MMC Connector
- */
-//! @{
-#define SD_MMC_CARD_DETECT_PIN      AVR32_PIN_PA02
-#define SD_MMC_WRITE_PROTECT_PIN    AVR32_PIN_PA07
-#define SD_MMC_SPI                  (&amp;AVR32_SPI1)
-#define SD_MMC_SPI_NPCS             1
-#define SD_MMC_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
-#define SD_MMC_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
-#define SD_MMC_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
-#define SD_MMC_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
-#define SD_MMC_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
-#define SD_MMC_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
-#define SD_MMC_SPI_NPCS_PIN         AVR32_SPI1_NPCS_1_0_PIN
-#define SD_MMC_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_1_0_FUNCTION
-//! @}
-
-
-/*! \name TWI Connections of the Spare TWI Connector
- */
-//! @{
-#define SPARE_TWI                   (&amp;AVR32_TWI)
-#define SPARE_TWI_SCL_PIN           AVR32_TWI_SCL_0_0_PIN
-#define SPARE_TWI_SCL_FUNCTION      AVR32_TWI_SCL_0_0_FUNCTION
-#define SPARE_TWI_SDA_PIN           AVR32_TWI_SDA_0_0_PIN
-#define SPARE_TWI_SDA_FUNCTION      AVR32_TWI_SDA_0_0_FUNCTION
-//! @}
-
-
-/*! \name SPI Connections of the Spare SPI Connector
- */
-//! @{
-#define SPARE_SPI                   (&amp;AVR32_SPI0)
-#define SPARE_SPI_NPCS              0
-#define SPARE_SPI_SCK_PIN           AVR32_SPI0_SCK_0_0_PIN
-#define SPARE_SPI_SCK_FUNCTION      AVR32_SPI0_SCK_0_0_FUNCTION
-#define SPARE_SPI_MISO_PIN          AVR32_SPI0_MISO_0_0_PIN
-#define SPARE_SPI_MISO_FUNCTION     AVR32_SPI0_MISO_0_0_FUNCTION
-#define SPARE_SPI_MOSI_PIN          AVR32_SPI0_MOSI_0_0_PIN
-#define SPARE_SPI_MOSI_FUNCTION     AVR32_SPI0_MOSI_0_0_FUNCTION
-#define SPARE_SPI_NPCS_PIN          AVR32_SPI0_NPCS_0_0_PIN
-#define SPARE_SPI_NPCS_FUNCTION     AVR32_SPI0_NPCS_0_0_FUNCTION
-//! @}
-
-
-#endif  // _EVK1100_H_

Modified: trunk/src/platform/avr32/exception.s
===================================================================
--- trunk/src/platform/avr32/exception.s	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/exception.s	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,14 +1,14 @@
-/* This file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
 /*This file is prepared for Doxygen automatic documentation generation.*/
 /*! \file *********************************************************************
  *
  * \brief Exception and interrupt vectors.
  *
- * This file maps all events supported by an AVR32UC.
+ * This file maps all events supported by an AVR32.
  *
  * - Compiler:           GNU GCC for AVR32
- * - Supported devices:  All AVR32UC devices with an INTC module can be used.
+ * - Supported devices:  All AVR32 devices with an INTC module can be used.
  * - AppNote:
  *
  * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
@@ -16,34 +16,42 @@
  *
  ******************************************************************************/
 
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following disclaimer in the documentation
  * and/or other materials provided with the distribution.
  *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * 3. The name of Atmel may not be used to endorse or promote products derived
  * from this software without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
  */
 
+#if !__AVR32_UC__ &amp;&amp; !__AVR32_AP__
+  #error Implementation of the AVR32 architecture not supported by the INTC driver.
+#endif
 
+
 #include &lt;avr32/io.h&gt;
 
 
@@ -71,7 +79,7 @@
         rjmp $
 
         .org  0x004
-        // TLB Multiple Hit: UNUSED IN AVR32UC.
+        // TLB Multiple Hit.
 _handle_TLB_Multiple_Hit:
         rjmp $
 
@@ -121,7 +129,7 @@
         rjmp $
 
         .org  0x02C
-        // Floating-Point: UNUSED IN AVR32UC.
+        // Floating-Point: UNUSED IN AVR32UC and AVR32AP.
 _handle_Floating_Point:
         rjmp $
 
@@ -156,17 +164,17 @@
         rjmp $
 
         .org  0x050
-        // ITLB Miss: UNUSED IN AVR32UC.
+        // ITLB Miss.
 _handle_ITLB_Miss:
         rjmp $
 
         .org  0x060
-        // DTLB Miss (Read): UNUSED IN AVR32UC.
+        // DTLB Miss (Read).
 _handle_DTLB_Miss_Read:
         rjmp $
 
         .org  0x070
-        // DTLB Miss (Write): UNUSED IN AVR32UC.
+        // DTLB Miss (Write).
 _handle_DTLB_Miss_Write:
         rjmp $
 
@@ -185,43 +193,32 @@
 
   .balign 4
 
-_int0:
+  .irp    priority, 0, 1, 2, 3
+_int\priority:
+#if __AVR32_UC__
   // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
-  // CPU upon interrupt entry.
-  mov     r12, 0  // Pass the int_lev parameter to the _get_interrupt_handler function.
+  // CPU upon interrupt entry. No other register is saved by hardware.
+#elif __AVR32_AP__
+  // PC and SR are automatically saved in respectively RAR_INTx and RSR_INTx by
+  // the CPU upon interrupt entry. No other register is saved by hardware.
+  pushm   r8-r12, lr
+#endif
+  mov     r12, \priority  // Pass the int_level parameter to the _get_interrupt_handler function.
   call    _get_interrupt_handler
-  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
-  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
-  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
+  cp.w    r12, 0          // Get the pointer to the interrupt handler returned by the function.
+#if __AVR32_UC__
+  movne   pc, r12         // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
+#elif __AVR32_AP__
+  breq    spint\priority  // If this was a spurious interrupt (R12 == NULL), branch.
+  st.w    --sp, r12       // Push the pointer to the interrupt handler onto the system stack since no register may be altered.
+  popm    r8-r12, lr, pc  // Restore registers and jump to the handler.
+spint\priority:
+  popm    r8-r12, lr
+#endif
+  rete                    // If this was a spurious interrupt (R12 == NULL), return from event handler.
+  .endr
 
-_int1:
-  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
-  // CPU upon interrupt entry.
-  mov     r12, 1  // Pass the int_lev parameter to the _get_interrupt_handler function.
-  call    _get_interrupt_handler
-  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
-  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
-  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
 
-_int2:
-  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
-  // CPU upon interrupt entry.
-  mov     r12, 2  // Pass the int_lev parameter to the _get_interrupt_handler function.
-  call    _get_interrupt_handler
-  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
-  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
-  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
-
-_int3:
-  // R8-R12, LR, PC and SR are automatically pushed onto the system stack by the
-  // CPU upon interrupt entry.
-  mov     r12, 3  // Pass the int_lev parameter to the _get_interrupt_handler function.
-  call    _get_interrupt_handler
-  cp.w    r12, 0  // Get the pointer to the interrupt handler returned by the function.
-  movne   pc, r12 // If this was not a spurious interrupt (R12 != NULL), jump to the handler.
-  rete            // If this was a spurious interrupt (R12 == NULL), return from event handler.
-
-
 // Constant data area.
 
   .balign 4
@@ -232,10 +229,10 @@
   .global ipr_val
   .type ipr_val, @object
 ipr_val:
-  .word (AVR32_INTC_INT0 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int0 - _evba),\
-        (AVR32_INTC_INT1 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int1 - _evba),\
-        (AVR32_INTC_INT2 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int2 - _evba),\
-        (AVR32_INTC_INT3 &lt;&lt; AVR32_INTC_IPR_INTLEV_OFFSET) | (_int3 - _evba)
+  .word (AVR32_INTC_INT0 &lt;&lt; AVR32_INTC_IPR_INTLEVEL_OFFSET) | (_int0 - _evba),\
+        (AVR32_INTC_INT1 &lt;&lt; AVR32_INTC_IPR_INTLEVEL_OFFSET) | (_int1 - _evba),\
+        (AVR32_INTC_INT2 &lt;&lt; AVR32_INTC_IPR_INTLEVEL_OFFSET) | (_int2 - _evba),\
+        (AVR32_INTC_INT3 &lt;&lt; AVR32_INTC_IPR_INTLEVEL_OFFSET) | (_int3 - _evba)
 
 
 //! \endverbatim

Modified: trunk/src/platform/avr32/flashc.c
===================================================================
--- trunk/src/platform/avr32/flashc.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/flashc.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,1057 +1,1118 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief FLASHC driver for AVR32 UC3.
- *
- * AVR32 Flash Controller driver module.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a FLASHC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &lt;avr32/io.h&gt;
-#include &lt;stddef.h&gt;
-#include &quot;compiler.h&quot;
-#include &quot;flashc.h&quot;
-
-
-/*! \name FLASHC Writable Bit-Field Registers
- */
-//! @{
-
-typedef union
-{
-  unsigned long                 fcr;
-  avr32_flashc_fcr_t            FCR;
-} u_avr32_flashc_fcr_t;
-
-typedef union
-{
-  unsigned long                 fcmd;
-  avr32_flashc_fcmd_t           FCMD;
-} u_avr32_flashc_fcmd_t;
-
-//! @}
-
-
-/*! \name Flash Properties
- */
-//! @{
-
-
-unsigned int flashc_get_flash_size(void)
-{
-  static const unsigned int FLASH_SIZE[1 &lt;&lt; AVR32_FLASHC_FSR_FSZ_SIZE] =
-  {
-      32 &lt;&lt; 10,
-      64 &lt;&lt; 10,
-     128 &lt;&lt; 10,
-     256 &lt;&lt; 10,
-     384 &lt;&lt; 10,
-     512 &lt;&lt; 10,
-     768 &lt;&lt; 10,
-    1024 &lt;&lt; 10
-  };
-  return FLASH_SIZE[(AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FSZ_MASK) &gt;&gt; AVR32_FLASHC_FSR_FSZ_OFFSET];
-}
-
-
-unsigned int flashc_get_page_count(void)
-{
-  return flashc_get_flash_size() / AVR32_FLASHC_PAGE_SIZE;
-}
-
-
-unsigned int flashc_get_page_count_per_region(void)
-{
-  return flashc_get_page_count() / AVR32_FLASHC_REGIONS;
-}
-
-
-unsigned int flashc_get_page_region(int page_number)
-{
-  return ((page_number &gt;= 0) ? page_number : flashc_get_page_number()) / flashc_get_page_count_per_region();
-}
-
-
-unsigned int flashc_get_region_first_page_number(unsigned int region)
-{
-  return region * flashc_get_page_count_per_region();
-}
-
-
-//! @}
-
-
-/*! \name FLASHC Control
- */
-//! @{
-
-
-unsigned int flashc_get_wait_state(void)
-{
-  return (AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FWS_MASK) &gt;&gt; AVR32_FLASHC_FCR_FWS_OFFSET;
-}
-
-
-void flashc_set_wait_state(unsigned int wait_state)
-{
-  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
-  u_avr32_flashc_fcr.FCR.fws = wait_state;
-  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
-}
-
-
-Bool flashc_is_ready_int_enabled(void)
-{
-  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FRDY_MASK) != 0);
-}
-
-
-void flashc_enable_ready_int(Bool enable)
-{
-  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
-  u_avr32_flashc_fcr.FCR.frdy = (enable != FALSE);
-  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
-}
-
-
-Bool flashc_is_lock_error_int_enabled(void)
-{
-  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_LOCKE_MASK) != 0);
-}
-
-
-void flashc_enable_lock_error_int(Bool enable)
-{
-  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
-  u_avr32_flashc_fcr.FCR.locke = (enable != FALSE);
-  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
-}
-
-
-Bool flashc_is_prog_error_int_enabled(void)
-{
-  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_PROGE_MASK) != 0);
-}
-
-
-void flashc_enable_prog_error_int(Bool enable)
-{
-  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
-  u_avr32_flashc_fcr.FCR.proge = (enable != FALSE);
-  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
-}
-
-
-//! @}
-
-
-/*! \name FLASHC Status
- */
-//! @{
-
-
-Bool flashc_is_ready(void)
-{
-  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FRDY_MASK) != 0);
-}
-
-
-void flashc_default_wait_until_ready(void)
-{
-  while (!flashc_is_ready());
-}
-
-
-void (*volatile flashc_wait_until_ready)(void) = flashc_default_wait_until_ready;
-
-
-/*! \brief Gets the error status of the FLASHC.
- *
- * \return The error status of the FLASHC built up from
- *         \c AVR32_FLASHC_FSR_LOCKE_MASK and \c AVR32_FLASHC_FSR_PROGE_MASK.
- *
- * \warning This hardware error status is cleared by all functions reading the
- *          Flash Status Register (FSR). This function is therefore not part of
- *          the driver's API which instead presents \ref flashc_is_lock_error
- *          and \ref flashc_is_programming_error.
- */
-static unsigned int flashc_get_error_status(void)
-{
-  return AVR32_FLASHC.fsr &amp; (AVR32_FLASHC_FSR_LOCKE_MASK |
-                             AVR32_FLASHC_FSR_PROGE_MASK);
-}
-
-
-//! Sticky error status of the FLASHC.
-//! This variable is updated by functions that issue FLASHC commands. It
-//! contains the cumulated FLASHC error status of all the FLASHC commands issued
-//! by a function.
-static unsigned int flashc_error_status = 0;
-
-
-Bool flashc_is_lock_error(void)
-{
-  return ((flashc_error_status &amp; AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
-}
-
-
-Bool flashc_is_programming_error(void)
-{
-  return ((flashc_error_status &amp; AVR32_FLASHC_FSR_PROGE_MASK) != 0);
-}
-
-
-//! @}
-
-
-/*! \name FLASHC Command Control
- */
-//! @{
-
-
-unsigned int flashc_get_command(void)
-{
-  return (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_CMD_MASK) &gt;&gt; AVR32_FLASHC_FCMD_CMD_OFFSET;
-}
-
-
-unsigned int flashc_get_page_number(void)
-{
-  return (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_PAGEN_MASK) &gt;&gt; AVR32_FLASHC_FCMD_PAGEN_OFFSET;
-}
-
-
-void flashc_issue_command(unsigned int command, int page_number)
-{
-  u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;
-  flashc_wait_until_ready();
-  u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
-  u_avr32_flashc_fcmd.FCMD.cmd = command;
-  if (page_number &gt;= 0) u_avr32_flashc_fcmd.FCMD.pagen = page_number;
-  u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
-  AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
-  flashc_error_status = flashc_get_error_status();
-  flashc_wait_until_ready();
-}
-
-
-//! @}
-
-
-/*! \name FLASHC Global Commands
- */
-//! @{
-
-
-void flashc_no_operation(void)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_NOP, -1);
-}
-
-
-void flashc_erase_all(void)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EA, -1);
-}
-
-
-//! @}
-
-
-/*! \name FLASHC Protection Mechanisms
- */
-//! @{
-
-
-Bool flashc_is_security_bit_active(void)
-{
-  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_SECURITY_MASK) != 0);
-}
-
-
-void flashc_activate_security_bit(void)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_SSB, -1);
-}
-
-
-unsigned int flashc_get_bootloader_protected_size(void)
-{
-  unsigned int bootprot = (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
-                          flashc_read_gp_fuse_bitfield(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
-                                                       AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE);
-  return (bootprot) ? AVR32_FLASHC_PAGE_SIZE &lt;&lt; bootprot : 0;
-}
-
-
-unsigned int flashc_set_bootloader_protected_size(unsigned int bootprot_size)
-{
-  flashc_set_gp_fuse_bitfield(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
-                              AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE,
-                              (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
-                              ((bootprot_size) ?
-                               32 - clz((((min(max(bootprot_size, AVR32_FLASHC_PAGE_SIZE &lt;&lt; 1),
-                                               AVR32_FLASHC_PAGE_SIZE &lt;&lt;
-                                               ((1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1)) +
-                                           AVR32_FLASHC_PAGE_SIZE - 1) /
-                                          AVR32_FLASHC_PAGE_SIZE) &lt;&lt; 1) - 1) - 1 :
-                               0));
-  return flashc_get_bootloader_protected_size();
-}
-
-
-Bool flashc_is_external_privileged_fetch_locked(void)
-{
-  return (!flashc_read_gp_fuse_bit(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET));
-}
-
-
-void flashc_lock_external_privileged_fetch(Bool lock)
-{
-  flashc_set_gp_fuse_bit(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET, !lock);
-}
-
-
-Bool flashc_is_page_region_locked(int page_number)
-{
-  return flashc_is_region_locked(flashc_get_page_region(page_number));
-}
-
-
-Bool flashc_is_region_locked(unsigned int region)
-{
-  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_LOCK0_MASK &lt;&lt; (region &amp; (AVR32_FLASHC_REGIONS - 1))) != 0);
-}
-
-
-void flashc_lock_page_region(int page_number, Bool lock)
-{
-  flashc_issue_command((lock) ? AVR32_FLASHC_FCMD_CMD_LP : AVR32_FLASHC_FCMD_CMD_UP, page_number);
-}
-
-
-void flashc_lock_region(unsigned int region, Bool lock)
-{
-  flashc_lock_page_region(flashc_get_region_first_page_number(region), lock);
-}
-
-
-void flashc_lock_all_regions(Bool lock)
-{
-  unsigned int error_status = 0;
-  unsigned int region = AVR32_FLASHC_REGIONS;
-  while (region)
-  {
-    flashc_lock_region(--region, lock);
-    error_status |= flashc_error_status;
-  }
-  flashc_error_status = error_status;
-}
-
-
-//! @}
-
-
-/*! \name Access to General-Purpose Fuses
- */
-//! @{
-
-
-Bool flashc_read_gp_fuse_bit(unsigned int gp_fuse_bit)
-{
-  return ((flashc_read_all_gp_fuses() &amp; 1ULL &lt;&lt; (gp_fuse_bit &amp; 0x3F)) != 0);
-}
-
-
-U64 flashc_read_gp_fuse_bitfield(unsigned int pos, unsigned int width)
-{
-  return flashc_read_all_gp_fuses() &gt;&gt; (pos &amp; 0x3F) &amp; ((1ULL &lt;&lt; min(width, 64)) - 1);
-}
-
-
-U8 flashc_read_gp_fuse_byte(unsigned int gp_fuse_byte)
-{
-  return flashc_read_all_gp_fuses() &gt;&gt; ((gp_fuse_byte &amp; 0x07) &lt;&lt; 3);
-}
-
-
-U64 flashc_read_all_gp_fuses(void)
-{
-  return AVR32_FLASHC.fgpfrlo | (U64)AVR32_FLASHC.fgpfrhi &lt;&lt; 32;
-}
-
-
-Bool flashc_erase_gp_fuse_bit(unsigned int gp_fuse_bit, Bool check)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EGPB, gp_fuse_bit &amp; 0x3F);
-  return (check) ? flashc_read_gp_fuse_bit(gp_fuse_bit) : TRUE;
-}
-
-
-Bool flashc_erase_gp_fuse_bitfield(unsigned int pos, unsigned int width, Bool check)
-{
-  unsigned int error_status = 0;
-  unsigned int gp_fuse_bit;
-  pos &amp;= 0x3F;
-  width = min(width, 64);
-  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++)
-  {
-    flashc_erase_gp_fuse_bit(gp_fuse_bit, FALSE);
-    error_status |= flashc_error_status;
-  }
-  flashc_error_status = error_status;
-  return (check) ? (flashc_read_gp_fuse_bitfield(pos, width) == (1ULL &lt;&lt; width) - 1) : TRUE;
-}
-
-
-Bool flashc_erase_gp_fuse_byte(unsigned int gp_fuse_byte, Bool check)
-{
-  unsigned int error_status;
-  unsigned int current_gp_fuse_byte;
-  U64 value = flashc_read_all_gp_fuses();
-  flashc_erase_all_gp_fuses(FALSE);
-  error_status = flashc_error_status;
-  for (current_gp_fuse_byte = 0; current_gp_fuse_byte &lt; 8; current_gp_fuse_byte++, value &gt;&gt;= 8)
-  {
-    if (current_gp_fuse_byte != gp_fuse_byte)
-    {
-      flashc_write_gp_fuse_byte(current_gp_fuse_byte, value);
-      error_status |= flashc_error_status;
-    }
-  }
-  flashc_error_status = error_status;
-  return (check) ? (flashc_read_gp_fuse_byte(gp_fuse_byte) == 0xFF) : TRUE;
-}
-
-
-Bool flashc_erase_all_gp_fuses(Bool check)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EAGPF, -1);
-  return (check) ? (flashc_read_all_gp_fuses() == 0xFFFFFFFFFFFFFFFFULL) : TRUE;
-}
-
-
-void flashc_write_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value)
-{
-  if (!value)
-    flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WGPB, gp_fuse_bit &amp; 0x3F);
-}
-
-
-void flashc_write_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value)
-{
-  unsigned int error_status = 0;
-  unsigned int gp_fuse_bit;
-  pos &amp;= 0x3F;
-  width = min(width, 64);
-  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
-  {
-    flashc_write_gp_fuse_bit(gp_fuse_bit, value &amp; 0x01);
-    error_status |= flashc_error_status;
-  }
-  flashc_error_status = error_status;
-}
-
-
-void flashc_write_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_PGPFB, (gp_fuse_byte &amp; 0x07) | value &lt;&lt; 3);
-}
-
-
-void flashc_write_all_gp_fuses(U64 value)
-{
-  unsigned int error_status = 0;
-  unsigned int gp_fuse_byte;
-  for (gp_fuse_byte = 0; gp_fuse_byte &lt; 8; gp_fuse_byte++, value &gt;&gt;= 8)
-  {
-    flashc_write_gp_fuse_byte(gp_fuse_byte, value);
-    error_status |= flashc_error_status;
-  }
-  flashc_error_status = error_status;
-}
-
-
-void flashc_set_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value)
-{
-  if (value)
-    flashc_erase_gp_fuse_bit(gp_fuse_bit, FALSE);
-  else
-    flashc_write_gp_fuse_bit(gp_fuse_bit, FALSE);
-}
-
-
-void flashc_set_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value)
-{
-  unsigned int error_status = 0;
-  unsigned int gp_fuse_bit;
-  pos &amp;= 0x3F;
-  width = min(width, 64);
-  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
-  {
-    flashc_set_gp_fuse_bit(gp_fuse_bit, value &amp; 0x01);
-    error_status |= flashc_error_status;
-  }
-  flashc_error_status = error_status;
-}
-
-
-void flashc_set_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value)
-{
-  unsigned int error_status;
-  switch (value)
-  {
-  case 0xFF:
-    flashc_erase_gp_fuse_byte(gp_fuse_byte, FALSE);
-    break;
-  case 0x00:
-    flashc_write_gp_fuse_byte(gp_fuse_byte, 0x00);
-    break;
-  default:
-    flashc_erase_gp_fuse_byte(gp_fuse_byte, FALSE);
-    error_status = flashc_error_status;
-    flashc_write_gp_fuse_byte(gp_fuse_byte, value);
-    flashc_error_status |= error_status;
-  }
-}
-
-
-void flashc_set_all_gp_fuses(U64 value)
-{
-  unsigned int error_status;
-  switch (value)
-  {
-  case 0xFFFFFFFFFFFFFFFFULL:
-    flashc_erase_all_gp_fuses(FALSE);
-    break;
-  case 0x0000000000000000ULL:
-    flashc_write_all_gp_fuses(0x0000000000000000ULL);
-    break;
-  default:
-    flashc_erase_all_gp_fuses(FALSE);
-    error_status = flashc_error_status;
-    flashc_write_all_gp_fuses(value);
-    flashc_error_status |= error_status;
-  }
-}
-
-
-//! @}
-
-
-/*! \name Access to Flash Pages
- */
-//! @{
-
-
-void flashc_clear_page_buffer(void)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
-}
-
-
-Bool flashc_is_page_erased(void)
-{
-  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_QPRR_MASK) != 0);
-}
-
-
-Bool flashc_quick_page_read(int page_number)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
-  return flashc_is_page_erased();
-}
-
-
-Bool flashc_erase_page(int page_number, Bool check)
-{
-  Bool page_erased = TRUE;
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
-  if (check)
-  {
-    unsigned int error_status = flashc_error_status;
-    page_erased = flashc_quick_page_read(-1);
-    flashc_error_status |= error_status;
-  }
-  return page_erased;
-}
-
-
-Bool flashc_erase_all_pages(Bool check)
-{
-  Bool all_pages_erased = TRUE;
-  unsigned int error_status = 0;
-  unsigned int page_number = flashc_get_page_count();
-  while (page_number)
-  {
-    all_pages_erased &amp;= flashc_erase_page(--page_number, check);
-    error_status |= flashc_error_status;
-  }
-  flashc_error_status = error_status;
-  return all_pages_erased;
-}
-
-
-void flashc_write_page(int page_number)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
-}
-
-
-Bool flashc_quick_user_page_read(void)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
-  return flashc_is_page_erased();
-}
-
-
-Bool flashc_erase_user_page(Bool check)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
-  return (check) ? flashc_quick_user_page_read() : TRUE;
-}
-
-
-void flashc_write_user_page(void)
-{
-  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
-}
-
-
-volatile void *flashc_memset8(volatile void *dst, U8 src, size_t nbytes, Bool erase)
-{
-  return flashc_memset16(dst, src | (U16)src &lt;&lt; 8, nbytes, erase);
-}
-
-
-volatile void *flashc_memset16(volatile void *dst, U16 src, size_t nbytes, Bool erase)
-{
-  return flashc_memset32(dst, src | (U32)src &lt;&lt; 16, nbytes, erase);
-}
-
-
-volatile void *flashc_memset32(volatile void *dst, U32 src, size_t nbytes, Bool erase)
-{
-  return flashc_memset64(dst, src | (U64)src &lt;&lt; 32, nbytes, erase);
-}
-
-
-volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase)
-{
-  // Use aggregated pointers to have several alignments available for a same address.
-  UnionCVPtr flash_array_end;
-  UnionVPtr dest;
-  Union64 source = {0};
-  StructCVPtr dest_end;
-  UnionCVPtr flash_page_source_end;
-  Bool incomplete_flash_page_end;
-  Union64 flash_dword;
-  UnionVPtr tmp;
-  unsigned int error_status = 0;
-  unsigned int i;
-
-  // Reformat arguments.
-  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
-  dest.u8ptr = dst;
-  for (i = (Get_align((U32)dest.u8ptr, sizeof(U64)) - 1) &amp; (sizeof(U64) - 1);
-       src; i = (i - 1) &amp; (sizeof(U64) - 1))
-  {
-    source.u8[i] = src;
-    src &gt;&gt;= 8;
-  }
-  dest_end.u8ptr = dest.u8ptr + nbytes;
-
-  // If destination is outside flash, go to next flash page if any.
-  if (dest.u8ptr &lt; AVR32_FLASH)
-  {
-    dest.u8ptr = AVR32_FLASH;
-  }
-  else if (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
-  {
-    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
-  }
-
-  // If end of destination is outside flash, move it to the end of the previous flash page if any.
-  if (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
-  {
-    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
-  }
-  else if (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
-  {
-    dest_end.u8ptr = flash_array_end.u8ptr;
-  }
-
-  // Align each end of destination pointer with its natural boundary.
-  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
-  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
-  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
-
-  // While end of destination is not reached...
-  while (dest.u8ptr &lt; dest_end.u8ptr)
-  {
-    // Clear the page buffer in order to prepare data for a flash page write.
-    flashc_clear_page_buffer();
-    error_status |= flashc_error_status;
-
-    // Determine where the source data will end in the current flash page.
-    flash_page_source_end.u64ptr =
-      (U64 *)min((U32)dest_end.u64ptr,
-                 Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
-
-    // Determine if the current destination page has an incomplete end.
-    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
-                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
-
-    // Use a flash double-word buffer to manage unaligned accesses.
-    flash_dword.u64 = source.u64;
-
-    // If destination does not point to the beginning of the current flash page...
-    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
-    {
-      // Fill the beginning of the page buffer with the current flash page data.
-      // This is required by the hardware, even if page erase is not requested,
-      // in order to be able to write successfully to erased parts of flash
-      // pages that have already been written to.
-      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
-           tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
-           tmp.u64ptr++)
-        *tmp.u64ptr = *tmp.u64ptr;
-
-      // If destination is not 64-bit aligned...
-      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
-      {
-        // Fill the beginning of the flash double-word buffer with the current
-        // flash page data.
-        // This is required by the hardware, even if page erase is not
-        // requested, in order to be able to write successfully to erased parts
-        // of flash pages that have already been written to.
-        for (i = 0; i &lt; Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
-          flash_dword.u8[i] = *tmp.u8ptr++;
-
-        // Align the destination pointer with its 64-bit boundary.
-        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
-
-        // If the current destination double-word is not the last one...
-        if (dest.u64ptr &lt; dest_end.u64ptr)
-        {
-          // Write the flash double-word buffer to the page buffer and reinitialize it.
-          *dest.u64ptr++ = flash_dword.u64;
-          flash_dword.u64 = source.u64;
-        }
-      }
-    }
-
-    // Write the source data to the page buffer with 64-bit alignment.
-    for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
-      *dest.u64ptr++ = source.u64;
-
-    // If the current destination page has an incomplete end...
-    if (incomplete_flash_page_end)
-    {
-      // This is required by the hardware, even if page erase is not requested,
-      // in order to be able to write successfully to erased parts of flash
-      // pages that have already been written to.
-      {
-        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
-
-        // If end of destination is not 64-bit aligned...
-        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
-        {
-          // Fill the end of the flash double-word buffer with the current flash page data.
-          for (i = Get_align((U32)dest_end.u8ptr, sizeof(U64)); i &lt; sizeof(U64); i++)
-            flash_dword.u8[i] = *tmp.u8ptr++;
-
-          // Write the flash double-word buffer to the page buffer.
-          *dest.u64ptr++ = flash_dword.u64;
-        }
-
-        // Fill the end of the page buffer with the current flash page data.
-        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
-          *tmp.u64ptr = *tmp.u64ptr;
-      }
-    }
-
-    // If the current flash page is in the flash array...
-    if (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
-    {
-      // Erase the current page if requested and write it from the page buffer.
-      if (erase)
-      {
-        flashc_erase_page(-1, FALSE);
-        error_status |= flashc_error_status;
-      }
-      flashc_write_page(-1);
-      error_status |= flashc_error_status;
-
-      // If the end of the flash array is reached, go to the User page.
-      if (dest.u8ptr &gt;= flash_array_end.u8ptr)
-        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
-    }
-    // If the current flash page is the User page...
-    else
-    {
-      // Erase the User page if requested and write it from the page buffer.
-      if (erase)
-      {
-        flashc_erase_user_page(FALSE);
-        error_status |= flashc_error_status;
-      }
-      flashc_write_user_page();
-      error_status |= flashc_error_status;
-    }
-  }
-
-  // Update the FLASHC error status.
-  flashc_error_status = error_status;
-
-  // Return the initial destination pointer as the standard memset function does.
-  return dst;
-}
-
-
-volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase)
-{
-  // Use aggregated pointers to have several alignments available for a same address.
-  UnionCVPtr flash_array_end;
-  UnionVPtr dest;
-  UnionCPtr source;
-  StructCVPtr dest_end;
-  UnionCVPtr flash_page_source_end;
-  Bool incomplete_flash_page_end;
-  Union64 flash_dword;
-  Bool flash_dword_pending = FALSE;
-  UnionVPtr tmp;
-  unsigned int error_status = 0;
-  unsigned int i, j;
-
-  // Reformat arguments.
-  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
-  dest.u8ptr = dst;
-  source.u8ptr = src;
-  dest_end.u8ptr = dest.u8ptr + nbytes;
-
-  // If destination is outside flash, go to next flash page if any.
-  if (dest.u8ptr &lt; AVR32_FLASH)
-  {
-    source.u8ptr += AVR32_FLASH - dest.u8ptr;
-    dest.u8ptr = AVR32_FLASH;
-  }
-  else if (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
-  {
-    source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
-    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
-  }
-
-  // If end of destination is outside flash, move it to the end of the previous flash page if any.
-  if (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
-  {
-    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
-  }
-  else if (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
-  {
-    dest_end.u8ptr = flash_array_end.u8ptr;
-  }
-
-  // Align each end of destination pointer with its natural boundary.
-  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
-  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
-  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
-
-  // While end of destination is not reached...
-  while (dest.u8ptr &lt; dest_end.u8ptr)
-  {
-    // Clear the page buffer in order to prepare data for a flash page write.
-    flashc_clear_page_buffer();
-    error_status |= flashc_error_status;
-
-    // Determine where the source data will end in the current flash page.
-    flash_page_source_end.u64ptr =
-      (U64 *)min((U32)dest_end.u64ptr,
-                 Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
-
-    // Determine if the current destination page has an incomplete end.
-    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
-                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
-
-    // If destination does not point to the beginning of the current flash page...
-    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
-    {
-      // Fill the beginning of the page buffer with the current flash page data.
-      // This is required by the hardware, even if page erase is not requested,
-      // in order to be able to write successfully to erased parts of flash
-      // pages that have already been written to.
-      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
-           tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
-           tmp.u64ptr++)
-        *tmp.u64ptr = *tmp.u64ptr;
-
-      // If destination is not 64-bit aligned...
-      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
-      {
-        // Fill the beginning of the flash double-word buffer with the current
-        // flash page data.
-        // This is required by the hardware, even if page erase is not
-        // requested, in order to be able to write successfully to erased parts
-        // of flash pages that have already been written to.
-        for (i = 0; i &lt; Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
-          flash_dword.u8[i] = *tmp.u8ptr++;
-
-        // Fill the end of the flash double-word buffer with the source data.
-        for (; i &lt; sizeof(U64); i++)
-          flash_dword.u8[i] = *source.u8ptr++;
-
-        // Align the destination pointer with its 64-bit boundary.
-        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
-
-        // If the current destination double-word is not the last one...
-        if (dest.u64ptr &lt; dest_end.u64ptr)
-        {
-          // Write the flash double-word buffer to the page buffer.
-          *dest.u64ptr++ = flash_dword.u64;
-        }
-        // If the current destination double-word is the last one, the flash
-        // double-word buffer must be kept for later.
-        else flash_dword_pending = TRUE;
-      }
-    }
-
-    // Read the source data with the maximal possible alignment and write it to
-    // the page buffer with 64-bit alignment.
-    switch (Get_align((U32)source.u8ptr, sizeof(U32)))
-    {
-    case 0:
-      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
-        *dest.u64ptr++ = *source.u64ptr++;
-      break;
-
-    case sizeof(U16):
-      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
-      {
-        for (j = 0; j &lt; sizeof(U64) / sizeof(U16); j++) flash_dword.u16[j] = *source.u16ptr++;
-        *dest.u64ptr++ = flash_dword.u64;
-      }
-      break;
-
-    default:
-      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
-      {
-        for (j = 0; j &lt; sizeof(U64); j++) flash_dword.u8[j] = *source.u8ptr++;
-        *dest.u64ptr++ = flash_dword.u64;
-      }
-    }
-
-    // If the current destination page has an incomplete end...
-    if (incomplete_flash_page_end)
-    {
-      // If the flash double-word buffer is in use, do not initialize it.
-      if (flash_dword_pending) i = Get_align((U32)dest_end.u8ptr, sizeof(U64));
-      // If the flash double-word buffer is free...
-      else
-      {
-        // Fill the beginning of the flash double-word buffer with the source data.
-        for (i = 0; i &lt; Get_align((U32)dest_end.u8ptr, sizeof(U64)); i++)
-          flash_dword.u8[i] = *source.u8ptr++;
-      }
-
-      // This is required by the hardware, even if page erase is not requested,
-      // in order to be able to write successfully to erased parts of flash
-      // pages that have already been written to.
-      {
-        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
-
-        // If end of destination is not 64-bit aligned...
-        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
-        {
-          // Fill the end of the flash double-word buffer with the current flash page data.
-          for (; i &lt; sizeof(U64); i++)
-            flash_dword.u8[i] = *tmp.u8ptr++;
-
-          // Write the flash double-word buffer to the page buffer.
-          *dest.u64ptr++ = flash_dword.u64;
-        }
-
-        // Fill the end of the page buffer with the current flash page data.
-        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
-          *tmp.u64ptr = *tmp.u64ptr;
-      }
-    }
-
-    // If the current flash page is in the flash array...
-    if (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
-    {
-      // Erase the current page if requested and write it from the page buffer.
-      if (erase)
-      {
-        flashc_erase_page(-1, FALSE);
-        error_status |= flashc_error_status;
-      }
-      flashc_write_page(-1);
-      error_status |= flashc_error_status;
-
-      // If the end of the flash array is reached, go to the User page.
-      if (dest.u8ptr &gt;= flash_array_end.u8ptr)
-      {
-        source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
-        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
-      }
-    }
-    // If the current flash page is the User page...
-    else
-    {
-      // Erase the User page if requested and write it from the page buffer.
-      if (erase)
-      {
-        flashc_erase_user_page(FALSE);
-        error_status |= flashc_error_status;
-      }
-      flashc_write_user_page();
-      error_status |= flashc_error_status;
-    }
-  }
-
-  // Update the FLASHC error status.
-  flashc_error_status = error_status;
-
-  // Return the initial destination pointer as the standard memcpy function does.
-  return dst;
-}
-
-
-//! @}
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief FLASHC driver for AVR32 UC3.
+ *
+ * AVR32 Flash Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a FLASHC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &lt;avr32/io.h&gt;
+#include &lt;stddef.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;flashc.h&quot;
+
+
+/*! \name FLASHC Writable Bit-Field Registers
+ */
+//! @{
+
+typedef union
+{
+  unsigned long                 fcr;
+  avr32_flashc_fcr_t            FCR;
+} u_avr32_flashc_fcr_t;
+
+typedef union
+{
+  unsigned long                 fcmd;
+  avr32_flashc_fcmd_t           FCMD;
+} u_avr32_flashc_fcmd_t;
+
+//! @}
+
+
+/*! \name Flash Properties
+ */
+//! @{
+
+
+unsigned int flashc_get_flash_size(void)
+{
+#if (defined AVR32_FLASHC_300_H_INCLUDED)
+  static const unsigned int FLASH_SIZE[1 &lt;&lt; AVR32_FLASHC_PR_FSZ_SIZE] =
+  {
+      32 &lt;&lt; 10,
+      64 &lt;&lt; 10,
+     128 &lt;&lt; 10,
+     256 &lt;&lt; 10,
+     384 &lt;&lt; 10,
+     512 &lt;&lt; 10,
+     768 &lt;&lt; 10,
+    1024 &lt;&lt; 10
+  };
+  return FLASH_SIZE[(AVR32_FLASHC.pr &amp; AVR32_FLASHC_PR_FSZ_MASK) &gt;&gt; AVR32_FLASHC_PR_FSZ_OFFSET];
+#else 
+  static const unsigned int FLASH_SIZE[1 &lt;&lt; AVR32_FLASHC_FSR_FSZ_SIZE] =
+  {
+      32 &lt;&lt; 10,
+      64 &lt;&lt; 10,
+     128 &lt;&lt; 10,
+     256 &lt;&lt; 10,
+     384 &lt;&lt; 10,
+     512 &lt;&lt; 10,
+     768 &lt;&lt; 10,
+    1024 &lt;&lt; 10
+  };
+  return FLASH_SIZE[(AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FSZ_MASK) &gt;&gt; AVR32_FLASHC_FSR_FSZ_OFFSET];
+#endif  
+}
+
+
+unsigned int flashc_get_page_count(void)
+{
+  return flashc_get_flash_size() / AVR32_FLASHC_PAGE_SIZE;
+}
+
+
+unsigned int flashc_get_page_count_per_region(void)
+{
+  return flashc_get_page_count() / AVR32_FLASHC_REGIONS;
+}
+
+
+unsigned int flashc_get_page_region(int page_number)
+{
+  return ((page_number &gt;= 0) ? page_number : flashc_get_page_number()) / flashc_get_page_count_per_region();
+}
+
+
+unsigned int flashc_get_region_first_page_number(unsigned int region)
+{
+  return region * flashc_get_page_count_per_region();
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Control
+ */
+//! @{
+
+
+unsigned int flashc_get_wait_state(void)
+{
+  return (AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FWS_MASK) &gt;&gt; AVR32_FLASHC_FCR_FWS_OFFSET;
+}
+
+
+void flashc_set_wait_state(unsigned int wait_state)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.fws = wait_state;
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+Bool flashc_is_ready_int_enabled(void)
+{
+  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FRDY_MASK) != 0);
+}
+
+
+void flashc_enable_ready_int(Bool enable)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.frdy = (enable != FALSE);
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+Bool flashc_is_lock_error_int_enabled(void)
+{
+  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_LOCKE_MASK) != 0);
+}
+
+
+void flashc_enable_lock_error_int(Bool enable)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.locke = (enable != FALSE);
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+Bool flashc_is_prog_error_int_enabled(void)
+{
+  return ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_PROGE_MASK) != 0);
+}
+
+
+void flashc_enable_prog_error_int(Bool enable)
+{
+  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
+  u_avr32_flashc_fcr.FCR.proge = (enable != FALSE);
+  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Status
+ */
+//! @{
+
+
+Bool flashc_is_ready(void)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FRDY_MASK) != 0);
+}
+
+
+void flashc_default_wait_until_ready(void)
+{
+  while (!flashc_is_ready());
+}
+
+
+void (*volatile flashc_wait_until_ready)(void) = flashc_default_wait_until_ready;
+
+
+/*! \brief Gets the error status of the FLASHC.
+ *
+ * \return The error status of the FLASHC built up from
+ *         \c AVR32_FLASHC_FSR_LOCKE_MASK and \c AVR32_FLASHC_FSR_PROGE_MASK.
+ *
+ * \warning This hardware error status is cleared by all functions reading the
+ *          Flash Status Register (FSR). This function is therefore not part of
+ *          the driver's API which instead presents \ref flashc_is_lock_error
+ *          and \ref flashc_is_programming_error.
+ */
+static unsigned int flashc_get_error_status(void)
+{
+  return AVR32_FLASHC.fsr &amp; (AVR32_FLASHC_FSR_LOCKE_MASK |
+                             AVR32_FLASHC_FSR_PROGE_MASK);
+}
+
+
+//! Sticky error status of the FLASHC.
+//! This variable is updated by functions that issue FLASHC commands. It
+//! contains the cumulated FLASHC error status of all the FLASHC commands issued
+//! by a function.
+static unsigned int flashc_error_status = 0;
+
+
+Bool flashc_is_lock_error(void)
+{
+  return ((flashc_error_status &amp; AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
+}
+
+
+Bool flashc_is_programming_error(void)
+{
+  return ((flashc_error_status &amp; AVR32_FLASHC_FSR_PROGE_MASK) != 0);
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Command Control
+ */
+//! @{
+
+
+unsigned int flashc_get_command(void)
+{
+  return (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_CMD_MASK) &gt;&gt; AVR32_FLASHC_FCMD_CMD_OFFSET;
+}
+
+
+unsigned int flashc_get_page_number(void)
+{
+  return (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_PAGEN_MASK) &gt;&gt; AVR32_FLASHC_FCMD_PAGEN_OFFSET;
+}
+
+
+void flashc_issue_command(unsigned int command, int page_number)
+{
+  u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;
+  flashc_wait_until_ready();
+  u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
+  u_avr32_flashc_fcmd.FCMD.cmd = command;
+  if (page_number &gt;= 0) u_avr32_flashc_fcmd.FCMD.pagen = page_number;
+  u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
+  AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
+  flashc_error_status = flashc_get_error_status();
+  flashc_wait_until_ready();
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Global Commands
+ */
+//! @{
+
+
+void flashc_no_operation(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_NOP, -1);
+}
+
+
+void flashc_erase_all(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EA, -1);
+}
+
+
+//! @}
+
+
+/*! \name FLASHC Protection Mechanisms
+ */
+//! @{
+
+
+Bool flashc_is_security_bit_active(void)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_SECURITY_MASK) != 0);
+}
+
+
+void flashc_activate_security_bit(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_SSB, -1);
+}
+
+
+unsigned int flashc_get_bootloader_protected_size(void)
+{
+  unsigned int bootprot = (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
+                          flashc_read_gp_fuse_bitfield(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
+                                                       AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE);
+  return (bootprot) ? AVR32_FLASHC_PAGE_SIZE &lt;&lt; bootprot : 0;
+}
+
+
+unsigned int flashc_set_bootloader_protected_size(unsigned int bootprot_size)
+{
+  flashc_set_gp_fuse_bitfield(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
+                              AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE,
+                              (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
+                              ((bootprot_size) ?
+                               32 - clz((((min(max(bootprot_size, AVR32_FLASHC_PAGE_SIZE &lt;&lt; 1),
+                                               AVR32_FLASHC_PAGE_SIZE &lt;&lt;
+                                               ((1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1)) +
+                                           AVR32_FLASHC_PAGE_SIZE - 1) /
+                                          AVR32_FLASHC_PAGE_SIZE) &lt;&lt; 1) - 1) - 1 :
+                               0));
+  return flashc_get_bootloader_protected_size();
+}
+
+
+Bool flashc_is_external_privileged_fetch_locked(void)
+{
+  return (!flashc_read_gp_fuse_bit(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET));
+}
+
+
+void flashc_lock_external_privileged_fetch(Bool lock)
+{
+  flashc_set_gp_fuse_bit(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET, !lock);
+}
+
+
+Bool flashc_is_page_region_locked(int page_number)
+{
+  return flashc_is_region_locked(flashc_get_page_region(page_number));
+}
+
+
+Bool flashc_is_region_locked(unsigned int region)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_LOCK0_MASK &lt;&lt; (region &amp; (AVR32_FLASHC_REGIONS - 1))) != 0);
+}
+
+
+void flashc_lock_page_region(int page_number, Bool lock)
+{
+  flashc_issue_command((lock) ? AVR32_FLASHC_FCMD_CMD_LP : AVR32_FLASHC_FCMD_CMD_UP, page_number);
+}
+
+
+void flashc_lock_region(unsigned int region, Bool lock)
+{
+  flashc_lock_page_region(flashc_get_region_first_page_number(region), lock);
+}
+
+
+void flashc_lock_all_regions(Bool lock)
+{
+  unsigned int error_status = 0;
+  unsigned int region = AVR32_FLASHC_REGIONS;
+  while (region)
+  {
+    flashc_lock_region(--region, lock);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+//! @}
+
+
+/*! \name Access to General-Purpose Fuses
+ */
+//! @{
+
+
+Bool flashc_read_gp_fuse_bit(unsigned int gp_fuse_bit)
+{
+  return ((flashc_read_all_gp_fuses() &amp; 1ULL &lt;&lt; (gp_fuse_bit &amp; 0x3F)) != 0);
+}
+
+
+U64 flashc_read_gp_fuse_bitfield(unsigned int pos, unsigned int width)
+{
+  return flashc_read_all_gp_fuses() &gt;&gt; (pos &amp; 0x3F) &amp; ((1ULL &lt;&lt; min(width, 64)) - 1);
+}
+
+
+U8 flashc_read_gp_fuse_byte(unsigned int gp_fuse_byte)
+{
+  return flashc_read_all_gp_fuses() &gt;&gt; ((gp_fuse_byte &amp; 0x07) &lt;&lt; 3);
+}
+
+
+U64 flashc_read_all_gp_fuses(void)
+{
+  return AVR32_FLASHC.fgpfrlo | (U64)AVR32_FLASHC.fgpfrhi &lt;&lt; 32;
+}
+
+
+Bool flashc_erase_gp_fuse_bit(unsigned int gp_fuse_bit, Bool check)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EGPB, gp_fuse_bit &amp; 0x3F);
+  return (check) ? flashc_read_gp_fuse_bit(gp_fuse_bit) : TRUE;
+}
+
+
+Bool flashc_erase_gp_fuse_bitfield(unsigned int pos, unsigned int width, Bool check)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_bit;
+  pos &amp;= 0x3F;
+  width = min(width, 64);
+  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++)
+  {
+    flashc_erase_gp_fuse_bit(gp_fuse_bit, FALSE);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+  return (check) ? (flashc_read_gp_fuse_bitfield(pos, width) == (1ULL &lt;&lt; width) - 1) : TRUE;
+}
+
+
+Bool flashc_erase_gp_fuse_byte(unsigned int gp_fuse_byte, Bool check)
+{
+  unsigned int error_status;
+  unsigned int current_gp_fuse_byte;
+  U64 value = flashc_read_all_gp_fuses();
+  flashc_erase_all_gp_fuses(FALSE);
+  error_status = flashc_error_status;
+  for (current_gp_fuse_byte = 0; current_gp_fuse_byte &lt; 8; current_gp_fuse_byte++, value &gt;&gt;= 8)
+  {
+    if (current_gp_fuse_byte != gp_fuse_byte)
+    {
+      flashc_write_gp_fuse_byte(current_gp_fuse_byte, value);
+      error_status |= flashc_error_status;
+    }
+  }
+  flashc_error_status = error_status;
+  return (check) ? (flashc_read_gp_fuse_byte(gp_fuse_byte) == 0xFF) : TRUE;
+}
+
+
+Bool flashc_erase_all_gp_fuses(Bool check)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EAGPF, -1);
+  return (check) ? (flashc_read_all_gp_fuses() == 0xFFFFFFFFFFFFFFFFULL) : TRUE;
+}
+
+
+void flashc_write_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value)
+{
+  if (!value)
+    flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WGPB, gp_fuse_bit &amp; 0x3F);
+}
+
+
+void flashc_write_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_bit;
+  pos &amp;= 0x3F;
+  width = min(width, 64);
+  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
+  {
+    flashc_write_gp_fuse_bit(gp_fuse_bit, value &amp; 0x01);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+void flashc_write_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_PGPFB, (gp_fuse_byte &amp; 0x07) | value &lt;&lt; 3);
+}
+
+
+void flashc_write_all_gp_fuses(U64 value)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_byte;
+  for (gp_fuse_byte = 0; gp_fuse_byte &lt; 8; gp_fuse_byte++, value &gt;&gt;= 8)
+  {
+    flashc_write_gp_fuse_byte(gp_fuse_byte, value);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+void flashc_set_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value)
+{
+  if (value)
+    flashc_erase_gp_fuse_bit(gp_fuse_bit, FALSE);
+  else
+    flashc_write_gp_fuse_bit(gp_fuse_bit, FALSE);
+}
+
+
+void flashc_set_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value)
+{
+  unsigned int error_status = 0;
+  unsigned int gp_fuse_bit;
+  pos &amp;= 0x3F;
+  width = min(width, 64);
+  for (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
+  {
+    flashc_set_gp_fuse_bit(gp_fuse_bit, value &amp; 0x01);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+}
+
+
+void flashc_set_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value)
+{
+  unsigned int error_status;
+  switch (value)
+  {
+  case 0xFF:
+    flashc_erase_gp_fuse_byte(gp_fuse_byte, FALSE);
+    break;
+  case 0x00:
+    flashc_write_gp_fuse_byte(gp_fuse_byte, 0x00);
+    break;
+  default:
+    flashc_erase_gp_fuse_byte(gp_fuse_byte, FALSE);
+    error_status = flashc_error_status;
+    flashc_write_gp_fuse_byte(gp_fuse_byte, value);
+    flashc_error_status |= error_status;
+  }
+}
+
+
+void flashc_set_all_gp_fuses(U64 value)
+{
+  unsigned int error_status;
+  switch (value)
+  {
+  case 0xFFFFFFFFFFFFFFFFULL:
+    flashc_erase_all_gp_fuses(FALSE);
+    break;
+  case 0x0000000000000000ULL:
+    flashc_write_all_gp_fuses(0x0000000000000000ULL);
+    break;
+  default:
+    flashc_erase_all_gp_fuses(FALSE);
+    error_status = flashc_error_status;
+    flashc_write_all_gp_fuses(value);
+    flashc_error_status |= error_status;
+  }
+}
+
+
+//! @}
+
+
+/*! \name Access to Flash Pages
+ */
+//! @{
+
+
+void flashc_clear_page_buffer(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
+}
+
+
+Bool flashc_is_page_erased(void)
+{
+  return ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_QPRR_MASK) != 0);
+}
+
+
+Bool flashc_quick_page_read(int page_number)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
+  return flashc_is_page_erased();
+}
+
+
+Bool flashc_erase_page(int page_number, Bool check)
+{
+  Bool page_erased = TRUE;
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
+  if (check)
+  {
+    unsigned int error_status = flashc_error_status;
+    page_erased = flashc_quick_page_read(-1);
+    flashc_error_status |= error_status;
+  }
+  return page_erased;
+}
+
+
+Bool flashc_erase_all_pages(Bool check)
+{
+  Bool all_pages_erased = TRUE;
+  unsigned int error_status = 0;
+  unsigned int page_number = flashc_get_page_count();
+  while (page_number)
+  {
+    all_pages_erased &amp;= flashc_erase_page(--page_number, check);
+    error_status |= flashc_error_status;
+  }
+  flashc_error_status = error_status;
+  return all_pages_erased;
+}
+
+
+void flashc_write_page(int page_number)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
+}
+
+
+Bool flashc_quick_user_page_read(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
+  return flashc_is_page_erased();
+}
+
+
+Bool flashc_erase_user_page(Bool check)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
+  return (check) ? flashc_quick_user_page_read() : TRUE;
+}
+
+
+void flashc_write_user_page(void)
+{
+  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
+}
+
+
+volatile void *flashc_memset8(volatile void *dst, U8 src, size_t nbytes, Bool erase)
+{
+  return flashc_memset16(dst, src | (U16)src &lt;&lt; 8, nbytes, erase);
+}
+
+
+volatile void *flashc_memset16(volatile void *dst, U16 src, size_t nbytes, Bool erase)
+{
+  return flashc_memset32(dst, src | (U32)src &lt;&lt; 16, nbytes, erase);
+}
+
+
+volatile void *flashc_memset32(volatile void *dst, U32 src, size_t nbytes, Bool erase)
+{
+  return flashc_memset64(dst, src | (U64)src &lt;&lt; 32, nbytes, erase);
+}
+
+
+volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase)
+{
+  // Use aggregated pointers to have several alignments available for a same address.
+  UnionCVPtr flash_array_end;
+  UnionVPtr dest;
+  Union64 source = {0};
+  StructCVPtr dest_end;
+  UnionCVPtr flash_page_source_end;
+  Bool incomplete_flash_page_end;
+  Union64 flash_dword;
+  UnionVPtr tmp;
+  unsigned int error_status = 0;
+  unsigned int i;
+
+  // Reformat arguments.
+  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
+  dest.u8ptr = dst;
+  for (i = (Get_align((U32)dest.u8ptr, sizeof(U64)) - 1) &amp; (sizeof(U64) - 1);
+       src; i = (i - 1) &amp; (sizeof(U64) - 1))
+  {
+    source.u8[i] = src;
+    src &gt;&gt;= 8;
+  }
+  dest_end.u8ptr = dest.u8ptr + nbytes;
+
+  // If destination is outside flash, go to next flash page if any.
+  if (dest.u8ptr &lt; AVR32_FLASH)
+  {
+    dest.u8ptr = AVR32_FLASH;
+  }
+  else if (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
+  {
+    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+  }
+
+  // If end of destination is outside flash, move it to the end of the previous flash page if any.
+  if (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
+  {
+    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
+  }
+  else if (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
+  {
+    dest_end.u8ptr = flash_array_end.u8ptr;
+  }
+
+  // Align each end of destination pointer with its natural boundary.
+  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
+  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
+  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
+
+  // While end of destination is not reached...
+  while (dest.u8ptr &lt; dest_end.u8ptr)
+  {
+    // Clear the page buffer in order to prepare data for a flash page write.
+    flashc_clear_page_buffer();
+    error_status |= flashc_error_status;
+
+    // Determine where the source data will end in the current flash page.
+    flash_page_source_end.u64ptr =
+      (U64 *)min((U32)dest_end.u64ptr,
+                 Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
+
+    // Determine if the current destination page has an incomplete end.
+    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
+                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
+
+    // Use a flash double-word buffer to manage unaligned accesses.
+    flash_dword.u64 = source.u64;
+
+    // If destination does not point to the beginning of the current flash page...
+    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
+    {
+      // Fill the beginning of the page buffer with the current flash page data.
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
+           tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+           tmp.u64ptr++)
+        *tmp.u64ptr = *tmp.u64ptr;
+
+      // If destination is not 64-bit aligned...
+      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
+      {
+        // Fill the beginning of the flash double-word buffer with the current
+        // flash page data.
+        // This is required by the hardware, even if page erase is not
+        // requested, in order to be able to write successfully to erased parts
+        // of flash pages that have already been written to.
+        for (i = 0; i &lt; Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
+          flash_dword.u8[i] = *tmp.u8ptr++;
+
+        // Align the destination pointer with its 64-bit boundary.
+        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+
+        // If the current destination double-word is not the last one...
+        if (dest.u64ptr &lt; dest_end.u64ptr)
+        {
+          // Write the flash double-word buffer to the page buffer and reinitialize it.
+          *dest.u64ptr++ = flash_dword.u64;
+          flash_dword.u64 = source.u64;
+        }
+      }
+    }
+
+    // Write the source data to the page buffer with 64-bit alignment.
+    for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+      *dest.u64ptr++ = source.u64;
+
+    // If the current destination page has an incomplete end...
+    if (incomplete_flash_page_end)
+    {
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      {
+        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
+
+        // If end of destination is not 64-bit aligned...
+        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
+        {
+          // Fill the end of the flash double-word buffer with the current flash page data.
+          for (i = Get_align((U32)dest_end.u8ptr, sizeof(U64)); i &lt; sizeof(U64); i++)
+            flash_dword.u8[i] = *tmp.u8ptr++;
+
+          // Write the flash double-word buffer to the page buffer.
+          *dest.u64ptr++ = flash_dword.u64;
+        }
+
+        // Fill the end of the page buffer with the current flash page data.
+        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
+          *tmp.u64ptr = *tmp.u64ptr;
+      }
+    }
+
+    // If the current flash page is in the flash array...
+    if (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
+    {
+      // Erase the current page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_page(-1, FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_page(-1);
+      error_status |= flashc_error_status;
+
+      // If the end of the flash array is reached, go to the User page.
+      if (dest.u8ptr &gt;= flash_array_end.u8ptr)
+        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+    }
+    // If the current flash page is the User page...
+    else
+    {
+      // Erase the User page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_user_page(FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_user_page();
+      error_status |= flashc_error_status;
+    }
+  }
+
+  // Update the FLASHC error status.
+  flashc_error_status = error_status;
+
+  // Return the initial destination pointer as the standard memset function does.
+  return dst;
+}
+
+
+volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase)
+{
+  // Use aggregated pointers to have several alignments available for a same address.
+  UnionCVPtr flash_array_end;
+  UnionVPtr dest;
+  UnionCPtr source;
+  StructCVPtr dest_end;
+  UnionCVPtr flash_page_source_end;
+  Bool incomplete_flash_page_end;
+  Union64 flash_dword;
+  Bool flash_dword_pending = FALSE;
+  UnionVPtr tmp;
+  unsigned int error_status = 0;
+  unsigned int i, j;
+
+  // Reformat arguments.
+  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
+  dest.u8ptr = dst;
+  source.u8ptr = src;
+  dest_end.u8ptr = dest.u8ptr + nbytes;
+
+  // If destination is outside flash, go to next flash page if any.
+  if (dest.u8ptr &lt; AVR32_FLASH)
+  {
+    source.u8ptr += AVR32_FLASH - dest.u8ptr;
+    dest.u8ptr = AVR32_FLASH;
+  }
+  else if (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
+  {
+    source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
+    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+  }
+
+  // If end of destination is outside flash, move it to the end of the previous flash page if any.
+  if (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
+  {
+    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
+  }
+  else if (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
+  {
+    dest_end.u8ptr = flash_array_end.u8ptr;
+  }
+
+  // Align each end of destination pointer with its natural boundary.
+  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
+  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
+  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
+
+  // While end of destination is not reached...
+  while (dest.u8ptr &lt; dest_end.u8ptr)
+  {
+    // Clear the page buffer in order to prepare data for a flash page write.
+    flashc_clear_page_buffer();
+    error_status |= flashc_error_status;
+
+    // Determine where the source data will end in the current flash page.
+    flash_page_source_end.u64ptr =
+      (U64 *)min((U32)dest_end.u64ptr,
+                 Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
+
+    // Determine if the current destination page has an incomplete end.
+    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
+                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
+
+    // If destination does not point to the beginning of the current flash page...
+    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
+    {
+      // Fill the beginning of the page buffer with the current flash page data.
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
+           tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+           tmp.u64ptr++)
+        *tmp.u64ptr = *tmp.u64ptr;
+
+      // If destination is not 64-bit aligned...
+      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
+      {
+        // Fill the beginning of the flash double-word buffer with the current
+        // flash page data.
+        // This is required by the hardware, even if page erase is not
+        // requested, in order to be able to write successfully to erased parts
+        // of flash pages that have already been written to.
+        for (i = 0; i &lt; Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
+          flash_dword.u8[i] = *tmp.u8ptr++;
+
+        // Fill the end of the flash double-word buffer with the source data.
+        for (; i &lt; sizeof(U64); i++)
+          flash_dword.u8[i] = *source.u8ptr++;
+
+        // Align the destination pointer with its 64-bit boundary.
+        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
+
+        // If the current destination double-word is not the last one...
+        if (dest.u64ptr &lt; dest_end.u64ptr)
+        {
+          // Write the flash double-word buffer to the page buffer.
+          *dest.u64ptr++ = flash_dword.u64;
+        }
+        // If the current destination double-word is the last one, the flash
+        // double-word buffer must be kept for later.
+        else flash_dword_pending = TRUE;
+      }
+    }
+
+    // Read the source data with the maximal possible alignment and write it to
+    // the page buffer with 64-bit alignment.
+    switch (Get_align((U32)source.u8ptr, sizeof(U32)))
+    {
+    case 0:
+      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+        *dest.u64ptr++ = *source.u64ptr++;
+      break;
+
+    case sizeof(U16):
+      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+      {
+        for (j = 0; j &lt; sizeof(U64) / sizeof(U16); j++) flash_dword.u16[j] = *source.u16ptr++;
+        *dest.u64ptr++ = flash_dword.u64;
+      }
+      break;
+
+    default:
+      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
+      {
+        for (j = 0; j &lt; sizeof(U64); j++) flash_dword.u8[j] = *source.u8ptr++;
+        *dest.u64ptr++ = flash_dword.u64;
+      }
+    }
+
+    // If the current destination page has an incomplete end...
+    if (incomplete_flash_page_end)
+    {
+      // If the flash double-word buffer is in use, do not initialize it.
+      if (flash_dword_pending) i = Get_align((U32)dest_end.u8ptr, sizeof(U64));
+      // If the flash double-word buffer is free...
+      else
+      {
+        // Fill the beginning of the flash double-word buffer with the source data.
+        for (i = 0; i &lt; Get_align((U32)dest_end.u8ptr, sizeof(U64)); i++)
+          flash_dword.u8[i] = *source.u8ptr++;
+      }
+
+      // This is required by the hardware, even if page erase is not requested,
+      // in order to be able to write successfully to erased parts of flash
+      // pages that have already been written to.
+      {
+        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
+
+        // If end of destination is not 64-bit aligned...
+        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
+        {
+          // Fill the end of the flash double-word buffer with the current flash page data.
+          for (; i &lt; sizeof(U64); i++)
+            flash_dword.u8[i] = *tmp.u8ptr++;
+
+          // Write the flash double-word buffer to the page buffer.
+          *dest.u64ptr++ = flash_dword.u64;
+        }
+
+        // Fill the end of the page buffer with the current flash page data.
+        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
+          *tmp.u64ptr = *tmp.u64ptr;
+      }
+    }
+
+    // If the current flash page is in the flash array...
+    if (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
+    {
+      // Erase the current page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_page(-1, FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_page(-1);
+      error_status |= flashc_error_status;
+
+      // If the end of the flash array is reached, go to the User page.
+      if (dest.u8ptr &gt;= flash_array_end.u8ptr)
+      {
+        source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
+        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
+      }
+    }
+    // If the current flash page is the User page...
+    else
+    {
+      // Erase the User page if requested and write it from the page buffer.
+      if (erase)
+      {
+        flashc_erase_user_page(FALSE);
+        error_status |= flashc_error_status;
+      }
+      flashc_write_user_page();
+      error_status |= flashc_error_status;
+    }
+  }
+
+  // Update the FLASHC error status.
+  flashc_error_status = error_status;
+
+  // Return the initial destination pointer as the standard memcpy function does.
+  return dst;
+}
+
+
+#if ( defined (__GNUC__) &amp;&amp; ( defined (__AVR32_UC3C064C__) || defined (__AVR32_UC3C0128C__) || defined (__AVR32_UC3C0256C__) || defined (__AVR32_UC3C0512CREVC__) || defined (__AVR32_UC3C164C__) || defined (__AVR32_UC3C1128C__) || defined (__AVR32_UC3C1256C__) || defined (__AVR32_UC3C1512CREVC__) || defined (__AVR32_UC3C264C__) || defined (__AVR32_UC3C2128C__) || defined (__AVR32_UC3C2256C__) || defined (__AVR32_UC3C2512CREVC__))) \
+  ||( defined (__ICCAVR32__) &amp;&amp; ( defined (__AT32UC3C064C__) || defined (__AT32UC3C0128C__) || defined (__AT32UC3C0256C__) || defined (__AT32UC3C0512C__) || defined (__AT32UC3C164C__) || defined (__AT32UC3C1128C__) || defined (__AT32UC3C1256C__) || defined (__AT32UC3C1512C__) || defined (__AT32UC3C264C__) || defined (__AT32UC3C2128C__) || defined (__AT32UC3C2256C__) || defined (__AT32UC3C2512C__)))
+void flashc_set_flash_waitstate_and_readmode(unsigned long cpu_f_hz)
+{
+  //! Device-specific data
+  #undef AVR32_FLASHC_FWS_0_MAX_FREQ
+  #undef AVR32_FLASHC_FWS_1_MAX_FREQ
+  #undef AVR32_FLASHC_HSEN_FWS_0_MAX_FREQ
+  #undef AVR32_FLASHC_HSEN_FWS_1_MAX_FREQ
+  #define AVR32_FLASHC_FWS_0_MAX_FREQ           33000000
+  #define AVR32_FLASHC_FWS_1_MAX_FREQ           66000000
+  #define AVR32_FLASHC_HSEN_FWS_0_MAX_FREQ      33000000
+  #define AVR32_FLASHC_HSEN_FWS_1_MAX_FREQ      72000000
+  // These defines are missing from or wrong in the toolchain header files uc3cxxx.h
+  // Put a Bugzilla 
+
+  if(cpu_f_hz &gt; AVR32_FLASHC_HSEN_FWS_0_MAX_FREQ)    // &gt; 33MHz
+  {
+    // Set a wait-state
+    flashc_set_wait_state(1);
+    if(cpu_f_hz &lt;= AVR32_FLASHC_FWS_1_MAX_FREQ) // &lt;= 66MHz and &gt;33Mhz
+    {
+      // Disable the high-speed read mode.      
+      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
+    }
+    else // &gt; 66Mhz
+    {
+      // Enable the high-speed read mode.
+      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSEN, -1);                     
+    }
+  }
+  else  // &lt;= 33 MHz    
+  {
+    // Disable wait-state
+    flashc_set_wait_state(0);
+
+    // Disable the high-speed read mode.
+    flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
+    
+  }
+}
+#endif // UC3C device-specific implementation
+
+//! @}

Modified: trunk/src/platform/avr32/flashc.h
===================================================================
--- trunk/src/platform/avr32/flashc.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/flashc.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,990 +1,1004 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief FLASHC driver for AVR32 UC3.
- *
- * AVR32 Flash Controller driver module.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a FLASHC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _FLASHC_H_
-#define _FLASHC_H_
-
-#include &lt;avr32/io.h&gt;
-#include &lt;stddef.h&gt;
-#include &quot;compiler.h&quot;
-
-
-//! Number of flash regions defined by the FLASHC.
-#define AVR32_FLASHC_REGIONS  (AVR32_FLASHC_FLASH_SIZE /\
-                               (AVR32_FLASHC_PAGES_PR_REGION * AVR32_FLASHC_PAGE_SIZE))
-
-
-/*! \name Flash Properties
- */
-//! @{
-
-/*! \brief Gets the size of the whole flash array.
- *
- * \return The size of the whole flash array in bytes.
- */
-extern unsigned int flashc_get_flash_size(void);
-
-/*! \brief Gets the total number of pages in the flash array.
- *
- * \return The total number of pages in the flash array.
- */
-extern unsigned int flashc_get_page_count(void);
-
-/*! \brief Gets the number of pages in each flash region.
- *
- * \return The number of pages in each flash region.
- */
-extern unsigned int flashc_get_page_count_per_region(void);
-
-/*! \brief Gets the region number of a page.
- *
- * \param page_number The page number:
- *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
- *        the flash array;
- *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
- *
- * \return The region number of the specified page.
- */
-extern unsigned int flashc_get_page_region(int page_number);
-
-/*! \brief Gets the number of the first page of a region.
- *
- * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
- *
- * \return The number of the first page of the specified region.
- */
-extern unsigned int flashc_get_region_first_page_number(unsigned int region);
-
-//! @}
-
-
-/*! \name FLASHC Control
- */
-//! @{
-
-/*! \brief Gets the number of wait states of flash read accesses.
- *
- * \return The number of wait states of flash read accesses.
- */
-extern unsigned int flashc_get_wait_state(void);
-
-/*! \brief Sets the number of wait states of flash read accesses.
- *
- * \param wait_state The number of wait states of flash read accesses: \c 0 to
- *                   \c 1.
- */
-extern void flashc_set_wait_state(unsigned int wait_state);
-
-/*! \brief Tells whether the Flash Ready interrupt is enabled.
- *
- * \return Whether the Flash Ready interrupt is enabled.
- */
-extern Bool flashc_is_ready_int_enabled(void);
-
-/*! \brief Enables or disables the Flash Ready interrupt.
- *
- * \param enable Whether to enable the Flash Ready interrupt: \c TRUE or
- *               \c FALSE.
- */
-extern void flashc_enable_ready_int(Bool enable);
-
-/*! \brief Tells whether the Lock Error interrupt is enabled.
- *
- * \return Whether the Lock Error interrupt is enabled.
- */
-extern Bool flashc_is_lock_error_int_enabled(void);
-
-/*! \brief Enables or disables the Lock Error interrupt.
- *
- * \param enable Whether to enable the Lock Error interrupt: \c TRUE or
- *               \c FALSE.
- */
-extern void flashc_enable_lock_error_int(Bool enable);
-
-/*! \brief Tells whether the Programming Error interrupt is enabled.
- *
- * \return Whether the Programming Error interrupt is enabled.
- */
-extern Bool flashc_is_prog_error_int_enabled(void);
-
-/*! \brief Enables or disables the Programming Error interrupt.
- *
- * \param enable Whether to enable the Programming Error interrupt: \c TRUE or
- *               \c FALSE.
- */
-extern void flashc_enable_prog_error_int(Bool enable);
-
-//! @}
-
-
-/*! \name FLASHC Status
- */
-//! @{
-
-/*! \brief Tells whether the FLASHC is ready to run a new command.
- *
- * \return Whether the FLASHC is ready to run a new command.
- */
-extern Bool flashc_is_ready(void);
-
-/*! \brief Waits actively until the FLASHC is ready to run a new command.
- *
- * This is the default function assigned to \ref flashc_wait_until_ready.
- */
-extern void flashc_default_wait_until_ready(void);
-
-//! Pointer to the function used by the driver when it needs to wait until the
-//! FLASHC is ready to run a new command.
-//! The default function is \ref flashc_default_wait_until_ready.
-//! The user may change this pointer to use another implementation.
-extern void (*volatile flashc_wait_until_ready)(void);
-
-/*! \brief Tells whether a Lock Error has occurred during the last function
- *         called that issued one or more FLASHC commands.
- *
- * \return Whether a Lock Error has occurred during the last function called
- *         that issued one or more FLASHC commands.
- */
-extern Bool flashc_is_lock_error(void);
-
-/*! \brief Tells whether a Programming Error has occurred during the last
- *         function called that issued one or more FLASHC commands.
- *
- * \return Whether a Programming Error has occurred during the last function
- *         called that issued one or more FLASHC commands.
- */
-extern Bool flashc_is_programming_error(void);
-
-//! @}
-
-
-/*! \name FLASHC Command Control
- */
-//! @{
-
-/*! \brief Gets the last issued FLASHC command.
- *
- * \return The last issued FLASHC command.
- */
-extern unsigned int flashc_get_command(void);
-
-/*! \brief Gets the current FLASHC page number.
- *
- * \return The current FLASHC page number.
- */
-extern unsigned int flashc_get_page_number(void);
-
-/*! \brief Issues a FLASHC command.
- *
- * \param command The command: \c AVR32_FLASHC_FCMD_CMD_x.
- * \param page_number The page number to apply the command to:
- *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
- *        the flash array;
- *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: use this to apply the command to the current page number
- *        or if the command does not apply to any page number;
- *   \arg this argument may have other meanings according to the command. See
- *        the FLASHC chapter of the MCU datasheet.
- *
- * \warning A Lock Error is issued if the command violates the protection
- *          mechanism.
- *
- * \warning A Programming Error is issued if the command is invalid.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_issue_command(unsigned int command, int page_number);
-
-//! @}
-
-
-/*! \name FLASHC Global Commands
- */
-//! @{
-
-/*! \brief Issues a No Operation command to the FLASHC.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_no_operation(void);
-
-/*! \brief Issues an Erase All command to the FLASHC.
- *
- * This command erases all bits in the flash array, the general-purpose fuse
- * bits and the Security bit. The User page is not erased.
- *
- * This command also ensures that all volatile memories, such as register file
- * and RAMs, are erased before the Security bit is erased, i.e. deactivated.
- *
- * \warning A Lock Error is issued if at least one region is locked or the
- *          bootloader protection is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- */
-extern void flashc_erase_all(void);
-
-//! @}
-
-
-/*! \name FLASHC Protection Mechanisms
- */
-//! @{
-
-/*! \brief Tells whether the Security bit is active.
- *
- * \return Whether the Security bit is active.
- */
-extern Bool flashc_is_security_bit_active(void);
-
-/*! \brief Activates the Security bit.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_activate_security_bit(void);
-
-/*! \brief Gets the bootloader protected size.
- *
- * \return The bootloader protected size in bytes.
- */
-extern unsigned int flashc_get_bootloader_protected_size(void);
-
-/*! \brief Sets the bootloader protected size.
- *
- * \param bootprot_size The wanted bootloader protected size in bytes. If this
- *                      size is not supported, the actual size will be the
- *                      nearest greater available size or the maximal possible
- *                      size if the requested size is too large.
- *
- * \return The actual bootloader protected size in bytes.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern unsigned int flashc_set_bootloader_protected_size(unsigned int bootprot_size);
-
-/*! \brief Tells whether external privileged fetch is locked.
- *
- * \return Whether external privileged fetch is locked.
- */
-extern Bool flashc_is_external_privileged_fetch_locked(void);
-
-/*! \brief Locks or unlocks external privileged fetch.
- *
- * \param lock Whether to lock external privileged fetch: \c TRUE or \c FALSE.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_lock_external_privileged_fetch(Bool lock);
-
-/*! \brief Tells whether the region of a page is locked.
- *
- * \param page_number The page number:
- *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
- *        the flash array;
- *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
- *
- * \return Whether the region of the specified page is locked.
- */
-extern Bool flashc_is_page_region_locked(int page_number);
-
-/*! \brief Tells whether a region is locked.
- *
- * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
- *
- * \return Whether the specified region is locked.
- */
-extern Bool flashc_is_region_locked(unsigned int region);
-
-/*! \brief Locks or unlocks the region of a page.
- *
- * \param page_number The page number:
- *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
- *        the flash array;
- *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
- * \param lock Whether to lock the region of the specified page: \c TRUE or
- *             \c FALSE.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_lock_page_region(int page_number, Bool lock);
-
-/*! \brief Locks or unlocks a region.
- *
- * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
- * \param lock Whether to lock the specified region: \c TRUE or \c FALSE.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_lock_region(unsigned int region, Bool lock);
-
-/*! \brief Locks or unlocks all regions.
- *
- * \param lock Whether to lock the regions: \c TRUE or \c FALSE.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_lock_all_regions(Bool lock);
-
-//! @}
-
-
-/*! \name Access to General-Purpose Fuses
- */
-//! @{
-
-/*! \brief Reads a general-purpose fuse bit.
- *
- * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
- *
- * \return The value of the specified general-purpose fuse bit.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern Bool flashc_read_gp_fuse_bit(unsigned int gp_fuse_bit);
-
-/*! \brief Reads a general-purpose fuse bit-field.
- *
- * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
- *            \c 63.
- * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
- *              \c 64.
- *
- * \return The value of the specified general-purpose fuse bit-field.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern U64 flashc_read_gp_fuse_bitfield(unsigned int pos, unsigned int width);
-
-/*! \brief Reads a general-purpose fuse byte.
- *
- * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
- *
- * \return The value of the specified general-purpose fuse byte.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern U8 flashc_read_gp_fuse_byte(unsigned int gp_fuse_byte);
-
-/*! \brief Reads all general-purpose fuses.
- *
- * \return The value of all general-purpose fuses as a word.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern U64 flashc_read_all_gp_fuses(void);
-
-/*! \brief Erases a general-purpose fuse bit.
- *
- * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
- * \param check Whether to check erase: \c TRUE or \c FALSE.
- *
- * \return Whether the erase succeeded or always \c TRUE if erase check was not
- *         requested.
- *
- * \warning A Lock Error is issued if the Security bit is active and the command
- *          is applied to BOOTPROT or EPFL fuses.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern Bool flashc_erase_gp_fuse_bit(unsigned int gp_fuse_bit, Bool check);
-
-/*! \brief Erases a general-purpose fuse bit-field.
- *
- * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
- *            \c 63.
- * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
- *              \c 64.
- * \param check Whether to check erase: \c TRUE or \c FALSE.
- *
- * \return Whether the erase succeeded or always \c TRUE if erase check was not
- *         requested.
- *
- * \warning A Lock Error is issued if the Security bit is active and the command
- *          is applied to BOOTPROT or EPFL fuses.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern Bool flashc_erase_gp_fuse_bitfield(unsigned int pos, unsigned int width, Bool check);
-
-/*! \brief Erases a general-purpose fuse byte.
- *
- * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
- * \param check Whether to check erase: \c TRUE or \c FALSE.
- *
- * \return Whether the erase succeeded or always \c TRUE if erase check was not
- *         requested.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern Bool flashc_erase_gp_fuse_byte(unsigned int gp_fuse_byte, Bool check);
-
-/*! \brief Erases all general-purpose fuses.
- *
- * \param check Whether to check erase: \c TRUE or \c FALSE.
- *
- * \return Whether the erase succeeded or always \c TRUE if erase check was not
- *         requested.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern Bool flashc_erase_all_gp_fuses(Bool check);
-
-/*! \brief Writes a general-purpose fuse bit.
- *
- * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
- * \param value The value of the specified general-purpose fuse bit.
- *
- * \warning A Lock Error is issued if the Security bit is active and the command
- *          is applied to BOOTPROT or EPFL fuses.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note A write operation can only clear bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_write_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value);
-
-/*! \brief Writes a general-purpose fuse bit-field.
- *
- * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
- *            \c 63.
- * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
- *              \c 64.
- * \param value The value of the specified general-purpose fuse bit-field.
- *
- * \warning A Lock Error is issued if the Security bit is active and the command
- *          is applied to BOOTPROT or EPFL fuses.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note A write operation can only clear bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_write_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value);
-
-/*! \brief Writes a general-purpose fuse byte.
- *
- * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
- * \param value The value of the specified general-purpose fuse byte.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note A write operation can only clear bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_write_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value);
-
-/*! \brief Writes all general-purpose fuses.
- *
- * \param value The value of all general-purpose fuses as a word.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note A write operation can only clear bits.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_write_all_gp_fuses(U64 value);
-
-/*! \brief Sets a general-purpose fuse bit with the appropriate erase and write
- *         operations.
- *
- * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
- * \param value The value of the specified general-purpose fuse bit.
- *
- * \warning A Lock Error is issued if the Security bit is active and the command
- *          is applied to BOOTPROT or EPFL fuses.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_set_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value);
-
-/*! \brief Sets a general-purpose fuse bit-field with the appropriate erase and
- *         write operations.
- *
- * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
- *            \c 63.
- * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
- *              \c 64.
- * \param value The value of the specified general-purpose fuse bit-field.
- *
- * \warning A Lock Error is issued if the Security bit is active and the command
- *          is applied to BOOTPROT or EPFL fuses.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_set_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value);
-
-/*! \brief Sets a general-purpose fuse byte with the appropriate erase and write
- *         operations.
- *
- * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
- * \param value The value of the specified general-purpose fuse byte.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_set_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value);
-
-/*! \brief Sets all general-purpose fuses with the appropriate erase and write
- *         operations.
- *
- * \param value The value of all general-purpose fuses as a word.
- *
- * \warning A Lock Error is issued if the Security bit is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note The actual number of general-purpose fuse bits implemented by hardware
- *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
- *       fixed at 1 by hardware.
- */
-extern void flashc_set_all_gp_fuses(U64 value);
-
-//! @}
-
-
-/*! \name Access to Flash Pages
- */
-//! @{
-
-/*! \brief Clears the page buffer.
- *
- * This command resets all bits in the page buffer to one. Write accesses to the
- * page buffer can only change page buffer bits from one to zero.
- *
- * \warning The page buffer is not automatically reset after a page write.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern void flashc_clear_page_buffer(void);
-
-/*! \brief Tells whether the page to which the last Quick Page Read or Quick
- *         Page Read User Page command was applied was erased.
- *
- * \return Whether the page to which the last Quick Page Read or Quick Page Read
- *         User Page command was applied was erased.
- */
-extern Bool flashc_is_page_erased(void);
-
-/*! \brief Applies the Quick Page Read command to a page.
- *
- * \param page_number The page number:
- *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
- *        the flash array;
- *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
- *
- * \return Whether the specified page is erased.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern Bool flashc_quick_page_read(int page_number);
-
-/*! \brief Erases a page.
- *
- * \param page_number The page number:
- *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
- *        the flash array;
- *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
- * \param check Whether to check erase: \c TRUE or \c FALSE.
- *
- * \return Whether the erase succeeded or always \c TRUE if erase check was not
- *         requested.
- *
- * \warning A Lock Error is issued if the command is applied to a page belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- */
-extern Bool flashc_erase_page(int page_number, Bool check);
-
-/*! \brief Erases all pages within the flash array.
- *
- * \param check Whether to check erase: \c TRUE or \c FALSE.
- *
- * \return Whether the erase succeeded or always \c TRUE if erase check was not
- *         requested.
- *
- * \warning A Lock Error is issued if at least one region is locked or the
- *          bootloader protection is active.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- */
-extern Bool flashc_erase_all_pages(Bool check);
-
-/*! \brief Writes a page from the page buffer.
- *
- * \param page_number The page number:
- *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
- *        the flash array;
- *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
- *
- * \warning A Lock Error is issued if the command is applied to a page belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \warning The page buffer is not automatically reset after a page write.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note A write operation can only clear bits.
- */
-extern void flashc_write_page(int page_number);
-
-/*! \brief Issues a Quick Page Read User Page command to the FLASHC.
- *
- * \return Whether the User page is erased.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern Bool flashc_quick_user_page_read(void);
-
-/*! \brief Erases the User page.
- *
- * \param check Whether to check erase: \c TRUE or \c FALSE.
- *
- * \return Whether the erase succeeded or always \c TRUE if erase check was not
- *         requested.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note An erase operation can only set bits.
- */
-extern Bool flashc_erase_user_page(Bool check);
-
-/*! \brief Writes the User page from the page buffer.
- *
- * \warning The page buffer is not automatically reset after a page write.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- *
- * \note A write operation can only clear bits.
- */
-extern void flashc_write_user_page(void);
-
-/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
- *         from the repeated \a src source byte.
- *
- * The destination areas that are not within the flash array or the User page
- * are ignored.
- *
- * All pointer and size alignments are supported.
- *
- * \param dst Pointer to flash destination.
- * \param src Source byte.
- * \param nbytes Number of bytes to set.
- * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
- *
- * \return The value of \a dst.
- *
- * \warning This function may be called with \a erase set to \c FALSE only if
- *          the destination consists only of erased bytes, i.e. this function
- *          can not be used to write only one bit of a previously written byte.
- *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
- *          value in flash may be different from \c 0x00.
- *
- * \warning A Lock Error is issued if the command is applied to pages belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern volatile void *flashc_memset8(volatile void *dst, U8 src, size_t nbytes, Bool erase);
-
-/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
- *         from the repeated \a src big-endian source half-word.
- *
- * The destination areas that are not within the flash array or the User page
- * are ignored.
- *
- * All pointer and size alignments are supported.
- *
- * \param dst Pointer to flash destination.
- * \param src Source half-word.
- * \param nbytes Number of bytes to set.
- * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
- *
- * \return The value of \a dst.
- *
- * \warning This function may be called with \a erase set to \c FALSE only if
- *          the destination consists only of erased bytes, i.e. this function
- *          can not be used to write only one bit of a previously written byte.
- *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
- *          value in flash may be different from \c 0x00.
- *
- * \warning A Lock Error is issued if the command is applied to pages belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern volatile void *flashc_memset16(volatile void *dst, U16 src, size_t nbytes, Bool erase);
-
-/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
- *         from the repeated \a src big-endian source word.
- *
- * The destination areas that are not within the flash array or the User page
- * are ignored.
- *
- * All pointer and size alignments are supported.
- *
- * \param dst Pointer to flash destination.
- * \param src Source word.
- * \param nbytes Number of bytes to set.
- * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
- *
- * \return The value of \a dst.
- *
- * \warning This function may be called with \a erase set to \c FALSE only if
- *          the destination consists only of erased bytes, i.e. this function
- *          can not be used to write only one bit of a previously written byte.
- *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
- *          value in flash may be different from \c 0x00.
- *
- * \warning A Lock Error is issued if the command is applied to pages belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern volatile void *flashc_memset32(volatile void *dst, U32 src, size_t nbytes, Bool erase);
-
-/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
- *         from the repeated \a src big-endian source double-word.
- *
- * The destination areas that are not within the flash array or the User page
- * are ignored.
- *
- * All pointer and size alignments are supported.
- *
- * \param dst Pointer to flash destination.
- * \param src Source double-word.
- * \param nbytes Number of bytes to set.
- * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
- *
- * \return The value of \a dst.
- *
- * \warning This function may be called with \a erase set to \c FALSE only if
- *          the destination consists only of erased bytes, i.e. this function
- *          can not be used to write only one bit of a previously written byte.
- *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
- *          value in flash may be different from \c 0x00.
- *
- * \warning A Lock Error is issued if the command is applied to pages belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase);
-
-/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
- *         from the repeated \a src big-endian source pattern.
- *
- * The destination areas that are not within the flash array or the User page
- * are ignored.
- *
- * All pointer and size alignments are supported.
- *
- * \param dst Pointer to flash destination.
- * \param src Source double-word.
- * \param src_width \a src width in bits: 8, 16, 32 or 64.
- * \param nbytes Number of bytes to set.
- * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
- *
- * \return The value of \a dst.
- *
- * \warning This function may be called with \a erase set to \c FALSE only if
- *          the destination consists only of erased bytes, i.e. this function
- *          can not be used to write only one bit of a previously written byte.
- *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
- *          value in flash may be different from \c 0x00.
- *
- * \warning A Lock Error is issued if the command is applied to pages belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-#define flashc_memset(dst, src, src_width, nbytes, erase) \
-          TPASTE2(flashc_memset, src_width)((dst), (src), (nbytes), (erase))
-
-/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
- *         from the source pointed to by \a src.
- *
- * The destination areas that are not within the flash array or the User page
- * are ignored.
- *
- * All pointer and size alignments are supported.
- *
- * \param dst Pointer to flash destination.
- * \param src Pointer to source data.
- * \param nbytes Number of bytes to copy.
- * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
- *
- * \return The value of \a dst.
- *
- * \warning If copying takes place between areas that overlap, the behavior is
- *          undefined.
- *
- * \warning This function may be called with \a erase set to \c FALSE only if
- *          the destination consists only of erased bytes, i.e. this function
- *          can not be used to write only one bit of a previously written byte.
- *          E.g., if \c 0x01 then \c 0xFE are written to a byte, the resulting
- *          value in flash may be different from \c 0x00.
- *
- * \warning A Lock Error is issued if the command is applied to pages belonging
- *          to a locked region or to the bootloader protected area.
- *
- * \note The FLASHC error status returned by \ref flashc_is_lock_error and
- *       \ref flashc_is_programming_error is updated.
- */
-extern volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase);
-
-//! @}
-
-
-#endif  // _FLASHC_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief FLASHC driver for AVR32 UC3.
+ *
+ * AVR32 Flash Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a FLASHC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _FLASHC_H_
+#define _FLASHC_H_
+
+#include &lt;avr32/io.h&gt;
+#include &lt;stddef.h&gt;
+#include &quot;compiler.h&quot;
+
+
+//! Number of flash regions defined by the FLASHC.
+#define AVR32_FLASHC_REGIONS  (AVR32_FLASHC_FLASH_SIZE /\
+                               (AVR32_FLASHC_PAGES_PR_REGION * AVR32_FLASHC_PAGE_SIZE))
+
+
+/*! \name Flash Properties
+ */
+//! @{
+
+/*! \brief Gets the size of the whole flash array.
+ *
+ * \return The size of the whole flash array in bytes.
+ */
+extern unsigned int flashc_get_flash_size(void);
+
+/*! \brief Gets the total number of pages in the flash array.
+ *
+ * \return The total number of pages in the flash array.
+ */
+extern unsigned int flashc_get_page_count(void);
+
+/*! \brief Gets the number of pages in each flash region.
+ *
+ * \return The number of pages in each flash region.
+ */
+extern unsigned int flashc_get_page_count_per_region(void);
+
+/*! \brief Gets the region number of a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \return The region number of the specified page.
+ */
+extern unsigned int flashc_get_page_region(int page_number);
+
+/*! \brief Gets the number of the first page of a region.
+ *
+ * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
+ *
+ * \return The number of the first page of the specified region.
+ */
+extern unsigned int flashc_get_region_first_page_number(unsigned int region);
+
+//! @}
+
+
+/*! \name FLASHC Control
+ */
+//! @{
+
+/*! \brief Gets the number of wait states of flash read accesses.
+ *
+ * \return The number of wait states of flash read accesses.
+ */
+extern unsigned int flashc_get_wait_state(void);
+
+/*! \brief Sets the number of wait states of flash read accesses.
+ *
+ * \param wait_state The number of wait states of flash read accesses: \c 0 to
+ *                   \c 1.
+ */
+extern void flashc_set_wait_state(unsigned int wait_state);
+
+/*! \brief Tells whether the Flash Ready interrupt is enabled.
+ *
+ * \return Whether the Flash Ready interrupt is enabled.
+ */
+extern Bool flashc_is_ready_int_enabled(void);
+
+/*! \brief Enables or disables the Flash Ready interrupt.
+ *
+ * \param enable Whether to enable the Flash Ready interrupt: \c TRUE or
+ *               \c FALSE.
+ */
+extern void flashc_enable_ready_int(Bool enable);
+
+/*! \brief Tells whether the Lock Error interrupt is enabled.
+ *
+ * \return Whether the Lock Error interrupt is enabled.
+ */
+extern Bool flashc_is_lock_error_int_enabled(void);
+
+/*! \brief Enables or disables the Lock Error interrupt.
+ *
+ * \param enable Whether to enable the Lock Error interrupt: \c TRUE or
+ *               \c FALSE.
+ */
+extern void flashc_enable_lock_error_int(Bool enable);
+
+/*! \brief Tells whether the Programming Error interrupt is enabled.
+ *
+ * \return Whether the Programming Error interrupt is enabled.
+ */
+extern Bool flashc_is_prog_error_int_enabled(void);
+
+/*! \brief Enables or disables the Programming Error interrupt.
+ *
+ * \param enable Whether to enable the Programming Error interrupt: \c TRUE or
+ *               \c FALSE.
+ */
+extern void flashc_enable_prog_error_int(Bool enable);
+
+//! @}
+
+
+/*! \name FLASHC Status
+ */
+//! @{
+
+/*! \brief Tells whether the FLASHC is ready to run a new command.
+ *
+ * \return Whether the FLASHC is ready to run a new command.
+ */
+extern Bool flashc_is_ready(void);
+
+/*! \brief Waits actively until the FLASHC is ready to run a new command.
+ *
+ * This is the default function assigned to \ref flashc_wait_until_ready.
+ */
+extern void flashc_default_wait_until_ready(void);
+
+//! Pointer to the function used by the driver when it needs to wait until the
+//! FLASHC is ready to run a new command.
+//! The default function is \ref flashc_default_wait_until_ready.
+//! The user may change this pointer to use another implementation.
+extern void (*volatile flashc_wait_until_ready)(void);
+
+/*! \brief Tells whether a Lock Error has occurred during the last function
+ *         called that issued one or more FLASHC commands.
+ *
+ * \return Whether a Lock Error has occurred during the last function called
+ *         that issued one or more FLASHC commands.
+ */
+extern Bool flashc_is_lock_error(void);
+
+/*! \brief Tells whether a Programming Error has occurred during the last
+ *         function called that issued one or more FLASHC commands.
+ *
+ * \return Whether a Programming Error has occurred during the last function
+ *         called that issued one or more FLASHC commands.
+ */
+extern Bool flashc_is_programming_error(void);
+
+//! @}
+
+
+/*! \name FLASHC Command Control
+ */
+//! @{
+
+/*! \brief Gets the last issued FLASHC command.
+ *
+ * \return The last issued FLASHC command.
+ */
+extern unsigned int flashc_get_command(void);
+
+/*! \brief Gets the current FLASHC page number.
+ *
+ * \return The current FLASHC page number.
+ */
+extern unsigned int flashc_get_page_number(void);
+
+/*! \brief Issues a FLASHC command.
+ *
+ * \param command The command: \c AVR32_FLASHC_FCMD_CMD_x.
+ * \param page_number The page number to apply the command to:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: use this to apply the command to the current page number
+ *        or if the command does not apply to any page number;
+ *   \arg this argument may have other meanings according to the command. See
+ *        the FLASHC chapter of the MCU datasheet.
+ *
+ * \warning A Lock Error is issued if the command violates the protection
+ *          mechanism.
+ *
+ * \warning A Programming Error is issued if the command is invalid.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_issue_command(unsigned int command, int page_number);
+
+//! @}
+
+
+/*! \name FLASHC Global Commands
+ */
+//! @{
+
+/*! \brief Issues a No Operation command to the FLASHC.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_no_operation(void);
+
+/*! \brief Issues an Erase All command to the FLASHC.
+ *
+ * This command erases all bits in the flash array, the general-purpose fuse
+ * bits and the Security bit. The User page is not erased.
+ *
+ * This command also ensures that all volatile memories, such as register file
+ * and RAMs, are erased before the Security bit is erased, i.e. deactivated.
+ *
+ * \warning A Lock Error is issued if at least one region is locked or the
+ *          bootloader protection is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern void flashc_erase_all(void);
+
+//! @}
+
+
+/*! \name FLASHC Protection Mechanisms
+ */
+//! @{
+
+/*! \brief Tells whether the Security bit is active.
+ *
+ * \return Whether the Security bit is active.
+ */
+extern Bool flashc_is_security_bit_active(void);
+
+/*! \brief Activates the Security bit.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_activate_security_bit(void);
+
+/*! \brief Gets the bootloader protected size.
+ *
+ * \return The bootloader protected size in bytes.
+ */
+extern unsigned int flashc_get_bootloader_protected_size(void);
+
+/*! \brief Sets the bootloader protected size.
+ *
+ * \param bootprot_size The wanted bootloader protected size in bytes. If this
+ *                      size is not supported, the actual size will be the
+ *                      nearest greater available size or the maximal possible
+ *                      size if the requested size is too large.
+ *
+ * \return The actual bootloader protected size in bytes.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern unsigned int flashc_set_bootloader_protected_size(unsigned int bootprot_size);
+
+/*! \brief Tells whether external privileged fetch is locked.
+ *
+ * \return Whether external privileged fetch is locked.
+ */
+extern Bool flashc_is_external_privileged_fetch_locked(void);
+
+/*! \brief Locks or unlocks external privileged fetch.
+ *
+ * \param lock Whether to lock external privileged fetch: \c TRUE or \c FALSE.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_external_privileged_fetch(Bool lock);
+
+/*! \brief Tells whether the region of a page is locked.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \return Whether the region of the specified page is locked.
+ */
+extern Bool flashc_is_page_region_locked(int page_number);
+
+/*! \brief Tells whether a region is locked.
+ *
+ * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
+ *
+ * \return Whether the specified region is locked.
+ */
+extern Bool flashc_is_region_locked(unsigned int region);
+
+/*! \brief Locks or unlocks the region of a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ * \param lock Whether to lock the region of the specified page: \c TRUE or
+ *             \c FALSE.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_page_region(int page_number, Bool lock);
+
+/*! \brief Locks or unlocks a region.
+ *
+ * \param region The region number: \c 0 to &lt;tt&gt;(AVR32_FLASHC_REGIONS - 1)&lt;/tt&gt;.
+ * \param lock Whether to lock the specified region: \c TRUE or \c FALSE.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_region(unsigned int region, Bool lock);
+
+/*! \brief Locks or unlocks all regions.
+ *
+ * \param lock Whether to lock the regions: \c TRUE or \c FALSE.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_lock_all_regions(Bool lock);
+
+//! @}
+
+
+/*! \name Access to General-Purpose Fuses
+ */
+//! @{
+
+/*! \brief Reads a general-purpose fuse bit.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ *
+ * \return The value of the specified general-purpose fuse bit.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_read_gp_fuse_bit(unsigned int gp_fuse_bit);
+
+/*! \brief Reads a general-purpose fuse bit-field.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ *
+ * \return The value of the specified general-purpose fuse bit-field.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern U64 flashc_read_gp_fuse_bitfield(unsigned int pos, unsigned int width);
+
+/*! \brief Reads a general-purpose fuse byte.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ *
+ * \return The value of the specified general-purpose fuse byte.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern U8 flashc_read_gp_fuse_byte(unsigned int gp_fuse_byte);
+
+/*! \brief Reads all general-purpose fuses.
+ *
+ * \return The value of all general-purpose fuses as a word.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern U64 flashc_read_all_gp_fuses(void);
+
+/*! \brief Erases a general-purpose fuse bit.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_gp_fuse_bit(unsigned int gp_fuse_bit, Bool check);
+
+/*! \brief Erases a general-purpose fuse bit-field.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_gp_fuse_bitfield(unsigned int pos, unsigned int width, Bool check);
+
+/*! \brief Erases a general-purpose fuse byte.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_gp_fuse_byte(unsigned int gp_fuse_byte, Bool check);
+
+/*! \brief Erases all general-purpose fuses.
+ *
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern Bool flashc_erase_all_gp_fuses(Bool check);
+
+/*! \brief Writes a general-purpose fuse bit.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ * \param value The value of the specified general-purpose fuse bit.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value);
+
+/*! \brief Writes a general-purpose fuse bit-field.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ * \param value The value of the specified general-purpose fuse bit-field.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value);
+
+/*! \brief Writes a general-purpose fuse byte.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ * \param value The value of the specified general-purpose fuse byte.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value);
+
+/*! \brief Writes all general-purpose fuses.
+ *
+ * \param value The value of all general-purpose fuses as a word.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_write_all_gp_fuses(U64 value);
+
+/*! \brief Sets a general-purpose fuse bit with the appropriate erase and write
+ *         operations.
+ *
+ * \param gp_fuse_bit The general-purpose fuse bit: \c 0 to \c 63.
+ * \param value The value of the specified general-purpose fuse bit.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_gp_fuse_bit(unsigned int gp_fuse_bit, Bool value);
+
+/*! \brief Sets a general-purpose fuse bit-field with the appropriate erase and
+ *         write operations.
+ *
+ * \param pos The bit-position of the general-purpose fuse bit-field: \c 0 to
+ *            \c 63.
+ * \param width The bit-width of the general-purpose fuse bit-field: \c 0 to
+ *              \c 64.
+ * \param value The value of the specified general-purpose fuse bit-field.
+ *
+ * \warning A Lock Error is issued if the Security bit is active and the command
+ *          is applied to BOOTPROT or EPFL fuses.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_gp_fuse_bitfield(unsigned int pos, unsigned int width, U64 value);
+
+/*! \brief Sets a general-purpose fuse byte with the appropriate erase and write
+ *         operations.
+ *
+ * \param gp_fuse_byte The general-purpose fuse byte: \c 0 to \c 7.
+ * \param value The value of the specified general-purpose fuse byte.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_gp_fuse_byte(unsigned int gp_fuse_byte, U8 value);
+
+/*! \brief Sets all general-purpose fuses with the appropriate erase and write
+ *         operations.
+ *
+ * \param value The value of all general-purpose fuses as a word.
+ *
+ * \warning A Lock Error is issued if the Security bit is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note The actual number of general-purpose fuse bits implemented by hardware
+ *       is given by \c AVR32_FLASHC_GPF_NUM. The other bits among the 64 are
+ *       fixed at 1 by hardware.
+ */
+extern void flashc_set_all_gp_fuses(U64 value);
+
+//! @}
+
+
+/*! \name Access to Flash Pages
+ */
+//! @{
+
+/*! \brief Clears the page buffer.
+ *
+ * This command resets all bits in the page buffer to one. Write accesses to the
+ * page buffer can only change page buffer bits from one to zero.
+ *
+ * \warning The page buffer is not automatically reset after a page write.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern void flashc_clear_page_buffer(void);
+
+/*! \brief Tells whether the page to which the last Quick Page Read or Quick
+ *         Page Read User Page command was applied was erased.
+ *
+ * \return Whether the page to which the last Quick Page Read or Quick Page Read
+ *         User Page command was applied was erased.
+ */
+extern Bool flashc_is_page_erased(void);
+
+/*! \brief Applies the Quick Page Read command to a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \return Whether the specified page is erased.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern Bool flashc_quick_page_read(int page_number);
+
+/*! \brief Erases a page.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if the command is applied to a page belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern Bool flashc_erase_page(int page_number, Bool check);
+
+/*! \brief Erases all pages within the flash array.
+ *
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \warning A Lock Error is issued if at least one region is locked or the
+ *          bootloader protection is active.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern Bool flashc_erase_all_pages(Bool check);
+
+/*! \brief Writes a page from the page buffer.
+ *
+ * \param page_number The page number:
+ *   \arg \c 0 to &lt;tt&gt;(flashc_get_page_count() - 1)&lt;/tt&gt;: a page number within
+ *        the flash array;
+ *   \arg &lt;tt&gt;&lt; 0&lt;/tt&gt;: the current page number.
+ *
+ * \warning A Lock Error is issued if the command is applied to a page belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \warning The page buffer is not automatically reset after a page write.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ */
+extern void flashc_write_page(int page_number);
+
+/*! \brief Issues a Quick Page Read User Page command to the FLASHC.
+ *
+ * \return Whether the User page is erased.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern Bool flashc_quick_user_page_read(void);
+
+/*! \brief Erases the User page.
+ *
+ * \param check Whether to check erase: \c TRUE or \c FALSE.
+ *
+ * \return Whether the erase succeeded or always \c TRUE if erase check was not
+ *         requested.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note An erase operation can only set bits.
+ */
+extern Bool flashc_erase_user_page(Bool check);
+
+/*! \brief Writes the User page from the page buffer.
+ *
+ * \warning The page buffer is not automatically reset after a page write.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ *
+ * \note A write operation can only clear bits.
+ */
+extern void flashc_write_user_page(void);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src source byte.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source byte.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased words, i.e. this function
+ *          can not be used to write only one bit of a previously written word.
+ *          E.g., if \c 0x00000001 then \c 0xFFFFFFFE are written to a word, the
+ *          resulting value in flash may be different from \c 0x00000000.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset8(volatile void *dst, U8 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source half-word.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source half-word.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased words, i.e. this function
+ *          can not be used to write only one bit of a previously written word.
+ *          E.g., if \c 0x00000001 then \c 0xFFFFFFFE are written to a word, the
+ *          resulting value in flash may be different from \c 0x00000000.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset16(volatile void *dst, U16 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source word.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source word.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased words, i.e. this function
+ *          can not be used to write only one bit of a previously written word.
+ *          E.g., if \c 0x00000001 then \c 0xFFFFFFFE are written to a word, the
+ *          resulting value in flash may be different from \c 0x00000000.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset32(volatile void *dst, U32 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source double-word.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source double-word.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased words, i.e. this function
+ *          can not be used to write only one bit of a previously written word.
+ *          E.g., if \c 0x00000001 then \c 0xFFFFFFFE are written to a word, the
+ *          resulting value in flash may be different from \c 0x00000000.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase);
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the repeated \a src big-endian source pattern.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Source double-word.
+ * \param src_width \a src width in bits: 8, 16, 32 or 64.
+ * \param nbytes Number of bytes to set.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased words, i.e. this function
+ *          can not be used to write only one bit of a previously written word.
+ *          E.g., if \c 0x00000001 then \c 0xFFFFFFFE are written to a word, the
+ *          resulting value in flash may be different from \c 0x00000000.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+#define flashc_memset(dst, src, src_width, nbytes, erase) \
+          TPASTE2(flashc_memset, src_width)((dst), (src), (nbytes), (erase))
+
+/*! \brief Copies \a nbytes bytes to the flash destination pointed to by \a dst
+ *         from the source pointed to by \a src.
+ *
+ * The destination areas that are not within the flash array or the User page
+ * are ignored.
+ *
+ * All pointer and size alignments are supported.
+ *
+ * \param dst Pointer to flash destination.
+ * \param src Pointer to source data.
+ * \param nbytes Number of bytes to copy.
+ * \param erase Whether to erase before writing: \c TRUE or \c FALSE.
+ *
+ * \return The value of \a dst.
+ *
+ * \warning If copying takes place between areas that overlap, the behavior is
+ *          undefined.
+ *
+ * \warning This function may be called with \a erase set to \c FALSE only if
+ *          the destination consists only of erased words, i.e. this function
+ *          can not be used to write only one bit of a previously written word.
+ *          E.g., if \c 0x00000001 then \c 0xFFFFFFFE are written to a word, the
+ *          resulting value in flash may be different from \c 0x00000000.
+ *
+ * \warning A Lock Error is issued if the command is applied to pages belonging
+ *          to a locked region or to the bootloader protected area.
+ *
+ * \note The FLASHC error status returned by \ref flashc_is_lock_error and
+ *       \ref flashc_is_programming_error is updated.
+ */
+extern volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase);
+
+#if ( defined (__GNUC__) &amp;&amp; ( defined (__AVR32_UC3C064C__) || defined (__AVR32_UC3C0128C__) || defined (__AVR32_UC3C0256C__) || defined (__AVR32_UC3C0512C__) || defined (__AVR32_UC3C164C__) || defined (__AVR32_UC3C1128C__) || defined (__AVR32_UC3C1256C__) || defined (__AVR32_UC3C1512C__) || defined (__AVR32_UC3C264C__) || defined (__AVR32_UC3C2128C__) || defined (__AVR32_UC3C2256C__) || defined (__AVR32_UC3C2512C__))) \
+  ||( defined (__ICCAVR32__) &amp;&amp; ( defined (__AT32UC3C064C__) || defined (__AT32UC3C0128C__) || defined (__AT32UC3C0256C__) || defined (__AT32UC3C0512C__) || defined (__AT32UC3C164C__) || defined (__AT32UC3C1128C__) || defined (__AT32UC3C1256C__) || defined (__AT32UC3C1512C__) || defined (__AT32UC3C264C__) || defined (__AT32UC3C2128C__) || defined (__AT32UC3C2256C__) || defined (__AT32UC3C2512C__)))
+
+/*! \brief Depednding to the CPU frequency, set the wait states of flash read
+ *         accesses and enable or disable the High speed read mode.
+ *
+ * \param cpu_f_hz The CPU frequency
+ */
+void flashc_set_flash_waitstate_and_readmode(unsigned long cpu_f_hz);
+#endif // UC3C device-specific implementation
+
+//! @}
+
+
+#endif  // _FLASHC_H_

Modified: trunk/src/platform/avr32/gpio.c
===================================================================
--- trunk/src/platform/avr32/gpio.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/gpio.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,270 +1,461 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file has been prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief GPIO driver for AVR32 UC3.
- *
- * This file defines a useful set of functions for the GPIO.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a GPIO module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- *****************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &quot;gpio.h&quot;
-
-
-//! GPIO module instance.
-#define GPIO  AVR32_GPIO
-
-
-/*! \name Peripheral Bus Interface
- */
-//! @{
-
-
-int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size)
-{
-  int status = GPIO_SUCCESS;
-  unsigned int i;
-
-  for (i = 0; i &lt; size; i++)
-  {
-    status |= gpio_enable_module_pin(gpiomap-&gt;pin, gpiomap-&gt;function);
-    gpiomap++;
-  }
-
-  return status;
-}
-
-
-int gpio_enable_module_pin(unsigned int pin, unsigned int function)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-
-  // Enable the correct function.
-  switch (function)
-  {
-  case 0: // A function.
-    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
-    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
-    break;
-
-  case 1: // B function.
-    gpio_port-&gt;pmr0s = 1 &lt;&lt; (pin &amp; 0x1F);
-    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
-    break;
-
-  case 2: // C function.
-    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
-    gpio_port-&gt;pmr1s = 1 &lt;&lt; (pin &amp; 0x1F);
-    break;
-
-  default:
-    return GPIO_INVALID_ARGUMENT;
-  }
-
-  // Disable GPIO control.
-  gpio_port-&gt;gperc = 1 &lt;&lt; (pin &amp; 0x1F);
-
-  return GPIO_SUCCESS;
-}
-
-
-void gpio_enable_gpio(const gpio_map_t gpiomap, unsigned int size)
-{
-  unsigned int i;
-
-  for (i = 0; i &lt; size; i++)
-  {
-    gpio_enable_gpio_pin(gpiomap-&gt;pin);
-    gpiomap++;
-  }
-}
-
-
-void gpio_enable_gpio_pin(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;oderc = 1 &lt;&lt; (pin &amp; 0x1F);
-  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-void gpio_enable_pin_open_drain(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;odmers = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-void gpio_disable_pin_open_drain(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;odmerc = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-void gpio_enable_pin_pull_up(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;puers = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-void gpio_disable_pin_pull_up(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;puerc = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-int gpio_get_pin_value(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  return (gpio_port-&gt;pvr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
-}
-
-
-int gpio_get_gpio_pin_output_value(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  return (gpio_port-&gt;ovr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
-}
-
-
-void gpio_set_gpio_pin(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-
-  gpio_port-&gt;ovrs  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line: 1.
-  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
-  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
-}
-
-
-void gpio_clr_gpio_pin(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-
-  gpio_port-&gt;ovrc  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line: 0.
-  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
-  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
-}
-
-
-void gpio_tgl_gpio_pin(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-
-  gpio_port-&gt;ovrt  = 1 &lt;&lt; (pin &amp; 0x1F); // Toggle the I/O line.
-  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
-  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
-}
-
-
-void gpio_enable_pin_glitch_filter(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;gfers = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-void gpio_disable_pin_glitch_filter(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;gferc = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-int gpio_enable_pin_interrupt(unsigned int pin, unsigned int mode)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-
-  // Enable the glitch filter.
-  gpio_port-&gt;gfers = 1 &lt;&lt; (pin &amp; 0x1F);
-
-  // Configure the edge detector.
-  switch (mode)
-  {
-  case GPIO_PIN_CHANGE:
-    gpio_port-&gt;imr0c = 1 &lt;&lt; (pin &amp; 0x1F);
-    gpio_port-&gt;imr1c = 1 &lt;&lt; (pin &amp; 0x1F);
-    break;
-
-  case GPIO_RISING_EDGE:
-    gpio_port-&gt;imr0s = 1 &lt;&lt; (pin &amp; 0x1F);
-    gpio_port-&gt;imr1c = 1 &lt;&lt; (pin &amp; 0x1F);
-    break;
-
-  case GPIO_FALLING_EDGE:
-    gpio_port-&gt;imr0c = 1 &lt;&lt; (pin &amp; 0x1F);
-    gpio_port-&gt;imr1s = 1 &lt;&lt; (pin &amp; 0x1F);
-    break;
-
-  default:
-    return GPIO_INVALID_ARGUMENT;
-  }
-
-  // Enable interrupt.
-  gpio_port-&gt;iers = 1 &lt;&lt; (pin &amp; 0x1F);
-
-  return GPIO_SUCCESS;
-}
-
-
-void gpio_disable_pin_interrupt(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;ierc = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-int gpio_get_pin_interrupt_flag(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  return (gpio_port-&gt;ifr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
-}
-
-
-void gpio_clear_pin_interrupt_flag(unsigned int pin)
-{
-  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
-  gpio_port-&gt;ifrc = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-
-//! @}
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief GPIO driver for AVR32 UC3.
+ *
+ * This file defines a useful set of functions for the GPIO.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a GPIO module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &quot;gpio.h&quot;
+
+
+//! GPIO module instance.
+#define GPIO  AVR32_GPIO
+
+
+/*! \name Peripheral Bus Interface
+ */
+//! @{
+
+
+int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size)
+{
+  int status = GPIO_SUCCESS;
+  unsigned int i;
+
+  for (i = 0; i &lt; size; i++)
+  {
+    status |= gpio_enable_module_pin(gpiomap-&gt;pin, gpiomap-&gt;function);
+    gpiomap++;
+  }
+
+  return status;
+}
+
+
+int gpio_enable_module_pin(unsigned int pin, unsigned int function)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  // Enable the correct function.
+  switch (function)
+  {
+  case 0: // A function.
+    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+#if defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+    gpio_port-&gt;pmr2c = 1 &lt;&lt; (pin &amp; 0x1F);
+#endif
+    break;
+
+  case 1: // B function.
+    gpio_port-&gt;pmr0s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+#if defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+    gpio_port-&gt;pmr2c = 1 &lt;&lt; (pin &amp; 0x1F);
+#endif
+    break;
+
+  case 2: // C function.
+    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1s = 1 &lt;&lt; (pin &amp; 0x1F);
+#if defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+    gpio_port-&gt;pmr2c = 1 &lt;&lt; (pin &amp; 0x1F);
+#endif
+    break;
+
+  case 3: // D function.
+    gpio_port-&gt;pmr0s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1s = 1 &lt;&lt; (pin &amp; 0x1F);
+#if defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+    gpio_port-&gt;pmr2c = 1 &lt;&lt; (pin &amp; 0x1F);
+#endif
+    break;
+
+#if defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+  case 4: // E function.
+    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr2s = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+    
+  case 5: // F function.
+    gpio_port-&gt;pmr0s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr2s = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+    
+  case 6: // G function.
+    gpio_port-&gt;pmr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr2s = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+    
+  case 7: // H function.
+    gpio_port-&gt;pmr0s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr1s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;pmr2s = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+#endif
+
+  default:
+    return GPIO_INVALID_ARGUMENT;
+  }
+
+  // Disable GPIO control.
+  gpio_port-&gt;gperc = 1 &lt;&lt; (pin &amp; 0x1F);
+
+  return GPIO_SUCCESS;
+}
+
+
+void gpio_enable_gpio(const gpio_map_t gpiomap, unsigned int size)
+{
+  unsigned int i;
+
+  for (i = 0; i &lt; size; i++)
+  {
+    gpio_enable_gpio_pin(gpiomap-&gt;pin);
+    gpiomap++;
+  }
+}
+
+
+void gpio_enable_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;oderc = 1 &lt;&lt; (pin &amp; 0x1F);
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+// The open-drain mode is not synthesized on the current AVR32 products.
+// If one day some AVR32 products have this feature, the corresponding part
+// numbers should be listed in the #if below.
+// Note that other functions are available in this driver to use pins with open
+// drain in GPIO mode. The advantage of the open-drain mode functions over these
+// other functions is that they can be used not only in GPIO mode but also in
+// module mode.
+#if 0
+
+
+void gpio_enable_pin_open_drain(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;odmers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+void gpio_disable_pin_open_drain(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;odmerc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+#endif
+
+
+void gpio_enable_pin_pull_up(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;puers = 1 &lt;&lt; (pin &amp; 0x1F);
+#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+  gpio_port-&gt;pderc = 1 &lt;&lt; (pin &amp; 0x1F);
+#endif
+}
+
+
+void gpio_disable_pin_pull_up(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;puerc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+// Added support of Pull-up Resistor, Pull-down Resistor and Buskeeper Control.
+
+/*! \brief Enables the pull-down resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+void gpio_enable_pin_pull_down(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;puerc = 1 &lt;&lt; (pin &amp; 0x1F);
+  gpio_port-&gt;pders = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Disables the pull-down resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+void gpio_disable_pin_pull_down(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;pderc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Enables the buskeeper functionality on a pin.
+ *
+ * \param pin The pin number.
+ */
+void gpio_enable_pin_buskeeper(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;puers = 1 &lt;&lt; (pin &amp; 0x1F);
+  gpio_port-&gt;pders = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Disables the buskeeper functionality on a pin.
+ *
+ * \param pin The pin number.
+ */
+void gpio_disable_pin_buskeeper(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;puerc = 1 &lt;&lt; (pin &amp; 0x1F);
+  gpio_port-&gt;pderc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+#endif
+
+int gpio_get_pin_value(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  return (gpio_port-&gt;pvr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+
+int gpio_get_gpio_pin_output_value(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  return (gpio_port-&gt;ovr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+
+int gpio_get_gpio_open_drain_pin_output_value(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  return ((gpio_port-&gt;oder &gt;&gt; (pin &amp; 0x1F)) &amp; 1) ^ 1;
+}
+
+
+void gpio_set_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrs  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line: 1.
+  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_clr_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrc  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line: 0.
+  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_tgl_gpio_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrt  = 1 &lt;&lt; (pin &amp; 0x1F); // Toggle the I/O line.
+  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_set_gpio_open_drain_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;oderc = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is disabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_clr_gpio_open_drain_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrc  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line: 0.
+  gpio_port-&gt;oders = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is enabled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_tgl_gpio_open_drain_pin(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  gpio_port-&gt;ovrc  = 1 &lt;&lt; (pin &amp; 0x1F); // Value to be driven on the I/O line if the GPIO output driver is enabled: 0.
+  gpio_port-&gt;odert = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is toggled for that pin.
+  gpio_port-&gt;gpers = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO module controls that pin.
+}
+
+
+void gpio_enable_pin_glitch_filter(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;gfers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+void gpio_disable_pin_glitch_filter(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;gferc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Configure the edge detector of an input pin
+ *
+ * \param pin The pin number.
+ * \param mode The edge detection mode (\ref GPIO_PIN_CHANGE, \ref GPIO_RISING_EDGE
+ *             or \ref GPIO_FALLING_EDGE).
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+static int gpio_configure_edge_detector(unsigned int pin, unsigned int mode)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  
+  // Configure the edge detector.
+  switch (mode)
+  {
+  case GPIO_PIN_CHANGE:
+    gpio_port-&gt;imr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;imr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  case GPIO_RISING_EDGE:
+    gpio_port-&gt;imr0s = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;imr1c = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  case GPIO_FALLING_EDGE:
+    gpio_port-&gt;imr0c = 1 &lt;&lt; (pin &amp; 0x1F);
+    gpio_port-&gt;imr1s = 1 &lt;&lt; (pin &amp; 0x1F);
+    break;
+
+  default:
+    return GPIO_INVALID_ARGUMENT;
+  }
+
+  return GPIO_SUCCESS;
+}
+
+
+int gpio_enable_pin_interrupt(unsigned int pin, unsigned int mode)
+{
+  volatile avr32_gpio_port_t  *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  // Enable the glitch filter.
+  gpio_port-&gt;gfers = 1 &lt;&lt; (pin &amp; 0x1F);
+
+  // Configure the edge detector.
+  if(GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode))
+    return(GPIO_INVALID_ARGUMENT);
+
+  // Enable interrupt.
+  gpio_port-&gt;iers = 1 &lt;&lt; (pin &amp; 0x1F);
+
+  return GPIO_SUCCESS;
+}
+
+
+void gpio_disable_pin_interrupt(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;ierc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+int gpio_get_pin_interrupt_flag(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  return (gpio_port-&gt;ifr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+
+void gpio_clear_pin_interrupt_flag(unsigned int pin)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+  gpio_port-&gt;ifrc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+
+//#
+//# Peripheral Event System Support.
+//#
+#if (((defined __GNUC__) &amp;&amp; ((defined __AVR32_UC3L016__) || (defined __AVR32_UC3L032__) || (defined __AVR32_UC3L064__))) \
+    ||((defined __ICCAVR32__) &amp;&amp; ((defined __AT32UC3L016__) || (defined __AT32UC3L032__) || (defined __AT32UC3L064__) )))
+
+int gpio_configure_pin_periph_event_mode(unsigned int pin, unsigned int mode, unsigned int use_igf)
+{
+  volatile avr32_gpio_port_t *gpio_port = &amp;GPIO.port[pin &gt;&gt; 5];
+
+  if(TRUE == use_igf)
+  {
+    // Enable the glitch filter.
+    gpio_port-&gt;gfers = 1 &lt;&lt; (pin &amp; 0x1F);
+  }
+  else
+  {
+    // Disable the glitch filter.
+    gpio_port-&gt;gferc = 1 &lt;&lt; (pin &amp; 0x1F);
+  }
+
+  // Configure the edge detector.
+  return(gpio_configure_edge_detector(pin, mode));
+}
+
+#endif
+
+//! @}

Modified: trunk/src/platform/avr32/gpio.h
===================================================================
--- trunk/src/platform/avr32/gpio.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/gpio.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,381 +1,587 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file has been prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief GPIO header for AVR32 UC3.
- *
- * This file contains basic GPIO driver functions.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a GPIO module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- *****************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _GPIO_H_
-#define _GPIO_H_
-
-#include &lt;avr32/io.h&gt;
-#include &quot;compiler.h&quot;
-
-
-/*! \name Return Values of the GPIO API
- */
-//! @{
-#define GPIO_SUCCESS            0 //!&lt; Function successfully completed.
-#define GPIO_INVALID_ARGUMENT   1 //!&lt; Input parameters are out of range.
-//! @}
-
-
-/*! \name Interrupt Trigger Modes
- */
-//! @{
-#define GPIO_PIN_CHANGE         0 //!&lt; Interrupt triggered upon pin change.
-#define GPIO_RISING_EDGE        1 //!&lt; Interrupt triggered upon rising edge.
-#define GPIO_FALLING_EDGE       2 //!&lt; Interrupt triggered upon falling edge.
-//! @}
-
-
-//! A type definition of pins and modules connectivity.
-typedef struct
-{
-  unsigned char pin;              //!&lt; Module pin.
-  unsigned char function;         //!&lt; Module function.
-} gpio_map_t[];
-
-
-/*! \name Peripheral Bus Interface
- *
- * Low-speed interface with a non-deterministic number of clock cycles per
- * access.
- *
- * This interface operates with lower clock frequencies (fPB &lt;= fCPU), and its
- * timing is not deterministic since it needs to access a shared bus which may
- * be heavily loaded.
- *
- * \note This interface is immediately available without initialization.
- */
-//! @{
-
-/*! \brief Enables specific module modes for a set of pins.
- *
- * \param gpiomap The pin map.
- * \param size The number of pins in \a gpiomap.
- *
- * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
- */
-extern int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size);
-
-/*! \brief Enables a specific module mode for a pin.
- *
- * \param pin The pin number.\n
- *            Refer to the product header file `uc3x.h' (where x is the part
- *            number; e.g. x = a0512) for module pins. E.g., to enable a PWM
- *            channel output, the pin number can be AVR32_PWM_3_PIN for PWM
- *            channel 3.
- * \param function The pin function.\n
- *                 Refer to the product header file `uc3x.h' (where x is the
- *                 part number; e.g. x = a0512) for module pin functions. E.g.,
- *                 to enable a PWM channel output, the pin function can be
- *                 AVR32_PWM_3_FUNCTION for PWM channel 3.
- *
- * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
- */
-extern int gpio_enable_module_pin(unsigned int pin, unsigned int function);
-
-/*! \brief Enables the GPIO mode of a set of pins.
- *
- * \param gpiomap The pin map.
- * \param size The number of pins in \a gpiomap.
- */
-extern void gpio_enable_gpio(const gpio_map_t gpiomap, unsigned int size);
-
-/*! \brief Enables the GPIO mode of a pin.
- *
- * \param pin The pin number.\n
- *            Refer to the product header file `uc3x.h' (where x is the part
- *            number; e.g. x = a0512) for pin definitions. E.g., to enable the
- *            GPIO mode of PX21, AVR32_PIN_PX21 can be used. Module pins such as
- *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
- *            module pins for GPIO.
- */
-extern void gpio_enable_gpio_pin(unsigned int pin);
-
-/*! \brief Enables the open-drain mode of a pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_enable_pin_open_drain(unsigned int pin);
-
-/*! \brief Disables the open-drain mode of a pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_disable_pin_open_drain(unsigned int pin);
-
-/*! \brief Enables the pull-up resistor of a pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_enable_pin_pull_up(unsigned int pin);
-
-/*! \brief Disables the pull-up resistor of a pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_disable_pin_pull_up(unsigned int pin);
-
-/*! \brief Returns the value of a pin.
- *
- * \param pin The pin number.
- *
- * \return The pin value.
- */
-extern int gpio_get_pin_value(unsigned int pin);
-
-/*! \brief Returns the output value set for a GPIO pin.
- *
- * \param pin The pin number.
- *
- * \return The pin output value.
- */
-extern int gpio_get_gpio_pin_output_value(unsigned int pin);
-
-/*! \brief Drives a GPIO pin to 1.
- *
- * \param pin The pin number.
- */
-extern void gpio_set_gpio_pin(unsigned int pin);
-
-/*! \brief Drives a GPIO pin to 0.
- *
- * \param pin The pin number.
- */
-extern void gpio_clr_gpio_pin(unsigned int pin);
-
-/*! \brief Toggles a GPIO pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_tgl_gpio_pin(unsigned int pin);
-
-/*! \brief Enables the glitch filter of a pin.
- *
- * When the glitch filter is enabled, a glitch with duration of less than 1
- * clock cycle is automatically rejected, while a pulse with duration of 2 clock
- * cycles or more is accepted. For pulse durations between 1 clock cycle and 2
- * clock cycles, the pulse may or may not be taken into account, depending on
- * the precise timing of its occurrence. Thus for a pulse to be guaranteed
- * visible it must exceed 2 clock cycles, whereas for a glitch to be reliably
- * filtered out, its duration must not exceed 1 clock cycle. The filter
- * introduces 2 clock cycles latency.
- *
- * \param pin The pin number.
- */
-extern void gpio_enable_pin_glitch_filter(unsigned int pin);
-
-/*! \brief Disables the glitch filter of a pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_disable_pin_glitch_filter(unsigned int pin);
-
-/*! \brief Enables the interrupt of a pin with the specified settings.
- *
- * \param pin The pin number.
- * \param mode The trigger mode (\ref GPIO_PIN_CHANGE, \ref GPIO_RISING_EDGE or
- *             \ref GPIO_FALLING_EDGE).
- *
- * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
- */
-extern int gpio_enable_pin_interrupt(unsigned int pin, unsigned int mode);
-
-/*! \brief Disables the interrupt of a pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_disable_pin_interrupt(unsigned int pin);
-
-/*! \brief Gets the interrupt flag of a pin.
- *
- * \param pin The pin number.
- *
- * \return The pin interrupt flag.
- */
-extern int gpio_get_pin_interrupt_flag(unsigned int pin);
-
-/*! \brief Clears the interrupt flag of a pin.
- *
- * \param pin The pin number.
- */
-extern void gpio_clear_pin_interrupt_flag(unsigned int pin);
-
-//! @}
-
-
-/*! \name Local Bus Interface
- *
- * High-speed interface with only one clock cycle per access.
- *
- * This interface operates with high clock frequency (fCPU), and its timing is
- * deterministic since it does not need to access a shared bus which may be
- * heavily loaded.
- *
- * \note This interface has to be initialized in order to be available.
- */
-//! @{
-
-/*! \brief Enables the local bus interface for GPIO.
- *
- * \note This function must have been called at least once before using other
- *       functions in this interface.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void gpio_local_init(void)
-{
-  Set_system_register(AVR32_CPUCR,
-                      Get_system_register(AVR32_CPUCR) | AVR32_CPUCR_LOCEN_MASK);
-}
-
-/*! \brief Enables the output driver of a pin.
- *
- * \param pin The pin number.
- *
- * \note \ref gpio_local_init must have been called beforehand.
- *
- * \note This function does not enable the GPIO mode of the pin.
- *       \ref gpio_enable_gpio_pin can be called for this purpose.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void gpio_local_enable_pin_output_driver(unsigned int pin)
-{
-  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oders = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-/*! \brief Disables the output driver of a pin.
- *
- * \param pin The pin number.
- *
- * \note \ref gpio_local_init must have been called beforehand.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void gpio_local_disable_pin_output_driver(unsigned int pin)
-{
-  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oderc = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-/*! \brief Returns the value of a pin.
- *
- * \param pin The pin number.
- *
- * \return The pin value.
- *
- * \note \ref gpio_local_init must have been called beforehand.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ int gpio_local_get_pin_value(unsigned int pin)
-{
-  return (AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].pvr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
-}
-
-/*! \brief Drives a GPIO pin to 1.
- *
- * \param pin The pin number.
- *
- * \note \ref gpio_local_init must have been called beforehand.
- *
- * \note This function does not enable the GPIO mode of the pin nor its output
- *       driver. \ref gpio_enable_gpio_pin and
- *       \ref gpio_local_enable_pin_output_driver can be called for this
- *       purpose.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void gpio_local_set_gpio_pin(unsigned int pin)
-{
-  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrs = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-/*! \brief Drives a GPIO pin to 0.
- *
- * \param pin The pin number.
- *
- * \note \ref gpio_local_init must have been called beforehand.
- *
- * \note This function does not enable the GPIO mode of the pin nor its output
- *       driver. \ref gpio_enable_gpio_pin and
- *       \ref gpio_local_enable_pin_output_driver can be called for this
- *       purpose.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void gpio_local_clr_gpio_pin(unsigned int pin)
-{
-  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrc = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-/*! \brief Toggles a GPIO pin.
- *
- * \param pin The pin number.
- *
- * \note \ref gpio_local_init must have been called beforehand.
- *
- * \note This function does not enable the GPIO mode of the pin nor its output
- *       driver. \ref gpio_enable_gpio_pin and
- *       \ref gpio_local_enable_pin_output_driver can be called for this
- *       purpose.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void gpio_local_tgl_gpio_pin(unsigned int pin)
-{
-  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrt = 1 &lt;&lt; (pin &amp; 0x1F);
-}
-
-//! @}
-
-
-#endif  // _GPIO_H_
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief GPIO header for AVR32 UC3.
+ *
+ * This file contains basic GPIO driver functions.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a GPIO module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _GPIO_H_
+#define _GPIO_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+
+
+/*! \name Return Values of the GPIO API
+ */
+//! @{
+#define GPIO_SUCCESS            0 //!&lt; Function successfully completed.
+#define GPIO_INVALID_ARGUMENT   1 //!&lt; Input parameters are out of range.
+//! @}
+
+
+/*! \name Interrupt Trigger Modes
+ */
+//! @{
+#define GPIO_PIN_CHANGE         0 //!&lt; Interrupt triggered upon pin change.
+#define GPIO_RISING_EDGE        1 //!&lt; Interrupt triggered upon rising edge.
+#define GPIO_FALLING_EDGE       2 //!&lt; Interrupt triggered upon falling edge.
+//! @}
+
+
+//! A type definition of pins and modules connectivity.
+typedef struct
+{
+  unsigned char pin;              //!&lt; Module pin.
+  unsigned char function;         //!&lt; Module function.
+} gpio_map_t[];
+
+
+/*! \name Peripheral Bus Interface
+ *
+ * Low-speed interface with a non-deterministic number of clock cycles per
+ * access.
+ *
+ * This interface operates with lower clock frequencies (fPB &lt;= fCPU), and its
+ * timing is not deterministic since it needs to access a shared bus which may
+ * be heavily loaded.
+ *
+ * \note This interface is immediately available without initialization.
+ */
+//! @{
+
+/*! \brief Enables specific module modes for a set of pins.
+ *
+ * \param gpiomap The pin map.
+ * \param size The number of pins in \a gpiomap.
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+extern int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size);
+
+/*! \brief Enables a specific module mode for a pin.
+ *
+ * \param pin The pin number.\n
+ *            Refer to the product header file `uc3x.h' (where x is the part
+ *            number; e.g. x = a0512) for module pins. E.g., to enable a PWM
+ *            channel output, the pin number can be AVR32_PWM_3_PIN for PWM
+ *            channel 3.
+ * \param function The pin function.\n
+ *                 Refer to the product header file `uc3x.h' (where x is the
+ *                 part number; e.g. x = a0512) for module pin functions. E.g.,
+ *                 to enable a PWM channel output, the pin function can be
+ *                 AVR32_PWM_3_FUNCTION for PWM channel 3.
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+extern int gpio_enable_module_pin(unsigned int pin, unsigned int function);
+
+/*! \brief Enables the GPIO mode of a set of pins.
+ *
+ * \param gpiomap The pin map.
+ * \param size The number of pins in \a gpiomap.
+ */
+extern void gpio_enable_gpio(const gpio_map_t gpiomap, unsigned int size);
+
+/*! \brief Enables the GPIO mode of a pin.
+ *
+ * \param pin The pin number.\n
+ *            Refer to the product header file `uc3x.h' (where x is the part
+ *            number; e.g. x = a0512) for pin definitions. E.g., to enable the
+ *            GPIO mode of PX21, AVR32_PIN_PX21 can be used. Module pins such as
+ *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
+ *            module pins for GPIO.
+ */
+extern void gpio_enable_gpio_pin(unsigned int pin);
+
+// The open-drain mode is not synthesized on the current AVR32 products.
+// If one day some AVR32 products have this feature, the corresponding part
+// numbers should be listed in the #if below.
+// Note that other functions are available in this driver to use pins with open
+// drain in GPIO mode. The advantage of the open-drain mode functions over these
+// other functions is that they can be used not only in GPIO mode but also in
+// module mode.
+#if 0
+
+/*! \brief Enables the open-drain mode of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_open_drain(unsigned int pin);
+
+/*! \brief Disables the open-drain mode of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_open_drain(unsigned int pin);
+
+#endif
+
+/*! \brief Enables the pull-up resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_pull_up(unsigned int pin);
+
+/*! \brief Disables the pull-up resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_pull_up(unsigned int pin);
+
+#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_211_H_INCLUDED)
+// Added support of Pull-up Resistor, Pull-down Resistor and Buskeeper Control.
+
+/*! \brief Enables the pull-down resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_pull_down(unsigned int pin);
+
+/*! \brief Disables the pull-down resistor of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_pull_down(unsigned int pin);
+
+/*! \brief Enables the buskeeper functionality on a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_buskeeper(unsigned int pin);
+
+/*! \brief Disables the buskeeper functionality on a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_buskeeper(unsigned int pin);
+
+#endif
+
+/*! \brief Returns the value of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin value.
+ */
+extern int gpio_get_pin_value(unsigned int pin);
+
+/*! \brief Returns the output value set for a GPIO pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin output value.
+ *
+ * \note This function must be used in conjunction with \ref gpio_set_gpio_pin,
+ *       \ref gpio_clr_gpio_pin and \ref gpio_tgl_gpio_pin.
+ */
+extern int gpio_get_gpio_pin_output_value(unsigned int pin);
+
+/*! \brief Returns the output value set for a GPIO pin using open drain.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin output value.
+ *
+ * \note This function must be used in conjunction with
+ *       \ref gpio_set_gpio_open_drain_pin, \ref gpio_clr_gpio_open_drain_pin
+ *       and \ref gpio_tgl_gpio_open_drain_pin.
+ */
+extern int gpio_get_gpio_open_drain_pin_output_value(unsigned int pin);
+
+/*! \brief Drives a GPIO pin to 1.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_set_gpio_pin(unsigned int pin);
+
+/*! \brief Drives a GPIO pin to 0.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_clr_gpio_pin(unsigned int pin);
+
+/*! \brief Toggles a GPIO pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_tgl_gpio_pin(unsigned int pin);
+
+/*! \brief Drives a GPIO pin to 1 using open drain.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_set_gpio_open_drain_pin(unsigned int pin);
+
+/*! \brief Drives a GPIO pin to 0 using open drain.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_clr_gpio_open_drain_pin(unsigned int pin);
+
+/*! \brief Toggles a GPIO pin using open drain.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_tgl_gpio_open_drain_pin(unsigned int pin);
+
+/*! \brief Enables the glitch filter of a pin.
+ *
+ * When the glitch filter is enabled, a glitch with duration of less than 1
+ * clock cycle is automatically rejected, while a pulse with duration of 2 clock
+ * cycles or more is accepted. For pulse durations between 1 clock cycle and 2
+ * clock cycles, the pulse may or may not be taken into account, depending on
+ * the precise timing of its occurrence. Thus for a pulse to be guaranteed
+ * visible it must exceed 2 clock cycles, whereas for a glitch to be reliably
+ * filtered out, its duration must not exceed 1 clock cycle. The filter
+ * introduces 2 clock cycles latency.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_enable_pin_glitch_filter(unsigned int pin);
+
+/*! \brief Disables the glitch filter of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_glitch_filter(unsigned int pin);
+
+/*! \brief Enables the interrupt of a pin with the specified settings.
+ *
+ * \param pin The pin number.
+ * \param mode The trigger mode (\ref GPIO_PIN_CHANGE, \ref GPIO_RISING_EDGE or
+ *             \ref GPIO_FALLING_EDGE).
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+extern int gpio_enable_pin_interrupt(unsigned int pin, unsigned int mode);
+
+/*! \brief Disables the interrupt of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_disable_pin_interrupt(unsigned int pin);
+
+/*! \brief Gets the interrupt flag of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin interrupt flag.
+ */
+extern int gpio_get_pin_interrupt_flag(unsigned int pin);
+
+/*! \brief Clears the interrupt flag of a pin.
+ *
+ * \param pin The pin number.
+ */
+extern void gpio_clear_pin_interrupt_flag(unsigned int pin);
+
+//! @}
+
+
+/*! \name Local Bus Interface
+ *
+ * High-speed interface with only one clock cycle per access.
+ *
+ * This interface operates with high clock frequency (fCPU), and its timing is
+ * deterministic since it does not need to access a shared bus which may be
+ * heavily loaded.
+ *
+ * \warning To use this interface, the clock frequency of the peripheral bus on
+ *          which the GPIO peripheral is connected must be set to the CPU clock
+ *          frequency (fPB = fCPU).
+ *
+ * \note This interface has to be initialized in order to be available.
+ */
+//! @{
+
+/*! \brief Enables the local bus interface for GPIO.
+ *
+ * \note This function must have been called at least once before using other
+ *       functions in this interface.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_init(void)
+{
+  Set_system_register(AVR32_CPUCR,
+                      Get_system_register(AVR32_CPUCR) | AVR32_CPUCR_LOCEN_MASK);
+}
+
+/*! \brief Enables the output driver of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin.
+ *       \ref gpio_enable_gpio_pin can be called for this purpose.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_enable_pin_output_driver(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oders = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Disables the output driver of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_disable_pin_output_driver(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oderc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Returns the value of a pin.
+ *
+ * \param pin The pin number.
+ *
+ * \return The pin value.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int gpio_local_get_pin_value(unsigned int pin)
+{
+  return (AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].pvr &gt;&gt; (pin &amp; 0x1F)) &amp; 1;
+}
+
+/*! \brief Drives a GPIO pin to 1.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin nor its output
+ *       driver. \ref gpio_enable_gpio_pin and
+ *       \ref gpio_local_enable_pin_output_driver can be called for this
+ *       purpose.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_set_gpio_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrs = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Drives a GPIO pin to 0.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin nor its output
+ *       driver. \ref gpio_enable_gpio_pin and
+ *       \ref gpio_local_enable_pin_output_driver can be called for this
+ *       purpose.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_clr_gpio_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Toggles a GPIO pin.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init must have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin nor its output
+ *       driver. \ref gpio_enable_gpio_pin and
+ *       \ref gpio_local_enable_pin_output_driver can be called for this
+ *       purpose.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_tgl_gpio_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrt = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Initializes the configuration of a GPIO pin so that it can be used
+ *         with GPIO open-drain functions.
+ *
+ * \note This function must have been called at least once before using
+ *       \ref gpio_local_set_gpio_open_drain_pin,
+ *       \ref gpio_local_clr_gpio_open_drain_pin or
+ *       \ref gpio_local_tgl_gpio_open_drain_pin.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_init_gpio_open_drain_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].ovrc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Drives a GPIO pin to 1 using open drain.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init and \ref gpio_local_init_gpio_open_drain_pin must
+ *       have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin.
+ *       \ref gpio_enable_gpio_pin can be called for this purpose.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_set_gpio_open_drain_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oderc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Drives a GPIO pin to 0 using open drain.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init and \ref gpio_local_init_gpio_open_drain_pin must
+ *       have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin.
+ *       \ref gpio_enable_gpio_pin can be called for this purpose.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_clr_gpio_open_drain_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].oders = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Toggles a GPIO pin using open drain.
+ *
+ * \param pin The pin number.
+ *
+ * \note \ref gpio_local_init and \ref gpio_local_init_gpio_open_drain_pin must
+ *       have been called beforehand.
+ *
+ * \note This function does not enable the GPIO mode of the pin.
+ *       \ref gpio_enable_gpio_pin can be called for this purpose.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_local_tgl_gpio_open_drain_pin(unsigned int pin)
+{
+  AVR32_GPIO_LOCAL.port[pin &gt;&gt; 5].odert = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+//! @}
+
+#if (((defined __GNUC__) &amp;&amp; ((defined __AVR32_UC3L016__) || \
+                             (defined __AVR32_UC3L032__) || \
+                             (defined __AVR32_UC3L064__)) \
+    ||(defined __ICCAVR32__) &amp;&amp; ((defined __AT32UC3L016__) || \
+                                 (defined __AT32UC3L032__) || \
+                                 (defined __AT32UC3L064__) )))
+//! @{
+/*! \name Peripheral Event System support
+ *
+ * The GPIO can be programmed to output peripheral events whenever an interrupt
+ * condition is detected, such as pin value change, or only when a rising or
+ * falling edge is detected.
+ *
+ */
+
+/*! \brief Enables the peripheral event generation of a pin.
+ *
+ * \param pin The pin number.
+ *
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_enable_pin_periph_event(unsigned int pin)
+{
+  AVR32_GPIO.port[pin &gt;&gt; 5].oderc = 1 &lt;&lt; (pin &amp; 0x1F); // The GPIO output driver is disabled for that pin.
+  AVR32_GPIO.port[pin &gt;&gt; 5].evers = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Disables the peripheral event generation of a pin.
+ *
+ * \param pin The pin number.
+ *
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void gpio_disable_pin_periph_event(unsigned int pin)
+{
+  AVR32_GPIO.port[pin &gt;&gt; 5].everc = 1 &lt;&lt; (pin &amp; 0x1F);
+}
+
+/*! \brief Configure the peripheral event trigger mode of a pin
+ *
+ * \param pin The pin number.
+ * \param mode The trigger mode (\ref GPIO_PIN_CHANGE, \ref GPIO_RISING_EDGE or
+ *             \ref GPIO_FALLING_EDGE).
+ * \param use_igf use the Input Glitch Filter (TRUE) or not (FALSE).
+ *
+ * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
+ */
+extern int gpio_configure_pin_periph_event_mode(unsigned int pin, unsigned int mode, unsigned int use_igf);
+
+//! @}
+#endif
+
+
+#endif  // _GPIO_H_

Modified: trunk/src/platform/avr32/intc.c
===================================================================
--- trunk/src/platform/avr32/intc.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/intc.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,202 +1,214 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief INTC driver for AVR32 UC3.
- *
- * AVR32 Interrupt Controller driver module.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with an INTC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &lt;avr32/io.h&gt;
-#include &quot;compiler.h&quot;
-#include &quot;preprocessor.h&quot;
-#include &quot;intc.h&quot;
-
-
-//! Values to store in the interrupt priority registers for the various interrupt priority levels.
-extern const unsigned int ipr_val[AVR32_INTC_NUM_INT_LEVELS];
-
-//! Creates a table of interrupt line handlers per interrupt group in order to optimize RAM space.
-//! Each line handler table contains a set of pointers to interrupt handlers.
-#if __GNUC__
-#define DECL_INT_LINE_HANDLER_TABLE(GRP, unused) \
-static volatile __int_handler _int_line_handler_table_##GRP[Max(AVR32_INTC_NUM_IRQS_PER_GRP##GRP, 1)];
-#elif __ICCAVR32__
-#define DECL_INT_LINE_HANDLER_TABLE(GRP, unused) \
-static volatile __no_init __int_handler _int_line_handler_table_##GRP[Max(AVR32_INTC_NUM_IRQS_PER_GRP##GRP, 1)];
-#endif
-MREPEAT(AVR32_INTC_NUM_INT_GRPS, DECL_INT_LINE_HANDLER_TABLE, ~);
-#undef DECL_INT_LINE_HANDLER_TABLE
-
-//! Table containing for each interrupt group the number of interrupt request
-//! lines and a pointer to the table of interrupt line handlers.
-static const struct
-{
-  unsigned int num_irqs;
-  volatile __int_handler *_int_line_handler_table;
-} _int_handler_table[AVR32_INTC_NUM_INT_GRPS] =
-{
-#define INSERT_INT_LINE_HANDLER_TABLE(GRP, unused) \
-  {AVR32_INTC_NUM_IRQS_PER_GRP##GRP, _int_line_handler_table_##GRP},
-  MREPEAT(AVR32_INTC_NUM_INT_GRPS, INSERT_INT_LINE_HANDLER_TABLE, ~)
-#undef INSERT_INT_LINE_HANDLER_TABLE
-};
-
-
-/*! \brief Default interrupt handler.
- *
- * \note Taken and adapted from Newlib.
- */
-#if __GNUC__
-__attribute__((__interrupt__))
-#elif __ICCAVR32__
-__interrupt
-#endif
-static void _unhandled_interrupt(void)
-{
-  // Catch unregistered interrupts.
-  while (TRUE);
-}
-
-
-/*! \brief Gets the interrupt handler of the current event at the \a int_lev
- *         interrupt priority level (called from exception.S).
- *
- * \param int_lev Interrupt priority level to handle.
- *
- * \return Interrupt handler to execute.
- *
- * \note Taken and adapted from Newlib.
- */
-__int_handler _get_interrupt_handler(unsigned int int_lev)
-{
-  // ICR3 is mapped first, ICR0 last.
-  // Code in exception.S puts int_lev in R12 which is used by AVR32-GCC to pass
-  // a single argument to a function.
-  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_lev];
-  unsigned int int_req = AVR32_INTC.irr[int_grp];
-
-  // As an interrupt may disappear while it is being fetched by the CPU
-  // (spurious interrupt caused by a delayed response from an MCU peripheral to
-  // an interrupt flag clear or interrupt disable instruction), check if there
-  // are remaining interrupt lines to process.
-  // If a spurious interrupt occurs, the status register (SR) contains an
-  // execution mode and interrupt level masks corresponding to a level 0
-  // interrupt, whatever the interrupt priority level causing the spurious
-  // event. This behavior has been chosen because a spurious interrupt has not
-  // to be a priority one and because it may not cause any trouble to other
-  // interrupts.
-  // However, these spurious interrupts place the hardware in an unstable state
-  // and could give problems in other/future versions of the CPU, so the
-  // software has to be written so that they never occur. The only safe way of
-  // achieving this is to always clear or disable peripheral interrupts with the
-  // following sequence:
-  // 1: Mask the interrupt in the CPU by setting GM (or IxM) in SR.
-  // 2: Perform the bus access to the peripheral register that clears or
-  //    disables the interrupt.
-  // 3: Wait until the interrupt has actually been cleared or disabled by the
-  //    peripheral. This is usually performed by reading from a register in the
-  //    same peripheral (it DOES NOT have to be the same register that was
-  //    accessed in step 2, but it MUST be in the same peripheral), what takes
-  //    bus system latencies into account, but peripheral internal latencies
-  //    (generally 0 cycle) also have to be considered.
-  // 4: Unmask the interrupt in the CPU by clearing GM (or IxM) in SR.
-  // Note that steps 1 and 4 are useless inside interrupt handlers as the
-  // corresponding interrupt level is automatically masked by IxM (unless IxM is
-  // explicitly cleared by the software).
-  //
-  // Get the right IRQ handler.
-  //
-  // If several interrupt lines are active in the group, the interrupt line with
-  // the highest number is selected. This is to be coherent with the
-  // prioritization of interrupt groups performed by the hardware interrupt
-  // controller.
-  //
-  // If no handler has been registered for the pending interrupt,
-  // _unhandled_interrupt will be selected thanks to the initialization of
-  // _int_line_handler_table_x by INTC_init_interrupts.
-  //
-  // exception.S will provide the interrupt handler with a clean interrupt stack
-  // frame, with nothing more pushed onto the stack. The interrupt handler must
-  // manage the `rete' instruction, what can be done thanks to pure assembly,
-  // inline assembly or the `__attribute__((__interrupt__))' C function
-  // attribute.
-  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
-}
-
-
-void INTC_init_interrupts(void)
-{
-  unsigned int int_grp, int_req;
-
-  // For all interrupt groups,
-  for (int_grp = 0; int_grp &lt; AVR32_INTC_NUM_INT_GRPS; int_grp++)
-  {
-    // For all interrupt request lines of each group,
-    for (int_req = 0; int_req &lt; _int_handler_table[int_grp].num_irqs; int_req++)
-    {
-      // Assign _unhandled_interrupt as default interrupt handler.
-      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &amp;_unhandled_interrupt;
-    }
-
-    // Set the interrupt group priority register to its default value.
-    // By default, all interrupt groups are linked to the interrupt priority
-    // level 0 and to the interrupt vector _int0.
-    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
-  }
-}
-
-
-void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_lev)
-{
-  // Determine the group of the IRQ.
-  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
-
-  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
-  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
-  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
-
-  // Program the corresponding IPRX register to set the interrupt priority level
-  // and the interrupt vector offset that will be fetched by the core interrupt
-  // system.
-  // NOTE: The _intx functions are intermediate assembly functions between the
-  // core interrupt system and the user interrupt handler.
-  AVR32_INTC.ipr[int_grp] = ipr_val[int_lev &amp; (AVR32_INTC_IPR_INTLEV_MASK &gt;&gt; AVR32_INTC_IPR_INTLEV_OFFSET)];
-}
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief INTC driver for AVR32 UC3.
+ *
+ * AVR32 Interrupt Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an INTC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;preprocessor.h&quot;
+#include &quot;intc.h&quot;
+
+// define _evba from exception.S
+extern void _evba;
+
+//! Values to store in the interrupt priority registers for the various interrupt priority levels.
+extern const unsigned int ipr_val[AVR32_INTC_NUM_INT_LEVELS];
+
+//! Creates a table of interrupt line handlers per interrupt group in order to optimize RAM space.
+//! Each line handler table contains a set of pointers to interrupt handlers.
+#if (defined __GNUC__)
+#define DECL_INT_LINE_HANDLER_TABLE(GRP, unused) \
+static volatile __int_handler _int_line_handler_table_##GRP[Max(AVR32_INTC_NUM_IRQS_PER_GRP##GRP, 1)];
+#elif (defined __ICCAVR32__)
+#define DECL_INT_LINE_HANDLER_TABLE(GRP, unused) \
+static volatile __no_init __int_handler _int_line_handler_table_##GRP[Max(AVR32_INTC_NUM_IRQS_PER_GRP##GRP, 1)];
+#endif
+MREPEAT(AVR32_INTC_NUM_INT_GRPS, DECL_INT_LINE_HANDLER_TABLE, ~);
+#undef DECL_INT_LINE_HANDLER_TABLE
+
+//! Table containing for each interrupt group the number of interrupt request
+//! lines and a pointer to the table of interrupt line handlers.
+static const struct
+{
+  unsigned int num_irqs;
+  volatile __int_handler *_int_line_handler_table;
+} _int_handler_table[AVR32_INTC_NUM_INT_GRPS] =
+{
+#define INSERT_INT_LINE_HANDLER_TABLE(GRP, unused) \
+  {AVR32_INTC_NUM_IRQS_PER_GRP##GRP, _int_line_handler_table_##GRP},
+  MREPEAT(AVR32_INTC_NUM_INT_GRPS, INSERT_INT_LINE_HANDLER_TABLE, ~)
+#undef INSERT_INT_LINE_HANDLER_TABLE
+};
+
+
+/*! \brief Default interrupt handler.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+#if (defined __GNUC__)
+__attribute__((__interrupt__))
+#elif (defined __ICCAVR32__)
+__interrupt
+#endif
+static void _unhandled_interrupt(void)
+{
+  // Catch unregistered interrupts.
+  while (TRUE);
+}
+
+
+/*! \brief Gets the interrupt handler of the current event at the \a int_level
+ *         interrupt priority level (called from exception.S).
+ *
+ * \param int_level Interrupt priority level to handle.
+ *
+ * \return Interrupt handler to execute.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+__int_handler _get_interrupt_handler(unsigned int int_level)
+{
+  // ICR3 is mapped first, ICR0 last.
+  // Code in exception.S puts int_level in R12 which is used by AVR32-GCC to
+  // pass a single argument to a function.
+  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
+  unsigned int int_req = AVR32_INTC.irr[int_grp];
+
+  // As an interrupt may disappear while it is being fetched by the CPU
+  // (spurious interrupt caused by a delayed response from an MCU peripheral to
+  // an interrupt flag clear or interrupt disable instruction), check if there
+  // are remaining interrupt lines to process.
+  // If a spurious interrupt occurs, the status register (SR) contains an
+  // execution mode and interrupt level masks corresponding to a level 0
+  // interrupt, whatever the interrupt priority level causing the spurious
+  // event. This behavior has been chosen because a spurious interrupt has not
+  // to be a priority one and because it may not cause any trouble to other
+  // interrupts.
+  // However, these spurious interrupts place the hardware in an unstable state
+  // and could give problems in other/future versions of the CPU, so the
+  // software has to be written so that they never occur. The only safe way of
+  // achieving this is to always clear or disable peripheral interrupts with the
+  // following sequence:
+  // 1: Mask the interrupt in the CPU by setting GM (or IxM) in SR.
+  // 2: Perform the bus access to the peripheral register that clears or
+  //    disables the interrupt.
+  // 3: Wait until the interrupt has actually been cleared or disabled by the
+  //    peripheral. This is usually performed by reading from a register in the
+  //    same peripheral (it DOES NOT have to be the same register that was
+  //    accessed in step 2, but it MUST be in the same peripheral), what takes
+  //    bus system latencies into account, but peripheral internal latencies
+  //    (generally 0 cycle) also have to be considered.
+  // 4: Unmask the interrupt in the CPU by clearing GM (or IxM) in SR.
+  // Note that steps 1 and 4 are useless inside interrupt handlers as the
+  // corresponding interrupt level is automatically masked by IxM (unless IxM is
+  // explicitly cleared by the software).
+  //
+  // Get the right IRQ handler.
+  //
+  // If several interrupt lines are active in the group, the interrupt line with
+  // the highest number is selected. This is to be coherent with the
+  // prioritization of interrupt groups performed by the hardware interrupt
+  // controller.
+  //
+  // If no handler has been registered for the pending interrupt,
+  // _unhandled_interrupt will be selected thanks to the initialization of
+  // _int_line_handler_table_x by INTC_init_interrupts.
+  //
+  // exception.S will provide the interrupt handler with a clean interrupt stack
+  // frame, with nothing more pushed onto the stack. The interrupt handler must
+  // manage the `rete' instruction, what can be done thanks to pure assembly,
+  // inline assembly or the `__attribute__((__interrupt__))' C function
+  // attribute.
+  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
+}
+
+//! Init EVBA address. This sequence might also be done in the UTILS/STARTUP/GCC/crt0.S
+static __inline__ void INTC_init_evba(void)
+{
+  Set_system_register(AVR32_EVBA, (int)&amp;_evba );
+}
+
+void INTC_init_interrupts(void)
+{
+  unsigned int int_grp, int_req;
+
+  INTC_init_evba();
+
+  // For all interrupt groups,
+  for (int_grp = 0; int_grp &lt; AVR32_INTC_NUM_INT_GRPS; int_grp++)
+  {
+    // For all interrupt request lines of each group,
+    for (int_req = 0; int_req &lt; _int_handler_table[int_grp].num_irqs; int_req++)
+    {
+      // Assign _unhandled_interrupt as default interrupt handler.
+      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &amp;_unhandled_interrupt;
+    }
+
+    // Set the interrupt group priority register to its default value.
+    // By default, all interrupt groups are linked to the interrupt priority
+    // level 0 and to the interrupt vector _int0.
+    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
+  }
+}
+
+
+void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_level)
+{
+  // Determine the group of the IRQ.
+  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
+
+  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
+  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
+  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
+
+  // Program the corresponding IPRX register to set the interrupt priority level
+  // and the interrupt vector offset that will be fetched by the core interrupt
+  // system.
+  // NOTE: The _intx functions are intermediate assembly functions between the
+  // core interrupt system and the user interrupt handler.
+  AVR32_INTC.ipr[int_grp] = ipr_val[int_level &amp; (AVR32_INTC_IPR_INTLEVEL_MASK &gt;&gt; AVR32_INTC_IPR_INTLEVEL_OFFSET)];
+}

Modified: trunk/src/platform/avr32/intc.h
===================================================================
--- trunk/src/platform/avr32/intc.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/intc.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,97 +1,100 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief INTC driver for AVR32 UC3.
- *
- * AVR32 Interrupt Controller driver module.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with an INTC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _INTC_H_
-#define _INTC_H_
-
-#include &quot;compiler.h&quot;
-
-
-//! Maximal number of interrupt request lines per group.
-#define AVR32_INTC_MAX_NUM_IRQS_PER_GRP             32
-
-//! Number of interrupt priority levels.
-#define AVR32_INTC_NUM_INT_LEVELS                   (1 &lt;&lt; AVR32_INTC_IPR_INTLEV_SIZE)
-
-
-#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
-
-//! Pointer to interrupt handler.
-#if __GNUC__
-typedef void (*__int_handler)(void);
-#elif __ICCAVR32__
-typedef void (__interrupt *__int_handler)(void);
-#endif
-
-
-/*! \brief Initializes the hardware interrupt controller driver.
- *
- * \note Taken and adapted from Newlib.
- */
-extern void INTC_init_interrupts(void);
-
-/*! \brief Registers an interrupt handler.
- *
- * \param handler Interrupt handler to register.
- * \param irq     IRQ of the interrupt handler to register.
- * \param int_lev Interrupt priority level to assign to the group of this IRQ.
- *
- * \warning The interrupt handler must manage the `rete' instruction, what can
- *          be done thanks to pure assembly, inline assembly or the
- *          `__attribute__((__interrupt__))' C function attribute.
- *
- * \warning If several interrupt handlers of a same group are registered with
- *          different priority levels, only the latest priority level set will
- *          be effective.
- *
- * \note Taken and adapted from Newlib.
- */
-extern void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_lev);
-
-#endif  // __AVR32_ABI_COMPILER__
-
-
-#endif  // _INTC_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief INTC driver for AVR32 UC3.
+ *
+ * AVR32 Interrupt Controller driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an INTC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _INTC_H_
+#define _INTC_H_
+
+#include &quot;compiler.h&quot;
+
+
+//! Maximal number of interrupt request lines per group.
+#define AVR32_INTC_MAX_NUM_IRQS_PER_GRP             32
+
+//! Number of interrupt priority levels.
+#define AVR32_INTC_NUM_INT_LEVELS                   (1 &lt;&lt; AVR32_INTC_IPR_INTLEVEL_SIZE)
+
+
+#ifdef __AVR32_ABI_COMPILER__ // Automatically defined when compiling for AVR32, not when assembling.
+
+//! Pointer to interrupt handler.
+#if (defined __GNUC__)
+typedef void (*__int_handler)(void);
+#elif (defined __ICCAVR32__)
+typedef void (__interrupt *__int_handler)(void);
+#endif
+
+
+/*! \brief Initializes the hardware interrupt controller driver.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+extern void INTC_init_interrupts(void);
+
+/*! \brief Registers an interrupt handler.
+ *
+ * \param handler   Interrupt handler to register.
+ * \param irq       IRQ of the interrupt handler to register.
+ * \param int_level Interrupt priority level to assign to the group of this IRQ.
+ *
+ * \warning The interrupt handler must manage the `rete' instruction, what can
+ *          be done thanks to pure assembly, inline assembly or the
+ *          `__attribute__((__interrupt__))' C function attribute.
+ *
+ * \warning If several interrupt handlers of a same group are registered with
+ *          different priority levels, only the latest priority level set will
+ *          be effective.
+ *
+ * \note Taken and adapted from Newlib.
+ */
+extern void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_level);
+
+#endif  // __AVR32_ABI_COMPILER__
+
+
+#endif  // _INTC_H_

Modified: trunk/src/platform/avr32/mrepeat.h
===================================================================
--- trunk/src/platform/avr32/mrepeat.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/mrepeat.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,325 +1,328 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Preprocessor macro repeating utils.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices can be used.
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _MREPEAT_H_
-#define _MREPEAT_H_
-
-#include &quot;preprocessor.h&quot;
-
-
-//! Maximal number of repetitions supported by MREPEAT.
-#define MREPEAT_LIMIT   256
-
-/*! \brief Macro repeat.
- *
- * This macro represents a horizontal repetition construct.
- *
- * \param count  The number of repetitious calls to macro. Valid values range from 0 to MREPEAT_LIMIT.
- * \param macro  A binary operation of the form macro(n, data). This macro is expanded by MREPEAT with
- *               the current repetition number and the auxiliary data argument.
- * \param data   Auxiliary data passed to macro.
- *
- * \return       &lt;tt&gt;macro(0, data) macro(1, data) ... macro(count - 1, data)&lt;/tt&gt;
- */
-#define MREPEAT(count, macro, data)         TPASTE2(MREPEAT, count)(macro, data)
-
-#define MREPEAT0(  macro, data)
-#define MREPEAT1(  macro, data)       MREPEAT0(  macro, data)   macro(  0, data)
-#define MREPEAT2(  macro, data)       MREPEAT1(  macro, data)   macro(  1, data)
-#define MREPEAT3(  macro, data)       MREPEAT2(  macro, data)   macro(  2, data)
-#define MREPEAT4(  macro, data)       MREPEAT3(  macro, data)   macro(  3, data)
-#define MREPEAT5(  macro, data)       MREPEAT4(  macro, data)   macro(  4, data)
-#define MREPEAT6(  macro, data)       MREPEAT5(  macro, data)   macro(  5, data)
-#define MREPEAT7(  macro, data)       MREPEAT6(  macro, data)   macro(  6, data)
-#define MREPEAT8(  macro, data)       MREPEAT7(  macro, data)   macro(  7, data)
-#define MREPEAT9(  macro, data)       MREPEAT8(  macro, data)   macro(  8, data)
-#define MREPEAT10( macro, data)       MREPEAT9(  macro, data)   macro(  9, data)
-#define MREPEAT11( macro, data)       MREPEAT10( macro, data)   macro( 10, data)
-#define MREPEAT12( macro, data)       MREPEAT11( macro, data)   macro( 11, data)
-#define MREPEAT13( macro, data)       MREPEAT12( macro, data)   macro( 12, data)
-#define MREPEAT14( macro, data)       MREPEAT13( macro, data)   macro( 13, data)
-#define MREPEAT15( macro, data)       MREPEAT14( macro, data)   macro( 14, data)
-#define MREPEAT16( macro, data)       MREPEAT15( macro, data)   macro( 15, data)
-#define MREPEAT17( macro, data)       MREPEAT16( macro, data)   macro( 16, data)
-#define MREPEAT18( macro, data)       MREPEAT17( macro, data)   macro( 17, data)
-#define MREPEAT19( macro, data)       MREPEAT18( macro, data)   macro( 18, data)
-#define MREPEAT20( macro, data)       MREPEAT19( macro, data)   macro( 19, data)
-#define MREPEAT21( macro, data)       MREPEAT20( macro, data)   macro( 20, data)
-#define MREPEAT22( macro, data)       MREPEAT21( macro, data)   macro( 21, data)
-#define MREPEAT23( macro, data)       MREPEAT22( macro, data)   macro( 22, data)
-#define MREPEAT24( macro, data)       MREPEAT23( macro, data)   macro( 23, data)
-#define MREPEAT25( macro, data)       MREPEAT24( macro, data)   macro( 24, data)
-#define MREPEAT26( macro, data)       MREPEAT25( macro, data)   macro( 25, data)
-#define MREPEAT27( macro, data)       MREPEAT26( macro, data)   macro( 26, data)
-#define MREPEAT28( macro, data)       MREPEAT27( macro, data)   macro( 27, data)
-#define MREPEAT29( macro, data)       MREPEAT28( macro, data)   macro( 28, data)
-#define MREPEAT30( macro, data)       MREPEAT29( macro, data)   macro( 29, data)
-#define MREPEAT31( macro, data)       MREPEAT30( macro, data)   macro( 30, data)
-#define MREPEAT32( macro, data)       MREPEAT31( macro, data)   macro( 31, data)
-#define MREPEAT33( macro, data)       MREPEAT32( macro, data)   macro( 32, data)
-#define MREPEAT34( macro, data)       MREPEAT33( macro, data)   macro( 33, data)
-#define MREPEAT35( macro, data)       MREPEAT34( macro, data)   macro( 34, data)
-#define MREPEAT36( macro, data)       MREPEAT35( macro, data)   macro( 35, data)
-#define MREPEAT37( macro, data)       MREPEAT36( macro, data)   macro( 36, data)
-#define MREPEAT38( macro, data)       MREPEAT37( macro, data)   macro( 37, data)
-#define MREPEAT39( macro, data)       MREPEAT38( macro, data)   macro( 38, data)
-#define MREPEAT40( macro, data)       MREPEAT39( macro, data)   macro( 39, data)
-#define MREPEAT41( macro, data)       MREPEAT40( macro, data)   macro( 40, data)
-#define MREPEAT42( macro, data)       MREPEAT41( macro, data)   macro( 41, data)
-#define MREPEAT43( macro, data)       MREPEAT42( macro, data)   macro( 42, data)
-#define MREPEAT44( macro, data)       MREPEAT43( macro, data)   macro( 43, data)
-#define MREPEAT45( macro, data)       MREPEAT44( macro, data)   macro( 44, data)
-#define MREPEAT46( macro, data)       MREPEAT45( macro, data)   macro( 45, data)
-#define MREPEAT47( macro, data)       MREPEAT46( macro, data)   macro( 46, data)
-#define MREPEAT48( macro, data)       MREPEAT47( macro, data)   macro( 47, data)
-#define MREPEAT49( macro, data)       MREPEAT48( macro, data)   macro( 48, data)
-#define MREPEAT50( macro, data)       MREPEAT49( macro, data)   macro( 49, data)
-#define MREPEAT51( macro, data)       MREPEAT50( macro, data)   macro( 50, data)
-#define MREPEAT52( macro, data)       MREPEAT51( macro, data)   macro( 51, data)
-#define MREPEAT53( macro, data)       MREPEAT52( macro, data)   macro( 52, data)
-#define MREPEAT54( macro, data)       MREPEAT53( macro, data)   macro( 53, data)
-#define MREPEAT55( macro, data)       MREPEAT54( macro, data)   macro( 54, data)
-#define MREPEAT56( macro, data)       MREPEAT55( macro, data)   macro( 55, data)
-#define MREPEAT57( macro, data)       MREPEAT56( macro, data)   macro( 56, data)
-#define MREPEAT58( macro, data)       MREPEAT57( macro, data)   macro( 57, data)
-#define MREPEAT59( macro, data)       MREPEAT58( macro, data)   macro( 58, data)
-#define MREPEAT60( macro, data)       MREPEAT59( macro, data)   macro( 59, data)
-#define MREPEAT61( macro, data)       MREPEAT60( macro, data)   macro( 60, data)
-#define MREPEAT62( macro, data)       MREPEAT61( macro, data)   macro( 61, data)
-#define MREPEAT63( macro, data)       MREPEAT62( macro, data)   macro( 62, data)
-#define MREPEAT64( macro, data)       MREPEAT63( macro, data)   macro( 63, data)
-#define MREPEAT65( macro, data)       MREPEAT64( macro, data)   macro( 64, data)
-#define MREPEAT66( macro, data)       MREPEAT65( macro, data)   macro( 65, data)
-#define MREPEAT67( macro, data)       MREPEAT66( macro, data)   macro( 66, data)
-#define MREPEAT68( macro, data)       MREPEAT67( macro, data)   macro( 67, data)
-#define MREPEAT69( macro, data)       MREPEAT68( macro, data)   macro( 68, data)
-#define MREPEAT70( macro, data)       MREPEAT69( macro, data)   macro( 69, data)
-#define MREPEAT71( macro, data)       MREPEAT70( macro, data)   macro( 70, data)
-#define MREPEAT72( macro, data)       MREPEAT71( macro, data)   macro( 71, data)
-#define MREPEAT73( macro, data)       MREPEAT72( macro, data)   macro( 72, data)
-#define MREPEAT74( macro, data)       MREPEAT73( macro, data)   macro( 73, data)
-#define MREPEAT75( macro, data)       MREPEAT74( macro, data)   macro( 74, data)
-#define MREPEAT76( macro, data)       MREPEAT75( macro, data)   macro( 75, data)
-#define MREPEAT77( macro, data)       MREPEAT76( macro, data)   macro( 76, data)
-#define MREPEAT78( macro, data)       MREPEAT77( macro, data)   macro( 77, data)
-#define MREPEAT79( macro, data)       MREPEAT78( macro, data)   macro( 78, data)
-#define MREPEAT80( macro, data)       MREPEAT79( macro, data)   macro( 79, data)
-#define MREPEAT81( macro, data)       MREPEAT80( macro, data)   macro( 80, data)
-#define MREPEAT82( macro, data)       MREPEAT81( macro, data)   macro( 81, data)
-#define MREPEAT83( macro, data)       MREPEAT82( macro, data)   macro( 82, data)
-#define MREPEAT84( macro, data)       MREPEAT83( macro, data)   macro( 83, data)
-#define MREPEAT85( macro, data)       MREPEAT84( macro, data)   macro( 84, data)
-#define MREPEAT86( macro, data)       MREPEAT85( macro, data)   macro( 85, data)
-#define MREPEAT87( macro, data)       MREPEAT86( macro, data)   macro( 86, data)
-#define MREPEAT88( macro, data)       MREPEAT87( macro, data)   macro( 87, data)
-#define MREPEAT89( macro, data)       MREPEAT88( macro, data)   macro( 88, data)
-#define MREPEAT90( macro, data)       MREPEAT89( macro, data)   macro( 89, data)
-#define MREPEAT91( macro, data)       MREPEAT90( macro, data)   macro( 90, data)
-#define MREPEAT92( macro, data)       MREPEAT91( macro, data)   macro( 91, data)
-#define MREPEAT93( macro, data)       MREPEAT92( macro, data)   macro( 92, data)
-#define MREPEAT94( macro, data)       MREPEAT93( macro, data)   macro( 93, data)
-#define MREPEAT95( macro, data)       MREPEAT94( macro, data)   macro( 94, data)
-#define MREPEAT96( macro, data)       MREPEAT95( macro, data)   macro( 95, data)
-#define MREPEAT97( macro, data)       MREPEAT96( macro, data)   macro( 96, data)
-#define MREPEAT98( macro, data)       MREPEAT97( macro, data)   macro( 97, data)
-#define MREPEAT99( macro, data)       MREPEAT98( macro, data)   macro( 98, data)
-#define MREPEAT100(macro, data)       MREPEAT99( macro, data)   macro( 99, data)
-#define MREPEAT101(macro, data)       MREPEAT100(macro, data)   macro(100, data)
-#define MREPEAT102(macro, data)       MREPEAT101(macro, data)   macro(101, data)
-#define MREPEAT103(macro, data)       MREPEAT102(macro, data)   macro(102, data)
-#define MREPEAT104(macro, data)       MREPEAT103(macro, data)   macro(103, data)
-#define MREPEAT105(macro, data)       MREPEAT104(macro, data)   macro(104, data)
-#define MREPEAT106(macro, data)       MREPEAT105(macro, data)   macro(105, data)
-#define MREPEAT107(macro, data)       MREPEAT106(macro, data)   macro(106, data)
-#define MREPEAT108(macro, data)       MREPEAT107(macro, data)   macro(107, data)
-#define MREPEAT109(macro, data)       MREPEAT108(macro, data)   macro(108, data)
-#define MREPEAT110(macro, data)       MREPEAT109(macro, data)   macro(109, data)
-#define MREPEAT111(macro, data)       MREPEAT110(macro, data)   macro(110, data)
-#define MREPEAT112(macro, data)       MREPEAT111(macro, data)   macro(111, data)
-#define MREPEAT113(macro, data)       MREPEAT112(macro, data)   macro(112, data)
-#define MREPEAT114(macro, data)       MREPEAT113(macro, data)   macro(113, data)
-#define MREPEAT115(macro, data)       MREPEAT114(macro, data)   macro(114, data)
-#define MREPEAT116(macro, data)       MREPEAT115(macro, data)   macro(115, data)
-#define MREPEAT117(macro, data)       MREPEAT116(macro, data)   macro(116, data)
-#define MREPEAT118(macro, data)       MREPEAT117(macro, data)   macro(117, data)
-#define MREPEAT119(macro, data)       MREPEAT118(macro, data)   macro(118, data)
-#define MREPEAT120(macro, data)       MREPEAT119(macro, data)   macro(119, data)
-#define MREPEAT121(macro, data)       MREPEAT120(macro, data)   macro(120, data)
-#define MREPEAT122(macro, data)       MREPEAT121(macro, data)   macro(121, data)
-#define MREPEAT123(macro, data)       MREPEAT122(macro, data)   macro(122, data)
-#define MREPEAT124(macro, data)       MREPEAT123(macro, data)   macro(123, data)
-#define MREPEAT125(macro, data)       MREPEAT124(macro, data)   macro(124, data)
-#define MREPEAT126(macro, data)       MREPEAT125(macro, data)   macro(125, data)
-#define MREPEAT127(macro, data)       MREPEAT126(macro, data)   macro(126, data)
-#define MREPEAT128(macro, data)       MREPEAT127(macro, data)   macro(127, data)
-#define MREPEAT129(macro, data)       MREPEAT128(macro, data)   macro(128, data)
-#define MREPEAT130(macro, data)       MREPEAT129(macro, data)   macro(129, data)
-#define MREPEAT131(macro, data)       MREPEAT130(macro, data)   macro(130, data)
-#define MREPEAT132(macro, data)       MREPEAT131(macro, data)   macro(131, data)
-#define MREPEAT133(macro, data)       MREPEAT132(macro, data)   macro(132, data)
-#define MREPEAT134(macro, data)       MREPEAT133(macro, data)   macro(133, data)
-#define MREPEAT135(macro, data)       MREPEAT134(macro, data)   macro(134, data)
-#define MREPEAT136(macro, data)       MREPEAT135(macro, data)   macro(135, data)
-#define MREPEAT137(macro, data)       MREPEAT136(macro, data)   macro(136, data)
-#define MREPEAT138(macro, data)       MREPEAT137(macro, data)   macro(137, data)
-#define MREPEAT139(macro, data)       MREPEAT138(macro, data)   macro(138, data)
-#define MREPEAT140(macro, data)       MREPEAT139(macro, data)   macro(139, data)
-#define MREPEAT141(macro, data)       MREPEAT140(macro, data)   macro(140, data)
-#define MREPEAT142(macro, data)       MREPEAT141(macro, data)   macro(141, data)
-#define MREPEAT143(macro, data)       MREPEAT142(macro, data)   macro(142, data)
-#define MREPEAT144(macro, data)       MREPEAT143(macro, data)   macro(143, data)
-#define MREPEAT145(macro, data)       MREPEAT144(macro, data)   macro(144, data)
-#define MREPEAT146(macro, data)       MREPEAT145(macro, data)   macro(145, data)
-#define MREPEAT147(macro, data)       MREPEAT146(macro, data)   macro(146, data)
-#define MREPEAT148(macro, data)       MREPEAT147(macro, data)   macro(147, data)
-#define MREPEAT149(macro, data)       MREPEAT148(macro, data)   macro(148, data)
-#define MREPEAT150(macro, data)       MREPEAT149(macro, data)   macro(149, data)
-#define MREPEAT151(macro, data)       MREPEAT150(macro, data)   macro(150, data)
-#define MREPEAT152(macro, data)       MREPEAT151(macro, data)   macro(151, data)
-#define MREPEAT153(macro, data)       MREPEAT152(macro, data)   macro(152, data)
-#define MREPEAT154(macro, data)       MREPEAT153(macro, data)   macro(153, data)
-#define MREPEAT155(macro, data)       MREPEAT154(macro, data)   macro(154, data)
-#define MREPEAT156(macro, data)       MREPEAT155(macro, data)   macro(155, data)
-#define MREPEAT157(macro, data)       MREPEAT156(macro, data)   macro(156, data)
-#define MREPEAT158(macro, data)       MREPEAT157(macro, data)   macro(157, data)
-#define MREPEAT159(macro, data)       MREPEAT158(macro, data)   macro(158, data)
-#define MREPEAT160(macro, data)       MREPEAT159(macro, data)   macro(159, data)
-#define MREPEAT161(macro, data)       MREPEAT160(macro, data)   macro(160, data)
-#define MREPEAT162(macro, data)       MREPEAT161(macro, data)   macro(161, data)
-#define MREPEAT163(macro, data)       MREPEAT162(macro, data)   macro(162, data)
-#define MREPEAT164(macro, data)       MREPEAT163(macro, data)   macro(163, data)
-#define MREPEAT165(macro, data)       MREPEAT164(macro, data)   macro(164, data)
-#define MREPEAT166(macro, data)       MREPEAT165(macro, data)   macro(165, data)
-#define MREPEAT167(macro, data)       MREPEAT166(macro, data)   macro(166, data)
-#define MREPEAT168(macro, data)       MREPEAT167(macro, data)   macro(167, data)
-#define MREPEAT169(macro, data)       MREPEAT168(macro, data)   macro(168, data)
-#define MREPEAT170(macro, data)       MREPEAT169(macro, data)   macro(169, data)
-#define MREPEAT171(macro, data)       MREPEAT170(macro, data)   macro(170, data)
-#define MREPEAT172(macro, data)       MREPEAT171(macro, data)   macro(171, data)
-#define MREPEAT173(macro, data)       MREPEAT172(macro, data)   macro(172, data)
-#define MREPEAT174(macro, data)       MREPEAT173(macro, data)   macro(173, data)
-#define MREPEAT175(macro, data)       MREPEAT174(macro, data)   macro(174, data)
-#define MREPEAT176(macro, data)       MREPEAT175(macro, data)   macro(175, data)
-#define MREPEAT177(macro, data)       MREPEAT176(macro, data)   macro(176, data)
-#define MREPEAT178(macro, data)       MREPEAT177(macro, data)   macro(177, data)
-#define MREPEAT179(macro, data)       MREPEAT178(macro, data)   macro(178, data)
-#define MREPEAT180(macro, data)       MREPEAT179(macro, data)   macro(179, data)
-#define MREPEAT181(macro, data)       MREPEAT180(macro, data)   macro(180, data)
-#define MREPEAT182(macro, data)       MREPEAT181(macro, data)   macro(181, data)
-#define MREPEAT183(macro, data)       MREPEAT182(macro, data)   macro(182, data)
-#define MREPEAT184(macro, data)       MREPEAT183(macro, data)   macro(183, data)
-#define MREPEAT185(macro, data)       MREPEAT184(macro, data)   macro(184, data)
-#define MREPEAT186(macro, data)       MREPEAT185(macro, data)   macro(185, data)
-#define MREPEAT187(macro, data)       MREPEAT186(macro, data)   macro(186, data)
-#define MREPEAT188(macro, data)       MREPEAT187(macro, data)   macro(187, data)
-#define MREPEAT189(macro, data)       MREPEAT188(macro, data)   macro(188, data)
-#define MREPEAT190(macro, data)       MREPEAT189(macro, data)   macro(189, data)
-#define MREPEAT191(macro, data)       MREPEAT190(macro, data)   macro(190, data)
-#define MREPEAT192(macro, data)       MREPEAT191(macro, data)   macro(191, data)
-#define MREPEAT193(macro, data)       MREPEAT192(macro, data)   macro(192, data)
-#define MREPEAT194(macro, data)       MREPEAT193(macro, data)   macro(193, data)
-#define MREPEAT195(macro, data)       MREPEAT194(macro, data)   macro(194, data)
-#define MREPEAT196(macro, data)       MREPEAT195(macro, data)   macro(195, data)
-#define MREPEAT197(macro, data)       MREPEAT196(macro, data)   macro(196, data)
-#define MREPEAT198(macro, data)       MREPEAT197(macro, data)   macro(197, data)
-#define MREPEAT199(macro, data)       MREPEAT198(macro, data)   macro(198, data)
-#define MREPEAT200(macro, data)       MREPEAT199(macro, data)   macro(199, data)
-#define MREPEAT201(macro, data)       MREPEAT200(macro, data)   macro(200, data)
-#define MREPEAT202(macro, data)       MREPEAT201(macro, data)   macro(201, data)
-#define MREPEAT203(macro, data)       MREPEAT202(macro, data)   macro(202, data)
-#define MREPEAT204(macro, data)       MREPEAT203(macro, data)   macro(203, data)
-#define MREPEAT205(macro, data)       MREPEAT204(macro, data)   macro(204, data)
-#define MREPEAT206(macro, data)       MREPEAT205(macro, data)   macro(205, data)
-#define MREPEAT207(macro, data)       MREPEAT206(macro, data)   macro(206, data)
-#define MREPEAT208(macro, data)       MREPEAT207(macro, data)   macro(207, data)
-#define MREPEAT209(macro, data)       MREPEAT208(macro, data)   macro(208, data)
-#define MREPEAT210(macro, data)       MREPEAT209(macro, data)   macro(209, data)
-#define MREPEAT211(macro, data)       MREPEAT210(macro, data)   macro(210, data)
-#define MREPEAT212(macro, data)       MREPEAT211(macro, data)   macro(211, data)
-#define MREPEAT213(macro, data)       MREPEAT212(macro, data)   macro(212, data)
-#define MREPEAT214(macro, data)       MREPEAT213(macro, data)   macro(213, data)
-#define MREPEAT215(macro, data)       MREPEAT214(macro, data)   macro(214, data)
-#define MREPEAT216(macro, data)       MREPEAT215(macro, data)   macro(215, data)
-#define MREPEAT217(macro, data)       MREPEAT216(macro, data)   macro(216, data)
-#define MREPEAT218(macro, data)       MREPEAT217(macro, data)   macro(217, data)
-#define MREPEAT219(macro, data)       MREPEAT218(macro, data)   macro(218, data)
-#define MREPEAT220(macro, data)       MREPEAT219(macro, data)   macro(219, data)
-#define MREPEAT221(macro, data)       MREPEAT220(macro, data)   macro(220, data)
-#define MREPEAT222(macro, data)       MREPEAT221(macro, data)   macro(221, data)
-#define MREPEAT223(macro, data)       MREPEAT222(macro, data)   macro(222, data)
-#define MREPEAT224(macro, data)       MREPEAT223(macro, data)   macro(223, data)
-#define MREPEAT225(macro, data)       MREPEAT224(macro, data)   macro(224, data)
-#define MREPEAT226(macro, data)       MREPEAT225(macro, data)   macro(225, data)
-#define MREPEAT227(macro, data)       MREPEAT226(macro, data)   macro(226, data)
-#define MREPEAT228(macro, data)       MREPEAT227(macro, data)   macro(227, data)
-#define MREPEAT229(macro, data)       MREPEAT228(macro, data)   macro(228, data)
-#define MREPEAT230(macro, data)       MREPEAT229(macro, data)   macro(229, data)
-#define MREPEAT231(macro, data)       MREPEAT230(macro, data)   macro(230, data)
-#define MREPEAT232(macro, data)       MREPEAT231(macro, data)   macro(231, data)
-#define MREPEAT233(macro, data)       MREPEAT232(macro, data)   macro(232, data)
-#define MREPEAT234(macro, data)       MREPEAT233(macro, data)   macro(233, data)
-#define MREPEAT235(macro, data)       MREPEAT234(macro, data)   macro(234, data)
-#define MREPEAT236(macro, data)       MREPEAT235(macro, data)   macro(235, data)
-#define MREPEAT237(macro, data)       MREPEAT236(macro, data)   macro(236, data)
-#define MREPEAT238(macro, data)       MREPEAT237(macro, data)   macro(237, data)
-#define MREPEAT239(macro, data)       MREPEAT238(macro, data)   macro(238, data)
-#define MREPEAT240(macro, data)       MREPEAT239(macro, data)   macro(239, data)
-#define MREPEAT241(macro, data)       MREPEAT240(macro, data)   macro(240, data)
-#define MREPEAT242(macro, data)       MREPEAT241(macro, data)   macro(241, data)
-#define MREPEAT243(macro, data)       MREPEAT242(macro, data)   macro(242, data)
-#define MREPEAT244(macro, data)       MREPEAT243(macro, data)   macro(243, data)
-#define MREPEAT245(macro, data)       MREPEAT244(macro, data)   macro(244, data)
-#define MREPEAT246(macro, data)       MREPEAT245(macro, data)   macro(245, data)
-#define MREPEAT247(macro, data)       MREPEAT246(macro, data)   macro(246, data)
-#define MREPEAT248(macro, data)       MREPEAT247(macro, data)   macro(247, data)
-#define MREPEAT249(macro, data)       MREPEAT248(macro, data)   macro(248, data)
-#define MREPEAT250(macro, data)       MREPEAT249(macro, data)   macro(249, data)
-#define MREPEAT251(macro, data)       MREPEAT250(macro, data)   macro(250, data)
-#define MREPEAT252(macro, data)       MREPEAT251(macro, data)   macro(251, data)
-#define MREPEAT253(macro, data)       MREPEAT252(macro, data)   macro(252, data)
-#define MREPEAT254(macro, data)       MREPEAT253(macro, data)   macro(253, data)
-#define MREPEAT255(macro, data)       MREPEAT254(macro, data)   macro(254, data)
-#define MREPEAT256(macro, data)       MREPEAT255(macro, data)   macro(255, data)
-
-
-#endif  // _MREPEAT_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor macro repeating utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _MREPEAT_H_
+#define _MREPEAT_H_
+
+#include &quot;preprocessor.h&quot;
+
+
+//! Maximal number of repetitions supported by MREPEAT.
+#define MREPEAT_LIMIT   256
+
+/*! \brief Macro repeat.
+ *
+ * This macro represents a horizontal repetition construct.
+ *
+ * \param count  The number of repetitious calls to macro. Valid values range from 0 to MREPEAT_LIMIT.
+ * \param macro  A binary operation of the form macro(n, data). This macro is expanded by MREPEAT with
+ *               the current repetition number and the auxiliary data argument.
+ * \param data   Auxiliary data passed to macro.
+ *
+ * \return       &lt;tt&gt;macro(0, data) macro(1, data) ... macro(count - 1, data)&lt;/tt&gt;
+ */
+#define MREPEAT(count, macro, data)         TPASTE2(MREPEAT, count)(macro, data)
+
+#define MREPEAT0(  macro, data)
+#define MREPEAT1(  macro, data)       MREPEAT0(  macro, data)   macro(  0, data)
+#define MREPEAT2(  macro, data)       MREPEAT1(  macro, data)   macro(  1, data)
+#define MREPEAT3(  macro, data)       MREPEAT2(  macro, data)   macro(  2, data)
+#define MREPEAT4(  macro, data)       MREPEAT3(  macro, data)   macro(  3, data)
+#define MREPEAT5(  macro, data)       MREPEAT4(  macro, data)   macro(  4, data)
+#define MREPEAT6(  macro, data)       MREPEAT5(  macro, data)   macro(  5, data)
+#define MREPEAT7(  macro, data)       MREPEAT6(  macro, data)   macro(  6, data)
+#define MREPEAT8(  macro, data)       MREPEAT7(  macro, data)   macro(  7, data)
+#define MREPEAT9(  macro, data)       MREPEAT8(  macro, data)   macro(  8, data)
+#define MREPEAT10( macro, data)       MREPEAT9(  macro, data)   macro(  9, data)
+#define MREPEAT11( macro, data)       MREPEAT10( macro, data)   macro( 10, data)
+#define MREPEAT12( macro, data)       MREPEAT11( macro, data)   macro( 11, data)
+#define MREPEAT13( macro, data)       MREPEAT12( macro, data)   macro( 12, data)
+#define MREPEAT14( macro, data)       MREPEAT13( macro, data)   macro( 13, data)
+#define MREPEAT15( macro, data)       MREPEAT14( macro, data)   macro( 14, data)
+#define MREPEAT16( macro, data)       MREPEAT15( macro, data)   macro( 15, data)
+#define MREPEAT17( macro, data)       MREPEAT16( macro, data)   macro( 16, data)
+#define MREPEAT18( macro, data)       MREPEAT17( macro, data)   macro( 17, data)
+#define MREPEAT19( macro, data)       MREPEAT18( macro, data)   macro( 18, data)
+#define MREPEAT20( macro, data)       MREPEAT19( macro, data)   macro( 19, data)
+#define MREPEAT21( macro, data)       MREPEAT20( macro, data)   macro( 20, data)
+#define MREPEAT22( macro, data)       MREPEAT21( macro, data)   macro( 21, data)
+#define MREPEAT23( macro, data)       MREPEAT22( macro, data)   macro( 22, data)
+#define MREPEAT24( macro, data)       MREPEAT23( macro, data)   macro( 23, data)
+#define MREPEAT25( macro, data)       MREPEAT24( macro, data)   macro( 24, data)
+#define MREPEAT26( macro, data)       MREPEAT25( macro, data)   macro( 25, data)
+#define MREPEAT27( macro, data)       MREPEAT26( macro, data)   macro( 26, data)
+#define MREPEAT28( macro, data)       MREPEAT27( macro, data)   macro( 27, data)
+#define MREPEAT29( macro, data)       MREPEAT28( macro, data)   macro( 28, data)
+#define MREPEAT30( macro, data)       MREPEAT29( macro, data)   macro( 29, data)
+#define MREPEAT31( macro, data)       MREPEAT30( macro, data)   macro( 30, data)
+#define MREPEAT32( macro, data)       MREPEAT31( macro, data)   macro( 31, data)
+#define MREPEAT33( macro, data)       MREPEAT32( macro, data)   macro( 32, data)
+#define MREPEAT34( macro, data)       MREPEAT33( macro, data)   macro( 33, data)
+#define MREPEAT35( macro, data)       MREPEAT34( macro, data)   macro( 34, data)
+#define MREPEAT36( macro, data)       MREPEAT35( macro, data)   macro( 35, data)
+#define MREPEAT37( macro, data)       MREPEAT36( macro, data)   macro( 36, data)
+#define MREPEAT38( macro, data)       MREPEAT37( macro, data)   macro( 37, data)
+#define MREPEAT39( macro, data)       MREPEAT38( macro, data)   macro( 38, data)
+#define MREPEAT40( macro, data)       MREPEAT39( macro, data)   macro( 39, data)
+#define MREPEAT41( macro, data)       MREPEAT40( macro, data)   macro( 40, data)
+#define MREPEAT42( macro, data)       MREPEAT41( macro, data)   macro( 41, data)
+#define MREPEAT43( macro, data)       MREPEAT42( macro, data)   macro( 42, data)
+#define MREPEAT44( macro, data)       MREPEAT43( macro, data)   macro( 43, data)
+#define MREPEAT45( macro, data)       MREPEAT44( macro, data)   macro( 44, data)
+#define MREPEAT46( macro, data)       MREPEAT45( macro, data)   macro( 45, data)
+#define MREPEAT47( macro, data)       MREPEAT46( macro, data)   macro( 46, data)
+#define MREPEAT48( macro, data)       MREPEAT47( macro, data)   macro( 47, data)
+#define MREPEAT49( macro, data)       MREPEAT48( macro, data)   macro( 48, data)
+#define MREPEAT50( macro, data)       MREPEAT49( macro, data)   macro( 49, data)
+#define MREPEAT51( macro, data)       MREPEAT50( macro, data)   macro( 50, data)
+#define MREPEAT52( macro, data)       MREPEAT51( macro, data)   macro( 51, data)
+#define MREPEAT53( macro, data)       MREPEAT52( macro, data)   macro( 52, data)
+#define MREPEAT54( macro, data)       MREPEAT53( macro, data)   macro( 53, data)
+#define MREPEAT55( macro, data)       MREPEAT54( macro, data)   macro( 54, data)
+#define MREPEAT56( macro, data)       MREPEAT55( macro, data)   macro( 55, data)
+#define MREPEAT57( macro, data)       MREPEAT56( macro, data)   macro( 56, data)
+#define MREPEAT58( macro, data)       MREPEAT57( macro, data)   macro( 57, data)
+#define MREPEAT59( macro, data)       MREPEAT58( macro, data)   macro( 58, data)
+#define MREPEAT60( macro, data)       MREPEAT59( macro, data)   macro( 59, data)
+#define MREPEAT61( macro, data)       MREPEAT60( macro, data)   macro( 60, data)
+#define MREPEAT62( macro, data)       MREPEAT61( macro, data)   macro( 61, data)
+#define MREPEAT63( macro, data)       MREPEAT62( macro, data)   macro( 62, data)
+#define MREPEAT64( macro, data)       MREPEAT63( macro, data)   macro( 63, data)
+#define MREPEAT65( macro, data)       MREPEAT64( macro, data)   macro( 64, data)
+#define MREPEAT66( macro, data)       MREPEAT65( macro, data)   macro( 65, data)
+#define MREPEAT67( macro, data)       MREPEAT66( macro, data)   macro( 66, data)
+#define MREPEAT68( macro, data)       MREPEAT67( macro, data)   macro( 67, data)
+#define MREPEAT69( macro, data)       MREPEAT68( macro, data)   macro( 68, data)
+#define MREPEAT70( macro, data)       MREPEAT69( macro, data)   macro( 69, data)
+#define MREPEAT71( macro, data)       MREPEAT70( macro, data)   macro( 70, data)
+#define MREPEAT72( macro, data)       MREPEAT71( macro, data)   macro( 71, data)
+#define MREPEAT73( macro, data)       MREPEAT72( macro, data)   macro( 72, data)
+#define MREPEAT74( macro, data)       MREPEAT73( macro, data)   macro( 73, data)
+#define MREPEAT75( macro, data)       MREPEAT74( macro, data)   macro( 74, data)
+#define MREPEAT76( macro, data)       MREPEAT75( macro, data)   macro( 75, data)
+#define MREPEAT77( macro, data)       MREPEAT76( macro, data)   macro( 76, data)
+#define MREPEAT78( macro, data)       MREPEAT77( macro, data)   macro( 77, data)
+#define MREPEAT79( macro, data)       MREPEAT78( macro, data)   macro( 78, data)
+#define MREPEAT80( macro, data)       MREPEAT79( macro, data)   macro( 79, data)
+#define MREPEAT81( macro, data)       MREPEAT80( macro, data)   macro( 80, data)
+#define MREPEAT82( macro, data)       MREPEAT81( macro, data)   macro( 81, data)
+#define MREPEAT83( macro, data)       MREPEAT82( macro, data)   macro( 82, data)
+#define MREPEAT84( macro, data)       MREPEAT83( macro, data)   macro( 83, data)
+#define MREPEAT85( macro, data)       MREPEAT84( macro, data)   macro( 84, data)
+#define MREPEAT86( macro, data)       MREPEAT85( macro, data)   macro( 85, data)
+#define MREPEAT87( macro, data)       MREPEAT86( macro, data)   macro( 86, data)
+#define MREPEAT88( macro, data)       MREPEAT87( macro, data)   macro( 87, data)
+#define MREPEAT89( macro, data)       MREPEAT88( macro, data)   macro( 88, data)
+#define MREPEAT90( macro, data)       MREPEAT89( macro, data)   macro( 89, data)
+#define MREPEAT91( macro, data)       MREPEAT90( macro, data)   macro( 90, data)
+#define MREPEAT92( macro, data)       MREPEAT91( macro, data)   macro( 91, data)
+#define MREPEAT93( macro, data)       MREPEAT92( macro, data)   macro( 92, data)
+#define MREPEAT94( macro, data)       MREPEAT93( macro, data)   macro( 93, data)
+#define MREPEAT95( macro, data)       MREPEAT94( macro, data)   macro( 94, data)
+#define MREPEAT96( macro, data)       MREPEAT95( macro, data)   macro( 95, data)
+#define MREPEAT97( macro, data)       MREPEAT96( macro, data)   macro( 96, data)
+#define MREPEAT98( macro, data)       MREPEAT97( macro, data)   macro( 97, data)
+#define MREPEAT99( macro, data)       MREPEAT98( macro, data)   macro( 98, data)
+#define MREPEAT100(macro, data)       MREPEAT99( macro, data)   macro( 99, data)
+#define MREPEAT101(macro, data)       MREPEAT100(macro, data)   macro(100, data)
+#define MREPEAT102(macro, data)       MREPEAT101(macro, data)   macro(101, data)
+#define MREPEAT103(macro, data)       MREPEAT102(macro, data)   macro(102, data)
+#define MREPEAT104(macro, data)       MREPEAT103(macro, data)   macro(103, data)
+#define MREPEAT105(macro, data)       MREPEAT104(macro, data)   macro(104, data)
+#define MREPEAT106(macro, data)       MREPEAT105(macro, data)   macro(105, data)
+#define MREPEAT107(macro, data)       MREPEAT106(macro, data)   macro(106, data)
+#define MREPEAT108(macro, data)       MREPEAT107(macro, data)   macro(107, data)
+#define MREPEAT109(macro, data)       MREPEAT108(macro, data)   macro(108, data)
+#define MREPEAT110(macro, data)       MREPEAT109(macro, data)   macro(109, data)
+#define MREPEAT111(macro, data)       MREPEAT110(macro, data)   macro(110, data)
+#define MREPEAT112(macro, data)       MREPEAT111(macro, data)   macro(111, data)
+#define MREPEAT113(macro, data)       MREPEAT112(macro, data)   macro(112, data)
+#define MREPEAT114(macro, data)       MREPEAT113(macro, data)   macro(113, data)
+#define MREPEAT115(macro, data)       MREPEAT114(macro, data)   macro(114, data)
+#define MREPEAT116(macro, data)       MREPEAT115(macro, data)   macro(115, data)
+#define MREPEAT117(macro, data)       MREPEAT116(macro, data)   macro(116, data)
+#define MREPEAT118(macro, data)       MREPEAT117(macro, data)   macro(117, data)
+#define MREPEAT119(macro, data)       MREPEAT118(macro, data)   macro(118, data)
+#define MREPEAT120(macro, data)       MREPEAT119(macro, data)   macro(119, data)
+#define MREPEAT121(macro, data)       MREPEAT120(macro, data)   macro(120, data)
+#define MREPEAT122(macro, data)       MREPEAT121(macro, data)   macro(121, data)
+#define MREPEAT123(macro, data)       MREPEAT122(macro, data)   macro(122, data)
+#define MREPEAT124(macro, data)       MREPEAT123(macro, data)   macro(123, data)
+#define MREPEAT125(macro, data)       MREPEAT124(macro, data)   macro(124, data)
+#define MREPEAT126(macro, data)       MREPEAT125(macro, data)   macro(125, data)
+#define MREPEAT127(macro, data)       MREPEAT126(macro, data)   macro(126, data)
+#define MREPEAT128(macro, data)       MREPEAT127(macro, data)   macro(127, data)
+#define MREPEAT129(macro, data)       MREPEAT128(macro, data)   macro(128, data)
+#define MREPEAT130(macro, data)       MREPEAT129(macro, data)   macro(129, data)
+#define MREPEAT131(macro, data)       MREPEAT130(macro, data)   macro(130, data)
+#define MREPEAT132(macro, data)       MREPEAT131(macro, data)   macro(131, data)
+#define MREPEAT133(macro, data)       MREPEAT132(macro, data)   macro(132, data)
+#define MREPEAT134(macro, data)       MREPEAT133(macro, data)   macro(133, data)
+#define MREPEAT135(macro, data)       MREPEAT134(macro, data)   macro(134, data)
+#define MREPEAT136(macro, data)       MREPEAT135(macro, data)   macro(135, data)
+#define MREPEAT137(macro, data)       MREPEAT136(macro, data)   macro(136, data)
+#define MREPEAT138(macro, data)       MREPEAT137(macro, data)   macro(137, data)
+#define MREPEAT139(macro, data)       MREPEAT138(macro, data)   macro(138, data)
+#define MREPEAT140(macro, data)       MREPEAT139(macro, data)   macro(139, data)
+#define MREPEAT141(macro, data)       MREPEAT140(macro, data)   macro(140, data)
+#define MREPEAT142(macro, data)       MREPEAT141(macro, data)   macro(141, data)
+#define MREPEAT143(macro, data)       MREPEAT142(macro, data)   macro(142, data)
+#define MREPEAT144(macro, data)       MREPEAT143(macro, data)   macro(143, data)
+#define MREPEAT145(macro, data)       MREPEAT144(macro, data)   macro(144, data)
+#define MREPEAT146(macro, data)       MREPEAT145(macro, data)   macro(145, data)
+#define MREPEAT147(macro, data)       MREPEAT146(macro, data)   macro(146, data)
+#define MREPEAT148(macro, data)       MREPEAT147(macro, data)   macro(147, data)
+#define MREPEAT149(macro, data)       MREPEAT148(macro, data)   macro(148, data)
+#define MREPEAT150(macro, data)       MREPEAT149(macro, data)   macro(149, data)
+#define MREPEAT151(macro, data)       MREPEAT150(macro, data)   macro(150, data)
+#define MREPEAT152(macro, data)       MREPEAT151(macro, data)   macro(151, data)
+#define MREPEAT153(macro, data)       MREPEAT152(macro, data)   macro(152, data)
+#define MREPEAT154(macro, data)       MREPEAT153(macro, data)   macro(153, data)
+#define MREPEAT155(macro, data)       MREPEAT154(macro, data)   macro(154, data)
+#define MREPEAT156(macro, data)       MREPEAT155(macro, data)   macro(155, data)
+#define MREPEAT157(macro, data)       MREPEAT156(macro, data)   macro(156, data)
+#define MREPEAT158(macro, data)       MREPEAT157(macro, data)   macro(157, data)
+#define MREPEAT159(macro, data)       MREPEAT158(macro, data)   macro(158, data)
+#define MREPEAT160(macro, data)       MREPEAT159(macro, data)   macro(159, data)
+#define MREPEAT161(macro, data)       MREPEAT160(macro, data)   macro(160, data)
+#define MREPEAT162(macro, data)       MREPEAT161(macro, data)   macro(161, data)
+#define MREPEAT163(macro, data)       MREPEAT162(macro, data)   macro(162, data)
+#define MREPEAT164(macro, data)       MREPEAT163(macro, data)   macro(163, data)
+#define MREPEAT165(macro, data)       MREPEAT164(macro, data)   macro(164, data)
+#define MREPEAT166(macro, data)       MREPEAT165(macro, data)   macro(165, data)
+#define MREPEAT167(macro, data)       MREPEAT166(macro, data)   macro(166, data)
+#define MREPEAT168(macro, data)       MREPEAT167(macro, data)   macro(167, data)
+#define MREPEAT169(macro, data)       MREPEAT168(macro, data)   macro(168, data)
+#define MREPEAT170(macro, data)       MREPEAT169(macro, data)   macro(169, data)
+#define MREPEAT171(macro, data)       MREPEAT170(macro, data)   macro(170, data)
+#define MREPEAT172(macro, data)       MREPEAT171(macro, data)   macro(171, data)
+#define MREPEAT173(macro, data)       MREPEAT172(macro, data)   macro(172, data)
+#define MREPEAT174(macro, data)       MREPEAT173(macro, data)   macro(173, data)
+#define MREPEAT175(macro, data)       MREPEAT174(macro, data)   macro(174, data)
+#define MREPEAT176(macro, data)       MREPEAT175(macro, data)   macro(175, data)
+#define MREPEAT177(macro, data)       MREPEAT176(macro, data)   macro(176, data)
+#define MREPEAT178(macro, data)       MREPEAT177(macro, data)   macro(177, data)
+#define MREPEAT179(macro, data)       MREPEAT178(macro, data)   macro(178, data)
+#define MREPEAT180(macro, data)       MREPEAT179(macro, data)   macro(179, data)
+#define MREPEAT181(macro, data)       MREPEAT180(macro, data)   macro(180, data)
+#define MREPEAT182(macro, data)       MREPEAT181(macro, data)   macro(181, data)
+#define MREPEAT183(macro, data)       MREPEAT182(macro, data)   macro(182, data)
+#define MREPEAT184(macro, data)       MREPEAT183(macro, data)   macro(183, data)
+#define MREPEAT185(macro, data)       MREPEAT184(macro, data)   macro(184, data)
+#define MREPEAT186(macro, data)       MREPEAT185(macro, data)   macro(185, data)
+#define MREPEAT187(macro, data)       MREPEAT186(macro, data)   macro(186, data)
+#define MREPEAT188(macro, data)       MREPEAT187(macro, data)   macro(187, data)
+#define MREPEAT189(macro, data)       MREPEAT188(macro, data)   macro(188, data)
+#define MREPEAT190(macro, data)       MREPEAT189(macro, data)   macro(189, data)
+#define MREPEAT191(macro, data)       MREPEAT190(macro, data)   macro(190, data)
+#define MREPEAT192(macro, data)       MREPEAT191(macro, data)   macro(191, data)
+#define MREPEAT193(macro, data)       MREPEAT192(macro, data)   macro(192, data)
+#define MREPEAT194(macro, data)       MREPEAT193(macro, data)   macro(193, data)
+#define MREPEAT195(macro, data)       MREPEAT194(macro, data)   macro(194, data)
+#define MREPEAT196(macro, data)       MREPEAT195(macro, data)   macro(195, data)
+#define MREPEAT197(macro, data)       MREPEAT196(macro, data)   macro(196, data)
+#define MREPEAT198(macro, data)       MREPEAT197(macro, data)   macro(197, data)
+#define MREPEAT199(macro, data)       MREPEAT198(macro, data)   macro(198, data)
+#define MREPEAT200(macro, data)       MREPEAT199(macro, data)   macro(199, data)
+#define MREPEAT201(macro, data)       MREPEAT200(macro, data)   macro(200, data)
+#define MREPEAT202(macro, data)       MREPEAT201(macro, data)   macro(201, data)
+#define MREPEAT203(macro, data)       MREPEAT202(macro, data)   macro(202, data)
+#define MREPEAT204(macro, data)       MREPEAT203(macro, data)   macro(203, data)
+#define MREPEAT205(macro, data)       MREPEAT204(macro, data)   macro(204, data)
+#define MREPEAT206(macro, data)       MREPEAT205(macro, data)   macro(205, data)
+#define MREPEAT207(macro, data)       MREPEAT206(macro, data)   macro(206, data)
+#define MREPEAT208(macro, data)       MREPEAT207(macro, data)   macro(207, data)
+#define MREPEAT209(macro, data)       MREPEAT208(macro, data)   macro(208, data)
+#define MREPEAT210(macro, data)       MREPEAT209(macro, data)   macro(209, data)
+#define MREPEAT211(macro, data)       MREPEAT210(macro, data)   macro(210, data)
+#define MREPEAT212(macro, data)       MREPEAT211(macro, data)   macro(211, data)
+#define MREPEAT213(macro, data)       MREPEAT212(macro, data)   macro(212, data)
+#define MREPEAT214(macro, data)       MREPEAT213(macro, data)   macro(213, data)
+#define MREPEAT215(macro, data)       MREPEAT214(macro, data)   macro(214, data)
+#define MREPEAT216(macro, data)       MREPEAT215(macro, data)   macro(215, data)
+#define MREPEAT217(macro, data)       MREPEAT216(macro, data)   macro(216, data)
+#define MREPEAT218(macro, data)       MREPEAT217(macro, data)   macro(217, data)
+#define MREPEAT219(macro, data)       MREPEAT218(macro, data)   macro(218, data)
+#define MREPEAT220(macro, data)       MREPEAT219(macro, data)   macro(219, data)
+#define MREPEAT221(macro, data)       MREPEAT220(macro, data)   macro(220, data)
+#define MREPEAT222(macro, data)       MREPEAT221(macro, data)   macro(221, data)
+#define MREPEAT223(macro, data)       MREPEAT222(macro, data)   macro(222, data)
+#define MREPEAT224(macro, data)       MREPEAT223(macro, data)   macro(223, data)
+#define MREPEAT225(macro, data)       MREPEAT224(macro, data)   macro(224, data)
+#define MREPEAT226(macro, data)       MREPEAT225(macro, data)   macro(225, data)
+#define MREPEAT227(macro, data)       MREPEAT226(macro, data)   macro(226, data)
+#define MREPEAT228(macro, data)       MREPEAT227(macro, data)   macro(227, data)
+#define MREPEAT229(macro, data)       MREPEAT228(macro, data)   macro(228, data)
+#define MREPEAT230(macro, data)       MREPEAT229(macro, data)   macro(229, data)
+#define MREPEAT231(macro, data)       MREPEAT230(macro, data)   macro(230, data)
+#define MREPEAT232(macro, data)       MREPEAT231(macro, data)   macro(231, data)
+#define MREPEAT233(macro, data)       MREPEAT232(macro, data)   macro(232, data)
+#define MREPEAT234(macro, data)       MREPEAT233(macro, data)   macro(233, data)
+#define MREPEAT235(macro, data)       MREPEAT234(macro, data)   macro(234, data)
+#define MREPEAT236(macro, data)       MREPEAT235(macro, data)   macro(235, data)
+#define MREPEAT237(macro, data)       MREPEAT236(macro, data)   macro(236, data)
+#define MREPEAT238(macro, data)       MREPEAT237(macro, data)   macro(237, data)
+#define MREPEAT239(macro, data)       MREPEAT238(macro, data)   macro(238, data)
+#define MREPEAT240(macro, data)       MREPEAT239(macro, data)   macro(239, data)
+#define MREPEAT241(macro, data)       MREPEAT240(macro, data)   macro(240, data)
+#define MREPEAT242(macro, data)       MREPEAT241(macro, data)   macro(241, data)
+#define MREPEAT243(macro, data)       MREPEAT242(macro, data)   macro(242, data)
+#define MREPEAT244(macro, data)       MREPEAT243(macro, data)   macro(243, data)
+#define MREPEAT245(macro, data)       MREPEAT244(macro, data)   macro(244, data)
+#define MREPEAT246(macro, data)       MREPEAT245(macro, data)   macro(245, data)
+#define MREPEAT247(macro, data)       MREPEAT246(macro, data)   macro(246, data)
+#define MREPEAT248(macro, data)       MREPEAT247(macro, data)   macro(247, data)
+#define MREPEAT249(macro, data)       MREPEAT248(macro, data)   macro(248, data)
+#define MREPEAT250(macro, data)       MREPEAT249(macro, data)   macro(249, data)
+#define MREPEAT251(macro, data)       MREPEAT250(macro, data)   macro(250, data)
+#define MREPEAT252(macro, data)       MREPEAT251(macro, data)   macro(251, data)
+#define MREPEAT253(macro, data)       MREPEAT252(macro, data)   macro(252, data)
+#define MREPEAT254(macro, data)       MREPEAT253(macro, data)   macro(253, data)
+#define MREPEAT255(macro, data)       MREPEAT254(macro, data)   macro(254, data)
+#define MREPEAT256(macro, data)       MREPEAT255(macro, data)   macro(255, data)
+
+
+#endif  // _MREPEAT_H_

Deleted: trunk/src/platform/avr32/mt48lc16m16a2tg7e.h
===================================================================
--- trunk/src/platform/avr32/mt48lc16m16a2tg7e.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/mt48lc16m16a2tg7e.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,117 +0,0 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
-
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief MT48LC16M16A2TG-7E SDRAM driver for AVR32 UC3 SDRAMC on EBI.
- *
- * \note The values defined in this file are device-specific. See the device
- *       datasheet for further information.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _MT48LC16M16A2TG7E_H_
-#define _MT48LC16M16A2TG7E_H_
-
-
-//! The number of bank bits for this SDRAM (1 or 2).
-#define SDRAM_BANK_BITS                 2
-
-//! The number of row bits for this SDRAM (11 to 13).
-#define SDRAM_ROW_BITS                  13
-
-//! The number of column bits for this SDRAM (8 to 11).
-#define SDRAM_COL_BITS                  9
-
-//! The minimal column address select (READ) latency for this SDRAM (1 to 3 SDRAM cycles).
-//! Unit: tCK (SDRAM cycle period).
-#define SDRAM_CAS                       2
-
-//! The minimal write recovery time for this SDRAM (0 to 15 SDRAM cycles).
-//! Unit: ns.
-#define SDRAM_TWR                       14
-
-//! The minimal row cycle time for this SDRAM (0 to 15 SDRAM cycles).
-//! ACTIVE-to-ACTIVE command delay.
-//! Unit: ns.
-#define SDRAM_TRC                       60
-
-//! The minimal row precharge time for this SDRAM (0 to 15 SDRAM cycles).
-//! PRECHARGE command period.
-//! Unit: ns.
-#define SDRAM_TRP                       15
-
-//! The minimal row to column delay time for this SDRAM (0 to 15 SDRAM cycles).
-//! ACTIVE-to-READ/WRITE command delay.
-//! Unit: ns.
-#define SDRAM_TRCD                      15
-
-//! The minimal row address select time for this SDRAM (0 to 15 SDRAM cycles).
-//! ACTIVE-to-PRECHARGE command delay.
-//! Unit: ns.
-#define SDRAM_TRAS                      37
-
-//! The minimal exit self refresh time for this SDRAM (0 to 15 SDRAM cycles).
-//! Exit SELF REFRESH to ACTIVE command delay.
-//! Unit: ns.
-#define SDRAM_TXSR                      67
-
-//! The maximal refresh time for this SDRAM (0 to 4095 SDRAM cycles).
-//! Refresh period.
-//! Unit: ns.
-#define SDRAM_TR                        7812
-
-//! The minimal refresh cycle time for this SDRAM.
-//! AUTO REFRESH command period.
-//! Unit: ns.
-#define SDRAM_TRFC                      66
-
-//! The minimal mode register delay time for this SDRAM.
-//! LOAD MODE REGISTER command to ACTIVE or REFRESH command delay.
-//! Unit: tCK (SDRAM cycle period).
-#define SDRAM_TMRD                      2
-
-//! The minimal stable-clock initialization delay for this SDRAM.
-//! Unit: us.
-#define SDRAM_STABLE_CLOCK_INIT_DELAY   100
-
-//! The minimal number of AUTO REFRESH commands required during initialization for this SDRAM.
-#define SDRAM_INIT_AUTO_REFRESH_COUNT   2
-
-
-#endif  // _MT48LC16M16A2TG7E_H_

Modified: trunk/src/platform/avr32/pm.c
===================================================================
--- trunk/src/platform/avr32/pm.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/pm.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,516 +1,546 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file has been prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Power Manager driver.
- *
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- *****************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &quot;compiler.h&quot;
-#include &quot;pm.h&quot;
-
-
-/*! \name PM Writable Bit-Field Registers
- */
-//! @{
-
-typedef union
-{
-  unsigned long                 mcctrl;
-  avr32_pm_mcctrl_t             MCCTRL;
-} u_avr32_pm_mcctrl_t;
-
-typedef union
-{
-  unsigned long                 cksel;
-  avr32_pm_cksel_t              CKSEL;
-} u_avr32_pm_cksel_t;
-
-typedef union
-{
-  unsigned long                 pll;
-  avr32_pm_pll_t                PLL;
-} u_avr32_pm_pll_t;
-
-typedef union
-{
-  unsigned long                 oscctrl0;
-  avr32_pm_oscctrl0_t           OSCCTRL0;
-} u_avr32_pm_oscctrl0_t;
-
-typedef union
-{
-  unsigned long                 oscctrl1;
-  avr32_pm_oscctrl1_t           OSCCTRL1;
-} u_avr32_pm_oscctrl1_t;
-
-typedef union
-{
-  unsigned long                 oscctrl32;
-  avr32_pm_oscctrl32_t          OSCCTRL32;
-} u_avr32_pm_oscctrl32_t;
-
-typedef union
-{
-  unsigned long                 ier;
-  avr32_pm_ier_t                IER;
-} u_avr32_pm_ier_t;
-
-typedef union
-{
-  unsigned long                 idr;
-  avr32_pm_idr_t                IDR;
-} u_avr32_pm_idr_t;
-
-typedef union
-{
-  unsigned long                 icr;
-  avr32_pm_icr_t                ICR;
-} u_avr32_pm_icr_t;
-
-typedef union
-{
-  unsigned long                 gcctrl;
-  avr32_pm_gcctrl_t             GCCTRL;
-} u_avr32_pm_gcctrl_t;
-
-typedef union
-{
-  unsigned long                 rccr;
-  avr32_pm_rccr_t               RCCR;
-} u_avr32_pm_rccr_t;
-
-typedef union
-{
-  unsigned long                 bgcr;
-  avr32_pm_bgcr_t               BGCR;
-} u_avr32_pm_bgcr_t;
-
-typedef union
-{
-  unsigned long                 vregcr;
-  avr32_pm_vregcr_t             VREGCR;
-} u_avr32_pm_vregcr_t;
-
-typedef union
-{
-  unsigned long                 bod;
-  avr32_pm_bod_t                BOD;
-} u_avr32_pm_bod_t;
-
-//! @}
-
-
-/*! \brief Sets the mode of the oscillator 0.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
- */
-static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
-{
-  // Read
-  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm-&gt;oscctrl0};
-  // Modify
-  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
-  // Write
-  pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
-}
-
-
-void pm_enable_osc0_ext_clock(volatile avr32_pm_t *pm)
-{
-  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
-}
-
-
-void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
-{
-  pm_set_osc0_mode(pm, (fosc0 &lt;  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
-                       (fosc0 &lt; 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
-                       (fosc0 &lt; 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
-                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
-}
-
-
-void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
-{
-  pm_enable_clk0_no_wait(pm, startup);
-  pm_wait_for_clk0_ready(pm);
-}
-
-
-void pm_disable_clk0(volatile avr32_pm_t *pm)
-{
-  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
-}
-
-
-void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
-{
-  // Read register
-  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm-&gt;oscctrl0};
-  // Modify
-  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
-  // Write back
-  pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
-
-  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
-}
-
-
-void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
-{
-  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC0RDY_MASK));
-}
-
-
-/*! \brief Sets the mode of the oscillator 1.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
- */
-static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
-{
-  // Read
-  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm-&gt;oscctrl1};
-  // Modify
-  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
-  // Write
-  pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
-}
-
-
-void pm_enable_osc1_ext_clock(volatile avr32_pm_t *pm)
-{
-  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
-}
-
-
-void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
-{
-  pm_set_osc1_mode(pm, (fosc1 &lt;  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
-                       (fosc1 &lt; 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
-                       (fosc1 &lt; 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
-                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
-}
-
-
-void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
-{
-  pm_enable_clk1_no_wait(pm, startup);
-  pm_wait_for_clk1_ready(pm);
-}
-
-
-void pm_disable_clk1(volatile avr32_pm_t *pm)
-{
-  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC1EN_MASK;
-}
-
-
-void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
-{
-  // Read register
-  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm-&gt;oscctrl1};
-  // Modify
-  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
-  // Write back
-  pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
-
-  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
-}
-
-
-void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
-{
-  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC1RDY_MASK));
-}
-
-
-/*! \brief Sets the mode of the 32-kHz oscillator.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
- */
-static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
-{
-  // Read
-  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm-&gt;oscctrl32};
-  // Modify
-  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
-  // Write
-  pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
-}
-
-
-void pm_enable_osc32_ext_clock(volatile avr32_pm_t *pm)
-{
-  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
-}
-
-
-void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
-{
-  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
-}
-
-
-void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
-{
-  pm_enable_clk32_no_wait(pm, startup);
-  pm_wait_for_clk32_ready(pm);
-}
-
-
-void pm_disable_clk32(volatile avr32_pm_t *pm)
-{
-  pm-&gt;oscctrl32 &amp;= ~AVR32_PM_OSCCTRL32_OSC32EN_MASK;
-}
-
-
-void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
-{
-  // Read register
-  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm-&gt;oscctrl32};
-  // Modify
-  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
-  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
-  // Write back
-  pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
-}
-
-
-void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
-{
-  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC32RDY_MASK));
-}
-
-
-void pm_cksel(volatile avr32_pm_t *pm,
-              unsigned int pbadiv,
-              unsigned int pbasel,
-              unsigned int pbbdiv,
-              unsigned int pbbsel,
-              unsigned int hsbdiv,
-              unsigned int hsbsel)
-{
-  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
-
-  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
-  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
-  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
-  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
-  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
-  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
-  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
-  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
-
-  pm-&gt;cksel = u_avr32_pm_cksel.cksel;
-
-  // Wait for ckrdy bit and then clear it
-  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_CKRDY_MASK));
-}
-
-
-void pm_gc_setup(volatile avr32_pm_t *pm,
-                  unsigned int gc,
-                  unsigned int osc_or_pll, // Use Osc (=0) or PLL (=1)
-                  unsigned int pll_osc, // Sel Osc0/PLL0 or Osc1/PLL1
-                  unsigned int diven,
-                  unsigned int div)
-{
-  u_avr32_pm_gcctrl_t u_avr32_pm_gcctrl = {0};
-
-  u_avr32_pm_gcctrl.GCCTRL.oscsel = pll_osc;
-  u_avr32_pm_gcctrl.GCCTRL.pllsel = osc_or_pll;
-  u_avr32_pm_gcctrl.GCCTRL.diven  = diven;
-  u_avr32_pm_gcctrl.GCCTRL.div    = div;
-
-  pm-&gt;gcctrl[gc] = u_avr32_pm_gcctrl.gcctrl;
-}
-
-
-void pm_gc_enable(volatile avr32_pm_t *pm,
-                  unsigned int gc)
-{
-  pm-&gt;gcctrl[gc] |= AVR32_PM_GCCTRL_CEN_MASK;
-}
-
-
-void pm_gc_disable(volatile avr32_pm_t *pm,
-                   unsigned int gc)
-{
-  pm-&gt;gcctrl[gc] &amp;= ~AVR32_PM_GCCTRL_CEN_MASK;
-}
-
-
-void pm_pll_setup(volatile avr32_pm_t *pm,
-                  unsigned int pll,
-                  unsigned int mul,
-                  unsigned int div,
-                  unsigned int osc,
-                  unsigned int lockcount)
-{
-  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
-
-  u_avr32_pm_pll.PLL.pllosc   = osc;
-  u_avr32_pm_pll.PLL.plldiv   = div;
-  u_avr32_pm_pll.PLL.pllmul   = mul;
-  u_avr32_pm_pll.PLL.pllcount = lockcount;
-
-  pm-&gt;pll[pll] = u_avr32_pm_pll.pll;
-}
-
-
-void pm_pll_set_option(volatile avr32_pm_t *pm,
-                       unsigned int pll,
-                       unsigned int pll_freq,
-                       unsigned int pll_div2,
-                       unsigned int pll_wbwdisable)
-{
-  u_avr32_pm_pll_t u_avr32_pm_pll = {pm-&gt;pll[pll]};
-  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 &lt;&lt; 1) | (pll_wbwdisable &lt;&lt; 2);
-  pm-&gt;pll[pll] = u_avr32_pm_pll.pll;
-}
-
-
-unsigned int pm_pll_get_option(volatile avr32_pm_t *pm,
-                               unsigned int pll)
-{
-  return (pm-&gt;pll[pll] &amp; AVR32_PM_PLLOPT_MASK) &gt;&gt; AVR32_PM_PLLOPT_OFFSET;
-}
-
-
-void pm_pll_enable(volatile avr32_pm_t *pm,
-                  unsigned int pll)
-{
-  pm-&gt;pll[pll] |= AVR32_PM_PLLEN_MASK;
-}
-
-
-void pm_pll_disable(volatile avr32_pm_t *pm,
-                  unsigned int pll)
-{
-  pm-&gt;pll[pll] &amp;= ~AVR32_PM_PLLEN_MASK;
-}
-
-
-void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
-{
-  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK0_MASK));
-}
-
-
-void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
-{
-  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK1_MASK));
-}
-
-
-void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
-{
-  // Read
-  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm-&gt;mcctrl};
-  // Modify
-  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
-  // Write back
-  pm-&gt;mcctrl = u_avr32_pm_mcctrl.mcctrl;
-}
-
-
-void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
-{
-  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
-  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
-  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
-}
-
-
-void pm_bod_enable_irq(volatile avr32_pm_t *pm)
-{
-  pm-&gt;ier = AVR32_PM_IER_BODDET_MASK;
-}
-
-
-void pm_bod_disable_irq(volatile avr32_pm_t *pm)
-{
-  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
-
-  if (global_interrupt_enabled) Disable_global_interrupt();
-  pm-&gt;idr = AVR32_PM_IDR_BODDET_MASK;
-  pm-&gt;isr;
-  if (global_interrupt_enabled) Enable_global_interrupt();
-}
-
-
-void pm_bod_clear_irq(volatile avr32_pm_t *pm)
-{
-  pm-&gt;icr = AVR32_PM_ICR_BODDET_MASK;
-}
-
-
-unsigned long pm_bod_get_irq_status(volatile avr32_pm_t *pm)
-{
-  return ((pm-&gt;isr &amp; AVR32_PM_ISR_BODDET_MASK) != 0);
-}
-
-
-unsigned long pm_bod_get_irq_enable_bit(volatile avr32_pm_t *pm)
-{
-  return ((pm-&gt;imr &amp; AVR32_PM_IMR_BODDET_MASK) != 0);
-}
-
-
-unsigned long pm_bod_get_level(volatile avr32_pm_t *pm)
-{
-  return (pm-&gt;bod &amp; AVR32_PM_BOD_LEVEL_MASK) &gt;&gt; AVR32_PM_BOD_LEVEL_OFFSET;
-}
-
-
-unsigned long pm_read_gplp(volatile avr32_pm_t *pm, unsigned long gplp)
-{
-  return pm-&gt;gplp[gplp];
-}
-
-
-void pm_write_gplp(volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value)
-{
-  pm-&gt;gplp[gplp] = value;
-}
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Power Manager driver.
+ *
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &quot;compiler.h&quot;
+#include &quot;pm.h&quot;
+
+
+/*! \name PM Writable Bit-Field Registers
+ */
+//! @{
+
+typedef union
+{
+  unsigned long                 mcctrl;
+  avr32_pm_mcctrl_t             MCCTRL;
+} u_avr32_pm_mcctrl_t;
+
+typedef union
+{
+  unsigned long                 cksel;
+  avr32_pm_cksel_t              CKSEL;
+} u_avr32_pm_cksel_t;
+
+typedef union
+{
+  unsigned long                 pll;
+  avr32_pm_pll_t                PLL;
+} u_avr32_pm_pll_t;
+
+typedef union
+{
+  unsigned long                 oscctrl0;
+  avr32_pm_oscctrl0_t           OSCCTRL0;
+} u_avr32_pm_oscctrl0_t;
+
+typedef union
+{
+  unsigned long                 oscctrl1;
+  avr32_pm_oscctrl1_t           OSCCTRL1;
+} u_avr32_pm_oscctrl1_t;
+
+typedef union
+{
+  unsigned long                 oscctrl32;
+  avr32_pm_oscctrl32_t          OSCCTRL32;
+} u_avr32_pm_oscctrl32_t;
+
+typedef union
+{
+  unsigned long                 ier;
+  avr32_pm_ier_t                IER;
+} u_avr32_pm_ier_t;
+
+typedef union
+{
+  unsigned long                 idr;
+  avr32_pm_idr_t                IDR;
+} u_avr32_pm_idr_t;
+
+typedef union
+{
+  unsigned long                 icr;
+  avr32_pm_icr_t                ICR;
+} u_avr32_pm_icr_t;
+
+typedef union
+{
+  unsigned long                 gcctrl;
+  avr32_pm_gcctrl_t             GCCTRL;
+} u_avr32_pm_gcctrl_t;
+
+typedef union
+{
+  unsigned long                 rccr;
+  avr32_pm_rccr_t               RCCR;
+} u_avr32_pm_rccr_t;
+
+typedef union
+{
+  unsigned long                 bgcr;
+  avr32_pm_bgcr_t               BGCR;
+} u_avr32_pm_bgcr_t;
+
+typedef union
+{
+  unsigned long                 vregcr;
+  avr32_pm_vregcr_t             VREGCR;
+} u_avr32_pm_vregcr_t;
+
+typedef union
+{
+  unsigned long                 bod;
+  avr32_pm_bod_t                BOD;
+} u_avr32_pm_bod_t;
+
+//! @}
+
+
+/*! \brief Sets the mode of the oscillator 0.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
+ */
+static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
+{
+  // Read
+  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm-&gt;oscctrl0};
+  // Modify
+  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
+  // Write
+  pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
+}
+
+
+void pm_enable_osc0_ext_clock(volatile avr32_pm_t *pm)
+{
+  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
+}
+
+
+void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
+{
+  pm_set_osc0_mode(pm, (fosc0 &lt;  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
+                       (fosc0 &lt; 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
+                       (fosc0 &lt; 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
+                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
+}
+
+
+void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  pm_enable_clk0_no_wait(pm, startup);
+  pm_wait_for_clk0_ready(pm);
+}
+
+
+void pm_disable_clk0(volatile avr32_pm_t *pm)
+{
+  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
+}
+
+
+void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  // Read register
+  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm-&gt;oscctrl0};
+  // Modify
+  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
+  // Write back
+  pm-&gt;oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
+
+  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
+}
+
+
+void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC0RDY_MASK));
+}
+
+
+/*! \brief Sets the mode of the oscillator 1.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ * \param mode Oscillator 1 mode (i.e. AVR32_PM_OSCCTRL1_MODE_x).
+ */
+static void pm_set_osc1_mode(volatile avr32_pm_t *pm, unsigned int mode)
+{
+  // Read
+  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm-&gt;oscctrl1};
+  // Modify
+  u_avr32_pm_oscctrl1.OSCCTRL1.mode = mode;
+  // Write
+  pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
+}
+
+
+void pm_enable_osc1_ext_clock(volatile avr32_pm_t *pm)
+{
+  pm_set_osc1_mode(pm, AVR32_PM_OSCCTRL1_MODE_EXT_CLOCK);
+}
+
+
+void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1)
+{
+  pm_set_osc1_mode(pm, (fosc1 &lt;  900000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G0 :
+                       (fosc1 &lt; 3000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G1 :
+                       (fosc1 &lt; 8000000) ? AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G2 :
+                                           AVR32_PM_OSCCTRL1_MODE_CRYSTAL_G3);
+}
+
+
+void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  pm_enable_clk1_no_wait(pm, startup);
+  pm_wait_for_clk1_ready(pm);
+}
+
+
+void pm_disable_clk1(volatile avr32_pm_t *pm)
+{
+  pm-&gt;mcctrl &amp;= ~AVR32_PM_MCCTRL_OSC1EN_MASK;
+}
+
+
+void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  // Read register
+  u_avr32_pm_oscctrl1_t u_avr32_pm_oscctrl1 = {pm-&gt;oscctrl1};
+  // Modify
+  u_avr32_pm_oscctrl1.OSCCTRL1.startup = startup;
+  // Write back
+  pm-&gt;oscctrl1 = u_avr32_pm_oscctrl1.oscctrl1;
+
+  pm-&gt;mcctrl |= AVR32_PM_MCCTRL_OSC1EN_MASK;
+}
+
+
+void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC1RDY_MASK));
+}
+
+
+/*! \brief Sets the mode of the 32-kHz oscillator.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
+ */
+static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
+{
+  // Read
+  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm-&gt;oscctrl32};
+  // Modify
+  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
+  // Write
+  pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
+}
+
+
+void pm_enable_osc32_ext_clock(volatile avr32_pm_t *pm)
+{
+  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
+}
+
+
+void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
+{
+  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
+}
+
+
+void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  pm_enable_clk32_no_wait(pm, startup);
+  pm_wait_for_clk32_ready(pm);
+}
+
+
+void pm_disable_clk32(volatile avr32_pm_t *pm)
+{
+  pm-&gt;oscctrl32 &amp;= ~AVR32_PM_OSCCTRL32_OSC32EN_MASK;
+}
+
+
+void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
+{
+  // Read register
+  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm-&gt;oscctrl32};
+  // Modify
+  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
+  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
+  // Write back
+  pm-&gt;oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
+}
+
+
+void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_OSC32RDY_MASK));
+}
+
+
+void pm_cksel(volatile avr32_pm_t *pm,
+              unsigned int pbadiv,
+              unsigned int pbasel,
+              unsigned int pbbdiv,
+              unsigned int pbbsel,
+              unsigned int hsbdiv,
+              unsigned int hsbsel)
+{
+  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
+
+  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
+  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
+  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
+  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
+  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
+  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
+  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
+  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
+
+  pm-&gt;cksel = u_avr32_pm_cksel.cksel;
+
+  // Wait for ckrdy bit and then clear it
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_CKRDY_MASK));
+}
+
+
+void pm_gc_setup(volatile avr32_pm_t *pm,
+                  unsigned int gc,
+                  unsigned int osc_or_pll, // Use Osc (=0) or PLL (=1)
+                  unsigned int pll_osc, // Sel Osc0/PLL0 or Osc1/PLL1
+                  unsigned int diven,
+                  unsigned int div)
+{
+  u_avr32_pm_gcctrl_t u_avr32_pm_gcctrl = {0};
+
+  u_avr32_pm_gcctrl.GCCTRL.oscsel = pll_osc;
+  u_avr32_pm_gcctrl.GCCTRL.pllsel = osc_or_pll;
+  u_avr32_pm_gcctrl.GCCTRL.diven  = diven;
+  u_avr32_pm_gcctrl.GCCTRL.div    = div;
+
+  pm-&gt;gcctrl[gc] = u_avr32_pm_gcctrl.gcctrl;
+}
+
+
+void pm_gc_enable(volatile avr32_pm_t *pm,
+                  unsigned int gc)
+{
+  pm-&gt;gcctrl[gc] |= AVR32_PM_GCCTRL_CEN_MASK;
+}
+
+
+void pm_gc_disable(volatile avr32_pm_t *pm,
+                   unsigned int gc)
+{
+  pm-&gt;gcctrl[gc] &amp;= ~AVR32_PM_GCCTRL_CEN_MASK;
+}
+
+
+void pm_pll_setup(volatile avr32_pm_t *pm,
+                  unsigned int pll,
+                  unsigned int mul,
+                  unsigned int div,
+                  unsigned int osc,
+                  unsigned int lockcount)
+{
+  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
+
+  u_avr32_pm_pll.PLL.pllosc   = osc;
+  u_avr32_pm_pll.PLL.plldiv   = div;
+  u_avr32_pm_pll.PLL.pllmul   = mul;
+  u_avr32_pm_pll.PLL.pllcount = lockcount;
+
+  pm-&gt;pll[pll] = u_avr32_pm_pll.pll;
+}
+
+
+void pm_pll_set_option(volatile avr32_pm_t *pm,
+                       unsigned int pll,
+                       unsigned int pll_freq,
+                       unsigned int pll_div2,
+                       unsigned int pll_wbwdisable)
+{
+  u_avr32_pm_pll_t u_avr32_pm_pll = {pm-&gt;pll[pll]};
+  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 &lt;&lt; 1) | (pll_wbwdisable &lt;&lt; 2);
+  pm-&gt;pll[pll] = u_avr32_pm_pll.pll;
+}
+
+
+unsigned int pm_pll_get_option(volatile avr32_pm_t *pm,
+                               unsigned int pll)
+{
+  return (pm-&gt;pll[pll] &amp; AVR32_PM_PLLOPT_MASK) &gt;&gt; AVR32_PM_PLLOPT_OFFSET;
+}
+
+
+void pm_pll_enable(volatile avr32_pm_t *pm,
+                  unsigned int pll)
+{
+  pm-&gt;pll[pll] |= AVR32_PM_PLLEN_MASK;
+}
+
+
+void pm_pll_disable(volatile avr32_pm_t *pm,
+                  unsigned int pll)
+{
+  pm-&gt;pll[pll] &amp;= ~AVR32_PM_PLLEN_MASK;
+}
+
+
+void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK0_MASK));
+}
+
+
+void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
+{
+  while (!(pm-&gt;poscsr &amp; AVR32_PM_POSCSR_LOCK1_MASK));
+}
+
+
+void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
+{
+  // Read
+  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm-&gt;mcctrl};
+  // Modify
+  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
+  // Write back
+  pm-&gt;mcctrl = u_avr32_pm_mcctrl.mcctrl;
+}
+
+
+void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
+{
+  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
+  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
+  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
+}
+
+
+void pm_bod_enable_irq(volatile avr32_pm_t *pm)
+{
+  pm-&gt;ier = AVR32_PM_IER_BODDET_MASK;
+}
+
+
+void pm_bod_disable_irq(volatile avr32_pm_t *pm)
+{
+  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
+
+  if (global_interrupt_enabled) Disable_global_interrupt();
+  pm-&gt;idr = AVR32_PM_IDR_BODDET_MASK;
+  pm-&gt;isr;
+  if (global_interrupt_enabled) Enable_global_interrupt();
+}
+
+
+void pm_bod_clear_irq(volatile avr32_pm_t *pm)
+{
+  pm-&gt;icr = AVR32_PM_ICR_BODDET_MASK;
+}
+
+
+unsigned long pm_bod_get_irq_status(volatile avr32_pm_t *pm)
+{
+  return ((pm-&gt;isr &amp; AVR32_PM_ISR_BODDET_MASK) != 0);
+}
+
+
+unsigned long pm_bod_get_irq_enable_bit(volatile avr32_pm_t *pm)
+{
+  return ((pm-&gt;imr &amp; AVR32_PM_IMR_BODDET_MASK) != 0);
+}
+
+
+unsigned long pm_bod_get_level(volatile avr32_pm_t *pm)
+{
+  return (pm-&gt;bod &amp; AVR32_PM_BOD_LEVEL_MASK) &gt;&gt; AVR32_PM_BOD_LEVEL_OFFSET;
+}
+
+
+unsigned long pm_read_gplp(volatile avr32_pm_t *pm, unsigned long gplp)
+{
+  return pm-&gt;gplp[gplp];
+}
+
+
+void pm_write_gplp(volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value)
+{
+  pm-&gt;gplp[gplp] = value;
+}
+
+
+long pm_enable_module(volatile avr32_pm_t *pm, unsigned long module)
+{
+  unsigned long domain = module&gt;&gt;5;
+  unsigned long *regptr = (unsigned long*)(&amp;(pm-&gt;cpumask) + domain*sizeof(unsigned long));
+
+  // Implementation-specific shortcut: the ckMASK registers are contiguous and
+  // memory-mapped in that order: CPUMASK, HSBMASK, PBAMASK, PBBMASK.
+
+  *regptr |= (module%32);
+
+  return PASS;
+}
+
+long pm_disable_module(volatile avr32_pm_t *pm, unsigned long module)
+{
+  unsigned long domain = module&gt;&gt;5;
+  unsigned long *regptr = (unsigned long*)(&amp;(pm-&gt;cpumask) + domain*sizeof(unsigned long));
+
+  // Implementation-specific shortcut: the ckMASK registers are contiguous and
+  // memory-mapped in that order: CPUMASK, HSBMASK, PBAMASK, PBBMASK.
+
+  *regptr &amp;= ~(module%32);
+
+  return PASS;
+}

Modified: trunk/src/platform/avr32/pm.h
===================================================================
--- trunk/src/platform/avr32/pm.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/pm.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,463 +1,493 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file has been prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Power Manager driver.
- *
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- *****************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _PM_H_
-#define _PM_H_
-
-#include &lt;avr32/io.h&gt;
-#include &quot;compiler.h&quot;
-#include &quot;preprocessor.h&quot;
-
-
-/*! \brief Sets the MCU in the specified sleep mode.
- *
- * \param mode Sleep mode:
- *   \arg \c AVR32_PM_SMODE_IDLE: Idle;
- *   \arg \c AVR32_PM_SMODE_FROZEN: Frozen;
- *   \arg \c AVR32_PM_SMODE_STANDBY: Standby;
- *   \arg \c AVR32_PM_SMODE_STOP: Stop;
- *   \arg \c AVR32_PM_SMODE_SHUTDOWN: Shutdown (DeepStop);
- *   \arg \c AVR32_PM_SMODE_STATIC: Static.
- */
-#define SLEEP(mode)   {__asm__ __volatile__ (&quot;sleep &quot;STRINGZ(mode));}
-
-
-//! Input and output parameters when initializing PM clocks using pm_configure_clocks().
-typedef struct
-{
-  //! CPU frequency (input/output argument).
-  unsigned long cpu_f;
-
-  //! PBA frequency (input/output argument).
-  unsigned long pba_f;
-
-  //! Oscillator 0 frequency (board dependant) (input argument).
-  unsigned long osc0_f;
-
-  //! Oscillator 0 startup time: AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC (input argument).
-  unsigned long osc0_startup;
-} pm_freq_param_t;
-
-#define PM_FREQ_STATUS_FAIL   (-1)
-#define PM_FREQ_STATUS_OK     (0)
-
-
-/*! \brief Gets the MCU reset cause.
- *
- * \param pm Base address of the Power Manager instance (i.e. &amp;AVR32_PM).
- *
- * \return The MCU reset cause which can be masked with the
- *         \c AVR32_PM_RCAUSE_x_MASK bit-masks to isolate specific causes.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ unsigned int pm_get_reset_cause(volatile avr32_pm_t *pm)
-{
-  return pm-&gt;rcause;
-}
-
-
-/*!
- * \brief This function will enable the external clock mode of the oscillator 0.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_enable_osc0_ext_clock(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the crystal mode of the oscillator 0.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param fosc0 Oscillator 0 crystal frequency (Hz)
- */
-extern void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0);
-
-
-/*!
- * \brief This function will enable the oscillator 0 to be used with a startup time.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param startup Clock 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
- */
-extern void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup);
-
-
-/*!
- * \brief This function will disable the oscillator 0.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_disable_clk0(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the oscillator 0 to be used with no startup time.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param startup Clock 0 startup time, for which the function does not wait. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
- */
-extern void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
-
-
-/*!
- * \brief This function will wait until the Osc0 clock is ready.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the external clock mode of the oscillator 1.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_enable_osc1_ext_clock(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the crystal mode of the oscillator 1.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param fosc1 Oscillator 1 crystal frequency (Hz)
- */
-extern void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1);
-
-
-/*!
- * \brief This function will enable the oscillator 1 to be used with a startup time.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param startup Clock 1 startup time. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC.
- */
-extern void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup);
-
-
-/*!
- * \brief This function will disable the oscillator 1.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_disable_clk1(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the oscillator 1 to be used with no startup time.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param startup Clock 1 startup time, for which the function does not wait. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC.
- */
-extern void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
-
-
-/*!
- * \brief This function will wait until the Osc1 clock is ready.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the external clock mode of the 32-kHz oscillator.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_enable_osc32_ext_clock(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the crystal mode of the 32-kHz oscillator.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_enable_osc32_crystal(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the oscillator 32 to be used with a startup time.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param startup Clock 32 kHz startup time. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC.
- */
-extern void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup);
-
-
-/*!
- * \brief This function will disable the oscillator 32.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_disable_clk32(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will enable the oscillator 32 to be used with no startup time.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param startup Clock 32 kHz startup time, for which the function does not wait. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC.
- */
-extern void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
-
-
-/*!
- * \brief This function will wait until the osc32 clock is ready.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will select all the power manager clocks.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param pbadiv Peripheral Bus A clock divisor enable
- * \param pbasel Peripheral Bus A select
- * \param pbbdiv Peripheral Bus B clock divisor enable
- * \param pbbsel Peripheral Bus B select
- * \param hsbdiv High Speed Bus clock divisor enable (CPU clock = HSB clock)
- * \param hsbsel High Speed Bus select (CPU clock = HSB clock )
- */
-extern void pm_cksel(volatile avr32_pm_t *pm, unsigned int pbadiv, unsigned int pbasel, unsigned int pbbdiv, unsigned int pbbsel, unsigned int hsbdiv, unsigned int hsbsel);
-
-
-/*!
- * \brief This function will setup a generic clock.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param gc generic clock number (0 for gc0...)
- * \param osc_or_pll Use OSC (=0) or PLL (=1)
- * \param pll_osc Select Osc0/PLL0 or Osc1/PLL1
- * \param diven Generic clock divisor enable
- * \param div Generic clock divisor
- */
-extern void pm_gc_setup(volatile avr32_pm_t *pm, unsigned int gc, unsigned int osc_or_pll, unsigned int pll_osc, unsigned int diven, unsigned int div);
-
-
-/*!
- * \brief This function will enable a generic clock.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param gc generic clock number (0 for gc0...)
- */
-extern void pm_gc_enable(volatile avr32_pm_t *pm, unsigned int gc);
-
-
-/*!
- * \brief This function will disable a generic clock.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param gc generic clock number (0 for gc0...)
- */
-extern void pm_gc_disable(volatile avr32_pm_t *pm, unsigned int gc);
-
-
-/*!
- * \brief This function will setup a PLL.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param pll PLL number(0 for PLL0, 1 for PLL1)
- * \param mul PLL MUL in the PLL formula
- * \param div PLL DIV in the PLL formula
- * \param osc OSC number (0 for osc0, 1 for osc1)
- * \param lockcount PLL lockount
- */
-extern void pm_pll_setup(volatile avr32_pm_t *pm, unsigned int pll, unsigned int mul, unsigned int div, unsigned int osc, unsigned int lockcount);
-
-
-/*!
- * \brief This function will set a PLL option.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param pll PLL number(0 for PLL0, 1 for PLL1)
- * \param pll_freq Set to 1 for VCO frequency range 80-180MHz, set to 0 for VCO frequency range 160-240Mhz.
- * \param pll_div2 Divide the PLL output frequency by 2 (this settings does not change the FVCO value)
- * \param pll_wbwdisable 1 Disable the Wide-Bandith Mode (Wide-Bandwith mode allow a faster startup time and out-of-lock time). 0 to enable the Wide-Bandith Mode.
- */
-extern void pm_pll_set_option(volatile avr32_pm_t *pm, unsigned int pll, unsigned int  pll_freq, unsigned int  pll_div2, unsigned int  pll_wbwdisable);
-
-
-/*!
- * \brief This function will get a PLL option.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param pll PLL number(0 for PLL0, 1 for PLL1)
- * \return       Option
- */
-extern unsigned int pm_pll_get_option(volatile avr32_pm_t *pm, unsigned int pll);
-
-
-/*!
- * \brief This function will enable a PLL.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param pll PLL number(0 for PLL0, 1 for PLL1)
- */
-extern void pm_pll_enable(volatile avr32_pm_t *pm, unsigned int pll);
-
-
-/*!
- * \brief This function will disable a PLL.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param pll PLL number(0 for PLL0, 1 for PLL1)
- */
-extern void pm_pll_disable(volatile avr32_pm_t *pm, unsigned int pll);
-
-
-/*!
- * \brief This function will wait for PLL0 locked
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will wait for PLL1 locked
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- */
-extern void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief This function will switch the power manager main clock.
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param clock Clock to be switched on. AVR32_PM_MCSEL_SLOW for RCOsc, AVR32_PM_MCSEL_OSC0 for Osc0, AVR32_PM_MCSEL_PLL0 for PLL0.
- */
-extern void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock);
-
-
-/*!
- * \brief Switch main clock to clock Osc0 (crystal mode)
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param fosc0 Oscillator 0 crystal frequency (Hz)
- * \param startup Crystal 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
- */
-extern void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup);
-
-
-/*! \brief Enables the Brown-Out Detector interrupt.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- */
-extern void pm_bod_enable_irq(volatile avr32_pm_t *pm);
-
-
-/*! \brief Disables the Brown-Out Detector interrupt.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- */
-extern void pm_bod_disable_irq(volatile avr32_pm_t *pm);
-
-
-/*! \brief Clears the Brown-Out Detector interrupt flag.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- */
-extern void pm_bod_clear_irq(volatile avr32_pm_t *pm);
-
-
-/*! \brief Gets the Brown-Out Detector interrupt flag.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- *
- * \retval 0 No BOD interrupt.
- * \retval 1 BOD interrupt pending.
- */
-extern unsigned long pm_bod_get_irq_status(volatile avr32_pm_t *pm);
-
-
-/*! \brief Gets the Brown-Out Detector interrupt enable status.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- *
- * \retval 0 BOD interrupt disabled.
- * \retval 1 BOD interrupt enabled.
- */
-extern unsigned long pm_bod_get_irq_enable_bit(volatile avr32_pm_t *pm);
-
-
-/*! \brief Gets the triggering threshold of the Brown-Out Detector.
- *
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
- *
- * \return Triggering threshold of the BOD. See the electrical characteristics
- *         in the part datasheet for actual voltage levels.
- */
-extern unsigned long pm_bod_get_level(volatile avr32_pm_t *pm);
-
-
-/*!
- * \brief Read the content of the PM GPLP registers
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param gplp GPLP register index (0,1,... depending on the number of GPLP registers for a given part)
- *
- * \return The content of the chosen GPLP register.
- */
-extern unsigned long pm_read_gplp(volatile avr32_pm_t *pm, unsigned long gplp);
-
-
-/*!
- * \brief Write into the PM GPLP registers
- * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
- * \param gplp GPLP register index (0,1,... depending on the number of GPLP registers for a given part)
- * \param value Value to write
- */
-extern void pm_write_gplp(volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value);
-
-
-/*! \brief Automatically configure the CPU, PBA, PBB, and HSB clocks
- *         according to the user wishes.
- *
- * This function needs some parameters stored in a pm_freq_param_t structure:
- *  - cpu_f and pba_f are the wanted frequencies,
- *  - osc0_f is the oscillator 0 on-board frequency (e.g. FOSC0),
- *  - osc0_startup is the oscillator 0 startup time (e.g. OSC0_STARTUP).
- *
- * The function will then configure the clocks using the following rules:
- *  - It first try to find a valid PLL frequency (the highest possible value to avoid jitter) in order
- *    to satisfy the CPU frequency,
- *  - It optimizes the configuration depending the various divide stages,
- *  - Then, the PBA frequency is configured from the CPU freq (PBA freq = CPU freq/(2 exp x)) so that
- *    PBA max frequencies is always below 30MHz.
- *  - Note that HSB and PBB are configured with the same frequency as CPU.
- *  - Note also that the number of wait states of the flash read accesses is automatically set-up depending
- *    the CPU frequency. As a consequence, the application needs the FLASHC driver to compile.
- *
- * The CPU, HSB and PBA frequencies programmed after configuration are stored back into cpu_f and pba_f.
- *
- * \param param    pointer on the configuration structure.
- *
- * \retval PM_FREQ_STATUS_OK    Mode successfully initialized.
- * \retval PM_FREQ_STATUS_FAIL  The configuration can not be done.
- */
-extern int pm_configure_clocks(pm_freq_param_t *param);
-
-
-/*! \brief Automatically configure the USB clock.
- *
- * USB clock is configured to 48MHz, using the PLL1 from the Oscillator0, assuming
- * a 12 MHz crystal is connected to it.
- */
-extern void pm_configure_usb_clock(void);
-
-
-#endif  // _PM_H_
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Power Manager driver.
+ *
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _PM_H_
+#define _PM_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;preprocessor.h&quot;
+
+
+/*! \brief Sets the MCU in the specified sleep mode.
+ *
+ * \param mode Sleep mode:
+ *   \arg \c AVR32_PM_SMODE_IDLE: Idle;
+ *   \arg \c AVR32_PM_SMODE_FROZEN: Frozen;
+ *   \arg \c AVR32_PM_SMODE_STANDBY: Standby;
+ *   \arg \c AVR32_PM_SMODE_STOP: Stop;
+ *   \arg \c AVR32_PM_SMODE_DEEP_STOP: DeepStop;
+ *   \arg \c AVR32_PM_SMODE_STATIC: Static.
+ */
+#define SLEEP(mode)   {__asm__ __volatile__ (&quot;sleep &quot;STRINGZ(mode));}
+
+
+//! Input and output parameters when initializing PM clocks using pm_configure_clocks().
+typedef struct
+{
+  //! CPU frequency (input/output argument).
+  unsigned long cpu_f;
+
+  //! PBA frequency (input/output argument).
+  unsigned long pba_f;
+
+  //! Oscillator 0's external crystal(or external clock) frequency (board dependant) (input argument).
+  unsigned long osc0_f;
+
+  //! Oscillator 0's external crystal(or external clock) startup time: AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC (input argument).
+  unsigned long osc0_startup;
+} pm_freq_param_t;
+
+#define PM_FREQ_STATUS_FAIL   (-1)
+#define PM_FREQ_STATUS_OK     (0)
+
+
+/*! \brief Gets the MCU reset cause.
+ *
+ * \param pm Base address of the Power Manager instance (i.e. &amp;AVR32_PM).
+ *
+ * \return The MCU reset cause which can be masked with the
+ *         \c AVR32_PM_RCAUSE_x_MASK bit-masks to isolate specific causes.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ unsigned int pm_get_reset_cause(volatile avr32_pm_t *pm)
+{
+  return pm-&gt;rcause;
+}
+
+
+/*!
+ * \brief This function will enable the external clock mode of the oscillator 0.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc0_ext_clock(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the crystal mode of the oscillator 0.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param fosc0 Oscillator 0 crystal frequency (Hz)
+ */
+extern void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0);
+
+
+/*!
+ * \brief This function will enable the oscillator 0 to be used with a startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will disable the oscillator 0.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_disable_clk0(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 0 to be used with no startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 0 startup time, for which the function does not wait. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will wait until the Osc0 clock is ready.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the external clock mode of the oscillator 1.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc1_ext_clock(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the crystal mode of the oscillator 1.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param fosc1 Oscillator 1 crystal frequency (Hz)
+ */
+extern void pm_enable_osc1_crystal(volatile avr32_pm_t *pm, unsigned int fosc1);
+
+
+/*!
+ * \brief This function will enable the oscillator 1 to be used with a startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 1 startup time. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk1(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will disable the oscillator 1.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_disable_clk1(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 1 to be used with no startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 1 startup time, for which the function does not wait. AVR32_PM_OSCCTRL1_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk1_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will wait until the Osc1 clock is ready.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_clk1_ready(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the external clock mode of the 32-kHz oscillator.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc32_ext_clock(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the crystal mode of the 32-kHz oscillator.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_enable_osc32_crystal(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 32 to be used with a startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 32 kHz startup time. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will disable the oscillator 32.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_disable_clk32(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will enable the oscillator 32 to be used with no startup time.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param startup Clock 32 kHz startup time, for which the function does not wait. AVR32_PM_OSCCTRL32_STARTUP_x_RCOSC.
+ */
+extern void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup);
+
+
+/*!
+ * \brief This function will wait until the osc32 clock is ready.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will select all the power manager clocks.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pbadiv Peripheral Bus A clock divisor enable
+ * \param pbasel Peripheral Bus A select
+ * \param pbbdiv Peripheral Bus B clock divisor enable
+ * \param pbbsel Peripheral Bus B select
+ * \param hsbdiv High Speed Bus clock divisor enable (CPU clock = HSB clock)
+ * \param hsbsel High Speed Bus select (CPU clock = HSB clock )
+ */
+extern void pm_cksel(volatile avr32_pm_t *pm, unsigned int pbadiv, unsigned int pbasel, unsigned int pbbdiv, unsigned int pbbsel, unsigned int hsbdiv, unsigned int hsbsel);
+
+
+/*!
+ * \brief This function will setup a generic clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gc generic clock number (0 for gc0...)
+ * \param osc_or_pll Use OSC (=0) or PLL (=1)
+ * \param pll_osc Select Osc0/PLL0 or Osc1/PLL1
+ * \param diven Generic clock divisor enable
+ * \param div Generic clock divisor
+ */
+extern void pm_gc_setup(volatile avr32_pm_t *pm, unsigned int gc, unsigned int osc_or_pll, unsigned int pll_osc, unsigned int diven, unsigned int div);
+
+
+/*!
+ * \brief This function will enable a generic clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gc generic clock number (0 for gc0...)
+ */
+extern void pm_gc_enable(volatile avr32_pm_t *pm, unsigned int gc);
+
+
+/*!
+ * \brief This function will disable a generic clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gc generic clock number (0 for gc0...)
+ */
+extern void pm_gc_disable(volatile avr32_pm_t *pm, unsigned int gc);
+
+
+/*!
+ * \brief This function will setup a PLL.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ * \param mul PLL MUL in the PLL formula
+ * \param div PLL DIV in the PLL formula
+ * \param osc OSC number (0 for osc0, 1 for osc1)
+ * \param lockcount PLL lockount
+ */
+extern void pm_pll_setup(volatile avr32_pm_t *pm, unsigned int pll, unsigned int mul, unsigned int div, unsigned int osc, unsigned int lockcount);
+
+
+/*!
+ * \brief This function will set a PLL option.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ * \param pll_freq Set to 1 for VCO frequency range 80-180MHz, set to 0 for VCO frequency range 160-240Mhz.
+ * \param pll_div2 Divide the PLL output frequency by 2 (this settings does not change the FVCO value)
+ * \param pll_wbwdisable 1 Disable the Wide-Bandith Mode (Wide-Bandwith mode allow a faster startup time and out-of-lock time). 0 to enable the Wide-Bandith Mode.
+ */
+extern void pm_pll_set_option(volatile avr32_pm_t *pm, unsigned int pll, unsigned int  pll_freq, unsigned int  pll_div2, unsigned int  pll_wbwdisable);
+
+
+/*!
+ * \brief This function will get a PLL option.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ * \return       Option
+ */
+extern unsigned int pm_pll_get_option(volatile avr32_pm_t *pm, unsigned int pll);
+
+
+/*!
+ * \brief This function will enable a PLL.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ */
+extern void pm_pll_enable(volatile avr32_pm_t *pm, unsigned int pll);
+
+
+/*!
+ * \brief This function will disable a PLL.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param pll PLL number(0 for PLL0, 1 for PLL1)
+ */
+extern void pm_pll_disable(volatile avr32_pm_t *pm, unsigned int pll);
+
+
+/*!
+ * \brief This function will wait for PLL0 locked
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will wait for PLL1 locked
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ */
+extern void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief This function will switch the power manager main clock.
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param clock Clock to be switched on. AVR32_PM_MCSEL_SLOW for RCOsc, AVR32_PM_MCSEL_OSC0 for Osc0, AVR32_PM_MCSEL_PLL0 for PLL0.
+ */
+extern void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock);
+
+
+/*!
+ * \brief Switch main clock to clock Osc0 (crystal mode)
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param fosc0 Oscillator 0 crystal frequency (Hz)
+ * \param startup Crystal 0 startup time. AVR32_PM_OSCCTRL0_STARTUP_x_RCOSC.
+ */
+extern void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup);
+
+
+/*! \brief Enables the Brown-Out Detector interrupt.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ */
+extern void pm_bod_enable_irq(volatile avr32_pm_t *pm);
+
+
+/*! \brief Disables the Brown-Out Detector interrupt.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ */
+extern void pm_bod_disable_irq(volatile avr32_pm_t *pm);
+
+
+/*! \brief Clears the Brown-Out Detector interrupt flag.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ */
+extern void pm_bod_clear_irq(volatile avr32_pm_t *pm);
+
+
+/*! \brief Gets the Brown-Out Detector interrupt flag.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ *
+ * \retval 0 No BOD interrupt.
+ * \retval 1 BOD interrupt pending.
+ */
+extern unsigned long pm_bod_get_irq_status(volatile avr32_pm_t *pm);
+
+
+/*! \brief Gets the Brown-Out Detector interrupt enable status.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ *
+ * \retval 0 BOD interrupt disabled.
+ * \retval 1 BOD interrupt enabled.
+ */
+extern unsigned long pm_bod_get_irq_enable_bit(volatile avr32_pm_t *pm);
+
+
+/*! \brief Gets the triggering threshold of the Brown-Out Detector.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM).
+ *
+ * \return Triggering threshold of the BOD. See the electrical characteristics
+ *         in the part datasheet for actual voltage levels.
+ */
+extern unsigned long pm_bod_get_level(volatile avr32_pm_t *pm);
+
+
+/*!
+ * \brief Read the content of the PM GPLP registers
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gplp GPLP register index (0,1,... depending on the number of GPLP registers for a given part)
+ *
+ * \return The content of the chosen GPLP register.
+ */
+extern unsigned long pm_read_gplp(volatile avr32_pm_t *pm, unsigned long gplp);
+
+
+/*!
+ * \brief Write into the PM GPLP registers
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param gplp GPLP register index (0,1,... depending on the number of GPLP registers for a given part)
+ * \param value Value to write
+ */
+extern void pm_write_gplp(volatile avr32_pm_t *pm, unsigned long gplp, unsigned long value);
+
+
+/*! \brief Enable the clock of a module.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param module The module to clock (use one of the defines in the part-specific
+ * header file under &quot;toolchain folder&quot;/avr32/inc(lude)/avr32/; depending on the
+ * clock domain, look for the sections &quot;CPU clocks&quot;, &quot;HSB clocks&quot;, &quot;PBx clocks&quot;)
+ *
+ * \return Status.
+ *   \retval 0  Success.
+ *   \retval &lt;0 An error occured.
+ */
+extern long pm_enable_module(volatile avr32_pm_t *pm, unsigned long module);
+
+/*! \brief Disable the clock of a module.
+ *
+ * \param pm Base address of the Power Manager (i.e. &amp;AVR32_PM)
+ * \param module The module to shut down (use one of the defines in the part-specific
+ * header file under &quot;toolchain folder&quot;/avr32/inc(lude)/avr32/; depending on the
+ * clock domain, look for the sections &quot;CPU clocks&quot;, &quot;HSB clocks&quot;, &quot;PBx clocks&quot;)
+ *
+ * \return Status.
+ *   \retval 0  Success.
+ *   \retval &lt;0 An error occured.
+ */
+extern long pm_disable_module(volatile avr32_pm_t *pm, unsigned long module);
+
+
+
+/*! \brief Automatically configure the CPU, PBA, PBB, and HSB clocks
+ *         according to the user wishes.
+ *
+ * This function needs some parameters stored in a pm_freq_param_t structure:
+ *  - cpu_f and pba_f are the wanted frequencies,
+ *  - osc0_f is the oscillator 0 on-board frequency (e.g. FOSC0),
+ *  - osc0_startup is the oscillator 0 startup time (e.g. OSC0_STARTUP).
+ *
+ * The function will then configure the clocks using the following rules:
+ *  - It first try to find a valid PLL frequency (the highest possible value to avoid jitter) in order
+ *    to satisfy the CPU frequency,
+ *  - It optimizes the configuration depending the various divide stages,
+ *  - Then, the PBA frequency is configured from the CPU freq.
+ *  - Note that HSB and PBB are configured with the same frequency as CPU.
+ *  - Note also that the number of wait states of the flash read accesses is automatically set-up depending
+ *    the CPU frequency. As a consequence, the application needs the FLASHC driver to compile.
+ *
+ * The CPU, HSB and PBA frequencies programmed after configuration are stored back into cpu_f and pba_f.
+ *
+ * \param param    pointer on the configuration structure.
+ *
+ * \retval PM_FREQ_STATUS_OK    Mode successfully initialized.
+ * \retval PM_FREQ_STATUS_FAIL  The configuration can not be done.
+ */
+extern int pm_configure_clocks(pm_freq_param_t *param);
+
+
+/*! \brief Automatically configure the USB clock.
+ *
+ * USB clock is configured to 48MHz, using the PLL1 from the Oscillator0, assuming
+ * a 12 MHz crystal is connected to it.
+ */
+extern void pm_configure_usb_clock(void);
+
+
+#endif  // _PM_H_

Modified: trunk/src/platform/avr32/pm_conf_clocks.c
===================================================================
--- trunk/src/platform/avr32/pm_conf_clocks.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/pm_conf_clocks.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,247 +1,272 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file has been prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Power Manager clocks configuration helper.
- *
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- *****************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &lt;string.h&gt;
-#if __GNUC__
-#  include &lt;sys/cpu.h&gt;
-#endif
-#include &quot;compiler.h&quot;
-#include &quot;pm.h&quot;
-
-
-extern void flashc_set_wait_state(unsigned int wait_state);
-
-
-#define PM_MAX_MUL                ((1 &lt;&lt; AVR32_PM_PLL0_PLLMUL_SIZE) - 1)
-
-
-int pm_configure_clocks(pm_freq_param_t *param)
-{
-  // Supported frequencies:
-  // Fosc0 mul div PLL div2_en cpu_f pba_f   Comment
-  //  12   15   1  192     1     12    12
-  //  12    9   3   40     1     20    20    PLL out of spec
-  //  12   15   1  192     1     24    12
-  //  12    9   1  120     1     30    15
-  //  12    9   3   40     0     40    20    PLL out of spec
-  //  12   15   1  192     1     48    12
-  //  12   15   1  192     1     48    24
-  //  12    8   1  108     1     54    27
-  //  12    9   1  120     1     60    15
-  //  12    9   1  120     1     60    30
-  //  12   10   1  132     1     66    16.5
-  //
-  unsigned long in_cpu_f  = param-&gt;cpu_f;
-  unsigned long in_osc0_f = param-&gt;osc0_f;
-  unsigned long mul, div, div2_en = 0, div2_cpu = 0, div2_pba = 0;
-  unsigned long pll_freq, rest;
-  Bool b_div2_pba, b_div2_cpu;
-
-  // Switch to external Oscillator 0
-  pm_switch_to_osc0(&amp;AVR32_PM, in_osc0_f, param-&gt;osc0_startup);
-
-  // Start with CPU freq config
-  if (in_cpu_f == in_osc0_f)
-  {
-    param-&gt;cpu_f = in_osc0_f;
-    param-&gt;pba_f = in_osc0_f;
-    return PM_FREQ_STATUS_OK;
-  }
-  else if (in_cpu_f &lt; in_osc0_f)
-  {
-    // TBD
-  }
-
-  rest = in_cpu_f % in_osc0_f;
-
-  for (div = 1; div &lt; 32; div++)
-  {
-    if ((div * rest) % in_osc0_f == 0)
-      break;
-  }
-  if (div == 32)
-    return PM_FREQ_STATUS_FAIL;
-
-  mul = (in_cpu_f * div) / in_osc0_f;
-
-  if (mul &gt; PM_MAX_MUL)
-    return PM_FREQ_STATUS_FAIL;
-
-  // export 2power from PLL div to div2_cpu
-  while (!(div % 2))
-  {
-    div /= 2;
-    div2_cpu++;
-  }
-
-  // Here we know the mul and div parameter of the PLL config.
-  // . Check out if the PLL has a valid in_cpu_f.
-  // . Try to have for the PLL frequency (VCO output) the highest possible value
-  //   to reduce jitter.
-  while (in_osc0_f * 2 * mul / div &lt; AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
-  {
-    if (2 * mul &gt; PM_MAX_MUL)
-      break;
-    mul *= 2;
-    div2_cpu++;
-  }
-
-  if (div2_cpu != 0)
-  {
-    div2_cpu--;
-    div2_en = 1;
-  }
-
-  pll_freq = in_osc0_f * mul / (div * (1 &lt;&lt; div2_en));
-
-  // Update real CPU Frequency
-  param-&gt;cpu_f = pll_freq / (1 &lt;&lt; div2_cpu);
-  mul--;
-
-  pm_pll_setup(&amp;AVR32_PM
-  , 0   // pll
-  , mul // mul
-  , div // div
-  , 0   // osc
-  , 16  // lockcount
-  );
-
-  pm_pll_set_option(&amp;AVR32_PM
-  , 0 // pll
-  // PLL clock is lower than 160MHz: need to set pllopt.
-  , (pll_freq &lt; 160000000) ? 1 : 0 // pll_freq
-  , div2_en // pll_div2
-  , 0 // pll_wbwdisable
-  );
-
-  rest = pll_freq;
-  while (rest &gt; AVR32_PM_PBA_MAX_FREQ ||
-         rest != param-&gt;pba_f)
-  {
-    div2_pba++;
-    rest = pll_freq / (1 &lt;&lt; div2_pba);
-    if (rest &lt; param-&gt;pba_f)
-      break;
-  }
-
-  // Update real PBA Frequency
-  param-&gt;pba_f = pll_freq / (1 &lt;&lt; div2_pba);
-
-#if __GNUC__
-  set_cpu_hz(param-&gt;pba_f);
-#endif
-
-  // Enable PLL0
-  pm_pll_enable(&amp;AVR32_PM, 0);
-
-  // Wait for PLL0 locked
-  pm_wait_for_pll0_locked(&amp;AVR32_PM);
-
-  if (div2_cpu)
-  {
-    b_div2_cpu = TRUE;
-    div2_cpu--;
-  }
-  else
-    b_div2_cpu = FALSE;
-
-  if (div2_pba)
-  {
-    b_div2_pba = TRUE;
-    div2_pba--;
-  }
-  else
-    b_div2_pba = FALSE;
-
-  pm_cksel(&amp;AVR32_PM
-  , b_div2_pba, div2_pba // PBA
-  , b_div2_cpu, div2_cpu // PBB
-  , b_div2_cpu, div2_cpu // HSB
-  );
-
-  if (param-&gt;cpu_f &gt; AVR32_FLASHC_FWS_0_MAX_FREQ)
-    flashc_set_wait_state(1);
-  else
-    flashc_set_wait_state(0);
-
-  pm_switch_to_clock(&amp;AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
-
-  return PM_FREQ_STATUS_OK;
-}
-
-
-void pm_configure_usb_clock(void)
-{
-  volatile avr32_pm_t *pm = &amp;AVR32_PM;
-
-  // Set PLL1 @ 96 MHz from Osc0: 12MHz*(7+1)/1 = 96MHz.
-  // In order to work, we need to go above 80MHz, then divide.
-  pm_pll_setup(pm, 1,   // pll
-                   7,   // mul
-                   1,   // div
-                   0,   // osc
-                   16); // lockcount
-
-  pm_pll_set_option(pm, 1,  // pll1
-                        1,  // Choose the range 80-180MHz.
-                        1,  // div2
-                        0); // wbwdisable
-
-  // Enable PLL1.
-  pm_pll_enable(pm, 1);
-
-  // Wait for PLL1 locked.
-  pm_wait_for_pll1_locked(pm);
-
-  // Setup USB GCLK.
-  pm_gc_setup(pm, AVR32_PM_GCLK_USBB, // gc
-                  1,                  // osc_or_pll: use Osc (if 0) or PLL (if 1)
-                  1,                  // pll_osc: select Osc0/PLL0 or Osc1/PLL1
-                  0,                  // diven
-                  0);                 // div
-
-  // Enable USB GCLK.
-  pm_gc_enable(pm, AVR32_PM_GCLK_USBB);
-}
+/*This file has been prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Power Manager clocks configuration helper.
+ *
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ *****************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &lt;string.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;pm.h&quot;
+
+
+extern void flashc_set_wait_state(unsigned int wait_state);
+#if (defined AVR32_FLASHC_210_H_INCLUDED)
+extern void flashc_issue_command(unsigned int command, int page_number);
+#endif
+
+
+#define PM_MAX_MUL                ((1 &lt;&lt; AVR32_PM_PLL0_PLLMUL_SIZE) - 1)
+
+
+int pm_configure_clocks(pm_freq_param_t *param)
+{
+  // Supported frequencies:
+  // Fosc0 mul div PLL div2_en cpu_f pba_f   Comment
+  //  12   15   1  192     1     12    12
+  //  12    9   3   40     1     20    20    PLL out of spec
+  //  12   15   1  192     1     24    12
+  //  12    9   1  120     1     30    15
+  //  12    9   3   40     0     40    20    PLL out of spec
+  //  12   15   1  192     1     48    12
+  //  12   15   1  192     1     48    24
+  //  12    8   1  108     1     54    27
+  //  12    9   1  120     1     60    15
+  //  12    9   1  120     1     60    30
+  //  12   10   1  132     1     66    16.5
+  //
+  unsigned long in_cpu_f  = param-&gt;cpu_f;
+  unsigned long in_osc0_f = param-&gt;osc0_f;
+  unsigned long mul, div, div2_en = 0, div2_cpu = 0, div2_pba = 0;
+  unsigned long pll_freq, rest;
+  Bool b_div2_pba, b_div2_cpu;
+
+  // Switch to external Oscillator 0
+  pm_switch_to_osc0(&amp;AVR32_PM, in_osc0_f, param-&gt;osc0_startup);
+
+  // Start with CPU freq config
+  if (in_cpu_f == in_osc0_f)
+  {
+    param-&gt;cpu_f = in_osc0_f;
+    param-&gt;pba_f = in_osc0_f;
+    return PM_FREQ_STATUS_OK;
+  }
+  else if (in_cpu_f &lt; in_osc0_f)
+  {
+    // TBD
+  }
+
+  rest = in_cpu_f % in_osc0_f;
+
+  for (div = 1; div &lt; 32; div++)
+  {
+    if ((div * rest) % in_osc0_f == 0)
+      break;
+  }
+  if (div == 32)
+    return PM_FREQ_STATUS_FAIL;
+
+  mul = (in_cpu_f * div) / in_osc0_f;
+
+  if (mul &gt; PM_MAX_MUL)
+    return PM_FREQ_STATUS_FAIL;
+
+  // export 2power from PLL div to div2_cpu
+  while (!(div % 2))
+  {
+    div /= 2;
+    div2_cpu++;
+  }
+
+  // Here we know the mul and div parameter of the PLL config.
+  // . Check out if the PLL has a valid in_cpu_f.
+  // . Try to have for the PLL frequency (VCO output) the highest possible value
+  //   to reduce jitter.
+  while (in_osc0_f * 2 * mul / div &lt; AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
+  {
+    if (2 * mul &gt; PM_MAX_MUL)
+      break;
+    mul *= 2;
+    div2_cpu++;
+  }
+
+  if (div2_cpu != 0)
+  {
+    div2_cpu--;
+    div2_en = 1;
+  }
+
+  pll_freq = in_osc0_f * mul / (div * (1 &lt;&lt; div2_en));
+
+  // Update real CPU Frequency
+  param-&gt;cpu_f = pll_freq / (1 &lt;&lt; div2_cpu);
+  mul--;
+
+  pm_pll_setup(&amp;AVR32_PM
+  , 0   // pll
+  , mul // mul
+  , div // div
+  , 0   // osc
+  , 16  // lockcount
+  );
+
+  pm_pll_set_option(&amp;AVR32_PM
+  , 0 // pll
+  // PLL clock is lower than 160MHz: need to set pllopt.
+  , (pll_freq &lt; AVR32_PM_PLL_VCO_RANGE0_MIN_FREQ) ? 1 : 0 // pll_freq
+  , div2_en // pll_div2
+  , 0 // pll_wbwdisable
+  );
+
+  rest = pll_freq;
+  while (rest &gt; AVR32_PM_PBA_MAX_FREQ ||
+         rest != param-&gt;pba_f)
+  {
+    div2_pba++;
+    rest = pll_freq / (1 &lt;&lt; div2_pba);
+    if (rest &lt; param-&gt;pba_f)
+      break;
+  }
+
+  // Update real PBA Frequency
+  param-&gt;pba_f = pll_freq / (1 &lt;&lt; div2_pba);
+
+  // Enable PLL0
+  pm_pll_enable(&amp;AVR32_PM, 0);
+
+  // Wait for PLL0 locked
+  pm_wait_for_pll0_locked(&amp;AVR32_PM);
+
+  if (div2_cpu)
+  {
+    b_div2_cpu = TRUE;
+    div2_cpu--;
+  }
+  else
+    b_div2_cpu = FALSE;
+
+  if (div2_pba)
+  {
+    b_div2_pba = TRUE;
+    div2_pba--;
+  }
+  else
+    b_div2_pba = FALSE;
+
+  pm_cksel(&amp;AVR32_PM
+  , b_div2_pba, div2_pba // PBA
+  , b_div2_cpu, div2_cpu // PBB
+  , b_div2_cpu, div2_cpu // HSB
+  );
+
+  if (param-&gt;cpu_f &gt; AVR32_FLASHC_FWS_0_MAX_FREQ)
+  {
+    flashc_set_wait_state(1);
+#if (defined AVR32_FLASHC_210_H_INCLUDED)
+    if (param-&gt;cpu_f &gt; AVR32_FLASHC_HSEN_FWS_1_MAX_FREQ)
+      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSEN, -1);
+    else
+      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
+#endif
+  }
+  else
+  {
+    flashc_set_wait_state(0);
+#if (defined AVR32_FLASHC_210_H_INCLUDED)
+    if (param-&gt;cpu_f &gt; AVR32_FLASHC_HSEN_FWS_0_MAX_FREQ)
+      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSEN, -1);
+    else
+      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
+#endif
+  }
+
+  pm_switch_to_clock(&amp;AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
+
+  return PM_FREQ_STATUS_OK;
+}
+
+
+void pm_configure_usb_clock(void)
+{
+#if (defined __AVR32_UC3A3256__)  || (defined __AVR32_UC3A3128__)  || (defined __AVR32_UC3A364__)  || \
+    (defined __AVR32_UC3A3256S__) || (defined __AVR32_UC3A3128S__) || (defined __AVR32_UC3A364S__) || \
+    (defined __AT32UC3A3256__)  || (defined __AT32UC3A3128__)  || (defined __AT32UC3A364__) ||        \
+    (defined __AT32UC3A3256S__) || (defined __AT32UC3A3128S__) || (defined __AT32UC3A364S__)
+
+  // Setup USB GCLK.
+  pm_gc_setup(&amp;AVR32_PM, AVR32_PM_GCLK_USBB, // gc
+                  0,                  // osc_or_pll: use Osc (if 0) or PLL (if 1)
+                  0,                  // pll_osc: select Osc0/PLL0 or Osc1/PLL1
+                  0,                  // diven
+                  0);                 // div
+
+  // Enable USB GCLK.
+  pm_gc_enable(&amp;AVR32_PM, AVR32_PM_GCLK_USBB);
+#else
+  // Use 12MHz from OSC0 and generate 96 MHz
+  pm_pll_setup(&amp;AVR32_PM, 1,  // pll.
+	  7,   // mul.
+	  1,   // div.
+	  0,   // osc.
+	  16); // lockcount.
+
+  pm_pll_set_option(&amp;AVR32_PM, 1, // pll.
+	  1,  // pll_freq: choose the range 80-180MHz.
+	  1,  // pll_div2.
+	  0); // pll_wbwdisable.
+
+  // start PLL1 and wait forl lock
+  pm_pll_enable(&amp;AVR32_PM, 1);
+
+  // Wait for PLL1 locked.
+  pm_wait_for_pll1_locked(&amp;AVR32_PM);
+
+  pm_gc_setup(&amp;AVR32_PM, AVR32_PM_GCLK_USBB,  // gc.
+            1,  // osc_or_pll: use Osc (if 0) or PLL (if 1).
+            1,  // pll_osc: select Osc0/PLL0 or Osc1/PLL1.
+            0,  // diven.
+            0); // div.
+  pm_gc_enable(&amp;AVR32_PM, AVR32_PM_GCLK_USBB);
+#endif
+}

Modified: trunk/src/platform/avr32/preprocessor.h
===================================================================
--- trunk/src/platform/avr32/preprocessor.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/preprocessor.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,52 +1,55 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Preprocessor utils.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices can be used.
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _PREPROCESSOR_H_
-#define _PREPROCESSOR_H_
-
-#include &quot;tpaste.h&quot;
-#include &quot;stringz.h&quot;
-#include &quot;mrepeat.h&quot;
-
-
-#endif  // _PREPROCESSOR_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _PREPROCESSOR_H_
+#define _PREPROCESSOR_H_
+
+#include &quot;tpaste.h&quot;
+#include &quot;stringz.h&quot;
+#include &quot;mrepeat.h&quot;
+
+
+#endif  // _PREPROCESSOR_H_

Modified: trunk/src/platform/avr32/sdramc.c
===================================================================
--- trunk/src/platform/avr32/sdramc.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/sdramc.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,262 +1,319 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief SDRAMC on EBI driver for AVR32 UC3.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &quot;compiler.h&quot;
-#include &quot;preprocessor.h&quot;
-#include &quot;gpio.h&quot;
-#include &quot;sdramc.h&quot;
-
-
-/*! \brief Waits during at least the specified delay before returning.
- *
- * \param ck Number of HSB clock cycles to wait.
- */
-static void sdramc_ck_delay(unsigned long ck)
-{
-  // Use the CPU cycle counter (CPU and HSB clocks are the same).
-  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
-  unsigned long delay_end_cycle = delay_start_cycle + ck;
-
-  // To be safer, the end of wait is based on an inequality test, so CPU cycle
-  // counter wrap around is checked.
-  if (delay_start_cycle &lt;= delay_end_cycle)
-  {
-    while ((unsigned long)Get_system_register(AVR32_COUNT) &lt; delay_end_cycle);
-  }
-  else
-  {
-    while ((unsigned long)Get_system_register(AVR32_COUNT) &gt; delay_end_cycle);
-  }
-}
-
-
-/*! \brief Waits during at least the specified delay before returning.
- *
- * \param ns Number of nanoseconds to wait.
- * \param hsb_mhz_up Rounded-up HSB frequency in MHz.
- */
-#define sdramc_ns_delay(ns, hsb_mhz_up)   sdramc_ck_delay(((ns) * (hsb_mhz_up) + 999) / 1000)
-
-
-/*! \brief Waits during at least the specified delay before returning.
- *
- * \param us Number of microseconds to wait.
- * \param hsb_mhz_up Rounded-up HSB frequency in MHz.
- */
-#define sdramc_us_delay(us, hsb_mhz_up)   sdramc_ck_delay((us) * (hsb_mhz_up))
-
-
-/*! \brief Puts the multiplexed MCU pins used for the SDRAM under control of the
- *         SDRAMC.
- */
-#if BOARD == EVK1100
-static void sdramc_enable_muxed_pins(void)
-{
-  static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
-  {
-    // Enable data pins.
-#define SDRAMC_ENABLE_DATA_PIN(DATA_BIT, unused) \
-    {AVR32_EBI_DATA_##DATA_BIT##_PIN, AVR32_EBI_DATA_##DATA_BIT##_FUNCTION},
-    MREPEAT(SDRAM_DBW, SDRAMC_ENABLE_DATA_PIN, ~)
-#undef SDRAMC_ENABLE_DATA_PIN
-
-    // Enable row/column address pins.
-    {AVR32_EBI_ADDR_2_PIN,            AVR32_EBI_ADDR_2_FUNCTION           },
-    {AVR32_EBI_ADDR_3_PIN,            AVR32_EBI_ADDR_3_FUNCTION           },
-    {AVR32_EBI_ADDR_4_PIN,            AVR32_EBI_ADDR_4_FUNCTION           },
-    {AVR32_EBI_ADDR_5_PIN,            AVR32_EBI_ADDR_5_FUNCTION           },
-    {AVR32_EBI_ADDR_6_PIN,            AVR32_EBI_ADDR_6_FUNCTION           },
-    {AVR32_EBI_ADDR_7_PIN,            AVR32_EBI_ADDR_7_FUNCTION           },
-    {AVR32_EBI_ADDR_8_PIN,            AVR32_EBI_ADDR_8_FUNCTION           },
-    {AVR32_EBI_ADDR_9_PIN,            AVR32_EBI_ADDR_9_FUNCTION           },
-    {AVR32_EBI_ADDR_10_PIN,           AVR32_EBI_ADDR_10_FUNCTION          },
-    {AVR32_EBI_ADDR_11_PIN,           AVR32_EBI_ADDR_11_FUNCTION          },
-    {AVR32_EBI_SDA10_0_PIN,           AVR32_EBI_SDA10_0_FUNCTION          },
-#if SDRAM_ROW_BITS &gt;= 12
-    {AVR32_EBI_ADDR_13_PIN,           AVR32_EBI_ADDR_13_FUNCTION          },
-  #if SDRAM_ROW_BITS &gt;= 13
-    {AVR32_EBI_ADDR_14_PIN,           AVR32_EBI_ADDR_14_FUNCTION          },
-  #endif
-#endif
-
-    // Enable bank address pins.
-    {AVR32_EBI_ADDR_16_PIN,           AVR32_EBI_ADDR_16_FUNCTION          },
-#if SDRAM_BANK_BITS &gt;= 2
-    {AVR32_EBI_ADDR_17_PIN,           AVR32_EBI_ADDR_17_FUNCTION          },
-#endif
-
-    // Enable data mask pins.
-    {AVR32_EBI_ADDR_0_PIN,            AVR32_EBI_ADDR_0_FUNCTION           },
-    {AVR32_EBI_NWE1_0_PIN,            AVR32_EBI_NWE1_0_FUNCTION           },
-#if SDRAM_DBW &gt;= 32
-    {AVR32_EBI_NWE2_0_PIN,            AVR32_EBI_NWE2_0_FUNCTION           },
-    {AVR32_EBI_NWE3_0_PIN,            AVR32_EBI_NWE3_0_FUNCTION           },
-#endif
-
-    // Enable control pins.
-    {AVR32_EBI_SDWE_0_PIN,            AVR32_EBI_SDWE_0_FUNCTION           },
-    {AVR32_EBI_CAS_0_PIN,             AVR32_EBI_CAS_0_FUNCTION            },
-    {AVR32_EBI_RAS_0_PIN,             AVR32_EBI_RAS_0_FUNCTION            },
-    {AVR32_EBI_NCS_1_PIN,             AVR32_EBI_NCS_1_FUNCTION            },
-
-    // Enable clock-related pins.
-    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
-    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
-  };
-
-  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
-}
-#elif BOARD == STK1000
-static void sdramc_enable_muxed_pins(void)
-{
-  volatile avr32_hmatrix_t *hmatrix = &amp;AVR32_HMATRIX;
-
-  // Enable SDRAM mode for CS1 in the BAMBI mux 
-  hmatrix-&gt;sfr[4] |= 0x0002;
-  hmatrix-&gt;sfr[4] |= 0x0100;
-
-  static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
-  {
-    // Enable DATA 16 through 31 pins, which is muxed with LCD
-    {AVR32_EBI_DATA_16_PIN,           AVR32_EBI_DATA_16_FUNCTION          },
-    {AVR32_EBI_DATA_17_PIN,           AVR32_EBI_DATA_17_FUNCTION          },
-    {AVR32_EBI_DATA_18_PIN,           AVR32_EBI_DATA_18_FUNCTION          },
-    {AVR32_EBI_DATA_19_PIN,           AVR32_EBI_DATA_19_FUNCTION          },
-    {AVR32_EBI_DATA_20_PIN,           AVR32_EBI_DATA_20_FUNCTION          },
-    {AVR32_EBI_DATA_21_PIN,           AVR32_EBI_DATA_21_FUNCTION          },
-    {AVR32_EBI_DATA_22_PIN,           AVR32_EBI_DATA_22_FUNCTION          },
-    {AVR32_EBI_DATA_23_PIN,           AVR32_EBI_DATA_23_FUNCTION          },
-    {AVR32_EBI_DATA_24_PIN,           AVR32_EBI_DATA_24_FUNCTION          },
-    {AVR32_EBI_DATA_25_PIN,           AVR32_EBI_DATA_25_FUNCTION          },
-    {AVR32_EBI_DATA_26_PIN,           AVR32_EBI_DATA_26_FUNCTION          },
-    {AVR32_EBI_DATA_27_PIN,           AVR32_EBI_DATA_27_FUNCTION          },
-    {AVR32_EBI_DATA_28_PIN,           AVR32_EBI_DATA_28_FUNCTION          },
-    {AVR32_EBI_DATA_29_PIN,           AVR32_EBI_DATA_29_FUNCTION          },
-    {AVR32_EBI_DATA_30_PIN,           AVR32_EBI_DATA_30_FUNCTION          },
-    {AVR32_EBI_DATA_31_PIN,           AVR32_EBI_DATA_31_FUNCTION          }
-  };
-
-  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
-
-
-}
-
-#endif
-
-void sdramc_init(unsigned long hsb_hz)
-{
-  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
-  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
-  volatile ATPASTE2(U, SDRAM_DBW) *sdram = SDRAM;
-  unsigned int i;
-
-  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
-  sdramc_enable_muxed_pins();
-
-  // Enable SDRAM mode for CS1.
-  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 &lt;&lt; AVR32_EBI_SDRAM_CS;
-  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
-
-  // Configure the SDRAM Controller with SDRAM setup and timing information.
-  // All timings below are rounded up because they are minimal values.
-  AVR32_SDRAMC.cr =
-      ((( SDRAM_COL_BITS                 -    8) &lt;&lt; AVR32_SDRAMC_CR_NC_OFFSET  ) &amp; AVR32_SDRAMC_CR_NC_MASK  ) |
-      ((( SDRAM_ROW_BITS                 -   11) &lt;&lt; AVR32_SDRAMC_CR_NR_OFFSET  ) &amp; AVR32_SDRAMC_CR_NR_MASK  ) |
-      ((( SDRAM_BANK_BITS                -    1) &lt;&lt; AVR32_SDRAMC_CR_NB_OFFSET  ) &amp; AVR32_SDRAMC_CR_NB_MASK  ) |
-      ((  SDRAM_CAS                              &lt;&lt; AVR32_SDRAMC_CR_CAS_OFFSET ) &amp; AVR32_SDRAMC_CR_CAS_MASK ) |
-      ((( SDRAM_DBW                      &gt;&gt;   4) &lt;&lt; AVR32_SDRAMC_CR_DBW_OFFSET ) &amp; AVR32_SDRAMC_CR_DBW_MASK ) |
-      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TWR_OFFSET ) &amp; AVR32_SDRAMC_CR_TWR_MASK ) |
-      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRC_OFFSET ) &amp; AVR32_SDRAMC_CR_TRC_MASK ) |
-      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRP_OFFSET ) &amp; AVR32_SDRAMC_CR_TRP_MASK ) |
-      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRCD_OFFSET) &amp; AVR32_SDRAMC_CR_TRCD_MASK) |
-      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRAS_OFFSET) &amp; AVR32_SDRAMC_CR_TRAS_MASK) |
-      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TXSR_OFFSET) &amp; AVR32_SDRAMC_CR_TXSR_MASK);
-  AVR32_SDRAMC.cr;
-
-  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
-  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
-  AVR32_SDRAMC.mr;
-  sdram[0];
-
-  // Wait during the SDRAM stable-clock initialization delay.
-  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
-
-  // Issue a PRECHARGE ALL command to the SDRAM.
-  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
-  AVR32_SDRAMC.mr;
-  sdram[0];
-  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
-
-  // Issue initialization AUTO REFRESH commands to the SDRAM.
-  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
-  AVR32_SDRAMC.mr;
-  for (i = 0; i &lt; SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
-  {
-    sdram[0];
-    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
-  }
-
-  // Issue a LOAD MODE REGISTER command to the SDRAM.
-  // This configures the SDRAM with the following parameters in the mode register:
-  //  - bits 0 to 2: burst length: 1 (000b);
-  //  - bit 3: burst type: sequential (0b);
-  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
-  //  - bits 7 to 8: operating mode: standard operation (00b);
-  //  - bit 9: write burst mode: programmed burst length (0b);
-  //  - all other bits: reserved: 0b.
-  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
-  AVR32_SDRAMC.mr;
-  sdram[0];
-  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
-
-  // Switch the SDRAM Controller to normal mode.
-  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
-  AVR32_SDRAMC.mr;
-  sdram[0];
-
-  // Write the refresh period into the SDRAMC Refresh Timer Register.
-  // tR is rounded down because it is a maximal value.
-  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
-  AVR32_SDRAMC.tr;
-}
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief SDRAMC on EBI driver for AVR32 UC3.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &quot;compiler.h&quot;
+#include &quot;preprocessor.h&quot;
+#include &quot;gpio.h&quot;
+#include &quot;sdramc.h&quot;
+
+
+/*! \brief Waits during at least the specified delay before returning.
+ *
+ * \param ck Number of HSB clock cycles to wait.
+ */
+static void sdramc_ck_delay(unsigned long ck)
+{
+  // Use the CPU cycle counter (CPU and HSB clocks are the same).
+  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
+  unsigned long delay_end_cycle = delay_start_cycle + ck;
+
+  // To be safer, the end of wait is based on an inequality test, so CPU cycle
+  // counter wrap around is checked.
+  if (delay_start_cycle &gt; delay_end_cycle)
+  {
+    while ((unsigned long)Get_system_register(AVR32_COUNT) &gt; delay_end_cycle);
+  }
+  while ((unsigned long)Get_system_register(AVR32_COUNT) &lt; delay_end_cycle);
+}
+
+
+/*! \brief Waits during at least the specified delay before returning.
+ *
+ * \param ns Number of nanoseconds to wait.
+ * \param hsb_mhz_up Rounded-up HSB frequency in MHz.
+ */
+#define sdramc_ns_delay(ns, hsb_mhz_up)   sdramc_ck_delay(((ns) * (hsb_mhz_up) + 999) / 1000)
+
+
+/*! \brief Waits during at least the specified delay before returning.
+ *
+ * \param us Number of microseconds to wait.
+ * \param hsb_mhz_up Rounded-up HSB frequency in MHz.
+ */
+#define sdramc_us_delay(us, hsb_mhz_up)   sdramc_ck_delay((us) * (hsb_mhz_up))
+
+
+/*! \brief Puts the multiplexed MCU pins used for the SDRAM under control of the
+ *         SDRAMC.
+ */
+#if BOARD == EVK1100 || BOARD == EVK1104 || BOARD == EVK1105 
+static void sdramc_enable_muxed_pins(void)
+{
+  static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
+  {
+    // Enable data pins.
+#define SDRAMC_ENABLE_DATA_PIN(DATA_BIT, unused) \
+    {AVR32_EBI_DATA_##DATA_BIT##_PIN, AVR32_EBI_DATA_##DATA_BIT##_FUNCTION},
+    MREPEAT(SDRAM_DBW, SDRAMC_ENABLE_DATA_PIN, ~)
+#undef SDRAMC_ENABLE_DATA_PIN
+
+    // Enable row/column address pins.
+    {AVR32_EBI_ADDR_2_PIN,            AVR32_EBI_ADDR_2_FUNCTION           },
+    {AVR32_EBI_ADDR_3_PIN,            AVR32_EBI_ADDR_3_FUNCTION           },
+    {AVR32_EBI_ADDR_4_PIN,            AVR32_EBI_ADDR_4_FUNCTION           },
+    {AVR32_EBI_ADDR_5_PIN,            AVR32_EBI_ADDR_5_FUNCTION           },
+    {AVR32_EBI_ADDR_6_PIN,            AVR32_EBI_ADDR_6_FUNCTION           },
+    {AVR32_EBI_ADDR_7_PIN,            AVR32_EBI_ADDR_7_FUNCTION           },
+    {AVR32_EBI_ADDR_8_PIN,            AVR32_EBI_ADDR_8_FUNCTION           },
+    {AVR32_EBI_ADDR_9_PIN,            AVR32_EBI_ADDR_9_FUNCTION           },
+    {AVR32_EBI_ADDR_10_PIN,           AVR32_EBI_ADDR_10_FUNCTION          },
+    {AVR32_EBI_ADDR_11_PIN,           AVR32_EBI_ADDR_11_FUNCTION          },
+    {AVR32_EBI_SDA10_0_PIN,           AVR32_EBI_SDA10_0_FUNCTION          },
+#if SDRAM_ROW_BITS &gt;= 12
+    {AVR32_EBI_ADDR_13_PIN,           AVR32_EBI_ADDR_13_FUNCTION          },
+  #if SDRAM_ROW_BITS &gt;= 13
+    {AVR32_EBI_ADDR_14_PIN,           AVR32_EBI_ADDR_14_FUNCTION          },
+  #endif
+#endif
+
+    // Enable bank address pins.
+    {AVR32_EBI_ADDR_16_PIN,           AVR32_EBI_ADDR_16_FUNCTION          },
+#if SDRAM_BANK_BITS &gt;= 2
+    {AVR32_EBI_ADDR_17_PIN,           AVR32_EBI_ADDR_17_FUNCTION          },
+#endif
+
+    // Enable data mask pins.
+    {AVR32_EBI_ADDR_0_PIN,            AVR32_EBI_ADDR_0_FUNCTION           },
+    {AVR32_EBI_NWE1_0_PIN,            AVR32_EBI_NWE1_0_FUNCTION           },
+#if SDRAM_DBW &gt;= 32
+    {AVR32_EBI_ADDR_1_PIN,            AVR32_EBI_ADDR_1_FUNCTION           },
+    {AVR32_EBI_NWE3_0_PIN,            AVR32_EBI_NWE3_0_FUNCTION           },
+#endif
+
+    // Enable control pins.
+    {AVR32_EBI_SDWE_0_PIN,            AVR32_EBI_SDWE_0_FUNCTION           },
+    {AVR32_EBI_CAS_0_PIN,             AVR32_EBI_CAS_0_FUNCTION            },
+    {AVR32_EBI_RAS_0_PIN,             AVR32_EBI_RAS_0_FUNCTION            },
+    {AVR32_EBI_NCS_1_PIN,             AVR32_EBI_NCS_1_FUNCTION            },
+
+    // Enable clock-related pins.
+    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
+    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
+  };
+
+  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
+}
+#elif BOARD == UC3C_EK 
+static void sdramc_enable_muxed_pins(void)
+{
+  static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
+  {
+    // Enable data pins.
+#define SDRAMC_ENABLE_DATA_PIN(DATA_BIT, unused) \
+    {AVR32_EBI_DATA_##DATA_BIT##_PIN, AVR32_EBI_DATA_##DATA_BIT##_FUNCTION},
+    MREPEAT(SDRAM_DBW, SDRAMC_ENABLE_DATA_PIN, ~)
+#undef SDRAMC_ENABLE_DATA_PIN
+
+    // Enable row/column address pins.
+    {AVR32_EBI_ADDR_2_PIN,            AVR32_EBI_ADDR_2_FUNCTION           },
+    {AVR32_EBI_ADDR_3_PIN,            AVR32_EBI_ADDR_3_FUNCTION           },
+    {AVR32_EBI_ADDR_4_PIN,            AVR32_EBI_ADDR_4_FUNCTION           },
+    {AVR32_EBI_ADDR_5_PIN,            AVR32_EBI_ADDR_5_FUNCTION           },
+    {AVR32_EBI_ADDR_6_PIN,            AVR32_EBI_ADDR_6_FUNCTION           },
+    {AVR32_EBI_ADDR_7_PIN,            AVR32_EBI_ADDR_7_FUNCTION           },
+    {AVR32_EBI_ADDR_8_PIN,            AVR32_EBI_ADDR_8_FUNCTION           },
+    {AVR32_EBI_ADDR_9_PIN,            AVR32_EBI_ADDR_9_FUNCTION           },
+    {AVR32_EBI_ADDR_10_PIN,           AVR32_EBI_ADDR_10_FUNCTION          },
+    {AVR32_EBI_ADDR_11_PIN,           AVR32_EBI_ADDR_11_FUNCTION          },
+    {AVR32_EBI_SDA10_PIN,           AVR32_EBI_SDA10_FUNCTION          },
+#if SDRAM_ROW_BITS &gt;= 12
+    {AVR32_EBI_ADDR_13_PIN,           AVR32_EBI_ADDR_13_FUNCTION          },
+  #if SDRAM_ROW_BITS &gt;= 13
+    {AVR32_EBI_ADDR_14_PIN,           AVR32_EBI_ADDR_14_FUNCTION          },
+  #endif
+#endif
+
+    // Enable bank address pins.
+    {AVR32_EBI_ADDR_16_PIN,           AVR32_EBI_ADDR_16_FUNCTION          },
+#if SDRAM_BANK_BITS &gt;= 2
+    {AVR32_EBI_ADDR_17_PIN,           AVR32_EBI_ADDR_17_FUNCTION          },
+#endif
+
+    // Enable data mask pins.
+    {AVR32_EBI_ADDR_0_PIN,            AVR32_EBI_ADDR_0_FUNCTION           },
+    {AVR32_EBI_NWE1_PIN,            AVR32_EBI_NWE1_FUNCTION           },
+#if SDRAM_DBW &gt;= 32
+    {AVR32_EBI_ADDR_1_PIN,            AVR32_EBI_ADDR_1_FUNCTION           },
+    {AVR32_EBI_NWE3_PIN,            AVR32_EBI_NWE3_FUNCTION           },
+#endif
+
+    // Enable control pins.
+    {AVR32_EBI_SDWE_PIN,            AVR32_EBI_SDWE_FUNCTION           },
+    {AVR32_EBI_CAS_PIN,             AVR32_EBI_CAS_FUNCTION            },
+    {AVR32_EBI_RAS_PIN,             AVR32_EBI_RAS_FUNCTION            },
+    {AVR32_EBI_NCS_1_PIN,             AVR32_EBI_NCS_1_FUNCTION            },
+
+    // Enable clock-related pins.
+    {AVR32_EBI_SDCK_PIN,            AVR32_EBI_SDCK_FUNCTION           },
+    {AVR32_EBI_SDCKE_PIN,           AVR32_EBI_SDCKE_FUNCTION          }
+  };
+
+  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
+}
+#elif BOARD == STK1000
+static void sdramc_enable_muxed_pins(void)
+{
+  volatile avr32_hmatrix_t *hmatrix = &amp;AVR32_HMATRIX;
+
+  // Enable SDRAM mode for CS1 in the BAMBI mux
+  hmatrix-&gt;sfr[4] |= 0x0002;
+  hmatrix-&gt;sfr[4] |= 0x0100;
+
+  static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
+  {
+    // Enable DATA 16 through 31 pins, which is muxed with LCD
+    {AVR32_EBI_DATA_16_PIN,           AVR32_EBI_DATA_16_FUNCTION          },
+    {AVR32_EBI_DATA_17_PIN,           AVR32_EBI_DATA_17_FUNCTION          },
+    {AVR32_EBI_DATA_18_PIN,           AVR32_EBI_DATA_18_FUNCTION          },
+    {AVR32_EBI_DATA_19_PIN,           AVR32_EBI_DATA_19_FUNCTION          },
+    {AVR32_EBI_DATA_20_PIN,           AVR32_EBI_DATA_20_FUNCTION          },
+    {AVR32_EBI_DATA_21_PIN,           AVR32_EBI_DATA_21_FUNCTION          },
+    {AVR32_EBI_DATA_22_PIN,           AVR32_EBI_DATA_22_FUNCTION          },
+    {AVR32_EBI_DATA_23_PIN,           AVR32_EBI_DATA_23_FUNCTION          },
+    {AVR32_EBI_DATA_24_PIN,           AVR32_EBI_DATA_24_FUNCTION          },
+    {AVR32_EBI_DATA_25_PIN,           AVR32_EBI_DATA_25_FUNCTION          },
+    {AVR32_EBI_DATA_26_PIN,           AVR32_EBI_DATA_26_FUNCTION          },
+    {AVR32_EBI_DATA_27_PIN,           AVR32_EBI_DATA_27_FUNCTION          },
+    {AVR32_EBI_DATA_28_PIN,           AVR32_EBI_DATA_28_FUNCTION          },
+    {AVR32_EBI_DATA_29_PIN,           AVR32_EBI_DATA_29_FUNCTION          },
+    {AVR32_EBI_DATA_30_PIN,           AVR32_EBI_DATA_30_FUNCTION          },
+    {AVR32_EBI_DATA_31_PIN,           AVR32_EBI_DATA_31_FUNCTION          }
+  };
+
+  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
+
+
+}
+
+#endif
+
+void sdramc_init(unsigned long hsb_hz)
+{
+  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
+  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
+  volatile ATPASTE2(U, SDRAM_DBW) *sdram = SDRAM;
+  unsigned int i;
+
+  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
+  sdramc_enable_muxed_pins();
+
+  // Enable SDRAM mode for CS1.
+  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 &lt;&lt; AVR32_EBI_SDRAM_CS;
+  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
+
+  // Configure the SDRAM Controller with SDRAM setup and timing information.
+  // All timings below are rounded up because they are minimal values.
+  AVR32_SDRAMC.cr =
+      ((( SDRAM_COL_BITS                 -    8) &lt;&lt; AVR32_SDRAMC_CR_NC_OFFSET  ) &amp; AVR32_SDRAMC_CR_NC_MASK  ) |
+      ((( SDRAM_ROW_BITS                 -   11) &lt;&lt; AVR32_SDRAMC_CR_NR_OFFSET  ) &amp; AVR32_SDRAMC_CR_NR_MASK  ) |
+      ((( SDRAM_BANK_BITS                -    1) &lt;&lt; AVR32_SDRAMC_CR_NB_OFFSET  ) &amp; AVR32_SDRAMC_CR_NB_MASK  ) |
+      ((  SDRAM_CAS                              &lt;&lt; AVR32_SDRAMC_CR_CAS_OFFSET ) &amp; AVR32_SDRAMC_CR_CAS_MASK ) |
+      ((( SDRAM_DBW                      &gt;&gt;   4) &lt;&lt; AVR32_SDRAMC_CR_DBW_OFFSET ) &amp; AVR32_SDRAMC_CR_DBW_MASK ) |
+      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TWR_OFFSET ) &amp; AVR32_SDRAMC_CR_TWR_MASK ) |
+      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRC_OFFSET ) &amp; AVR32_SDRAMC_CR_TRC_MASK ) |
+      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRP_OFFSET ) &amp; AVR32_SDRAMC_CR_TRP_MASK ) |
+      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRCD_OFFSET) &amp; AVR32_SDRAMC_CR_TRCD_MASK) |
+      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRAS_OFFSET) &amp; AVR32_SDRAMC_CR_TRAS_MASK) |
+      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TXSR_OFFSET) &amp; AVR32_SDRAMC_CR_TXSR_MASK);
+  AVR32_SDRAMC.cr;
+
+  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+
+  // Wait during the SDRAM stable-clock initialization delay.
+  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
+
+  // Issue a PRECHARGE ALL command to the SDRAM.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
+
+  // Issue initialization AUTO REFRESH commands to the SDRAM.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
+  AVR32_SDRAMC.mr;
+  for (i = 0; i &lt; SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
+  {
+    sdram[0];
+    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
+  }
+
+  // Issue a LOAD MODE REGISTER command to the SDRAM.
+  // This configures the SDRAM with the following parameters in the mode register:
+  //  - bits 0 to 2: burst length: 1 (000b);
+  //  - bit 3: burst type: sequential (0b);
+  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
+  //  - bits 7 to 8: operating mode: standard operation (00b);
+  //  - bit 9: write burst mode: programmed burst length (0b);
+  //  - all other bits: reserved: 0b.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
+
+  // Switch the SDRAM Controller to normal mode.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+
+  // Write the refresh period into the SDRAMC Refresh Timer Register.
+  // tR is rounded down because it is a maximal value.
+  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
+  AVR32_SDRAMC.tr;
+}

Modified: trunk/src/platform/avr32/sdramc.h
===================================================================
--- trunk/src/platform/avr32/sdramc.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/sdramc.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,84 +1,90 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief SDRAMC on EBI driver for AVR32 UC3.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _SDRAMC_H_
-#define _SDRAMC_H_
-
-#include &lt;avr32/io.h&gt;
-#include &quot;board.h&quot;
-
-#ifdef SDRAM_PART_HDR
-  #include SDRAM_PART_HDR
-#else
-  #error No SDRAM header file defined
-#endif
-
-
-//! Pointer to SDRAM.
-#define SDRAM           ((void *)AVR32_EBI_CS1_ADDRESS)
-
-//! SDRAM size.
-#define SDRAM_SIZE      (1 &lt;&lt; (SDRAM_BANK_BITS + \
-                               SDRAM_ROW_BITS  + \
-                               SDRAM_COL_BITS  + \
-                               (SDRAM_DBW &gt;&gt; 4)))
-
-
-/*! \brief Initializes the AVR32 SDRAM Controller and the connected SDRAM(s).
- *
- * \param hsb_hz HSB frequency in Hz (the HSB frequency is applied to the SDRAMC
- *               and to the SDRAM).
- *
- * \note HMATRIX and SDRAMC registers are always read with a dummy load
- *       operation after having been written to, in order to force write-back
- *       before executing the following accesses, which depend on the values set
- *       in these registers.
- *
- * \note Each access to the SDRAM address space validates the mode of the SDRAMC
- *       and generates an operation corresponding to this mode.
- */
-extern void sdramc_init(unsigned long hsb_hz);
-
-
-#endif  // _SDRAMC_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief SDRAMC on EBI driver for AVR32 UC3.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _SDRAMC_H_
+#define _SDRAMC_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;board.h&quot;
+
+#ifdef SDRAM_PART_HDR
+  #include SDRAM_PART_HDR
+#else
+  #error No SDRAM header file defined
+#endif
+
+//! Pointer to SDRAM.
+#if BOARD == UC3C_EK
+#define SDRAM           ((void *)AVR32_EBI_CS1_0_ADDRESS)
+#else
+#define SDRAM           ((void *)AVR32_EBI_CS1_ADDRESS)
+#endif
+
+//! SDRAM size.
+#define SDRAM_SIZE      (1 &lt;&lt; (SDRAM_BANK_BITS + \
+                               SDRAM_ROW_BITS  + \
+                               SDRAM_COL_BITS  + \
+                               (SDRAM_DBW &gt;&gt; 4)))
+
+
+/*! \brief Initializes the AVR32 SDRAM Controller and the connected SDRAM(s).
+ *
+ * \param hsb_hz HSB frequency in Hz (the HSB frequency is applied to the SDRAMC
+ *               and to the SDRAM).
+ *
+ * \note HMATRIX and SDRAMC registers are always read with a dummy load
+ *       operation after having been written to, in order to force write-back
+ *       before executing the following accesses, which depend on the values set
+ *       in these registers.
+ *
+ * \note Each access to the SDRAM address space validates the mode of the SDRAMC
+ *       and generates an operation corresponding to this mode.
+ */
+extern void sdramc_init(unsigned long hsb_hz);
+
+
+#endif  // _SDRAMC_H_

Modified: trunk/src/platform/avr32/stringz.h
===================================================================
--- trunk/src/platform/avr32/stringz.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/stringz.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,72 +1,75 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Preprocessor stringizing utils.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices can be used.
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _STRINGZ_H_
-#define _STRINGZ_H_
-
-
-/*! \brief Stringize.
- *
- * Stringize a preprocessing token, this token being allowed to be \#defined.
- *
- * May be used only within macros with the token passed as an argument if the token is \#defined.
- *
- * For example, writing STRINGZ(PIN) within a macro \#defined by PIN_NAME(PIN)
- * and invoked as PIN_NAME(PIN0) with PIN0 \#defined as A0 is equivalent to
- * writing &quot;A0&quot;.
- */
-#define STRINGZ(x)                                #x
-
-/*! \brief Absolute stringize.
- *
- * Stringize a preprocessing token, this token being allowed to be \#defined.
- *
- * No restriction of use if the token is \#defined.
- *
- * For example, writing ASTRINGZ(PIN0) anywhere with PIN0 \#defined as A0 is
- * equivalent to writing &quot;A0&quot;.
- */
-#define ASTRINGZ(x)                               STRINGZ(x)
-
-
-#endif  // _STRINGZ_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor stringizing utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _STRINGZ_H_
+#define _STRINGZ_H_
+
+
+/*! \brief Stringize.
+ *
+ * Stringize a preprocessing token, this token being allowed to be \#defined.
+ *
+ * May be used only within macros with the token passed as an argument if the token is \#defined.
+ *
+ * For example, writing STRINGZ(PIN) within a macro \#defined by PIN_NAME(PIN)
+ * and invoked as PIN_NAME(PIN0) with PIN0 \#defined as A0 is equivalent to
+ * writing &quot;A0&quot;.
+ */
+#define STRINGZ(x)                                #x
+
+/*! \brief Absolute stringize.
+ *
+ * Stringize a preprocessing token, this token being allowed to be \#defined.
+ *
+ * No restriction of use if the token is \#defined.
+ *
+ * For example, writing ASTRINGZ(PIN0) anywhere with PIN0 \#defined as A0 is
+ * equivalent to writing &quot;A0&quot;.
+ */
+#define ASTRINGZ(x)                               STRINGZ(x)
+
+
+#endif  // _STRINGZ_H_

Modified: trunk/src/platform/avr32/tc.c
===================================================================
--- trunk/src/platform/avr32/tc.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/tc.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,299 +1,314 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief TC driver for AVR32 UC3.
- *
- * AVR32 Timer/Counter driver module.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a TC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &lt;avr32/io.h&gt;
-#include &quot;compiler.h&quot;
-#include &quot;tc.h&quot;
-
-
-int tc_get_interrupt_settings(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  return tc-&gt;channel[channel].imr;
-}
-
-
-int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
-{
-  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
-
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // Enable the appropriate interrupts.
-  tc-&gt;channel[channel].ier = bitfield-&gt;etrgs &lt;&lt; AVR32_TC_ETRGS_OFFSET |
-                             bitfield-&gt;ldrbs &lt;&lt; AVR32_TC_LDRBS_OFFSET |
-                             bitfield-&gt;ldras &lt;&lt; AVR32_TC_LDRAS_OFFSET |
-                             bitfield-&gt;cpcs &lt;&lt; AVR32_TC_CPCS_OFFSET |
-                             bitfield-&gt;cpbs &lt;&lt; AVR32_TC_CPBS_OFFSET |
-                             bitfield-&gt;cpas &lt;&lt; AVR32_TC_CPAS_OFFSET |
-                             bitfield-&gt;lovrs &lt;&lt; AVR32_TC_LOVRS_OFFSET |
-                             bitfield-&gt;covfs &lt;&lt; AVR32_TC_COVFS_OFFSET;
-
-  // Disable the appropriate interrupts.
-  if (global_interrupt_enabled) Disable_global_interrupt();
-  tc-&gt;channel[channel].idr = (~bitfield-&gt;etrgs &amp; 1) &lt;&lt; AVR32_TC_ETRGS_OFFSET |
-                             (~bitfield-&gt;ldrbs &amp; 1) &lt;&lt; AVR32_TC_LDRBS_OFFSET |
-                             (~bitfield-&gt;ldras &amp; 1) &lt;&lt; AVR32_TC_LDRAS_OFFSET |
-                             (~bitfield-&gt;cpcs &amp; 1) &lt;&lt; AVR32_TC_CPCS_OFFSET |
-                             (~bitfield-&gt;cpbs &amp; 1) &lt;&lt; AVR32_TC_CPBS_OFFSET |
-                             (~bitfield-&gt;cpas &amp; 1) &lt;&lt; AVR32_TC_CPAS_OFFSET |
-                             (~bitfield-&gt;lovrs &amp; 1) &lt;&lt; AVR32_TC_LOVRS_OFFSET |
-                             (~bitfield-&gt;covfs &amp; 1) &lt;&lt; AVR32_TC_COVFS_OFFSET;
-  tc-&gt;channel[channel].sr;
-  if (global_interrupt_enabled) Enable_global_interrupt();
-
-  return 0;
-}
-
-
-int tc_select_external_clock(volatile avr32_tc_t *tc, unsigned int channel, unsigned int ext_clk_sig_src)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS || ext_clk_sig_src &gt;= 1 &lt;&lt; AVR32_TC_BMR_TC0XC0S_SIZE)
-    return TC_INVALID_ARGUMENT;
-
-  // Clear bit-field and set the correct behavior.
-  tc-&gt;bmr = (tc-&gt;bmr &amp; ~(AVR32_TC_BMR_TC0XC0S_MASK &lt;&lt; (channel * AVR32_TC_BMR_TC0XC0S_SIZE))) |
-            (ext_clk_sig_src &lt;&lt; (channel * AVR32_TC_BMR_TC0XC0S_SIZE));
-
-  return 0;
-}
-
-
-int tc_init_capture(volatile avr32_tc_t *tc, const tc_capture_opt_t *opt)
-{
-  // Check for valid input.
-  if (opt-&gt;channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // MEASURE SIGNALS: Capture operating mode.
-  tc-&gt;channel[opt-&gt;channel].cmr = opt-&gt;ldrb &lt;&lt; AVR32_TC_LDRB_OFFSET |
-                                  opt-&gt;ldra &lt;&lt; AVR32_TC_LDRA_OFFSET |
-                                  0 &lt;&lt; AVR32_TC_WAVE_OFFSET |
-                                  opt-&gt;cpctrg &lt;&lt; AVR32_TC_CPCTRG_OFFSET |
-                                  opt-&gt;abetrg &lt;&lt; AVR32_TC_ABETRG_OFFSET |
-                                  opt-&gt;etrgedg &lt;&lt; AVR32_TC_ETRGEDG_OFFSET|
-                                  opt-&gt;ldbdis &lt;&lt; AVR32_TC_LDBDIS_OFFSET |
-                                  opt-&gt;ldbstop &lt;&lt; AVR32_TC_LDBSTOP_OFFSET |
-                                  opt-&gt;burst &lt;&lt; AVR32_TC_BURST_OFFSET |
-                                  opt-&gt;clki &lt;&lt; AVR32_TC_CLKI_OFFSET |
-                                  opt-&gt;tcclks &lt;&lt; AVR32_TC_TCCLKS_OFFSET;
-
-  return 0;
-}
-
-
-int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
-{
-  // Check for valid input.
-  if (opt-&gt;channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // GENERATE SIGNALS: Waveform operating mode.
-  tc-&gt;channel[opt-&gt;channel].cmr = opt-&gt;bswtrg &lt;&lt; AVR32_TC_BSWTRG_OFFSET |
-                                  opt-&gt;beevt &lt;&lt; AVR32_TC_BEEVT_OFFSET |
-                                  opt-&gt;bcpc &lt;&lt; AVR32_TC_BCPC_OFFSET |
-                                  opt-&gt;bcpb &lt;&lt; AVR32_TC_BCPB_OFFSET |
-                                  opt-&gt;aswtrg &lt;&lt; AVR32_TC_ASWTRG_OFFSET |
-                                  opt-&gt;aeevt &lt;&lt; AVR32_TC_AEEVT_OFFSET |
-                                  opt-&gt;acpc &lt;&lt; AVR32_TC_ACPC_OFFSET |
-                                  opt-&gt;acpa &lt;&lt; AVR32_TC_ACPA_OFFSET |
-                                  1 &lt;&lt; AVR32_TC_WAVE_OFFSET |
-                                  opt-&gt;wavsel &lt;&lt; AVR32_TC_WAVSEL_OFFSET |
-                                  opt-&gt;enetrg &lt;&lt; AVR32_TC_ENETRG_OFFSET |
-                                  opt-&gt;eevt &lt;&lt; AVR32_TC_EEVT_OFFSET |
-                                  opt-&gt;eevtedg &lt;&lt; AVR32_TC_EEVTEDG_OFFSET |
-                                  opt-&gt;cpcdis &lt;&lt; AVR32_TC_CPCDIS_OFFSET |
-                                  opt-&gt;cpcstop &lt;&lt; AVR32_TC_CPCSTOP_OFFSET |
-                                  opt-&gt;burst &lt;&lt; AVR32_TC_BURST_OFFSET |
-                                  opt-&gt;clki &lt;&lt; AVR32_TC_CLKI_OFFSET |
-                                  opt-&gt;tcclks &lt;&lt; AVR32_TC_TCCLKS_OFFSET;
-
-  return 0;
-}
-
-
-int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // Enable, reset and start the selected timer/counter channel.
-  tc-&gt;channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
-
-  return 0;
-}
-
-
-int tc_stop(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // Disable the selected timer/counter channel.
-  tc-&gt;channel[channel].ccr = AVR32_TC_CLKDIS_MASK;
-
-  return 0;
-}
-
-
-int tc_software_trigger(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // Reset the selected timer/counter channel.
-  tc-&gt;channel[channel].ccr = AVR32_TC_SWTRG_MASK;
-
-  return 0;
-}
-
-
-void tc_sync_trigger(volatile avr32_tc_t *tc)
-{
-  // Reset all channels of the selected timer/counter.
-  tc-&gt;bcr = AVR32_TC_BCR_SYNC_MASK;
-}
-
-
-int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  return tc-&gt;channel[channel].sr;
-}
-
-
-int tc_read_tc(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  return Rd_bitfield(tc-&gt;channel[channel].cv, AVR32_TC_CV_MASK);
-}
-
-
-int tc_read_ra(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  return Rd_bitfield(tc-&gt;channel[channel].ra, AVR32_TC_RA_MASK);
-}
-
-
-int tc_read_rb(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  return Rd_bitfield(tc-&gt;channel[channel].rb, AVR32_TC_RB_MASK);
-}
-
-
-int tc_read_rc(volatile avr32_tc_t *tc, unsigned int channel)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  return Rd_bitfield(tc-&gt;channel[channel].rc, AVR32_TC_RC_MASK);
-}
-
-
-int tc_write_ra(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // This function is only available in WAVEFORM mode.
-  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
-    Wr_bitfield(tc-&gt;channel[channel].ra, AVR32_TC_RA_MASK, value);
-
-  return value;
-}
-
-
-int tc_write_rb(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // This function is only available in WAVEFORM mode.
-  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
-    Wr_bitfield(tc-&gt;channel[channel].rb, AVR32_TC_RB_MASK, value);
-
-  return value;
-}
-
-
-int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
-{
-  // Check for valid input.
-  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
-    return TC_INVALID_ARGUMENT;
-
-  // This function is only available in WAVEFORM mode.
-  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
-    Wr_bitfield(tc-&gt;channel[channel].rc, AVR32_TC_RC_MASK, value);
-
-  return value;
-}
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief TC driver for AVR32 UC3.
+ *
+ * AVR32 Timer/Counter driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a TC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+#include &quot;tc.h&quot;
+
+
+int tc_get_interrupt_settings(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return tc-&gt;channel[channel].imr;
+}
+
+
+int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
+{
+  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
+
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Enable the appropriate interrupts.
+  tc-&gt;channel[channel].ier = bitfield-&gt;etrgs &lt;&lt; AVR32_TC_ETRGS_OFFSET |
+                             bitfield-&gt;ldrbs &lt;&lt; AVR32_TC_LDRBS_OFFSET |
+                             bitfield-&gt;ldras &lt;&lt; AVR32_TC_LDRAS_OFFSET |
+                             bitfield-&gt;cpcs &lt;&lt; AVR32_TC_CPCS_OFFSET |
+                             bitfield-&gt;cpbs &lt;&lt; AVR32_TC_CPBS_OFFSET |
+                             bitfield-&gt;cpas &lt;&lt; AVR32_TC_CPAS_OFFSET |
+                             bitfield-&gt;lovrs &lt;&lt; AVR32_TC_LOVRS_OFFSET |
+                             bitfield-&gt;covfs &lt;&lt; AVR32_TC_COVFS_OFFSET;
+
+  // Disable the appropriate interrupts.
+  if (global_interrupt_enabled) Disable_global_interrupt();
+  tc-&gt;channel[channel].idr = (~bitfield-&gt;etrgs &amp; 1) &lt;&lt; AVR32_TC_ETRGS_OFFSET |
+                             (~bitfield-&gt;ldrbs &amp; 1) &lt;&lt; AVR32_TC_LDRBS_OFFSET |
+                             (~bitfield-&gt;ldras &amp; 1) &lt;&lt; AVR32_TC_LDRAS_OFFSET |
+                             (~bitfield-&gt;cpcs &amp; 1) &lt;&lt; AVR32_TC_CPCS_OFFSET |
+                             (~bitfield-&gt;cpbs &amp; 1) &lt;&lt; AVR32_TC_CPBS_OFFSET |
+                             (~bitfield-&gt;cpas &amp; 1) &lt;&lt; AVR32_TC_CPAS_OFFSET |
+                             (~bitfield-&gt;lovrs &amp; 1) &lt;&lt; AVR32_TC_LOVRS_OFFSET |
+                             (~bitfield-&gt;covfs &amp; 1) &lt;&lt; AVR32_TC_COVFS_OFFSET;
+  tc-&gt;channel[channel].sr;
+  if (global_interrupt_enabled) Enable_global_interrupt();
+
+  return 0;
+}
+
+
+int tc_select_external_clock(volatile avr32_tc_t *tc, unsigned int channel, unsigned int ext_clk_sig_src)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS || ext_clk_sig_src &gt;= 1 &lt;&lt; AVR32_TC_BMR_TC0XC0S_SIZE)
+    return TC_INVALID_ARGUMENT;
+
+  // Clear bit-field and set the correct behavior.
+  tc-&gt;bmr = (tc-&gt;bmr &amp; ~(AVR32_TC_BMR_TC0XC0S_MASK &lt;&lt; (channel * AVR32_TC_BMR_TC0XC0S_SIZE))) |
+            (ext_clk_sig_src &lt;&lt; (channel * AVR32_TC_BMR_TC0XC0S_SIZE));
+
+  return 0;
+}
+
+
+int tc_init_capture(volatile avr32_tc_t *tc, const tc_capture_opt_t *opt)
+{
+  // Check for valid input.
+  if (opt-&gt;channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // MEASURE SIGNALS: Capture operating mode.
+  tc-&gt;channel[opt-&gt;channel].cmr = opt-&gt;ldrb &lt;&lt; AVR32_TC_LDRB_OFFSET |
+                                  opt-&gt;ldra &lt;&lt; AVR32_TC_LDRA_OFFSET |
+                                  0 &lt;&lt; AVR32_TC_WAVE_OFFSET |
+                                  opt-&gt;cpctrg &lt;&lt; AVR32_TC_CPCTRG_OFFSET |
+                                  opt-&gt;abetrg &lt;&lt; AVR32_TC_ABETRG_OFFSET |
+                                  opt-&gt;etrgedg &lt;&lt; AVR32_TC_ETRGEDG_OFFSET|
+                                  opt-&gt;ldbdis &lt;&lt; AVR32_TC_LDBDIS_OFFSET |
+                                  opt-&gt;ldbstop &lt;&lt; AVR32_TC_LDBSTOP_OFFSET |
+                                  opt-&gt;burst &lt;&lt; AVR32_TC_BURST_OFFSET |
+                                  opt-&gt;clki &lt;&lt; AVR32_TC_CLKI_OFFSET |
+                                  opt-&gt;tcclks &lt;&lt; AVR32_TC_TCCLKS_OFFSET;
+
+  return 0;
+}
+
+
+int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
+{
+  // Check for valid input.
+  if (opt-&gt;channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // GENERATE SIGNALS: Waveform operating mode.
+  tc-&gt;channel[opt-&gt;channel].cmr = opt-&gt;bswtrg &lt;&lt; AVR32_TC_BSWTRG_OFFSET |
+                                  opt-&gt;beevt &lt;&lt; AVR32_TC_BEEVT_OFFSET |
+                                  opt-&gt;bcpc &lt;&lt; AVR32_TC_BCPC_OFFSET |
+                                  opt-&gt;bcpb &lt;&lt; AVR32_TC_BCPB_OFFSET |
+                                  opt-&gt;aswtrg &lt;&lt; AVR32_TC_ASWTRG_OFFSET |
+                                  opt-&gt;aeevt &lt;&lt; AVR32_TC_AEEVT_OFFSET |
+                                  opt-&gt;acpc &lt;&lt; AVR32_TC_ACPC_OFFSET |
+                                  opt-&gt;acpa &lt;&lt; AVR32_TC_ACPA_OFFSET |
+                                  1 &lt;&lt; AVR32_TC_WAVE_OFFSET |
+                                  opt-&gt;wavsel &lt;&lt; AVR32_TC_WAVSEL_OFFSET |
+                                  opt-&gt;enetrg &lt;&lt; AVR32_TC_ENETRG_OFFSET |
+                                  opt-&gt;eevt &lt;&lt; AVR32_TC_EEVT_OFFSET |
+                                  opt-&gt;eevtedg &lt;&lt; AVR32_TC_EEVTEDG_OFFSET |
+                                  opt-&gt;cpcdis &lt;&lt; AVR32_TC_CPCDIS_OFFSET |
+                                  opt-&gt;cpcstop &lt;&lt; AVR32_TC_CPCSTOP_OFFSET |
+                                  opt-&gt;burst &lt;&lt; AVR32_TC_BURST_OFFSET |
+                                  opt-&gt;clki &lt;&lt; AVR32_TC_CLKI_OFFSET |
+                                  opt-&gt;tcclks &lt;&lt; AVR32_TC_TCCLKS_OFFSET;
+
+  return 0;
+}
+
+
+int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Enable, reset and start the selected timer/counter channel.
+  tc-&gt;channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
+
+  return 0;
+}
+
+
+int tc_stop(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Disable the selected timer/counter channel.
+  tc-&gt;channel[channel].ccr = AVR32_TC_CLKDIS_MASK;
+
+  return 0;
+}
+
+
+int tc_software_trigger(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // Reset the selected timer/counter channel.
+  tc-&gt;channel[channel].ccr = AVR32_TC_SWTRG_MASK;
+
+  return 0;
+}
+
+
+void tc_sync_trigger(volatile avr32_tc_t *tc)
+{
+  // Reset all channels of the selected timer/counter.
+  tc-&gt;bcr = AVR32_TC_BCR_SYNC_MASK;
+}
+
+
+void tc_sync_start(volatile avr32_tc_t *tc)
+{
+  unsigned int i;
+  // Enable the clock for each channel.
+  for(i=0; i&lt;TC_NUMBER_OF_CHANNELS;i++)
+    tc-&gt;channel[i].ccr = AVR32_TC_CLKEN_MASK;
+    
+  // Reset all channels of the selected timer/counter.
+  tc-&gt;bcr = AVR32_TC_BCR_SYNC_MASK;
+}
+
+
+int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return tc-&gt;channel[channel].sr;
+}
+
+
+int tc_read_tc(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].cv, AVR32_TC_CV_MASK);
+}
+
+
+int tc_read_ra(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].ra, AVR32_TC_RA_MASK);
+}
+
+
+int tc_read_rb(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].rb, AVR32_TC_RB_MASK);
+}
+
+
+int tc_read_rc(volatile avr32_tc_t *tc, unsigned int channel)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  return Rd_bitfield(tc-&gt;channel[channel].rc, AVR32_TC_RC_MASK);
+}
+
+
+int tc_write_ra(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // This function is only available in WAVEFORM mode.
+  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
+    Wr_bitfield(tc-&gt;channel[channel].ra, AVR32_TC_RA_MASK, value);
+
+  return value;
+}
+
+
+int tc_write_rb(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // This function is only available in WAVEFORM mode.
+  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
+    Wr_bitfield(tc-&gt;channel[channel].rb, AVR32_TC_RB_MASK, value);
+
+  return value;
+}
+
+
+int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
+{
+  // Check for valid input.
+  if (channel &gt;= TC_NUMBER_OF_CHANNELS)
+    return TC_INVALID_ARGUMENT;
+
+  // This function is only available in WAVEFORM mode.
+  if (Tst_bits(tc-&gt;channel[channel].cmr, AVR32_TC_WAVE_MASK))
+    Wr_bitfield(tc-&gt;channel[channel].rc, AVR32_TC_RC_MASK, value);
+
+  return value;
+}

Modified: trunk/src/platform/avr32/tc.h
===================================================================
--- trunk/src/platform/avr32/tc.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/tc.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,582 +1,591 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Timer/Counter driver for AVR32 UC3.
- *
- * AVR32 Timer/Counter driver module.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a TC module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _TC_H_
-#define _TC_H_
-
-#include &lt;avr32/io.h&gt;
-
-
-//! TC driver functions return value in case of invalid argument(s).
-#define TC_INVALID_ARGUMENT                     (-1)
-
-//! Number of timer/counter channels.
-#define TC_NUMBER_OF_CHANNELS                   (sizeof(((avr32_tc_t *)0)-&gt;channel) / sizeof(avr32_tc_channel_t))
-
-/*! \name External Clock Signal 0 Selection
- */
-//! @{
-#define TC_CH0_EXT_CLK0_SRC_TCLK0               AVR32_TC_TC0XC0S_TCLK0
-#define TC_CH0_EXT_CLK0_SRC_NO_CLK              AVR32_TC_TC0XC0S_NO_CLK
-#define TC_CH0_EXT_CLK0_SRC_TIOA1               AVR32_TC_TC0XC0S_TIOA1
-#define TC_CH0_EXT_CLK0_SRC_TIOA2               AVR32_TC_TC0XC0S_TIOA2
-//! @}
-
-/*! \name External Clock Signal 1 Selection
- */
-//! @{
-#define TC_CH1_EXT_CLK1_SRC_TCLK1               AVR32_TC_TC1XC1S_TCLK1
-#define TC_CH1_EXT_CLK1_SRC_NO_CLK              AVR32_TC_TC1XC1S_NO_CLK
-#define TC_CH1_EXT_CLK1_SRC_TIOA0               AVR32_TC_TC1XC1S_TIOA0
-#define TC_CH1_EXT_CLK1_SRC_TIOA2               AVR32_TC_TC1XC1S_TIOA2
-//! @}
-
-/*! \name External Clock Signal 2 Selection
- */
-//! @{
-#define TC_CH2_EXT_CLK2_SRC_TCLK2               AVR32_TC_TC2XC2S_TCLK2
-#define TC_CH2_EXT_CLK2_SRC_NO_CLK              AVR32_TC_TC2XC2S_NO_CLK
-#define TC_CH2_EXT_CLK2_SRC_TIOA0               AVR32_TC_TC2XC2S_TIOA0
-#define TC_CH2_EXT_CLK2_SRC_TIOA1               AVR32_TC_TC2XC2S_TIOA1
-//! @}
-
-/*! \name Event/Trigger Actions on Output
- */
-//! @{
-#define TC_EVT_EFFECT_NOOP                      AVR32_TC_NONE
-#define TC_EVT_EFFECT_SET                       AVR32_TC_SET
-#define TC_EVT_EFFECT_CLEAR                     AVR32_TC_CLEAR
-#define TC_EVT_EFFECT_TOGGLE                    AVR32_TC_TOGGLE
-//! @}
-
-/*! \name RC Compare Trigger Enable
- */
-//! @{
-#define TC_NO_TRIGGER_COMPARE_RC                0
-#define TC_TRIGGER_COMPARE_RC                   1
-//! @}
-
-/*! \name Waveform Selection
- */
-//! @{
-#define TC_WAVEFORM_SEL_UP_MODE                 AVR32_TC_WAVSEL_UP_NO_AUTO
-#define TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER      AVR32_TC_WAVSEL_UP_AUTO
-#define TC_WAVEFORM_SEL_UPDOWN_MODE             AVR32_TC_WAVSEL_UPDOWN_NO_AUTO
-#define TC_WAVEFORM_SEL_UPDOWN_MODE_RC_TRIGGER  AVR32_TC_WAVSEL_UPDOWN_AUTO
-//! @}
-
-/*! \name TIOA or TIOB External Trigger Selection
- */
-//! @{
-#define TC_EXT_TRIG_SEL_TIOA                    1
-#define TC_EXT_TRIG_SEL_TIOB                    0
-//! @}
-
-/*! \name External Event Selection
- */
-//! @{
-#define TC_EXT_EVENT_SEL_TIOB_INPUT             AVR32_TC_EEVT_TIOB_INPUT
-#define TC_EXT_EVENT_SEL_XC0_OUTPUT             AVR32_TC_EEVT_XC0_OUTPUT
-#define TC_EXT_EVENT_SEL_XC1_OUTPUT             AVR32_TC_EEVT_XC1_OUTPUT
-#define TC_EXT_EVENT_SEL_XC2_OUTPUT             AVR32_TC_EEVT_XC2_OUTPUT
-//! @}
-
-/*! \name Edge Selection
- */
-//! @{
-#define TC_SEL_NO_EDGE                          AVR32_TC_EEVTEDG_NO_EDGE
-#define TC_SEL_RISING_EDGE                      AVR32_TC_EEVTEDG_POS_EDGE
-#define TC_SEL_FALLING_EDGE                     AVR32_TC_EEVTEDG_NEG_EDGE
-#define TC_SEL_EACH_EDGE                        AVR32_TC_EEVTEDG_BOTH_EDGES
-//! @}
-
-/*! \name Burst Signal Selection
- */
-//! @{
-#define TC_BURST_NOT_GATED                      AVR32_TC_BURST_NOT_GATED
-#define TC_BURST_CLK_AND_XC0                    AVR32_TC_BURST_CLK_AND_XC0
-#define TC_BURST_CLK_AND_XC1                    AVR32_TC_BURST_CLK_AND_XC1
-#define TC_BURST_CLK_AND_XC2                    AVR32_TC_BURST_CLK_AND_XC2
-//! @}
-
-/*! \name Clock Invert
- */
-//! @{
-#define TC_CLOCK_RISING_EDGE                    0
-#define TC_CLOCK_FALLING_EDGE                   1
-//! @}
-
-/*! \name Clock Selection
- */
-//! @{
-#define TC_CLOCK_SOURCE_TC1                     AVR32_TC_TCCLKS_TIMER_DIV1_CLOCK
-#define TC_CLOCK_SOURCE_TC2                     AVR32_TC_TCCLKS_TIMER_DIV2_CLOCK
-#define TC_CLOCK_SOURCE_TC3                     AVR32_TC_TCCLKS_TIMER_DIV3_CLOCK
-#define TC_CLOCK_SOURCE_TC4                     AVR32_TC_TCCLKS_TIMER_DIV4_CLOCK
-#define TC_CLOCK_SOURCE_TC5                     AVR32_TC_TCCLKS_TIMER_DIV5_CLOCK
-#define TC_CLOCK_SOURCE_XC0                     AVR32_TC_TCCLKS_XC0
-#define TC_CLOCK_SOURCE_XC1                     AVR32_TC_TCCLKS_XC1
-#define TC_CLOCK_SOURCE_XC2                     AVR32_TC_TCCLKS_XC2
-//! @}
-
-
-//! Timer/counter interrupts.
-typedef struct
-{
-  unsigned int                 :24;
-
-  //! External trigger interrupt.
-  unsigned int etrgs           : 1;
-
-  //! RB load interrupt.
-  unsigned int ldrbs           : 1;
-
-  //! RA load interrupt.
-  unsigned int ldras           : 1;
-
-  //! RC compare interrupt.
-  unsigned int cpcs            : 1;
-
-  //! RB compare interrupt.
-  unsigned int cpbs            : 1;
-
-  //! RA compare interrupt.
-  unsigned int cpas            : 1;
-
-  //! Load overrun interrupt.
-  unsigned int lovrs           : 1;
-
-  //! Counter overflow interrupt.
-  unsigned int covfs           : 1;
-} tc_interrupt_t;
-
-//! Parameters when initializing a timer/counter in capture mode.
-typedef struct
-{
-  //! Channel to initialize.
-  unsigned int channel            ;
-
-  unsigned int                 :12;
-
-  //! RB loading selection:\n
-  //!   - \ref TC_SEL_NO_EDGE;\n
-  //!   - \ref TC_SEL_RISING_EDGE;\n
-  //!   - \ref TC_SEL_FALLING_EDGE;\n
-  //!   - \ref TC_SEL_EACH_EDGE.
-  unsigned int ldrb            : 2;
-
-  //! RA loading selection:\n
-  //!   - \ref TC_SEL_NO_EDGE;\n
-  //!   - \ref TC_SEL_RISING_EDGE;\n
-  //!   - \ref TC_SEL_FALLING_EDGE;\n
-  //!   - \ref TC_SEL_EACH_EDGE.
-  unsigned int ldra            : 2;
-
-  unsigned int                 : 1;
-
-  //! RC compare trigger enable:\n
-  //!   - \ref TC_NO_TRIGGER_COMPARE_RC;\n
-  //!   - \ref TC_TRIGGER_COMPARE_RC.
-  unsigned int cpctrg          : 1;
-
-  unsigned int                 : 3;
-
-  //! TIOA or TIOB external trigger selection:\n
-  //!   - \ref TC_EXT_TRIG_SEL_TIOA;\n
-  //!   - \ref TC_EXT_TRIG_SEL_TIOB.
-  unsigned int abetrg          : 1;
-
-  //! External trigger edge selection:\n
-  //!   - \ref TC_SEL_NO_EDGE;\n
-  //!   - \ref TC_SEL_RISING_EDGE;\n
-  //!   - \ref TC_SEL_FALLING_EDGE;\n
-  //!   - \ref TC_SEL_EACH_EDGE.
-  unsigned int etrgedg         : 2;
-
-  //! Counter clock disable with RB loading:\n
-  //!   - \c FALSE;\n
-  //!   - \c TRUE.
-  unsigned int ldbdis          : 1;
-
-  //! Counter clock stopped with RB loading:\n
-  //!   - \c FALSE;\n
-  //!   - \c TRUE.
-  unsigned int ldbstop         : 1;
-
-  //! Burst signal selection:\n
-  //!   - \ref TC_BURST_NOT_GATED;\n
-  //!   - \ref TC_BURST_CLK_AND_XC0;\n
-  //!   - \ref TC_BURST_CLK_AND_XC1;\n
-  //!   - \ref TC_BURST_CLK_AND_XC2.
-  unsigned int burst           : 2;
-
-  //! Clock invert:\n
-  //!   - \ref TC_CLOCK_RISING_EDGE;\n
-  //!   - \ref TC_CLOCK_FALLING_EDGE.
-  unsigned int clki            : 1;
-
-  //! Clock selection:\n
-  //!   - \ref TC_CLOCK_SOURCE_TC1;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC2;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC3;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC4;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC5;\n
-  //!   - \ref TC_CLOCK_SOURCE_XC0;\n
-  //!   - \ref TC_CLOCK_SOURCE_XC1;\n
-  //!   - \ref TC_CLOCK_SOURCE_XC2.
-  unsigned int tcclks          : 3;
-} tc_capture_opt_t;
-
-//! Parameters when initializing a timer/counter in waveform mode.
-typedef struct
-{
-  //! Channel to initialize.
-  unsigned int channel            ;
-
-  //! Software trigger effect on TIOB:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int bswtrg          : 2;
-
-  //! External event effect on TIOB:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int beevt           : 2;
-
-  //! RC compare effect on TIOB:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int bcpc            : 2;
-
-  //! RB compare effect on TIOB:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int bcpb            : 2;
-
-  //! Software trigger effect on TIOA:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int aswtrg          : 2;
-
-  //! External event effect on TIOA:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int aeevt           : 2;
-
-  //! RC compare effect on TIOA:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int acpc            : 2;
-
-  //! RA compare effect on TIOA:\n
-  //!   - \ref TC_EVT_EFFECT_NOOP;\n
-  //!   - \ref TC_EVT_EFFECT_SET;\n
-  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
-  //!   - \ref TC_EVT_EFFECT_TOGGLE.
-  unsigned int acpa            : 2;
-
-  unsigned int                 : 1;
-
-  //! Waveform selection:\n
-  //!   - \ref TC_WAVEFORM_SEL_UP_MODE;\n
-  //!   - \ref TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER;\n
-  //!   - \ref TC_WAVEFORM_SEL_UPDOWN_MODE;\n
-  //!   - \ref TC_WAVEFORM_SEL_UPDOWN_MODE_RC_TRIGGER.
-  unsigned int wavsel          : 2;
-
-  //! External event trigger enable:\n
-  //!   - \c FALSE;\n
-  //!   - \c TRUE.
-  unsigned int enetrg          : 1;
-
-  //! External event selection:\n
-  //!   - \ref TC_EXT_EVENT_SEL_TIOB_INPUT;\n
-  //!   - \ref TC_EXT_EVENT_SEL_XC0_OUTPUT;\n
-  //!   - \ref TC_EXT_EVENT_SEL_XC1_OUTPUT;\n
-  //!   - \ref TC_EXT_EVENT_SEL_XC2_OUTPUT.
-  unsigned int eevt            : 2;
-
-  //! External event edge selection:\n
-  //!   - \ref TC_SEL_NO_EDGE;\n
-  //!   - \ref TC_SEL_RISING_EDGE;\n
-  //!   - \ref TC_SEL_FALLING_EDGE;\n
-  //!   - \ref TC_SEL_EACH_EDGE.
-  unsigned int eevtedg         : 2;
-
-  //! Counter clock disable with RC compare:\n
-  //!   - \c FALSE;\n
-  //!   - \c TRUE.
-  unsigned int cpcdis          : 1;
-
-  //! Counter clock stopped with RC compare:\n
-  //!   - \c FALSE;\n
-  //!   - \c TRUE.
-  unsigned int cpcstop         : 1;
-
-  //! Burst signal selection:\n
-  //!   - \ref TC_BURST_NOT_GATED;\n
-  //!   - \ref TC_BURST_CLK_AND_XC0;\n
-  //!   - \ref TC_BURST_CLK_AND_XC1;\n
-  //!   - \ref TC_BURST_CLK_AND_XC2.
-  unsigned int burst           : 2;
-
-  //! Clock invert:\n
-  //!   - \ref TC_CLOCK_RISING_EDGE;\n
-  //!   - \ref TC_CLOCK_FALLING_EDGE.
-  unsigned int clki            : 1;
-
-  //! Clock selection:\n
-  //!   - \ref TC_CLOCK_SOURCE_TC1;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC2;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC3;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC4;\n
-  //!   - \ref TC_CLOCK_SOURCE_TC5;\n
-  //!   - \ref TC_CLOCK_SOURCE_XC0;\n
-  //!   - \ref TC_CLOCK_SOURCE_XC1;\n
-  //!   - \ref TC_CLOCK_SOURCE_XC2.
-  unsigned int tcclks          : 3;
-} tc_waveform_opt_t;
-
-
-/*! \brief Reads timer/counter interrupt settings.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval &gt;=0 The interrupt enable configuration organized according to \ref tc_interrupt_t.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_get_interrupt_settings(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Enables various timer/counter interrupts.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- * \param bitfield        The interrupt enable configuration.
- *
- * \retval 0 Success.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield);
-
-/*! \brief Selects which external clock to use and how to configure it.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- * \param ext_clk_sig_src External clock signal selection:
- *   \arg \c TC_CH0_EXT_CLK0_SRC_TCLK0;
- *   \arg \c TC_CH0_EXT_CLK0_SRC_NO_CLK;
- *   \arg \c TC_CH0_EXT_CLK0_SRC_TIOA1;
- *   \arg \c TC_CH0_EXT_CLK0_SRC_TIOA2;
- *   \arg \c TC_CH1_EXT_CLK1_SRC_TCLK1;
- *   \arg \c TC_CH1_EXT_CLK1_SRC_NO_CLK;
- *   \arg \c TC_CH1_EXT_CLK1_SRC_TIOA0;
- *   \arg \c TC_CH1_EXT_CLK1_SRC_TIOA2;
- *   \arg \c TC_CH2_EXT_CLK2_SRC_TCLK2;
- *   \arg \c TC_CH2_EXT_CLK2_SRC_NO_CLK;
- *   \arg \c TC_CH2_EXT_CLK2_SRC_TIOA0;
- *   \arg \c TC_CH2_EXT_CLK2_SRC_TIOA1.
- *
- * \retval 0 Success.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_select_external_clock(volatile avr32_tc_t *tc, unsigned int channel, unsigned int ext_clk_sig_src);
-
-/*! \brief Sets options for timer/counter capture initialization.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param opt             Options for capture mode.
- *
- * \retval 0 Success.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_init_capture(volatile avr32_tc_t *tc, const tc_capture_opt_t *opt);
-
-/*! \brief Sets options for timer/counter waveform initialization.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param opt             Options for waveform generation.
- *
- * \retval 0 Success.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt);
-
-/*! \brief Starts a timer/counter.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval 0 Success.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_start(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Stops a timer/counter.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval 0 Success.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_stop(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Performs a software trigger: the counter is reset and the clock is started.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval 0 Success.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_software_trigger(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Asserts a SYNC signal to generate a software trigger and reset all channels.
- *
- * \param tc              Pointer to the TC instance to access.
- */
-extern void tc_sync_trigger(volatile avr32_tc_t *tc);
-
-/*! \brief Reads the status register.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval &gt;=0 Status register value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Reads the channel's TC counter and returns the value.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval &gt;=0 TC counter value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_read_tc(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Reads the channel's RA register and returns the value.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval &gt;=0 RA register value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_read_ra(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Reads the channel's RB register and returns the value.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval &gt;=0 RB register value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_read_rb(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Reads the channel's RC register and returns the value.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- *
- * \retval &gt;=0 RC register value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_read_rc(volatile avr32_tc_t *tc, unsigned int channel);
-
-/*! \brief Writes a value to the channel's RA register.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- * \param value           Value to write to the RA register.
- *
- * \retval &gt;=0 Written value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_write_ra(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
-
-/*! \brief Writes a value to the channel's RB register.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- * \param value           Value to write to the RB register.
- *
- * \retval &gt;=0 Written value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_write_rb(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
-
-/*! \brief Writes a value to the channel's RC register.
- *
- * \param tc              Pointer to the TC instance to access.
- * \param channel         The TC instance channel to access.
- * \param value           Value to write to the RC register.
- *
- * \retval &gt;=0 Written value.
- * \retval TC_INVALID_ARGUMENT Invalid argument(s).
- */
-extern int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
-
-
-#endif  // _TC_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Timer/Counter driver for AVR32 UC3.
+ *
+ * AVR32 Timer/Counter driver module.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a TC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _TC_H_
+#define _TC_H_
+
+#include &lt;avr32/io.h&gt;
+
+
+//! TC driver functions return value in case of invalid argument(s).
+#define TC_INVALID_ARGUMENT                     (-1)
+
+//! Number of timer/counter channels.
+#define TC_NUMBER_OF_CHANNELS                   (sizeof(((avr32_tc_t *)0)-&gt;channel) / sizeof(avr32_tc_channel_t))
+
+/*! \name External Clock Signal 0 Selection
+ */
+//! @{
+#define TC_CH0_EXT_CLK0_SRC_TCLK0               AVR32_TC_TC0XC0S_TCLK0
+#define TC_CH0_EXT_CLK0_SRC_NO_CLK              AVR32_TC_TC0XC0S_NO_CLK
+#define TC_CH0_EXT_CLK0_SRC_TIOA1               AVR32_TC_TC0XC0S_TIOA1
+#define TC_CH0_EXT_CLK0_SRC_TIOA2               AVR32_TC_TC0XC0S_TIOA2
+//! @}
+
+/*! \name External Clock Signal 1 Selection
+ */
+//! @{
+#define TC_CH1_EXT_CLK1_SRC_TCLK1               AVR32_TC_TC1XC1S_TCLK1
+#define TC_CH1_EXT_CLK1_SRC_NO_CLK              AVR32_TC_TC1XC1S_NO_CLK
+#define TC_CH1_EXT_CLK1_SRC_TIOA0               AVR32_TC_TC1XC1S_TIOA0
+#define TC_CH1_EXT_CLK1_SRC_TIOA2               AVR32_TC_TC1XC1S_TIOA2
+//! @}
+
+/*! \name External Clock Signal 2 Selection
+ */
+//! @{
+#define TC_CH2_EXT_CLK2_SRC_TCLK2               AVR32_TC_TC2XC2S_TCLK2
+#define TC_CH2_EXT_CLK2_SRC_NO_CLK              AVR32_TC_TC2XC2S_NO_CLK
+#define TC_CH2_EXT_CLK2_SRC_TIOA0               AVR32_TC_TC2XC2S_TIOA0
+#define TC_CH2_EXT_CLK2_SRC_TIOA1               AVR32_TC_TC2XC2S_TIOA1
+//! @}
+
+/*! \name Event/Trigger Actions on Output
+ */
+//! @{
+#define TC_EVT_EFFECT_NOOP                      AVR32_TC_NONE
+#define TC_EVT_EFFECT_SET                       AVR32_TC_SET
+#define TC_EVT_EFFECT_CLEAR                     AVR32_TC_CLEAR
+#define TC_EVT_EFFECT_TOGGLE                    AVR32_TC_TOGGLE
+//! @}
+
+/*! \name RC Compare Trigger Enable
+ */
+//! @{
+#define TC_NO_TRIGGER_COMPARE_RC                0
+#define TC_TRIGGER_COMPARE_RC                   1
+//! @}
+
+/*! \name Waveform Selection
+ */
+//! @{
+#define TC_WAVEFORM_SEL_UP_MODE                 AVR32_TC_WAVSEL_UP_NO_AUTO
+#define TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER      AVR32_TC_WAVSEL_UP_AUTO
+#define TC_WAVEFORM_SEL_UPDOWN_MODE             AVR32_TC_WAVSEL_UPDOWN_NO_AUTO
+#define TC_WAVEFORM_SEL_UPDOWN_MODE_RC_TRIGGER  AVR32_TC_WAVSEL_UPDOWN_AUTO
+//! @}
+
+/*! \name TIOA or TIOB External Trigger Selection
+ */
+//! @{
+#define TC_EXT_TRIG_SEL_TIOA                    1
+#define TC_EXT_TRIG_SEL_TIOB                    0
+//! @}
+
+/*! \name External Event Selection
+ */
+//! @{
+#define TC_EXT_EVENT_SEL_TIOB_INPUT             AVR32_TC_EEVT_TIOB_INPUT
+#define TC_EXT_EVENT_SEL_XC0_OUTPUT             AVR32_TC_EEVT_XC0_OUTPUT
+#define TC_EXT_EVENT_SEL_XC1_OUTPUT             AVR32_TC_EEVT_XC1_OUTPUT
+#define TC_EXT_EVENT_SEL_XC2_OUTPUT             AVR32_TC_EEVT_XC2_OUTPUT
+//! @}
+
+/*! \name Edge Selection
+ */
+//! @{
+#define TC_SEL_NO_EDGE                          AVR32_TC_EEVTEDG_NO_EDGE
+#define TC_SEL_RISING_EDGE                      AVR32_TC_EEVTEDG_POS_EDGE
+#define TC_SEL_FALLING_EDGE                     AVR32_TC_EEVTEDG_NEG_EDGE
+#define TC_SEL_EACH_EDGE                        AVR32_TC_EEVTEDG_BOTH_EDGES
+//! @}
+
+/*! \name Burst Signal Selection
+ */
+//! @{
+#define TC_BURST_NOT_GATED                      AVR32_TC_BURST_NOT_GATED
+#define TC_BURST_CLK_AND_XC0                    AVR32_TC_BURST_CLK_AND_XC0
+#define TC_BURST_CLK_AND_XC1                    AVR32_TC_BURST_CLK_AND_XC1
+#define TC_BURST_CLK_AND_XC2                    AVR32_TC_BURST_CLK_AND_XC2
+//! @}
+
+/*! \name Clock Invert
+ */
+//! @{
+#define TC_CLOCK_RISING_EDGE                    0
+#define TC_CLOCK_FALLING_EDGE                   1
+//! @}
+
+/*! \name Clock Selection
+ */
+//! @{
+#define TC_CLOCK_SOURCE_TC1                     AVR32_TC_TCCLKS_TIMER_CLOCK1
+#define TC_CLOCK_SOURCE_TC2                     AVR32_TC_TCCLKS_TIMER_CLOCK2
+#define TC_CLOCK_SOURCE_TC3                     AVR32_TC_TCCLKS_TIMER_CLOCK3
+#define TC_CLOCK_SOURCE_TC4                     AVR32_TC_TCCLKS_TIMER_CLOCK4
+#define TC_CLOCK_SOURCE_TC5                     AVR32_TC_TCCLKS_TIMER_CLOCK5
+#define TC_CLOCK_SOURCE_XC0                     AVR32_TC_TCCLKS_XC0
+#define TC_CLOCK_SOURCE_XC1                     AVR32_TC_TCCLKS_XC1
+#define TC_CLOCK_SOURCE_XC2                     AVR32_TC_TCCLKS_XC2
+//! @}
+
+
+//! Timer/counter interrupts.
+typedef struct
+{
+  unsigned int                 :24;
+
+  //! External trigger interrupt.
+  unsigned int etrgs           : 1;
+
+  //! RB load interrupt.
+  unsigned int ldrbs           : 1;
+
+  //! RA load interrupt.
+  unsigned int ldras           : 1;
+
+  //! RC compare interrupt.
+  unsigned int cpcs            : 1;
+
+  //! RB compare interrupt.
+  unsigned int cpbs            : 1;
+
+  //! RA compare interrupt.
+  unsigned int cpas            : 1;
+
+  //! Load overrun interrupt.
+  unsigned int lovrs           : 1;
+
+  //! Counter overflow interrupt.
+  unsigned int covfs           : 1;
+} tc_interrupt_t;
+
+//! Parameters when initializing a timer/counter in capture mode.
+typedef struct
+{
+  //! Channel to initialize.
+  unsigned int channel            ;
+
+  unsigned int                 :12;
+
+  //! RB loading selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int ldrb            : 2;
+
+  //! RA loading selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int ldra            : 2;
+
+  unsigned int                 : 1;
+
+  //! RC compare trigger enable:\n
+  //!   - \ref TC_NO_TRIGGER_COMPARE_RC;\n
+  //!   - \ref TC_TRIGGER_COMPARE_RC.
+  unsigned int cpctrg          : 1;
+
+  unsigned int                 : 3;
+
+  //! TIOA or TIOB external trigger selection:\n
+  //!   - \ref TC_EXT_TRIG_SEL_TIOA;\n
+  //!   - \ref TC_EXT_TRIG_SEL_TIOB.
+  unsigned int abetrg          : 1;
+
+  //! External trigger edge selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int etrgedg         : 2;
+
+  //! Counter clock disable with RB loading:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int ldbdis          : 1;
+
+  //! Counter clock stopped with RB loading:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int ldbstop         : 1;
+
+  //! Burst signal selection:\n
+  //!   - \ref TC_BURST_NOT_GATED;\n
+  //!   - \ref TC_BURST_CLK_AND_XC0;\n
+  //!   - \ref TC_BURST_CLK_AND_XC1;\n
+  //!   - \ref TC_BURST_CLK_AND_XC2.
+  unsigned int burst           : 2;
+
+  //! Clock invert:\n
+  //!   - \ref TC_CLOCK_RISING_EDGE;\n
+  //!   - \ref TC_CLOCK_FALLING_EDGE.
+  unsigned int clki            : 1;
+
+  //! Clock selection:\n
+  //!   - \ref TC_CLOCK_SOURCE_TC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC2;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC3;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC4;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC5;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC0;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC2.
+  unsigned int tcclks          : 3;
+} tc_capture_opt_t;
+
+//! Parameters when initializing a timer/counter in waveform mode.
+typedef struct
+{
+  //! Channel to initialize.
+  unsigned int channel            ;
+
+  //! Software trigger effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int bswtrg          : 2;
+
+  //! External event effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int beevt           : 2;
+
+  //! RC compare effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int bcpc            : 2;
+
+  //! RB compare effect on TIOB:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int bcpb            : 2;
+
+  //! Software trigger effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int aswtrg          : 2;
+
+  //! External event effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int aeevt           : 2;
+
+  //! RC compare effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int acpc            : 2;
+
+  //! RA compare effect on TIOA:\n
+  //!   - \ref TC_EVT_EFFECT_NOOP;\n
+  //!   - \ref TC_EVT_EFFECT_SET;\n
+  //!   - \ref TC_EVT_EFFECT_CLEAR;\n
+  //!   - \ref TC_EVT_EFFECT_TOGGLE.
+  unsigned int acpa            : 2;
+
+  unsigned int                 : 1;
+
+  //! Waveform selection:\n
+  //!   - \ref TC_WAVEFORM_SEL_UP_MODE;\n
+  //!   - \ref TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER;\n
+  //!   - \ref TC_WAVEFORM_SEL_UPDOWN_MODE;\n
+  //!   - \ref TC_WAVEFORM_SEL_UPDOWN_MODE_RC_TRIGGER.
+  unsigned int wavsel          : 2;
+
+  //! External event trigger enable:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int enetrg          : 1;
+
+  //! External event selection:\n
+  //!   - \ref TC_EXT_EVENT_SEL_TIOB_INPUT;\n
+  //!   - \ref TC_EXT_EVENT_SEL_XC0_OUTPUT;\n
+  //!   - \ref TC_EXT_EVENT_SEL_XC1_OUTPUT;\n
+  //!   - \ref TC_EXT_EVENT_SEL_XC2_OUTPUT.
+  unsigned int eevt            : 2;
+
+  //! External event edge selection:\n
+  //!   - \ref TC_SEL_NO_EDGE;\n
+  //!   - \ref TC_SEL_RISING_EDGE;\n
+  //!   - \ref TC_SEL_FALLING_EDGE;\n
+  //!   - \ref TC_SEL_EACH_EDGE.
+  unsigned int eevtedg         : 2;
+
+  //! Counter clock disable with RC compare:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int cpcdis          : 1;
+
+  //! Counter clock stopped with RC compare:\n
+  //!   - \c FALSE;\n
+  //!   - \c TRUE.
+  unsigned int cpcstop         : 1;
+
+  //! Burst signal selection:\n
+  //!   - \ref TC_BURST_NOT_GATED;\n
+  //!   - \ref TC_BURST_CLK_AND_XC0;\n
+  //!   - \ref TC_BURST_CLK_AND_XC1;\n
+  //!   - \ref TC_BURST_CLK_AND_XC2.
+  unsigned int burst           : 2;
+
+  //! Clock invert:\n
+  //!   - \ref TC_CLOCK_RISING_EDGE;\n
+  //!   - \ref TC_CLOCK_FALLING_EDGE.
+  unsigned int clki            : 1;
+
+  //! Clock selection:\n
+  //!   - \ref TC_CLOCK_SOURCE_TC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC2;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC3;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC4;\n
+  //!   - \ref TC_CLOCK_SOURCE_TC5;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC0;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC1;\n
+  //!   - \ref TC_CLOCK_SOURCE_XC2.
+  unsigned int tcclks          : 3;
+} tc_waveform_opt_t;
+
+
+/*! \brief Reads timer/counter interrupt settings.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 The interrupt enable configuration organized according to \ref tc_interrupt_t.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_get_interrupt_settings(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Enables various timer/counter interrupts.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param bitfield        The interrupt enable configuration.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield);
+
+/*! \brief Selects which external clock to use and how to configure it.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param ext_clk_sig_src External clock signal selection:
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_TCLK0;
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_NO_CLK;
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_TIOA1;
+ *   \arg \c TC_CH0_EXT_CLK0_SRC_TIOA2;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_TCLK1;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_NO_CLK;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_TIOA0;
+ *   \arg \c TC_CH1_EXT_CLK1_SRC_TIOA2;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_TCLK2;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_NO_CLK;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_TIOA0;
+ *   \arg \c TC_CH2_EXT_CLK2_SRC_TIOA1.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_select_external_clock(volatile avr32_tc_t *tc, unsigned int channel, unsigned int ext_clk_sig_src);
+
+/*! \brief Sets options for timer/counter capture initialization.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param opt             Options for capture mode.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_init_capture(volatile avr32_tc_t *tc, const tc_capture_opt_t *opt);
+
+/*! \brief Sets options for timer/counter waveform initialization.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param opt             Options for waveform generation.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt);
+
+/*! \brief Starts a timer/counter.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_start(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Stops a timer/counter.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_stop(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Performs a software trigger: the counter is reset and the clock is started.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval 0 Success.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_software_trigger(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Asserts a SYNC signal to generate a software trigger and reset all channels.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ */
+extern void tc_sync_trigger(volatile avr32_tc_t *tc);
+
+/*! \brief Start all TC channels simultaneously.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ */
+extern void tc_sync_start(volatile avr32_tc_t *tc);
+
+/*! \brief Reads the status register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 Status register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's TC counter and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 TC counter value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_tc(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's RA register and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 RA register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_ra(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's RB register and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 RB register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_rb(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Reads the channel's RC register and returns the value.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ *
+ * \retval &gt;=0 RC register value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_read_rc(volatile avr32_tc_t *tc, unsigned int channel);
+
+/*! \brief Writes a value to the channel's RA register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param value           Value to write to the RA register.
+ *
+ * \retval &gt;=0 Written value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_write_ra(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
+
+/*! \brief Writes a value to the channel's RB register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param value           Value to write to the RB register.
+ *
+ * \retval &gt;=0 Written value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_write_rb(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
+
+/*! \brief Writes a value to the channel's RC register.
+ *
+ * \param tc              Pointer to the TC instance to access.
+ * \param channel         The TC instance channel to access.
+ * \param value           Value to write to the RC register.
+ *
+ * \retval &gt;=0 Written value.
+ * \retval TC_INVALID_ARGUMENT Invalid argument(s).
+ */
+extern int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value);
+
+
+#endif  // _TC_H_

Modified: trunk/src/platform/avr32/tpaste.h
===================================================================
--- trunk/src/platform/avr32/tpaste.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/tpaste.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,92 +1,95 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief Preprocessor token pasting utils.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices can be used.
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _TPASTE_H_
-#define _TPASTE_H_
-
-
-/*! \name Token Paste
- *
- * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
- *
- * May be used only within macros with the tokens passed as arguments if the tokens are \#defined.
- *
- * For example, writing TPASTE2(U, WIDTH) within a macro \#defined by
- * UTYPE(WIDTH) and invoked as UTYPE(UL_WIDTH) with UL_WIDTH \#defined as 32 is
- * equivalent to writing U32.
- */
-//! @{
-#define TPASTE2( a, b)                            a##b
-#define TPASTE3( a, b, c)                         a##b##c
-#define TPASTE4( a, b, c, d)                      a##b##c##d
-#define TPASTE5( a, b, c, d, e)                   a##b##c##d##e
-#define TPASTE6( a, b, c, d, e, f)                a##b##c##d##e##f
-#define TPASTE7( a, b, c, d, e, f, g)             a##b##c##d##e##f##g
-#define TPASTE8( a, b, c, d, e, f, g, h)          a##b##c##d##e##f##g##h
-#define TPASTE9( a, b, c, d, e, f, g, h, i)       a##b##c##d##e##f##g##h##i
-#define TPASTE10(a, b, c, d, e, f, g, h, i, j)    a##b##c##d##e##f##g##h##i##j
-//! @}
-
-/*! \name Absolute Token Paste
- *
- * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
- *
- * No restriction of use if the tokens are \#defined.
- *
- * For example, writing ATPASTE2(U, UL_WIDTH) anywhere with UL_WIDTH \#defined
- * as 32 is equivalent to writing U32.
- */
-//! @{
-#define ATPASTE2( a, b)                           TPASTE2( a, b)
-#define ATPASTE3( a, b, c)                        TPASTE3( a, b, c)
-#define ATPASTE4( a, b, c, d)                     TPASTE4( a, b, c, d)
-#define ATPASTE5( a, b, c, d, e)                  TPASTE5( a, b, c, d, e)
-#define ATPASTE6( a, b, c, d, e, f)               TPASTE6( a, b, c, d, e, f)
-#define ATPASTE7( a, b, c, d, e, f, g)            TPASTE7( a, b, c, d, e, f, g)
-#define ATPASTE8( a, b, c, d, e, f, g, h)         TPASTE8( a, b, c, d, e, f, g, h)
-#define ATPASTE9( a, b, c, d, e, f, g, h, i)      TPASTE9( a, b, c, d, e, f, g, h, i)
-#define ATPASTE10(a, b, c, d, e, f, g, h, i, j)   TPASTE10(a, b, c, d, e, f, g, h, i, j)
-//! @}
-
-
-#endif  // _TPASTE_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief Preprocessor token pasting utils.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices can be used.
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _TPASTE_H_
+#define _TPASTE_H_
+
+
+/*! \name Token Paste
+ *
+ * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
+ *
+ * May be used only within macros with the tokens passed as arguments if the tokens are \#defined.
+ *
+ * For example, writing TPASTE2(U, WIDTH) within a macro \#defined by
+ * UTYPE(WIDTH) and invoked as UTYPE(UL_WIDTH) with UL_WIDTH \#defined as 32 is
+ * equivalent to writing U32.
+ */
+//! @{
+#define TPASTE2( a, b)                            a##b
+#define TPASTE3( a, b, c)                         a##b##c
+#define TPASTE4( a, b, c, d)                      a##b##c##d
+#define TPASTE5( a, b, c, d, e)                   a##b##c##d##e
+#define TPASTE6( a, b, c, d, e, f)                a##b##c##d##e##f
+#define TPASTE7( a, b, c, d, e, f, g)             a##b##c##d##e##f##g
+#define TPASTE8( a, b, c, d, e, f, g, h)          a##b##c##d##e##f##g##h
+#define TPASTE9( a, b, c, d, e, f, g, h, i)       a##b##c##d##e##f##g##h##i
+#define TPASTE10(a, b, c, d, e, f, g, h, i, j)    a##b##c##d##e##f##g##h##i##j
+//! @}
+
+/*! \name Absolute Token Paste
+ *
+ * Paste N preprocessing tokens together, these tokens being allowed to be \#defined.
+ *
+ * No restriction of use if the tokens are \#defined.
+ *
+ * For example, writing ATPASTE2(U, UL_WIDTH) anywhere with UL_WIDTH \#defined
+ * as 32 is equivalent to writing U32.
+ */
+//! @{
+#define ATPASTE2( a, b)                           TPASTE2( a, b)
+#define ATPASTE3( a, b, c)                        TPASTE3( a, b, c)
+#define ATPASTE4( a, b, c, d)                     TPASTE4( a, b, c, d)
+#define ATPASTE5( a, b, c, d, e)                  TPASTE5( a, b, c, d, e)
+#define ATPASTE6( a, b, c, d, e, f)               TPASTE6( a, b, c, d, e, f)
+#define ATPASTE7( a, b, c, d, e, f, g)            TPASTE7( a, b, c, d, e, f, g)
+#define ATPASTE8( a, b, c, d, e, f, g, h)         TPASTE8( a, b, c, d, e, f, g, h)
+#define ATPASTE9( a, b, c, d, e, f, g, h, i)      TPASTE9( a, b, c, d, e, f, g, h, i)
+#define ATPASTE10(a, b, c, d, e, f, g, h, i, j)   TPASTE10(a, b, c, d, e, f, g, h, i, j)
+//! @}
+
+
+#endif  // _TPASTE_H_

Modified: trunk/src/platform/avr32/usart.c
===================================================================
--- trunk/src/platform/avr32/usart.c	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/usart.c	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,839 +1,911 @@
-/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This source file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief USART driver for AVR32 UC3.
- *
- * This file contains basic functions for the AVR32 USART, with support for all
- * modes, settings and clock speeds.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a USART module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include &quot;compiler.h&quot;
-#include &quot;usart.h&quot;
-
-
-//------------------------------------------------------------------------------
-/*! \name Private Functions
- */
-//! @{
-
-
-/*! \brief Checks if the USART is in multidrop mode.
- *
- * \param usart Base address of the USART instance.
- *
- * \return \c 1 if the USART is in multidrop mode, otherwise \c 0.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-static __inline__ int usart_mode_is_multidrop(volatile avr32_usart_t *usart)
-{
-  return ((usart-&gt;mr &gt;&gt; AVR32_USART_MR_PAR_OFFSET) &amp; AVR32_USART_MR_PAR_MULTI) == AVR32_USART_MR_PAR_MULTI;
-}
-
-
-/*! \brief Calculates a clock divider (\e CD) and a fractional part (\e FP) for
- *         the USART asynchronous modes to generate a baud rate as close as
- *         possible to the baud rate set point.
- *
- * Baud rate calculation:
- * \f$ Baudrate = \frac{SelectedClock}{Over \times (CD + \frac{FP}{8})} \f$, \e Over being 16 or 8.
- * The maximal oversampling is selected if it allows to generate a baud rate close to the set point.
- *
- * \param usart     Base address of the USART instance.
- * \param baudrate  Baud rate set point.
- * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Baud rate successfully initialized.
- * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
- */
-static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
-{
-  unsigned int over = (pba_hz &gt;= 16 * baudrate) ? 16 : 8;
-  unsigned int cd = pba_hz / (over * baudrate);
-  unsigned int fp = ((1 &lt;&lt; AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate) -
-                    (1 &lt;&lt; AVR32_USART_BRGR_FP_SIZE) * cd;
-
-  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
-    return USART_INVALID_INPUT;
-
-  usart-&gt;mr = (usart-&gt;mr &amp; ~(AVR32_USART_MR_USCLKS_MASK |
-                             AVR32_USART_MR_SYNC_MASK |
-                             AVR32_USART_MR_OVER_MASK)) |
-              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
-              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) &lt;&lt; AVR32_USART_MR_OVER_OFFSET;
-
-  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET |
-                fp &lt;&lt; AVR32_USART_BRGR_FP_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-/*! \brief Calculates a clock divider (\e CD) for the USART synchronous master
- *         modes to generate a baud rate as close as possible to the baud rate
- *         set point.
- *
- * Baud rate calculation:
- * \f$ Baudrate = \frac{SelectedClock}{CD} \f$.
- *
- * \param usart     Base address of the USART instance.
- * \param baudrate  Baud rate set point.
- * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Baud rate successfully initialized.
- * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
- */
-static int usart_set_sync_master_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
-{
-  unsigned int cd = (pba_hz + baudrate / 2) / baudrate;
-
-  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
-    return USART_INVALID_INPUT;
-
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
-              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
-              AVR32_USART_MR_SYNC_MASK;
-
-  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-/*! \brief Selects the SCK pin as the source of baud rate for the USART
- *         synchronous slave modes.
- *
- * \param usart Base address of the USART instance.
- *
- * \retval USART_SUCCESS  Baud rate successfully initialized.
- */
-static int usart_set_sync_slave_baudrate(volatile avr32_usart_t *usart)
-{
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
-              AVR32_USART_MR_USCLKS_SCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
-              AVR32_USART_MR_SYNC_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-/*! \brief Calculates a clock divider (\e CD) for the USART ISO7816 mode to
- *         generate an ISO7816 clock as close as possible to the clock set point.
- *
- * ISO7816 clock calculation:
- * \f$ Clock = \frac{SelectedClock}{CD} \f$.
- *
- * \param usart   Base address of the USART instance.
- * \param clock   ISO7816 clock set point.
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        ISO7816 clock successfully initialized.
- * \retval USART_INVALID_INPUT  ISO7816 clock set point is out of range for the given input clock frequency.
- */
-static int usart_set_iso7816_clock(volatile avr32_usart_t *usart, unsigned int clock, unsigned long pba_hz)
-{
-  unsigned int cd = (pba_hz + clock / 2) / clock;
-
-  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
-    return USART_INVALID_INPUT;
-
-  usart-&gt;mr = (usart-&gt;mr &amp; ~(AVR32_USART_MR_USCLKS_MASK |
-                             AVR32_USART_MR_SYNC_MASK |
-                             AVR32_USART_MR_OVER_MASK)) |
-              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
-              AVR32_USART_MR_OVER_X16 &lt;&lt; AVR32_USART_MR_OVER_OFFSET;
-
-  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-#ifdef AVR32_USART_400_H_INCLUDED
-
-
-/*! \brief Calculates a clock divider (\e CD) for the USART SPI master mode to
- *         generate a baud rate as close as possible to the baud rate set point.
- *
- * Baud rate calculation:
- * \f$ Baudrate = \frac{SelectedClock}{CD} \f$.
- *
- * \param usart     Base address of the USART instance.
- * \param baudrate  Baud rate set point.
- * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Baud rate successfully initialized.
- * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
- */
-static int usart_set_spi_master_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
-{
-  unsigned int cd = (pba_hz + baudrate / 2) / baudrate;
-
-  if (cd &lt; 4 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
-    return USART_INVALID_INPUT;
-
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
-              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET;
-
-  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-/*! \brief Selects the SCK pin as the source of baud rate for the USART SPI
- *         slave mode.
- *
- * \param usart Base address of the USART instance.
- *
- * \retval USART_SUCCESS  Baud rate successfully initialized.
- */
-static int usart_set_spi_slave_baudrate(volatile avr32_usart_t *usart)
-{
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
-              AVR32_USART_MR_USCLKS_SCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-#endif
-
-
-//! @}
-
-
-//------------------------------------------------------------------------------
-/*! \name Initialization Functions
- */
-//! @{
-
-
-void usart_reset(volatile avr32_usart_t *usart)
-{
-  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
-
-  // Disable all USART interrupts.
-  // Interrupts needed should be set explicitly on every reset.
-  if (global_interrupt_enabled) Disable_global_interrupt();
-  usart-&gt;idr = 0xFFFFFFFF;
-  usart-&gt;csr;
-  if (global_interrupt_enabled) Enable_global_interrupt();
-
-  // Reset mode and other registers that could cause unpredictable behavior after reset.
-  usart-&gt;mr = 0;
-  usart-&gt;rtor = 0;
-  usart-&gt;ttgr = 0;
-
-  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
-  // reset status bits and turn off DTR and RTS.
-  usart-&gt;cr = AVR32_USART_CR_RSTRX_MASK   |
-              AVR32_USART_CR_RSTTX_MASK   |
-              AVR32_USART_CR_RSTSTA_MASK  |
-              AVR32_USART_CR_RSTIT_MASK   |
-              AVR32_USART_CR_RSTNACK_MASK |
-              AVR32_USART_CR_DTRDIS_MASK  |
-              AVR32_USART_CR_RTSDIS_MASK;
-}
-
-
-int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
-{
-  // Reset the USART and shutdown TX and RX.
-  usart_reset(usart);
-
-  // Check input values.
-  if (!opt || // Null pointer.
-      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
-      opt-&gt;paritytype &gt; 7 ||
-      opt-&gt;stopbits &gt; 2 + 255 ||
-      opt-&gt;channelmode &gt; 3 ||
-      usart_set_async_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  if (opt-&gt;charlength == 9)
-  {
-    // Character length set to 9 bits. MODE9 dominates CHRL.
-    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
-  }
-  else
-  {
-    // CHRL gives the character length (- 5) when MODE9 = 0.
-    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
-  }
-
-  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
-               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
-
-  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
-  {
-    // Set two stop bits
-    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-    // and a timeguard period gives the rest.
-    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
-  }
-  else
-    // Insert 1, 1.5 or 2 stop bits.
-    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-
-  // Set normal mode.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
-
-  // Setup complete; enable communication.
-  // Enable input and output.
-  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
-              AVR32_USART_CR_TXEN_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_rs232_tx_only(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
-{
-  // Reset the USART and shutdown TX and RX.
-  usart_reset(usart);
-
-  // Check input values.
-  if (!opt || // Null pointer.
-      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
-      opt-&gt;paritytype &gt; 7 ||
-      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
-      opt-&gt;channelmode &gt; 3 ||
-      usart_set_sync_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  if (opt-&gt;charlength == 9)
-  {
-    // Character length set to 9 bits. MODE9 dominates CHRL.
-    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
-  }
-  else
-  {
-    // CHRL gives the character length (- 5) when MODE9 = 0.
-    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
-  }
-
-  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
-               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
-
-  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
-  {
-    // Set two stop bits
-    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-    // and a timeguard period gives the rest.
-    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
-  }
-  else
-    // Insert 1 or 2 stop bits.
-    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-
-  // Set normal mode.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
-
-  // Setup complete; enable communication.
-  // Enable only output as input is not possible in synchronous mode without
-  // transferring clock.
-  usart-&gt;cr = AVR32_USART_CR_TXEN_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_hw_handshaking(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
-{
-  // First: Setup standard RS232.
-  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  // Set hardware handshaking mode.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MR_MODE_HARDWARE &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_modem(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
-{
-  // First: Setup standard RS232.
-  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  // Set modem mode.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MR_MODE_MODEM &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_sync_master(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
-{
-  // Reset the USART and shutdown TX and RX.
-  usart_reset(usart);
-
-  // Check input values.
-  if (!opt || // Null pointer.
-      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
-      opt-&gt;paritytype &gt; 7 ||
-      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
-      opt-&gt;channelmode &gt; 3 ||
-      usart_set_sync_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  if (opt-&gt;charlength == 9)
-  {
-    // Character length set to 9 bits. MODE9 dominates CHRL.
-    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
-  }
-  else
-  {
-    // CHRL gives the character length (- 5) when MODE9 = 0.
-    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
-  }
-
-  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
-               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
-
-  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
-  {
-    // Set two stop bits
-    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-    // and a timeguard period gives the rest.
-    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
-  }
-  else
-    // Insert 1 or 2 stop bits.
-    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-
-  // Set normal mode.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
-              AVR32_USART_MR_CLKO_MASK;
-
-  // Setup complete; enable communication.
-  // Enable input and output.
-  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
-              AVR32_USART_CR_TXEN_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_sync_slave(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
-{
-  // Reset the USART and shutdown TX and RX.
-  usart_reset(usart);
-
-  // Check input values.
-  if (!opt || // Null pointer.
-      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
-      opt-&gt;paritytype &gt; 7 ||
-      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
-      opt-&gt;channelmode &gt; 3 ||
-      usart_set_sync_slave_baudrate(usart) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  if (opt-&gt;charlength == 9)
-  {
-    // Character length set to 9 bits. MODE9 dominates CHRL.
-    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
-  }
-  else
-  {
-    // CHRL gives the character length (- 5) when MODE9 = 0.
-    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
-  }
-
-  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
-               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
-
-  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
-  {
-    // Set two stop bits
-    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-    // and a timeguard period gives the rest.
-    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
-  }
-  else
-    // Insert 1 or 2 stop bits.
-    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-
-  // Set normal mode.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
-
-  // Setup complete; enable communication.
-  // Enable input and output.
-  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
-              AVR32_USART_CR_TXEN_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_rs485(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
-{
-  // First: Setup standard RS232.
-  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  // Set RS485 mode.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MR_MODE_RS485 &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_IrDA(volatile avr32_usart_t *usart, const usart_options_t *opt,
-                    long pba_hz, unsigned char irda_filter)
-{
-  // First: Setup standard RS232.
-  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  // Set IrDA filter.
-  usart-&gt;ifr = irda_filter;
-
-  // Set IrDA mode and activate filtering of input.
-  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
-              AVR32_USART_MODE_IRDA &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
-              AVR32_USART_MR_FILTER_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_iso7816(volatile avr32_usart_t *usart, const usart_iso7816_options_t *opt, int t, long pba_hz)
-{
-  // Reset the USART and shutdown TX and RX.
-  usart_reset(usart);
-
-  // Check input values.
-  if (!opt || // Null pointer.
-      opt-&gt;paritytype &gt; 1)
-    return USART_INVALID_INPUT;
-
-  if (t == 0)
-  {
-    // Set USART mode to ISO7816, T=0.
-    // The T=0 protocol always uses 2 stop bits.
-    usart-&gt;mr = AVR32_USART_MR_MODE_ISO7816_T0 &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
-                AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET |
-                opt-&gt;bit_order &lt;&lt; AVR32_USART_MR_MSBF_OFFSET; // Allow MSBF in T=0.
-  }
-  else if (t == 1)
-  {
-    // Only LSB first in the T=1 protocol.
-    // max_iterations field is only used in T=0 mode.
-    if (opt-&gt;bit_order != 0 ||
-        opt-&gt;max_iterations != 0)
-      return USART_INVALID_INPUT;
-
-    // Set USART mode to ISO7816, T=1.
-    // The T=1 protocol always uses 1 stop bit.
-    usart-&gt;mr = AVR32_USART_MR_MODE_ISO7816_T1 &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
-                AVR32_USART_MR_NBSTOP_1 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
-  }
-  else
-    return USART_INVALID_INPUT;
-
-  if (usart_set_iso7816_clock(usart, opt-&gt;iso7816_hz, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  // Set FIDI register: bit rate = selected clock/FI_DI_ratio/16.
-  usart-&gt;fidi = opt-&gt;fidi_ratio;
-
-  // Set ISO7816 spesific options in the MODE register.
-  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
-               AVR32_USART_MR_CLKO_MASK | // Enable clock output.
-               opt-&gt;inhibit_nack &lt;&lt; AVR32_USART_MR_INACK_OFFSET |
-               opt-&gt;dis_suc_nack &lt;&lt; AVR32_USART_MR_DSNACK_OFFSET |
-               opt-&gt;max_iterations &lt;&lt; AVR32_USART_MR_MAX_ITERATION_OFFSET;
-
-  // Setup complete; enable the receiver by default.
-  usart_iso7816_enable_receiver(usart);
-
-  return USART_SUCCESS;
-}
-
-
-#ifdef AVR32_USART_400_H_INCLUDED
-
-
-int usart_init_spi_master(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz)
-{
-  // Reset the USART and shutdown TX and RX.
-  usart_reset(usart);
-
-  // Check input values.
-  if (!opt || // Null pointer.
-      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
-      opt-&gt;spimode &gt; 3 ||
-      opt-&gt;channelmode &gt; 3 ||
-      usart_set_spi_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  if (opt-&gt;charlength == 9)
-  {
-    // Character length set to 9 bits. MODE9 dominates CHRL.
-    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
-  }
-  else
-  {
-    // CHRL gives the character length (- 5) when MODE9 = 0.
-    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
-  }
-
-  usart-&gt;mr |= AVR32_USART_MR_MODE_SPI_MASTER &lt;&lt; AVR32_USART_MR_MODE_OFFSET | // SPI master mode.
-               ((opt-&gt;spimode &amp; 0x1) ^ 0x1) &lt;&lt; AVR32_USART_MR_SYNC_OFFSET |   // SPI clock phase.
-               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET |             // Channel mode.
-               (opt-&gt;spimode &gt;&gt; 1) &lt;&lt; AVR32_USART_MR_MSBF_OFFSET |            // SPI clock polarity.
-               AVR32_USART_MR_CLKO_MASK;                                      // Drive SCK pin.
-
-  // Setup complete; enable communication.
-  // Enable input and output.
-  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
-              AVR32_USART_CR_TXEN_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_init_spi_slave(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz)
-{
-  // Reset the USART and shutdown TX and RX.
-  usart_reset(usart);
-
-  // Check input values.
-  if (!opt || // Null pointer.
-      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
-      opt-&gt;spimode &gt; 3 ||
-      opt-&gt;channelmode &gt; 3 ||
-      usart_set_spi_slave_baudrate(usart) == USART_INVALID_INPUT)
-    return USART_INVALID_INPUT;
-
-  if (opt-&gt;charlength == 9)
-  {
-    // Character length set to 9 bits. MODE9 dominates CHRL.
-    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
-  }
-  else
-  {
-    // CHRL gives the character length (- 5) when MODE9 = 0.
-    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
-  }
-
-  usart-&gt;mr |= AVR32_USART_MR_MODE_SPI_SLAVE &lt;&lt; AVR32_USART_MR_MODE_OFFSET |  // SPI slave mode.
-               ((opt-&gt;spimode &amp; 0x1) ^ 0x1) &lt;&lt; AVR32_USART_MR_SYNC_OFFSET |   // SPI clock phase.
-               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET |             // Channel mode.
-               (opt-&gt;spimode &gt;&gt; 1) &lt;&lt; AVR32_USART_MR_MSBF_OFFSET;             // SPI clock polarity.
-
-  // Setup complete; enable communication.
-  // Enable input and output.
-  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
-              AVR32_USART_CR_TXEN_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-#endif
-
-
-//! @}
-
-
-//------------------------------------------------------------------------------
-#ifdef AVR32_USART_400_H_INCLUDED
-
-
-/*! \name SPI Control Functions
- */
-//! @{
-
-
-int usart_spi_selectChip(volatile avr32_usart_t *usart)
-{
-  // Force the SPI chip select.
-  usart-&gt;cr = AVR32_USART_CR_RTSEN_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-int usart_spi_unselectChip(volatile avr32_usart_t *usart)
-{
-  int timeout = USART_DEFAULT_TIMEOUT;
-
-  do
-  {
-    if (!timeout--) return USART_FAILURE;
-  } while (!usart_tx_empty(usart));
-
-  // Release the SPI chip select.
-  usart-&gt;cr = AVR32_USART_CR_RTSDIS_MASK;
-
-  return USART_SUCCESS;
-}
-
-
-//! @}
-
-
-#endif
-
-
-//------------------------------------------------------------------------------
-/*! \name Transmit/Receive Functions
- */
-//! @{
-
-
-int usart_send_address(volatile avr32_usart_t *usart, int address)
-{
-  // Check if USART is in multidrop / RS485 mode.
-  if (!usart_mode_is_multidrop(usart)) return USART_MODE_FAULT;
-
-  // Prepare to send an address.
-  usart-&gt;cr = AVR32_USART_CR_SENDA_MASK;
-
-  // Write the address to TX.
-  usart_bw_write_char(usart, address);
-
-  return USART_SUCCESS;
-}
-
-
-int usart_write_char(volatile avr32_usart_t *usart, int c)
-{
-  if (usart_tx_ready(usart))
-  {
-    usart-&gt;thr = (c &lt;&lt; AVR32_USART_THR_TXCHR_OFFSET) &amp; AVR32_USART_THR_TXCHR_MASK;
-    return USART_SUCCESS;
-  }
-  else
-    return USART_TX_BUSY;
-}
-
-
-int usart_putchar(volatile avr32_usart_t *usart, int c)
-{
-  while (usart_write_char(usart, c) != USART_SUCCESS);
-  return USART_SUCCESS;
-}
-
-
-int usart_read_char(volatile avr32_usart_t *usart, int *c)
-{
-  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
-  // would mean that an address char has been received.
-  if (usart-&gt;csr &amp; (AVR32_USART_CSR_OVRE_MASK |
-                    AVR32_USART_CSR_FRAME_MASK |
-                    AVR32_USART_CSR_PARE_MASK))
-    return USART_RX_ERROR;
-
-  // No error; if we really did receive a char, read it and return SUCCESS.
-  if (usart_test_hit(usart))
-  {
-    *c = (usart-&gt;rhr &amp; AVR32_USART_RHR_RXCHR_MASK) &gt;&gt; AVR32_USART_RHR_RXCHR_OFFSET;
-    return USART_SUCCESS;
-  }
-  else
-    return USART_RX_EMPTY;
-}
-
-
-int usart_getchar(volatile avr32_usart_t *usart)
-{
-  int c, ret;
-
-  while ((ret = usart_read_char(usart, &amp;c)) == USART_RX_EMPTY);
-
-  if (ret == USART_RX_ERROR)
-    return USART_FAILURE;
-
-  return c;
-}
-
-
-void usart_write_line(volatile avr32_usart_t *usart, const char *string)
-{
-  while (*string != '\0')
-    usart_putchar(usart, *string++);
-}
-
-
-int usart_get_echo_line(volatile avr32_usart_t *usart)
-{
-  int rx_char;
-  int retval = USART_SUCCESS;
-
-  while (1)
-  {
-    rx_char = usart_getchar(usart);
-    if (rx_char == USART_FAILURE)
-    {
-      usart_write_line(usart, &quot;Error!!!\n&quot;);
-      break;
-    }
-    if (rx_char == '\x03')
-    {
-      retval = USART_FAILURE;
-      break;
-    }
-    usart_putchar(usart, rx_char);
-    if (rx_char == '\r')
-    {
-      usart_putchar(usart, '\n');
-      break;
-    }
-  }
-
-  return retval;
-}
-
-
-//! @}
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief USART driver for AVR32 UC3.
+ *
+ * This file contains basic functions for the AVR32 USART, with support for all
+ * modes, settings and clock speeds.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a USART module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#include &quot;compiler.h&quot;
+#include &quot;usart.h&quot;
+
+
+//------------------------------------------------------------------------------
+/*! \name Private Functions
+ */
+//! @{
+
+
+/*! \brief Checks if the USART is in multidrop mode.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \return \c 1 if the USART is in multidrop mode, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+static __inline__ int usart_mode_is_multidrop(volatile avr32_usart_t *usart)
+{
+  return ((usart-&gt;mr &gt;&gt; AVR32_USART_MR_PAR_OFFSET) &amp; AVR32_USART_MR_PAR_MULTI) == AVR32_USART_MR_PAR_MULTI;
+}
+
+
+/*! \brief Calculates a clock divider (\e CD) and a fractional part (\e FP) for
+ *         the USART asynchronous modes to generate a baud rate as close as
+ *         possible to the baud rate set point.
+ *
+ * Baud rate calculation:
+ * \f$ Baudrate = \frac{SelectedClock}{Over \times (CD + \frac{FP}{8})} \f$, \e Over being 16 or 8.
+ * The maximal oversampling is selected if it allows to generate a baud rate close to the set point.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate set point.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Baud rate successfully initialized.
+ * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
+ */
+static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
+{
+  unsigned int over = (pba_hz &gt;= 16 * baudrate) ? 16 : 8;
+  unsigned int cd_fp = ((1 &lt;&lt; AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
+  unsigned int cd = cd_fp &gt;&gt; AVR32_USART_BRGR_FP_SIZE;
+  unsigned int fp = cd_fp &amp; ((1 &lt;&lt; AVR32_USART_BRGR_FP_SIZE) - 1);
+
+  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~(AVR32_USART_MR_USCLKS_MASK |
+                             AVR32_USART_MR_SYNC_MASK |
+                             AVR32_USART_MR_OVER_MASK)) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) &lt;&lt; AVR32_USART_MR_OVER_OFFSET;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET |
+                fp &lt;&lt; AVR32_USART_BRGR_FP_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Calculates a clock divider (\e CD) for the USART synchronous master
+ *         modes to generate a baud rate as close as possible to the baud rate
+ *         set point.
+ *
+ * Baud rate calculation:
+ * \f$ Baudrate = \frac{SelectedClock}{CD} \f$.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate set point.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Baud rate successfully initialized.
+ * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
+ */
+static int usart_set_sync_master_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
+{
+  unsigned int cd = (pba_hz + baudrate / 2) / baudrate;
+
+  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              AVR32_USART_MR_SYNC_MASK;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Selects the SCK pin as the source of baud rate for the USART
+ *         synchronous slave modes.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS  Baud rate successfully initialized.
+ */
+static int usart_set_sync_slave_baudrate(volatile avr32_usart_t *usart)
+{
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_SCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              AVR32_USART_MR_SYNC_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Calculates a clock divider (\e CD) for the USART ISO7816 mode to
+ *         generate an ISO7816 clock as close as possible to the clock set point.
+ *
+ * ISO7816 clock calculation:
+ * \f$ Clock = \frac{SelectedClock}{CD} \f$.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param clock   ISO7816 clock set point.
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        ISO7816 clock successfully initialized.
+ * \retval USART_INVALID_INPUT  ISO7816 clock set point is out of range for the given input clock frequency.
+ */
+static int usart_set_iso7816_clock(volatile avr32_usart_t *usart, unsigned int clock, unsigned long pba_hz)
+{
+  unsigned int cd = (pba_hz + clock / 2) / clock;
+
+  if (cd &lt; 1 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~(AVR32_USART_MR_USCLKS_MASK |
+                             AVR32_USART_MR_SYNC_MASK |
+                             AVR32_USART_MR_OVER_MASK)) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET |
+              AVR32_USART_MR_OVER_X16 &lt;&lt; AVR32_USART_MR_OVER_OFFSET;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+
+/*! \brief Calculates a clock divider (\e CD) for the USART SPI master mode to
+ *         generate a baud rate as close as possible to the baud rate set point.
+ *
+ * Baud rate calculation:
+ * \f$ Baudrate = \frac{SelectedClock}{CD} \f$.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate set point.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Baud rate successfully initialized.
+ * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
+ */
+static int usart_set_spi_master_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
+{
+  unsigned int cd = (pba_hz + baudrate / 2) / baudrate;
+
+  if (cd &lt; 4 || cd &gt; (1 &lt;&lt; AVR32_USART_BRGR_CD_SIZE) - 1)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_MCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET;
+
+  usart-&gt;brgr = cd &lt;&lt; AVR32_USART_BRGR_CD_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+/*! \brief Selects the SCK pin as the source of baud rate for the USART SPI
+ *         slave mode.
+ *
+ * \param usart Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS  Baud rate successfully initialized.
+ */
+static int usart_set_spi_slave_baudrate(volatile avr32_usart_t *usart)
+{
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_USCLKS_MASK) |
+              AVR32_USART_MR_USCLKS_SCK &lt;&lt; AVR32_USART_MR_USCLKS_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+#endif  // USART rev. &gt;= 4.0.0
+
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+/*! \name Initialization Functions
+ */
+//! @{
+
+
+void usart_reset(volatile avr32_usart_t *usart)
+{
+  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
+
+  // Disable all USART interrupts.
+  // Interrupts needed should be set explicitly on every reset.
+  if (global_interrupt_enabled) Disable_global_interrupt();
+  usart-&gt;idr = 0xFFFFFFFF;
+  usart-&gt;csr;
+  if (global_interrupt_enabled) Enable_global_interrupt();
+
+  // Reset mode and other registers that could cause unpredictable behavior after reset.
+  usart-&gt;mr = 0;
+  usart-&gt;rtor = 0;
+  usart-&gt;ttgr = 0;
+
+  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
+  // reset status bits and turn off DTR and RTS.
+  usart-&gt;cr = AVR32_USART_CR_RSTRX_MASK   |
+              AVR32_USART_CR_RSTTX_MASK   |
+              AVR32_USART_CR_RSTSTA_MASK  |
+              AVR32_USART_CR_RSTIT_MASK   |
+              AVR32_USART_CR_RSTNACK_MASK |
+#ifndef AVR32_USART_440_H_INCLUDED
+// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
+              AVR32_USART_CR_DTRDIS_MASK  |
+#endif
+              AVR32_USART_CR_RTSDIS_MASK;
+}
+
+
+int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_async_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1, 1.5 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_rs232_tx_only(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_sync_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  // Setup complete; enable communication.
+  // Enable only output as input is not possible in synchronous mode without
+  // transferring clock.
+  usart-&gt;cr = AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_hw_handshaking(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set hardware handshaking mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_HARDWARE &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_modem(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set modem mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_MODEM &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_sync_master(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_sync_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+              AVR32_USART_MR_CLKO_MASK;
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_sync_slave(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;paritytype &gt; 7 ||
+      opt-&gt;stopbits == 1 || opt-&gt;stopbits &gt; 2 + 255 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_sync_slave_baudrate(usart) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET;
+
+  if (opt-&gt;stopbits &gt; USART_2_STOPBITS)
+  {
+    // Set two stop bits
+    usart-&gt;mr |= AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+    // and a timeguard period gives the rest.
+    usart-&gt;ttgr = opt-&gt;stopbits - USART_2_STOPBITS;
+  }
+  else
+    // Insert 1 or 2 stop bits.
+    usart-&gt;mr |= opt-&gt;stopbits &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+
+  // Set normal mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_NORMAL &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_rs485(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set RS485 mode.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MR_MODE_RS485 &lt;&lt; AVR32_USART_MR_MODE_OFFSET;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_IrDA(volatile avr32_usart_t *usart, const usart_options_t *opt,
+                    long pba_hz, unsigned char irda_filter)
+{
+  // First: Setup standard RS232.
+  if (usart_init_rs232(usart, opt, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set IrDA filter.
+  usart-&gt;ifr = irda_filter;
+
+  // Set IrDA mode and activate filtering of input.
+  usart-&gt;mr = (usart-&gt;mr &amp; ~AVR32_USART_MR_MODE_MASK) |
+              AVR32_USART_MODE_IRDA &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+              AVR32_USART_MR_FILTER_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_iso7816(volatile avr32_usart_t *usart, const usart_iso7816_options_t *opt, int t, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;paritytype &gt; 1)
+    return USART_INVALID_INPUT;
+
+  if (t == 0)
+  {
+    // Set USART mode to ISO7816, T=0.
+    // The T=0 protocol always uses 2 stop bits.
+    usart-&gt;mr = AVR32_USART_MR_MODE_ISO7816_T0 &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+                AVR32_USART_MR_NBSTOP_2 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET |
+                opt-&gt;bit_order &lt;&lt; AVR32_USART_MR_MSBF_OFFSET; // Allow MSBF in T=0.
+  }
+  else if (t == 1)
+  {
+    // Only LSB first in the T=1 protocol.
+    // max_iterations field is only used in T=0 mode.
+    if (opt-&gt;bit_order != 0 ||
+        opt-&gt;max_iterations != 0)
+      return USART_INVALID_INPUT;
+
+    // Set USART mode to ISO7816, T=1.
+    // The T=1 protocol always uses 1 stop bit.
+    usart-&gt;mr = AVR32_USART_MR_MODE_ISO7816_T1 &lt;&lt; AVR32_USART_MR_MODE_OFFSET |
+                AVR32_USART_MR_NBSTOP_1 &lt;&lt; AVR32_USART_MR_NBSTOP_OFFSET;
+  }
+  else
+    return USART_INVALID_INPUT;
+
+  if (usart_set_iso7816_clock(usart, opt-&gt;iso7816_hz, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  // Set FIDI register: bit rate = selected clock/FI_DI_ratio/16.
+  usart-&gt;fidi = opt-&gt;fidi_ratio;
+
+  // Set ISO7816 spesific options in the MODE register.
+  usart-&gt;mr |= opt-&gt;paritytype &lt;&lt; AVR32_USART_MR_PAR_OFFSET |
+               AVR32_USART_MR_CLKO_MASK | // Enable clock output.
+               opt-&gt;inhibit_nack &lt;&lt; AVR32_USART_MR_INACK_OFFSET |
+               opt-&gt;dis_suc_nack &lt;&lt; AVR32_USART_MR_DSNACK_OFFSET |
+               opt-&gt;max_iterations &lt;&lt; AVR32_USART_MR_MAX_ITERATION_OFFSET;
+
+  // Setup complete; enable the receiver by default.
+  usart_iso7816_enable_receiver(usart);
+
+  return USART_SUCCESS;
+}
+
+
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+
+int usart_init_lin_master(volatile avr32_usart_t *usart, unsigned long baudrate, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (usart_set_async_baudrate(usart, baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr |= AVR32_USART_MR_MODE_LIN_MASTER &lt;&lt; AVR32_USART_MR_MODE_OFFSET;  // LIN master mode.
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_lin_slave(volatile avr32_usart_t *usart, unsigned long baudrate, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (usart_set_async_baudrate(usart, baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  usart-&gt;mr |= AVR32_USART_MR_MODE_LIN_SLAVE &lt;&lt; AVR32_USART_MR_MODE_OFFSET; // LIN slave mode.
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_spi_master(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;spimode &gt; 3 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_spi_master_baudrate(usart, opt-&gt;baudrate, pba_hz) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= AVR32_USART_MR_MODE_SPI_MASTER &lt;&lt; AVR32_USART_MR_MODE_OFFSET | // SPI master mode.
+               ((opt-&gt;spimode &amp; 0x1) ^ 0x1) &lt;&lt; AVR32_USART_MR_SYNC_OFFSET |   // SPI clock phase.
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET |             // Channel mode.
+               (opt-&gt;spimode &gt;&gt; 1) &lt;&lt; AVR32_USART_MR_MSBF_OFFSET |            // SPI clock polarity.
+               AVR32_USART_MR_CLKO_MASK;                                      // Drive SCK pin.
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_init_spi_slave(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz)
+{
+  // Reset the USART and shutdown TX and RX.
+  usart_reset(usart);
+
+  // Check input values.
+  if (!opt || // Null pointer.
+      opt-&gt;charlength &lt; 5 || opt-&gt;charlength &gt; 9 ||
+      opt-&gt;spimode &gt; 3 ||
+      opt-&gt;channelmode &gt; 3 ||
+      usart_set_spi_slave_baudrate(usart) == USART_INVALID_INPUT)
+    return USART_INVALID_INPUT;
+
+  if (opt-&gt;charlength == 9)
+  {
+    // Character length set to 9 bits. MODE9 dominates CHRL.
+    usart-&gt;mr |= AVR32_USART_MR_MODE9_MASK;
+  }
+  else
+  {
+    // CHRL gives the character length (- 5) when MODE9 = 0.
+    usart-&gt;mr |= (opt-&gt;charlength - 5) &lt;&lt; AVR32_USART_MR_CHRL_OFFSET;
+  }
+
+  usart-&gt;mr |= AVR32_USART_MR_MODE_SPI_SLAVE &lt;&lt; AVR32_USART_MR_MODE_OFFSET |  // SPI slave mode.
+               ((opt-&gt;spimode &amp; 0x1) ^ 0x1) &lt;&lt; AVR32_USART_MR_SYNC_OFFSET |   // SPI clock phase.
+               opt-&gt;channelmode &lt;&lt; AVR32_USART_MR_CHMODE_OFFSET |             // Channel mode.
+               (opt-&gt;spimode &gt;&gt; 1) &lt;&lt; AVR32_USART_MR_MSBF_OFFSET;             // SPI clock polarity.
+
+  // Setup complete; enable communication.
+  // Enable input and output.
+  usart-&gt;cr = AVR32_USART_CR_RXEN_MASK |
+              AVR32_USART_CR_TXEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+#endif  // USART rev. &gt;= 4.0.0
+
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+
+/*! \name SPI Control Functions
+ */
+//! @{
+
+
+int usart_spi_selectChip(volatile avr32_usart_t *usart)
+{
+  // Force the SPI chip select.
+  usart-&gt;cr = AVR32_USART_CR_RTSEN_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+int usart_spi_unselectChip(volatile avr32_usart_t *usart)
+{
+  int timeout = USART_DEFAULT_TIMEOUT;
+
+  do
+  {
+    if (!timeout--) return USART_FAILURE;
+  } while (!usart_tx_empty(usart));
+
+  // Release the SPI chip select.
+  usart-&gt;cr = AVR32_USART_CR_RTSDIS_MASK;
+
+  return USART_SUCCESS;
+}
+
+
+//! @}
+
+
+#endif  // USART rev. &gt;= 4.0.0
+
+
+//------------------------------------------------------------------------------
+/*! \name Transmit/Receive Functions
+ */
+//! @{
+
+
+int usart_send_address(volatile avr32_usart_t *usart, int address)
+{
+  // Check if USART is in multidrop / RS485 mode.
+  if (!usart_mode_is_multidrop(usart)) return USART_MODE_FAULT;
+
+  // Prepare to send an address.
+  usart-&gt;cr = AVR32_USART_CR_SENDA_MASK;
+
+  // Write the address to TX.
+  usart_bw_write_char(usart, address);
+
+  return USART_SUCCESS;
+}
+
+
+int usart_write_char(volatile avr32_usart_t *usart, int c)
+{
+  if (usart_tx_ready(usart))
+  {
+    usart-&gt;thr = (c &lt;&lt; AVR32_USART_THR_TXCHR_OFFSET) &amp; AVR32_USART_THR_TXCHR_MASK;
+    return USART_SUCCESS;
+  }
+  else
+    return USART_TX_BUSY;
+}
+
+
+int usart_putchar(volatile avr32_usart_t *usart, int c)
+{
+  int timeout = USART_DEFAULT_TIMEOUT;
+
+  if (c == '\n')
+  {
+    do
+    {
+      if (!timeout--) return USART_FAILURE;
+    } while (usart_write_char(usart, '\r') != USART_SUCCESS);
+
+    timeout = USART_DEFAULT_TIMEOUT;
+  }
+
+  do
+  {
+    if (!timeout--) return USART_FAILURE;
+  } while (usart_write_char(usart, c) != USART_SUCCESS);
+
+  return USART_SUCCESS;
+}
+
+
+int usart_read_char(volatile avr32_usart_t *usart, int *c)
+{
+  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
+  // would mean that an address char has been received.
+  if (usart-&gt;csr &amp; (AVR32_USART_CSR_OVRE_MASK |
+                    AVR32_USART_CSR_FRAME_MASK |
+                    AVR32_USART_CSR_PARE_MASK))
+    return USART_RX_ERROR;
+
+  // No error; if we really did receive a char, read it and return SUCCESS.
+  if (usart_test_hit(usart))
+  {
+    *c = (usart-&gt;rhr &amp; AVR32_USART_RHR_RXCHR_MASK) &gt;&gt; AVR32_USART_RHR_RXCHR_OFFSET;
+    return USART_SUCCESS;
+  }
+  else
+    return USART_RX_EMPTY;
+}
+
+
+int usart_getchar(volatile avr32_usart_t *usart)
+{
+  int c, ret;
+
+  while ((ret = usart_read_char(usart, &amp;c)) == USART_RX_EMPTY);
+
+  if (ret == USART_RX_ERROR)
+    return USART_FAILURE;
+
+  return c;
+}
+
+
+void usart_write_line(volatile avr32_usart_t *usart, const char *string)
+{
+  while (*string != '\0')
+    usart_putchar(usart, *string++);
+}
+
+
+int usart_get_echo_line(volatile avr32_usart_t *usart)
+{
+  int rx_char;
+  int retval = USART_SUCCESS;
+
+  while (1)
+  {
+    rx_char = usart_getchar(usart);
+    if (rx_char == USART_FAILURE)
+    {
+      usart_write_line(usart, &quot;Error!!!\n&quot;);
+      retval = USART_FAILURE;
+      break;
+    }
+    if (rx_char == '\x03')
+    {
+      retval = USART_FAILURE;
+      break;
+    }
+    usart_putchar(usart, rx_char);
+    if (rx_char == '\r')
+    {
+      usart_putchar(usart, '\n');
+      break;
+    }
+  }
+
+  return retval;
+}
+
+
+//! @}

Modified: trunk/src/platform/avr32/usart.h
===================================================================
--- trunk/src/platform/avr32/usart.h	2010-02-23 17:18:06 UTC (rev 725)
+++ trunk/src/platform/avr32/usart.h	2010-02-24 19:45:50 UTC (rev 726)
@@ -1,606 +1,882 @@
-/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+/* This header file is part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
 
-/*This file is prepared for Doxygen automatic documentation generation.*/
-/*! \file *********************************************************************
- *
- * \brief USART driver for AVR32 UC3.
- *
- * This file contains basic functions for the AVR32 USART, with support for all
- * modes, settings and clock speeds.
- *
- * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
- * - Supported devices:  All AVR32 devices with a USART module can be used.
- * - AppNote:
- *
- * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
- *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
- *
- ******************************************************************************/
-
-/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. The name of ATMEL may not be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
- * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#ifndef _USART_H_
-#define _USART_H_
-
-#include &lt;avr32/io.h&gt;
-#include &quot;compiler.h&quot;
-
-
-/*! \name Return Values
- */
-//! @{
-#define USART_SUCCESS           0 //!&lt; Successful completion.
-#define USART_FAILURE          -1 //!&lt; Failure because of some unspecified reason.
-#define USART_INVALID_INPUT     1 //!&lt; Input value out of range.
-#define USART_INVALID_ARGUMENT -1 //!&lt; Argument value out of range.
-#define USART_TX_BUSY           2 //!&lt; Transmitter was busy.
-#define USART_RX_EMPTY          3 //!&lt; Nothing was received.
-#define USART_RX_ERROR          4 //!&lt; Transmission error occurred.
-#define USART_MODE_FAULT        5 //!&lt; USART not in the appropriate mode.
-//! @}
-
-//! Default time-out value (number of attempts).
-#define USART_DEFAULT_TIMEOUT   10000
-
-/*! \name Parity Settings
- */
-//! @{
-#define USART_EVEN_PARITY       AVR32_USART_MR_PAR_EVEN   //!&lt; Use even parity on character transmission.
-#define USART_ODD_PARITY        AVR32_USART_MR_PAR_ODD    //!&lt; Use odd parity on character transmission.
-#define USART_SPACE_PARITY      AVR32_USART_MR_PAR_SPACE  //!&lt; Use a space as parity bit.
-#define USART_MARK_PARITY       AVR32_USART_MR_PAR_MARK   //!&lt; Use a mark as parity bit.
-#define USART_NO_PARITY         AVR32_USART_MR_PAR_NONE   //!&lt; Don't use a parity bit.
-#define USART_MULTIDROP_PARITY  AVR32_USART_MR_PAR_MULTI  //!&lt; Parity bit is used to flag address characters.
-//! @}
-
-/*! \name Stop Bits Settings
- */
-//! @{
-#define USART_1_STOPBIT         AVR32_USART_MR_NBSTOP_1   //!&lt; Use 1 stop bit.
-#define USART_1_5_STOPBITS      AVR32_USART_MR_NBSTOP_1_5 //!&lt; Use 1.5 stop bits.
-#define USART_2_STOPBITS        AVR32_USART_MR_NBSTOP_2   //!&lt; Use 2 stop bits (for more, just give the number of bits).
-//! @}
-
-/*! \name Channel Modes
- */
-//! @{
-#define USART_NORMAL_CHMODE     AVR32_USART_MR_CHMODE_NORMAL      //!&lt; Normal communication.
-#define USART_AUTO_ECHO         AVR32_USART_MR_CHMODE_ECHO        //!&lt; Echo data.
-#define USART_LOCAL_LOOPBACK    AVR32_USART_MR_CHMODE_LOCAL_LOOP  //!&lt; Local loopback.
-#define USART_REMOTE_LOOPBACK   AVR32_USART_MR_CHMODE_REMOTE_LOOP //!&lt; Remote loopback.
-//! @}
-
-
-//! Input parameters when initializing RS232 and similar modes.
-typedef struct
-{
-  //! Set baud rate of the USART (unused in slave modes).
-  unsigned long baudrate;
-
-  //! Number of bits to transmit as a character (5 to 9).
-  unsigned char charlength;
-
-  //! How to calculate the parity bit: \ref USART_EVEN_PARITY, \ref USART_ODD_PARITY,
-  //! \ref USART_SPACE_PARITY, \ref USART_MARK_PARITY, \ref USART_NO_PARITY or
-  //! \ref USART_MULTIDROP_PARITY.
-  unsigned char paritytype;
-
-  //! Number of stop bits between two characters: \ref USART_1_STOPBIT,
-  //! \ref USART_1_5_STOPBITS, \ref USART_2_STOPBITS or any number from 3 to 257
-  //! which will result in a time guard period of that length between characters.
-  //! \note \ref USART_1_5_STOPBITS is supported in asynchronous modes only.
-  unsigned short stopbits;
-
-  //! Run the channel in testmode: \ref USART_NORMAL_CHMODE, \ref USART_AUTO_ECHO,
-  //! \ref USART_LOCAL_LOOPBACK or \ref USART_REMOTE_LOOPBACK.
-  unsigned char channelmode;
-} usart_options_t;
-
-//! Input parameters when initializing ISO7816 mode.
-typedef struct
-{
-  //! Set the frequency of the ISO7816 clock.
-  unsigned long iso7816_hz;
-
-  //! The number of ISO7816 clock ticks in every bit period (1 to 2047, 0 = disable clock).
-  //! Bit rate = \ref iso7816_hz / \ref fidi_ratio.
-  unsigned short fidi_ratio;
-
-  //! How to calculate the parity bit: \ref USART_EVEN_PARITY for normal mode or
-  //! \ref USART_ODD_PARITY for inverse mode.
-  unsigned char paritytype;
-
-  //! Inhibit Non Acknowledge:\n
-  //!   - 0: the NACK is generated;\n
-  //!   - 1: the NACK is not generated.
-  //!
-  //! \note This bit will be used only in ISO7816 mode, protocol T = 0 receiver.
-  int inhibit_nack;
-
-  //! Disable successive NACKs.
-  //! Successive parity errors are counted up to the value in the \ref max_iterations field.
-  //! These parity errors generate a NACK on the ISO line. As soon as this value is reached,
-  //! no addititional NACK is sent on the ISO line. The ITERATION flag is asserted.
-  int dis_suc_nack;
-
-  //! Max number of repetitions (0 to 7).
-  unsigned char max_iterations;
-
-  //! Bit order in transmitted characters:\n
-  //!   - 0: LSB first;\n
-  //!   - 1: MSB first.
-  int bit_order;
-} usart_iso7816_options_t;
-
-#ifdef AVR32_USART_400_H_INCLUDED
-
-//! Input parameters when initializing SPI mode.
-typedef struct
-{
-  //! Set the frequency of the SPI clock (unused in slave mode).
-  unsigned long baudrate;
-
-  //! Number of bits to transmit as a character (5 to 9).
-  unsigned char charlength;
-
-  //! Which SPI mode to use.
-  unsigned char spimode;
-
-  //! Run the channel in testmode: \ref USART_NORMAL_CHMODE, \ref USART_AUTO_ECHO,
-  //! \ref USART_LOCAL_LOOPBACK or \ref USART_REMOTE_LOOPBACK.
-  unsigned char channelmode;
-} usart_spi_options_t;
-
-#endif
-
-
-//------------------------------------------------------------------------------
-/*! \name Initialization Functions
- */
-//! @{
-
-/*! \brief Resets the USART and disables TX and RX.
- *
- * \param usart Base address of the USART instance.
- */
-extern void usart_reset(volatile avr32_usart_t *usart);
-
-/*! \brief Sets up the USART to use the standard RS232 protocol.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use the standard RS232 protocol in TX-only mode.
- *
- * Compared to \ref usart_init_rs232, this function allows very high baud rates
- * (up to \a pba_hz instead of \a pba_hz / \c 8) at the expense of full duplex.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- *
- * \note The \c 1.5 stop bit is not supported in this mode.
- */
-extern int usart_init_rs232_tx_only(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use hardware handshaking.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- *
- * \note \ref usart_init_rs232 does not need to be invoked before this function.
- */
-extern int usart_init_hw_handshaking(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use the modem protocol, activating dedicated inputs/outputs.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_modem(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use a synchronous RS232-like protocol in master mode.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_sync_master(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use a synchronous RS232-like protocol in slave mode.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_sync_slave(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use the RS485 protocol.
- *
- * \param usart       Base address of the USART instance.
- * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz      USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_rs485(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use the IrDA protocol.
- *
- * \param usart       Base address of the USART instance.
- * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
- * \param pba_hz      USART module input clock frequency (PBA clock, Hz).
- * \param irda_filter Counter used to distinguish received ones from zeros.
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_IrDA(volatile avr32_usart_t *usart, const usart_options_t *opt,
-                           long pba_hz, unsigned char irda_filter);
-
-/*! \brief Sets up the USART to use the ISO7816 T=0 or T=1 smartcard protocols.
- *
- * The receiver is enabled by default. \ref usart_iso7816_enable_receiver and
- * \ref usart_iso7816_enable_transmitter can be called to change the half-duplex
- * communication direction.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up ISO7816 communication (see \ref usart_iso7816_options_t).
- * \param t       ISO7816 mode to use (T=0 or T=1).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_iso7816(volatile avr32_usart_t *usart, const usart_iso7816_options_t *opt, int t, long pba_hz);
-
-#ifdef AVR32_USART_400_H_INCLUDED
-
-/*! \brief Sets up the USART to use the SPI master mode.
- *
- * \ref usart_spi_selectChip and \ref usart_spi_unselectChip can be called to
- * select or unselect the SPI slave chip.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up SPI mode (see \ref usart_spi_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_spi_master(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz);
-
-/*! \brief Sets up the USART to use the SPI slave mode.
- *
- * \param usart   Base address of the USART instance.
- * \param opt     Options needed to set up SPI mode (see \ref usart_spi_options_t).
- * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
- *
- * \retval USART_SUCCESS        Mode successfully initialized.
- * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
- */
-extern int usart_init_spi_slave(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz);
-
-#endif
-
-//! @}
-
-
-//------------------------------------------------------------------------------
-/*! \name Read and Reset Error Status Bits
- */
-//! @{
-
-/*! \brief Resets the error status.
- *
- * This function resets the status bits indicating that a parity error,
- * framing error or overrun has occurred. The RXBRK bit, indicating
- * a start/end of break condition on the RX line, is also reset.
- *
- * \param usart Base address of the USART instance.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void usart_reset_status(volatile avr32_usart_t *usart)
-{
-  usart-&gt;cr = AVR32_USART_CR_RSTSTA_MASK;
-}
-
-/*! \brief Checks if a parity error has occurred since last status reset.
- *
- * \param usart Base address of the USART instance.
- *
- * \return \c 1 if a parity error has been detected, otherwise \c 0.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ int usart_parity_error(volatile avr32_usart_t *usart)
-{
-  return (usart-&gt;csr &amp; AVR32_USART_CSR_PARE_MASK) != 0;
-}
-
-/*! \brief Checks if a framing error has occurred since last status reset.
- *
- * \param usart Base address of the USART instance.
- *
- * \return \c 1 if a framing error has been detected, otherwise \c 0.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ int usart_framing_error(volatile avr32_usart_t *usart)
-{
-  return (usart-&gt;csr &amp; AVR32_USART_CSR_FRAME_MASK) != 0;
-}
-
-/*! \brief Checks if an overrun error has occurred since last status reset.
- *
- * \param usart Base address of the USART instance.
- *
- * \return \c 1 if a overrun error has been detected, otherwise \c 0.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ int usart_overrun_error(volatile avr32_usart_t *usart)
-{
-  return (usart-&gt;csr &amp; AVR32_USART_CSR_OVRE_MASK) != 0;
-}
-
-//! @}
-
-
-//------------------------------------------------------------------------------
-/*! \name ISO7816 Control Functions
- */
-//! @{
-
-/*! \brief Enables the ISO7816 receiver.
- *
- * The ISO7816 transmitter is disabled.
- *
- * \param usart   Base address of the USART instance.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void usart_iso7816_enable_receiver(volatile avr32_usart_t *usart)
-{
-  usart-&gt;cr = AVR32_USART_CR_TXDIS_MASK | AVR32_USART_CR_RXEN_MASK;
-}
-
-/*! \brief Enables the ISO7816 transmitter.
- *
- * The ISO7816 receiver is disabled.
- *
- * \param usart   Base address of the USART instance.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void usart_iso7816_enable_transmitter(volatile avr32_usart_t *usart)
-{
-  usart-&gt;cr = AVR32_USART_CR_RXDIS_MASK | AVR32_USART_CR_TXEN_MASK;
-}
-
-//! @}
-
-
-//------------------------------------------------------------------------------
-#ifdef AVR32_USART_400_H_INCLUDED
-
-/*! \name SPI Control Functions
- */
-//! @{
-
-/*! \brief Selects SPI slave chip.
- *
- * \param usart   Base address of the USART instance.
- *
- * \retval USART_SUCCESS        Success.
- */
-extern int usart_spi_selectChip(volatile avr32_usart_t *usart);
-
-/*! \brief Unselects SPI slave chip.
- *
- * \param usart   Base address of the USART instance.
- *
- * \retval USART_SUCCESS        Success.
- * \retval USART_FAILURE        Time-out.
- */
-extern int usart_spi_unselectChip(volatile avr32_usart_t *usart);
-
-//! @}
-
-#endif
-
-
-//------------------------------------------------------------------------------
-/*! \name Transmit/Receive Functions
- */
-//! @{
-
-/*! \brief Addresses a receiver.
- *
- * While in RS485 mode, receivers only accept data addressed to them.
- * A packet/char with the address tag set has to precede any data.
- * This function is used to address a receiver. This receiver should read
- * all the following data, until an address packet addresses another receiver.
- *
- * \param usart   Base address of the USART instance.
- * \param address Address of the target device.
- *
- * \retval USART_SUCCESS    Address successfully sent (if current mode is RS485).
- * \retval USART_MODE_FAULT Wrong operating mode.
- */
-extern int usart_send_address(volatile avr32_usart_t *usart, int address);
-
-/*! \brief Tests if the USART is ready to transmit a character.
- *
- * \param usart Base address of the USART instance.
- *
- * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ int usart_tx_ready(volatile avr32_usart_t *usart)
-{
-  return (usart-&gt;csr &amp; AVR32_USART_CSR_TXRDY_MASK) != 0;
-}
-
-/*! \brief Writes the given character to the TX buffer if the transmitter is ready.
- *
- * \param usart Base address of the USART instance.
- * \param c     The character (up to 9 bits) to transmit.
- *
- * \retval USART_SUCCESS  The transmitter was ready.
- * \retval USART_TX_BUSY  The transmitter was busy.
- */
-extern int usart_write_char(volatile avr32_usart_t *usart, int c);
-
-/*! \brief An active wait writing a character to the USART.
- *
- * \param usart Base address of the USART instance.
- * \param c     The character (up to 9 bits) to transmit.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ void usart_bw_write_char(volatile avr32_usart_t *usart, int c)
-{
-  while (usart_write_char(usart, c) != USART_SUCCESS);
-}
-
-/*! \brief Sends a character with the USART.
- *
- * \param usart Base address of the USART instance.
- * \param c     Character to write.
- *
- * \retval USART_SUCCESS  The character was written.
- * \retval USART_FAILURE  The function timed out before the USART transmitter became ready to send.
- */
-extern int usart_putchar(volatile avr32_usart_t *usart, int c);
-
-/*! \brief Tests if all requested USART transmissions are over.
- *
- * \param usart Base address of the USART instance.
- *
- * \return \c 1 if the USART Transmit Shift Register and the USART Transmit
- *         Holding Register are free, otherwise \c 0.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ int usart_tx_empty(volatile avr32_usart_t *usart)
-{
-  return (usart-&gt;csr &amp; AVR32_USART_CSR_TXEMPTY_MASK) != 0;
-}
-
-/*! \brief Tests if the USART contains a received character.
- *
- * \param usart Base address of the USART instance.
- *
- * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
- */
-#if __GNUC__
-__attribute__((__always_inline__))
-#endif
-extern __inline__ int usart_test_hit(volatile avr32_usart_t *usart)
-{
-  return (usart-&gt;csr &amp; AVR32_USART_CSR_RXRDY_MASK) != 0;
-}
-
-/*! \brief Checks the RX buffer for a received character, and stores it at the
- *         given memory location.
- *
- * \param usart Base address of the USART instance.
- * \param c     Pointer to the where the read character should be stored
- *              (must be at least short in order to accept 9-bit characters).
- *
- * \retval USART_SUCCESS  The character was read successfully.
- * \retval USART_RX_EMPTY The RX buffer was empty.
- * \retval USART_RX_ERROR An error was deteceted.
- */
-extern int usart_read_char(volatile avr32_usart_t *usart, int *c);
-
-/*! \brief Waits until a character is received, and returns it.
- *
- * \param usart Base address of the USART instance.
- *
- * \return The received character, or \ref USART_FAILURE upon error.
- */
-extern int usart_getchar(volatile avr32_usart_t *usart);
-
-/*! \brief Writes one character string to the USART.
- *
- * \param usart   Base address of the USART instance.
- * \param string  String to be written.
- */
-extern void usart_write_line(volatile avr32_usart_t *usart, const char *string);
-
-/*! \brief Gets and echoes characters until end of line.
- *
- * \param usart Base address of the USART instance.
- *
- * \retval USART_SUCCESS  Success.
- * \retval USART_FAILURE  ETX character received.
- */
-extern int usart_get_echo_line(volatile avr32_usart_t *usart);
-
-//! @}
-
-
-#endif  // _USART_H_
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief USART driver for AVR32 UC3.
+ *
+ * This file contains basic functions for the AVR32 USART, with support for all
+ * modes, settings and clock speeds.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with a USART module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _USART_H_
+#define _USART_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;compiler.h&quot;
+
+
+/*! \name Return Values
+ */
+//! @{
+#define USART_SUCCESS                 0 //!&lt; Successful completion.
+#define USART_FAILURE                -1 //!&lt; Failure because of some unspecified reason.
+#define USART_INVALID_INPUT           1 //!&lt; Input value out of range.
+#define USART_INVALID_ARGUMENT       -1 //!&lt; Argument value out of range.
+#define USART_TX_BUSY                 2 //!&lt; Transmitter was busy.
+#define USART_RX_EMPTY                3 //!&lt; Nothing was received.
+#define USART_RX_ERROR                4 //!&lt; Transmission error occurred.
+#define USART_MODE_FAULT              5 //!&lt; USART not in the appropriate mode.
+//! @}
+
+//! Default time-out value (number of attempts).
+#define USART_DEFAULT_TIMEOUT         10000
+
+/*! \name Parity Settings
+ */
+//! @{
+#define USART_EVEN_PARITY             AVR32_USART_MR_PAR_EVEN   //!&lt; Use even parity on character transmission.
+#define USART_ODD_PARITY              AVR32_USART_MR_PAR_ODD    //!&lt; Use odd parity on character transmission.
+#define USART_SPACE_PARITY            AVR32_USART_MR_PAR_SPACE  //!&lt; Use a space as parity bit.
+#define USART_MARK_PARITY             AVR32_USART_MR_PAR_MARK   //!&lt; Use a mark as parity bit.
+#define USART_NO_PARITY               AVR32_USART_MR_PAR_NONE   //!&lt; Don't use a parity bit.
+#define USART_MULTIDROP_PARITY        AVR32_USART_MR_PAR_MULTI  //!&lt; Parity bit is used to flag address characters.
+//! @}
+
+/*! \name Stop Bits Settings
+ */
+//! @{
+#define USART_1_STOPBIT               AVR32_USART_MR_NBSTOP_1   //!&lt; Use 1 stop bit.
+#define USART_1_5_STOPBITS            AVR32_USART_MR_NBSTOP_1_5 //!&lt; Use 1.5 stop bits.
+#define USART_2_STOPBITS              AVR32_USART_MR_NBSTOP_2   //!&lt; Use 2 stop bits (for more, just give the number of bits).
+//! @}
+
+/*! \name Channel Modes
+ */
+//! @{
+#define USART_NORMAL_CHMODE           AVR32_USART_MR_CHMODE_NORMAL      //!&lt; Normal communication.
+#define USART_AUTO_ECHO               AVR32_USART_MR_CHMODE_ECHO        //!&lt; Echo data.
+#define USART_LOCAL_LOOPBACK          AVR32_USART_MR_CHMODE_LOCAL_LOOP  //!&lt; Local loopback.
+#define USART_REMOTE_LOOPBACK         AVR32_USART_MR_CHMODE_REMOTE_LOOP //!&lt; Remote loopback.
+//! @}
+
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+/*! \name LIN Node Actions
+ */
+//! @{
+#define USART_LIN_PUBLISH_ACTION      AVR32_USART_LINMR_NACT_PUBLISH    //!&lt; The USART transmits the response.
+#define USART_LIN_SUBSCRIBE_ACTION    AVR32_USART_LINMR_NACT_SUBSCRIBE  //!&lt; The USART receives the response.
+#define USART_LIN_IGNORE_ACTION       AVR32_USART_LINMR_NACT_IGNORE     //!&lt; The USART does not transmit and does not receive the reponse.
+//! @}
+
+/*! \name LIN Checksum Types
+ */
+//! @{
+#define USART_LIN_ENHANCED_CHECKSUM   0 //!&lt; LIN 2.0 &quot;enhanced&quot; checksum.
+#define USART_LIN_CLASSIC_CHECKSUM    1 //!&lt; LIN 1.3 &quot;classic&quot; checksum.
+//! @}
+
+#endif  // USART rev. &gt;= 4.0.0
+
+
+//! Input parameters when initializing RS232 and similar modes.
+typedef struct
+{
+  //! Set baud rate of the USART (unused in slave modes).
+  unsigned long baudrate;
+
+  //! Number of bits to transmit as a character (5 to 9).
+  unsigned char charlength;
+
+  //! How to calculate the parity bit: \ref USART_EVEN_PARITY, \ref USART_ODD_PARITY,
+  //! \ref USART_SPACE_PARITY, \ref USART_MARK_PARITY, \ref USART_NO_PARITY or
+  //! \ref USART_MULTIDROP_PARITY.
+  unsigned char paritytype;
+
+  //! Number of stop bits between two characters: \ref USART_1_STOPBIT,
+  //! \ref USART_1_5_STOPBITS, \ref USART_2_STOPBITS or any number from 3 to 257
+  //! which will result in a time guard period of that length between characters.
+  //! \note \ref USART_1_5_STOPBITS is supported in asynchronous modes only.
+  unsigned short stopbits;
+
+  //! Run the channel in testmode: \ref USART_NORMAL_CHMODE, \ref USART_AUTO_ECHO,
+  //! \ref USART_LOCAL_LOOPBACK or \ref USART_REMOTE_LOOPBACK.
+  unsigned char channelmode;
+} usart_options_t;
+
+//! Input parameters when initializing ISO7816 mode.
+typedef struct
+{
+  //! Set the frequency of the ISO7816 clock.
+  unsigned long iso7816_hz;
+
+  //! The number of ISO7816 clock ticks in every bit period (1 to 2047, 0 = disable clock).
+  //! Bit rate = \ref iso7816_hz / \ref fidi_ratio.
+  unsigned short fidi_ratio;
+
+  //! How to calculate the parity bit: \ref USART_EVEN_PARITY for normal mode or
+  //! \ref USART_ODD_PARITY for inverse mode.
+  unsigned char paritytype;
+
+  //! Inhibit Non Acknowledge:\n
+  //!   - 0: the NACK is generated;\n
+  //!   - 1: the NACK is not generated.
+  //!
+  //! \note This bit will be used only in ISO7816 mode, protocol T = 0 receiver.
+  int inhibit_nack;
+
+  //! Disable successive NACKs.
+  //! Successive parity errors are counted up to the value in the \ref max_iterations field.
+  //! These parity errors generate a NACK on the ISO line. As soon as this value is reached,
+  //! no addititional NACK is sent on the ISO line. The ITERATION flag is asserted.
+  int dis_suc_nack;
+
+  //! Max number of repetitions (0 to 7).
+  unsigned char max_iterations;
+
+  //! Bit order in transmitted characters:\n
+  //!   - 0: LSB first;\n
+  //!   - 1: MSB first.
+  int bit_order;
+} usart_iso7816_options_t;
+
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+//! Input parameters when initializing SPI mode.
+typedef struct
+{
+  //! Set the frequency of the SPI clock (unused in slave mode).
+  unsigned long baudrate;
+
+  //! Number of bits to transmit as a character (5 to 9).
+  unsigned char charlength;
+
+  //! Which SPI mode to use.
+  unsigned char spimode;
+
+  //! Run the channel in testmode: \ref USART_NORMAL_CHMODE, \ref USART_AUTO_ECHO,
+  //! \ref USART_LOCAL_LOOPBACK or \ref USART_REMOTE_LOOPBACK.
+  unsigned char channelmode;
+} usart_spi_options_t;
+
+#endif  // USART rev. &gt;= 4.0.0
+
+
+//------------------------------------------------------------------------------
+/*! \name Initialization Functions
+ */
+//! @{
+
+/*! \brief Resets the USART and disables TX and RX.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+extern void usart_reset(volatile avr32_usart_t *usart);
+
+/*! \brief Sets up the USART to use the standard RS232 protocol.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the standard RS232 protocol in TX-only mode.
+ *
+ * Compared to \ref usart_init_rs232, this function allows very high baud rates
+ * (up to \a pba_hz instead of \a pba_hz / \c 8) at the expense of full duplex.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ *
+ * \note The \c 1.5 stop bit is not supported in this mode.
+ */
+extern int usart_init_rs232_tx_only(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use hardware handshaking.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ *
+ * \note \ref usart_init_rs232 does not need to be invoked before this function.
+ */
+extern int usart_init_hw_handshaking(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the modem protocol, activating dedicated inputs/outputs.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_modem(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use a synchronous RS232-like protocol in master mode.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_sync_master(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use a synchronous RS232-like protocol in slave mode.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_sync_slave(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the RS485 protocol.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_rs485(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the IrDA protocol.
+ *
+ * \param usart         Base address of the USART instance.
+ * \param opt           Options needed to set up RS232 communication (see \ref usart_options_t).
+ * \param pba_hz        USART module input clock frequency (PBA clock, Hz).
+ * \param irda_filter   Counter used to distinguish received ones from zeros.
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_IrDA(volatile avr32_usart_t *usart, const usart_options_t *opt,
+                           long pba_hz, unsigned char irda_filter);
+
+/*! \brief Sets up the USART to use the ISO7816 T=0 or T=1 smartcard protocols.
+ *
+ * The receiver is enabled by default. \ref usart_iso7816_enable_receiver and
+ * \ref usart_iso7816_enable_transmitter can be called to change the half-duplex
+ * communication direction.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up ISO7816 communication (see \ref usart_iso7816_options_t).
+ * \param t       ISO7816 mode to use (T=0 or T=1).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_iso7816(volatile avr32_usart_t *usart, const usart_iso7816_options_t *opt, int t, long pba_hz);
+
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+/*! \brief Sets up the USART to use the LIN master mode.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ */
+extern int usart_init_lin_master(volatile avr32_usart_t *usart, unsigned long baudrate, long pba_hz);
+
+/*! \brief Sets up the USART to use the LIN slave mode.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param baudrate  Baud rate.
+ * \param pba_hz    USART module input clock frequency (PBA clock, Hz).
+ *
+ */
+extern int usart_init_lin_slave(volatile avr32_usart_t *usart, unsigned long baudrate, long pba_hz);
+
+/*! \brief Sets up the USART to use the SPI master mode.
+ *
+ * \ref usart_spi_selectChip and \ref usart_spi_unselectChip can be called to
+ * select or unselect the SPI slave chip.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up SPI mode (see \ref usart_spi_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_spi_master(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz);
+
+/*! \brief Sets up the USART to use the SPI slave mode.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param opt     Options needed to set up SPI mode (see \ref usart_spi_options_t).
+ * \param pba_hz  USART module input clock frequency (PBA clock, Hz).
+ *
+ * \retval USART_SUCCESS        Mode successfully initialized.
+ * \retval USART_INVALID_INPUT  One or more of the arguments is out of valid range.
+ */
+extern int usart_init_spi_slave(volatile avr32_usart_t *usart, const usart_spi_options_t *opt, long pba_hz);
+
+#endif  // USART rev. &gt;= 4.0.0
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+/*! \name Read and Reset Error Status Bits
+ */
+//! @{
+
+/*! \brief Resets the error status.
+ *
+ * This function resets the status bits indicating that a parity error,
+ * framing error or overrun has occurred. The RXBRK bit, indicating
+ * a start/end of break condition on the RX line, is also reset.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_reset_status(volatile avr32_usart_t *usart)
+{
+  usart-&gt;cr = AVR32_USART_CR_RSTSTA_MASK;
+}
+
+/*! \brief Checks if a parity error has occurred since last status reset.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return \c 1 if a parity error has been detected, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_parity_error(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_PARE_MASK) != 0;
+}
+
+/*! \brief Checks if a framing error has occurred since last status reset.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return \c 1 if a framing error has been detected, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_framing_error(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_FRAME_MASK) != 0;
+}
+
+/*! \brief Checks if an overrun error has occurred since last status reset.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return \c 1 if a overrun error has been detected, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_overrun_error(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_OVRE_MASK) != 0;
+}
+
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+/*! \brief Get LIN Error Status
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \retval The binary value of the error field.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_lin_get_error(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; (AVR32_USART_CSR_LINSNRE_MASK |
+                        AVR32_USART_CSR_LINCE_MASK |
+                        AVR32_USART_CSR_LINIPE_MASK |
+                        AVR32_USART_CSR_LINISFE_MASK |
+                        AVR32_USART_CSR_LINBE_MASK)) &gt;&gt; AVR32_USART_CSR_LINBE_OFFSET;
+}
+
+#endif  // USART rev. &gt;= 4.0.0
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+/*! \name ISO7816 Control Functions
+ */
+//! @{
+
+/*! \brief Enables the ISO7816 receiver.
+ *
+ * The ISO7816 transmitter is disabled.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_iso7816_enable_receiver(volatile avr32_usart_t *usart)
+{
+  usart-&gt;cr = AVR32_USART_CR_TXDIS_MASK | AVR32_USART_CR_RXEN_MASK;
+}
+
+/*! \brief Enables the ISO7816 transmitter.
+ *
+ * The ISO7816 receiver is disabled.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_iso7816_enable_transmitter(volatile avr32_usart_t *usart)
+{
+  usart-&gt;cr = AVR32_USART_CR_RXDIS_MASK | AVR32_USART_CR_TXEN_MASK;
+}
+
+//! @}
+
+
+//------------------------------------------------------------------------------
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+/*! \name LIN Control Functions
+ */
+//! @{
+
+/*! \brief Sets the node action.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param action  The node action: \ref USART_LIN_PUBLISH_ACTION,
+ *                \ref USART_LIN_SUBSCRIBE_ACTION or
+ *                \ref USART_LIN_IGNORE_ACTION.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_set_node_action(volatile avr32_usart_t *usart, unsigned char action)
+{
+  usart-&gt;linmr = (usart-&gt;linmr &amp; ~AVR32_USART_LINMR_NACT_MASK) |
+                 action &lt;&lt; AVR32_USART_LINMR_NACT_OFFSET;
+}
+
+/*! \brief Enables or disables the Identifier parity.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param parity  Whether to enable the Identifier parity: \c TRUE or \c FALSE.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_enable_parity(volatile avr32_usart_t *usart, unsigned char parity)
+{
+  usart-&gt;linmr = (usart-&gt;linmr &amp; ~AVR32_USART_LINMR_PARDIS_MASK) |
+                 !parity &lt;&lt; AVR32_USART_LINMR_PARDIS_OFFSET;
+}
+
+/*! \brief Enables or disables the checksum.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param parity  Whether to enable the checksum: \c TRUE or \c FALSE.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_enable_checksum(volatile avr32_usart_t *usart, unsigned char checksum)
+{
+  usart-&gt;linmr = (usart-&gt;linmr &amp; ~AVR32_USART_LINMR_CHKDIS_MASK) |
+                 !checksum &lt;&lt; AVR32_USART_LINMR_CHKDIS_OFFSET;
+}
+
+/*! \brief Sets the checksum type.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param chktyp  The checksum type: \ref USART_LIN_ENHANCED_CHEKSUM or
+ *                \ref USART_LIN_CLASSIC_CHECKSUM.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_set_checksum(volatile avr32_usart_t *usart, unsigned char chktyp)
+{
+  usart-&gt;linmr = (usart-&gt;linmr &amp; ~AVR32_USART_LINMR_CHKTYP_MASK) |
+                 chktyp &lt;&lt; AVR32_USART_LINMR_CHKTYP_OFFSET;
+}
+
+/*! \brief Gets the response data length.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return The response data length.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ unsigned char usart_lin_get_data_length(volatile avr32_usart_t *usart)
+{
+  if (usart-&gt;linmr &amp; AVR32_USART_LINMR_DLM_MASK)
+  {
+    unsigned char data_length = 1 &lt;&lt; ((usart-&gt;linir &gt;&gt; (AVR32_USART_LINIR_IDCHR_OFFSET + 4)) &amp; 0x03);
+    if (data_length == 1)
+      data_length = 2;
+    return data_length;
+  }
+  else
+    return ((usart-&gt;linmr &amp; AVR32_USART_LINMR_DLC_MASK) &gt;&gt; AVR32_USART_LINMR_DLC_OFFSET) + 1;
+}
+
+/*! \brief Sets the response data length for LIN 1.x.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_set_data_length_lin1x(volatile avr32_usart_t *usart)
+{
+  usart-&gt;linmr |= AVR32_USART_LINMR_DLM_MASK;
+}
+
+/*! \brief Sets the response data length for LIN 2.x.
+ *
+ * \param usart         Base address of the USART instance.
+ * \param data_length   The response data length.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_set_data_length_lin2x(volatile avr32_usart_t *usart, unsigned char data_length)
+{
+  usart-&gt;linmr = (usart-&gt;linmr &amp; ~(AVR32_USART_LINMR_DLC_MASK |
+                                   AVR32_USART_LINMR_DLM_MASK)) |
+                 (data_length - 1) &lt;&lt; AVR32_USART_LINMR_DLC_OFFSET;
+}
+
+/*! \brief Enables or disables the frame slot mode.
+ *
+ * \param usart       Base address of the USART instance.
+ * \param frameslot   Whether to enable the frame slot mode: \c TRUE or
+ *                    \c FALSE.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_enable_frameslot(volatile avr32_usart_t *usart, unsigned char frameslot)
+{
+  usart-&gt;linmr = (usart-&gt;linmr &amp; ~AVR32_USART_LINMR_FSDIS_MASK) |
+                 !frameslot &lt;&lt; AVR32_USART_LINMR_FSDIS_OFFSET;
+}
+
+/*! \brief Gets the Identifier character.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return The Identifier character.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ unsigned char usart_lin_get_id_char(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;linir &amp; AVR32_USART_LINIR_IDCHR_MASK) &gt;&gt; AVR32_USART_LINIR_IDCHR_OFFSET;
+}
+
+/*! \brief Sets the Identifier character.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param id_char   The Identifier character.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_set_id_char(volatile avr32_usart_t *usart, unsigned char id_char)
+{
+  usart-&gt;linir = (usart-&gt;linir &amp; ~AVR32_USART_LINIR_IDCHR_MASK) |
+                 id_char &lt;&lt; AVR32_USART_LINIR_IDCHR_OFFSET;
+}
+
+//! @}
+
+#endif  // USART rev. &gt;= 4.0.0
+
+
+//------------------------------------------------------------------------------
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+/*! \name SPI Control Functions
+ */
+//! @{
+
+/*! \brief Selects SPI slave chip.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS        Success.
+ */
+extern int usart_spi_selectChip(volatile avr32_usart_t *usart);
+
+/*! \brief Unselects SPI slave chip.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS        Success.
+ * \retval USART_FAILURE        Time-out.
+ */
+extern int usart_spi_unselectChip(volatile avr32_usart_t *usart);
+
+//! @}
+
+#endif  // USART rev. &gt;= 4.0.0
+
+
+//------------------------------------------------------------------------------
+/*! \name Transmit/Receive Functions
+ */
+//! @{
+
+/*! \brief Addresses a receiver.
+ *
+ * While in RS485 mode, receivers only accept data addressed to them.
+ * A packet/char with the address tag set has to precede any data.
+ * This function is used to address a receiver. This receiver should read
+ * all the following data, until an address packet addresses another receiver.
+ *
+ * \param usart     Base address of the USART instance.
+ * \param address   Address of the target device.
+ *
+ * \retval USART_SUCCESS    Address successfully sent (if current mode is RS485).
+ * \retval USART_MODE_FAULT Wrong operating mode.
+ */
+extern int usart_send_address(volatile avr32_usart_t *usart, int address);
+
+/*! \brief Tests if the USART is ready to transmit a character.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_tx_ready(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_TXRDY_MASK) != 0;
+}
+
+/*! \brief Writes the given character to the TX buffer if the transmitter is ready.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param c       The character (up to 9 bits) to transmit.
+ *
+ * \retval USART_SUCCESS  The transmitter was ready.
+ * \retval USART_TX_BUSY  The transmitter was busy.
+ */
+extern int usart_write_char(volatile avr32_usart_t *usart, int c);
+
+/*! \brief An active wait writing a character to the USART.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param c       The character (up to 9 bits) to transmit.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_bw_write_char(volatile avr32_usart_t *usart, int c)
+{
+  while (usart_write_char(usart, c) != USART_SUCCESS);
+}
+
+/*! \brief Sends a character with the USART.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param c       Character to write.
+ *
+ * \retval USART_SUCCESS  The character was written.
+ * \retval USART_FAILURE  The function timed out before the USART transmitter became ready to send.
+ */
+extern int usart_putchar(volatile avr32_usart_t *usart, int c);
+
+/*! \brief Tests if all requested USART transmissions are over.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return \c 1 if the USART Transmit Shift Register and the USART Transmit
+ *         Holding Register are free, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_tx_empty(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_TXEMPTY_MASK) != 0;
+}
+
+/*! \brief Tests if the USART contains a received character.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_test_hit(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_RXRDY_MASK) != 0;
+}
+
+/*! \brief Checks the RX buffer for a received character, and stores it at the
+ *         given memory location.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param c       Pointer to the where the read character should be stored
+ *                (must be at least short in order to accept 9-bit characters).
+ *
+ * \retval USART_SUCCESS  The character was read successfully.
+ * \retval USART_RX_EMPTY The RX buffer was empty.
+ * \retval USART_RX_ERROR An error was deteceted.
+ */
+extern int usart_read_char(volatile avr32_usart_t *usart, int *c);
+
+/*! \brief Waits until a character is received, and returns it.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return The received character, or \ref USART_FAILURE upon error.
+ */
+extern int usart_getchar(volatile avr32_usart_t *usart);
+
+/*! \brief Writes one character string to the USART.
+ *
+ * \param usart   Base address of the USART instance.
+ * \param string  String to be written.
+ */
+extern void usart_write_line(volatile avr32_usart_t *usart, const char *string);
+
+/*! \brief Gets and echoes characters until end of line.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \retval USART_SUCCESS  Success.
+ * \retval USART_FAILURE  Low-level error detected or ETX character received.
+ */
+extern int usart_get_echo_line(volatile avr32_usart_t *usart);
+
+#if defined(AVR32_USART_400_H_INCLUDED) || \
+    defined(AVR32_USART_410_H_INCLUDED) || \
+    defined(AVR32_USART_420_H_INCLUDED) || \
+    defined(AVR32_USART_440_H_INCLUDED)
+
+/*! \brief Abort LIN transmission.
+ *
+ * \param usart   Base address of the USART instance.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ void usart_lin_abort(volatile avr32_usart_t *usart)
+{
+  usart-&gt;cr = AVR32_USART_LINABT_MASK;
+}
+
+/*! \brief Tests if a LIN transfer has been completed.
+ *
+ * \param usart   Base address of the USART instance.
+ *
+ * \return \c 1 if a LIN transfer has been completed, otherwise \c 0.
+ */
+#if (defined __GNUC__)
+__attribute__((__always_inline__))
+#endif
+extern __inline__ int usart_lin_transfer_completed(volatile avr32_usart_t *usart)
+{
+  return (usart-&gt;csr &amp; AVR32_USART_CSR_LINTC_MASK) != 0;
+}
+
+#endif  // USART rev. &gt;= 4.0.0
+
+//! @}
+
+
+#endif  // _USART_H_


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000678.html">[Elua-svn] r725 - trunk/inc
</A></li>
	<LI>Next message: <A HREF="000680.html">[Elua-svn] r727 - in trunk/src/platform/lpc17xx: . drivers/inc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#679">[ date ]</a>
              <a href="thread.html#679">[ thread ]</a>
              <a href="subject.html#679">[ subject ]</a>
              <a href="author.html#679">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
