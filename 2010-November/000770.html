<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r817 - in branches/remotefs_int: . mux rfs_server
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r817%20-%20in%20branches/remotefs_int%3A%20.%20mux%20rfs_server&In-Reply-To=%3C20101112164855.475DE480C72%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000769.html">
   <LINK REL="Next"  HREF="000771.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r817 - in branches/remotefs_int: . mux rfs_server</H1>
    <B>bogdanm at mail.berlios.de</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r817%20-%20in%20branches/remotefs_int%3A%20.%20mux%20rfs_server&In-Reply-To=%3C20101112164855.475DE480C72%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r817 - in branches/remotefs_int: . mux rfs_server">bogdanm at mail.berlios.de
       </A><BR>
    <I>Fri Nov 12 17:48:55 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000769.html">[Elua-svn] r816 - in branches/remotefs_int: doc/en inc src	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc17xx src/platform/lpc24xx	src/platform/lpc288x src/platform/sim src/platform/stm32	src/platform/str7 src/platform/str9
</A></li>
        <LI>Next message: <A HREF="000771.html">[Elua-svn] r818 - in branches/remotefs_int: . inc inc/remotefs mux	rfs_server src src/modules src/platform/stm32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#770">[ date ]</a>
              <a href="thread.html#770">[ thread ]</a>
              <a href="subject.html#770">[ subject ]</a>
              <a href="author.html#770">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2010-11-12 17:48:54 +0100 (Fri, 12 Nov 2010)
New Revision: 817

Added:
   branches/remotefs_int/mux.py
   branches/remotefs_int/mux/
   branches/remotefs_int/mux/config.h
   branches/remotefs_int/mux/main.c
   branches/remotefs_int/mux/main.c.allthreads
   branches/remotefs_int/mux/main.c.old
   branches/remotefs_int/rfs_server/net.h
   branches/remotefs_int/rfs_server/net_posix.c
   branches/remotefs_int/rfs_server/net_win32.c
Removed:
   branches/remotefs_int/rfs_server/netinit.c
   branches/remotefs_int/rfs_server/netinit.h
   branches/remotefs_int/rfs_server/pnet.h
Modified:
   branches/remotefs_int/rfs_server.py
   branches/remotefs_int/rfs_server/main.c
   branches/remotefs_int/rfs_server/serial.h
   branches/remotefs_int/rfs_server/serial_win32.c
   branches/remotefs_int/rfs_server/type.h
Log:
working on the serial multiplexer

Added: branches/remotefs_int/mux/config.h
===================================================================
--- branches/remotefs_int/mux/config.h	                        (rev 0)
+++ branches/remotefs_int/mux/config.h	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,13 @@
+// Service multiplexer configurator
+
+#ifndef __CONFIG_H__
+#define __CONFIG_H__
+
+#include &quot;sermux.h&quot;
+
+#define SER_TIMEOUT_MS              100
+#define NET_TIMEOUT_MS              100
+#define MEM_BUF_SIZE                ( 6 * 1024 )
+
+#endif
+

Added: branches/remotefs_int/mux/main.c
===================================================================
--- branches/remotefs_int/mux/main.c	                        (rev 0)
+++ branches/remotefs_int/mux/main.c	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,346 @@
+// Service multiplexer 
+
+#include &quot;net.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;limits.h&gt;
+#include &quot;config.h&quot;
+#include &quot;log.h&quot;
+#include &quot;type.h&quot;
+#include &quot;serial.h&quot;
+#include &quot;sermux.h&quot;
+#include &quot;rfs.h&quot;
+
+// ****************************************************************************
+// Data structures and local variables
+
+#define MODE_MUX              1
+#define MODE_RFSMUX           2
+
+// Send/receive/init function pointers
+typedef u32 ( *p_recv_func )( u8 *p, u32 size );
+typedef u32 ( *p_send_func )( const u8 *p, u32 size );
+typedef int ( *p_init_func )( void );
+
+// Serial thread buffer structure
+typedef struct {
+  const char *pname;
+  ser_handler fd;
+} SERVICE_DATA;
+
+// Serial transport data structure
+typedef struct {
+  ser_handler fd;
+  const char *pname;
+  long speed;
+} TRANSPORT_SER;
+
+static SERVICE_DATA *services;
+static unsigned vport_num;
+
+static TRANSPORT_SER *transport_data;
+static p_recv_func transport_recv;
+static p_send_func transport_send;
+static p_init_func transport_init;
+
+static int service_id_in = -1, service_id_out = -1;
+ 
+static ser_handler transport_hnd = SER_HANDLER_INVALID;
+static int mux_mode;
+static int verbose_mode;
+
+// ***************************************************************************
+// Serial transport implementation
+
+static u32 transport_ser_recv( u8 *p, u32 size ) 
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  return ser_read( pser-&gt;fd, p, size, SER_NO_TIMEOUT );
+}
+
+static u32 transport_ser_send( const u8 *p, u32 size )
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  return ser_write( pser-&gt;fd, p, size );
+}
+
+static int transport_ser_init()
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  if( ( pser-&gt;fd = ser_open( pser-&gt;pname ) ) == ( ser_handler )-1 )
+  {
+    log_err( &quot;Unable to open %s\n&quot;, pser-&gt;pname );
+    return 0;
+  }
+  if( ser_setup( pser-&gt;fd, pser-&gt;speed, 8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
+  {
+    log_err( &quot;Unable to setup serial port %s\n&quot;, pser-&gt;pname );
+    return 0;
+  }
+  transport_hnd = pser-&gt;fd;
+  while( ser_read_byte( pser-&gt;fd, SER_NO_TIMEOUT ) != -1 );
+  log_msg( &quot;Running serial transport on port %s at %u baud (8N1)\n&quot;, pser-&gt;pname, ( unsigned )pser-&gt;speed );
+  return 1;
+}
+
+// ****************************************************************************
+// Utility functions and helpers
+
+static void transport_send_byte( u8 data )
+{
+  transport_send( &amp;data, 1 );
+}
+
+static int transport_read_byte() 
+{
+  u8 c;
+
+  return transport_recv( &amp;c, 1 ) == 1 ? c : -1;
+}
+
+// Secure atoi
+static int secure_atoi( const char *str, long *pres )
+{
+  char *end_ptr;
+  long s1;
+  
+  errno = 0;
+  s1 = strtol( str, &amp;end_ptr, 10 );
+  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
+    return 0;
+  else if( end_ptr == str )
+    return 0;
+  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
+    return 0;
+  else if( '\0' != *end_ptr )
+    return 0;
+  *pres = s1;
+  return 1;  
+}
+
+// Local strndup function to compensate the lack of strndup in Windows
+static char* l_strndup( const char* s, size_t n )
+{
+  char* p;
+  
+  if( ( p = ( char* )malloc( n + 1 ) ) == NULL )
+    return NULL;
+  p [ 0 ] = p[ n ] = '\0';
+  strncpy( p, s, n );
+  return p;
+} 
+
+// Transport parser
+static int parse_transport( const char* s )
+{
+  const char *c;
+  static TRANSPORT_SER tser; 
+
+  if( ( c = strchr( s, ',' ) ) == NULL )
+  {
+    log_err( &quot;Invalid serial transport syntax.\n&quot; );
+    return 0;
+  }
+  if( secure_atoi( c + 1, &amp;tser.speed ) == 0 )
+  {
+    log_err( &quot;Invalid port speed\n&quot; );
+    return 0;
+  }
+  tser.pname = l_strndup( s, c - s );
+  transport_data = &tser;
+  transport_send = transport_ser_send;
+  transport_recv = transport_ser_recv;
+  transport_init = transport_ser_init;
+  return 1;
+}
+
+// ****************************************************************************
+// Program entry point
+
+#define MODE_IDX              1
+#define MAIN_TRANSPORT_IDX    2
+#define FIRST_SERVICE_IDX     3
+#define MIN_ARGC_COUNT        4
+
+int main( int argc, char **argv )
+{
+  unsigned i;
+  SERVICE_DATA *tservice;
+  int c;
+  int temp, sdata;
+  int got_esc = 0;
+  fd_set fds;
+  char* rfs_dir_name;
+
+  // Interpret arguments
+  setvbuf( stdout, NULL, _IONBF, 0 );  
+  if( argc &lt; MIN_ARGC_COUNT )
+  {
+    log_err( &quot;Usage: %s &lt;mode&gt; &lt;transport&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]\n&quot;, argv[ 0 ] );
+    log_err( &quot;  mode: 'mux' for multiplexer mode, 'rfsmux:&lt;directory&gt;' for combined RFS and multiplexer mode.\n&quot; );
+    log_err( &quot;  transport: '&lt;port&gt;,&lt;baud&gt;.\n&quot; );
+    log_err( &quot;  vcom1, ..., vcomn: multiplexer serial ports.&quot; );
+    log_err( &quot;  Use '-v' for verbose output.\n&quot; );
+    return 1;
+  }
+  
+  // Check mode
+  if( !strcmp( argv[ MODE_IDX ], &quot;mux&quot; ) )
+    mux_mode = MODE_MUX;
+  else if( !strncmp( argv[ MODE_IDX ], &quot;rfsmux:&quot;, strlen( &quot;rfsmux:&quot; ) ) )
+  {
+    rfs_dir_name = argv[ MODE_IDX ] + strlen( &quot;rfsmux:&quot; );
+    mux_mode = MODE_RFSMUX;
+  }
+  else
+  {
+    log_err( &quot;Invalid mode.\n&quot; );
+    return 1;
+  } 
+  
+  // Check verbose
+  i = argc - 1;
+  if( !strcasecmp( argv[ i ], &quot;-v&quot; ) )
+  {
+    i --;
+    log_init( LOG_ALL );
+    verbose_mode = 1;
+  }
+  else
+    log_init( LOG_NONE );
+  
+  // Get number of virtual UARTs     
+  if( ( vport_num = i - FIRST_SERVICE_IDX + 1 ) &gt; SERMUX_SERVICE_MAX )
+  {
+    log_err( &quot;Too many service ports, maximum is %d\n&quot;, SERMUX_SERVICE_MAX );
+    return 1;
+  }
+  
+  // Parse transport data and initialize it
+  if( parse_transport( argv[ MAIN_TRANSPORT_IDX ] ) == 0 )
+    return 1;
+  if( transport_init() == 0 )
+    return 1;
+
+  // Open all the service ports
+  if( ( services = ( SERVICE_DATA* )malloc( sizeof( SERVICE_DATA ) * vport_num ) ) == NULL )
+  {
+    log_err( &quot;Not enough memory\n&quot; );
+    return 1;
+  }
+
+  memset( services, 0, sizeof( SERVICE_DATA ) * vport_num );
+  for( i = 0; i &lt; vport_num; i ++ ) 
+  {
+    tservice = services + i;
+    if( ( tservice-&gt;fd = ser_open( argv[ i + FIRST_SERVICE_IDX ] ) ) == SER_HANDLER_INVALID )
+    {
+      log_err( &quot;Unable to open port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
+      return 1;
+    }
+    if( ser_setup( tservice-&gt;fd, transport_data-&gt;speed, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
+    {
+      log_err( &quot;Unable to setup serial port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
+      return 1;
+    }
+    tservice-&gt;pname = argv[ i + FIRST_SERVICE_IDX ];
+  }
+  
+  // Setup RFS server in RFSMUX mode
+  if( mux_mode == MODE_RFSMUX )
+  {
+    char *args[] = { &quot;dummy&quot;, &quot;mem&quot;, rfs_dir_name, NULL };
+    if( verbose_mode )
+      args[ 3 ] = &quot;-v&quot;;
+    if( rfs_init( verbose_mode ? 4 : 3, args ) != 0 )      
+      return 1;
+  }
+
+  log_msg( &quot;Starting service multiplexer on %u port(s)\n&quot;, vport_num );
+/*  
+  // Main service thread
+  while( 1 )
+  {
+    FD_ZERO( &amp;fds );
+    FD_SET( transport_hnd, &amp;fds );
+    for( i = 0; i &lt; vport_num; i ++ )
+      FD_SET( ports[ i ].fd, &amp;fds );
+    if( select( maxfd + 1, &amp;fds, NULL, NULL, NULL ) &lt;= 0 )
+      continue;
+    if( FD_ISSET( transport_hnd, &amp;fds ) )
+    {
+      c = transport_read_byte();
+      // Read one byte, interpret it
+      if( c != ESCAPE_CHAR )
+      {
+        if( c &gt;= SERVICE_ID_FIRST &amp;&amp; c &lt;= SERVICE_ID_LAST )
+          service_id_in = c;
+        else
+        {
+          if( got_esc )
+          {
+            // Got an escape last time, check the char now (with the 5th bit flipped)
+            c ^= ESCAPE_XOR_MASK;
+            if( c != ESCAPE_CHAR &amp;&amp; c &lt; SERVICE_ID_FIRST &amp;&amp; c &gt; SERVICE_ID_LAST )
+            {
+               log_err( &quot;Protocol error: invalid escape sequence\n&quot; );
+               return 1;
+            }
+            got_esc = 0;
+          }  
+          if( service_id_in == -1 )
+          {
+            log_err( &quot;Protocol error: service ID not specified\n&quot; );
+            return 1;
+          }
+          ser_write_byte( ports[ service_id_in - SERVICE_ID_FIRST ].fd, c );
+        }
+      }
+      else
+        got_esc = 1;
+    }
+    else
+    {
+      // No byte to read, check if there's something to send
+      // Favour the service that sent data previously (if any)
+      temp = service_id_out != -1 ? service_id_out : SERVICE_ID_FIRST;
+      if( FD_ISSET( ports[ temp - SERVICE_ID_FIRST ].fd, &amp;fds ) )
+        sdata = ser_read_byte( ports[ temp - SERVICE_ID_FIRST ].fd, SER_NO_TIMEOUT );
+      else
+      {
+        temp = -1;
+        for( i = SERVICE_ID_FIRST; i &lt; SERVICE_ID_FIRST + vport_num; i ++ )
+          if( FD_ISSET( ports[ i - SERVICE_ID_FIRST ].fd, &amp;fds ) )
+          {
+            temp = ( int )i;
+            sdata = ser_read_byte( ports[ i - SERVICE_ID_FIRST ].fd, SER_NO_TIMEOUT );
+            break;
+          }
+      }
+      if( temp != -1 )
+      {
+        // We have something to send
+        // Send the service ID first if needed
+        if( temp != service_id_out )
+          transport_send_byte( temp );
+        // Then send the actual data byte, escaping it if needed
+        if( sdata == ESCAPE_CHAR || ( sdata &gt;= SERVICE_ID_FIRST &amp;&amp; sdata &lt;= SERVICE_ID_LAST ) )
+        {
+          transport_send_byte( ESCAPE_CHAR );
+          transport_send_byte( ( u8 )sdata ^ ESCAPE_XOR_MASK );
+        }
+        else
+          transport_send_byte( sdata );
+        service_id_out = temp;
+      }
+    }
+  }
+*/
+  return 0;
+}
+

Added: branches/remotefs_int/mux/main.c.allthreads
===================================================================
--- branches/remotefs_int/mux/main.c.allthreads	                        (rev 0)
+++ branches/remotefs_int/mux/main.c.allthreads	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,349 @@
+// Service multiplexer 
+
+#include &lt;stdio.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;semaphore.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;limits.h&gt;
+#include &quot;config.h&quot;
+#include &quot;log.h&quot;
+#include &quot;type.h&quot;
+#include &quot;serial.h&quot;
+
+// ****************************************************************************
+// Data structures and local variables
+
+#define TRANSPORT_TYPE_ERROR        0
+#define TRANSPORT_TYPE_SER          1
+
+// Service ID of the transport thread
+#define TRANSPORT_SERVICE_ID        -1
+
+// Send/receive/init function pointers
+typedef u32 ( *p_recv_func )( u8 *p, u32 size );
+typedef u32 ( *p_send_func )( const u8 *p, u32 size );
+typedef int ( *p_init_func )( void );
+
+// Serial thread buffer structure
+typedef struct 
+{
+  pthread_t tid;
+  const char *pname;
+  ser_handler fd;
+  int service_id;
+} THREAD_DATA;
+
+// Serial transport data structure
+typedef struct 
+{
+  ser_handler fd;
+  const char *pname;
+  long speed;
+} TRANSPORT_SER;
+
+// Service/transport data
+typedef struct 
+{
+  int id;
+  u8 data;
+} DATA;
+
+static THREAD_DATA *threads;
+static unsigned vport_num;
+
+static void *transport_data;
+static int transport_type;
+static p_recv_func transport_recv;
+static p_send_func transport_send;
+static p_init_func transport_init;
+
+static long service_baud;
+static sem_t mux_w_sem, mux_r_sem;
+static DATA mux_data;
+static int service_id_in = -1, service_id_out = -1;
+
+// ***************************************************************************
+// Serial transport implementation
+
+static u32 transport_ser_recv( u8 *p, u32 size ) 
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  return ser_read( pser-&gt;fd, p, size, SER_INF_TIMEOUT );
+}
+
+static u32 transport_ser_send( const u8 *p, u32 size )
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  return ser_write( pser-&gt;fd, p, size );
+}
+
+static int transport_ser_init()
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  if( ( pser-&gt;fd = ser_open( pser-&gt;pname ) ) == ( ser_handler )-1 )
+  {
+    fprintf( stderr, &quot;Unable to open %s\n&quot;, pser-&gt;pname );
+    return 0;
+  }
+  if( ser_setup( pser-&gt;fd, pser-&gt;speed, 8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
+  {
+    fprintf( stderr, &quot;Unable to setup serial port %s\n&quot;, pser-&gt;pname );
+    return 0;
+  }
+  while( ser_read_byte( pser-&gt;fd, SER_NO_TIMEOUT ) != -1 );
+  printf( &quot;Running serial transport on port %s at %u baud (8N1)\n&quot;, pser-&gt;pname, ( unsigned )pser-&gt;speed );
+  return 1;
+}
+
+// ****************************************************************************
+// Utility functions and helpers
+
+static void transport_send_byte( u8 data )
+{
+  transport_send( &amp;data, 1 );
+}
+
+static int transport_read_byte() 
+{
+  u8 c;
+
+  return transport_recv( &amp;c, 1 ) == 1 ? c : -1;
+}
+
+// Secure atoi
+static int secure_atoi( const char *str, long *pres )
+{
+  char *end_ptr;
+  long s1;
+  
+  errno = 0;
+  s1 = strtol( str, &amp;end_ptr, 10 );
+  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
+    return 0;
+  else if( end_ptr == str )
+    return 0;
+  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
+    return 0;
+  else if( '\0' != *end_ptr )
+    return 0;
+  *pres = s1;
+  return 1;  
+}
+
+// Transport parser
+static int parse_transport( const char* s )
+{
+  const char *c;
+  static TRANSPORT_SER tser; 
+
+  if( strstr( s, &quot;ser:&quot; ) == s )
+  {
+    s += strlen( &quot;ser:&quot; );
+    if( ( c = strchr( s, ',' ) ) == NULL )
+    {
+      fprintf( stderr, &quot;Invalid serial transport syntax\n&quot; );
+      return 0;
+    }
+    if( secure_atoi( c + 1, &amp;tser.speed ) == 0 )
+    {
+      fprintf( stderr, &quot;Invalid port speed\n&quot; );
+      return 0;
+    }
+    tser.pname = strndup( s, c - s );
+    transport_data = &tser;
+    transport_send = transport_ser_send;
+    transport_recv = transport_ser_recv;
+    transport_init = transport_ser_init;
+    transport_type = TRANSPORT_TYPE_SER;
+    return 1;
+  }
+  fprintf( stderr, &quot;Error: unsupported transport\n&quot; );
+  return 0;
+}
+
+// ***************************************************************************
+// Service thread
+
+static void* service_thread( void* data )
+{
+  THREAD_DATA *pdata = ( THREAD_DATA*) data;
+  int sdata;
+
+  log_msg( &quot;Starting service thread for port %s\n&quot;, pdata-&gt;pname );
+  while( 1 ) 
+  {
+    if( ( sdata = ser_read_byte( pdata-&gt;fd, SER_INF_TIMEOUT ) ) == -1 )
+      continue;
+    sem_wait( &amp;mux_w_sem );
+    mux_data.data = sdata;
+    mux_data.id = pdata-&gt;service_id;
+    sem_post( &amp;mux_r_sem );
+  }
+  return NULL;
+}
+
+// ****************************************************************************
+// Transport thread
+
+static void* transport_thread( void* data )
+{
+  int sdata;
+
+  log_msg( &quot;Starting transport thread\n&quot; );
+  while( 1 ) 
+  {
+    if( ( sdata = transport_read_byte() ) == -1 )
+      continue;
+    sem_wait( &amp;mux_w_sem );
+    mux_data.data = sdata;
+    mux_data.id = TRANSPORT_SERVICE_ID;
+    sem_post( &amp;mux_r_sem );
+  }
+  return NULL;
+}
+
+// ****************************************************************************
+// Program entry point
+
+#define MAIN_TRANSPORT_IDX    1
+#define SERVICE_BAUD_IDX      2
+#define FIRST_SERVICE_IDX     3
+
+int main( int argc, char **argv )
+{
+  unsigned i;
+  THREAD_DATA *tdata;
+  int c;
+  int temp, sdata;
+  int got_esc = 0;
+  DATA data;
+
+  // Interpret arguments
+  if( argc &lt; 4 )
+  {
+    fprintf( stderr, &quot;Usage: %s &lt;transport&gt; &lt;baud&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]\n&quot;, argv[ 0 ] );
+    return 1;
+  }
+  i = argc - 1;
+  if( !strcasecmp( argv[ i ], &quot;-v&quot; ) )
+  {
+    i --;
+    log_init( LOG_ALL );
+  }
+  else
+    log_init( LOG_NONE ); 
+  if( ( vport_num = i - 2 ) &gt; SERVICE_MAX )
+  {
+    fprintf( stderr, &quot;Too many service ports, maximum is %d\n&quot;, SERVICE_MAX );
+    return 1;
+  }
+  if( parse_transport( argv[ MAIN_TRANSPORT_IDX ] ) == 0 )
+    return 1;
+  if( secure_atoi( argv[ SERVICE_BAUD_IDX ], &amp;service_baud ) == 0 )
+  {
+    fprintf( stderr, &quot;Invalid service baud\n&quot; );
+    return 1;
+  }
+  if( transport_init() == 0 )
+    return 1;
+
+  // Create global sync objects
+  sem_init( &amp;mux_w_sem, 0, 1 );
+  sem_init( &amp;mux_r_sem, 0, 0 );
+
+  // Open all the service ports and create their corresponding threads
+  if( ( threads = ( THREAD_DATA* )malloc( sizeof( THREAD_DATA ) * ( vport_num + 1 ) ) ) == NULL )
+  {
+    fprintf( stderr, &quot;Not enough memory\n&quot; );
+    return 1;
+  }
+  for( i = 0; i &lt;= vport_num; i ++ ) 
+  {
+    tdata = threads + i;
+    if( i &lt; vport_num )
+    {
+      if( ( tdata-&gt;fd = ser_open( argv[ i + FIRST_SERVICE_IDX ] ) ) == ( ser_handler )-1 )
+      {
+        fprintf( stderr, &quot;Unable to open port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
+        return 1;
+      }
+      if( ser_setup( tdata-&gt;fd, service_baud, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
+      {
+        fprintf( stderr, &quot;Unable to setup serial port %s\n&quot;, argv[ i + FIRST_SERVICE_IDX ] );
+        return 1;
+      }
+      tdata-&gt;pname = argv[ i + FIRST_SERVICE_IDX ];
+      tdata-&gt;service_id = i + SERVICE_ID_FIRST;
+    }
+    if( pthread_create( &amp;tdata-&gt;tid, NULL, i == vport_num ? transport_thread : service_thread, ( void* )tdata ) )
+    {
+      fprintf( stderr, &quot;Unable to create thread\n&quot; );
+      return 1;
+    }
+  }
+
+  printf( &quot;Starting service multiplexer on %u port(s)\n&quot;, vport_num );
+  // Main service thread
+  while( 1 )
+  {
+    sem_wait( &amp;mux_r_sem );
+    data = mux_data;
+    sem_post( &amp;mux_w_sem );
+    if( data.id == TRANSPORT_SERVICE_ID )
+    {
+      // Read one byte, interpret it
+      c = data.data;
+      if( c != ESCAPE_CHAR )
+      {
+        if( c &gt;= SERVICE_ID_FIRST &amp;&amp; c &lt;= SERVICE_ID_LAST )
+          service_id_in = c;
+        else
+        {
+          if( got_esc )
+          {
+            // Got an escape last time, check the char now (with the 5th bit flipped)
+            c ^= ESCAPE_XOR_MASK;
+            if( c != ESCAPE_CHAR &amp;&amp; c &lt; SERVICE_ID_FIRST &amp;&amp; c &gt; SERVICE_ID_LAST )
+            {
+               fprintf( stderr, &quot;Protocol error: invalid escape sequence\n&quot; );
+               return 1;
+            }
+            got_esc = 0;
+          }  
+          if( service_id_in == -1 )
+          {
+            fprintf( stderr, &quot;Protocol error: service ID not specified\n&quot; );
+            return 1;
+          }
+          ser_write_byte( threads[ service_id_in - SERVICE_ID_FIRST ].fd, c );
+        }
+      }
+      else
+        got_esc = 1;
+    }
+    else
+    {
+      temp = data.id;
+      sdata = data.data;
+      if( temp != service_id_out )
+        transport_send_byte( temp );
+      // Then send the actual data byte, escaping it if needed
+      if( sdata == ESCAPE_CHAR || ( sdata &gt;= SERVICE_ID_FIRST &amp;&amp; sdata &lt;= SERVICE_ID_LAST ) )
+      {
+        transport_send_byte( ESCAPE_CHAR );
+        transport_send_byte( ( u8 )sdata ^ ESCAPE_XOR_MASK );
+      }
+      else
+        transport_send_byte( sdata );
+      service_id_out = temp;
+    }
+  }
+
+  return 0;
+}
+

Added: branches/remotefs_int/mux/main.c.old
===================================================================
--- branches/remotefs_int/mux/main.c.old	                        (rev 0)
+++ branches/remotefs_int/mux/main.c.old	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,755 @@
+// Service multiplexer 
+
+#include &lt;stdio.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;semaphore.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;limits.h&gt;
+#include &quot;config.h&quot;
+#include &quot;log.h&quot;
+#include &quot;type.h&quot;
+#include &quot;serial.h&quot;
+#include &quot;os_io.h&quot;
+#include &quot;pnet.h&quot;
+
+// External RFS functions
+extern int rfs_server_init( unsigned server_port, const char* dirname );
+extern void rfs_server_cleanup();
+extern void* rfs_thread( void* data );
+extern volatile int rfs_thread_should_die;
+
+// ****************************************************************************
+// Data structures and local variables
+
+#define TRANSPORT_TYPE_ERROR        0
+#define TRANSPORT_TYPE_SER          1
+#define TRANSPORT_TYPE_UDP          2
+#define TRANSPORT_TYPE_TEXTCTRL     3
+
+// Service ID of the transport thread
+#define TRANSPORT_SERVICE_ID        ( -1 )
+#define THREAD_STOP_SERVICE_ID      ( -2 )  
+
+// Thread indexes in the threads array
+#ifdef MUX_THREAD_MODE
+#define TEXTCTRL_THREAD_IDX         1
+#else
+#define TEXTCTRL_THREAD_IDX         ( -1 )
+#endif
+#define RFS_UDP_THREAD_IDX          0
+        
+// Send/receive/init function pointers for transport
+typedef u32 ( *p_recv_func )( u8 *p, u32 size );
+typedef u32 ( *p_send_func )( const u8 *p, u32 size );
+typedef int ( *p_init_func )( void );
+typedef void ( *p_cleanup_func )( void );
+
+// Thread function type
+typedef void* ( *p_thread_func )( void* );
+
+// Thread structure
+typedef struct 
+{
+  pthread_t tid;
+  int thread_created;
+  volatile int thread_should_die;
+  int type;  
+  union
+  {
+    const char *pname;
+    unsigned port;
+  };
+  union
+  {
+    ser_handler fd;
+    SOCKET s;
+  };
+  int service_id;
+  struct sockaddr_in server;
+  union
+  {
+    sem_t udp_sem;
+    sem_t textctrl_sem;
+  };
+  int textctrl_data;
+  u8 *udp_buf;
+} THREAD_DATA;
+
+// Serial transport data structure
+typedef struct 
+{
+  ser_handler fd;
+  char *pname;
+  long speed;
+} TRANSPORT_SER;
+
+// Service/transport data
+typedef struct 
+{
+  int id;
+  u8 data;
+} DATA;
+
+static THREAD_DATA *threads;
+static unsigned vport_num;
+
+static void *transport_data;
+static int transport_type;
+static p_recv_func transport_recv;
+static p_send_func transport_send;
+static p_init_func transport_init;
+static p_cleanup_func transport_cleanup;
+static long service_baud;
+static sem_t mux_w_sem, mux_r_sem;
+static DATA mux_data;
+static int service_id_in = -1, service_id_out = -1;
+static pthread_t rfs_thread_id;
+static int rfs_thread_created;
+volatile int mux_thread_running;
+
+// *****************************************************************************
+// wxTextCtrl &quot;transport&quot; helpers
+
+#ifdef MUX_THREAD_MODE
+
+// wxTextCtrl buffer data
+typedef struct
+{
+  int *pdata;
+  unsigned r_idx, w_idx, total;  
+  sem_t count_sem;
+} TEXTCTRL_DATA;
+
+static TEXTCTRL_DATA textctrl_data;
+
+int mux_textctrl_init( unsigned total )
+{                                  
+  if( ( textctrl_data.pdata = ( int* )malloc( total * sizeof( int ) ) ) == NULL )
+  {
+    log_err( &quot;Unable to alloc textctrl buffer\n&quot; );
+    return 0;
+  }
+  textctrl_data.r_idx = textctrl_data.w_idx = 0;
+  textctrl_data.total = total;
+  sem_init( &amp;textctrl_data.count_sem, 0, 0 );
+  return 1;
+}
+
+void mux_textctrl_cleanup()
+{
+  free( textctrl_data.pdata );
+  sem_destroy( &amp;textctrl_data.count_sem );
+}
+
+void textctrl_get_char( int c )
+{
+#if 0
+  textctrl_data.pdata[ textctrl_data.w_idx ] = c;
+  textctrl_data.w_idx = ( textctrl_data.w_idx + 1 ) % textctrl_data.total;
+  printf( &quot;!&quot; );
+  sem_post( &amp;textctrl_data.count_sem );
+#else
+  THREAD_DATA *pdata = threads + TEXTCTRL_THREAD_IDX;
+  pdata-&gt;textctrl_data = c;
+  sem_post( &amp;pdata-&gt;textctrl_sem );
+#endif
+}
+
+extern void textctrl_put_char( int c );
+
+#else // #ifdef MUX_THREAD_MODE
+
+static void textctrl_put_char( int c )
+{
+}
+
+static void textctrl_get_char( int c )
+{
+}
+
+#endif // #ifdef MUX_THREAD_MODE
+
+// *****************************************************************************
+// Serial transport implementation
+
+static u32 transport_ser_recv( u8 *p, u32 size ) 
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  return ser_read( pser-&gt;fd, p, size, SER_TIMEOUT_MS );
+}
+
+static u32 transport_ser_send( const u8 *p, u32 size )
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  return ser_write( pser-&gt;fd, p, size );
+}
+
+static int transport_ser_init()
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  if( ( pser-&gt;fd = ser_open( pser-&gt;pname ) ) == ( ser_handler )-1 )
+  {
+    log_err( &quot;Unable to open %s\n&quot;, pser-&gt;pname );
+    return 0;
+  }
+  if( ser_setup( pser-&gt;fd, pser-&gt;speed, 8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
+  {
+    log_err( &quot;Unable to setup serial port %s\n&quot;, pser-&gt;pname );
+    return 0;
+  }
+  while( ser_read_byte( pser-&gt;fd, SER_NO_TIMEOUT ) != -1 );
+  log_msg( &quot;Running serial transport on port %s at %u baud (8N1)\n&quot;, pser-&gt;pname, ( unsigned )pser-&gt;speed );
+  return 1;
+}
+
+static void transport_ser_cleanup()
+{
+  TRANSPORT_SER *pser = ( TRANSPORT_SER* )transport_data;
+
+  if( pser-&gt;fd &amp;&amp; pser-&gt;fd != ( ser_handler )-1 )
+    ser_close( pser-&gt;fd );
+  free( pser-&gt;pname );
+}
+
+// ****************************************************************************
+// Utility functions and helpers
+
+static void transport_send_byte( u8 data )
+{
+  transport_send( &amp;data, 1 );
+}
+
+static int transport_read_byte() 
+{
+  u8 c;
+
+  return transport_recv( &amp;c, 1 ) == 1 ? c : -1;
+}
+
+// Secure atoi
+static int secure_atoi( const char *str, long *pres )
+{
+  char *end_ptr;
+  long s1;
+  
+  errno = 0;
+  s1 = strtol( str, &amp;end_ptr, 10 );
+  if( ( s1 == LONG_MIN || s1 == LONG_MAX ) &amp;&amp; errno != 0 )
+    return 0;
+  else if( end_ptr == str )
+    return 0;
+  else if( s1 &gt; INT_MAX || s1 &lt; INT_MIN )
+    return 0;
+  else if( '\0' != *end_ptr )
+    return 0;
+  *pres = s1;
+  return 1;  
+}
+
+// Local strndup function to compensate the lack of strndup in Windows
+static char* l_strndup( const char* s, size_t n )
+{
+  char* p;
+  
+  if( ( p = ( char* )malloc( n + 1 ) ) == NULL )
+    return NULL;
+  p [ 0 ] = p[ n ] = '\0';
+  strncpy( p, s, n );
+  return p;
+} 
+
+// Transport parser
+static int parse_transport( const char* s )
+{
+  const char *c;
+  static TRANSPORT_SER tser; 
+
+  if( strstr( s, &quot;ser:&quot; ) == s )
+  {
+    s += strlen( &quot;ser:&quot; );
+    if( ( c = strchr( s, ',' ) ) == NULL )
+    {
+      log_err( &quot;Invalid serial transport syntax\n&quot; );
+      return 0;
+    }
+    if( secure_atoi( c + 1, &amp;tser.speed ) == 0 )
+    {
+      log_err( &quot;Invalid port speed\n&quot; );
+      return 0;
+    }
+    tser.pname = l_strndup( s, c - s );
+    transport_data = &tser;
+    transport_send = transport_ser_send;
+    transport_recv = transport_ser_recv;
+    transport_init = transport_ser_init;
+    transport_cleanup = transport_ser_cleanup;
+    transport_type = TRANSPORT_TYPE_SER;
+    return 1;
+  }
+  log_err( &quot;Error: unsupported transport\n&quot; );
+  return 0;
+}
+
+// ***************************************************************************
+// Service threads
+
+static void* service_thread_ser( void* data )
+{
+  THREAD_DATA *pdata = ( THREAD_DATA* )data;
+  int sdata;
+
+  log_msg( &quot;Starting serial service thread for port %s\n&quot;, pdata-&gt;pname );
+  while( 1 ) 
+  {
+    if( ( sdata = ser_read_byte( pdata-&gt;fd, SER_TIMEOUT_MS ) ) == -1 )
+    {
+      if( pdata-&gt;thread_should_die )
+        break;
+      else
+        continue;
+    }
+    sem_wait( &amp;mux_w_sem );
+    mux_data.data = sdata;
+    mux_data.id = pdata-&gt;service_id;
+    sem_post( &amp;mux_r_sem );
+  }
+  return NULL;
+}
+
+static void* service_thread_udp( void* data )
+{
+  THREAD_DATA *pdata = ( THREAD_DATA* )data;
+  socklen_t fromlen;
+  struct sockaddr_in from;
+  int readbytes, i;
+  fd_set fds;
+  struct timeval tv;
+    
+  log_msg( &quot;Starting UDP service thread for port %d\n&quot;, pdata-&gt;port );
+  while( 1 ) 
+  {
+    FD_ZERO( &amp;fds );
+    FD_SET( pdata-&gt;s, &amp;fds );
+    tv.tv_sec = 0;
+    tv.tv_usec = NET_TIMEOUT_MS * 1000;
+    if( select( pdata-&gt;s + 1, &amp;fds, NULL, NULL, &amp;tv ) &lt;= 0 )
+    {
+      if( pdata-&gt;thread_should_die )
+        break;
+      else
+        continue;
+    }
+    fromlen = sizeof( from );
+    readbytes = recvfrom( pdata-&gt;s, pdata-&gt;udp_buf, UDP_BUF_SIZE, 0, ( struct sockaddr* )&amp;from, &amp;fromlen );
+    for( i = 0; i &lt; readbytes; i ++ )
+    {
+      if( pdata-&gt;thread_should_die )
+        break;    
+      sem_wait( &amp;mux_w_sem );
+      mux_data.data = pdata-&gt;udp_buf[ i ];
+      mux_data.id = pdata-&gt;service_id;
+      sem_post( &amp;mux_r_sem );
+    }
+    if( pdata-&gt;thread_should_die )
+      break;       
+  }
+  return NULL;  
+}
+
+static void* service_thread_textctrl( void* data )
+{
+#ifdef MUX_THREAD_MODE
+  int c;
+  THREAD_DATA *pdata = ( THREAD_DATA* )data;  
+    
+  log_msg( &quot;Starting wxTextCtrl service thread\n&quot; );
+  while( 1 )
+  {
+#if 0  
+    sem_wait( &amp;textctrl_data.count_sem );
+    if( ( c = textctrl_data.pdata[ textctrl_data.r_idx ] ) == -1 )
+      break;
+    textctrl_data.r_idx = ( textctrl_data.r_idx + 1 ) % textctrl_data.total;
+#else
+    sem_wait( &amp;pdata-&gt;textctrl_sem );
+    if( ( c = pdata-&gt;textctrl_data ) == -1 )
+      break;
+#endif
+    sem_wait( &amp;mux_w_sem );
+    mux_data.data = c;
+    mux_data.id = pdata-&gt;service_id;
+    sem_post( &amp;mux_r_sem );      
+  }
+#endif  
+  return NULL;
+}
+
+static const p_thread_func mux_service_funcs[] = { NULL, service_thread_ser, service_thread_udp, service_thread_textctrl };
+
+// *****************************************************************************
+// Transport thread
+
+static void* transport_thread( void* data )
+{                     
+  int sdata;
+  THREAD_DATA *pdata = ( THREAD_DATA* )data;
+  
+  log_msg( &quot;Starting transport thread\n&quot; );  
+  while( 1 ) 
+  {
+    if( ( sdata = transport_read_byte() ) == -1 )
+    {    
+      if( pdata-&gt;thread_should_die )
+        break;
+      else
+        continue;
+    }    
+    sem_wait( &amp;mux_w_sem );
+    mux_data.data = sdata;
+    mux_data.id = TRANSPORT_SERVICE_ID;
+    sem_post( &amp;mux_r_sem );
+  }
+  return NULL;
+}
+
+// *****************************************************************************
+// Transport aware byte send function
+
+static void byte_send( THREAD_DATA *data, u8 d )
+{   
+  if( data-&gt;type == TRANSPORT_TYPE_SER )
+    ser_write_byte( data-&gt;fd, d );
+  else if( data-&gt;type == TRANSPORT_TYPE_UDP )
+    sendto( data-&gt;s, &amp;d, 1, 0, ( struct sockaddr* )&amp;data-&gt;server, sizeof( data-&gt;server ) );
+  else 
+    textctrl_put_char( d );            
+}
+
+// ****************************************************************************
+// Program entry point
+
+#define MAIN_TRANSPORT_IDX    1
+#define SERVICE_BAUD_IDX      2
+#define RFS_DIRNAME_IDX       3
+#define FIRST_SERVICE_IDX     4
+
+int mux_init( int argc, char **argv )
+{
+  unsigned i;
+  THREAD_DATA *tdata;
+  struct hostent *hp;
+        
+  // Setup networking in Windows
+#ifdef WIN32_BUILD
+  // The socket subsystem must be initialized if working in Windows
+  WORD wVersionRequested;
+  WSADATA wsaData;
+  int err;
+ 
+  wVersionRequested = MAKEWORD( 2, 0 );
+  err = WSAStartup( wVersionRequested, &amp;wsaData );  
+  if( err != 0 )
+  {
+    log_err( &quot;Unable to initialize the socket subsystem\n&quot; );
+    return 1;
+  }
+#endif // #ifdef WIN32_BUILD  
+
+  // Interpret arguments
+  if( argc &lt; FIRST_SERVICE_IDX + 1 )
+  {
+    log_err( &quot;Usage: %s &lt;transport&gt; &lt;baud&gt; &lt;rfs_dir_name&gt; &lt;vcom1&gt; [&lt;vcom2&gt;] ... [&lt;vcomn&gt;] [-v]\n&quot;, argv[ 0 ] );
+    return 1;
+  }
+  i = argc - 1;
+  if( !strcasecmp( argv[ i ], &quot;-v&quot; ) )
+  {
+    i --;
+    log_init( LOG_ALL );
+  }
+  else                            
+    log_init( LOG_NONE ); 
+  if( ( vport_num = i - 3 ) &gt; SERVICE_MAX )
+  {
+    log_err( &quot;Too many service ports, maximum is %d\n&quot;, SERVICE_MAX );
+    return 1;
+  }
+  if( parse_transport( argv[ MAIN_TRANSPORT_IDX ] ) == 0 )
+    return 1;
+  if( secure_atoi( argv[ SERVICE_BAUD_IDX ], &amp;service_baud ) == 0 )
+  {
+    log_err( &quot;Invalid service baud\n&quot; );
+    return 1;
+  }
+  if( !os_isdir( argv[ RFS_DIRNAME_IDX ] ) )
+  {
+    log_err( &quot;Invalid directory %s\n&quot;, argv[ RFS_DIRNAME_IDX ] );
+    return 1;
+  }  
+  if( transport_init() == 0 )
+    return 1;
+  if( rfs_server_init( RFS_SERVER_PORT, argv[ RFS_DIRNAME_IDX ] ) == 0 )
+    return 1;
+      
+  // Create global sync objects
+  sem_init( &amp;mux_w_sem, 0, 1 );
+  sem_init( &amp;mux_r_sem, 0, 0 );
+
+  // Open all the service ports and create their corresponding threads
+  if( ( threads = ( THREAD_DATA* )malloc( sizeof( THREAD_DATA ) * ( vport_num + 2 ) ) ) == NULL )
+  {
+    log_err( &quot;Not enough memory\n&quot; );
+    return 1;
+  }
+  memset( threads, 0, sizeof( THREAD_DATA ) * ( vport_num + 2 ) );
+  // Thread map:
+  // index 0 : UDP thread (ALWAYS first service ID!)
+  // 1 ... vport_num : actual serial ports
+  //   (1 is connected to the console wxTextCtrl in frontend mode)
+  // vport_num + 1: transport thread
+  for( i = 0; i &lt;= vport_num + 1; i ++ ) 
+  {
+    tdata = threads + i;
+    tdata-&gt;thread_should_die = 0;
+    if( i &lt;= vport_num )
+    {    
+      if( i == TEXTCTRL_THREAD_IDX )
+      {
+        sem_init( &amp;tdata-&gt;textctrl_sem, 0, 0 );          
+        tdata-&gt;type = TRANSPORT_TYPE_TEXTCTRL;
+      } 
+      else if( i == RFS_UDP_THREAD_IDX )    
+      {      
+        tdata-&gt;s = INVALID_SOCKET_VALUE;
+        if( ( tdata-&gt;udp_buf = ( u8* )malloc( UDP_BUF_SIZE ) ) == NULL )
+        {
+          log_err( &quot;Unable to allocate UDP buffer\n&quot; );
+          return 1;
+        }
+        // UDP thread  
+        if( ( tdata-&gt;s = socket( AF_INET, SOCK_DGRAM, 0 ) ) == INVALID_SOCKET_VALUE )
+        {
+          log_err( &quot;Error creating socket\n&quot; );
+          return 1;
+        }
+        tdata-&gt;server.sin_family = AF_INET;
+        hp = gethostbyname( &quot;127.0.0.1&quot; );
+        memcpy( &amp;tdata-&gt;server.sin_addr, hp-&gt;h_addr, hp-&gt;h_length );
+        tdata-&gt;server.sin_port = htons( RFS_SERVER_PORT );
+        tdata-&gt;type = TRANSPORT_TYPE_UDP;
+        tdata-&gt;port = RFS_SERVER_PORT;
+        sem_init( &amp;tdata-&gt;udp_sem, 0, 0 );                  
+      }
+      else
+      {   
+        // Serial thread
+        if( ( tdata-&gt;fd = ser_open( argv[ i  - 1 + FIRST_SERVICE_IDX ] ) ) == ( ser_handler )-1 )
+        {
+          log_err( &quot;Unable to open port %s\n&quot;, argv[ i - 1 + FIRST_SERVICE_IDX ] );
+          return 1;
+        }
+        if( ser_setup( tdata-&gt;fd, service_baud, SER_DATABITS_8, SER_PARITY_NONE, SER_STOPBITS_1 ) != SER_OK )
+        {
+          log_err( &quot;Unable to setup serial port %s\n&quot;, argv[ i - 1 + FIRST_SERVICE_IDX ] );
+          return 1;
+        }
+        tdata-&gt;type = TRANSPORT_TYPE_SER;
+        tdata-&gt;pname = argv[ i - 1 + FIRST_SERVICE_IDX ];        
+      }
+      tdata-&gt;service_id = i + SERVICE_ID_FIRST;         
+    }
+    if( pthread_create( &amp;tdata-&gt;tid, NULL, i &lt;= vport_num ? mux_service_funcs[ tdata-&gt;type ] : transport_thread, tdata ) )
+    {
+      log_err( &quot;Unable to create transport thread\n&quot; );
+      return 1;
+    }
+    tdata-&gt;thread_created = 1;
+  }
+  // Create rfs_server thread
+  if( pthread_create( &amp;rfs_thread_id, NULL, rfs_thread, argv[ RFS_DIRNAME_IDX ] ) )
+  {
+    log_err( &quot;Unable to create RFS thread\n&quot; );
+    return 1;
+  }
+  rfs_thread_created = 1;
+  return 0;  
+}
+
+void mux_cleanup()
+{
+  unsigned i;
+  THREAD_DATA *tdata;
+                            
+  if( threads )
+  {
+    // Thread map:
+    // index 0 : UDP thread (ALWAYS first service ID!)
+    // 1 ... vport_num : actual serial ports
+    // vport_num + 1: transport thread
+    for( i = 0; i &lt;= vport_num + 1; i ++ ) 
+    {
+      tdata = threads + i;
+      if( tdata-&gt;thread_created == 1 )
+      {
+        if( i == TEXTCTRL_THREAD_IDX )
+          textctrl_get_char( -1 );
+        tdata-&gt;thread_should_die = 1;
+        pthread_join( tdata-&gt;tid, NULL );
+      }
+      if( i &lt;= vport_num )
+      {
+        if( i == TEXTCTRL_THREAD_IDX )
+          sem_destroy( &amp;tdata-&gt;textctrl_sem );
+        else if( i == RFS_UDP_THREAD_IDX )
+        {        
+          free( tdata-&gt;udp_buf );
+          if( tdata-&gt;s != INVALID_SOCKET_VALUE )
+            socket_close( tdata-&gt;s );             
+          sem_destroy( &amp;tdata-&gt;udp_sem );                   
+        }
+        else
+        {  
+          // Serial thread
+          if( tdata-&gt;fd &amp;&amp; tdata-&gt;fd != ( ser_handler )-1 )
+            ser_close( tdata-&gt;fd );         
+        }    
+      }
+    }
+    free( threads );
+    threads = NULL;
+  }
+  if( rfs_thread_created )
+  {
+    rfs_thread_should_die = 1;
+    pthread_join( rfs_thread_id, NULL );
+  }
+  rfs_server_cleanup();
+  transport_cleanup();
+  
+  sem_destroy( &amp;mux_w_sem );
+  sem_destroy( &amp;mux_r_sem );
+  
+  // Re-init globals
+  vport_num = 0;
+  transport_type = TRANSPORT_TYPE_ERROR;
+  service_baud = 0;
+  service_id_in = -1;
+  service_id_out = -1;
+  rfs_thread_created = 0;
+  mux_thread_running = 0;
+}
+
+#if defined( MUX_STANDALONE_MODE )
+
+#define RETVAL  1
+#define RETVAL_TYPE int
+
+#elif defined( MUX_THREAD_MODE )
+
+#define RETVAL  NULL
+#define RETVAL_TYPE void*
+
+void mux_thread_stop()
+{
+  sem_wait( &amp;mux_w_sem );
+  mux_data.id = THREAD_STOP_SERVICE_ID;
+  sem_post( &amp;mux_r_sem );
+}
+    
+#else
+#error &quot;Operating mode (standalone or thread) not defined&quot;
+#endif
+
+RETVAL_TYPE mux_thread( void *pdata ) 
+{
+  int c, prev_sent = -1;
+  int temp, sdata;
+  int got_esc = 0;
+  DATA data;
+                                                                                     
+  log_msg( &quot;Starting service multiplexer on %u port(s) and RFS server\n&quot;, vport_num );
+  // Main service thread
+  while( 1 )
+  {
+    sem_wait( &amp;mux_r_sem );
+    data = mux_data;
+    sem_post( &amp;mux_w_sem );
+    if( data.id == THREAD_STOP_SERVICE_ID )
+      break;        
+    if( data.id == TRANSPORT_SERVICE_ID )
+    {
+      // Read one byte, interpret it
+      c = data.data;
+      if( c != ESCAPE_CHAR )
+      {
+        if( c &gt;= SERVICE_ID_FIRST &amp;&amp; c &lt;= SERVICE_ID_LAST )
+          service_id_in = c;
+        else if( c == FORCE_SID_CHAR &amp;&amp; prev_sent != -1 )
+        {
+          // Re-transmit the last data AND the service ID
+          transport_send_byte( service_id_out );
+          if( prev_sent &amp; ESC_MASK )
+            transport_send_byte( ESCAPE_CHAR );
+          transport_send_byte( prev_sent &amp; 0xFF );
+        }
+        else
+        {
+          if( got_esc )
+          {
+            // Got an escape last time, check the char now (with the 5th bit flipped)
+            c ^= ESCAPE_XOR_MASK;
+            if( c != ESCAPE_CHAR &amp;&amp; c != FORCE_SID_CHAR &amp;&amp; ( c &lt; SERVICE_ID_FIRST || c &gt; SERVICE_ID_LAST ) )
+            {
+               log_err( &quot;Protocol error: invalid escape sequence\n&quot; );
+               break;
+            }
+            got_esc = 0;
+          }  
+          if( service_id_in == -1 )
+          {
+            transport_send_byte( FORCE_SID_CHAR );
+            log_msg( &quot;Requested resend of service ID\n&quot; );
+          }
+          else
+            byte_send( threads + service_id_in - SERVICE_ID_FIRST, c );
+        }
+      }
+      else
+        got_esc = 1;
+    }
+    else
+    {
+      temp = data.id;
+      sdata = data.data;
+      if( temp != service_id_out )
+        transport_send_byte( temp );
+      prev_sent = sdata;
+      // Then send the actual data byte, escaping it if needed
+      if( sdata == ESCAPE_CHAR || sdata == FORCE_SID_CHAR || ( sdata &gt;= SERVICE_ID_FIRST &amp;&amp; sdata &lt;= SERVICE_ID_LAST ) )
+      {
+        transport_send_byte( ESCAPE_CHAR );
+        transport_send_byte( ( u8 )sdata ^ ESCAPE_XOR_MASK );
+        prev_sent = ESC_MASK | ( ( u8 )sdata ^ ESCAPE_XOR_MASK );
+      }
+      else
+        transport_send_byte( sdata );
+      service_id_out = temp;
+    }
+  }
+  mux_thread_running = 0;
+  return RETVAL;
+}
+
+#ifdef MUX_STANDALONE_MODE
+int main( int argc, char **argv )
+{
+  if( mux_init( argc, argv ) )
+    return RETVAL;
+  return mux_thread( NULL );
+}
+#endif

Added: branches/remotefs_int/mux.py
===================================================================
--- branches/remotefs_int/mux.py	                        (rev 0)
+++ branches/remotefs_int/mux.py	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,34 @@
+import os, sys, platform
+
+flist = &quot;main.c&quot;
+rfs_flist = ''
+rfs_flist = &quot;main.c server.c log.c&quot;
+cdefs = &quot;-DRFS_UDP_TRANSPORT -DRFS_INSIDE_MUX_MODE&quot;
+socklib = ''
+ptlib = ''
+if platform.system() == &quot;Windows&quot;:
+  cdefs = cdefs + &quot; -DWIN32_BUILD&quot;
+  rfs_flist = rfs_flist + &quot; os_io_win32.c serial_win32.c net_win32.c&quot;
+  exeprefix = &quot;exe&quot;
+  socklib = '-lws2_32'
+else:
+  rfs_flist = rfs_flist + &quot; os_io_posix.c serial_posix.c net_posix.c&quot;
+  exeprefix = &quot;elf&quot;
+  socklib = ''
+
+output = &quot;mux.%s&quot; % exeprefix
+
+rfs_full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;rfs_server/%s&quot; % name for name in rfs_flist.split() ] )
+full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;mux/%s&quot; % name for name in flist.split() ] ) + rfs_full_files + &quot; src/remotefs/remotefs.c src/eluarpc.c&quot;
+local_include = &quot;-Imux -Irfs_server -Iinc -Iinc/remotefs&quot;
+
+# Compiler/linker options
+cccom = &quot;gcc -m32 -O0 -g %s -Wall %s -c $SOURCE -o $TARGET&quot; % ( local_include, cdefs )
+linkcom = &quot;gcc -m32 -o $TARGET $SOURCES %s&quot; % socklib
+
+# Env for building the program
+comp = Environment( CCCOM = cccom,
+                    LINKCOM = linkcom,
+                    ENV = os.environ )
+Decider( 'MD5' )                  
+Default( comp.Program( output, Split( full_files ) ) )

Modified: branches/remotefs_int/rfs_server/main.c
===================================================================
--- branches/remotefs_int/rfs_server/main.c	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server/main.c	2010-11-12 16:48:54 UTC (rev 817)
@@ -1,6 +1,6 @@
 // Remote FS server
 
-#include &quot;pnet.h&quot;
+#include &quot;net.h&quot;
 #include &quot;remotefs.h&quot;
 #include &quot;eluarpc.h&quot;
 #include &quot;serial.h&quot;
@@ -8,12 +8,12 @@
 #include &quot;type.h&quot;
 #include &quot;log.h&quot;
 #include &quot;os_io.h&quot;
-#include &quot;netinit.h&quot;
 #include &lt;stdio.h&gt;
 #include &lt;limits.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
+#include &quot;rfs.h&quot;
 
 // ****************************************************************************
 // Local definitions
@@ -124,7 +124,7 @@
 // ****************************************************************************
 // UDP transport implementation
 
-static SOCKET trans_socket = INVALID_SOCKET_VALUE;
+static NET_SOCKET trans_socket = INVALID_SOCKET_VALUE;
 static struct sockaddr_in trans_from;
 
 // Helper: read (blocking) the specified number of bytes
@@ -137,7 +137,7 @@
   while( size )
   {
     fromlen = sizeof( trans_from );
-    readbytes = recvfrom( trans_socket, ( char* )dest, size, 0, ( struct sockaddr* )&amp;trans_from, &amp;fromlen );
+    readbytes = net_recvfrom( trans_socket, ( char* )dest, size, 0, ( struct sockaddr* )&amp;trans_from, &amp;fromlen, NET_INF_TIMEOUT );
     size -= readbytes;
     if( size == 0 )
       break;
@@ -174,7 +174,7 @@
   if( eluarpc_get_packet_size( rfs_buffer, &amp;temp16 ) != ELUARPC_ERR )
   {
     log_msg( &quot;send_response_packet: sending response packet of %u bytes\n&quot;, ( unsigned )temp16 );
-    sendto( trans_socket, ( char* )rfs_buffer, temp16, 0, ( struct sockaddr* )&amp;trans_from, sizeof( trans_from ) );
+    net_sendto( trans_socket, ( char* )rfs_buffer, temp16, 0, ( struct sockaddr* )&amp;trans_from, sizeof( trans_from ) );
   }  
 }
 
@@ -183,7 +183,7 @@
   int length;
   struct sockaddr_in server;
      
-  if( ( trans_socket = socket( AF_INET, SOCK_DGRAM, 0 ) ) &lt; 0 )
+  if( ( trans_socket = net_create_socket( AF_INET, SOCK_DGRAM, 0 ) ) == INVALID_SOCKET_VALUE )
   {
     log_err( &quot;Unable to create socket\n&quot; );
     return 1;
@@ -193,7 +193,7 @@
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = INADDR_ANY;
   server.sin_port = htons( server_port );
-  if( bind( trans_socket, ( struct sockaddr * )&amp;server, length ) &lt; 0 )
+  if( bind( net_socket( trans_socket ), ( struct sockaddr * )&amp;server, length ) &lt; 0 )
   {
    log_err( &quot;Unable to bind socket\n&quot; );
    return 0; 
@@ -204,11 +204,113 @@
 
 static void udp_cleanup()
 {
+  net_close( trans_socket );
 }
 
 static const RFS_TRANSPORT_DATA udp_transport_data = { udp_read_request_packet, udp_send_response_packet, udp_cleanup };
 
-// *****************************************************************************
+// ****************************************************************************
+// Memory transport implementation
+
+// Read state machine
+enum
+{
+  MEM_STATE_READ_LENGTH,
+  MEM_STATE_READ_REQUEST,
+  MEM_STATE_REQUEST_DONE
+};
+
+static int mem_read_len;
+static int mem_expected_len;
+static int mem_read_state;
+static int mem_response_flag;
+
+void rfs_mem_start_request()
+{
+  mem_read_state = MEM_STATE_READ_LENGTH;
+  mem_read_len = mem_expected_len = 0;
+  mem_response_flag = 0;
+}
+
+int rfs_mem_read_request_packet( int c )
+{
+  u16 temp16;
+  int res = 1;
+  
+  if( c == -1 )
+  {
+    rfs_mem_start_request();
+    return 0;
+  }
+  
+  switch( mem_read_state )
+  {
+    case MEM_STATE_READ_LENGTH:
+      rfs_buffer[ mem_read_len ++ ] = c;
+      if( mem_read_len == ELUARPC_START_OFFSET )
+      {
+        mem_read_len = 0;
+        if( eluarpc_get_packet_size( rfs_buffer, &amp;temp16 ) == ELUARPC_ERR )
+        {
+          log_msg( &quot;RFS read_request_packet: ERROR getting packet size.\n&quot; );
+          mem_read_state = MEM_STATE_REQUEST_DONE;
+          res = 0;
+        }
+        else
+        {
+          mem_read_state = MEM_STATE_READ_REQUEST;
+          mem_expected_len = temp16 - ELUARPC_START_OFFSET;
+        }        
+      }
+      break;
+      
+    case MEM_STATE_READ_REQUEST:
+      rfs_buffer[ ELUARPC_START_OFFSET + mem_read_len ] = c;
+      mem_read_len ++;
+      if( mem_read_len == mem_expected_len )  
+      {
+        mem_read_state = MEM_STATE_REQUEST_DONE;
+        mem_response_flag = 1;
+      }     
+      break;
+  }
+  
+  return res;
+}
+
+int rfs_mem_has_response()
+{
+  return mem_response_flag;
+}
+
+void rfs_mem_write_response( u16 *plen, u8 **pdata )
+{  
+  // Execute request  
+  server_execute_request( rfs_buffer );
+  
+  // Send response
+  if( eluarpc_get_packet_size( rfs_buffer, plen ) != ELUARPC_ERR )
+  {
+    log_msg( &quot;send_response_packet: sending response packet of %u bytes\n&quot;, ( unsigned )*plen );
+    *pdata = rfs_buffer;    
+  } 
+  else
+  {
+    log_msg( &quot;ERROR in send_response_packet!\n&quot; );
+    *plen = 0;
+  }
+}
+
+static int mem_server_init()
+{
+  rfs_mem_start_request();  
+  log_msg( &quot;RFS: using memory transport.\n&quot; );
+  return 1;   
+}
+
+static const RFS_TRANSPORT_DATA mem_transport_data = { NULL, NULL, NULL };
+
+// ****************************************************************************
 // Helper functions
 
 // Secure atoi
@@ -279,9 +381,18 @@
       return 0;
     }    
     if( net_init() == 0 )
+    { 
+      log_err( &quot;Unable to initialize network\n&quot; );
       return 0;
+    }
     return udp_server_init( tempi );   
   }
+  else if( !strcmp( s, &quot;mem&quot; ) )
+  {
+    // Direct memory transport, only used with mux in rfsmux mode
+    p_transport_data = &amp;mem_transport_data;
+    return mem_server_init( tempi ); 
+  }  
   log_err( &quot;Error: unsupported transport\n&quot; );
   return 0;
 }
@@ -289,26 +400,21 @@
 // *****************************************************************************
 // Entry point
 
-#ifdef RFS_STANDALONE_MODE
-#define RFS_MAIN_FUNC_NAME    main
-#else
-#define RFS_MAIN_FUNC_NAME    rfs_main
-#endif
-
 #define TRANSPORT_ARG_IDX     1
 #define DIRNAME_ARG_IDX       2
 #define VERBOSE_ARG_IDX       3
 #define MIN_ARGC_COUNT        3
 #define VERBOSE_ARGC_COUNT    4
 
-int RFS_MAIN_FUNC_NAME( int argc, const char **argv )
-{  
+int rfs_init( int argc, const char **argv )
+{
+  setvbuf( stdout, NULL, _IONBF, 0 );
   if( argc &lt; MIN_ARGC_COUNT )
   {
     log_err( &quot;Usage: %s &lt;transport&gt; &lt;dirname&gt; [-v]\n&quot;, argv[ 0 ] );
     log_err( &quot;  Serial transport: 'ser:&lt;sername&gt;,&lt;serspeed&gt;'\n&quot; );
     log_err( &quot;  UDP transport: 'udp:&lt;port&gt;'\n&quot; );
-    log_err( &quot;Use -v for verbose output.\n&quot;);
+    log_err( &quot;Use -v for verbose output.\n&quot; );
     return 1;
   }
   
@@ -324,11 +430,27 @@
   }  
   if( parse_transport_and_init( argv[ TRANSPORT_ARG_IDX ] ) == 0 )
     return 1;
-  
+    
     // Setup RFS server
   server_setup( argv[ DIRNAME_ARG_IDX ] );   
   log_msg( &quot;Sharing directory %s\n&quot;, argv[ DIRNAME_ARG_IDX ] );
+  return 0;
+} 
 
+#ifdef RFS_STANDALONE_MODE
+int main( int argc, const char **argv )
+{  
+  // Initialize data
+  if( rfs_init( argc, argv ) != 0 )
+    return 1;
+  
+  // 'mem' transport doesn't work in this mode
+  if( p_transport_data == &amp;mem_transport_data )
+  {
+    log_err( &quot;Invalid transport in standalone mode.\n&quot; );
+    return 1;
+  }
+  
   // Enter the server endless loop
   while( 1 )
   {
@@ -340,3 +462,4 @@
   p_transport_data-&gt;f_cleanup();
   return 0;
 }
+#endif

Copied: branches/remotefs_int/rfs_server/net.h (from rev 816, branches/remotefs_int/rfs_server/netinit.h)
===================================================================
--- branches/remotefs_int/rfs_server/net.h	                        (rev 0)
+++ branches/remotefs_int/rfs_server/net.h	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,44 @@
+// Network functions
+
+#ifndef __NETINIT_H__
+#define __NETINIT_H__
+
+#ifdef WIN32_BUILD
+
+#include &lt;winsock2.h&gt;
+#include &lt;windows.h&gt;
+typedef int socklen_t;
+typedef int ssize_t;
+#define INVALID_SOCKET_VALUE  NULL
+typedef struct 
+{
+  SOCKET s;
+  OVERLAPPED o;
+} NET_DATA;
+typedef NET_DATA* NET_SOCKET;
+#define net_socket( d )       ( d )-&gt;s
+typedef HANDLE net_sync_object;
+
+#else // #ifdef WIN32_BUILD
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;netdb.h&gt;
+#include &lt;sys/select.h&gt;
+typedef int NET_SOCKET;
+#define INVALID_SOCKET_VALUE  ( -1 )
+#define net_socket( s )       s
+typedef int net_sync_object;
+#endif // #ifdef WIN32_BUILD
+
+#define NET_INF_TIMEOUT       ( -1 )
+
+int net_init();
+NET_SOCKET net_create_socket( int domain, int type, int protocol );
+ssize_t net_recvfrom( NET_SOCKET s, void *buf, size_t len, int flags, struct sockaddr* from, socklen_t *fromlen, int timeout );
+ssize_t net_sendto( NET_SOCKET s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen );
+int net_close( NET_SOCKET s );
+net_sync_object net_get_sync_object( NET_SOCKET s );
+
+#endif

Added: branches/remotefs_int/rfs_server/net_posix.c
===================================================================
--- branches/remotefs_int/rfs_server/net_posix.c	                        (rev 0)
+++ branches/remotefs_int/rfs_server/net_posix.c	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,49 @@
+// Network functions (POSIX)
+
+#include &quot;net.h&quot;
+#include &quot;log.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;sys/select.h&gt;
+
+int net_init()
+{ 
+  return 1;
+}
+
+NET_SOCKET net_create_socket( int domain, int type, int protocol )
+{
+  return socket( domain, type, protocol ); 
+}
+
+ssize_t net_recvfrom( NET_SOCKET s, void *buf, size_t len, int flags, struct sockaddr* from, socklen_t *fromlen, int timeout )
+{
+  fd_set fds;
+  struct timeval tv;
+  
+  FD_ZERO( &amp;fds );
+  FD_SET( s, &amp;fds );
+  tv.tv_sec = timeout * 1000;
+  tv.tv_usec = 0;
+  if( select( s + 1, &amp;fds, NULL, NULL, timeout == NET_INF_TIMEOUT ? NULL : &amp;tv ) &lt;= 0 )
+    return 0;
+  return recvfrom( s, buf, len, flags, from, fromlen, timeout );      
+}
+
+ssize_t net_sendto( NET_SOCKET s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen )
+{
+  return sendto( s, buf, len, flags, to, tolen );
+}
+
+int net_close( NET_SOCKET s )
+{
+  return close( s );
+}
+
+net_sync_object net_get_sync_object( NET_SOCKET s )
+{
+  return s;
+}

Copied: branches/remotefs_int/rfs_server/net_win32.c (from rev 816, branches/remotefs_int/rfs_server/netinit.c)
===================================================================
--- branches/remotefs_int/rfs_server/net_win32.c	                        (rev 0)
+++ branches/remotefs_int/rfs_server/net_win32.c	2010-11-12 16:48:54 UTC (rev 817)
@@ -0,0 +1,102 @@
+// Network functions (WIN32)
+
+#include &quot;net.h&quot;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &quot;log.h&quot;
+
+int net_init()
+{
+  // The socket subsystem must be initialized if working in Windows
+  WORD wVersionRequested;
+  WSADATA wsaData;
+  int err;
+ 
+  wVersionRequested = MAKEWORD( 2, 0 );
+  err = WSAStartup( wVersionRequested, &amp;wsaData );  
+  if( err != 0 )
+  {
+    log_err( &quot;Unable to initialize the socket subsystem\n&quot; );
+    return 0;
+  }  
+  return 1;
+}
+
+NET_SOCKET net_create_socket( int domain, int type, int protocol )
+{
+  SOCKET s;
+  NET_SOCKET d;
+  
+  if( ( s = WSASocket( domain, type, protocol, NULL, 0, WSA_FLAG_OVERLAPPED ) ) == INVALID_SOCKET )
+    return INVALID_SOCKET_VALUE;
+  if( ( d = malloc( sizeof( NET_DATA ) ) ) == NULL )
+  {
+    closesocket( s );
+    return INVALID_SOCKET_VALUE;
+  } 
+  memset( d, 0, sizeof( NET_DATA ) );
+  d-&gt;s = s;
+  if( ( d-&gt;o.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) == NULL )
+  {
+    closesocket( s );
+    return INVALID_SOCKET_VALUE;
+  }
+  return d;  
+}
+
+ssize_t net_recvfrom( NET_SOCKET s, void *buf, size_t len, int flags, struct sockaddr* from, socklen_t *fromlen, int timeout )
+{
+  DWORD readbytes = 0;
+  DWORD rflags = ( DWORD )flags;
+  BOOL dwRes;
+  DWORD selflags;
+  WSABUF datadesc = { len, buf };
+  
+  ResetEvent( s-&gt;o.hEvent );
+  if( WSARecvFrom( s-&gt;s, &amp;datadesc, 1, &amp;readbytes, &amp;rflags, from, fromlen, &amp;s-&gt;o, NULL ) == SOCKET_ERROR )
+  {
+    if( WSAGetLastError() != WSA_IO_PENDING )
+      return 0;
+  }
+  else
+    return readbytes;
+  
+  dwRes = WaitForSingleObject( s-&gt;o.hEvent, timeout == NET_INF_TIMEOUT ? INFINITE : timeout );
+  if( dwRes == WAIT_OBJECT_0 ) 
+  {
+    if( !WSAGetOverlappedResult( s-&gt;s, &amp;s-&gt;o, &amp;readbytes, TRUE, &amp;selflags ) )
+      readbytes = 0;
+  }
+  else if( dwRes == WAIT_TIMEOUT )
+  {
+    WSAGetOverlappedResult( s-&gt;s, &amp;s-&gt;o, &amp;readbytes, TRUE, &amp;selflags );
+    readbytes = 0;
+  }
+  
+  return readbytes;    
+}
+
+ssize_t net_sendto( NET_SOCKET s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen )
+{
+  DWORD wrotebytes;
+  WSABUF datadesc = { len, ( char* )buf };
+    
+  if( WSASendTo( s-&gt;s, &amp;datadesc, 1, &amp;wrotebytes, flags, to, tolen, NULL, NULL ) == SOCKET_ERROR )
+    return 0;
+  return wrotebytes;
+}
+
+int net_close( NET_SOCKET s )
+{
+  closesocket( s-&gt;s );
+  CloseHandle( s-&gt;o.hEvent );
+  free( s );
+  return 0;  
+}
+
+net_sync_object net_get_sync_object( NET_SOCKET s )
+{
+  return s-&gt;o.hEvent;
+}
+
+

Deleted: branches/remotefs_int/rfs_server/netinit.c
===================================================================
--- branches/remotefs_int/rfs_server/netinit.c	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server/netinit.c	2010-11-12 16:48:54 UTC (rev 817)
@@ -1,34 +0,0 @@
-// Network initialization (needed under WIN32)
-
-#ifdef WIN32_BUILD
-
-#include &lt;winsock2.h&gt;
-#include &lt;windows.h&gt;
-#include &quot;log.h&quot;
-
-int net_init()
-{
-  // The socket subsystem must be initialized if working in Windows
-  WORD wVersionRequested;
-  WSADATA wsaData;
-  int err;
- 
-  wVersionRequested = MAKEWORD( 2, 0 );
-  err = WSAStartup( wVersionRequested, &amp;wsaData );  
-  if( err != 0 )
-  {
-    log_err( &quot;Unable to initialize the socket subsystem\n&quot; );
-    return 0;
-  }  
-  return 1;
-}
-
-#else //  #ifdef WIN32_BUILD
-
-int net_init()
-{
-  return 1;
-}
-
-#endif // #ifdef WIN32_BUILD
-

Deleted: branches/remotefs_int/rfs_server/netinit.h
===================================================================
--- branches/remotefs_int/rfs_server/netinit.h	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server/netinit.h	2010-11-12 16:48:54 UTC (rev 817)
@@ -1,8 +0,0 @@
-// Network initialization (needed under WIN32)
-
-#ifndef __NETINIT_H__
-#define __NETINIT_H__
-
-int net_init();
-
-#endif

Deleted: branches/remotefs_int/rfs_server/pnet.h
===================================================================
--- branches/remotefs_int/rfs_server/pnet.h	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server/pnet.h	2010-11-12 16:48:54 UTC (rev 817)
@@ -1,27 +0,0 @@
-// Platform dependent network definitions
-
-#ifndef __PNET_H__
-#define __PNET_H__
-
-#ifdef WIN32_BUILD
-
-#include &lt;winsock2.h&gt;
-#include &lt;windows.h&gt;
-typedef int socklen_t;
-#define socket_close  closesocket
-#define INVALID_SOCKET_VALUE  INVALID_SOCKET
-
-#else // #ifdef WIN32_BUILD
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;netdb.h&gt;
-#include &lt;sys/select.h&gt;
-typedef int SOCKET;
-#define socket_close  close
-#define INVALID_SOCKET_VALUE  ( -1 )
-
-#endif // #ifdef WIN32_BUILD
-
-#endif // #ifndef __PNET_H__

Modified: branches/remotefs_int/rfs_server/serial.h
===================================================================
--- branches/remotefs_int/rfs_server/serial.h	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server/serial.h	2010-11-12 16:48:54 UTC (rev 817)
@@ -36,5 +36,6 @@
 int ser_read_byte( ser_handler id, u32 timeout );
 u32 ser_write( ser_handler id, const u8 *src, u32 size );
 u32 ser_write_byte( ser_handler id, u8 data );
+int ser_select_byte( ser_handler *pobjects, unsigned nobjects, int timeout );
 
 #endif

Modified: branches/remotefs_int/rfs_server/serial_win32.c
===================================================================
--- branches/remotefs_int/rfs_server/serial_win32.c	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server/serial_win32.c	2010-11-12 16:48:54 UTC (rev 817)
@@ -9,7 +9,10 @@
 
 #define WIN_ERROR     ( HANDLE )-1
 #define WIN_MAX_PORT_NAME   1024
+#define MAX_HANDLES   1024
 
+static HANDLE sel_handlers[ MAX_HANDLES ];
+
 // Helper: set timeout
 static int ser_win32_set_timeouts( HANDLE hComm, DWORD ri, DWORD rtm, DWORD rtc, DWORD wtm, DWORD wtc )
 {   
@@ -127,22 +130,24 @@
 {
   HANDLE hComm = id-&gt;hnd;
   DWORD readbytes = 0;
-  BOOL fWaitingOnRead = FALSE;
   
-  ResetEvent( id-&gt;o.hEvent );
-  if( ReadFile( hComm, dest, maxsize, &amp;readbytes, &amp;id-&gt;o ) == FALSE )
+  if( !id-&gt;fWaitingOnRead )
   {
-    if( GetLastError() != ERROR_IO_PENDING )   
-      return 0;
+    if( ReadFile( hComm, dest, maxsize, &amp;readbytes, &amp;id-&gt;o ) == FALSE )
+    {
+      if( GetLastError() != ERROR_IO_PENDING )   
+        return 0;
+      else
+        id-&gt;fWaitingOnRead = TRUE;
+    }
     else
-      fWaitingOnRead = TRUE;
+      return readbytes;
   }
-  else
-    return readbytes;
-    
-  if( fWaitingOnRead )
+      
+  if( id-&gt;fWaitingOnRead )
   {
-    BOOL dwRes = WaitForSingleObject( id-&gt;o.hEvent, timeout == SER_INF_TIMEOUT ? INFINITE : timeout );
+    DWORD dwRes = WaitForSingleObject( id-&gt;o.hEvent, timeout == SER_INF_TIMEOUT ? INFINITE : timeout );
+    ResetEvent( id-&gt;o.hEvent );    
     if( dwRes == WAIT_OBJECT_0 ) 
     {
       if( !GetOverlappedResult( hComm, &amp;id-&gt;o, &amp;readbytes, TRUE ) )
@@ -155,6 +160,7 @@
       readbytes = 0;
     }
   }  
+  id-&gt;fWaitingOnRead = FALSE;  
   return readbytes;
 }
 
@@ -187,7 +193,7 @@
 
   if( fWaitingOnWrite )
   {
-    BOOL dwRes = WaitForSingleObject( id-&gt;o.hEvent, INFINITE );
+    DWORD dwRes = WaitForSingleObject( id-&gt;o.hEvent, INFINITE );
     if( dwRes == WAIT_OBJECT_0 )
       if( !GetOverlappedResult( hComm, &amp;id-&gt;o, &amp;written, FALSE ) )
         written = 0;
@@ -201,3 +207,68 @@
 {
   return ser_write( id, &amp;data, 1 );
 }
+
+// Perform 'select' on the specified handler(s), returning a single byte 
+// if it could be read (plus the object ID in the upper 8 bits) and -1
+// otherwise
+int ser_select_byte( ser_handler *pobjects, unsigned nobjects, int timeout )
+{
+  unsigned i;
+  int wait_on_read = 0;
+  DWORD readbytes;
+  int res;
+  
+  // Try to read directly first
+  for( i = 0; i &lt; nobjects; i ++ )
+    if( !pobjects[ i ]-&gt;fWaitingOnRead )
+    {
+      if( ReadFile( pobjects[ i ]-&gt;hnd, &amp;pobjects[ i ]-&gt;databuf, 1, &amp;readbytes, &amp;pobjects[ i ]-&gt;o ) == FALSE )
+      {
+        if( GetLastError() != ERROR_IO_PENDING )   
+          return -1;
+        else
+        {
+          pobjects[ i ]-&gt;fWaitingOnRead = TRUE;
+          wait_on_read = 1;
+        }
+      }
+      else
+      {
+        if( readbytes == 1 )
+          return pobjects[ i ]-&gt;databuf | ( i &lt;&lt; 8 );
+        else
+          return -1;
+      }    
+    }
+    
+  // Populate handler array  
+  for( i = 0; i &lt; nobjects; i ++ )
+    sel_handlers[ i ] = pobjects[ i ]-&gt;o.hEvent;
+    
+  if( wait_on_read )
+  {
+    DWORD dwRes = WaitForMultipleObjects( nobjects, sel_handlers, FALSE, timeout == SER_INF_TIMEOUT ? INFINITE : timeout );
+    if( dwRes &gt;= WAIT_OBJECT_0 &amp;&amp; dwRes &lt; WAIT_OBJECT_0 + nobjects ) 
+    {
+      i = dwRes - WAIT_OBJECT_0;
+      pobjects[ i ]-&gt;fWaitingOnRead = FALSE;
+      if( !GetOverlappedResult( pobjects[ i ]-&gt;hnd, &amp;pobjects[ i ]-&gt;o, &amp;readbytes, TRUE ) )
+        res = -1;
+      else if( readbytes == 1 )
+        res = pobjects[ i ]-&gt;databuf | ( i &lt;&lt; 8 );
+      ResetEvent( pobjects[ i ]-&gt;o.hEvent );        
+    }
+    else if( dwRes == WAIT_TIMEOUT )
+    {
+      for( i = 0; i &lt; nobjects; i ++ )
+      {
+        CancelIo( pobjects[ i ]-&gt;hnd );
+        GetOverlappedResult( pobjects[ i ]-&gt;hnd, &amp;pobjects[ i ]-&gt;o, &amp;readbytes, TRUE );
+        pobjects[ i ]-&gt;fWaitingOnRead = FALSE;
+        ResetEvent( pobjects[ i ]-&gt;o.hEvent );
+      }
+    }
+  }  
+  
+  return res;    
+}

Modified: branches/remotefs_int/rfs_server/type.h
===================================================================
--- branches/remotefs_int/rfs_server/type.h	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server/type.h	2010-11-12 16:48:54 UTC (rev 817)
@@ -19,16 +19,20 @@
 {
   HANDLE hnd;
   OVERLAPPED o;
+  BOOL fWaitingOnRead;
+  u8 databuf;
 } SERIAL_DATA;
 typedef SERIAL_DATA* ser_handler;
 #define SER_HANDLER_INVALID   ( NULL )
-typedef OVERLAPPED* ser_sync_object;
+typedef HANDLE sync_object;
+
 #else // #ifdef WIN32_BUILD
 
 // Assume POSIX here
 
 typedef int ser_handler;
 #define SER_HANDLER_INVALID   ( -1 )
+typedef int sync_object;
 
 #endif // #ifdef WIN32_BUILD
                                     

Modified: branches/remotefs_int/rfs_server.py
===================================================================
--- branches/remotefs_int/rfs_server.py	2010-11-11 23:47:37 UTC (rev 816)
+++ branches/remotefs_int/rfs_server.py	2010-11-12 16:48:54 UTC (rev 817)
@@ -13,12 +13,12 @@
   if sim == '1':
     print &quot;SIM target not supported under Windows&quot;
     os.exit( 1 )
-  flist = &quot;main.c server.c os_io_win32.c log.c netinit.c&quot;
+  flist = &quot;main.c server.c os_io_win32.c log.c net_win32.c serial_win32.c&quot;
   cdefs = cdefs + &quot; -DWIN32_BUILD&quot;
   exeprefix = &quot;exe&quot;
-  socklib = '-lwsock32'
+  socklib = '-lws2_32'
 else:
-  flist = &quot;%s server.c os_io_posix.c log.c netinit.c&quot; % mainname
+  flist = &quot;%s server.c os_io_posix.c log.c net_posix.c serial_posix.c&quot; % mainname
   exeprefix = &quot;elf&quot;
 
 if sim == '0':
@@ -29,10 +29,6 @@
 
 full_files = &quot; &quot; + &quot; &quot;.join( [ &quot;rfs_server/%s&quot; % name for name in flist.split() ] )
 full_files = full_files + &quot; src/remotefs/remotefs.c src/eluarpc.c&quot;
-if platform.system() == &quot;Windows&quot;:
-  full_files = full_files + &quot; rfs_server/serial_win32.c&quot;
-else:
-  full_files = full_files + &quot; rfs_server/serial_posix.c&quot;
 local_include = &quot;-Irfs_server -Iinc/remotefs -Iinc&quot;
 
 # Compiler/linker options


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000769.html">[Elua-svn] r816 - in branches/remotefs_int: doc/en inc src	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc17xx src/platform/lpc24xx	src/platform/lpc288x src/platform/sim src/platform/stm32	src/platform/str7 src/platform/str9
</A></li>
	<LI>Next message: <A HREF="000771.html">[Elua-svn] r818 - in branches/remotefs_int: . inc inc/remotefs mux	rfs_server src src/modules src/platform/stm32
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#770">[ date ]</a>
              <a href="thread.html#770">[ thread ]</a>
              <a href="subject.html#770">[ subject ]</a>
              <a href="author.html#770">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
