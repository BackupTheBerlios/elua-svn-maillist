<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r808 - in trunk: . inc romfs src src/lua src/modules	src/platform/lpc24xx
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r808%20-%20in%20trunk%3A%20.%20inc%20romfs%20src%20src/lua%20src/modules%0A%09src/platform/lpc24xx&In-Reply-To=%3C20101103235728.39532480C33%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000762.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r808 - in trunk: . inc romfs src src/lua src/modules	src/platform/lpc24xx</H1>
    <B>bogdanm at mail.berlios.de</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r808%20-%20in%20trunk%3A%20.%20inc%20romfs%20src%20src/lua%20src/modules%0A%09src/platform/lpc24xx&In-Reply-To=%3C20101103235728.39532480C33%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r808 - in trunk: . inc romfs src src/lua src/modules	src/platform/lpc24xx">bogdanm at mail.berlios.de
       </A><BR>
    <I>Thu Nov  4 00:57:27 CET 2010</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000762.html">[Elua-svn] r809 - in trunk: inc src src/modules	src/platform/lpc24xx src/platform/str9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#761">[ date ]</a>
              <a href="thread.html#761">[ thread ]</a>
              <a href="subject.html#761">[ subject ]</a>
              <a href="author.html#761">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2010-11-04 00:57:27 +0100 (Thu, 04 Nov 2010)
New Revision: 808

Added:
   trunk/src/common_tmr.c
   trunk/src/platform/lpc24xx/platform_int.c
Modified:
   trunk/SConstruct
   trunk/inc/common.h
   trunk/inc/elua_int.h
   trunk/inc/platform.h
   trunk/romfs/inttest.lua
   trunk/src/common.c
   trunk/src/elua_int.c
   trunk/src/lua/lrodefs.h
   trunk/src/lua/lrotable.h
   trunk/src/lua/lstate.c
   trunk/src/modules/cpu.c
   trunk/src/modules/tmr.c
   trunk/src/platform/lpc24xx/conf.py
   trunk/src/platform/lpc24xx/platform.c
   trunk/src/platform/lpc24xx/platform_conf.h
Log:
- Changed interrupt support infrastructure. No docs yet (will be added later), but check src/platform/lpc24xx/platform_int.c for a quick glimpse of the concept.
- Added direct access to interrupt flags; an interrupt doesn't have to trigger a handler anymore, its flag(s) can be checked instead (platform_cpu_get_interrupt_flag).
- Added experimental C interrupt handlers support (NOT TESTED). It can be compiled and used separately from the Lua interrupt support implementation. Hint: src/elua_int.c, elua_int_set_c_handler and elua_int_get_c_handler, also BUILD_C_INT_HANDLERS (as opposed to BUILD_LUA_INT_HANDLERS).
- Added tmr.set_match_int function that sets a match interrupt on a timer (one-shot or cyclic). Also works on virtual timers. In fact, it currently works only on virtual timers, as none of the platforms have support for this operation with hardware timers.
-Added more interrupt support functions in the CPU module.

All of the above were implemented and tested on the ELUA-PUC board, and nothing else. As a side effect, THIS COMMIT BRAKES THE STR912 PORT! The port will be modified to take advantage of the new interrupt structure soon; until then, please don't update it.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/SConstruct	2010-11-03 23:57:27 UTC (rev 808)
@@ -380,7 +380,8 @@
   local_libs = ''
 
   # Application files
-  app_files = &quot; src/main.c src/romfs.c src/semifs.c src/xmodem.c src/shell.c src/term.c src/common.c src/buf.c src/elua_adc.c src/dlmalloc.c src/salloc.c src/luarpc_elua_uart.c src/elua_int.c &quot;
+  app_files = &quot;&quot;&quot; src/main.c src/romfs.c src/semifs.c src/xmodem.c src/shell.c src/term.c src/common.c src/common_tmr.c src/buf.c src/elua_adc.c src/dlmalloc.c 
+                  src/salloc.c src/luarpc_elua_uart.c src/elua_int.c &quot;&quot;&quot;
 
   # Newlib related files
   newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c src/newlib/stdtcp.c&quot;

Modified: trunk/inc/common.h
===================================================================
--- trunk/inc/common.h	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/inc/common.h	2010-11-03 23:57:27 UTC (rev 808)
@@ -3,6 +3,8 @@
 #ifndef __COMMON_H__
 #define __COMMON_H__
 
+#include &quot;elua_int.h&quot;
+
 // Virtual timers data
 #define VTMR_FIRST_ID           ( 32 )
 #define VTMR_GET_ID( x )        ( ( x ) - VTMR_FIRST_ID )
@@ -11,7 +13,13 @@
 // Functions exported by the common platform layer
 void cmn_platform_init();
 void cmn_virtual_timer_cb();
+void cmn_int_handler( elua_int_id id, elua_int_resnum resnum );
+// Timer-specific functions
+int cmn_tmr_int_set_status( elua_int_resnum resnum, int status );
+int cmn_tmr_int_get_status( elua_int_resnum resnum );
+int cmn_tmr_int_get_flag( elua_int_resnum resnum, int clear );
 
 unsigned int intlog2( unsigned int v );
 
 #endif // #ifndef __COMMON_H__
+

Modified: trunk/inc/elua_int.h
===================================================================
--- trunk/inc/elua_int.h	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/inc/elua_int.h	2010-11-03 23:57:27 UTC (rev 808)
@@ -14,6 +14,9 @@
 #define ELUA_INT_FIRST_ID               1
 #define ELUA_INT_INVALID_INTERRUPT      0xFF
 
+// &quot;Any resnum&quot; value for &quot;get flag&quot; functions
+#define ELUA_INT_RESNUM_ANY             0xFFFF
+
 // This is what gets pushed in the interrupt queue
 typedef struct 
 {
@@ -21,6 +24,20 @@
   elua_int_resnum resnum;
 } elua_int_element;
 
+// Interrupt functions and descriptor
+typedef int ( *elua_int_p_set_status )( elua_int_resnum resnum, int state ); 
+typedef int ( *elua_int_p_get_status )( elua_int_resnum resnum );
+typedef int ( *elua_int_p_get_flag )( elua_int_resnum resnum, int clear );
+typedef struct 
+{
+  elua_int_p_set_status int_set_status;
+  elua_int_p_get_status int_get_status;
+  elua_int_p_get_flag int_get_flag;
+} elua_int_descriptor;
+
+// C interrupt handlers
+typedef void( *elua_int_c_handler )( elua_int_resnum resnum );
+
 // Handler key in the registry
 #define LUA_INT_HANDLER_KEY             ( int )&amp;elua_int_add
 
@@ -33,7 +50,10 @@
 void elua_int_enable( elua_int_id inttype );
 void elua_int_disable( elua_int_id inttype );
 int elua_int_is_enabled( elua_int_id inttype );
+void elua_int_cleanup();
 void elua_int_disable_all();
+elua_int_c_handler elua_int_set_c_handler( elua_int_id inttype, elua_int_c_handler phandler );
+elua_int_c_handler elua_int_get_c_handler( elua_int_id inttype );
 
 #endif
 

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/inc/platform.h	2010-11-03 23:57:27 UTC (rev 808)
@@ -17,6 +17,7 @@
 
 // Platform initialization
 int platform_init();
+void platform_int_init();
 
 // *****************************************************************************
 // PIO subsection
@@ -151,6 +152,16 @@
 // Data types
 typedef u32 timer_data_type;
 
+// Interrupt types
+#define PLATFORM_TIMER_INT_ONESHOT            1
+#define PLATFORM_TIMER_INT_CYCLIC             2
+
+// Match interrupt error codes
+#define PLATFORM_TIMER_INT_OK                 0
+#define PLATFORM_TIMER_INT_TOO_SHORT          1
+#define PLATFORM_TIMER_INT_INVALID_ID         2  
+#define PLATFORM_TIMER_INT_GENERIC_ERR        3         
+
 // Timer operations
 enum
 {
@@ -159,8 +170,7 @@
   PLATFORM_TIMER_OP_SET_CLOCK,
   PLATFORM_TIMER_OP_GET_CLOCK,
   PLATFORM_TIMER_OP_GET_MAX_DELAY,
-  PLATFORM_TIMER_OP_GET_MIN_DELAY,
-  PLATFORM_TIMER_OP_SET_INT_TIMEOUT
+  PLATFORM_TIMER_OP_GET_MIN_DELAY
 };
 
 // The platform timer functions
@@ -169,6 +179,8 @@
 void platform_s_timer_delay( unsigned id, u32 delay_us );
 u32 platform_timer_op( unsigned id, int op, u32 data );
 u32 platform_s_timer_op( unsigned id, int op, u32 data );
+int platform_timer_set_match_int( unsigned id, u32 period_us, int type );
+int platform_s_timer_set_match_int( unsigned id, u32 period_us, int type );
 u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start );
 
 // *****************************************************************************
@@ -197,10 +209,18 @@
 #define PLATFORM_CPU_DISABLE            0
 #define PLATFORM_CPU_ENABLE             1
 
+// Interrupt functions return status
+#define PLATFORM_INT_OK                 0
+#define PLATFORM_INT_GENERIC_ERROR      ( -1 )
+#define PLATFORM_INT_INVALID            ( -2 )
+#define PLATFORM_INT_NOT_HANDLED        ( -3 )
+#define PLATFORM_INT_NOT_ANY            ( -4 )
+
 int platform_cpu_set_global_interrupts( int status );
 int platform_cpu_get_global_interrupts();
 int platform_cpu_set_interrupt( elua_int_id id, elua_int_resnum resnum, int status );
 int platform_cpu_get_interrupt( elua_int_id id, elua_int_resnum resnum );
+int platform_cpu_get_interrupt_flag( elua_int_id id, elua_int_resnum resnum, int clear );
 u32 platform_cpu_get_frequency();
 
 // *****************************************************************************

Modified: trunk/romfs/inttest.lua
===================================================================
--- trunk/romfs/inttest.lua	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/romfs/inttest.lua	2010-11-03 23:57:27 UTC (rev 808)
@@ -1,5 +1,6 @@
 local vtmrid = tmr.VIRT0
 local to = 1500000
+local uartid = 0 
 
 local function handler( id, resnum )
   print( string.format( &quot;Got interrupt with id %d and resnum %d&quot;, id, resnum ) )
@@ -7,18 +8,19 @@
     local port, pin = pio.decode( resnum )
     print( string.format( &quot;Port is %d, pin is %d&quot;, port, pin ) )
   elseif id == cpu.INT_TMR_MATCH then
-    print &quot;Timer interrupt! Rearming ... &quot;
-    tmr.setinttimeout( vtmrid, to )
+    print &quot;Timer interrupt!&quot;
   end
 end
 
 cpu.set_int_handler( handler )
+tmr.set_match_int( vtmrid, to, tmr.INT_CYCLIC )
 cpu.sei( cpu.INT_GPIO_NEGEDGE, pio.P0_0 )
 cpu.sei( cpu.INT_TMR_MATCH, vtmrid )
-tmr.setinttimeout( vtmrid, to )
+
 local tmrid = 0
 while true do
   print &quot;Outside interrupt&quot; 
   for i = 1, 1000 do tmr.delay( tmrid, 1000 ) end
+  if uart.getchar( uartid, 0 ) ~= &quot;&quot; then break end 
 end
 

Modified: trunk/src/common.c
===================================================================
--- trunk/src/common.c	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/common.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -15,6 +15,17 @@
 #include &quot;xmodem.h&quot;
 #include &quot;elua_int.h&quot;
 
+#if defined( BUILD_LUA_INT_HANDLERS ) || defined( BUILD_C_INT_HANDLERS )
+#define BUILD_INT_HANDLERS
+
+#ifndef INT_TMR_MATCH
+#define INT_TMR_MATCH         ELUA_INT_INVALID_INTERRUPT
+#endif
+
+extern elua_int_descriptor elua_int_table[ INT_ELUA_LAST ];
+
+#endif
+
 // ****************************************************************************
 // XMODEM support code
 
@@ -125,6 +136,10 @@
 
 void cmn_platform_init()
 {
+#ifdef BUILD_LUA_INT_HANDLERS
+  platform_int_init();
+#endif
+
   // Set the send/recv functions                          
   std_set_send_func( uart_send );
   std_set_get_func( uart_recv );  
@@ -227,161 +242,6 @@
 }
 
 // ****************************************************************************
-// Timers (and vtimers) functions
-
-#if VTMR_NUM_TIMERS &gt; 0
-static volatile u32 vtmr_counters[ VTMR_NUM_TIMERS ];
-static volatile s8 vtmr_reset_idx = -1;
-
-#ifdef BUILD_LUA_INT_HANDLERS
-static volatile u32 vtmr_period_limit[ VTMR_NUM_TIMERS ];  
-static volatile u8 vtmr_int_enabled[ ( VTMR_NUM_TIMERS + 7 ) &gt;&gt; 3 ];
-#endif // #ifdef BUILD_LUA_INTERRUPT_HANDLERS
-
-// This should be called from the platform's timer interrupt at VTMR_FREQ_HZ
-void cmn_virtual_timer_cb()
-{
-  unsigned i;
-
-  for( i = 0; i &lt; VTMR_NUM_TIMERS; i ++ )
-  {
-    vtmr_counters[ i ] ++;  
-#ifdef BUILD_LUA_INT_HANDLERS
-    if( ( vtmr_int_enabled[ i &gt;&gt; 3 ] &amp; ( 1 &lt;&lt; ( i &amp; 0x07 ) ) ) &amp;&amp; ( vtmr_counters[ i ] == vtmr_period_limit[ i ] ) )
-    {
-      vtmr_int_enabled[ i &gt;&gt; 3 ] &amp;= ( u8 )~( 1 &lt;&lt; ( i &amp; 0x07 ) );    
-      elua_int_add( INT_TMR_MATCH, i + VTMR_FIRST_ID );
-    }
-#endif // #ifdef BUILD_LUA_INT_HANDLERS
-  }    
-  if( vtmr_reset_idx != -1 )
-  {
-    vtmr_counters[ vtmr_reset_idx ] = 0;
-    vtmr_reset_idx = -1;
-  }
-}
-
-static void vtmr_reset_timer( unsigned vid )
-{
-  unsigned id = VTMR_GET_ID( vid );
-
-  vtmr_reset_idx = ( s8 )id;
-  while( vtmr_reset_idx != -1 );  
-}
-
-static void vtmr_delay( unsigned vid, u32 delay_us )
-{
-  timer_data_type final;
-  unsigned id = VTMR_GET_ID( vid );
-  
-  final = ( ( u64 )delay_us * VTMR_FREQ_HZ ) / 1000000;
-  vtmr_reset_timer( vid );
-  while( vtmr_counters[ id ] &lt; final );  
-}
-
-#ifdef BUILD_LUA_INT_HANDLERS
-static int vtmr_set_int_timeout( unsigned vid, u32 delay_us )
-{
-  timer_data_type final;
-  unsigned id = VTMR_GET_ID( vid );
-    
-  if( ( final = ( ( u64 )delay_us * VTMR_FREQ_HZ ) / 1000000 ) == 0 )
-    return 0;
-  vtmr_period_limit[ id ] = final;
-  vtmr_reset_timer( vid );  
-  vtmr_int_enabled[ id &gt;&gt; 3 ] |= 1 &lt;&lt; ( id &amp; 0x07 );    
-  return 1; 
-}
-#else // #ifdef BUILD_LUA_INT_HANDLERS
-static int vtmr_set_int_timeout( unsigned vid, u32 delay_us )
-{
-  fprintf( stderr, &quot;Timeouts with interrupts not available when Lua interrupt support is not enabled\n&quot; );
-  return 0;
-}
-#endif // #ifdef BUILD_LUA_INT_HANDLERS
-
-#else // #if VTMR_NUM_TIMERS &gt; 0
-
-void cmn_virtual_timer_cb()
-{
-}
-#endif // #if VTMR_NUM_TIMERS &gt; 0
-
-int platform_timer_exists( unsigned id )
-{
-#if VTMR_NUM_TIMERS &gt; 0
-  if( id &gt;= VTMR_FIRST_ID )
-    return TIMER_IS_VIRTUAL( id );
-  else
-#endif
-    return id &lt; NUM_TIMER;
-}
-
-void platform_timer_delay( unsigned id, u32 delay_us )
-{
-#if VTMR_NUM_TIMERS &gt; 0
-  if( TIMER_IS_VIRTUAL( id ) )
-    vtmr_delay( id, delay_us );
-  else
-#endif
-    platform_s_timer_delay( id, delay_us );
-}
-      
-u32 platform_timer_op( unsigned id, int op, u32 data )
-{
-  u32 res = 0;
-
-  if( ( VTMR_NUM_TIMERS == 0 ) || ( !TIMER_IS_VIRTUAL( id ) ) )
-    return platform_s_timer_op( id, op, data );
-#if VTMR_NUM_TIMERS &gt; 0
-  switch( op )
-  {
-    case PLATFORM_TIMER_OP_START:
-      vtmr_reset_timer( id );
-      res = 0;
-      break;
-      
-    case PLATFORM_TIMER_OP_READ:
-      res = vtmr_counters[ VTMR_GET_ID( id ) ];
-      break;
-      
-    case PLATFORM_TIMER_OP_GET_MAX_DELAY:
-      res = platform_timer_get_diff_us( id, 0, 0xFFFFFFFF );
-      break;
-      
-    case PLATFORM_TIMER_OP_GET_MIN_DELAY:
-      res = platform_timer_get_diff_us( id, 0, 1 );
-      break;
-      
-    case PLATFORM_TIMER_OP_SET_CLOCK:
-    case PLATFORM_TIMER_OP_GET_CLOCK:
-      res = VTMR_FREQ_HZ;
-      break;      
-      
-    case PLATFORM_TIMER_OP_SET_INT_TIMEOUT:
-      res = vtmr_set_int_timeout( id, data );
-      break;
-  }
-#endif
-  return res;
-}
-
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
-{
-  timer_data_type temp;
-  u32 freq;
-    
-  freq = platform_timer_op( id, PLATFORM_TIMER_OP_GET_CLOCK, 0 );
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / freq;
-}
-
-// ****************************************************************************
 // CAN functions
 
 int platform_can_exists( unsigned id )
@@ -512,7 +372,65 @@
 }
 
 // ****************************************************************************
+// Interrupt support
+#ifdef BUILD_INT_HANDLERS
+
+int platform_cpu_set_interrupt( elua_int_id id, elua_int_resnum resnum, int status )
+{
+  elua_int_p_set_status ps;
+
+  if( id &lt; ELUA_INT_FIRST_ID || id &gt; INT_ELUA_LAST )
+    return PLATFORM_INT_INVALID;
+  if( ( ps = elua_int_table[ id - ELUA_INT_FIRST_ID ].int_set_status ) == NULL )
+    return PLATFORM_INT_NOT_HANDLED;
+  if( id == INT_TMR_MATCH )
+    return cmn_tmr_int_set_status( resnum, status );
+  return ps( resnum, status );
+}
+
+int platform_cpu_get_interrupt( elua_int_id id, elua_int_resnum resnum )
+{
+  elua_int_p_get_status pg;
+
+  if( id &lt; ELUA_INT_FIRST_ID || id &gt; INT_ELUA_LAST )
+    return PLATFORM_INT_INVALID;
+  if( ( pg = elua_int_table[ id - ELUA_INT_FIRST_ID ].int_get_status ) == NULL )
+    return PLATFORM_INT_NOT_HANDLED;
+  if( id == INT_TMR_MATCH )
+    return cmn_tmr_int_get_status( resnum );
+  return pg( resnum );
+}
+
+int platform_cpu_get_interrupt_flag( elua_int_id id, elua_int_resnum resnum, int clear )
+{
+  elua_int_p_get_flag pf;
+
+  if( id &lt; ELUA_INT_FIRST_ID || id &gt; INT_ELUA_LAST )
+    return PLATFORM_INT_INVALID;
+  if( ( pf = elua_int_table[ id - ELUA_INT_FIRST_ID ].int_get_flag ) == NULL )
+    return PLATFORM_INT_NOT_HANDLED;
+  if( id == INT_TMR_MATCH )
+    return cmn_tmr_int_get_flag( resnum, clear );
+  else    
+    return pf( resnum, clear );
+}
+
+// Common interrupt handling
+void cmn_int_handler( elua_int_id id, elua_int_resnum resnum )
+{
+  elua_int_add( id, resnum );
+#ifdef BUILD_C_INT_HANDLERS
+  elua_int_c_handler phnd = elua_int_get_c_handler( id );
+  if( phnd )
+    phnd( resnum );
+#endif
+}
+
+#endif // #ifdef BUILD_INT_HANDLERS
+
+// ****************************************************************************
 // Misc support
+
 unsigned int intlog2( unsigned int v )
 {
   unsigned r = 0;

Added: trunk/src/common_tmr.c
===================================================================
--- trunk/src/common_tmr.c	                        (rev 0)
+++ trunk/src/common_tmr.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -0,0 +1,289 @@
+// Common code, timer section
+// Also implements virtual timers
+
+#include &quot;platform.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;type.h&quot;
+#include &quot;common.h&quot;
+#include &quot;elua_int.h&quot;
+#include &lt;stdio.h&gt;
+
+// [TODO] when the new build system is ready, automatically add the
+// code below in platform_conf.h
+#if defined( BUILD_LUA_INT_HANDLERS ) || defined( BUILD_C_INT_HANDLERS )
+#define BUILD_INT_HANDLERS
+
+#ifndef INT_TMR_MATCH
+#define INT_TMR_MATCH         ELUA_INT_INVALID_INTERRUPT
+#endif
+
+extern elua_int_descriptor elua_int_table[ INT_ELUA_LAST ];
+
+#endif
+
+// ****************************************************************************
+// Timers (and vtimers) functions
+
+#if VTMR_NUM_TIMERS &gt; 0
+
+// ============================================================================
+// VTMR functions
+
+static volatile u32 vtmr_counters[ VTMR_NUM_TIMERS ];
+static volatile s8 vtmr_reset_idx = -1;
+
+#if defined( BUILD_INT_HANDLERS ) &amp;&amp; ( INT_TMR_MATCH != ELUA_INT_INVALID_INTERRUPT )
+#define CMN_TIMER_INT_SUPPORT
+#endif // #if defined( BUILD_INT_HANDLERS ) &amp;&amp; ( INT_TMR_MATCH != ELUA_INT_INVALID_INTERRUPT )
+
+#ifdef CMN_TIMER_INT_SUPPORT
+static volatile u32 vtmr_period_limit[ VTMR_NUM_TIMERS ];  
+static volatile u8 vtmr_int_periodic_flag[ ( VTMR_NUM_TIMERS + 7 ) &gt;&gt; 3 ];
+static volatile u8 vtmr_int_enabled[ ( VTMR_NUM_TIMERS + 7 ) &gt;&gt; 3 ];
+static volatile u8 vtmr_int_flag[ ( VTMR_NUM_TIMERS + 7 ) &gt;&gt; 3 ];
+#endif // #ifdef CMN_TIMER_INT_SUPPORT
+
+// This should be called from the platform's timer interrupt at VTMR_FREQ_HZ
+void cmn_virtual_timer_cb()
+{
+  unsigned i;
+  u8 msk;
+
+  for( i = 0; i &lt; VTMR_NUM_TIMERS; i ++ )
+  {
+    vtmr_counters[ i ] ++;  
+#ifdef CMN_TIMER_INT_SUPPORT
+    msk = 1 &lt;&lt; ( i &amp; 0x07 );
+    if( vtmr_counters[ i ] &gt;= vtmr_period_limit[ i ] )
+    {
+      vtmr_int_flag[ i &gt;&gt; 3 ] |= msk;
+      if( vtmr_int_enabled[ i &gt;&gt; 3 ] &amp; msk )      
+        elua_int_add( INT_TMR_MATCH, i + VTMR_FIRST_ID );
+      if( vtmr_int_periodic_flag[ i &gt;&gt; 3 ] &amp; msk )
+        vtmr_counters[ i ] = 0;
+      else
+        vtmr_int_enabled[ i &gt;&gt; 3 ] &amp;= ( u8 )~msk;    
+    }
+#endif // #ifdef CMN_TIMER_INT_SUPPORT
+  }    
+  if( vtmr_reset_idx != -1 )
+  {
+    vtmr_counters[ vtmr_reset_idx ] = 0;
+    vtmr_reset_idx = -1;
+  }
+}
+
+static void vtmr_reset_timer( unsigned vid )
+{
+  unsigned id = VTMR_GET_ID( vid );
+
+  vtmr_reset_idx = ( s8 )id;
+  while( vtmr_reset_idx != -1 );  
+}
+
+static void vtmr_delay( unsigned vid, u32 delay_us )
+{
+  timer_data_type final;
+  unsigned id = VTMR_GET_ID( vid );
+  
+  final = ( ( u64 )delay_us * VTMR_FREQ_HZ ) / 1000000;
+  vtmr_reset_timer( vid );
+  while( vtmr_counters[ id ] &lt; final );  
+}
+
+#ifdef CMN_TIMER_INT_SUPPORT
+static int vtmr_set_match_int( unsigned vid, u32 period_us, int type )
+{
+  timer_data_type final;
+  unsigned id = VTMR_GET_ID( vid );
+  u8 msk = 1 &lt;&lt; ( id &amp; 0x07 );
+
+  if( period_us == 0 )
+  {
+    vtmr_int_enabled[ id &gt;&gt; 3 ] &amp;= ( u8 )~msk;
+    vtmr_int_flag[ id &gt;&gt; 3 ] &amp;= ( u8 )~msk;
+    return PLATFORM_TIMER_INT_OK;
+  }
+  if( ( final = ( ( u64 )period_us * VTMR_FREQ_HZ ) / 1000000 ) == 0 )
+    return PLATFORM_TIMER_INT_TOO_SHORT;
+  vtmr_period_limit[ id ] = final;
+  vtmr_reset_timer( vid ); 
+  if( type == PLATFORM_TIMER_INT_ONESHOT )
+    vtmr_int_periodic_flag[ id &gt;&gt; 3 ] &amp;= ( u8 )~msk;
+  else
+    vtmr_int_periodic_flag[ id &gt;&gt; 3 ] |= msk;
+  vtmr_int_flag[ id &gt;&gt; 3 ] &amp;= ( u8 )~msk;
+  vtmr_int_enabled[ id &gt;&gt; 3 ] |= msk;
+  return PLATFORM_TIMER_INT_OK;
+}
+
+static int vtmr_int_get_flag( elua_int_resnum resnum, int clear )
+{
+  unsigned id = VTMR_GET_ID( resnum );
+  u8 msk = 1 &lt;&lt; ( id &amp; 0x07 );
+  int status = ( vtmr_int_flag[ id &gt;&gt; 3 ] &amp; msk ) != 0;
+
+  if( clear )
+    vtmr_int_flag[ id &gt;&gt; 3 ] &amp;= ( u8 )~msk;
+  return status;
+}
+
+static int vtmr_int_set_status( elua_int_resnum resnum, int status )
+{
+  unsigned id = VTMR_GET_ID( resnum );
+  u8 msk = 1 &lt;&lt; ( id &amp; 0x07 );
+  int prev = ( vtmr_int_enabled[ id &gt;&gt; 3 ] &amp; msk ) != 0;
+
+  if( status == PLATFORM_CPU_ENABLE )
+    vtmr_int_enabled[ id &gt;&gt; 3 ] |= msk;
+  else
+    vtmr_int_enabled[ id &gt;&gt; 3 ] &amp;= ( u8 )~msk;
+  return prev;
+}
+
+static int vtmr_int_get_status( elua_int_resnum resnum )
+{
+  unsigned id = VTMR_GET_ID( resnum );
+  u8 msk = 1 &lt;&lt; ( id &amp; 0x07 );
+  return ( vtmr_int_enabled[ id &gt;&gt; 3 ] &amp; msk ) != 0;
+}
+#endif // #ifdef CMN_TIMER_INT_SUPPORT 
+
+#else // #if VTMR_NUM_TIMERS &gt; 0
+
+void cmn_virtual_timer_cb()
+{
+}
+
+#endif // #if VTMR_NUM_TIMERS &gt; 0
+
+// ============================================================================
+// Actual timer functions
+
+int platform_timer_exists( unsigned id )
+{
+#if VTMR_NUM_TIMERS &gt; 0
+  if( id &gt;= VTMR_FIRST_ID )
+    return TIMER_IS_VIRTUAL( id );
+  else
+#endif
+    return id &lt; NUM_TIMER;
+}
+
+void platform_timer_delay( unsigned id, u32 delay_us )
+{
+#if VTMR_NUM_TIMERS &gt; 0
+  if( TIMER_IS_VIRTUAL( id ) )
+    vtmr_delay( id, delay_us );
+  else
+#endif
+    platform_s_timer_delay( id, delay_us );
+}
+      
+u32 platform_timer_op( unsigned id, int op, u32 data )
+{
+  u32 res = 0;
+
+  if( ( VTMR_NUM_TIMERS == 0 ) || ( !TIMER_IS_VIRTUAL( id ) ) )
+    return platform_s_timer_op( id, op, data );
+#if VTMR_NUM_TIMERS &gt; 0
+  switch( op )
+  {
+    case PLATFORM_TIMER_OP_START:
+      vtmr_reset_timer( id );
+      res = 0;
+      break;
+      
+    case PLATFORM_TIMER_OP_READ:
+      res = vtmr_counters[ VTMR_GET_ID( id ) ];
+      break;
+      
+    case PLATFORM_TIMER_OP_GET_MAX_DELAY:
+      res = platform_timer_get_diff_us( id, 0, 0xFFFFFFFF );
+      break;
+      
+    case PLATFORM_TIMER_OP_GET_MIN_DELAY:
+      res = platform_timer_get_diff_us( id, 0, 1 );
+      break;
+      
+    case PLATFORM_TIMER_OP_SET_CLOCK:
+    case PLATFORM_TIMER_OP_GET_CLOCK:
+      res = VTMR_FREQ_HZ;
+      break;      
+  }
+#endif
+  return res;
+}
+
+u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
+{
+  timer_data_type temp;
+  u32 freq;
+    
+  freq = platform_timer_op( id, PLATFORM_TIMER_OP_GET_CLOCK, 0 );
+  if( start &lt; end )
+  {
+    temp = end;
+    end = start;
+    start = temp;
+  }
+  return ( ( u64 )( start - end ) * 1000000 ) / freq;
+}
+
+#ifdef CMN_TIMER_INT_SUPPORT
+int platform_timer_set_match_int( unsigned id, u32 period_us, int type )
+{
+#if VTMR_NUM_TIMERS &gt; 0
+  if( TIMER_IS_VIRTUAL( id ) )
+    return vtmr_set_match_int( id, period_us, type );
+  else
+#endif
+    return platform_s_timer_set_match_int( id, period_us, type );
+}
+
+int cmn_tmr_int_set_status( elua_int_resnum resnum, int status )
+{
+#if VTMR_NUM_TIMERS &gt; 0
+  if( TIMER_IS_VIRTUAL( resnum ) )
+    return vtmr_int_set_status( resnum, status );
+#endif
+  elua_int_p_set_status ps;
+  if( ( ps = elua_int_table[ INT_TMR_MATCH - ELUA_INT_FIRST_ID ].int_set_status ) == NULL )
+    return PLATFORM_INT_NOT_HANDLED;
+  return ps( resnum, status );
+}
+
+int cmn_tmr_int_get_status( elua_int_resnum resnum )
+{
+#if VTMR_NUM_TIMERS &gt; 0
+  if( TIMER_IS_VIRTUAL( resnum ) )
+    return vtmr_int_get_status( resnum );
+#endif
+  elua_int_p_get_status pg;
+  if( ( pg = elua_int_table[ INT_TMR_MATCH - ELUA_INT_FIRST_ID ].int_get_status ) == NULL )
+    return PLATFORM_INT_NOT_HANDLED;
+  return pg( resnum );
+}
+
+int cmn_tmr_int_get_flag( elua_int_resnum resnum, int clear )
+{
+  if( resnum == ELUA_INT_RESNUM_ANY )
+    return PLATFORM_INT_NOT_ANY;
+#if VTMR_NUM_TIMERS &gt; 0
+  if( TIMER_IS_VIRTUAL( resnum ) )
+    return vtmr_int_get_flag( resnum, clear );
+#endif
+  elua_int_p_get_flag pf;
+  if( ( pf = elua_int_table[ INT_TMR_MATCH - ELUA_INT_FIRST_ID ].int_get_flag ) == NULL )
+    return PLATFORM_INT_NOT_HANDLED;
+  return pf( resnum, clear );
+}
+
+#else // #ifdef CMN_TIMER_INT_SUPPORT
+int platform_timer_set_match_int( unsigned id, u32 period_us, int type )
+{
+  fprintf( stderr, &quot;Timer match interrupt not available when eLua interrupt support is not enabled.\n&quot; );
+  return 0;
+}
+#endif // #ifdef CMN_TIMER_INT_SUPPORT
+

Modified: trunk/src/elua_int.c
===================================================================
--- trunk/src/elua_int.c	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/elua_int.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -9,6 +9,9 @@
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 
+// ****************************************************************************
+// Lua handlers
+
 #ifdef BUILD_LUA_INT_HANDLERS
 
 // Interrupt queue read and write indexes
@@ -64,6 +67,9 @@
 // Returns PLATFORM_OK or PLATFORM_ERR
 int elua_int_add( elua_int_id inttype, elua_int_resnum resnum )
 {
+  if( inttype &lt; ELUA_INT_FIRST_ID || inttype &gt; INT_ELUA_LAST )
+    return PLATFORM_ERR;
+
   // If Lua is not running (no Lua state), or no Lua interrupt handler is set, 
   // or the interrupt is not enabled, don't do anything
   if( lua_getstate() == NULL || !cpu_is_int_handler_active() || !elua_int_is_enabled( inttype ) )
@@ -82,7 +88,6 @@
   elua_int_write_idx = ( elua_int_write_idx + 1 ) &amp; INT_IDX_MASK;
 
   // Set the Lua hook (it's OK to set it even if it's already set)
-  // [TODO] is it safe to call lua_sethook here ? If not, set a &quot;trap&quot; in lvm.c
   lua_sethook( lua_getstate(), elua_int_hook, LUA_MASKCOUNT, 2 ); 
 
   // All OK
@@ -120,6 +125,14 @@
     elua_int_flags[ i ] = 0;    
 }
 
+// Called from lstate.c/lua_close
+void elua_int_cleanup()
+{
+  elua_int_disable_all();
+  elua_int_read_idx = elua_int_write_idx = 0;
+  memset( elua_int_queue, ELUA_INT_EMPTY_SLOT, sizeof( elua_int_queue ) );
+}
+
 #else // #ifdef BUILD_LUA_INT_HANDLERS
 
 // This is needed by lua_close (lstate.c)
@@ -127,6 +140,11 @@
 {
 }
 
+// This too
+void elua_int_cleanup()
+{
+}
+
 void elua_int_enable( elua_int_id inttype )
 {
 }
@@ -135,5 +153,50 @@
 {
 }
 
+int elua_int_add( elua_int_id inttype, elua_int_resnum resnum )
+{
+  return PLATFORM_ERR;
+}
+
 #endif // #ifdef BUILD_LUA_INT_HANDLERS
 
+// ****************************************************************************
+// C handlers
+
+#ifdef BUILD_C_INT_HANDLERS
+
+static elua_int_c_handler elua_int_c_handler_list[ INT_ELUA_LAST ];
+
+elua_int_c_handler elua_int_set_c_handler( elua_int_id inttype, elua_int_c_handler phandler )
+{
+  elua_int_c_handler crthandler;
+
+  if( inttype &lt; ELUA_INT_FIRST_ID || inttype &gt; INT_ELUA_LAST )
+    return NULL;
+  inttype -= ELUA_INT_FIRST_ID;
+  crthandler = elua_int_c_handler_list[ inttype ];
+  elua_int_c_handler_list[ inttype ] = phandler;
+  return crthandler;
+}
+
+elua_int_c_handler elua_int_get_c_handler( elua_int_id inttype )
+{
+  if( inttype &lt; ELUA_INT_FIRST_ID || inttype &gt; INT_ELUA_LAST )
+    return NULL;
+  return elua_int_c_handler_list[ inttype - ELUA_INT_FIRST_ID ];
+}
+
+#else // #ifdef BUILD_C_INT_HANDLERS
+
+elua_int_c_handler elua_int_set_c_handler( elua_int_id inttype, elua_int_c_handler phandler )
+{
+  return NULL;
+}
+
+elua_int_c_handler elua_int_get_c_handler( elua_int_id inttype )
+{
+  return NULL;
+}
+
+#endif // #ifdef BUILD_C_INT_HANDLERS
+

Modified: trunk/src/lua/lrodefs.h
===================================================================
--- trunk/src/lua/lrodefs.h	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/lua/lrodefs.h	2010-11-03 23:57:27 UTC (rev 808)
@@ -17,6 +17,7 @@
 #define LNILKEY                     LRO_NILKEY
 #define LFUNCVAL                    LRO_FUNCVAL
 #define LNUMVAL                     LRO_NUMVAL
+#define LBOOLVAL                    LRO_BOOLVAL
 #define LROVAL                      LRO_ROVAL
 #define LNILVAL                     LRO_NILVAL
 #define LREGISTER(L, name, table)\

Modified: trunk/src/lua/lrotable.h
===================================================================
--- trunk/src/lua/lrotable.h	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/lua/lrotable.h	2010-11-03 23:57:27 UTC (rev 808)
@@ -11,6 +11,7 @@
 /* Macros one can use to define rotable entries */
 #define LRO_FUNCVAL(v)  {{.p = v}, LUA_TLIGHTFUNCTION}
 #define LRO_NUMVAL(v)   {{.n = v}, LUA_TNUMBER}
+#define LRO_BOOLVAL(v)  {{.n = v}, LUA_TBOOLEAN}
 #define LRO_ROVAL(v)    {{.p = ( void* )v}, LUA_TROTABLE}
 #define LRO_NILVAL      {{.p = NULL}, LUA_TNIL}
 

Modified: trunk/src/lua/lstate.c
===================================================================
--- trunk/src/lua/lstate.c	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/lua/lstate.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -25,6 +25,7 @@
 #include &quot;platform_conf.h&quot;
 // BogdanM: modified for Lua interrupt support
 #include &quot;elua_int.h&quot;
+#include &quot;platform.h&quot;
 
 #define state_size(x)	(sizeof(x) + LUAI_EXTRASPACE)
 #define fromstate(l)	(cast(lu_byte *, (l)) - LUAI_EXTRASPACE)
@@ -226,6 +227,13 @@
   return lua_crtstate;
 }
 LUA_API void lua_close (lua_State *L) {
+#ifndef LUA_CROSS_COMPILER  
+  int oldstate = platform_cpu_set_global_interrupts( PLATFORM_CPU_DISABLE );
+  lua_sethook( L, NULL, 0, 0 );
+  lua_crtstate = NULL;
+  elua_int_cleanup();
+  platform_cpu_set_global_interrupts( oldstate );
+#endif  
   L = G(L)-&gt;mainthread;  /* only the main thread can be closed */
   lua_lock(L);
   luaF_close(L, L-&gt;stack);  /* close all upvalues for this thread */
@@ -240,9 +248,5 @@
   luai_userstateclose(L);
   close_state(L);
   // BogdanM: modified for eLua interrupt support
-#ifndef LUA_CROSS_COMPILER  
-  lua_crtstate = NULL;
-  elua_int_disable_all();
-#endif  
 }
 

Modified: trunk/src/modules/cpu.c
===================================================================
--- trunk/src/modules/cpu.c	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/modules/cpu.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -90,6 +90,7 @@
   unsigned i;
   elua_int_id id;
   elua_int_resnum resnum;
+  int res;
 
   if( lua_gettop( L ) &gt; 0 )
   {
@@ -97,7 +98,11 @@
     for( i = 2; i &lt;= lua_gettop( L ); i ++ )
     {
       resnum = ( elua_int_resnum )luaL_checkinteger( L, i );
-      platform_cpu_set_interrupt( id, resnum, PLATFORM_CPU_DISABLE );
+      res = platform_cpu_set_interrupt( id, resnum, PLATFORM_CPU_DISABLE );
+      if( res == PLATFORM_INT_INVALID )
+        return luaL_error( L, &quot;%d is not a valid interrupt ID&quot;, ( int )id );
+      else if( res == PLATFORM_INT_NOT_HANDLED )
+        return luaL_error( L, &quot;cli operation not implemented for interrupt %d with resnum %d&quot;, ( int )id, ( int )resnum );
     }
     elua_int_disable( id );
   }
@@ -119,6 +124,7 @@
   unsigned i;
   elua_int_id id;
   elua_int_resnum resnum;  
+  int res;
 
   if( lua_gettop( L ) &gt; 0 )
   {
@@ -126,7 +132,11 @@
     for( i = 2; i &lt;= lua_gettop( L ); i ++ )
     {
       resnum = ( elua_int_resnum )luaL_checkinteger( L, i );
-      platform_cpu_set_interrupt( id, resnum, PLATFORM_CPU_ENABLE );
+      res = platform_cpu_set_interrupt( id, resnum, PLATFORM_CPU_ENABLE );
+      if( res == PLATFORM_INT_INVALID )
+        return luaL_error( L, &quot;%d is not a valid interrupt ID&quot;, ( int )id );
+      else if( res == PLATFORM_INT_NOT_HANDLED )
+        return luaL_error( L, &quot;sei operation not implemented for interrupt %d with resnum %d&quot;, ( int )id, ( int )resnum );
     }
     elua_int_enable( id );
   }
@@ -201,8 +211,35 @@
     return luaL_error( L, &quot;invalid argument (must be a function or nil)&quot; );
   return 0;
 }
-#endif
 
+// Lua: flag = get_int_flag( id, resnum, [clear] )
+// 'clear' default to true if not specified
+static int cpu_get_int_flag( lua_State *L )
+{
+  elua_int_id id;
+  elua_int_resnum resnum;  
+  int clear = 1;
+  int res;
+
+  id = ( elua_int_id )luaL_checkinteger( L, 1 );
+  resnum = ( elua_int_resnum )luaL_checkinteger( L, 2 );
+  if( lua_gettop( L ) &gt;= 3 )
+  {
+    if( lua_isboolean( L, 3 ) )
+      clear = lua_toboolean( L, 3 );
+    else
+      return luaL_error( L, &quot;expected a bool as the 3rd argument of this function&quot; );
+  }
+  res = platform_cpu_get_interrupt_flag( id, resnum, clear );
+  if( res == PLATFORM_INT_INVALID )
+    return luaL_error( L, &quot;%d is not a valid interrupt ID&quot;, ( int )id );
+  else if( res == PLATFORM_INT_NOT_HANDLED )
+    return luaL_error( L, &quot;get flag operation not implemented for interrupt %d with resnum %d&quot;, ( int )id, ( int )resnum );
+  lua_pushinteger( L, res );
+  return 1;
+}
+#endif // #ifdef BUILD_LUA_INT_HANDLERS
+
 // Module function map
 #define MIN_OPT_LEVEL 2
 #include &quot;lrodefs.h&quot;
@@ -219,6 +256,10 @@
   { LSTRKEY( &quot;clock&quot; ), LFUNCVAL( cpu_clock ) },
 #ifdef BUILD_LUA_INT_HANDLERS
   { LSTRKEY( &quot;set_int_handler&quot; ), LFUNCVAL( cpu_set_int_handler ) },
+  { LSTRKEY( &quot;get_int_flag&quot; ), LFUNCVAL( cpu_get_int_flag) },
+  { LSTRKEY( &quot;ANY_RES&quot; ), LNUMVAL( ELUA_INT_RESNUM_ANY ) },
+  { LSTRKEY( &quot;INT_FLAG_CLEAR&quot; ), LBOOLVAL( 1 ) },
+  { LSTRKEY( &quot;INT_FLAG_KEEP&quot; ), LBOOLVAL( 0 ) },
 #endif
 #if defined( PLATFORM_CPU_CONSTANTS ) &amp;&amp; LUA_OPTIMIZE_MEMORY &gt; 0
   { LSTRKEY( &quot;__metatable&quot; ), LROVAL( cpu_map ) },

Modified: trunk/src/modules/tmr.c
===================================================================
--- trunk/src/modules/tmr.c	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/modules/tmr.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -120,22 +120,23 @@
   return 1;
 }
 
-// Lua: setinttimeout( id, timeout )
-static int tmr_setinttimeout( lua_State *L )
+#ifdef BUILD_LUA_INT_HANDLERS
+// Lua: set_match_int( id, timeout, type )
+static int tmr_set_match_int( lua_State *L )
 {
-#ifdef BUILD_LUA_INT_HANDLERS
   unsigned id;
   u32 res;
   
   id = luaL_checkinteger( L, 1 );
   MOD_CHECK_ID( timer, id );
-  res = platform_timer_op( id, PLATFORM_TIMER_OP_SET_INT_TIMEOUT, ( u32 )luaL_checknumber( L, 2 ) );
-  lua_pushinteger( L, res );
-  return 1;
-#else
-  return luaL_error( L, &quot;setinttimeout not supported when Lua interrupt support is not compiled&quot; );
-#endif
+  res = platform_timer_set_match_int( id, ( u32 )luaL_checknumber( L, 2 ), ( int )luaL_checkinteger( L, 3 ) );
+  if( res == PLATFORM_TIMER_INT_TOO_SHORT )
+    return luaL_error( L, &quot;timer interval too small&quot; );
+  else if( res == PLATFORM_TIMER_INT_INVALID_ID )
+    return luaL_error( L, &quot;mach interrupt cannot be set on this timer&quot; );
+  return 0;
 }
+#endif // #ifdef BUILD_LUA_INT_HANDLERS
 
 #if VTMR_NUM_TIMERS &gt; 0
 // __index metafunction for TMR
@@ -173,13 +174,19 @@
   { LSTRKEY( &quot;getmaxdelay&quot; ), LFUNCVAL( tmr_getmaxdelay ) },
   { LSTRKEY( &quot;setclock&quot; ), LFUNCVAL( tmr_setclock ) },
   { LSTRKEY( &quot;getclock&quot; ), LFUNCVAL( tmr_getclock ) },
-  { LSTRKEY( &quot;setinttimeout&quot; ), LFUNCVAL( tmr_setinttimeout ) },
+#ifdef BUILD_LUA_INT_HANDLERS
+  { LSTRKEY( &quot;set_match_int&quot; ), LFUNCVAL( tmr_set_match_int ) },
+#endif  
 #if LUA_OPTIMIZE_MEMORY &gt; 0 &amp;&amp; VTMR_NUM_TIMERS &gt; 0
   { LSTRKEY( &quot;__metatable&quot; ), LROVAL( tmr_map ) },
 #endif
 #if VTMR_NUM_TIMERS &gt; 0  
   { LSTRKEY( &quot;__index&quot; ), LFUNCVAL( tmr_mt_index ) },
 #endif  
+#if LUA_OPTIMIZE_MEMORY &gt; 0 &amp;&amp; defined( BUILD_LUA_INT_HANDLERS )
+  { LSTRKEY( &quot;INT_ONESHOT&quot; ), LNUMVAL( PLATFORM_TIMER_INT_ONESHOT ) },
+  { LSTRKEY( &quot;INT_CYCLIC&quot; ), LNUMVAL( PLATFORM_TIMER_INT_CYCLIC ) },
+#endif
   { LNILKEY, LNILVAL }
 };
 

Modified: trunk/src/platform/lpc24xx/conf.py
===================================================================
--- trunk/src/platform/lpc24xx/conf.py	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/platform/lpc24xx/conf.py	2010-11-03 23:57:27 UTC (rev 808)
@@ -2,7 +2,7 @@
 
 cpumode = ARGUMENTS.get( 'cpumode', 'arm' ).lower()
 
-specific_files = &quot;startup.s irq.c target.c platform.c&quot;
+specific_files = &quot;startup.s irq.c target.c platform.c platform_int.c&quot;
 if comp[ 'cpu' ] == 'LPC2468':
   ldscript = &quot;lpc2468.lds&quot;
 else:

Modified: trunk/src/platform/lpc24xx/platform.c
===================================================================
--- trunk/src/platform/lpc24xx/platform.c	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/platform/lpc24xx/platform.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -27,40 +27,6 @@
 extern void enable_ints();
 extern void disable_ints();
 
-// *****************************************************************************
-// These interrupt handlers are the link to elua_int.c
-
-static PREG const posedge_status[] = { ( PREG )&amp;IO0_INT_STAT_R, ( PREG )&amp;IO2_INT_STAT_R };
-static PREG const negedge_status[] = { ( PREG )&amp;IO0_INT_STAT_F, ( PREG )&amp;IO2_INT_STAT_F };
-static PREG const intclr_regs[] = { ( PREG )&amp;IO0_INT_CLR, ( PREG )&amp;IO2_INT_CLR };
-
-static void int_handler_eint3()
-{
-  elua_int_id id = ELUA_INT_INVALID_INTERRUPT;
-  pio_code resnum = 0;
-  int pidx, pin;
-  
-  EXTINT |= 1 &lt;&lt; 3; // clear interrupt
-  // Look for interrupt source
-  // In can only be GPIO0/GPIO2, as the EXT interrupts are not (yet) used
-  pidx = ( IO_INT_STAT &amp; 1 ) ? 0 : 1;
-  if( *posedge_status[ pidx ] )
-  {
-    id = INT_GPIO_POSEDGE;
-    pin = intlog2( *posedge_status[ pidx ] );
-  }
-  else
-  {
-    id = INT_GPIO_NEGEDGE;
-    pin = intlog2( *negedge_status[ pidx ] );
-  }
-  resnum = PLATFORM_IO_ENCODE( pidx * 2, pin, PLATFORM_IO_ENC_PIN );   
-  *intclr_regs[ pidx ] = 1 &lt;&lt; pin;
-  
-  // Queue interrupt
-  elua_int_add( id, resnum );
-  VICVectAddr = 0; // ACK interrupt    
-}
 // ****************************************************************************
 // Platform initialization
 
@@ -96,12 +62,6 @@
   SCS |= 1;
 }
 
-// Setup all required interrupt handlers
-static void platform_setup_interrupts()
-{
-  install_irq( EINT3_INT, int_handler_eint3, HIGHEST_PRIORITY - 1 );   
-}
-
 #define P2C(Period)     (((Period&lt;EMC_PERIOD)?0:(unsigned int)((float)Period/EMC_PERIOD)))
 #define SDRAM_BASE_ADDR *(volatile unsigned int*)0xA0000000 //DYCS0
 #define SDRAM_CS0_BASE (0xA0000000)
@@ -179,9 +139,6 @@
   platform_setup_timers();
   platform_setup_pwm();
   
-  // Setup interrupt handlers
-  platform_setup_interrupts();
-
   // Initialize console UART
   platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
   
@@ -578,61 +535,11 @@
   return res;
 }
 
-// ****************************************************************************
-// CPU functions
-
-static PREG const posedge_regs[] = { ( PREG )&amp;IO0_INT_EN_R, NULL, ( PREG )&amp;IO2_INT_EN_R };
-static PREG const negedge_regs[] = { ( PREG )&amp;IO0_INT_EN_F, NULL, ( PREG )&amp;IO0_INT_EN_F };
-
-// Helper: return the status of a specific interrupt (enabled/disabled)
-static int platform_cpuh_get_int_status( elua_int_id id, elua_int_resnum resnum )
+int platform_s_timer_set_match_int( unsigned id, u32 period_us, int type )
 {
-  int port, pin;
-  
-  if( id == INT_GPIO_POSEDGE || id == INT_GPIO_NEGEDGE )
-  {
-    port = PLATFORM_IO_GET_PORT( resnum ); 
-    pin = PLATFORM_IO_GET_PIN( resnum ); 
-    if( id == INT_GPIO_POSEDGE )
-      return *posedge_regs[ port ] &amp; ( 1 &lt;&lt; pin );
-    else
-      return *negedge_regs[ port ] &amp; ( 1 &lt;&lt; pin );        
-  } 
-  return 0;
+  return PLATFORM_TIMER_INT_INVALID_ID;
 }
 
-int platform_cpu_set_interrupt( elua_int_id id, elua_int_resnum resnum, int status )
-{
-  int crt_status = platform_cpuh_get_int_status( id, resnum );
-  int port, pin;
-  
-  if( id == INT_GPIO_POSEDGE || id == INT_GPIO_NEGEDGE )
-  {
-    port = PLATFORM_IO_GET_PORT( resnum ); 
-    pin = PLATFORM_IO_GET_PIN( resnum ); 
-    if( id == INT_GPIO_POSEDGE )
-    {
-      if( status == PLATFORM_CPU_ENABLE )
-        *posedge_regs[ port ] |= 1 &lt;&lt; pin;
-      else
-        *posedge_regs[ port ] &amp;= ~( 1 &lt;&lt; pin );       
-    }
-    else
-    {
-      if( status == PLATFORM_CPU_ENABLE )
-        *negedge_regs[ port ] |= 1 &lt;&lt; pin;
-      else
-        *negedge_regs[ port ] &amp;= ~( 1 &lt;&lt; pin );         
-    }    
-  }
-  return crt_status;
-}
-
-int platform_cpu_get_interrupt( elua_int_id id, elua_int_resnum resnum )
-{
-  return platform_cpuh_get_int_status( id, resnum );
-}
-
 // *****************************************************************************
 // ADC specific functions and variables
 

Modified: trunk/src/platform/lpc24xx/platform_conf.h
===================================================================
--- trunk/src/platform/lpc24xx/platform_conf.h	2010-10-18 16:40:25 UTC (rev 807)
+++ trunk/src/platform/lpc24xx/platform_conf.h	2010-11-03 23:57:27 UTC (rev 808)
@@ -20,6 +20,7 @@
 #define BUILD_ADC
 #define BUILD_RPC
 #define BUILD_LUA_INT_HANDLERS
+#define BUILD_C_INT_HANDLERS
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
@@ -137,27 +138,24 @@
 // *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module
 
-#define PINSEL_BASE_ADDR	0xE002C000
-#define IO_PINSEL0           ( PINSEL_BASE_ADDR + 0x00 )
-#define IO_PINSEL1           ( PINSEL_BASE_ADDR + 0x04 )
-#define IO_PINSEL2           ( PINSEL_BASE_ADDR + 0x08 )
-#define IO_PINSEL3           ( PINSEL_BASE_ADDR + 0x0C )
-#define IO_PINSEL4           ( PINSEL_BASE_ADDR + 0x10 )
-#define IO_PINSEL5           ( PINSEL_BASE_ADDR + 0x14 )
-#define IO_PINSEL6           ( PINSEL_BASE_ADDR + 0x18 )
-#define IO_PINSEL7           ( PINSEL_BASE_ADDR + 0x1C )
-#define IO_PINSEL8           ( PINSEL_BASE_ADDR + 0x20 )
-#define IO_PINSEL9           ( PINSEL_BASE_ADDR + 0x24 )
-#define IO_PINSEL10          ( PINSEL_BASE_ADDR + 0x28 )
+#define PINSEL_BASE_ADDR	      0xE002C000
+#define IO_PINSEL0            ( PINSEL_BASE_ADDR + 0x00 )
+#define IO_PINSEL1            ( PINSEL_BASE_ADDR + 0x04 )
+#define IO_PINSEL2            ( PINSEL_BASE_ADDR + 0x08 )
+#define IO_PINSEL3            ( PINSEL_BASE_ADDR + 0x0C )
+#define IO_PINSEL4            ( PINSEL_BASE_ADDR + 0x10 )
+#define IO_PINSEL5            ( PINSEL_BASE_ADDR + 0x14 )
+#define IO_PINSEL6            ( PINSEL_BASE_ADDR + 0x18 )
+#define IO_PINSEL7            ( PINSEL_BASE_ADDR + 0x1C )
+#define IO_PINSEL8            ( PINSEL_BASE_ADDR + 0x20 )
+#define IO_PINSEL9            ( PINSEL_BASE_ADDR + 0x24 )
+#define IO_PINSEL10           ( PINSEL_BASE_ADDR + 0x28 )
 
 // Interrupt list
-enum
-{
-  // Platform interrupts
-  INT_GPIO_POSEDGE = ELUA_INT_FIRST_ID,
-  INT_GPIO_NEGEDGE,
-  INT_TMR_MATCH
-};
+#define INT_GPIO_POSEDGE      ELUA_INT_FIRST_ID
+#define INT_GPIO_NEGEDGE      ( ELUA_INT_FIRST_ID + 1 )
+#define INT_TMR_MATCH         ( ELUA_INT_FIRST_ID + 2 )
+#define INT_ELUA_LAST         INT_TMR_MATCH
 
 #define PLATFORM_CPU_CONSTANTS\
  _C( IO_PINSEL0 ),\

Added: trunk/src/platform/lpc24xx/platform_int.c
===================================================================
--- trunk/src/platform/lpc24xx/platform_int.c	                        (rev 0)
+++ trunk/src/platform/lpc24xx/platform_int.c	2010-11-03 23:57:27 UTC (rev 808)
@@ -0,0 +1,194 @@
+// LPC24xx interrupt support
+
+// Generic headers
+#include &quot;platform.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;elua_int.h&quot;
+#include &quot;common.h&quot;
+
+// Platform-specific headers
+#include &quot;irq.h&quot;
+#include &quot;LPC23xx.h&quot;
+#include &quot;target.h&quot;
+
+// ****************************************************************************
+// Interrupt handlers
+
+static PREG const posedge_status[] = { ( PREG )&amp;IO0_INT_STAT_R, ( PREG )&amp;IO2_INT_STAT_R };
+static PREG const negedge_status[] = { ( PREG )&amp;IO0_INT_STAT_F, ( PREG )&amp;IO2_INT_STAT_F };
+static PREG const intclr_regs[] = { ( PREG )&amp;IO0_INT_CLR, ( PREG )&amp;IO2_INT_CLR };
+
+#define EINT3_BIT             3
+
+// EINT3 (INT_GPIO) interrupt handler
+static void int_handler_eint3()
+{
+  elua_int_id id = ELUA_INT_INVALID_INTERRUPT;
+  pio_code resnum = 0;
+  int pidx, pin;
+  
+  EXTINT |= 1 &lt;&lt; EINT3_BIT; // clear interrupt
+  // Look for interrupt source
+  // In can only be GPIO0/GPIO2, as the EXT interrupts are not (yet) used
+  pidx = ( IO_INT_STAT &amp; 1 ) ? 0 : 1;
+  if( *posedge_status[ pidx ] )
+  {
+    id = INT_GPIO_POSEDGE;
+    pin = intlog2( *posedge_status[ pidx ] );
+  }
+  else
+  {
+    id = INT_GPIO_NEGEDGE;
+    pin = intlog2( *negedge_status[ pidx ] );
+  }
+  resnum = PLATFORM_IO_ENCODE( pidx * 2, pin, PLATFORM_IO_ENC_PIN );   
+  *intclr_regs[ pidx ] = 1 &lt;&lt; pin;
+  
+  // Run the interrupt through eLua
+  cmn_int_handler( id, resnum );
+  VICVectAddr = 0; // ACK interrupt    
+}
+
+// ****************************************************************************
+// GPIO helper functions
+
+static PREG const posedge_regs[] = { ( PREG )&amp;IO0_INT_EN_R, NULL, ( PREG )&amp;IO2_INT_EN_R };
+static PREG const negedge_regs[] = { ( PREG )&amp;IO0_INT_EN_F, NULL, ( PREG )&amp;IO0_INT_EN_F };
+
+static int gpioh_get_int_status( elua_int_id id, elua_int_resnum resnum )
+{
+  int port, pin;
+  
+  port = PLATFORM_IO_GET_PORT( resnum ); 
+  pin = PLATFORM_IO_GET_PIN( resnum ); 
+  if( id == INT_GPIO_POSEDGE )
+    return *posedge_regs[ port ] &amp; ( 1 &lt;&lt; pin );
+  else
+    return *negedge_regs[ port ] &amp; ( 1 &lt;&lt; pin );        
+  return 0;
+}
+
+static int gpioh_set_int_status( elua_int_id id, elua_int_resnum resnum, int status )
+{
+  int crt_status = gpioh_get_int_status( id, resnum );
+  int port, pin;
+  
+  port = PLATFORM_IO_GET_PORT( resnum ); 
+  pin = PLATFORM_IO_GET_PIN( resnum ); 
+  if( id == INT_GPIO_POSEDGE )
+  {
+    if( status == PLATFORM_CPU_ENABLE )
+      *posedge_regs[ port ] |= 1 &lt;&lt; pin;
+    else
+      *posedge_regs[ port ] &amp;= ~( 1 &lt;&lt; pin );       
+  }
+  else
+  {
+    if( status == PLATFORM_CPU_ENABLE )
+      *negedge_regs[ port ] |= 1 &lt;&lt; pin;
+    else
+      *negedge_regs[ port ] &amp;= ~( 1 &lt;&lt; pin );         
+  }    
+  EXTINT |= 1 &lt;&lt; EINT3_BIT;
+  return crt_status;
+}
+
+static int gpioh_get_flag( elua_int_id id, elua_int_resnum resnum, int clear )
+{
+  int pidx;
+  int flag = 0;
+  
+  // Look for interrupt source
+  // In can only be GPIO0/GPIO2, as the EXT interrupts are not (yet) used
+  pidx = ( IO_INT_STAT &amp; 1 ) ? 0 : 1;
+  if( resnum == ELUA_INT_RESNUM_ANY )
+  {
+    if( id == INT_GPIO_POSEDGE &amp;&amp; *posedge_status[ pidx ] )
+      resnum = intlog2( *posedge_status[ pidx ] );
+    else if( id == INT_GPIO_NEGEDGE &amp;&amp; *negedge_status[ pidx ] )
+      resnum = intlog2( *negedge_status[ pidx ] );
+    else
+      return 0;
+  }
+  if( id == INT_GPIO_POSEDGE &amp;&amp; ( *posedge_status[ pidx ] &amp;&amp; ( 1 &lt;&lt; resnum ) ) )
+    flag = 1;
+  else if( id == INT_GPIO_NEGEDGE &amp;&amp; ( *negedge_status[ pidx ] &amp;&amp; ( 1 &lt;&lt; resnum ) ) )
+    flag = 1;
+  if( flag &amp;&amp; clear )
+    *intclr_regs[ pidx ] = 1 &lt;&lt; resnum;  
+  return flag;
+}
+
+// ****************************************************************************
+// Interrupt: INT_GPIO_POSEDGE
+
+static int int_gpio_posedge_set_status( elua_int_resnum resnum, int status )
+{
+  return gpioh_set_int_status( INT_GPIO_POSEDGE, resnum, status );
+}
+
+static int int_gpio_posedge_get_status( elua_int_resnum resnum )
+{
+  return gpioh_get_int_status( INT_GPIO_POSEDGE, resnum );
+}
+
+static int int_gpio_posedge_get_flag( elua_int_resnum resnum, int clear )
+{
+  return gpioh_get_flag( INT_GPIO_POSEDGE, resnum, clear );
+}
+
+// ****************************************************************************
+// Interrupt: INT_GPIO_NEGEDGE
+
+static int int_gpio_negedge_set_status( elua_int_resnum resnum, int status )
+{
+  return gpioh_set_int_status( INT_GPIO_NEGEDGE, resnum, status );
+}
+
+static int int_gpio_negedge_get_status( elua_int_resnum resnum )
+{
+  return gpioh_get_int_status( INT_GPIO_NEGEDGE, resnum );
+}
+
+static int int_gpio_negedge_get_flag( elua_int_resnum resnum, int clear )
+{
+  return gpioh_get_flag( INT_GPIO_NEGEDGE, resnum, clear );
+}
+
+// ****************************************************************************
+// Interrupt: INT_TMR_MATCH
+
+static int int_tmr_match_set_status( elua_int_resnum resnum, int status )
+{
+  return PLATFORM_INT_NOT_HANDLED;
+}
+
+static int int_tmr_match_get_status( elua_int_resnum resnum )
+{
+  return PLATFORM_INT_NOT_HANDLED;
+}
+
+static int int_tmr_match_get_flag( elua_int_resnum resnum, int clear )
+{
+  return PLATFORM_INT_NOT_HANDLED;
+}
+
+// ****************************************************************************
+// Interrupt initialization
+
+void platform_int_init()
+{
+  install_irq( EINT3_INT, int_handler_eint3, HIGHEST_PRIORITY - 1 );   
+}
+
+// ****************************************************************************
+// Interrupt table
+// Must have a 1-to-1 correspondence with the interrupt enum in platform_conf.h!
+
+elua_int_descriptor elua_int_table[ INT_ELUA_LAST ] = 
+{
+  { int_gpio_posedge_set_status, int_gpio_posedge_get_status, int_gpio_posedge_get_flag },
+  { int_gpio_negedge_set_status, int_gpio_negedge_get_status, int_gpio_negedge_get_flag },
+  { int_tmr_match_set_status, int_tmr_match_get_status, int_tmr_match_get_flag }
+};
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000762.html">[Elua-svn] r809 - in trunk: inc src src/modules	src/platform/lpc24xx src/platform/str9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#761">[ date ]</a>
              <a href="thread.html#761">[ thread ]</a>
              <a href="subject.html#761">[ subject ]</a>
              <a href="author.html#761">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
