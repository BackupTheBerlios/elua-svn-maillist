<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r426 - in tags/pre0.6/doc: . pt
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r426%20-%20in%20tags/pre0.6/doc%3A%20.%20pt&In-Reply-To=%3C200909110529.n8B5T7Wg013359%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000381.html">
   <LINK REL="Next"  HREF="000383.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r426 - in tags/pre0.6/doc: . pt</H1>
    <B>dadosutter at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r426%20-%20in%20tags/pre0.6/doc%3A%20.%20pt&In-Reply-To=%3C200909110529.n8B5T7Wg013359%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r426 - in tags/pre0.6/doc: . pt">dadosutter at mail.berlios.de
       </A><BR>
    <I>Fri Sep 11 07:29:07 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000381.html">[Elua-svn] r425 - tags/pre0.6/doc
</A></li>
        <LI>Next message: <A HREF="000383.html">[Elua-svn] r427 - in tags/pre0.6/doc: . en pt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#382">[ date ]</a>
              <a href="thread.html#382">[ thread ]</a>
              <a href="subject.html#382">[ subject ]</a>
              <a href="author.html#382">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dadosutter
Date: 2009-09-11 07:28:49 +0200 (Fri, 11 Sep 2009)
New Revision: 426

Added:
   tags/pre0.6/doc/pt/arch.html
   tags/pre0.6/doc/pt/arch_coding.html
   tags/pre0.6/doc/pt/arch_con_term.html
   tags/pre0.6/doc/pt/arch_ltr.html
   tags/pre0.6/doc/pt/arch_newport.html
   tags/pre0.6/doc/pt/arch_overview.html
   tags/pre0.6/doc/pt/arch_platform.html
   tags/pre0.6/doc/pt/arch_romfs.html
   tags/pre0.6/doc/pt/arch_tcpip.html
   tags/pre0.6/doc/pt/doc.html
   tags/pre0.6/doc/pt/forum.html
   tags/pre0.6/doc/pt/installing.html
   tags/pre0.6/doc/pt/installing_at91sam7x.html
   tags/pre0.6/doc/pt/installing_avr32.html
   tags/pre0.6/doc/pt/installing_i386.html
   tags/pre0.6/doc/pt/installing_lm3s.html
   tags/pre0.6/doc/pt/installing_lpc2888.html
   tags/pre0.6/doc/pt/installing_stm32.html
   tags/pre0.6/doc/pt/installing_str7.html
   tags/pre0.6/doc/pt/installing_str9.html
   tags/pre0.6/doc/pt/refman_gen.html
   tags/pre0.6/doc/pt/toolchains.html
Modified:
   tags/pre0.6/doc/docdata.lua
Log:
Main Menu now supports Portuguese too
23 more translated (to Portuguese) pages added
Some revisions &amp; corrections on pt content



Modified: tags/pre0.6/doc/docdata.lua
===================================================================
--- tags/pre0.6/doc/docdata.lua	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/docdata.lua	2009-09-11 05:28:49 UTC (rev 426)
@@ -24,46 +24,46 @@
 local menu =
 {
   -- &quot;eLua project&quot; (menu separator)
-  { &quot;eLua project&quot; },
+  { { &quot;eLua project&quot;, &quot;Projeto eLua&quot; } },
 
   -- &quot;Overview&quot;
-  { &quot;Overview&quot;, &quot;overview.html&quot;, 
+  { { &quot;Overview&quot;, &quot;Apresenta&#231;&#227;o&quot; }, &quot;overview.html&quot;, 
     {
-      { &quot;About&quot;, &quot;overview.html#whatis&quot; },
-      { &quot;Features&quot;, &quot;overview.html#features&quot; },
-      { &quot;Audience&quot;, &quot;overview.html#audience&quot; },
-      { &quot;Authors&quot;, &quot;overview.html#authors&quot; },
-      { &quot;Contacts&quot;, &quot;overview.html#contacts&quot; },
-      { &quot;License&quot;, &quot;overview.html#license&quot; }
+      { { &quot;About&quot;, &quot;eLua&quot; }, &quot;overview.html#whatis&quot; },
+      { { &quot;Features&quot;, &quot;Caracter&#237;sticas&quot; }, &quot;overview.html#features&quot; },
+      { { &quot;Audience&quot;, &quot;P&#250;blico Alvo&quot; }, &quot;overview.html#audience&quot; },
+      { { &quot;Authors&quot;, &quot;Autores&quot; }, &quot;overview.html#authors&quot; },
+      { { &quot;Contacts&quot;,&quot;Contatos&quot; }, &quot;overview.html#contacts&quot; },
+      { { &quot;License&quot;, &quot;Licen&#231;a&quot; },&quot;overview.html#license&quot; }
     }
   },
 
   -- &quot;Community&quot;
-  { &quot;Community&quot;, &quot;comunity.html&quot;, 
+  { { &quot;Community&quot;, &quot;Comunidade&quot; }, &quot;comunity.html&quot;, 
     {
-      { &quot;Lists&quot;, &quot;comunity.html#lists&quot; },
+      { { &quot;Lists&quot;, &quot;Listas de Discuss&#227;o&quot; }, &quot;comunity.html#lists&quot; },
       { &quot;Forums&quot;, &quot;comunity.html#forums&quot; },
 --      { &quot;User's Wiki&quot;, &quot;comunity.html#userswiki&quot; },      
-      { &quot;Credits&quot;, &quot;comunity.html#credits&quot; },
+      { { &quot;Credits&quot;, &quot;Cr&#233;ditos&quot; }, &quot;comunity.html#credits&quot; },
       { nil, &quot;forum.html&quot;, nil, &quot;Forum&quot; } -- &quot;hidden&quot; entry (doesn't appear in the menu)
     }
   },
 
   -- &quot;News&quot;
-  { &quot;News&quot;, &quot;news.html&quot; },
+  { { &quot;News&quot;, &quot;Not&#237;cias&quot; }, &quot;news.html&quot; },
 
   -- &quot;Status&quot;
   { &quot;Status&quot;, &quot;status.html&quot;, 
     {
-      { &quot;Supported platforms&quot;, &quot;status.html#platforms&quot; },
-      { &quot;Roadmap&quot;, &quot;status.html#roadmap&quot; }
+      { { &quot;Supported platforms&quot;, &quot;Plataformas Suportadas&quot; }, &quot;status.html#platforms&quot; },
+      { { &quot;Roadmap&quot;, &quot;Planejamento Futuro&quot; }, &quot;status.html#roadmap&quot; }
     }
   },
 
  -- &quot;Using eLua&quot; -- Menu Separator
-  { &quot;Using eLua&quot; },
-  { &quot;Overview&quot;, &quot;doc.html&quot; },
-  { &quot;Installing&quot;, &quot;installing.html&quot;, 
+  { { &quot;Using eLua&quot;, &quot;Usando eLua&quot;}, nil },
+  { { &quot;Overview&quot;, &quot;Vis&#227;o Geral&quot; }, &quot;doc.html&quot; },
+  { { &quot;Installing&quot;, &quot;Instala&#231;&#245;es&quot; }, &quot;installing.html&quot;, 
     {
       { &quot;AT91SAM7x&quot;, &quot;installing_at91sam7x.html&quot; },
       { &quot;AVR32&quot;, &quot;installing_avr32.html&quot; },
@@ -77,45 +77,45 @@
   },
   { &quot;Downloads&quot;, &quot;downloads.html&quot;, 
     {
-      { &quot;Binaries&quot;, &quot;downloads.html#binaries&quot; },
-      { &quot;Source code&quot;, &quot;downloads.html#source&quot;, 
+      { { &quot;Binaries&quot;, &quot;Bin&#225;rios&quot; }, &quot;downloads.html#binaries&quot; },
+      { { &quot;Source code&quot;, &quot;C&#243;digo Fonte&quot; }, &quot;downloads.html#source&quot;, 
         {
-          { &quot;Official releases&quot;, &quot;downloads.html#official&quot; },
+          { { &quot;Official releases&quot;, &quot;Vers&#245;es Oficiais&quot; }, &quot;downloads.html#official&quot; },
           { &quot;Bleeding edge (SVN)&quot;, &quot;downloads.html#svnpublic&quot; },
-          { &quot;Developers&quot;, &quot;downloads.html#svndev&quot; },
+          { { &quot;Developers&quot;, &quot;Desenvolvedores&quot; }, &quot;downloads.html#svndev&quot; },
         }
       },
-      { &quot;Old versions&quot;, &quot;dl_old.html&quot;, 
+      { { &quot;Old versions&quot;, &quot;Vers&#245;es Anteriores&quot; }, &quot;dl_old.html&quot;, 
         {
           { &quot;0.4.1&quot;, &quot;dl_old.html#v041&quot; },
           { &quot;0.4&quot;, &quot;dl_old.html#v04&quot; },
           { &quot;0.3&quot;, &quot;dl_old.html#v03&quot; },
           { &quot;0.2&quot;, &quot;dl_old.html#v02&quot; },
           { &quot;0.1&quot;, &quot;dl_old.html#v01&quot; },
-          { &quot;Version history&quot;, &quot;versionhistory.html&quot; },
+          { { &quot;Version history&quot;, &quot;Hist&#243;rico das Vers&#245;es&quot; }, &quot;versionhistory.html&quot; },
         }
       },
     },
   },
-  { &quot;Using&quot;, &quot;using.html&quot;, 
+  { { &quot;Using&quot;, &quot;Usando eLua&quot; }, &quot;using.html&quot;, 
     {
-      { &quot;Over UART&quot;, &quot;using.html#uart&quot; },
-      { &quot;Over TCP/IP&quot;, &quot;using.html#tcpip&quot; },
-      { &quot;On PC&quot;, &quot;using.html#pc&quot; },
-      { &quot;The shell&quot;, &quot;using.html#shell&quot; },
+      { { &quot;Over UART&quot;, &quot;Console via UART&quot; }, &quot;using.html#uart&quot; },
+      { { &quot;Over TCP/IP&quot;, &quot;Console via TCP/IP&quot; }, &quot;using.html#tcpip&quot; },
+      { { &quot;On PC&quot;, &quot;Num PC&quot; }, &quot;using.html#pc&quot; },
+      { { &quot;The shell&quot;, &quot;O Shell&quot; }, &quot;using.html#shell&quot; },
       { &quot;Cross-compiling&quot;, &quot;using.html#cross&quot; },
     },
   },
-  { &quot;Code Examples&quot;, &quot;examples.html&quot; },
-  { &quot;FAQ&quot;, &quot;faq.html&quot; },
-  { &quot;Tutorials&quot;, &quot;tutorials.html&quot;,
+  { { &quot;Code Examples&quot;, &quot;Exemplos de C&#243;digo&quot; }, &quot;examples.html&quot; },
+  { { &quot;FAQ&quot;, &quot;Perguntas Frequ&#234;ntes&quot; }, &quot;faq.html&quot; },
+  { { &quot;Tutorials&quot;, &quot;Tutoriais&quot; }, &quot;tutorials.html&quot;,
     {
-      { &quot;Booting on a PC&quot;, &quot;tut_bootpc.html&quot; },
-      { &quot;Booting from a PenDrive&quot;, &quot;tut_bootstick.html&quot; },
-      { &quot;Using OpenOCD&quot;, &quot;tut_openocd.html&quot; },
-      { &quot;Building eLua&quot;, &quot;building.html&quot; },
-      { &quot;eLua Toolchains&quot;, &quot;toolchains.html&quot; },
-      { &quot;Building toolchains&quot;, &quot;tchainbuild.html&quot;,
+      { { &quot;Booting on a PC&quot;, &quot;Bootando num PC&quot; }, &quot;tut_bootpc.html&quot; },
+      { { &quot;Booting from a PenDrive&quot;, &quot;Bootando de um Pen-Drive&quot; }, &quot;tut_bootstick.html&quot; },
+      { { &quot;Using OpenOCD&quot;, &quot;Usando OpenOCD&quot; }, &quot;tut_openocd.html&quot; },
+      { { &quot;Building eLua&quot;, &quot;Build de eLua&quot; }, &quot;building.html&quot; },
+      { { &quot;eLua Toolchains&quot;, &quot;Toolchains para eLua&quot; }, &quot;toolchains.html&quot; },
+      { { &quot;Building toolchains&quot;, &quot;Build de Toolchains&quot; }, &quot;tchainbuild.html&quot;,
         {
           { &quot;ARM7 and ARM9&quot;, &quot;tc_arm.html&quot; },
           { &quot;ARM Cortex-M3&quot;, &quot;tc_cortex.html&quot; },
@@ -126,42 +126,42 @@
   },
 
   -- &quot;eLua internals&quot; (menu separator)
-  { &quot;eLua internals&quot; },
+  { { &quot;eLua internals&quot;, &quot;Arquitetura de eLua&quot; } },
 
   -- &quot;Overview&quot;
-  { &quot;Overview&quot;, &quot;arch_overview.html&quot;, 
+  { { &quot;Overview&quot;, &quot;Vis&#227;o Geral&quot; }, &quot;arch_overview.html&quot;, 
     {
-      { &quot;Structure&quot;, &quot;arch_overview.html#structure&quot; },
-      { &quot;Commond code&quot;, &quot;arch_overview.html#common&quot; },
-      { &quot;Platform interface&quot;, &quot;arch_overview.html#platform&quot; },
-      { &quot;Platforms/ports&quot;, &quot;arch_overview.html#platforms&quot; },
-      { &quot;Booting eLua&quot;, &quot;arch_overview.html#boot&quot; }
+      { { &quot;Structure&quot;, &quot;Estrutura&quot; }, &quot;arch_overview.html#structure&quot; },
+      { { &quot;Commond code&quot;, &quot;C&#243;digo B&#225;sico&quot; }, &quot;arch_overview.html#common&quot; },
+      { { &quot;Interface Architecture&quot;, &quot;Interfaceamento&quot; }, &quot;arch_overview.html#platform&quot; },
+      { { &quot;Platforms/ports&quot;, &quot;Portabiliza&#231;&#227;o&quot; }, &quot;arch_overview.html#platforms&quot; },
+      { { &quot;Booting eLua&quot;, &quot;O Boot de eLua&quot; }, &quot;arch_overview.html#boot&quot; }
     }
   },
 
   -- Platform interface (automatically generated)
-  { &quot;Platform interface&quot;, &quot;arch_platform.html&quot;, &quot;arch_platform&quot; },
+  { { &quot;Platform interface&quot;, &quot;Interfaceando com Plataformas&quot; }, &quot;arch_platform.html&quot;, &quot;arch_platform&quot; },
 
   -- Other WRITE THE arch_platform_other.html file
-  { &quot;Other&quot;, &quot;#&quot;, 
+  { { &quot;Some more Info&quot;, &quot;Informa&#231;&#245;es Adicionais&quot; }, &quot;#&quot;, 
     {
-      { &quot;ROM file system&quot;, &quot;arch_romfs.html&quot; },
-      { &quot;Adding a new port&quot;, &quot;arch_newport.html&quot; },
-      { &quot;Modules and LTR&quot;, &quot;arch_ltr.html&quot; },
-      { &quot;Consoles and terminals&quot;, &quot;arch_con_term.html&quot; },
-      { &quot;TCP/IP in eLua&quot;, &quot;arch_tcpip.html&quot; },
-      { &quot;eLua coding style&quot;, &quot;arch_coding.html&quot; }
+      { { &quot;ROM file system&quot;, &quot;O ROM File System&quot; }, &quot;arch_romfs.html&quot; },
+      { { &quot;Adding a new port&quot;, &quot;Portando eLua&quot; }, &quot;arch_newport.html&quot; },
+      { { &quot;Modules and LTR&quot;, &quot;Modulos e LTR&quot; }, &quot;arch_ltr.html&quot; },
+      { { &quot;Consoles and terminals&quot;, &quot;Consoles e Terminais&quot; }, &quot;arch_con_term.html&quot; },
+      { { &quot;TCP/IP in eLua&quot;, &quot;TCP/IP em eLua&quot; }, &quot;arch_tcpip.html&quot; },
+      { { &quot;eLua coding style&quot;, &quot;Regras de Codifica&#231;&#227;o&quot; }, &quot;arch_coding.html&quot; }
     }
   },
 
   -- &quot;Reference manual&quot; (menu separator)
-  { &quot;Reference manual&quot; },
+  { { &quot;Reference manual&quot;, &quot;Manual de Refer&#234;ncia&quot; } },
 
   -- &quot;Generic modules&quot; (automatically generated)
-  { &quot;Generic modules&quot;, &quot;refman_gen.html&quot;, &quot;refman_gen&quot; },
+  { { &quot;Generic modules&quot;, &quot;M&#243;dulos Gen&#233;ricos&quot; }, &quot;refman_gen.html&quot;, &quot;refman_gen&quot; },
 
   -- &quot;Platform modules&quot;
-  { &quot;Platform modules&quot;, &quot;refman_dep.html&quot;, 
+  { { &quot;Platform modules&quot;, &quot;M&#243;dulos dependentes de Plataformas&quot; }, &quot;refman_dep.html&quot;, 
     {
       { &quot;lm3s&quot;, &quot;modules_lm3s.html&quot;, &quot;refman_ps_lm3s&quot; }
     }

Added: tags/pre0.6/doc/pt/arch.html
===================================================================
--- tags/pre0.6/doc/pt/arch.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,14 @@
+&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Strict//EN&quot;&gt;
+&lt;html&gt;&lt;head&gt;
+&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; 
+&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en-us&quot;&gt;&lt;title&gt;eLua architecture&lt;/title&gt;
+
+&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;
+&lt;body style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;
+&lt;h3&gt;A arquitetura Elua&lt;/h3&gt;
+&lt;p&gt;Esta se&ccedil;&atilde;o apresenta em detalhes, a concep&ccedil;&atilde;o e implementa&ccedil;&atilde;o de &lt;b&gt;eLua&lt;/b&gt;. Foi concebida como um guia, principalmente para os desenvolvedores &lt;b&gt;eLua&lt;/b&gt;,
+  mas cont&eacute;m informa&ccedil;&atilde;o que pode ser tamb&eacute;m &uacute;til tamb&eacute;m para usu&aacute;rios de &lt;b&gt;eLua&lt;/b&gt;. Um exemplo &eacute; o cap&iacute;tulo sobre o &lt;a href=&quot;arch_romfs.html&quot;&gt;sistema de arquivos ROM&lt;/a&gt;.
+  Al&eacute;m disso, ao ler a &lt;a href=&quot;arch_overview.html&quot;&gt;vis&atilde;o geral da arquitetura Elua&lt;/a&gt; voc&ecirc; vai ter uma boa vis&atilde;o da estrutura geral de &lt;b&gt;eLua&lt;/b&gt;,
+  que ir&aacute; ajudar, n&atilde;o importa se voc&ecirc; &eacute; um desenvolvedor ou n&atilde;o.&lt;/p&gt;
+&lt;p&gt;Antes de nos aprofundarmos nisso, v&aacute; para a &lt;a href=&quot;downloads.html&quot;&gt;se&ccedil;&atilde;o de downloads&lt;/a&gt; e baixe o c&oacute;digo fonte do &lt;b&gt;Elua&lt;/b&gt;, &eacute; muito mais f&aacute;cil seguir esta se&ccedil;&atilde;o acompanhando pelo c&oacute;digo-fonte.&lt;/p&gt;
+&lt;/body&gt;&lt;/html&gt;

Added: tags/pre0.6/doc/pt/arch_coding.html
===================================================================
--- tags/pre0.6/doc/pt/arch_coding.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_coding.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,163 @@
+$$HEADER$$
+&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;
+&lt;body style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;
+&lt;h3&gt;Estilo de codifica&ccedil;&atilde;o em eLua&lt;/h3&gt;
+&lt;p&gt;Esta se&ccedil;&atilde;o tem o objetivo de apresentar o estilo de codifica&ccedil;&atilde;o em &lt;b&gt;eLua&lt;/b&gt; que deve ser seguido por todo desenvolvedor. Segue abaixo as regras de codifica&ccedil;&atilde;o &lt;b&gt;eLua&lt;/b&gt;:
+&lt;ol&gt;
+  &lt;li&gt;Deve-se formatar o texto adequadamente. Exemplos (&quot;por favor, preste aten&ccedil;&atilde;o nas regras de espa&ccedil;amento, pois resumem-se em acrescentar espa&ccedil;os em tudo, com o objetivo de tornar mais f&aacute;cil a leitura do c&oacute;digo&quot;):
+  &lt;p&gt;&lt;pre&gt;&lt;code&gt;i = 3 (not i=3)
+a = ( a + 5 ) / 3
+for( i = 0; i &lt; 10; i ++ ) ...
+if( ( i == 5 ) &amp;&amp; ( a == 10 ) ) ...
+unsigned i = ( unsigned )p;
+void func( int arg1, const char* arg2 ) ...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;Indenta&ccedil;&atilde;o&lt;/b&gt;: Use dois espa&ccedil;os para toda identa&ccedil;&atilde;o. Novamente, &lt;b&gt;ESPA&Ccedil;OS&lt;/b&gt;. &lt;b&gt;N&Atilde;O USE TABS&lt;/b&gt;; isto &eacute; importante (e felizmente f&aacute;cil de lembrar :) ). 
+  Existem muitos exemplos onde tabs estragam completamente a clareza do c&oacute;digo fonte. A maioria dos editores de texto t&ecirc;m a op&ccedil;&atilde;o de &quot;inser&ccedil;&atilde;o de tabs ao inv&eacute;s de espa&ccedil;os&quot;;
+  utilize-a e configure o tamanho do TAB para 2.&lt;br&gt;
+  Al&eacute;m disso, idente &quot;{&quot; e &quot;}&quot; sobre suas pr&oacute;rias linhas:
+  &lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
+{
+  // algum c&oacute;digo aqui
+}
+else
+{
+  // mais algum c&oacute;digo aqui
+}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+      Ou:
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;void f( int i )
+{
+  // function code
+}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+Sempre que poss&iacute;vel, n&atilde;o cerque um comando com {}. Por exemplo, fa&ccedil;a isso:
+
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
+  return;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+          
+          ao inv&eacute;s disso:
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
+{
+  return;
+}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+Al&eacute;m disso, siga a regra de &quot;um comando por linha&quot;. Em outras palavras, n&atilde;o fa&ccedil;a isso:
+
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 ) return;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+ao inv&eacute; disso, fa&ccedil;a:
+
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;if( i == 2 )
+  return;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+Observe que o c&oacute;digo &lt;b&gt;eLua&lt;/b&gt; n&atilde;o usa espa&ccedil;o entre o nome da fun&ccedil;&atilde;o e sua lista de par&acirc;metros quando de sua chamada/defini&ccedil;&atilde;o (como no c&oacute;digo Lua, por exemplo). So do this:
+
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;void f( int i )
+{
+  // function code here
+}
+
+f( 2 ); // function call&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+instead of this:
+
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;void f ( int i )
+{
+  // function code here
+}
+
+f ( 2 ); // function call&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;line terminators&lt;/b&gt;: &lt;b&gt;THIS IS IMPORTANT TOO!&lt;/b&gt; Use UNIX style (LF) line terminators, not DOS (CR/LF) or old Mac (CR) line terminators.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;identifier names&lt;/b&gt;: use a &quot;GNU-style&quot; here, with underlines and all lowercase:
+
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;int simple;
+double another_identifier;
+char yes_this_is_OK_although_quite_stupid;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+As opposed to:
+
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;int Simple1;
+double AnotherIdentifier;
+char DontEvenThinkAboutWritingSomethingLikeThis;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;b&gt;DO NOT USE HUNGARIAN NOTATION&lt;/b&gt; (like iNumber, sString, fFloat ... if you don't know what that is, it's fine, as it means that we don't need to worry about it :) ). It has its advantages
+when used properly, it's just not for &lt;b&gt;eLua&lt;/b&gt;.
+&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;constants in code&lt;/b&gt;: don't ever write something like this:
+
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;if( key == 10 )
+  sys_ok();
+else if( key == 5 )
+  phone_dial( &quot;911&quot; );
+else if( key == 666 )
+{
+  while( user_is_evil() )
+    exorcize_user();
+}
+else if( key == 0 )
+ sys_retry();
+else
+ sys_error();&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+Instead, define some constants with meaningful names (via enums or even #define) and write like this:
+
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;if( key == KEY_CODE_OK )
+  sys_ok();
+else if( key == KEY_CODE_FATAL_ERROR )
+  phone_dial( &quot;911&quot; );
+else if( key == KEY_CODE_COMPLETELY_EVIL )
+{
+  while( user_is_evil() )
+    exorcize_user();
+}
+else if( key == KEY_CODE_NONE )
+  sys_retry();
+else
+  sys_error();&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+You can see in this example an accepted violation of the &quot;one statement per line&quot; rule: it's OK to write &quot;else if (newcondition)&quot; on the same line.&lt;/li&gt;
+
+&lt;li&gt;use specific data types as much as possible. In this context, &lt;b&gt;specific data types&lt;/b&gt; reffers to generic types that have the same size on all 
+  platforms. They are defined by each platform in turn and their meaning is given below:
+  &lt;ul&gt;
+    &lt;li&gt;&lt;b&gt;s8&lt;/b&gt;: signed 8-bit integer&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;u8&lt;/b&gt;: unsigned 8-bit integer&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;s16&lt;/b&gt;: signed 16-bit integer&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;u16&lt;/b&gt;: unsigned 16-bit integer&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;s32&lt;/b&gt;: signed 32-bit integer&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;u32&lt;/b&gt;: unsigned 32-bit integer&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;s64&lt;/b&gt;: signed 64-bit integer&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;u64&lt;/b&gt;: unsigned 64-bit integer&lt;/li&gt;
+  &lt;/ul&gt;
+  By writing your code to take advantage of these specific data types you ensure high portability of the code amongst different hardware platforms. Don't
+  overuse this rule though. For example, a &lt;b&gt;for&lt;/b&gt; loop has generally an &lt;b&gt;int&lt;/b&gt; index, which is perfectly fine. But when you specify a timeout that
+  must fit in 32 bits, definitely declare it as &lt;b&gt;u32 to&lt;/b&gt; instead of &lt;b&gt;unsigned int to&lt;/b&gt;.
+&lt;/li&gt;
+
+&lt;li&gt;&lt;b&gt;endianness&lt;/b&gt;: remember that &lt;b&gt;eLua&lt;/b&gt; runs on both little endian and big endian architectures, and write your code accordingly.&lt;/li&gt;
+
+&lt;li&gt;&lt;b&gt;comments&lt;/b&gt;: we generally favour C++ style comments (//), but it's perfectly OK to use C style (/**/) comments. Automatic documentation generators like Doxygen aren't encouraged, since 
+  they tend to make the programmer overdocument the code to the point where it becomes hard to read because of the documentation alone. Ideally, you'd neither overdocument, nor 
+  underdocument your code; just document it as much as you think it's needed, without getting into too much details, but also without omitting important information. In particular, DON'T do this:
+
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;// This function returns the sum of two numbers
+// Input: n1 - first number
+// Input: n2 - the second number
+// Output: the sum of n1 and n2
+int sum( int n1, int n2 )
+{
+  return n1 + n2;
+}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+
+  When something is self-obvious from the context, documenting it more is pointless and decreases readability.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;pseudo name-spaces&lt;/b&gt;: since we don't have namespaces in C, I like to &quot;emulate&quot; them by prefixing anything (constants, variables, functions) in a file with something that identifies that 
+  file uniquely (most likely its name, but this is not a definite rule). For example, a file called &quot;uart.c&quot; would look like this:
+
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;int uart_tx_count, uart_rx_count;
+
+int uart_receive( unsigned limit )...
+unsigned uart_send( const char *buf, unsigned size )...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;/li&gt;
+
+&lt;/ol&gt;&lt;/p&gt;
+&lt;p&gt;Also, if you're using 3rd party code (from a library/support package for example) making it follow the above rules is nice, but not mandatory. Focus on functionality and writing your own code properly, and come back to indent other people's code when you really don't have anything better to do with your time.&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/arch_con_term.html
===================================================================
--- tags/pre0.6/doc/pt/arch_con_term.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_con_term.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,84 @@
+$$HEADER$$
+&lt;h3&gt;eLua consoles and terminals&lt;/h3&gt;
+&lt;p&gt;In &lt;b&gt;eLua&lt;/b&gt;, a &lt;b&gt;console&lt;/b&gt; and a &lt;b&gt;terminal&lt;/b&gt; serve two related, but different purposes:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;the &lt;b&gt;console&lt;/b&gt; takes care of basic user input/output. They come in two flavours: serial consoles and TCP/IP consoles (note that the two can't coexist at the same time).&lt;/li&gt;
+  &lt;li&gt;the &lt;b&gt;terminal&lt;/b&gt; enhances the console in order to take advantage of ANSI terminals and their advanced control functions, like explicit cursor positioning, clear screen and others. At this
+  time, terminals work only over serial connections, not over TCP/IP (like consoles).&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;Both components can be enabled and disabled as needed (they don't rely on each other). See &lt;a href=&quot;building.html&quot;&gt;building eLua&lt;/a&gt; for details on how to enable and disable components.&lt;/p&gt;
+&lt;h2&gt;Serial consoles&lt;/h2&gt;
+&lt;p&gt;The serial console input/output is handled by a generic layer (&lt;i&gt;src/newlib/genstd.c&lt;/i&gt;) that can be used to easily adapt the console subsystem to a variety of input/output devices. 
+  It needs just two functions, one for displaying characters and another one for receiving input with timeout:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;// Send/receive function types
+typedef void ( *p_std_send_char )( int fd, char c );
+typedef int ( *p_std_get_char )( s32 to );
+&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;(the &lt;b&gt;send&lt;/b&gt; faction gets an additional &lt;b&gt;fd&lt;/b&gt; parameter that you can use to  differentiate between the standard C stdout and stderr output streams).&lt;/p&gt;
+&lt;p&gt;To set them, use &lt;b&gt;std_set_send_func&lt;/b&gt; and &lt;b&gt;std_set_get_func&lt;/b&gt;, both defined in &lt;i&gt;inc/newlib/getstd.h&lt;/i&gt;. Usually they are called from &lt;i&gt;src/common.c&lt;/i&gt; and configured to work
+  over UART by default:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;// *****************************************************************************
+// std functions and platform initialization
+
+static void uart_send( int fd, char c )
+{
+  fd = fd;
+  platform_uart_send( CON_UART_ID, c );
+}
+
+static int uart_recv( s32 to )
+{
+  return platform_uart_recv( CON_UART_ID, TERM_TIMER_ID, to );
+}
+
+void cmn_platform_init()
+{
+  // Set the send/recv functions                          
+  std_set_send_func( uart_send );
+  std_set_get_func( uart_recv );  
+}
+&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;If you need another type of serial console device (for example a dedicated console running over a SPI connection) just call &lt;i&gt;std_set_send_func/std_set_get_func&lt;/i&gt; with the appropriate 
+  function pointers.&lt;/p&gt;
+&lt;p&gt;To enable serial consoles, define the &lt;b&gt;BUILD_CON_GENERIC&lt;/b&gt; macro in your platform's &lt;b&gt;platform_conf.h&lt;/b&gt; file.&lt;/p&gt;
+&lt;h2&gt;TCP/IP consoles&lt;/h2&gt;
+&lt;p&gt;TCP/IP consoles have the same functionality as serial consoles, but they work over a TCP/IP connection using the telnet protocol. As they integrate directly with the TCP/IP subsystem, 
+  they don't have the same generic function based mechanism as serial consoles. To enable TCP/IP consoles, define the &lt;b&gt;BUILD_CON_TCP&lt;/b&gt; macro in your platform's &lt;b&gt;platform_conf.h&lt;/b&gt; file.&lt;/p&gt;
+&lt;h2&gt;Terminals&lt;/h2&gt;
+&lt;p&gt;Besides standard stdio/stdout/stderr support provided by consoles, &lt;b&gt;eLua&lt;/b&gt; uses the &quot;term&quot; module to access ANSI compatible terminal emulators.  It is designed to be as flexible as 
+  possible, thus allowing a large number of terminal emulators to be used. To enable terminal support, add &lt;b&gt;BUILD_TERM&lt;/b&gt; in your platform's &lt;b&gt;platform_conf.h&lt;/b&gt; file. To use it, initialize
+  it with a call to &lt;b&gt;term_init&lt;/b&gt;:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;...........................
+// Terminal output function
+typedef void ( *p_term_out )( u8 );
+// Terminal input function
+typedef int ( *p_term_in )( int );
+// Terminal translate input function
+typedef int ( *p_term_translate )( u8 );
+...........................
+// Terminal initialization
+void term_init( unsigned lines, unsigned cols, p_term_out term_out_func, 
+                p_term_in term_in_func, p_term_translate term_translate_func );
+&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;The initialization function takes the physical size of the terminal emulator window (usually 80 lines and 25 cols) and three function pointers:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;&lt;b&gt;p_term_out&lt;/b&gt;: this function will be called to output characters to the terminal. It receives the character to output as its single parameter.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;p_term_in&lt;/b&gt;: this function will be called to read a character from the terminal. It receives a parameter that can be either TERM_INPUT_DONT_WAIT (in which case the function returns 
+  -1 immediately if no character is available) or TERM_INPUT_WAIT (in which case the function will wait for the character).&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;p_term_translate&lt;/b&gt;: this function translates terminal-specific codes to &quot;term&quot; codes. The &quot;term&quot; codes are defined in an enum from &lt;i&gt;inc/term.h&lt;/i&gt;:
+&lt;pre&gt;&lt;code&gt;...........................
+_D( KC_UP ),\
+_D( KC_DOWN ),\
+_D( KC_LEFT ),\
+...........................
+_D( KC_ESC ),\
+_D( KC_UNKNOWN )  
+...........................&lt;/code&gt;&lt;/pre&gt;
+By using this function, it is possible to adapt a very large number of &quot;term emulators&quot; to &lt;b&gt;eLua&lt;/b&gt;. For example, you might want to run eLua in a &quot;standalone
+  mode&quot; that does not require a PC at all, just an external LCD display and maybe a keyboard for data input. Your &lt;b&gt;eLua&lt;/b&gt; board can connect to this standalone terminal using its 
+  I/O pins or built in peripherals, for example via SPI. By writing the three functions described above, the effort of making &lt;b&gt;eLua&lt;/b&gt; work with this new type of device is minimal, 
+  and also writing an &quot;ANSI emulator&quot; for your terminal device is not hard.&lt;/li&gt;&lt;/ul&gt;
+&lt;p&gt;For an example, see &lt;i&gt;src/main.c&lt;/i&gt;, where these functions are implemented for an UART connection with a terminal emulator program running on PC.&lt;/p&gt;
+&lt;p&gt;&lt;b&gt;eLua&lt;/b&gt; also provides a Lua module (called &lt;b&gt;term&lt;/b&gt;) that can be used to access ANSI terminal. See &lt;a href=&quot;&quot;&gt;the term module API&lt;/a&gt; for a full description of this module.&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/arch_ltr.html
===================================================================
--- tags/pre0.6/doc/pt/arch_ltr.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_ltr.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,264 @@
+$$HEADER$$
+&lt;h3&gt;Modules and LTR&lt;/h3&gt;
+&lt;p&gt;LTR (Lua Tiny RAM) is a Lua patch (written specifically for &lt;b&gt;eLua&lt;/b&gt; by Bogdan Marinescu) that significantly decreases the RAM usage of Lua scripts,
+  thus making it possible to run large Lua programs on systems with limited RAM. This section gives a full description of LTR. If you're writing &lt;b&gt;eLua&lt;/b&gt;
+  modules, this page will certainly be of interest to you, as it shows how to interact with LTR in a portable and easy to configure way.&lt;/p&gt;
+&lt;h2&gt;Motivation&lt;/h2&gt;
+&lt;p&gt;The main thing that drove me to write this patch is the relatively high Lua memory consumption at startup (obtained by running 
+  &lt;i&gt;lua -e &quot;print(collectgarbage'count')&quot;&lt;/i&gt;). It's about 17k for regular Lua 5.1.4, and more than 25k for some of eLua's platforms. These figures are 
+  mainly a result of registering many different modules to Lua. Each time you register a module (via luaL_register) you create a new table and populate 
+  it with the module's methods. But a table is a read/write datatype, so luaL_register is quite inefficient if you don't plan to do any write operations 
+  on that table later (adding new elements or manipulating existing ones). I found that I almost never have to do any such operations on a module's 
+  table after it was created, I just query it for its elements. So, from the perspective of someone worried about memory usage, I'd rather have a 
+  different type of table in this case, one that wouldn't need any RAM at all, since it would be read only, so it could reside entirely in ROM.&lt;/p&gt;
+  &lt;p&gt;There's one more thing related to this context: Lua's functions. While Lua does have the concept of C functions, they still require data structures 
+  that need to be allocated (see lua_pushcclosure in lapi.c for details), as they can have upvalues or environments. Once again, this isn't something I 
+  use often with eLua. Most of the times my functions (especially the ones exported by a C module) are very simple, and they don't need upvalues or 
+  environments at all. In conclusion, having a &quot;simpler&quot; function type would improve memory usage.
+&lt;/p&gt;
+&lt;h2&gt;Details&lt;/h2&gt;
+&lt;p&gt;The patch adds two new data types to Lua. Both or them are based on the lightuserdata type already found in Lua, and they share the same basic 
+  attributes: they don't need to be dynamically allocated (as they're just pointers on steroids) and they're compared in the same way lightuserdatas 
+  are compared (by value). And of course, they are not collectable, so the garbage collector won't have anything to do with them. The new types are:&lt;/p&gt;
+&lt;ol&gt;
+&lt;li&gt;&lt;b&gt;lightfunctions&lt;/b&gt;: these are &quot;simple&quot; functions, in the sense that they can't have upvalues or environments. They are just pointers to regular 
+  C functions. Other than that, you can use them from Lua just as you'd use any other function.&lt;/li&gt;
+
+&lt;li&gt;&lt;b&gt;rotables&lt;/b&gt;: these are read-only tables, but unlike the read-only tables that one can already implement in Lua with metamethods, they have a 
+  very specific property: they don't need any RAM at all. They are fully constant, so they can be read directly from ROM. They have a number of 
+  special features and limitations when compared with a regular table:
+&lt;ul&gt;
+  &lt;li&gt;rotables can only contain values of type &quot;lightfunction&quot;, lua_Number or pointers to other rotables.&lt;/li&gt;
+  &lt;li&gt;you can't add/delete/modify elements from rotables (obviously). However, rotables will honour the &quot;__newindex&quot; metamethod.&lt;/li&gt;
+  &lt;li&gt;you can use rotables as metatables for both &quot;regular&quot; tables and for Lua types (via debug.setmetatable)&lt;/li&gt;
+  &lt;li&gt;a rotable can have another rotable (or tself) as a metatable&lt;/li&gt;
+  &lt;li&gt;you can iterate over rotables with pairs/ipairs/next just as you do with &quot;regular&quot; tables.&lt;/li&gt;
+&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
+&lt;p&gt;Just as with lightuserdata, you can only create lightfunctions and rotables from C code, never from Lua itself.&lt;/p&gt;
+&lt;h2&gt;Testing&lt;/h2&gt;
+&lt;p&gt;I tested my patch with the (&lt;a target=&quot;_blank&quot; href=&quot;<A HREF="http://lua-users.org/lists/lua-l/2006-03/msg00723.html">http://lua-users.org/lists/lua-l/2006-03/msg00723.html</A>&quot;&gt;Lua 5.1 test suite&lt;/a&gt;). The test suite 
+  was an excellent testing tool. I thought I had the patch ready until I found the test suite and ran it. After another week of work, I had something 
+  that could be called functional :)&lt;/p&gt;
+&lt;p&gt;I tested everything via &quot;make generic&quot;, which is how I always build Lua for my embedded environments. This means (among other things) that I didn't 
+test pipes and dynamic module loading, although I don't see why they wouldn't work.&lt;/p&gt;
+&lt;p&gt;I never tested the patch in a multithreaded environment with more threads running different lua_States. I never even used regular Lua like this, 
+so I can't make asumptions about how my patch would behave in a multithreaded environment. It doesn't use any global or static variables, but you 
+might encounter other problems with it.&lt;/p&gt;
+&lt;h2&gt;Results&lt;/h2&gt;
+&lt;p&gt;The table below summarizes the RAM usage in KBytes (as obtained by running &lt;i&gt;lua -e &quot;print(collectgarbage'count')&quot;&lt;/i&gt; from the &lt;b&gt;eLua&lt;/b&gt; shell). 
+  &lt;b&gt;OPT=0&lt;/b&gt; is LTR's &quot;compatibility mode&quot; (basically this means that the patch is disabled, so you're running plain Lua) and &lt;b&gt;OPT=2&lt;/b&gt; is the 
+  patch in action.&lt;/p&gt;
+&lt;table style=&quot;width: 325px;&quot; class=&quot;table_center&quot;&gt;
+&lt;tbody&gt;
+&lt;tr&gt;
+&lt;th style=&quot;text-align: left;&quot;&gt;Platform&lt;/th&gt;
+&lt;th style=&quot;text-align: center;&quot;&gt;OPT=0&lt;/th&gt;
+&lt;th style=&quot;text-align: center;&quot;&gt;OPT=2&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;AVR32&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;23.75&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;5.42&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;AT91SAM7X&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;25.16&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;5.42&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;STR7&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;24.92&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;5.42&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;STR9&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;22.23&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;5.42&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;LPC2888&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;22.23&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;5.42&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;i386&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;16.90&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;5.42&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;LM3S&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;27.14&lt;/td&gt;
+  &lt;td style=&quot;text-align: center;&quot;&gt;5.42&lt;/td&gt;
+&lt;/tr&gt;
+&lt;/tbody&gt;
+&lt;/table&gt;
+
+&lt;p&gt;As you can see, the differences are significant, and (more important) it doesn't matter how many modules you load in &lt;b&gt;eLua&lt;/b&gt;, the RAM consumption
+   doesn't modify.&lt;/p&gt;
+&lt;p&gt;Currently, there aren't any performane measurements related to LTR. It's clear from the implementation that the patch slows down the virtual machine, 
+   but a precise performance penalty figure is not known. Experience suggests that the peformance penalty is minimal, and it certainly can't be observed 
+   with &quot;regular&quot; (non-computationally intensive) Lua programs.&lt;/p&gt;
+&lt;h2&gt;How to enable LTR&lt;/h2&gt;
+&lt;p&gt;Enabling LTR is very easy: all you need to do is specify the &lt;b&gt;opt=1&lt;/b&gt; as a paramater to scons when bulding &lt;b&gt;eLua&lt;/b&gt;, as explained
+   &lt;a href=&quot;building.html&quot;&gt;here&lt;/a&gt;. You don't even to specify this explicitly, as LTR is enabled by default for all &lt;b&gt;eLua&lt;/b&gt; targets.&lt;/p&gt;
+&lt;p&gt;When &lt;b&gt;optram&lt;/b&gt; is 0, LTR is not active. In this mode the patch just tries to keep the modified version as close as possible to the unpatched version 
+  in terms of speed and functionality. You might want to use this if you want full Lua compatibility (although this is rarely an issue in practice),
+  or need to overcome the read-only limitations of rotables (but check &lt;a href=&quot;faq.html#rotables&quot;&gt;this&lt;/a&gt; first). If your program behaves weird and you
+  suspect that LTR might be the cause of your problems, recompiling with &lt;b&gt;optram=0&lt;/b&gt; is a quick way to eliminate or confirm your suspicions.&lt;/p&gt;
+&lt;p&gt;When &lt;b&gt;optram&lt;/b&gt; is 1 (default), all the LTR optimizations are enabled. The implementation of the Lua standard libraries is modified to take advantage
+   of the new datatypes. In particular, the IO library is modified to use the registry instead of environments, thus making it more resource-friendly, 
+   the side effect  being that this mode doesn't support pipes in the &lt;b&gt;io&lt;/b&gt; module (which isn't an issue for &lt;b&gt;eLua&lt;/b&gt;). 
+   It also leaves the &lt;b&gt;_G&lt;/b&gt; (globals) table with a single method (&lt;i&gt;__index&lt;/i&gt;) and sets it as its own metatable, so all accesses to globals are
+   now sligthly slower because of the &lt;i&gt;__index&lt;/i&gt; metamethod call.&lt;/p&gt;
+&lt;h2&gt;Writing LTR-compatible modules&lt;/h2&gt;
+&lt;p&gt;The LTR patch introduces a specific method for writing modules in such a way that they're fully compatible with both &lt;b&gt;optram=0&lt;/b&gt; and &lt;b&gt;optram=1&lt;/b&gt;.
+   If you're writing a new &lt;b&gt;eLua&lt;/b&gt; module you should use this method, as it keeps code coherency. &lt;/p&gt;
+&lt;p&gt;We'll show this method using a simple example. Let's assume that you want to register a simple module called &quot;mod&quot; that has a single function named &quot;f&quot;. 
+  For regular Lua, you'd do something like this:&lt;/p&gt;
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;static const luaL_reg mod_map[] =
+{
+  { &quot;f&quot;, f_implementation },
+  { NULL, NULL }
+};
+
+LUALIB_API int luaopen_mod( lua_State *L )
+{
+  luaL_register( L, &quot;mod&quot;, mod_map );
+  return 1;
+}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;p&gt;For the rotables implementation, however, you'd need to define the same thing like this:&lt;/p&gt;
+
+&lt;pre&gt;&lt;code&gt;const luaR_entry mod_map[] = &lt;span class=&quot;warning&quot;&gt;// note: no static this time&lt;/span&gt;
+{
+  { LRO_STRKEY( &quot;f&quot; ), LRO_FUNCVAL( f_implementation ) },
+  { LRO_NILKEY, LRO_NILVAL }
+};
+
+&lt;span class=&quot;warning&quot;&gt;// note: in this case the &quot;luaopen_mod&quot; function isn't really needed anymore&lt;/span&gt;
+LUALIB_API int luaopen_mod( lua_State *L )
+{
+  return 0;
+}&lt;/code&gt;&lt;/pre&gt;
+
+&lt;p&gt;A few points about the rotables example above:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;a rotable needs a &quot;map&quot; (mod_map) array much like a regular module, but you need to define that array with special macros:
+  &lt;ul&gt;
+    &lt;li&gt;&lt;b&gt;for keys&lt;/b&gt;: &lt;b&gt;LRO_STRKEY(&quot;str&quot;)&lt;/b&gt; defines a string key, &lt;b&gt;LRO_NUMKEY(n)&lt;/b&gt; defines an integer key, and &lt;b&gt;LRO_NILKEY&lt;/b&gt; defines a NULL 
+       (empty) key&lt;/li&gt;
+    &lt;li&gt;&lt;b&gt;for values&lt;/b&gt;: &lt;b&gt;LRO_FUNCVAL(f)&lt;/b&gt; defines a lightfunction value, &lt;b&gt;LRO_NUMVAL(f)&lt;/b&gt; defines a number value, &lt;b&gt;LRO_RO(p)&lt;/b&gt; defines a 
+       rotable value (p is the pointer to the rotable) and &lt;b&gt;LRO_NILVAL&lt;/b&gt; defines a NULL (empty) value.&lt;/li&gt;
+  &lt;/ul&gt;&lt;/li&gt;
+  &lt;li&gt;all the &quot;global&quot; rotables in the system (the ones that must be visible from &lt;b&gt;_G&lt;/b&gt;, like the rotables of all the modules exported to Lua) must be 
+  included in a special array, called &lt;b&gt;lua_rotable&lt;/b&gt; (defined in &lt;i&gt;linit.c&lt;/i&gt;). Simply including the rotable's definition array (mod_map in this case)
+  in the lua_rotable array makes it visible globally, thus you don't need to call any kind of register function. This is why &lt;b&gt;luaopen_mod&lt;/b&gt; now returns
+  0.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;The two forms above (for regular tables and for rotables) are clearly different, but we want to keep them both to be able to work at both &lt;b&gt;optram=0&lt;/b&gt;
+  and &lt;b&gt;optram=2&lt;/b&gt;. You can use #ifdefs to differentiate between the two cases in different optimization levels, but this becomes really annoying after 
+  a (short) while. This is why I added another file called &lt;b&gt;lrodefs.h&lt;/b&gt; (&lt;i&gt;src/lua&lt;/i&gt;) that can be used to give an &quot;universal&quot; definition to our map 
+  arrays. Here's how our example looks after rewriting it to take advantage of &lt;b&gt;lrodefs.h&lt;/b&gt;:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;warning&quot;&gt;#define MIN_OPT_LEVEL  2 // the minimum optimization level at which we use rotables&lt;/span&gt;
+#include &quot;lrodefs.h&quot;
+const &lt;span class=&quot;warning&quot;&gt; LUA_REG_TYPE&lt;/span&gt; mod_map[] = &lt;span class=&quot;warning&quot;&gt;// note: no more luaL_reg or luaR_entry&lt;/span&gt;
+{
+  { LSTRKEY( &quot;f&quot; ), LFUNCVAL( f_implementation ) },
+  { LNILKEY, LNILVAL }
+};
+// &lt;span class=&quot;warning&quot;&gt;note: no more LRO_something, just Lsomething (for example LRO_STRKEY becomes LSTRKEY)&lt;/span&gt;
+
+LUALIB_API int luaopen_mod( lua_State *L )
+{
+  &lt;span class=&quot;warning&quot;&gt;LREGISTER&lt;/span&gt;( L, &quot;mod&quot;, mod_map ); // &lt;span class=&quot;warning&quot;&gt;note: no more luaL_register, no &quot;return 1&quot;&lt;/span&gt;
+}&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;Now, if &lt;b&gt;LUA_OPTIMIZE_MEMORY&lt;/b&gt; (a macro defined by the system as 0 when &lt;b&gt;optram=0&lt;/b&gt; and as 2 when &lt;b&gt;optram=1&lt;/b&gt;) is less than 
+  &lt;b&gt;MIN_OPT_LEVEL&lt;/b&gt;, the above definition will compile in its &quot;regular table&quot; format. If &lt;b&gt;LUA_OPTIMIZE_MEMORY&lt;/b&gt; is 2, it compiles to the 
+  rotables format. Problem solved :) &lt;b&gt;LREGISTER&lt;/b&gt; will also take care of calling &lt;b&gt;luaL_register&lt;/b&gt; and return 1 when &lt;b&gt;optram=0&lt;/b&gt; and do 
+  absolutely nothing when &lt;b&gt;optram=1&lt;/b&gt;. You can see more examples of this in any module from &lt;i&gt;src/modules&lt;/i&gt;, and you're encouraged to do so,
+  as this is only a very basic example; &lt;i&gt;src/modules&lt;/i&gt; contains real life examples that can serve as a good basis for a new module.&lt;/p&gt;
+&lt;p&gt;As you know by now, rotables can have metatables, and also you can set a rotable as a metatable for a regular table. If a rotable must have a 
+  metatable, it needs a &quot;__metatable&quot; field to point to its metatable (which is also a rotable, not necessarily another rotable) and the usual 
+  metatable functions. For example, let's make our &lt;b&gt;mod&lt;/b&gt; rotable its own metatable and declare an &lt;b&gt;__index&lt;/b&gt; function. Moreover, let's do 
+  this for both &lt;b&gt;optram=0&lt;/b&gt; and &lt;b&gt;optram=1&lt;/b&gt;.&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;static int mod_mt_index( lua_State *L ) 
+{
+  return 0;
+}
+
+#define MIN_OPT_LEVEL  2 // the minimum optimization level at which we use rotables
+#include &quot;lrodefs.h&quot;
+const LUA_REG_TYPE mod_map[] =
+{
+  { LSTRKEY( &quot;f&quot; ), LFUNCVAL( f_implementation ) },
+&lt;span class=&quot;warning&quot;&gt;#if LUA_OPTIMIZE_MEMORY &gt; 0
+  { LSTRKEY( &quot;__metatable&quot; ), LROVAL( mod_map ) },
+#endif&lt;/span&gt;
+  { LSTRKEY( &quot;__index&quot; ), LFUNCVAL( mod_mt_index) },
+  { LNILKEY, LNILVAL };
+};
+	  
+LUALIB_API int luaopen_mod( lua_State *L )
+{
+#if LUA_OPTIMIZE_MEMORY &gt; 0
+  return 0;
+#else
+  luaL_register( L, &quot;mod&quot;, mod_map );
+	      
+  &lt;span class=&quot;warning&quot;&gt;// Set &quot;mod&quot; as its own metatable
+  lua_pushvalue( L, -1 );
+  lua_setmetatable( L, -2 );&lt;/span&gt;
+		    
+ return 1;
+ #endif
+}&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;If you want to register a module using a regular Lua table, but use lightfunctions instead of regular functions, use &lt;i&gt;luaL_register_light&lt;/i&gt; instead
+  of &lt;i&gt;luaL_register&lt;/i&gt; (same syntax). &lt;/p&gt;
+&lt;p&gt;More important things to keep in mind when working with LTR:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;currently, &lt;b&gt;MIN_OPT_LEVEL&lt;/b&gt; should be always set to 2&lt;/li&gt;
+  &lt;li&gt;you need a C99-compatible compiler to use LTR (because of the compile-time explicit union initialization that's needed to declare const rotables). 
+  Fortunately this isn't a issue right now, as all current eLua targets use GCC and GCC knows how to handle this.&lt;/li&gt;
+  &lt;li&gt;your linker command file should export two symbols: &lt;b&gt;stext&lt;/b&gt; and &lt;b&gt;etext&lt;/b&gt;. They should be declared before and after the .rodata* section 
+  placement (generally you'd declare stext at the beginning of .text definition and etext and the end of .text definition, see for example 
+  &lt;i&gt;src/lua/at91sam7x256/flash256.lds&lt;/i&gt;). These are needed by the patch to differentiate between a regular table and a rotable (although this is likely
+  to change in a future version of the patch.&lt;/li&gt;
+  &lt;li&gt;&lt;span class=&quot;warning&quot;&gt;remember to declare all you rotable's definition array as 'const'!!&lt;/span&gt; Forgetting to do so will not only increase 
+  memory usage, it will also make the patch not functional, because of the way it recognizes rotables (see above).&lt;/li&gt;
+&lt;/ul&gt;
+&lt;a name=&quot;config&quot; /&gt;&lt;h2&gt;LTR and module configuration at build time&lt;/h2&gt;
+&lt;p&gt;With unpatched Lua, you can specify what modules to be part of the Lua image by modifying &lt;i&gt;src/lua/linit.c&lt;/i&gt;. In the particular case of &lt;b&gt;eLua&lt;/b&gt;
+  one had to declare a list of the modules that must be compiled in &lt;i&gt;src/platform/&lt;name&gt;/platform_conf.h&lt;/i&gt; like this:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;#define LUA_PLATFORM_LIBS\
+  { AUXLIB_PIO, luaopen_pio },\
+  { AUXLIB_TMR, luaopen_tmr },\
+  { AUXLIB_PD, luaopen_pd },\
+  { AUXLIB_UART, luaopen_uart },\
+  { AUXLIB_TERM, luaopen_term },\
+  { AUXLIB_PWM, luaopen_pwm },\
+  { AUXLIB_PACK, luaopen_pack },\
+  { AUXLIB_BIT, luaopen_bit },\
+  { LUA_MATHLIBNAME, luaopen_math }
+&lt;/code&gt;&lt;/pre&gt;
+  &lt;p&gt;Things are a bit more complex with LTR, but not by much. The list of modules that must be compiled is declared via a preprocessor macro in 
+  &lt;i&gt;src/platform/&lt;name&gt;/platform_conf.h&lt;/i&gt; and it looks like this:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;#define LUA_PLATFORM_LIBS_ROM\
+  _ROM( AUXLIB_PIO, luaopen_pio, pio_map )\
+  _ROM( AUXLIB_TMR, luaopen_tmr, tmr_map )\
+  _ROM( AUXLIB_PD, luaopen_pd, pd_map )\
+  _ROM( AUXLIB_UART, luaopen_uart, uart_map )\
+  _ROM( AUXLIB_TERM, luaopen_term, term_map )\
+  _ROM( AUXLIB_PWM, luaopen_pwm, pwm_map )\
+  _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
+  _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
+  _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;(&lt;b&gt;IMPORTANT NOTE&lt;/b&gt;: the fact that there are no commas between two different _ROM declarations (as seen above) is NOT an error; 
+  on the contrary, this is very much intended. Try using commas and you'll get in trouble very soon :) ).&lt;/p&gt;
+&lt;p&gt;Note the 3rd parameter of the &lt;b&gt;_ROM&lt;/b&gt; macro, which is the name of the definition array for the (ro)table. That's it. The code in linit.c will take 
+  care of everything else, including initializing the list of modules in LUA_PLATFORM_LIBS_ROM with regular tables instead of rotables at &lt;b&gt;optram=0&lt;/b&gt; 
+  (to maintain compatilibity with regular Lua). You can also have a list of modules that you want to use with regular tables no matter what the 
+  optimization level is. In that case, list it in the &lt;b&gt;LUA_PLATFORM_LIBS_REG&lt;/b&gt; macro via the old syntax for &lt;b&gt;LUA_PLATFORM_LIBS&lt;/b&gt;, as shown
+  above (the regular Lua syntax for defining a module to be registered with luaL_register). If you want this module to use lightfunctions instead of 
+  regular functions (at &lt;b&gt;optram=1&lt;/b&gt;), use &lt;i&gt;luaL_register_light&lt;/i&gt; instead of &lt;i&gt;luaL_register&lt;/i&gt;.
+&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/arch_newport.html
===================================================================
--- tags/pre0.6/doc/pt/arch_newport.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_newport.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,137 @@
+$$HEADER$$
+&lt;h3&gt;Porting eLua&lt;/h3&gt;
+&lt;p&gt;So, you realized how cool &lt;b&gt;eLua&lt;/b&gt; is :), and you'd like to give it a try. Unfortunately, &lt;b&gt;eLua&lt;/b&gt; doesn't have a port on your CPU or board of choice.
+  The solution is simple: write the port yourself. This might seem as a daunting task at first, but it's actually easier than it sounds. &lt;b&gt;eLua&lt;/b&gt; was
+  designed to make the task of implementing new ports as easy and intuitive as possible. This section gives an overview of the porting process. It's not
+  an exhaustive guide, but it should be enough to point you in the right direction. Before diving into this, it's highly recommended that you take a look
+  at the &lt;a href=&quot;elua_arch.html&quot;&gt;eLua architecture page&lt;/a&gt;. &lt;/p&gt;
+&lt;h3&gt;Prerequisites&lt;/h3&gt;
+&lt;p&gt;Before starting to work on the port, make sure that:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;your CPU has enough resources to run &lt;b&gt;eLua&lt;/b&gt;. A very rough estimation (based on ARM Thumb code only) is that you'd need at least 256k
+  of program memory and 32k of RAM for a complete &lt;b&gt;eLua&lt;/b&gt; image, and 128k of program memory for a basic image. It's possible to run &lt;b&gt;eLua&lt;/b&gt; in
+  less than 32k of RAM (especially when &lt;a href=&quot;arch_ltr.html&quot;&gt;LTR&lt;/a&gt; is enabled), but you'll probably run out of memory fast.
+  64k of RAM (or more) is recommended.&lt;/li&gt;
+  &lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;<A HREF="http://sourceware.org/newlib">http://sourceware.org/newlib</A>&quot;&gt;Newlib&lt;/a&gt; is available for your CPU. &lt;b&gt;eLua&lt;/b&gt; depends on Newlib currently
+  (although this limitation will be eliminated in a future version), so if Newlib is not available for your CPU, you're out of luck. &lt;/li&gt;
+  &lt;li&gt;you have a C compiler for your target. Ideally you'd use GCC, but if this isn't possible other compilers might work as well. Keep in mind that
+  &lt;a href=&quot;arch_ltr.html&quot;&gt;LTR&lt;/a&gt; needs a C99 C compiler (or at least a partially C99 compliant C compiler than supports C99-style union initialization). 
+  &lt;/li&gt;
+  &lt;li&gt;you have a platform library (it usually comes from the CPU manufacturer) that you can use to implement (at least part of) the platform interface.
+  It's also highly recommended to gain at least a basic understanding of your platform, it will help a lot while writing the port.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;If all of the above are true, you should continue reading this document to bring your port to life. If not, we're sorry, but (at least at this point)
+&lt;b&gt;eLua&lt;/b&gt; can't be ported to your CPU. If, on the other hand, you're good to go, please take a bit of time and read 
+  &lt;a href=&quot;arch_overview.html#platforms&quot;&gt;this section&lt;/a&gt; first, as it details the structure of a port and might simplify your work quite a bit.&lt;/p&gt;
+&lt;a name=&quot;newboard&quot; /&gt;&lt;h3&gt;Adding a new board&lt;/h3&gt;
+&lt;p&gt;If all you need is to add a new board that uses a CPU already supported by &lt;b&gt;eLua&lt;/b&gt; (check &lt;a href=&quot;status.html&quot;&gt;here&lt;/a&gt; for a complete list), it's
+fairly easy to accomplish this:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;choose a good name for your board :)&lt;/li&gt;
+  &lt;li&gt;edit &lt;b&gt;SConstruct&lt;/b&gt; and add your board to the &lt;b&gt;board_list&lt;/b&gt; dictionary, specifying its CPU. A part of the definition of &lt;b&gt;board_list&lt;/b&gt; is given below:
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;# List of board/CPU combinations
+board_list = { 'SAM7-EX256' : [ 'AT91SAM7X256', 'AT91SAM7X512' ],
+               'EK-LM3S8962' : [ 'LM3S8962' ],
+               'EK-LM3S6965' : [ 'LM3S6965' ],
+               ..............................
+            }&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+  &lt;/li&gt;
+  &lt;li&gt;also edit the &lt;b&gt;file_list&lt;/b&gt; dictionary in &lt;b&gt;SConstruct&lt;/b&gt; to specify the list of ROMFS files that will be compiled for your board (see the 
+  &lt;a href=&quot;arch_romfs.html&quot;&gt;ROMFS section&lt;/a&gt; for details). A part of the definition of &lt;b&gt;file_list&lt;/b&gt; is given below:
+&lt;pre&gt;&lt;code&gt;# List of board/romfs data combinations
+file_list = { 'SAM7-EX256' : [ 'bisect', 'hangman' , 'led', 'piano', 'hello', 'info', 'morse' ],
+              'EK-LM3S8962' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
+              'EK-LM3S6965' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
+              ...............................
+            }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+  &lt;li&gt;if your board has external memory, you'll probably want to use the &quot;multiple&quot; allocator by default to take advantage of that (see &lt;a href=&quot;building.html&quot;&gt;building&lt;/a&gt;)
+  for details. If so, you need to modify the CPU/allocator mapping code from &lt;b&gt;SConstruct&lt;/b&gt;:
+&lt;pre&gt;&lt;code&gt;# CPU/allocator mapping (if allocator not specified)
+if allocator == '':
+  if &lt;b&gt;boardname == 'LPC-H2888'&lt;/b&gt; or &lt;b&gt;boardname == 'ATEVK1100'&lt;/b&gt;:
+    allocator = 'multiple'
+  else:
+    allocator = 'newlib'
+elif allocator not in [ 'newlib', 'multiple', 'simple' ]:
+  print &quot;Unknown allocator&quot;, allocator
+  print &quot;Allocator can be either 'newlib', 'multiple' or 'simple'&quot;
+  sys.exit( -1 )
+&lt;/code&gt;&lt;/pre&gt;
+  &lt;/li&gt;
+  &lt;li&gt;customize the &lt;b&gt;eLua&lt;/b&gt; image for this new board. You can use the variable &lt;b&gt;boardname&lt;/b&gt; in &lt;b&gt;conf.py&lt;/b&gt; to define new preprocessor macros specifically for your board
+  (that you can use later in &lt;b&gt;platform_conf.h&lt;/b&gt;, for example), or to include or exclude certain files from the build, or change the build flags and so on. An example taken from 
+  the &lt;b&gt;lm3s&lt;/b&gt; port is given below (part of &lt;b&gt;conf.py&lt;/b&gt;):
+&lt;pre&gt;&lt;code&gt;if boardname == 'EK-LM3S6965' or boardname == 'EK-LM3S8962':
+  specific_files = specific_files + &quot; rit128x96x4.c disp.c&quot;
+  cdefs = cdefs + &quot; -DENABLE_DISP&quot;
+
+# The default for the Eagle 100 board is to start the image at 0x2000,
+# so that the built in Ethernet boot loader can be used to upload it
+if boardname == 'EAGLE-100':
+  linkopts = &quot;-Wl,-Ttext,0x2000&quot;
+else:
+  linkopts = &quot;&quot;
+&lt;/code&gt;&lt;/pre&gt;
+&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;After you edit all the relevant source files, all you have to do is to execute &lt;i&gt;scons board=&lt;boardname&gt;&lt;/i&gt; and you'll have &lt;b&gt;eLua&lt;/b&gt; compiled for your board.&lt;/p&gt;
+&lt;a name=&quot;newcpu&quot; /&gt;&lt;h3&gt;Adding a new CPU&lt;/h3&gt;
+&lt;p&gt;If you want to add a new CPU to &lt;b&gt;eLua&lt;/b&gt; and the new CPU happens to be supported by a platform on which &lt;b&gt;eLua&lt;/b&gt; already runs (see &lt;a href=&quot;status.html&quot;&gt;here&lt;/a&gt; for a full
+list), your task is still quite easy. Follow the steps below:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;edit &lt;b&gt;SConstruct&lt;/b&gt; and add your new CPU to the &lt;b&gt;platform_list&lt;/b&gt; dictionary. Use the &quot;official&quot; name of the CPU (as it appears in its datasheet). An example is given below:
+&lt;pre&gt;&lt;code&gt;# List of platform/CPU/toolchains combinations
+# The first toolchain in the toolchains list is the default one
+# (the one that will be used if none is specified)
+platform_list = {
+  'at91sam7x' : { 'cpus' : [ 'AT91SAM7X256', 'AT91SAM7X512' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
+  'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
+  'str9' : { 'cpus' : [ 'STR912FAW44' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
+  ..................
+}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+  &lt;li&gt;you also need to add a new board to &lt;b&gt;eLua&lt;/b&gt; (which makes sense, since you're most likely going to run &lt;b&gt;eLua&lt;/b&gt; on a board built around the CPU 
+  of your choice, not only on the CPU itself). So follow the instruction from the &lt;a href=&quot;arch_newport.html#newboard&quot;&gt;previous paragraph&lt;/a&gt; to add
+  your new board.&lt;/li&gt;
+  &lt;li&gt;customize the &lt;b&gt;eLua&lt;/b&gt; image for this new CPU. You can use the variable &lt;b&gt;cputype&lt;/b&gt; in &lt;b&gt;conf.py&lt;/b&gt; to define new preprocessor macros specifically for your CPU
+  (that you can use later in &lt;b&gt;platform_conf.h&lt;/b&gt;, for example), or to include or exclude certain files from the build, or change the build flags and so on. An example taken from 
+  the &lt;b&gt;at91sam7x&lt;/b&gt; port is given below (part of &lt;b&gt;conf.py&lt;/b&gt;):
+&lt;pre&gt;&lt;code&gt;if cputype == 'AT91SAM7X256':
+  ldscript = &quot;flash256.lds&quot;
+  cdefs = cdefs + &quot; -Dat91sam7x256&quot;
+elif cputype == 'AT91SAM7X512':
+  ldscript = &quot;flash512.lds&quot;
+  cdefs = cdefs + &quot; -Dat91sam7x512&quot;
+else:
+  print &quot;Invalid AT91SAM7X CPU %s&quot; % cputype
+  sys.exit( -1 ) &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;After you edit all the relevant source files, all you have to do is to execute &lt;i&gt;scons board=&lt;boardname&gt;&lt;/i&gt; and you'll have &lt;b&gt;eLua&lt;/b&gt; compiled for your board (and implicitly for
+  your new CPU).&lt;/p&gt;
+&lt;a name=&quot;newplatform&quot; /&gt;&lt;h3&gt;Adding a new platform&lt;/h3&gt;
+&lt;p&gt;If you want to add a new CPU to &lt;b&gt;eLua&lt;/b&gt; and the new CPU is not supported by a platform on which &lt;b&gt;eLua&lt;/b&gt; already runs (see &lt;a href=&quot;status.html&quot;&gt;here&lt;/a&gt; for a full list), you have to
+go the whole way and add a completely new platform to &lt;b&gt;eLua&lt;/b&gt;. This is certainly more difficult than the previous cases, but still not that hard. Remember to start small (implement only
+minimal support at first) and don't write everything from scratch, start from an already existing platform implementation and work your way up from there. The &lt;b&gt;i386&lt;/b&gt; port is the simplest, 
+but also a bit different from the embedded ports. Another port that is quite simple at this point is the &lt;b&gt;lpc2888&lt;/b&gt; port, you might take a look at that too. After you &quot;get a feeling&quot; of
+how a port should look like, and after you read about the architecture of &lt;b&gt;eLua&lt;/b&gt; and the structure of a port &lt;a href=&quot;arch_overview.html&quot;&gt;here&lt;/a&gt;, follow the steps below:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;choose the name of your new platform. It should be an easy, descriptive name. For example, all the CPUs from the LM3S series are grouped inside a platform called &lt;b&gt;lm3s&lt;/b&gt;.&lt;/li&gt;
+  &lt;li&gt;create the &lt;i&gt;src/platform/&lt;name&gt;&lt;/i&gt; directory, and add all your platform-specific files here. Check &lt;a href=&quot;arch_overview.html#platforms&quot;&gt;here&lt;/a&gt; for specific details.&lt;/li&gt;
+  &lt;li&gt;use the instructions from the &lt;a href=&quot;arch_newport.html#newcpu&quot;&gt;previous paragraph&lt;/a&gt; to add your new CPU and board to &lt;b&gt;eLua&lt;/b&gt;.&lt;/li&gt;
+  &lt;li&gt;implement as much as you need from the &lt;a href=&quot;arch_platform.html&quot;&gt;platform interface&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;if your new platform uses a toolchain that wasn't previously configured in &lt;b&gt;eLua&lt;/b&gt;, add it now (see &lt;a href=&quot;toolchains.html&quot;&gt;here&lt;/a&gt; for more details about toolchains).&lt;/li&gt;
+  &lt;li&gt;let &lt;b&gt;SConstruct&lt;/b&gt; know about your new platform by modifying the &lt;b&gt;platform_list&lt;/b&gt; variable to add information about the CPU(s) available for your platform and about its toolchains. 
+An example is given below:
+&lt;pre&gt;&lt;code&gt;# List of platform/CPU/toolchains combinations
+# The first toolchain in the toolchains list is the default one
+# (the one that will be used if none is specified)
+platform_list = {
+  'at91sam7x' : { 'cpus' : [ 'AT91SAM7X256', 'AT91SAM7X512' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
+  'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
+  'str9' : { 'cpus' : [ 'STR912FAW44' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
+  ..................
+}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;After you edit all the relevant source files, all you have to do is to execute &lt;i&gt;scons board=&lt;boardname&gt;&lt;/i&gt; and you'll have &lt;b&gt;eLua&lt;/b&gt; compiled for your board (and implicitly for
+  your new CPU).&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/arch_overview.html
===================================================================
--- tags/pre0.6/doc/pt/arch_overview.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_overview.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,208 @@
+$$HEADER$$
+&lt;a name=&quot;structure&quot; /&gt;&lt;h3&gt;eLua architecture overview&lt;/h3&gt;
+&lt;p&gt;The overall logical structure of &lt;b&gt;eLua&lt;/b&gt; is shown in the image below:&lt;/p&gt;
+&lt;p style=&quot;text-align: center; valign:middle;&quot;&gt;&lt;img src=&quot;images/elua_arch.png&quot; style=&quot;border: 0;&quot; alt=&quot;eLua architecture&quot;&gt;&lt;/img&gt;&lt;/p&gt;
+&lt;p&gt;&lt;b&gt;eLua&lt;/b&gt; uses the notion of &lt;b&gt;platform&lt;/b&gt; to denote a group of &lt;b&gt;CPUs&lt;/b&gt; that share the same core structure, although their specific silicon
+  implementation might differ in terms of intergrated peripherals, internal memory and other such attributes. An &lt;b&gt;eLua&lt;/b&gt; port implements one or 
+  more CPUs from a given platform. For example, the &lt;b&gt;lm3s port&lt;/b&gt; of &lt;b&gt;eLua&lt;/b&gt; runs on LM3S8962, LM3S6965 and LM3S6918 CPUs, all of them part of the 
+  &lt;b&gt;lm3s&lt;/b&gt; platform. Refer to &lt;a href=&quot;status.html&quot;&gt;the status page&lt;/a&gt; for a full list of platforms and CPUs on which &lt;b&gt;eLua&lt;/b&gt; runs.&lt;/p&gt;
+&lt;p&gt;As can be seen from this image, &lt;b&gt;eLua&lt;/b&gt; tries to be as portable as possible between different platforms by using a few simple design
+rules:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;all code that is platform-independent is &lt;b&gt;common code&lt;/b&gt; and it should be written in ANSI C as much as possible, this makes it highly portable
+  among different architectures and compilers, just like Lua itself. &lt;/li&gt;
+  &lt;li&gt;all the code that can't possibly be generic (mostly peripheral and CPU specific code) must still be made as portable as possible by using a common
+  interface that must be implemented by all platforms on which &lt;b&gt;eLua&lt;/b&gt; runs. This interface is called &lt;b&gt;platform interface&lt;/b&gt; and is discussed in
+  detail &lt;a href=&quot;arch_platform.html&quot;&gt;here&lt;/a&gt; (but please see also &lt;a href=&quot;arch_overview.html#platform&quot;&gt;&quot;The platform interface&quot;&lt;/a&gt; 
+  paragraph in this document).&lt;/li&gt;
+  &lt;li&gt;all platforms (and their peripherals) are not created equal and vary greatly in capabilities. As already mentioned, the platform interface tries
+  to group only common attributes of different platforms. If one needs to access the specific functionality on a given platform (like the loopback support
+  mentioned before) it can do so by using a &lt;b&gt;platform module&lt;/b&gt;. These are of course platform specific, and their goal is to fill the gap between the
+  platform interface and the full set of features provided by a platform.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;a name=&quot;common&quot; /&gt;&lt;h3&gt;Common (generic) code&lt;/h3&gt;
+&lt;p&gt;The following gives an incomplete set of items that can be classified as &lt;b&gt;common code&lt;/b&gt;:&lt;/p&gt;
+  &lt;ul&gt;
+    &lt;li&gt;the Lua code itself (obviously) plus the &lt;a href=&quot;arch_ltr.html&quot;&gt;LTR patch&lt;/a&gt;.&lt;/li&gt;
+    &lt;li&gt;all the &lt;b&gt;components&lt;/b&gt; in &lt;b&gt;eLua&lt;/b&gt; (like the ROM file system, the XMODEM receive code, the &lt;b&gt;eLua&lt;/b&gt; shell, the TCP/IP stack and others).
+    &lt;/li&gt;
+    &lt;li&gt;all the &lt;b&gt;generic modules&lt;/b&gt;, which are Lua modules used to expose the functionality of the platform to Lua.&lt;/li&gt;
+    &lt;li&gt;generic &lt;b&gt;peripheral support code&lt;/b&gt;, like the ADC support code (&lt;i&gt;src/common/elua_adc.c&lt;/i&gt;) that is &lt;b&gt;independent&lt;/b&gt; of the actual ADC
+      hardware.&lt;/li&gt;
+    &lt;li&gt;libc code (for example allocators and Newlib stubs).&lt;/li&gt;
+  &lt;/ul&gt;
+&lt;p&gt;This should give you a pretty good idea about what &quot;common code&quot; means in this context. Note that the generic code layer should be as &quot;greedy&quot; as 
+possible; that is, it should absorb as much common code as possible. For example:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;if you want to add a new file system to &lt;b&gt;eLua&lt;/b&gt;, this should definitely be generic code. It's likely that this kind of code will have
+  dependencies related to the physical medium on which this file system resides. If you're lucky, you can solve these dependencies using only the functions 
+  defined in the &lt;a href=&quot;elua_platform.html&quot;&gt;platform interface&lt;/a&gt; (this would make sense if you're using a SD card controlled over SPI, since the 
+  platform interface already has a SPI layer). If not, you should group the platform specific functions in a separate interface that will be implemented by
+  all platform that want to use your new file system. This gives the code maximum portability.&lt;/li&gt;
+  &lt;li&gt;if you want to add a driver for a specific ADC chip that works over SPI, the same observations apply: write it as common code as much as you can,
+  and use the &lt;a href=&quot;elua_platform.html&quot;&gt;platform interface&lt;/a&gt; for the specific SPI functions you need.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;When designing and implementing a new component, keep in mind other &lt;b&gt;eLua&lt;/b&gt; design goal: &lt;b&gt;flexibility&lt;/b&gt;. The user should be able to 
+  select which components are part of its &lt;b&gt;eLua&lt;/b&gt; binary image (as described &lt;a href=&quot;building.html&quot;&gt;here&lt;/a&gt;), and the implementation should take
+  this into consideration. The same thing holds for the generic modules: the user must have a way to choose the set of modules he needs.&lt;/p&gt;
+&lt;p&gt;For maximum portability, make your code work in a variety of scenarios if possible (and if that makes sense from a practical point of view). 
+  Take for example the code for stdio/stdout/stderr handling (&lt;i&gt;src/newlib/genstd.c&lt;/i&gt;): it acknowledges the fact that a terminal can be implemented 
+  over a large variety of physical transports (RS-232 for PC, SPI for a separate LCD/keyboard board, a radio link and so on) so it uses pointers for its 
+  send/receive functions (see &lt;a href=&quot;arch_con_term.html&quot;&gt;this link&lt;/a&gt; for more details). The impact on speed and resource consumption is minimum, but 
+  it matters a lot in the portability department.&lt;/p&gt;
+&lt;a name=&quot;platform&quot; /&gt;&lt;h3&gt;Platform interface&lt;/h3&gt;
+&lt;p&gt;Used properly, the platform interface allows writing extremely portable code over a large variety of different platforms, both from C and from Lua. 
+  An important property of the platform interface is that it tries to group only &lt;b&gt;common&lt;/b&gt; attributes of different platforms (as much as possible). 
+  For example, if a platform supported by &lt;b&gt;eLua&lt;/b&gt; has an UART that can work in loopback mode, but the others don't, loopback support won't be included 
+  in the platform interface.&lt;/p&gt;
+&lt;p&gt;A special emphasis on the platform interface usage: remember to use it not only for Lua, but also for C. The platform interface is mainly used by the 
+  generic modules to allow Lua code to access platform peripherals, but this isn't its only use. It can (and it should) also be used by C code that wants 
+  to implement a generic module and neeeds access to peripherals. An example was given in the previous section: implementing a new file system.&lt;/p&gt;
+&lt;p&gt;The platform interface definition is always in the &lt;i&gt;inc/platform.h&lt;/i&gt; header file. For a full description of its functions, check
+  &lt;a href=&quot;arch_platform.html&quot;&gt;the platform interface documentation.&lt;/a&gt;&lt;/p&gt;
+&lt;a name=&quot;platforms&quot; /&gt;&lt;h3&gt;Platforms and ports&lt;/h3&gt;
+&lt;p&gt;All the platforms that run &lt;b&gt;eLua&lt;/b&gt; (and that implement the platform interface) are implemened in this conceptual layer. A &lt;b&gt;port&lt;/b&gt; is a full
+  &lt;b&gt;eLua&lt;/b&gt; implementation on a given platform. The two terms can generally be used interchangeably.&lt;/p&gt;
+&lt;p&gt;A port can (and generally will) contain specific peripheral drivers, many times taken directly from the platform's CPU support
+   package. These drivers are used to implement the platform interface. Note that:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;a port isn't required to implement &lt;b&gt;all&lt;/b&gt; the platform interface functions, just the ones it needs. As explained 
+  &lt;a href=&quot;building.html&quot;&gt;here&lt;/a&gt;, the user must have full control over what's getting built into this &lt;b&gt;eLua&lt;/b&gt; image. If you don't need the SPI
+  module, for example, you don't need to implement its platform interface.&lt;/li&gt;
+  &lt;li&gt;a part of the platform interface is implemented (at least partially) in a file that is common for all the platforms (&lt;i&gt;src/common.c&lt;/i&gt;). It
+  eases the implmentation of some modules (such as the timer module) and also implements common features that are tied to the platform interface,
+  but have a common behaviour on all platforms (for example virtual timers, see &lt;a href=&quot;&quot;&gt;##here&lt;/a&gt; for details). You probably won't need to modify 
+  if you're writing platform specific code, but it's best to keep in mind what it does.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;A platform implementation might also contain one or more &lt;b&gt;platform dependent modules&lt;/b&gt;. As already exaplained, their purpose is to allow Lua
+  to use the full potential of the platform peripherals, not only the functionality covered by the platform interface, as well as functionality that
+  is so specific to the platform that it's not even covered by the platform interface. By convention, all the platform dependent modules should be 
+  grouped inside a single module that has the same name as the platform itself. If the platform dependent module augments the functionality of a 
+  module already found in the platform interface, it should have the same name, otherwise it should be given a different, but meaningful name. For example:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;if implementing new functionality on the UART module of the LM3S platform, the corresponding module should be called &lt;b&gt;lm3s.uart&lt;/b&gt;.&lt;/li&gt;
+  &lt;li&gt;if implementing a peripheral driver that for some reason should be specific to the platform on the LPC2888 platform, for example its dual audio
+  DAC, give it a meaningful name, for example &lt;b&gt;lpc288x.audiodac&lt;/b&gt;.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;h2&gt;Structure of a port&lt;/h2&gt;
+&lt;p&gt;All the code for platform &lt;i&gt;name&lt;/i&gt; (including peripheral drivers) must reside in a directory called &lt;i&gt;src/platform/&lt;name&gt;&lt;/i&gt; (for example
+&lt;i&gt;src/platform/lm3s&lt;/i&gt; for the &lt;i&gt;lm3s&lt;/i&gt; platform). Each such platform-specific subdirectory must contain at least these files:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;&lt;b&gt;type.h&lt;/b&gt;: this defines the &quot;specific data types&quot;, which are integer types with a specific size (see &lt;a href=&quot;arch_coding.html&quot;&gt;coding style&lt;/a&gt; 
+      for details. An example from the &lt;b&gt;i386&lt;/b&gt; platform:
+&lt;pre&gt;&lt;code&gt;typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned long u32;
+typedef signed long s32;
+typedef unsigned long long u64;
+typedef signed long long s64;&lt;/code&gt;&lt;/pre&gt;
+  &lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;conf.py&lt;/b&gt;: this is the platform specific build configuration file, used by the &lt;a href=&quot;building.html&quot;&gt;build system&lt;/a&gt; for a number of purposes:
+&lt;ul&gt;
+    &lt;li&gt;to get the list of platform-specific files that will be compiled in the &lt;b&gt;eLua&lt;/b&gt; image. They are exported in the &lt;i&gt;specific_files&lt;/i&gt; string,
+      separated by spaces, and must be prepended with the relative path to the platform subdirectory. An example from the &lt;b&gt;i386&lt;/b&gt; platform:
+&lt;pre&gt;&lt;code&gt;specific_files = &quot;boot.s common.c descriptor_tables.c gdt.s interrupt.s isr.c kb.c  monitor.c timer.c platform.c&quot;
+# Prepend with path
+specific_files = &quot; &quot;.join( [ &quot;src/platform/%s/%s&quot; % ( platform, f ) for f in specific_files.split() ] )&lt;/code&gt;&lt;/pre&gt;
+    &lt;/li&gt;
+    &lt;li&gt;to get the full command lines of the different toolchain utilities (linker, assembler, compiler) used to compile &lt;b&gt;eLua&lt;/b&gt;. They must be declared
+      inside the &lt;i&gt;tools&lt;/i&gt; variable, in a separate dictinoary which key is the same as the platform name, and with specific names for each tool in turn:
+      &lt;b&gt;cccom&lt;/b&gt; for the compiler, &lt;b&gt;linkcom&lt;/b&gt; for the linker and &lt;b&gt;ascom&lt;/b&gt; for the assembler.
+      For example, this is how the &lt;i&gt;tools&lt;/i&gt; variable is defined for the &lt;b&gt;i386&lt;/b&gt; platform:
+ &lt;pre&gt;&lt;code&gt;# Toolset data
+ tools[ 'i386' ] = {}
+ tools[ 'i386' ][ 'cccom' ] = &quot;%s %s %s -march=i386 -mfpmath=387 -m32 -ffunction-sections -fdata-sections -fno-builtin -fno-stack-protector %s -Wall -c $SOURCE -o $TARGET&quot; % ( toolset[ 'compile' ], opt, local_include, cdefs )
+ tools[ 'i386' ][ 'linkcom' ] = &quot;%s -nostartfiles -nostdlib -march=i386 -mfpmath=387 -m32 -T %s -Wl,--gc-sections -Wl,-e,start -Wl,--allow-multiple-definition -o $TARGET $SOURCES -lc -lgcc -lm %s&quot; % ( toolset[ 'compile' ], ldscript, local_libs )
+ tools[ 'i386' ][ 'ascom' ] = &quot;%s -felf $SOURCE&quot; % toolset[ 'asm' ]&lt;/code&gt;&lt;/pre&gt;
+  Note how the definition of &lt;b&gt;tools&lt;/b&gt; uses the definition of &lt;b&gt;toolset&lt;/b&gt;, a dictionary with the names of the tools in the current toolchain. This
+  is also part of the &lt;b&gt;eLua&lt;/b&gt; build system and is documented &lt;a href=&quot;toolchains.html&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;to get the name of a &lt;b&gt;programmning function&lt;/b&gt; which receives the name of the &lt;b&gt;eLua&lt;/b&gt; executable file (the result of the build step) and 
+  produces a file suitable for programming on the corresponding hardware platform. The name of this function should also be set in the &lt;i&gt;tools&lt;/i&gt; 
+  dictionary, as shown below (example taken from the &lt;b&gt;str7&lt;/b&gt; platform):
+ &lt;pre&gt;&lt;code&gt;# Programming function for STR7
+ def progfunc_str7( target, source, env ):
+   outname = output + &quot;.elf&quot;
+   os.system( &quot;%s %s&quot; % ( toolset[ 'size' ], outname ) )
+   print &quot;Generating binary image...&quot;
+   os.system( &quot;%s -O binary %s %s.bin&quot; % ( toolset[ 'bin' ], outname, output ) )
+           
+   tools[ 'str7' ][ 'progfunc' ] = progfunc_str7&lt;/code&gt;&lt;/pre&gt;
+  Note, once again, how this function uses the same &lt;i&gt;toolset&lt;/i&gt; variable mentioned in the previous paragraph.
+  &lt;/li&gt;
+  &lt;/ul&gt;
+  &lt;/li&gt;
+&lt;li&gt;&lt;b&gt;stacks.h&lt;/b&gt;: by convention, the stack(s) size(s) used in the system are declared in this file. An example taken from the &lt;b&gt;at91sam7x&lt;/b&gt; platform is given below:
+&lt;pre&gt;&lt;code&gt;#define  STACK_SIZE_USR   2048
+#define  STACK_SIZE_IRQ   64
+#define  STACK_SIZE_TOTAL ( STACK_SIZE_USR + STACK_SIZE_IRQ )&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;platform.c&lt;/b&gt;: by convention, the &lt;a href=&quot;arch_platform.html&quot;&gt;platform interface&lt;/a&gt; is implemented in this file. It also contains the platform-specific
+  initialization function (&lt;i&gt;platform_init&lt;/i&gt;, see the description of the &lt;a href=&quot;elua_arch.html#boot&quot;&gt;eLua boot process&lt;/a&gt; for details).&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;platform_conf.h&lt;/b&gt;: this is the platform configuration file, used to give information about both the platform itself and the build configuration for the 
+  platform. This is what you can set inside &lt;b&gt;platform_conf.h&lt;/b&gt;:
+&lt;ul&gt;
+  &lt;li&gt;the list of &lt;b&gt;components&lt;/b&gt; that will be part of the build (see &lt;a href=&quot;building.html&quot;&gt;building eLua&lt;/a&gt; for details).&lt;/li&gt;
+  &lt;li&gt;the list of &lt;b&gt;modules&lt;/b&gt; that will be part of the build (see &lt;a href=&quot;building.html&quot;&gt;building eLua&lt;/a&gt; and &lt;a href=&quot;arch_ltr.html#config&quot;&gt;LTR configuration&lt;/a&gt;
+     for details.&lt;/li&gt;
+  &lt;li&gt;the &lt;b&gt;static configuration data&lt;/b&gt; (see &lt;a href=&quot;building.html&quot;&gt;building eLua&lt;/a&gt; for details).&lt;/li&gt;
+  &lt;li&gt;the &lt;b&gt;number of peripherals&lt;/b&gt; on your CPU. See an example below (taken from &lt;b&gt;lm3s&lt;/b&gt;) that also shows how to differentiate between different CPUs that belong to the same 
+  platform; the &lt;b&gt;FORxxxx&lt;/b&gt; macros are defined in &lt;b&gt;conf.py&lt;/b&gt;):
+&lt;pre&gt;&lt;code&gt;// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               7
+#define NUM_SPI               1
+#ifdef FORLM3S6965
+  #define NUM_UART            3
+#else
+  #define NUM_UART            2
+#endif
+#define NUM_TIMER             4
+#ifndef FORLM3S6918
+  #define NUM_PWM             6
+#else
+  #define NUM_PWM             0
+#endif  
+#define NUM_ADC               4&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;specific peripheral configuration&lt;/b&gt;: this includes (but it not limited to) enabling buffering on UART, enabling and setting up virtual timers, setting PIO configuration and so on.
+  All these parameters are described in detail in the &lt;a href=&quot;arch_platform.html&quot;&gt;platform interface section&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;memory configuration&lt;/b&gt;: describes the regions of free RAM in the system, which will be later used by the standard system allocator (malloc/realloc/free). Two macros
+  (&lt;b&gt;MEM_START_ADDRESS&lt;/b&gt; and &lt;b&gt;MEM_END_ADDRESS&lt;/b&gt;) define two arrays with the beginning and the end of all the free RAM memory in the system. If your board has external RAM memory, you 
+  should define it here. If not, you can only use the internal memory, and you'll generally need to use the linker-defined symbol &lt;b&gt;end&lt;/b&gt; to find out where your free memory starts. Following 
+  is an example from the &lt;b&gt;ATEVK1100&lt;/b&gt; (AVR32) board that has both on-chip and external RAM:
+&lt;pre&gt;&lt;code&gt;// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define MEM_START_ADDRESS     { ( void* )end, ( void* )SDRAM }
+#define MEM_END_ADDRESS       { ( void* )( 0x10000 - STACK_SIZE_TOTAL - 1 ), ( void* )( SDRAM + SDRAM_SIZE - 1 ) }
+&lt;/code&gt;&lt;/pre&gt;
+  &lt;/li&gt;
+&lt;/ul&gt;
+  If you want to take a look at a real life example of a &lt;b&gt;platform_conf.h&lt;/b&gt; file, see for example &lt;i&gt;src/platform/lm3s/platform_conf.h&lt;/i&gt;.
+&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;networking configuration&lt;/b&gt;: if you need TCP/IP on your board, you need to add networking support to &lt;b&gt;eLua&lt;/b&gt; (see &lt;a href=&quot;building.html&quot;&gt;
+  building&lt;/a&gt; for a list of configuration options related to TCP/IP). You also need to have another file, called &lt;b&gt;uip-conf.h&lt;/b&gt; that configures uIP
+  (the TCP/IP stack in &lt;b&gt;eLua&lt;/b&gt;) for your specific architecture. See &lt;a href=&quot;arch_tcpip.html&quot;&gt;TCP/IP in eLua&lt;/a&gt; for details.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;Besides the required files, the most common scenario is to include other platform specific files in your port:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;&lt;b&gt;a &quot;startup sequence&quot;&lt;/b&gt;, generally written in assembler, that does very low level
+  intialization, sets the stack pointer, zeroes the BSS section, copies ROM to 
+  RAM for the DATA section, and then jumps to main.&lt;/li&gt;
+  &lt;li&gt;a &lt;b&gt;linker command file&lt;/b&gt;.&lt;/li&gt;
+  &lt;li&gt;the &lt;b&gt;CPU support package&lt;/b&gt; generally comes from the CPU manufacturer, and includes code
+  for accessing peripherals, configuring the core, setting up interrupts and so on.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;a name=&quot;boot&quot; /&gt;&lt;h3&gt;eLua boot process&lt;/h3&gt;
+&lt;p&gt;This is what happens when you power up your &lt;b&gt;eLua&lt;/b&gt; board:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;the platform initialization code is executed. This is the code that does very low level platform setup (if needed), copies ROM to RAM, zeroes out
+  the BSS section, sets up the stack pointer and jumps to &lt;b&gt;main&lt;/b&gt;.&lt;/li&gt;
+  &lt;li&gt;the first thing &lt;b&gt;main&lt;/b&gt; does is call the platform specific initialization function (&lt;b&gt;platform_init&lt;/b&gt;). &lt;b&gt;platform_init&lt;/b&gt; must fully
+  initialize the platform and return a result to main, that can be either &lt;b&gt;PLATFORM_OK&lt;/b&gt; if the initialization succeded or &lt;b&gt;PLATFORM_ERR&lt;/b&gt;
+  otherwise. If &lt;b&gt;PLATFORM_ERR&lt;/b&gt; is returned, &lt;b&gt;main&lt;/b&gt; blocks immediately in an infinite loop.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;main&lt;/b&gt; then initializes the rest of the system: the ROM file system, XMODEM, and term.&lt;/li&gt;
+  &lt;li&gt;if &lt;b&gt;/rom/autorun.lua&lt;/b&gt; (which is a file called &lt;b&gt;autorun.lua&lt;/b&gt; in the &lt;a href=&quot;arch_romfs.html&quot;&gt;ROM file system&lt;/a&gt;) is found, it is
+  executed. If it returns after execution, or if it isn't found, the boot process continues with the next step.&lt;/li&gt;
+  &lt;li&gt;if the &lt;a href=&quot;using.html#shell&quot;&gt;shell&lt;/a&gt; was compiled in the image, it is started, otherwise a standard Lua interpreter is started.&lt;/li&gt;
+&lt;/ol&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/arch_platform.html
===================================================================
--- tags/pre0.6/doc/pt/arch_platform.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_platform.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,17 @@
+$$HEADER$$
+&lt;h3&gt;The platform interface&lt;/h3&gt;
+&lt;p&gt;The platform interface is the part of &lt;b&gt;eLua&lt;/b&gt; that makes it easily portable between different hardware platforms by grouping the common elements
+  of all platforms supported by &lt;b&gt;eLua&lt;/b&gt; in a common interface. For more details about the platform interface and the overall structure of 
+  &lt;b&gt;eLua&lt;/b&gt; in general, check &lt;a href=&quot;arch_overview.html&quot;&gt;this link&lt;/a&gt;.&lt;/p&gt;
+  &lt;p&gt;The platform interface is defined in the &lt;i&gt;inc/platform.h&lt;/i&gt; header file from the &lt;b&gt;eLua&lt;/b&gt; source distribution. It is a collection of various 
+  components (UART, SPI, timers ...), each of them is detailed in the next subsections. Each such component has an &lt;b&gt;id&lt;/b&gt; which is a number that 
+  identifies that component in &lt;b&gt;eLua&lt;/b&gt;. Generally, numbers are assigned to components in their &quot;natural&quot; order; for example, PORTA will have the id
+  0, PORTB will have 1 and so on. Similarly, the second SPI interface (SPI1) of the MCU will probably have an id equal to 1. However, this is not a strict
+  rule. The implementation of the platform interface might choose to expose only some of the peripherals (components) of the MCU, thus this rule might be 
+  broken. For example, if a board has 3 UARTs, but for some reason the second UART (UART1) is dedicated and can't be touched by &lt;b&gt;eLua&lt;/b&gt;, then UART0 will have the id 0 and UART2 will
+  have the id 1, so UART1 won't ever be accesible to the code. Such cases are documented in the &lt;a href=&quot;&quot;&gt;##specific usage notes&lt;/a&gt; section.&lt;/p&gt;
+  &lt;p&gt;With some exceptions (most notably the low-level support functions), the different modules supported by the platform interface are 
+  mirrored more or less accurately in separate Lua modules that can be used directly from &lt;b&gt;eLua&lt;/b&gt;. Check &lt;a href=&quot;&quot;&gt;the reference manual&lt;/a&gt; for a 
+  complete description of these modules.&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/arch_romfs.html
===================================================================
--- tags/pre0.6/doc/pt/arch_romfs.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_romfs.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,59 @@
+$$HEADER$$
+&lt;h3&gt;The ROM file system&lt;/h3&gt;
+&lt;p&gt;The ROM file system (ROMFS) is a small, read-only file system built for &lt;b&gt;eLua&lt;/b&gt;. It is integrated with the C
+  library, so you can use standard POSIX calls (fopen/fread/fwrite...) to access it. It is also accessible directly from Lua via the &lt;b&gt;io&lt;/b&gt; module.
+  The files in the file system are part of the &lt;b&gt;eLua&lt;/b&gt; binary image, thus they can't be modified after the image is
+  built. For the same reason, you can't add/delete files after the image is built. ROMFS doesn't support
+  sub-directories.&lt;/p&gt;
+&lt;p&gt;ROMFS is integrated with &lt;a href=&quot;building.html&quot;&gt;the build system&lt;/a&gt; for maximum flexibility on various platforms. As a result, you can select the ROMFS contents for each board on which 
+  &lt;b&gt;eLua&lt;/b&gt; runs. Moreover, you can specify what &lt;b&gt;applications&lt;/b&gt; (instead of individual files) go to the file system, as a real application might need more than a single Lua program 
+  to run (for example a HTTP page with all its dependencies).&lt;/p&gt;
+&lt;h2&gt;Using ROMFS&lt;/h2&gt;
+&lt;p&gt;To use ROMFS, you have to copy the required files to the &lt;i&gt;romfs/&lt;/i&gt; directory, before building eLua.
+ Keep in mind that the maximum file name of a ROMFS file is 14 characters, including the dot between the file 
+  name and its extension. Make sure that the file names from &lt;i&gt;romfs/&lt;/i&gt; follow this rule. Then edit the main build script (&lt;b&gt;SConstruct&lt;/b&gt;) to add a new application
+  or to modify an existing one.
+  All the applications that can be included in ROMFS are defined in the &lt;b&gt;romfs&lt;/b&gt; array in &lt;b&gt;SConstruct&lt;/b&gt;. Each application in the &lt;b&gt;romfs&lt;/b&gt; array lists its files, as shown below 
+  (note that &lt;b&gt;ltthpd&lt;/b&gt;, &lt;b&gt;tvbgone&lt;/b&gt; and &lt;b&gt;pong&lt;/b&gt; applications require more than one file in order to run):&lt;/p&gt;
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;romfs = { 
+    'bisect' : [ 'bisect.lua' ],
+    'hangman' : [ 'hangman.lua' ],
+    'lhttpd' : [ 'index.pht', 'lhttpd.lua', 'test.lua' ],
+    'pong' : [ 'pong.lua', 'LM3S.lua' ],
+    'led' : [ 'led.lua' ],
+    'piano' : [ 'piano.lua' ],
+    'pwmled' : [ 'pwmled.lua' ],
+    'tvbgone' : [ 'tvbgone.lua', 'codes.bin' ],
+    'hello' : [ 'hello.lua' ],
+    'info' : [ 'info.lua' ],
+    'morse' : [ 'morse.lua' ],
+    'dualpwm' : [ 'dualpwm.lua' ],
+    'adcscope' : [ 'adcscope.lua' ],
+    'life' : [ 'life.lua' ]
+}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;p&gt;After this, you need to decide the application-to-board mapping. This is defined in another array in &lt;b&gt;SConsctruct&lt;/b&gt;, named &lt;b&gt;file_list&lt;/b&gt;. The definition of this array is shown below,
+  the format is self-explanatory:&lt;/p&gt;
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;file_list = { 
+    'SAM7-EX256' : [ 'bisect', 'hangman' , 'led', 'piano', 'hello', 'info', 'morse' ],
+    'EK-LM3S8962' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
+    'EK-LM3S6965' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
+    'STR9-COMSTICK' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
+    'PC' : [ 'bisect', 'hello', 'info', 'life' ],
+    'LPC-H2888' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
+    'MOD711' : [ 'bisect', 'hangman', 'led', 'hello', 'info', 'dualpwm' ],
+    'STM3210E-EVAL' : [ 'bisect', 'hello', 'info' ],
+    'ATEVK1100' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
+    'ET-STM32' : [ 'hello', 'hangman', 'info', 'bisect' ],
+    'EAGLE-100' : [ 'bisect', 'hangman', 'lhttpd', 'led', 'hello', 'info' ]              
+}
+&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;p&gt;What's left to do is &lt;a href=&quot;building.html&quot;&gt;build eLua&lt;/a&gt;. As part of the build process, &lt;b&gt;mkfs.py&lt;/b&gt; will be called, which will read the contents of the &lt;i&gt;romfs/&lt;/i&gt; directory and 
+  output a C header file that contains a binary description of the file system. To use ROMFS from C code, whevener you want to access a file, prefix its name with &lt;b&gt;/rom/&lt;/b&gt;. For example, 
+  if you want to open the &lt;b&gt;a.txt&lt;/b&gt; file in ROMFS, you should call fopen like this:&lt;/p&gt;
+&lt;p&gt;&lt;pre&gt;&lt;code&gt;f = fopen( &quot;/rom/a.txt&quot;, &quot;rb&quot; )&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;p&gt;If you want to execute one file from the ROM file system with Lua, simply do this from the shell:&lt;/p&gt;
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;eLua# lua /rom/bisect.lua&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+&lt;p&gt;Or directly from Lua:&lt;/p&gt;
+ &lt;p&gt;&lt;pre&gt;&lt;code&gt;&gt; dofile &quot;/rom/bisect.lua&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/arch_tcpip.html
===================================================================
--- tags/pre0.6/doc/pt/arch_tcpip.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/arch_tcpip.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,90 @@
+$$HEADER$$
+&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;    
+&lt;h3&gt;TCP/IP in eLua &lt;span class=&quot;warning&quot;&gt;(WIP)&lt;/span&gt;&lt;/h3&gt;
+&lt;p&gt;&lt;b&gt;eLua&lt;/b&gt;'s TCP/IP support was designed with flexibility and ease of use in mind. It
+might not provide all the functions of a &quot;full-fledged&quot; TCP/IP stack, but it's 
+still fully functional, has a much smaller footprint and is probably easier to use than a &quot;regular&quot; (POSIX) TCP/IP
+stack. These are the services provided by the TCP/IP stack:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;a set of functions for network access (defined in inc/elua_net.h)&lt;/li&gt;
+  &lt;li&gt;a DHCP client&lt;/li&gt;
+  &lt;li&gt;a DNS resolver&lt;/li&gt;
+  &lt;li&gt;a module (&lt;a href=&quot;m_net.html&quot;&gt;net&lt;/a&gt;) which can be used from Lua to access the network functions&lt;/li&gt;
+  &lt;li&gt;a Telnet miniclient, which is used to support the eLua shell via TCP/IP instead of serial connections.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;br /&gt;
+
+&lt;h2&gt;TCP/IP configuration&lt;/h2&gt;
+&lt;p&gt;To configure the TCP/IP subsystem, &lt;i&gt;edit src/platform/&lt;name&gt;platform_conf.h&lt;/i&gt; and:&lt;/p&gt;
+&lt;ol&gt;
+&lt;li&gt;&lt;b&gt;#define BUILD_UIP&lt;/b&gt; to enable TCP/IP support&lt;/li&gt;
+&lt;li&gt;if you'll be using the DHCP client, just &lt;b&gt;#define BUILD_DHCPC&lt;/b&gt; to build the 
+   DHCP client. In any case, you must also define a static network configuration:
+
+&lt;p&gt;&lt;b&gt;#define ELUA_CONF_IPADDR0 ... ELUA_CONF_IPADDR3&lt;/b&gt; : the IP address&lt;br&gt;
+  &lt;b&gt;#define ELUA_CONF_NETMASK0 ... ELUA_CONF_NETMASK3&lt;/b&gt; : the network mask&lt;br&gt;
+  &lt;b&gt;#define ELUA_CONF_DEFGW0 ... ELUA_CONF_DEFGW3&lt;/b&gt; : the default gateway&lt;br&gt;
+  &lt;b&gt;#define ELUA_CONF_DNS0 ... ELUA_CONF_DNS3&lt;/b&gt; : the DNS server &lt;/p&gt;
+
+  &lt;p&gt;Note that you must define both &lt;b&gt;BUILD_DHCPC&lt;/b&gt; and the &lt;b&gt;ELUA_CONF_*&lt;/b&gt; macros. If the
+  DHCP client fails to obtain a valid IP address, the static configuration will 
+  be used instead. To use only the static configuration (and make the eLua image
+  size a bit smaller) don't define the BUILD_DHCPC client.&lt;/p&gt;&lt;/li&gt;
+
+&lt;li&gt;&lt;b&gt;#define BUILD_DNSM&lt;/b&gt; if you want support for the DNS server.&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;#define BUILD_CON_TCP&lt;/b&gt; if you want support for shell over telnet instead of
+   serial. Note that you must NOT define &lt;b&gt;BUILD_CON_GENERIC&lt;/b&gt; in this case (see
+   &lt;a href=&quot;arch_con_term.html&quot;&gt;here&lt;/a&gt; for details).&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;You'll also need an uIP configuration file (&lt;i&gt;src/platform/&lt;name&gt;/uip-conf.h&lt;/i&gt;) to configure the TCP/IP
+stack. For an example, look at &lt;i&gt;src/platform/&lt;lm3s&gt;/uip-conf.h&lt;/i&gt;. The header if quite self-explanatory, below
+you have a list of parameters that you might want to change:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;&lt;b&gt;u8_t, u16_t&lt;/b&gt;: define these types to match your platform.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;UIP_CONF_MAX_CONNECTIONS&lt;/b&gt;: the maximum number of TCP connections that can be active at a given time.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;UIP_CONF_UDP_CONNS&lt;/b&gt;: same thing for UDP connections.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;UIP_CONF_BYTE_ORDER&lt;/b&gt;: &lt;b&gt;LITTLE_ENDIAN&lt;/b&gt; or &lt;b&gt;BIG_ENDIAN&lt;/b&gt;, it's very important to match this with your architecture.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;UIP_CONF_BUFFER_SIZE&lt;/b&gt;: the size of the buffer used by uIP for all its connections. You should keep it small to avoid memory consumption,
+    but doing so when you have to transfer large amounts of data will slow the transfer speed. 1k seems to be a good compromise.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;UIP_CONF_UDP&lt;/b&gt;: turn off UDP support. While &lt;b&gt;eLua&lt;/b&gt; doesn't have support for UDP via its &lt;b&gt;net&lt;/b&gt; module at this time, UDP can still
+    be used (for example by DNS/DHCP), so be careful if you disable this.&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;ELUA_DHCP_TIMER_ID&lt;/b&gt;: the timer ID used for the TCP/IP subsystem. Note that this should be a dedicated timer, not available to the rest 
+    of the system (or available in &quot;read-only&quot; mode).&lt;/li&gt;
+&lt;/ul&gt;
+&lt;br /&gt;
+
+&lt;h2&gt;TCP/IP implementation internals&lt;/h2&gt;
+&lt;p&gt;The TCP/IP support was designed in such a way that it doesn't require a specific
+TCP/IP stack implementation. To work with &lt;b&gt;eLua&lt;/b&gt;, a TCP/IP stack must simply 
+implement all the functions defined in the inc/elua_net.h file. This allows for
+easy integration of more than one TCP/IP stack. Currently only uIP is used in 
+eLua, but lwIP (and possibly others) are planned to be added at some point.
+Another key point of the TCP/IP implementation (and of the whole &lt;b&gt;eLua&lt;/b&gt; design
+for that matter) is that it should be as platform independent as possible: write
+everything in a platform-independent manner, except for some functions (as few as
+possible and as simple as possible) that must be implemented by each platform.
+To illustrate the above, a short overview of the uIP integration is given below.&lt;/p&gt;
+
+&lt;p&gt;&lt;a  href=&quot;<A HREF="http://www.sics.se/~adam/uip/index.php/Main_Page">http://www.sics.se/~adam/uip/index.php/Main_Page</A>&quot;&gt;uIP&lt;/a&gt; is a minimalistic TCP/IP
+stack designed specifically for resource constrained embedded systems. While the
+design and implementation of uIP are an excellent example of what can be done
+with a few kilobytes of memory, it has a number of quirks that make it hard to
+integrate with &lt;b&gt;eLua&lt;/b&gt;. First, it uses a callback approach, as opposed to the 
+sequential approach of &quot;regular&quot; TCP/IP stacks. It provides a &quot;protosocket&quot; 
+library that can be used to write uIP applications in a more &quot;traditional&quot; way,
+but it's quite restrictive. So, to use it with &lt;b&gt;eLua&lt;/b&gt;, a translation layer was
+needed. It is implemented in &lt;i&gt;src/elua_uip.c&lt;/i&gt;, and its sole purpose is to &quot;adapt&quot;
+the uIP stack to the &lt;b&gt;eLua&lt;/b&gt; model: implement the functions in &lt;i&gt;inc/elua_net.h&lt;/i&gt; and
+you're ready to use the stack. In this case the &quot;adaption layer&quot; is quite large
+because of uIP's callback-based design.&lt;/p&gt;
+
+&lt;p&gt;To make the uIP implementation as platform-independent as possible, a special
+&lt;a href=&quot;&quot;&gt;##networking layer&lt;/a&gt; is added to the &lt;a href=&quot;arch_platform.html&quot;&gt;platform interface&lt;/a&gt;. 
+There are only 4 functions that must be implemented by a backend
+to use the networking layer. They might change as more TCP/IP stacks are added
+to eLua, but probably the networking layer won't get much bigger than it is now.&lt;br&gt;
+For a more in-depth understanding of how the networking layer is implemented,
+look at the LM3S implementation in &lt;i&gt;src/platform/lm3s/platform.c&lt;/i&gt;. 
+&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/doc.html
===================================================================
--- tags/pre0.6/doc/pt/doc.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/doc.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,19 @@
+$$HEADER$$
+&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;
+&lt;body style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;
+&lt;h3&gt;Documenta&ccedil;&atilde;o&lt;/h3&gt;
+&lt;p&gt;Nesta se&ccedil;&atilde;o voc&ecirc; encontrar&aacute; a documenta&ccedil;&atilde;o completa de &lt;b&gt;eLua&lt;/b&gt; tanto para usu&aacute;rios quanto para desenvolvedores, incluindo (mas n&#227;o se limitando a):
+&lt;ul&gt;
+  &lt;li&gt;como fazer um build de &lt;b&gt;eLua&lt;/b&gt;&lt;/li&gt;
+  &lt;li&gt;como compilar e instalar os toolchains necess&aacute;rios para um
+  build de &lt;b&gt;eLua&lt;/b&gt;&lt;/li&gt;
+  &lt;li&gt;como utilizar &lt;b&gt;eLua&lt;/b&gt;&lt;/li&gt;
+  &lt;li&gt;descri&ccedil;&atilde;o de exemplos de programas-fontes de &lt;b&gt;eLua&lt;/b&gt;&lt;/li&gt;
+&lt;/ul&gt;&lt;/p&gt;
+&lt;p&gt;Aquele que desejar contribuir com o c&oacute;digo fonte de &lt;b&gt;eLua&lt;/b&gt; encontrar&aacute; aqui muita informa&ccedil;&atilde;o importante:&lt;ul&gt;
+  &lt;li&gt;descri&ccedil;&atilde;o da arquitetura de &lt;b&gt;eLua&lt;/b&gt;&lt;/li&gt;
+  &lt;li&gt;as regras de codifica&ccedil;&atilde;o padr&atilde; de &lt;b&gt;eLua&lt;/b&gt;&lt;/li&gt;
+  &lt;li&gt;como portar &lt;b&gt;eLua&lt;/b&gt; para uma nova plataforma&lt;/li&gt;
+&lt;/ul&gt;
+&lt;/p&gt;
+$$FOOTER$$

Added: tags/pre0.6/doc/pt/forum.html
===================================================================
--- tags/pre0.6/doc/pt/forum.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/forum.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,5 @@
+$$HEADER$$
+&lt;a id=&quot;nabblelink&quot; href=&quot;<A HREF="http://n2.nabble.com/eLua-Development-f2368040.html">http://n2.nabble.com/eLua-Development-f2368040.html</A>&quot;&gt;eLua Development&lt;/a&gt;
+&lt;script src=&quot;<A HREF="http://n2.nabble.com/embed/f2368040">http://n2.nabble.com/embed/f2368040</A>&quot;&gt;&lt;/script&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing.html
===================================================================
--- tags/pre0.6/doc/pt/installing.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,7 @@
+$$HEADER$$
+&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;
+&lt;body style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;
+&lt;h3&gt;Instalando eLua&lt;/h3&gt;
+&lt;p&gt;Ap&oacute;s a gera&ccedil;&atilde;o de &lt;b&gt;eLua&lt;/b&gt;, ser&aacute; necess&aacute;rio instal&aacute;-lo (grav&aacute;-lo na sua placa de prefer&ecirc;ncia) antes de us&aacute;-lo. Neste item apresentamos instru&ccedil;&otilde;es espec&iacute;ficas para a instala&ccedil;&atilde;o em todas as CPU/placas suportadas por &lt;b&gt;eLua&lt;/b&gt;. Certifique-se que voc&ecirc; j&aacute; possui uma imagem de &lt;b&gt;eLua&lt;/b&gt; gerada para funcionar no seu hardware (tanto &lt;a href=&quot;downloads.html&quot;&gt;baixando uma j&aacute; pronta&lt;/a&gt; ou &lt;a href=&quot;building.html&quot;&gt;gerando voc&ecirc; mesmo&lt;/a&gt;), ent&atilde;o escolha a plataforma que lhe interessa a partir das op&ccedil;&otilde;es do o menu &quot;Instalando&quot;.&lt;/p&gt;
+&lt;p&gt;Para obter o seu arquivo de imagem bin&aacute;ria necess&aacute;rio para permitir a programa&ccedil;&atilde;o de sua CPU durante a gera&ccedil;&atilde;o de &lt;b&gt;eLua&lt;/b&gt;, lembre-se de especificar o par&acirc;metro &quot;prog&quot; na linha do comando scons.&lt;/p&gt;
+$$FOOTER$$

Added: tags/pre0.6/doc/pt/installing_at91sam7x.html
===================================================================
--- tags/pre0.6/doc/pt/installing_at91sam7x.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_at91sam7x.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,47 @@
+$$HEADER$$
+&lt;h3&gt;Using &lt;b&gt;eLua&lt;/b&gt; with the AT91SAM7X CPUs from Atmel&lt;/h3&gt;
+ &lt;p&gt;&lt;a href=&quot;<A HREF="http://www.atmel.com">http://www.atmel.com</A>&quot;&gt;Atmel&lt;/a&gt; is a company that doesn't need any kind of introduction :) Their huge product range include some quite nice ARM7TDMI core implementations.
+ Among them are the &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755">http://www.atmel.com/dyn/products/Product_card.asp?part_id=3755</A>&quot;&gt;AT91SAM7X256&lt;/a&gt; and
+ &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104">http://www.atmel.com/dyn/products/Product_card.asp?part_id=4104</A>&quot;&gt;AT91SAM7X512&lt;/a&gt; CPUs. The only difference between them is the ammount of internal memory (256k Flash+64k RAM for
+ AT91SAM7X256 vs. 512k Flash+128k RAM for AT91SAM7X512). Loaded with peripherals, and accompanied by a good support package, they make a perfect host for &lt;b&gt;eLua&lt;/b&gt;. For this tutorial
+ I'm going to use the &lt;a href=&quot;<A HREF="http://www.olimex.com/dev/sam7-ex256.html">http://www.olimex.com/dev/sam7-ex256.html</A>&quot;&gt;SAM7-EX256&lt;/a&gt; development board from &lt;a href=&quot;<A HREF="http://www.olimex.com">http://www.olimex.com</A>&quot;&gt;Olimex&lt;/a&gt;. It's quite a 
+ decent board, and also reasonably priced, although it lacks a proper documentation package in my oppinion. It is equipped with an AT91SAM7X256 CPU. As much as I'd like to get
+ my hands on a board with a AT91SAM7X512 CPU, this didn't happen so far, so I'm going to stick with AT91SAM7X256. Of course, you can still try this tutorial if you have
+ a different AT91SAM7X256 development board. Plus, the instructions should be quite similar for AT91SAM7X512 CPUs.
+ &lt;/p&gt;
+ &lt;h3&gt; Prerequisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the AT91SAM7X256 CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;you're using Windows. This isn't actually a strict requirement, it just makes life a bit easier. As the Atmel CPU is supported by the &lt;a href=&quot;<A HREF="http://openocd.berlios.de/web/">http://openocd.berlios.de/web/</A>&quot;&gt;OpenOCD&lt;/a&gt; package, programming it from Linux is definitely possible, as OpenOCD runs equally well on Windows and Linux. However, since I'm forced to use Windows anyway because of the restrictions of
+ some of my other development boards, I'm going to take advantage of this and cover the Atmel programming tool instead of OpenOCD. The advantage is that you don't need a JTAG &quot;dongle&quot;
+ to program your board (which would be the case if you were using OpenOCD). The disadvantage, of course, is that the Atmel tool runs only on Windows. Plus, I personally find OpenOCD 
+ tedious to use. If you still want to use it though, you might want to check the forementioned &lt;a href=&quot;<A HREF="http://www.olimex.com/dev/sam7-ex256.html">http://www.olimex.com/dev/sam7-ex256.html</A>&quot;&gt;Olimex page&lt;/a&gt;, they have some OpenOCD related links there.
+ That said, from now on I'm going to assume that you use Windows. I'm using XP, Vista should work too.&lt;/li&gt;
+ &lt;li&gt;you have installed the &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3883">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3883</A>&quot;&gt;AT91 In-system Programmer (ISP)&lt;/a&gt; package from Atmel.&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the AT91SAM7X256 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;).&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;h3&gt;Programming eLua on the SAM7-EX256 board&lt;/h3&gt;
+ &lt;p&gt;This involves some jumper tricks, but it's still easy enough to do. We'll need to play with four jumpers: the &quot;USB/EXT&quot; jumper (located to the right of the USB connector 
+ from the bottom left part of the board in its close proximity), the &quot;ERASE&quot; jumper (located at the right of the &quot;UEXT&quot; header connector in the top-left 
+ part of the board, right ahead the quartz), and the block of two jumpers located right under the &quot;RS232&quot; connector on the board (the one that is adjacent to the Ethernet connector on its right side,
+ &lt;b&gt;NOT&lt;/b&gt; the one labeled &quot;CAN&quot; that is closer to the right edge of the board). &lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;connect your board to your PC using a suitable USB cable.&lt;/li&gt; 
+ &lt;li&gt;if you have a terminal emulation program connected to the board, close it (or at least disconnect it from its port).&lt;/li&gt;
+ &lt;li&gt;make sure that the the block of two jumpers mentioned before is set to positions &quot;RXD0&quot; and &quot;TXD0&quot; respectively, &lt;b&gt;NOT&lt;/b&gt; &quot;DRXD&quot; and &quot;DTXD&quot;.&lt;/li&gt;
+ &lt;li&gt;make sure that the &quot;USB/EXT&quot; connector is set to &quot;USB&quot; (position 1-2) and that the &quot;ERASE&quot; jumper is disconnected.&lt;/li&gt;
+ &lt;li&gt;connect the &quot;ERASE&quot; jumper and wait one second or more.&lt;/li&gt;
+ &lt;li&gt;disconnect the &quot;USB/EXT&quot; jumper completely, then disconnect the &quot;ERASE&quot; jumper too.&lt;/li&gt;
+ &lt;li&gt;connect the &quot;USB/EXT&quot; jumper back in the &quot;USB&quot; position (1-2).&lt;/li&gt;
+ &lt;li&gt;fire up the Atmel programming tool. If you haven't installed your board yet, you'll be asked to do so at this point.&lt;/li&gt;
+ &lt;li&gt;select &quot;\usb\ARMx&quot; as the connection (for me it's \usb\ARM0) and &quot;AT91SAM7X256-EK&quot; as the board.&lt;/li&gt;
+ &lt;li&gt;select the &quot;Flash&quot; tab from the middle tab of the window.&lt;/li&gt;
+ &lt;li&gt;in the &quot;Send file name&quot; box select your &lt;b&gt;eLua&lt;/b&gt; bin file that you got from the compilation step and then press &quot;Send File&quot;.&lt;/li&gt;
+ &lt;li&gt;wait for the file to be sent and answer &quot;No&quot; to the &quot;Lock region(s)&quot; dialog.&lt;/li&gt;
+ &lt;li&gt;in the window section below (&quot;Scripts&quot;) select &quot;Boot from Flash (GPNVM2)&quot; then press &quot;Execute&quot;.&lt;/li&gt;
+ &lt;li&gt;exit the application.&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;p&gt;That's it! A bit tricky, but &lt;b&gt;eLua&lt;/b&gt; is now programmed in the CPU, so you can start your terminal emulator and enjoy it, as described in &lt;a href=&quot;using.html&quot;&gt;using eLua&lt;/a&gt;. 
+ &lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing_avr32.html
===================================================================
--- tags/pre0.6/doc/pt/installing_avr32.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_avr32.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,76 @@
+$$HEADER$$
+&lt;h3&gt;Installing &lt;b&gt;eLua&lt;/b&gt; on the AVR32 CPUs from Atmel&lt;/h3&gt;
+&lt;p&gt;&lt;a href=&quot;<A HREF="http://www.atmel.com/products/AVR32/">http://www.atmel.com/products/AVR32/</A>&quot;&gt;AVR32&lt;/a&gt; is a family of high performance 32-bit CPUs from &lt;a 
+  href=&quot;<A HREF="http://www.atmel.com">http://www.atmel.com</A>&quot;&gt;Atmel&lt;/a&gt;. They were built as direct competitors for the various ARM core implementation of the market, and offer very good
+  performance (91 MIPS @ 66MHz) and power efficieny (1.3mW/MHz). Atmel claims that their AVR32 core outperforms ARMv5 (in ARM and Thumb mode) in terms of 
+  both performance and code size. It's a proprietary architecture (so it's only implemented by Atmel), yet it has a very good support package, and an
+  open source toolchain based on GCC, which made it an ideal candidate for the first non-ARM (and also the first big endian) &lt;b&gt;eLua&lt;/b&gt; target. Atmel
+  also sells a number of development boards based on their AVR23 CPUs. The one used for &lt;b&gt;eLua&lt;/b&gt; is the 
+  &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114">http://www.atmel.com/dyn/Products/tools_card.asp?tool_id=4114</A>&quot;&gt;ATEVK1100 board&lt;/a&gt;, built around the 
+  &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/product_card.asp?part_id=4117">http://www.atmel.com/dyn/products/product_card.asp?part_id=4117</A>&quot;&gt;AT32UC3A0512 AVR32 MCU&lt;/a&gt; (512k internal Flash/64k internal ARM).
+  It's a very powerful board, featuring (among other things) an external 32 MByte SDRAM memory, which is more than enough to run any &lt;b&gt;eLua&lt;/b&gt; 
+  program I can think of :).&lt;/p&gt;
+&lt;h3&gt;Prerequisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the AT32UC3A0512 CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;you're using Linux or Windows. It's easier to install and use Atmel's programming software on Windows, so use Windows version if you want to save
+   yourself from quite a bit of hassle.&lt;/li&gt;
+ &lt;li&gt;you installed Atmel's &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886</A>&quot;&gt;FLIP programming software&lt;/a&gt;, which is what you need
+    in order to install your &lt;b&gt;eLua&lt;/b&gt; image. Installation in easy under Windows (you just need to run a setup paclage), but quite tricky under Linux. 
+    The next paragraph outlines the procedure for installing FLIP in Linux.&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the AT32UC3A0512 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;). 
+    Note that unlike other platforms, the ATEVK1100 needs a .hex file for programming, not a .bin.&lt;/li&gt;
+ &lt;/ul&gt;
+&lt;h2&gt;Installing FLIP in Ubuntu Linux&lt;/h2&gt;
+&lt;p&gt;Follow the steps below to install FLIP under Linux:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;download the Linux version of FLIP from &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3886</A>&quot;&gt;the Atmel FLIP page&lt;/a&gt;. Save it 
+  (or move it later) to your &lt;i&gt;/usr/local/&lt;/i&gt; directory (you need to have superuser privileges to do that). At the moment of writing this tutorial, the
+  latest FLIP version is 3.2.1, so this is what we're going to use here.&lt;/li&gt;
+  &lt;li&gt;untar the FLIP archive:
+  &lt;pre&gt;&lt;code&gt;$ cd /usr/local
+$ sudo tar xvzf flip_linux_3-2-1.tgz&lt;/code&gt;&lt;/pre&gt;
+  This will create the &lt;i&gt;/usr/local/flip.3.2.1&lt;/i&gt; directory.&lt;/li&gt;
+  &lt;li&gt;you need to install OpenJDK if it is not installed:
+  &lt;pre&gt;&lt;code&gt;$ sudo apt-get install openjdk-6-jre&lt;/code&gt;&lt;/pre&gt;
+  &lt;/li&gt;
+  &lt;li&gt;edit &lt;i&gt;/usr/local/flip.3.2.1/bin/batchisp3.sh&lt;/i&gt; and add the two bolded lines before at the beginning of the file:
+  &lt;pre&gt;&lt;code&gt;#!/bin/bash -f
+
+&lt;b&gt;export JAVA_HOME=/usr/lib/jvm/java-6-openjdk/jre/
+export FLIP_HOME=/usr/local/flip.3.2.1/bin/&lt;/b&gt;
+
+if [ &quot;$FLIP_HOME&quot; = &quot;&quot; ]; then&lt;/code&gt;&lt;/pre&gt;
+  &lt;/li&gt;
+  &lt;li&gt;you need to edit a binary file this time (&lt;i&gt;/usr/local/flip.3.2.1/libatlibusbdfu.so&lt;/i&gt;). This happens because FLIP comes compiled for RedHat by
+  default, and Ubuntu some different system paths. See &lt;a href=&quot;<A HREF="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;amp;file=viewtopic&amp;amp;t=56562">http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=56562</A>&quot;&gt;this topic&lt;/a&gt; 
+  for full details. All you have to do is change all the &lt;b&gt;/sys/bus/usb&lt;/b&gt; strings inside &lt;i&gt;libatlibusbdfu.so&lt;/i&gt; to &lt;b&gt;/dev/bus/usb&lt;/b&gt;.&lt;/li&gt;
+  &lt;li&gt;add the FLIP directory to your PATH:
+  &lt;pre&gt;&lt;code&gt;$ export PATH=/usr/local/flip.3.2.1/bin:$PATH&lt;/code&gt;&lt;/pre&gt;
+  &lt;/li&gt;
+  &lt;li&gt;FLIP interferes with a program that comes pre-installed on Ubuntu system, called &lt;b&gt;brltty&lt;/b&gt;. It's meant to help the visually 
+  impaired, so if you're not one of them, simply remove it (as it seems to interfere with a lot of other USB devices too):
+  &lt;pre&gt;&lt;code&gt;$ sudo apt-get remove brltty&lt;/code&gt;&lt;/pre&gt;
+  &lt;/li&gt;
+&lt;/ol&gt;
+
+ &lt;h3&gt;Burning &lt;b&gt;eLua&lt;/b&gt; to the EVK1100 board&lt;/h3&gt;
+&lt;p&gt;After you installed FLIP and added it to your $PATH, burning the &lt;b&gt;eLua&lt;/b&gt; image should be quite easy:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;connect your ATEVK1100 board with the PC using an USB cable&lt;/li&gt;
+  &lt;li&gt;put your board in DFU mode (this is required for FLIP interaction). To do this:
+    &lt;ol&gt;
+      &lt;li&gt;press &lt;b&gt;on&lt;/b&gt; the on-board joystick (and keep it pressed)&lt;/li&gt;
+      &lt;li&gt;press the RESET button on the board briefly&lt;/li&gt;
+      &lt;li&gt;release the RESET button&lt;/li&gt;
+      &lt;li&gt;release the joystick&lt;/li&gt;
+    &lt;/ol&gt;
+  &lt;/li&gt;
+  &lt;li&gt;if you're using Windows and it asks you for a driver, you should install it manually from &lt;i&gt;c:\Program Files\Atmel\Flip &lt;version&gt;\usb&lt;/i&gt;&lt;/li&gt;
+  &lt;li&gt;Execute this from the command line (the command is the same on Windows and Linux, with a single exception: the FLIP executable name is &lt;b&gt;batchisp3&lt;/b&gt; in Linux and &lt;b&gt;batchisp&lt;/b&gt; (without a 3) in Windows):
+  &lt;pre&gt;&lt;code&gt;$ batchisp3 -hardware usb -device at32uc3a0512 -operation erase f memory flash blankcheck 
+  loadbuffer &lt;image name&gt;.hex program verify start reset 0&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;That's all, your &lt;b&gt;eLua&lt;/b&gt; image is (finally) installed on your ATEVK1100 board.&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing_i386.html
===================================================================
--- tags/pre0.6/doc/pt/installing_i386.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_i386.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,15 @@
+$$HEADER$$
+&lt;h3&gt;Using eLua with Intel i386 (or better) CPUs&lt;/h3&gt;
+ &lt;p&gt;Since the i386 platform was implemented as a proof of concept only, the only things you can do with it are:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;&lt;a href=&quot;tut_boot_lua.html&quot;&gt;##Boot your PC in eLua&lt;/a&gt;&lt;/li&gt;
+ &lt;li&gt;&lt;a href=&quot;tut_lua_usb.html&quot;&gt;##Boot eLua from a stick&lt;/a&gt;&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;p&gt;If you want to do this, &lt;a href=&quot;building.html&quot;&gt;build your eLua image&lt;/a&gt; or download a precompiled image, as explained in the &lt;a href=&quot;downloads.html&quot;&gt;download page&lt;/a&gt;.&lt;/p&gt;
+ &lt;p&gt;However, most of the features that you'd find on an embedded platform won't work. You won't be able to upload programs to your i386 &lt;b&gt;eLua&lt;/b&gt; box using the
+ XMODEM protocol (not because it's impossible, but simply because this doesn't make sense at all on a desktop PC). Also, you won't be able to control the peripherals that you'd normally find in an
+ embedded CPU (SPI, I2C, PIO and all the others), because they are not present on the i386 platform (they can be emulated via different means, but this is way beyond
+ the scope of &lt;b&gt;eLua&lt;/b&gt;). So, until further notice, i386 will be nothing more than a spectacular demo platform for &lt;b&gt;eLua&lt;/b&gt;. If you think that you can make something
+ more out of it, please feel free to &lt;a href=&quot;overview.html#contacts&quot;&gt;contact us&lt;/a&gt;. I'm actually very interested in this, but I lack the necessary resources to continue it.&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing_lm3s.html
===================================================================
--- tags/pre0.6/doc/pt/installing_lm3s.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_lm3s.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,47 @@
+$$HEADER$$
+&lt;h3&gt;Using &lt;b&gt;eLua&lt;/b&gt; with the LM3S (Cortex-M3) CPUs from Luminary Micro&lt;/h3&gt;
+ &lt;p&gt;&lt;a href=&quot;<A HREF="http://www.luminarymicro.com">http://www.luminarymicro.com</A>&quot;&gt;Luminary Micro&lt;/a&gt; is the company that produced the world's first silicon implementation of the Cortex-M3 processor. Their 
+ device portfolio is quite impressive, ranging from relatively simple devices to full-featured CPUs (with on-chip USB, EMAC, CAN, and many other peripherals). The support
+ package for these devices is also very good, with drivers for all the CPU peripherals and ports of 3rd party applications. And, on a personal note, I contacted Luminary Micro
+ some while ago with a request to support this project with one of their evaluation kits, and their response was excellent (thanks again, Luminary!). That's how a
+ &lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/lm3s8962_can_ethernet_evaluation_kit.html</A>&quot;&gt;EKx-LM3S8962K&lt;/a&gt; landed on my desk. This is the development board that I'm going
+ to use in this tutorial. &lt;b&gt;eLua&lt;/b&gt; also supports the &lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/ekk-lm3s6965_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/ekk-lm3s6965_ethernet_evaluation_kit.html</A>&quot;&gt;EKx-LM3S6965&lt;/a&gt; board from Luminary (which can be programmed exactly like the EKx-LM3S8962) and the &lt;a href=&quot;<A HREF="http://www.micromint.com/index.php/products/by-family/sbcs/77">http://www.micromint.com/index.php/products/by-family/sbcs/77</A>&quot;&gt;Eagle 100&lt;/a&gt; board from &lt;a href=&quot;<A HREF="http://www.micromint.com">http://www.micromint.com</A>&quot;&gt;Micromint&lt;/a&gt;, which uses a different installation procedure. 
+&lt;/p&gt;
+ &lt;h3&gt;Pre-requisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the LM3S CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;you're using Windows. Yes, I really said &lt;b&gt;Windows&lt;/b&gt;. The reason is quite simple: we're going to use Luminary's tools to burn &lt;b&gt;eLua&lt;/b&gt; to the board,
+ and they're Windows specific. This is the case with many CPUs and vendors out there. You can have Windows installed on your HDD, or under 
+ an emulator in Linux, it doesn't matter, you can even try to run it from &lt;a href=&quot;<A HREF="http://www.winehq.org/">http://www.winehq.org/</A>&quot;&gt;Wine&lt;/a&gt; if you're really, really brave. I'm using XP, Vista should work too.&lt;/li&gt;
+ &lt;li&gt;you have installed the LM Flash Programmer tool from Luminary. Look for it on &lt;a href=&quot;<A HREF="http://www.luminarymicro.com/products/ekk-lm3s8962_can_ethernet_evaluation_kit.html">http://www.luminarymicro.com/products/ekk-lm3s8962_can_ethernet_evaluation_kit.html</A>&quot;&gt;this page&lt;/a&gt;,
+ for example (the link is in the &quot;Software updates&quot; table).&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the LM3S8962 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;). &lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;h3&gt;Installing &lt;b&gt;eLua&lt;/b&gt; on EKx-LM3S8962EK and EKx-LM3S6965&lt;/h3&gt;
+ &lt;p&gt;Fortunately, this is as easy and painless as possible. One of the nicest things about these two kits is they use the on-board USB port for both firmware downloading and for
+ emulating a serial port (via a hardware USB to UART converter, so you don't need any special software on the CPU to access this UART port). Moreover, it automagically
+ knows how (and when) to switch from the firmware download mode to the UART emulation mode, so you don't need to move jumpers around or anything like this. It's zero effort
+ firmware upgrading at its best. So, let's do it:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;connect your board to your PC using a suitable USB cable. If you didn't install the board drivers yet, you'll be asked to install them now.&lt;/li&gt;
+ &lt;li&gt;if you're already using the USB connection on the board in the UART emulation mode, close your terminal program (or at least disconnect it from the USB COM port).&lt;/li&gt;
+ &lt;li&gt;fire up the &quot;Luminary Micro Flash Programmer&quot; application.&lt;/li&gt;
+ &lt;li&gt;in the &quot;Configuration&quot; tab, select &quot;LM3S8962 Ethernet and CAN Evaluation board&quot; or &quot;LM3S6965 Ethernet Evaluation Board&quot; (depending on your board).&lt;/li&gt;
+ &lt;li&gt;in the &quot;Program&quot; tab, select the &lt;b&gt;eLua&lt;/b&gt; .bin file that you got from the compilation step.&lt;/li&gt;
+ &lt;li&gt;select the &quot;Options&quot; as you like (I generally choose &quot;Erase entire flash&quot; and &quot;Reset MCU after program&quot;).&lt;/li&gt;
+ &lt;li&gt;hit the &quot;Program&quot; button.&lt;/li&gt;
+ &lt;li&gt;wait until programming is over, then exit the flash programmer application.&lt;/li&gt;
+ &lt;/ul&gt;
+&lt;p&gt;It's worth to mention that since these boards come with an USB to JTAG converter it should be possible to use OpenOCD (or a similar package) instead of the Luminary tool to program the image. The Luminary Micro forums are a good place to look for information if you're exploring the OpenOCD option.
+&lt;/p&gt;
+&lt;h3&gt;Installing eLua on Eagle 100&lt;/h3&gt;
+&lt;p&gt;The Eagle 100 board can also be programmed via JTAG, but it doesn't include an on-board USB to JTAG adapter, so you'd need an external adapter if you
+want to use JTAG for programming. Fortunately, it also comes with an Ethernet bootloader, so you can upload your image via Ethernet. The only requirement
+to use the bootloader is to start your image at address 0x2000 instead of the usual 0x0, since that's where the bootloader jumps. The 
+&lt;a href=&quot;building.html&quot;&gt;eLua build system&lt;/a&gt; does this automatically if the &quot;board=eagle-100&quot; parameter is given at build time.&lt;br&gt;
+For a full description of the Ethernet bootloader consult the &lt;a href=&quot;<A HREF="http://www.micromint.com/index.php/products/by-family/sbcs/54/118">http://www.micromint.com/index.php/products/by-family/sbcs/54/118</A>&quot;&gt;Eagle 100 board manual&lt;/a&gt;, or (more specifically) &lt;a href=&quot;<A HREF="http://www.micromint.com/index.php/products/by-family/sbcs/54/122">http://www.micromint.com/index.php/products/by-family/sbcs/54/122</A>&quot;&gt;this link&lt;/a&gt; (look for section 2.7, &lt;b&gt;Firmware Updates using the Ethernet Bootloader&lt;/b&gt;).&lt;br&gt;
+You still need the LM Flash Tool to use the Ethernet bootloader, but since the board can use JTAG for firmware uploading, it should be possible to use it 
+with OpenOCD (or a similar package) and an external USB to JTAG adapter. The Luminary Micro forums are a good place to look for information if you're exploring the OpenOCD option.
+&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing_lpc2888.html
===================================================================
--- tags/pre0.6/doc/pt/installing_lpc2888.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_lpc2888.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,36 @@
+$$HEADER$$
+&lt;h3&gt;Installing &lt;b&gt;eLua&lt;/b&gt; with the LPC2888 CPU from NXP&lt;/h3&gt;
+&lt;p&gt;The &lt;a href=&quot;<A HREF="http://www.standardics.nxp.com/products/lpc2000/all/~LPC2888/">http://www.standardics.nxp.com/products/lpc2000/all/~LPC2888/</A>&quot;&gt;LPC2888 CPU&lt;/a&gt; from &lt;a href=&quot;<A HREF="http://www.nxp.com">http://www.nxp.com</A>&quot;&gt;NXP&lt;/a&gt; packs some interesting features: huge internal 1Mbyte flash memory,
+  on-chip USB 2.0 high speed interface, and the most complex (by far) clocking network that I've ever seen on an ATM7TDMI chip. Also, it implements the USB DFU (Device Firmware Update) profile over
+  its USB interface, so it's quite easy to program it in-circuit. I'm using the &lt;a href=&quot;<A HREF="http://www.olimex.com/dev/lpc-h2888.html">http://www.olimex.com/dev/lpc-h2888.html</A>&quot;&gt;Olimex LPC-H2888&lt;/a&gt; development board built around this chip, which packs
+  32MBytes of external SDRAM and also 2MBytes of external flash, which is more than enough for my needs. However, it does have its fair share of downsides. For starters, its support package (from NXP) is very poot when
+  compared to other targets on which &lt;b&gt;eLua&lt;/b&gt; runs. You don't even get drivers for all your peripherals, just a a few (quite incomplete) examples. Its datasheet could be much more explit at times, especially when
+  referring to the clocking section (which is quite complicated). On my board, the DFU download mode (firmware upgrade via USB) stopped working out of the blue, without any apparent reasons, and I was unable to
+  use DFU on the chip since then, I had to resort to using OpenOCD (and come up with a configuration file, since it was impossible to find one for LPC2888). The CPU itself has a very interesting limitation: because of a sillicon 
+  error, it's impossible to run Thumb code from the on-chip flash, you can only run regular ARM code (?!). Also, the board that I got from Olimex completely ignores the fact that this chip can run in DFU mode (it doesn't include 
+  any kind of jumper and/or switch to enable this mode), so I had to build a support board for it. Which is something I had to do also because the board doesn't export a RS232 interface, I had to build one around a MAX232 chip. 
+  All in all, my experience with this chip (and with the Olimex board) wasn't that pleasant, but this doesn't change the fact that the LPC-H2888 is one of the most powerful (resource-wise) boards on which &lt;b&gt;eLua&lt;/b&gt; runs.    
+ &lt;/p&gt;
+ &lt;h3&gt;Prerequisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the LPC2888 CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;if you're going to use DFU for firmware programming, you'll need Windows (although I heard reports of Linux programs that can program this chip in DFU mode, but I won't cover them here). If you're going to use OpenOCD, Linux, Windows, 
+ or any other OS that has support for &lt;a href=&quot;<A HREF="http://openocd.berlios.de/web/">http://openocd.berlios.de/web/</A>&quot;&gt;OpenOCD&lt;/a&gt; will do. In this case, you might want to have a look at my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD tutorial&lt;/a&gt; before continuing.&lt;/li&gt;
+ &lt;li&gt;also, if you're going to use DFU, you'll need a way to boot the chip in DFU firmware upgrade mode. This is done by pulling up (tie to VCC) the P2.3 pin at startup. On my board I included a switch for this. Press the switch, press RESET
+ while holding the switch pressed, then release the switch. You chip is now in DFU mode.&lt;/li&gt;
+ &lt;li&gt;if you're using DFU, you have installed the LPC2888 flash programming utility from &lt;a href=&quot;<A HREF="http://www.standardics.nxp.com/support/documents/microcontrollers/zip/flash.utility.mass.dfu.lpc2888.zip">http://www.standardics.nxp.com/support/documents/microcontrollers/zip/flash.utility.mass.dfu.lpc2888.zip</A>&quot;&gt;here&lt;/a&gt; (the package also
+ contains the Windows DFU drivers).&lt;/li&gt;
+ &lt;li&gt;if you're using OpenOCD, you have followed the instructions from my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD&lt;/a&gt; tutorial.&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the LPC2888 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;).&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;h3&gt;Burning &lt;b&gt;eLua&lt;/b&gt; to the LPC2888 using the DFU tool from NXP&lt;/h3&gt;
+ &lt;p&gt;The DFU flashing application doesn't work directly on the .bin files you get after building &lt;b&gt;eLua&lt;/b&gt;, you need to run them though NXP's &quot;hostcrypt&quot; program (which is part of the LPC2888 DFU package). After you have your &lt;b&gt;eLua&lt;/b&gt; .bin file,
+ do this from a Windows command prompt (make sure that hostcryptv2.exe is in the path):&lt;/p&gt;
+ &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;C:&gt; hostcryptv2 elua_lua_lpc2888.bin elua.ebn -K0 -F0&lt;/pre&gt;&lt;/div&gt;
+ &lt;p&gt;As a result, you'll have a new file (&lt;i&gt;elua.ebn&lt;/i&gt;). Now boot your chip in DFU firmware upgrade mode (see above) and use the DFU utility (&lt;i&gt;MassDFUApplication.exe&lt;/i&gt;) to load &lt;i&gt;elua.ebn&lt;/i&gt; into your chip (the instructions on
+ using MassDFUApplication are in a PDF file that's included in the LPC2888 DFU package). Reset the board and enjoy.
+ &lt;/p&gt;
+ &lt;h3&gt;Burning &lt;b&gt;eLua&lt;/b&gt; to the LPC2888 using OpenOCD&lt;/h3&gt;
+ &lt;p&gt;If you're as lucky as me and your board refuses to use DFU anymore, follow my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD tutorial&lt;/a&gt; to burn your image using OpenOCD.&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing_stm32.html
===================================================================
--- tags/pre0.6/doc/pt/installing_stm32.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_stm32.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,41 @@
+$$HEADER$$
+&lt;h3&gt;Using &lt;b&gt;eLua&lt;/b&gt; with the STM32 CPUs from ST&lt;/h3&gt;
+ &lt;p&gt;The &lt;a href=&quot;<A HREF="http://www.st.com/mcu/inchtml-pages-stm32.html">http://www.st.com/mcu/inchtml-pages-stm32.html</A>&quot;&gt;STM32 family&lt;/a&gt; of MCUs from 
+ &lt;a href=&quot;<A HREF="http://www.st.com">http://www.st.com</A>&quot;&gt;ST&lt;/a&gt; is a line of Cortex-M3 based chips with a lot of neat features, including (but not limited to) high
+ amounts of on-chip Flash/RAM (up to 512k Flash and 64k RAM), external memory controller that covers (P)SRAM, NAND Flash and NOR flash, integrated ADC and
+ DACs, advanced timers and many others. They also feature an integrated serial boot loader, so it's extremely easy to program them from anything that has
+ a serial port. ST provides a tool that can be used to download a program to the STM32 using this serial bootloader, but it only works in Windows. Their
+ bootloader protocol is documented in a separate application note though, so one can easily write a programming application for any other OS.&lt;/p&gt;
+ &lt;p&gt;&lt;b&gt;eLua&lt;/b&gt; currently works on two STM32F103 variants of the STM32 family, specifically on these boards:
+ &lt;a href=&quot;<A HREF="http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html">http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html</A>&quot;&gt;the STM3210E-EVAL&lt;/a&gt; from 
+ &lt;a href=&quot;<A HREF="http://www.st.com">http://www.st.com</A>&quot;&gt;ST&lt;/a&gt; and the 
+ &lt;a href=&quot;<A HREF="http://www.futurlec.com/ET-STM32_Stamp.shtml">http://www.futurlec.com/ET-STM32_Stamp.shtml</A>&quot;&gt;ETM-STM32 stamp&lt;/a&gt; 
+ from &lt;a href=&quot;<A HREF="http://www.futurlec.com">http://www.futurlec.com</A>&quot;&gt;Futurlec&lt;/a&gt;. Instruction for installing &lt;b&gt;eLua&lt;/b&gt; on each of them are provided below.
+ &lt;/p&gt;
+ &lt;h3&gt; Prerequisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the STM32F103 CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;you're using Windows. As already explained, the software provided by ST for serial firmware downloading works only under Windows. It's quite likely
+ that similar tools for Linux and other operating systems already exist or will be available shortly.&lt;/li&gt;
+ &lt;li&gt;you have installed the &quot;Flash loader demonstrator&quot; from &lt;a href=&quot;<A HREF="http://www.st.com/mcu/modules.php?name=mcu&amp;amp;file=familiesdocs&amp;amp;FAM=110">http://www.st.com/mcu/modules.php?name=mcu&amp;file=familiesdocs&amp;FAM=110</A>&quot;&gt;
+this page&lt;/a&gt; (look for it in the &quot;Software - PC&quot; section).&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the STM32F103 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;).&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;h3&gt;Programming eLUa on the STM3210E-EVAL board&lt;/h3&gt;
+ &lt;p&gt;##TODO&lt;/p&gt;
+ &lt;h3&gt;Programming eLua on the ET-STM32 stamp&lt;/h3&gt;
+ &lt;p&gt;Follow the steps below to install &lt;b&gt;eLua&lt;/b&gt; on your ET-STM32 stamp:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;connect the board to one of your PC serial ports using the provided serial cable.&lt;/li&gt;
+ &lt;li&gt;put the BOOT1 jumper on your board in the ISP position (it should come like that from the factory, and must likely you won't need to change this).&lt;/li&gt; 
+ &lt;li&gt;press on the BOOT0 switch. The green &quot;BOOT0=1&quot; LED should light up.&lt;/li&gt;
+ &lt;li&gt;reset the board by pressing on the RESET button.&lt;/li&gt;
+ &lt;li&gt;start the ST Flash loader demonstrator. Choose your serial port in the first screen, don't change the communication parameters (57600 8E1) and press &quot;Next&quot; 3 times.&lt;/li&gt;
+ &lt;li&gt;select the &quot;Download to device&quot; radio button, then choose your &lt;b&gt;eLua&lt;/b&gt; image file and hit &quot;Next&quot;.&lt;/li&gt;
+ &lt;li&gt;wait until programming is over and press &quot;Finish&quot;.&lt;/li&gt;
+ &lt;li&gt;press on the BOOT0 switch again.&lt;/li&gt;
+ &lt;li&gt;reset the board by pressing the RESET button again.&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;p&gt;Now you have &lt;b&gt;eLua&lt;/b&gt; installed on your board, and you can choose the same port you used for programming as a general purpose serial port for &lt;b&gt;eLua&lt;/b&gt;.&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing_str7.html
===================================================================
--- tags/pre0.6/doc/pt/installing_str7.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_str7.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,17 @@
+$$HEADER$$
+&lt;h3&gt;Installing &lt;b&gt;eLua&lt;/b&gt; on the STR7 CPU family from ST&lt;/h3&gt;
+ &lt;p&gt;&lt;a href=&quot;<A HREF="http://www.st.com/mcu/inchtml-pages-str7.html">http://www.st.com/mcu/inchtml-pages-str7.html</A>&quot;&gt;STR7&lt;/a&gt; is a family of ATM7TDMI based CPUs from &lt;a href=&quot;<A HREF="http://www.st.com">http://www.st.com</A>&quot;&gt;ST&lt;/a&gt;. They are small, low power MCUs, with a well balanced set of on-chip peripherals. I'm using the &lt;a href=&quot;<A HREF="http://www.sctec.com.br/content/view/101/30/">http://www.sctec.com.br/content/view/101/30/</A>&quot;&gt;MOD711&lt;/a&gt; header board from &lt;a href=&quot;<A HREF="http://www.sctec.com.br">http://www.sctec.com.br</A>&quot;&gt;ScTec&lt;/a&gt;. The board is 
+based on this STR711FR2 variant of the STR7 family. Since this is not a full-fledged development board, I had to add a few things around it: a MAX3232 RS232 to TTL converter for the serial interface, a couple of LEDs and a reset button. After that, the board was ready for some &lt;b&gt;eLua&lt;/b&gt; :) &lt;/p&gt;
+ &lt;h3&gt;Prerequisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the STR711FR2 CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;you're using Linux, Windows, or any other OS that has support for &lt;a href=&quot;<A HREF="http://openocd.berlios.de/web/">http://openocd.berlios.de/web/</A>&quot;&gt;OpenOCD&lt;/a&gt;. You might have a look at my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD tutorial&lt;/a&gt; before continuing.&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the STR711FR2 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;).&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;h3&gt;Burning &lt;b&gt;eLua&lt;/b&gt; to the MOD711 board&lt;/h3&gt;
+ &lt;p&gt;You need OpenOCD to do this. Just follow the instructions from my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD tutorial &lt;/a&gt;. On the tutorial page you'll also find links to the OpenOCD
+ configuration files that I'm using for burning &lt;b&gt;eLua&lt;/b&gt; to the MOD711 board. And that's it! &lt;b&gt;eLua&lt;/b&gt; is now programmed in the CPU, so you can start your terminal emulator and enjoy it, as described in &lt;a href=&quot;using.html&quot;&gt;using eLua&lt;/a&gt;.&lt;/p&gt;
+&lt;p&gt;&lt;b&gt;IMPORTANT NOTE&lt;/b&gt;: for this board you need to set your COM port speed to 38400 baud (as opposed to 115200 baud for the other boards). All the other parameters are the same (8 data bits,
+ no parity, one stop bit).&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/installing_str9.html
===================================================================
--- tags/pre0.6/doc/pt/installing_str9.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/installing_str9.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,25 @@
+$$HEADER$$
+&lt;h3&gt;Installing &lt;b&gt;eLua&lt;/b&gt; on the STR9 CPU family from ST&lt;/h3&gt;
+ &lt;p&gt;Among the ARM based MCUs available today, the &lt;a href=&quot;<A HREF="http://www.st.com/mcu/inchtml-pages-str9.html">http://www.st.com/mcu/inchtml-pages-str9.html</A>&quot;&gt;STR9&lt;/a&gt; CPUs from &lt;a href=&quot;<A HREF="http://www.st.com">http://www.st.com</A>&quot;&gt;ST&lt;/a&gt; stand up because of a few unique features.
+ First, their core is an ARM966-E, as opposed to the very popular ARM7TDMI core. This, together with some cleverly chosen on-chip hardware blocks, allows the CPU to run at 96MHz, which is very fast for a 
+ general purpose MCU. The particular CPU I'm using (STR912FAW44) ) also has 512k of flash (and another bank of 32k flash) and 96k of internal RAM, so you won't be running out of memory anytime soon. It is accompanied by a very good support library, 
+ and ST provides a lot of nice tools for STR9, including a graphical tool that you can use to configure the chip exactly how you want. When I wrote to ST about &lt;b&gt;eLua&lt;/b&gt;, they
+ agreed to send me a &lt;a href=&quot;<A HREF="http://www.hitex.com/str9-comstick/">http://www.hitex.com/str9-comstick/</A>&quot;&gt;STR9-comStick&lt;/a&gt; board to run &lt;b&gt;eLua&lt;/b&gt; on it. Thank you very much for your help, once again. This is the board that I'm going to
+ use through this tutorial.&lt;/p&gt;
+ &lt;h3&gt;Prerequisites&lt;/h3&gt; 
+ &lt;p&gt;Before you'll be able to use &lt;b&gt;eLua&lt;/b&gt; on the STR912FAW44 CPU, make sure that:&lt;/p&gt;
+ &lt;ul&gt;
+ &lt;li&gt;you're using Linux, Windows, or any other OS that has support for &lt;a href=&quot;<A HREF="http://openocd.berlios.de/web/">http://openocd.berlios.de/web/</A>&quot;&gt;OpenOCD&lt;/a&gt;. You might have a look at my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD tutorial&lt;/a&gt; before continuing.&lt;/li&gt;
+ &lt;li&gt;if you're on Windows, you have installed the STR9-comStick support package from the accompanying CD.&lt;/li&gt;
+ &lt;li&gt;you already have your &lt;b&gt;eLua&lt;/b&gt; image for the STR912FAW44 CPU (&lt;a href=&quot;building.html&quot;&gt;built&lt;/a&gt; or &lt;a href=&quot;downloads.html&quot;&gt;downloaded&lt;/a&gt;).&lt;/li&gt;
+ &lt;/ul&gt;
+ &lt;h3&gt;Burning &lt;b&gt;eLua&lt;/b&gt; to the STR9-comStick&lt;/h3&gt;
+ &lt;p&gt;You need OpenOCD to do this. Just follow the instructions from my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD tutorial &lt;/a&gt;. On the tutorial page you'll also find links to the OpenOCD
+ configuration files that I'm using for burning &lt;b&gt;eLua&lt;/b&gt; to the comstick.&lt;/p&gt;
+ &lt;p&gt;&lt;b&gt;IMPORTANT NOTE&lt;/b&gt;: for some very strage reasons (probably related to the on-board USB to JTAG converter) my comstick does NOT start to execute the code from its internal flash after being
+ powered up via the USB cable (faulty reset sequence?). To overcome this, you'll find a special OpenOCD configuration file on my &lt;a href=&quot;tut_openocd.html&quot;&gt;OpenOCD tutorial&lt;/a&gt; page. It is called &lt;i&gt;comrst.cfg&lt;/i&gt;,
+ and you can use it to reset your comstick after it is powered up.&lt;/p&gt;
+ &lt;p&gt;That's it! &lt;b&gt;eLua&lt;/b&gt; is now programmed in the CPU, so you can start your terminal emulator and enjoy it, as described in &lt;a href=&quot;using.html&quot;&gt;using eLua&lt;/a&gt;.
+&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/refman_gen.html
===================================================================
--- tags/pre0.6/doc/pt/refman_gen.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/refman_gen.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,6 @@
+$$HEADER$$
+&lt;h3&gt;Reference manual - generic modules&lt;/h3&gt;
+&lt;p&gt;This part of the reference manual presents the generic modules in &lt;b&gt;eLua&lt;/b&gt; (see &lt;a href=&quot;refman.html&quot;&gt;here&lt;/a&gt; for more information about generic
+modules).&lt;/p&gt;
+$$FOOTER$$
+

Added: tags/pre0.6/doc/pt/toolchains.html
===================================================================
--- tags/pre0.6/doc/pt/toolchains.html	2009-09-10 21:19:23 UTC (rev 425)
+++ tags/pre0.6/doc/pt/toolchains.html	2009-09-11 05:28:49 UTC (rev 426)
@@ -0,0 +1,170 @@
+$$HEADER$$
+&lt;h3&gt;Toolchains for eLua&lt;/h3&gt;
+&lt;p&gt;You need (at least) a toolchain if you decide to build &lt;b&gt;eLua&lt;/b&gt; yourself. The toolchain must contain at least a compiler, an assembler, a linker and (most likely) a tool to extract binary 
+   data from the compiled image (in order to build the actual firmware). Also, a program that reports the sizes of different sections in the compiled image is often used to give an idea about the 
+   resource consumption of &lt;b&gt;eLua&lt;/b&gt;. You can use as many toolchains as you want for a given target, as long as the build scripts know to handle them. This
+   section outlines the different toolchain choices available for compiling &lt;b&gt;eLua&lt;/b&gt;. Use the links below to navigate directly to your target of interest.&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;&lt;a href=&quot;#armcortex&quot;&gt;Toolchains for ARM and Cortex&lt;/a&gt;&lt;/li&gt;
+  &lt;li&gt;&lt;a href=&quot;#avr32&quot;&gt;Toolchains for AVR32&lt;/a&gt;&lt;/li&gt;
+  &lt;li&gt;&lt;a href=&quot;#i386&quot;&gt;Toolchains for i386&lt;/a&gt;&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;If you have a different toolchain, reffer to the &lt;a href=&quot;#configuration&quot;&gt;toolchain configuration&lt;/a&gt; paragraph in this document.&lt;/p&gt;
+&lt;a name=&quot;armcortex&quot;&gt;&lt;h2&gt;Toolcains for ARM and Cortex&lt;/h2&gt;&lt;/a&gt;
+&lt;p&gt;You have multiple options when building &lt;b&gt;eLua&lt;/b&gt; for ARM and Cortex CPUs:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;build your own toolchain. Even if you have a toolchain already available, you might want to do this for maximum flexibility and control (for example to control the libc build flags, or to
+      use specific version of the tools). Check &lt;a href=&quot;#&quot;&gt;##this link&lt;/a&gt; for a step by step tutorial on building your own toolchain.&lt;/li&gt;
+  &lt;li&gt;use a readily available toolchain. This saves you the hassle of building the toolchain yourself, which makes the process quicker and less error-prone.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;Because building a toolchain is already covered in another section of the documentation, we'll focus on installing a pre-compiled toolchain here. ARM is a very popular architecture, and because
+of this there are a lot of toolchains available for download free of charge. One of the most popular ones comes from &lt;a href=&quot;<A HREF="http://www.codesourcery.com">http://www.codesourcery.com</A>&quot;&gt;CodeSourcery&lt;/a&gt;, and we'll cover it here for a number of important reasons:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;it has support for both &quot;traditional&quot; ARM targets and Cortex-M3 (Thumb2) targets&lt;/li&gt;
+  &lt;li&gt;it comes with user-friendly installers for both Linux and Windows&lt;/li&gt;
+  &lt;li&gt;it has fairlygood documentation&lt;/li&gt;
+  &lt;li&gt;&lt;b&gt;eLua&lt;/b&gt; supports this toolchain for all its ARM and Cortex targets&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;Obtaining and installing the toolchain is very easy:&lt;/p&gt;
+&lt;ol&gt;
+  &lt;li&gt;go to &lt;a href=&quot;<A HREF="http://www.codesourcery.com/sgpp/lite/arm/portal/subscription?@template=lite">http://www.codesourcery.com/sgpp/lite/arm/portal/subscription?@template=lite</A>&quot;&gt;the CodeSourcery download location&lt;/a&gt; for the toolchain.&lt;/li&gt;
+  &lt;li&gt;select from the table the current version in the &quot;EABI&quot; line (the link to the current version is just above the &quot;All versions...&quot; link).&lt;/li&gt;
+  &lt;li&gt;download and run the installer.&lt;/li&gt;
+&lt;/ol&gt;
+&lt;p&gt;That's all! Make sure that the location of the toolchain is in your $PATH and build &lt;b&gt;eLua&lt;/b&gt; with the &lt;b&gt;toolchain=codesourcery&lt;/b&gt; option.&lt;/p&gt;
+&lt;a name=&quot;avr32&quot;&gt;&lt;h2&gt;Toolchains for AVR32&lt;/h2&gt;&lt;/a&gt;
+&lt;p&gt;Currently you have only one option for AVR32: download and install the toolchain from &lt;a href=&quot;<A HREF="http://www.atmel.com">http://www.atmel.com</A>&quot;&gt;Atmel&lt;/a&gt;. Unfortuntely they don't provide an installer, just a bunch of 
+   Linux packages with some dependencies, so the installation process might be a bit tricky. These are the steps you should follow to install Atmel's AVR32 toolchain:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;download the correct version for your Linux distribution (in this case Ubuntu) from &lt;a href=&quot;<A HREF="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4118">http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4118</A>&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
+  &lt;li&gt;unzip the downloaded archive to a temporary directory, you'll get a bunch of .deb packages&lt;/li&gt;
+  &lt;li&gt;install the packages from this command line (the package names are based on version 2.1.4 of the toolchain, change them as needed if you're using a different version):
+  &lt;pre&gt;&lt;code&gt;$ sudo dpkg -i libavr32ocd1_3.0.9-1_i386.deb libavr32sim_0.2.1-1_i386.deb 
+$ sudo dpkg -i libavrtools1_3.0.9-1_i386.deb libelfdwarfparser_2.0.7-1_i386.deb
+$ sudo dpkg -i avr32headers_1.9.11-1_all.deb
+$ sudo dpkg -i avr32parts_1.9.9-1_all.deb
+$ sudo dpkg -i avr32-binutils_2.17.atmel.1.2.6-2_i386
+$ sudo dpkg -i avr32-gcc-newlib_4.2.2-atmel.1.0.8-2_i386.deb
+$ sudo dpkg -i avr32program_3.0.4-1_i386.deb&lt;/code&gt;&lt;/pre&gt;
+  If dpkg complains about missing dependencies, install them as required and resume the installation process.
+  &lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;That's it. Your toolchain is already be in $PATH (since it installs itself in /usr/bin) so you should be ready to build &lt;b&gt;eLua&lt;/b&gt; for AVR32.&lt;/p&gt;
+&lt;a name=&quot;i386&quot;&gt;&lt;h2&gt;Toolchains for i386&lt;/h2&gt;&lt;/a&gt;
+&lt;p&gt;Currently the only tested procedure for building &lt;b&gt;eLua&lt;/b&gt; for i386 is to &lt;a href=&quot;&quot;&gt;##build an i386 toolchain&lt;/a&gt;. Other toolchains might work equally well though, but none was tested so far.
+&lt;/p&gt;
+&lt;a name=&quot;configuration&quot;&gt;&lt;h3&gt;Toolchain configuration in eLua &lt;span style=&quot;color: red;&quot;&gt;(WIP)&lt;/span&gt;&lt;/h3&gt;&lt;/a&gt;
+&lt;p&gt;The &lt;b&gt;eLua&lt;/b&gt; build system makes provisions for specifying an unlimited number of toolchains for a given target, selectable via the scons &lt;b&gt;toolchain=...&lt;/b&gt; option. The default structure
+   of each of the toolchains supported by default is listed in the table below.&lt;/p&gt;
+&lt;table class=&quot;table_center&quot;&gt;
+&lt;tbody&gt;
+&lt;tr&gt;
+  &lt;th&gt;Toolchain&lt;/th&gt;
+  &lt;th style=&quot;text-align:center;&quot; rowspan=&quot;2&quot;&gt;Name&lt;/th&gt;
+  &lt;th style=&quot;text-align:center;&quot; rowspan=&quot;2&quot;&gt;Compiler&lt;/th&gt;
+  &lt;th style=&quot;text-align:center;&quot; rowspan=&quot;2&quot;&gt;Linker&lt;/th&gt;
+  &lt;th style=&quot;text-align:center;&quot; rowspan=&quot;2&quot;&gt;Assembler&lt;/th&gt;
+  &lt;th style=&quot;text-align:center;&quot; rowspan=&quot;2&quot;&gt;Size tool&lt;/th&gt;
+  &lt;th style=&quot;text-align:center;&quot; rowspan=&quot;2&quot;&gt;Image copy tool&lt;/th&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td&gt;Platform&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td style=&quot;color: rgb(255, 102, 0);&quot;&gt;ARM (ELF)&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-ld&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-as&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-size&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-objcopy&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td style=&quot;color: rgb(255, 102, 0);&quot;&gt;ARM (EABI)&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;codesourcery&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-ld&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-as&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-size&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-objcopy&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td style=&quot;color: rgb(255, 102, 0);&quot;&gt;Cortex (ELF)&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-ld&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-as&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-size&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-elf-objcopy&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td style=&quot;color: rgb(255, 102, 0);&quot;&gt;Cortex (EABI)&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;codesourcery&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-ld&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-as&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-size&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;arm-none-eabi-objcopy&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td style=&quot;color: rgb(255, 102, 0);&quot;&gt;AVR32&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;avr32-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;avr32-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;avr32-ld&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;avr32-s&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;avr32-size&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;avr32-objcopy&lt;/td&gt;
+&lt;/tr&gt;
+&lt;tr&gt;
+  &lt;td style=&quot;color: rgb(255, 102, 0);&quot;&gt;i386&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;i686-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;i686-elf-gcc&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;i686-elf-ld&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;nasm&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;i686-elf-size&lt;/td&gt;
+  &lt;td style=&quot;text-align:center;&quot;&gt;i686-elf-objcopy&lt;/td&gt;
+&lt;/tr&gt;
+&lt;/tbody&gt;
+&lt;/table&gt;
+
+&lt;p&gt;If you need to add a new toolchain or modify an existing one, take a look at the scons build script (SConstruct). A toolchain-related fragment of SConstruct is shown below:&lt;/p&gt;
+&lt;pre&gt;&lt;code&gt;# List of toolchains
+toolchain_list = {
+  &lt;b&gt;# This defines a toolchain with the name &quot;arm-elf&quot;&lt;/b&gt;
+  'arm-gcc' : { 
+      'compile' : 'arm-elf-gcc', 
+      'link' : 'arm-elf-ld', 
+      'asm' : 'arm-elf-as', 
+      'bin' : 'arm-elf-objcopy', 
+      'size' : 'arm-elf-size' 
+  },
+  &lt;b&gt;# Another toolchain, this time called &quot;codesourcery&quot;&lt;/b&gt;
+  'codesourcery' : { 
+    'compile' : 'arm-none-eabi-gcc', 
+    'link' : 'arm-none-eabi-ld', 
+    'asm' : 'arm-none-eabi-as', 
+    'bin' : 'arm-none-eabi-objcopy', 
+    'size' : 'arm-none-eabi-size' 
+  },
+................  
+}
+
+# List of platform/CPU/toolchains combinations
+# The first toolchain in the toolchains list is the default one
+# (the one that will be used if none is specified)
+platform_list = {  
+  'at91sam7x' : { 'cpus' : [ 'AT91SAM7X256', 'AT91SAM7X512' ], &lt;b&gt;'toolchains' : [ 'arm-gcc', 'codesourcery' ]&lt;/b&gt; },
+  'lm3s' : { 'cpus' : [ 'LM3S8962', 'LM3S6965', 'LM3S6918' ], &lt;b&gt;'toolchains' : [ 'arm-gcc', 'codesourcery' ]&lt;/b&gt; },
+  ................
+}&lt;/code&gt;&lt;/pre&gt;
+&lt;p&gt;From this fragment it's easy to undertand that there are at most two places in SConstruct that must be taken into account when dealing with toolchain:&lt;/p&gt;
+&lt;ul&gt;
+  &lt;li&gt;the definition of &lt;b&gt;toolchain_list&lt;/b&gt;. This is a list of all the supported toolchains with all their relevant components (compiler, linker, assembler, image copy tool and size tool).&lt;/li&gt;
+  &lt;li&gt;each &lt;b&gt;eLua&lt;/b&gt; platform has a list of permitted toolchains (only the toolchains specified in this list can be used to build an &lt;b&gt;eLua&lt;/b&gt; image for that target). The first element of 
+      this list will be automatically used if a &lt;b&gt;toolchain=...&lt;/b&gt; option is not specified on the command line.&lt;/li&gt;
+&lt;/ul&gt;
+&lt;p&gt;Please note that in order to add a new toolchain to &lt;b&gt;eLua&lt;/b&gt; it's generally not enough to edit just SConstruct. As different toolchains have different command line options, one should also
+   edit the platform's build configuration file (&lt;i&gt;src/platform/&lt;platform name&gt;/conf.py&lt;/i&gt;) and make it aware of the new toolchain. The exact procedure for doing this is highly dependent on
+   the toolchain and it's well beyond the scope of this tutorial.&lt;/p&gt;
+$$FOOTER$$
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000381.html">[Elua-svn] r425 - tags/pre0.6/doc
</A></li>
	<LI>Next message: <A HREF="000383.html">[Elua-svn] r427 - in tags/pre0.6/doc: . en pt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#382">[ date ]</a>
              <a href="thread.html#382">[ thread ]</a>
              <a href="subject.html#382">[ subject ]</a>
              <a href="author.html#382">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
