<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r529 - in branches/eagle_mmc: doc doc/eluadoc doc/luadoc	doc/wb src/lua src/modules
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r529%20-%20in%20branches/eagle_mmc%3A%20doc%20doc/eluadoc%20doc/luadoc%0A%09doc/wb%20src/lua%20src/modules&In-Reply-To=%3C200911060210.nA62ARUR030400%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000483.html">
   <LINK REL="Next"  HREF="000485.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r529 - in branches/eagle_mmc: doc doc/eluadoc doc/luadoc	doc/wb src/lua src/modules</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r529%20-%20in%20branches/eagle_mmc%3A%20doc%20doc/eluadoc%20doc/luadoc%0A%09doc/wb%20src/lua%20src/modules&In-Reply-To=%3C200911060210.nA62ARUR030400%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r529 - in branches/eagle_mmc: doc doc/eluadoc doc/luadoc	doc/wb src/lua src/modules">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Fri Nov  6 03:10:27 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000483.html">[Elua-svn] r528 - in branches/eagle_mmc/src: . platform/lm3s	platform/stm32
</A></li>
        <LI>Next message: <A HREF="000485.html">[Elua-svn] r530 - in branches/eagle_mmc/src: . platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#484">[ date ]</a>
              <a href="thread.html#484">[ thread ]</a>
              <a href="subject.html#484">[ subject ]</a>
              <a href="author.html#484">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-11-06 03:10:25 +0100 (Fri, 06 Nov 2009)
New Revision: 529

Removed:
   branches/eagle_mmc/doc/build_dist_doc.sh
   branches/eagle_mmc/doc/builddoc.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_adc.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_cpu.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_eth.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_ll.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_pio.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_pwm.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_spi.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_timers.lua
   branches/eagle_mmc/doc/luadoc/arch_platform_uart.lua
   branches/eagle_mmc/doc/luadoc/refman_gen_adc.lua
   branches/eagle_mmc/doc/luadoc/refman_gen_bit.lua
   branches/eagle_mmc/doc/luadoc/refman_gen_cpu.lua
   branches/eagle_mmc/doc/luadoc/refman_gen_pack.lua
   branches/eagle_mmc/doc/luadoc/refman_gen_pd.lua
   branches/eagle_mmc/doc/luadoc/refman_gen_pwm.lua
   branches/eagle_mmc/doc/luadoc/refman_gen_tmr.lua
   branches/eagle_mmc/doc/luadoc/template.lua
   branches/eagle_mmc/doc/wb/wb_usr_template.lua
Modified:
   branches/eagle_mmc/doc/eluadoc/refman_gen_uart.lua
   branches/eagle_mmc/src/lua/ldo.c
   branches/eagle_mmc/src/lua/lgc.c
   branches/eagle_mmc/src/lua/lgc.h
   branches/eagle_mmc/src/lua/lobject.h
   branches/eagle_mmc/src/lua/lvm.c
   branches/eagle_mmc/src/lua/lzio.h
   branches/eagle_mmc/src/modules/uart.c
Log:
Merge remote branch 'remotes/trunk' into local_mmc

Deleted: branches/eagle_mmc/doc/build_dist_doc.sh
===================================================================
--- branches/eagle_mmc/doc/build_dist_doc.sh	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/build_dist_doc.sh	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,54 +0,0 @@
-#!/bin/bash
-# Builds a full documentation package in the &quot;dist/&quot; directory
-
-# Delete and recreate directory
-rm -rf dist
-mkdir dist
-
-# Build platform docs
-lua builddoc.lua
-if [ $? -ne 0 ]
-then
-  exit
-fi
-cd wb
-lua wb_build.lua
-cd ..
-
-# Copy the required files to the dist/ directory
-for lang in en pt
-do
-  cp -R $lang/ dist/
-done
-cp -R wb_img dist/
-for f in wb*.html style.css index*.html
-do
-  echo Copying $f...
-  cp $f dist/
-done
-cp dist/index_en.html dist/index.html
-
-# Remove all version data from dist
-find dist/ -name &quot;.svn&quot; | xargs rm -rf
-
-if [ &quot;$1&quot; != &quot;noclean&quot; ]
-then
-  # Remove unneeded files from base dir
-  echo
-  echo &quot;Cleaning up...&quot;
-  for lang in en pt
-  do
-    rm -f $lang/arch_platform_*.html
-    rm -f $lang/refman_gen_*.html
-  done
-  rm -f index_*.html wb/wb_usr.lua ssSearch*.html wb_bar_*.html
-  rm -f wb_search*.txt wb_title*.html wb_tree*.html
-else
-  echo
-  echo &quot;NOT cleaning base directory!&quot;
-fi
-
-# All done
-echo
-echo &quot;DONE! Enjoy your documentation in dist/ :)&quot;
-

Deleted: branches/eagle_mmc/doc/builddoc.lua
===================================================================
--- branches/eagle_mmc/doc/builddoc.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/builddoc.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,374 +0,0 @@
--- eLua doc builder tool 
-
--- List here all the sections for which we're generating the documentation
-local doc_sections = { &quot;arch_platform&quot;, &quot;refman_gen&quot; }
-
--- List here all the components of each section
-local components = 
-{ 
-  arch_platform = { &quot;ll&quot;, &quot;pio&quot;, &quot;spi&quot;, &quot;uart&quot;, &quot;timers&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;eth&quot;, &quot;adc&quot; },
-  refman_gen = { &quot;bit&quot;, &quot;pd&quot;, &quot;pack&quot;, &quot;tmr&quot;, &quot;pwm&quot;, &quot;cpu&quot;, &quot;adc&quot; }
-}
-
--- List here all languages for the documentation (make sure to keep English (&quot;en&quot;) the first one)
-local languages = { &quot;en&quot;, &quot;pt&quot; }
--- Also list here the translation for a bunch of fixed strings
-local overview_tr = { en = &quot;Overview&quot;, pt = &quot;##Overview&quot; }
-local structures_tr = { en = &quot;Data structures&quot;, pt = &quot;##Data structures&quot; }
-local functions_tr = { en = &quot;Functions&quot;, pt = &quot;##Functions&quot; }
-
--- Format a name to a link by changing all the spaces to &quot;_&quot; and
--- making all letters lowercase
-local function name2link( str )
-  str = str:gsub( &quot; &quot;, &quot;_&quot; )
-  return str:lower()
-end
-
--- Returns the part of the string enclosed between two '#' chars
--- Used for parsing function sig. 
-local function namefromsig( str )
-  local _, _, name = str:find( &quot;#(.*)#&quot; )
-  return name
-end
-
---[[ Process the given string as follows:
-- $string$ becomes &lt;b&gt;string&lt;/b&gt;
-- %string% becomes &lt;i&gt;string&lt;/i&gt;
-- @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ref at text</A>@ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
-- ^ref^text^ becomes &lt;a target=&quot;_blank&quot; href=&quot;ref&quot;&gt;text&lt;/a&gt;
-- $$, %%, @@, ^^ become $, %, @, ^ respectively
-- the string &quot;eLua&quot; becomes &lt;b&gt;eLua&lt;/b&gt;
-- strings between two tildas (~~) get special code-like formatting
-- newlines are changed to ' ' if 'keepnl' isn't true
-- '&amp;' is translated to its corresponding HTML code.
-- '&lt;&lt;' and '&gt;&gt;&quot; are also translated to the corresponding HTML codes (note the repetition).
---]]
-local function format_string( str, keepnl )
-  -- replace double &quot;special chars&quot; with &quot;temps&quot; for later use
-  str = str:gsub( &quot;%$%$&quot;, &quot;\001&quot; )
-  str = str:gsub( &quot;%%%%&quot;, &quot;\002&quot; )
-  str = str:gsub( &quot;@@&quot;, &quot;\003&quot; )
-  str = str:gsub( &quot;%^%^&quot;, &quot;\004&quot; )
-  str = str:gsub( &quot;~~&quot;, &quot;\005&quot; )
-
-   -- Translate 'special' HTML chars to their equivalents
-  local tr_table = 
-  {
-    [ &quot;%&amp;&quot; ] = &quot;&amp;&quot;,
-  }
-  for char, rep in pairs( tr_table ) do
-    str = str:gsub( char, rep )
-  end
-
-  -- some double chars are replaced directly with their HTML codes
-  str = str:gsub( &quot;&lt;&lt;&quot;, &quot;&lt;&quot; )
-  str = str:gsub( &quot;&gt;&gt;&quot;, &quot;&gt;&quot; )
-
-  -- replace eLua with &lt;b&gt;eLua&lt;/b&gt;
-  str = str:gsub( &quot;eLua&quot;, &quot;&lt;b&gt;eLua&lt;/b&gt;&quot; )
-
-  -- $string$ becomes &lt;b&gt;string&gt;&lt;/b&gt;
-  str = str:gsub( &quot;%$([^%s%$][^%$]*)%$&quot;, &quot;&lt;b&gt;%1&lt;/b&gt;&quot; )
-
-  -- %string% becomes &lt;i&gt;string&lt;/i&gt;
-  str = str:gsub( &quot;%%([^%s%%][^%%]*)%%&quot;, &quot;&lt;i&gt;%1&lt;/i&gt;&quot; )
-
-  -- @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ref at text</A>@ becomes &lt;a href=&quot;ref&quot;&gt;text&lt;/a&gt;
-  str = str:gsub( &quot;@([^%s@][^@]*)@([^%s@][^@]*)@&quot;, '&lt;a href=&quot;%1&quot;&gt;%2&lt;/a&gt;' )
-
-  -- ^ref^text^ becomes &lt;a target=&quot;_blank&quot; href=&quot;ref&quot;&gt;text&lt;/a&gt;
-  str = str:gsub( &quot;%^([^%s%^][^%^]*)%^([^%s%^][^%^]*)%^&quot;, '&lt;a target=&quot;_blank&quot; href=&quot;%1&quot;&gt;%2&lt;/a&gt;' )
-
-  -- strings between two tildas (~~) get special code-like formatting
-  str = str:gsub( &quot;~([^%s~][^~]*)~&quot;, function( x )
-    x = x:gsub( &quot;\n&quot;, &quot;&lt;br&gt;&quot; )
-    x = x:gsub( &quot;%s%s+&quot;, function( x ) return ( &quot;&nbsp;&quot; ):rep( #x ) end )
-    return &quot;&lt;p&gt;&lt;code&gt;&quot; .. x .. &quot;&lt;/code&gt;&lt;/p&gt;&quot;
-  end )
-  str = str:gsub( &quot;~~&quot;, &quot;~&quot; )
-
-  -- other &quot;\n&quot; chars should dissapear now
-  if not keepnl then  str = str:gsub( &quot;\n&quot;, &quot; &quot; ) end
-
-  -- put back the &quot;temps&quot;
-  str = str:gsub( &quot;\001&quot;, &quot;%$&quot; )
-  str = str:gsub( &quot;\002&quot;, &quot;%%&quot; )
-  str = str:gsub( &quot;\003&quot;, &quot;@&quot; )
-  str = str:gsub( &quot;\004&quot;, &quot;%^&quot; )
-  str = str:gsub( &quot;\005&quot;, &quot;~&quot; )
-
-  -- all done
-  return str
-end
-
-local header = [[
-&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Strict//EN&quot;&gt;
-&lt;html&gt;&lt;head&gt;
-&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;
-&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en-us&quot;&gt;&lt;title&gt;%s&lt;/title&gt;
-
-&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;
-&lt;body style=&quot;background-color: rgb(255, 255, 255);&quot;&gt;]]
-
--- Build the documentation starting from the given file
-local function build_file( fname )
-  dofile( fname )
-  local res = {}
-
-  for _, lang in pairs( languages ) do
-    res[ lang ] = {}
-    res[ lang ].wb = {}
-    local wb = res[ lang ].wb
-    
-    -- we need english always
-    -- the other languages will be substituted with english if not found
-    local resname = string.format( &quot;data_%s&quot;, lang )
-    local r = _G[ resname ]
-    if not r then
-      if lang == &quot;en&quot; then
-        return false, &quot;data_en must exist in the description&quot;
-      else
-        print( string.format( &quot;'%s': data for language '%s' not found, defaulting to english&quot;, fname, lang ) )
-        r = _G[ &quot;data_en&quot; ]
-      end
-    end
-
-    -- process names
-    if not r.menu_name then
-      return false, &quot;menu_names not found&quot;
-    end
-    wb.name = r.menu_name
-
-    -- process title
-    if not r.title then
-      return false, &quot;title not found&quot;
-    end
-    local page = header:format( r.title ) .. &quot;\n\n&quot;
-
-    -- process overview
-    if not r.overview then
-      return false, &quot;overview not found&quot;
-    end
-    page = page .. '&lt;a name=&quot;overview&quot;&gt;&lt;h3&gt;Overview&lt;/h3&gt;&lt;/a&gt;\n&lt;p&gt;' .. format_string( r.overview ) .. &quot;&lt;/p&gt;\n\n&quot;
-
-    -- process structures if needed
-    if r.structures then
-      local structures = r.structures
-      wb.structs = {}
-      page = page .. '&lt;a name=&quot;structures&quot;&gt;&lt;h3&gt;Data structures, constants and types&lt;/h3&gt;&lt;/a&gt;\n'
-      for i = 1, #structures do
-        local s = structures[ i ]
-        wb.structs[ #wb.structs + 1 ] = s.name
-        if not s.text or not s.desc or not s.name then
-          return false, &quot;structure without text, desc or name fields&quot;
-        end
-        -- text/name. The link name is ALWAYS the one in ENGLISH.
-        page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', name2link( res.en.wb.structs[ i ] ) )
-        page = page .. &quot;&lt;p&gt;&lt;pre&gt;&lt;code&gt;&quot; .. format_string( s.text, true ) .. &quot;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&quot;
-        page = page .. &quot;&lt;/a&gt;&quot;
-        -- description
-        page = page .. &quot;\n&lt;p&gt;&quot; .. format_string( s.desc ) .. &quot;&lt;/p&gt;\n\n&quot;
-      end 
-    end
-
-    -- process functions now
-    if not r.funcs then
-      return false, &quot;funcs not found&quot;
-    end
-    local funcs = r.funcs
-    page = page .. '&lt;a name=&quot;funcs&quot;&gt;&lt;h3&gt;Functions&lt;/h3&gt;&lt;/a&gt;\n'
-    wb.funcs = {}
-    for i = 1, #funcs do
-      local f = funcs[ i ]
-      if not f.sig or not f.desc then
-        return false, &quot;function without sig or desc fields&quot;
-      end
-      local funcname = namefromsig( f.sig )
-      if not funcname then
-        return false, string.format( &quot;'%s' should contain the function name between '*' chars&quot;, f.sig )
-      end
-      wb.funcs[ #wb.funcs + 1 ] = funcname
-      -- signature
-      page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', funcname )
-      page = page .. &quot;&lt;p&gt;&lt;pre&gt;&lt;code&gt;&quot; .. f.sig:gsub( '#', '' ) .. &quot;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&quot;
-      page = page .. &quot;&lt;/a&gt;&quot;
-      -- description
-      page = page .. &quot;\n&lt;p&gt;&quot; .. format_string( f.desc ) .. &quot;&lt;/p&gt;\n&quot;
-      -- arguments
-      page = page .. &quot;&lt;p&gt;&lt;b&gt;Arguments&lt;/b&gt;: &quot;
-      if f.args then
-        local a = f.args
-        if type( a ) == &quot;string&quot; or ( type( a ) == &quot;table&quot; and #a == 1 ) then
-          local text = type( a ) == &quot;string&quot; and a or a[ 1 ]
-          page = page .. format_string( text )
-        else
-          page = page .. &quot;\n&lt;ul&gt;\n&quot;
-          for i = 1, #a do page = page .. &quot;  &lt;li&gt;&quot; .. format_string( a[ i ] ) .. &quot;&lt;/li&gt;\n&quot; end
-          page = page .. &quot;&lt;/ul&gt;&quot;
-        end
-      else
-        page = page .. &quot;none&quot;
-      end
-      page = page .. &quot;&lt;/p&gt;\n&quot;
-      -- return value
-      page = page .. &quot;&lt;p&gt;&lt;b&gt;Returns&lt;/b&gt;: &quot;
-      if f.ret then
-        local r = f.ret
-        if type( r ) == &quot;string&quot; or ( type( r ) == &quot;table&quot; and #r == 1 ) then
-          local text = type( r ) == &quot;string&quot; and r or r[ 1 ]
-          page = page .. format_string( text )
-        else
-          page = page .. &quot;\n&lt;ul&gt;\n&quot;
-          for i = 1, #r do page = page .. &quot;  &lt;li&gt;&quot; .. format_string( r[ i ] ) .. &quot;&lt;/li&gt;\n&quot; end
-          page = page .. &quot;&lt;/ul&gt;&quot;
-        end
-      else
-        page = page .. &quot;nothing&quot;
-      end
-      page = page .. &quot;&lt;/p&gt;\n\n&quot;
-    end
-
-    -- aux data (if any)
-    if r.auxdata then
-      local auxdata = r.auxdata
-      wb.auxdata = {}
-      for i = 1, #auxdata do
-        local a = auxdata[ i ]
-        wb.auxdata[ #wb.auxdata + 1 ] = a.title
-        if not a.title or not a.desc then
-          return false, &quot;auxdata without title or desc&quot;
-        end
-        -- the link name is ALWAYS the one in ENGLISH
-        page = page .. string.format( '&lt;a name=&quot;%s&quot;&gt;', name2link( res.en.wb.auxdata[ i ] ) )
-        page = page .. &quot;&lt;h3&gt;&quot; .. a.title .. &quot;&lt;/h3&gt;&quot;
-        page = page .. &quot;&lt;/a&gt;&quot;
-        page = page .. &quot;\n&lt;p&gt;&quot; .. format_string( a.desc ) .. &quot;&lt;/p&gt;\n\n&quot;
-      end
-    end
-
-    -- footer
-    page = page .. &quot;&lt;/body&gt;&lt;/html&gt;\n&quot;
-    res[ lang ].page = page
-  end
-  return res
-end
-
--- Helper function to get strings in all languages when needed
-local function alllangs( getstr )
-  local str =  &quot;name = {&quot;
-  for _, lang in pairs( languages ) do
-    str = str .. string.format( ' %s = &quot;%s&quot;,', lang, getstr( lang ) )
-  end
-  return str .. &quot; }&quot;
-end
-
--- Transform the data from the wb dictionary (in 'fulldata') for module 'modname' to a wb string, for section 'sect'
-local function wb2str( fulldata, modname, sect )
-  local relfname = sect .. &quot;_&quot; .. modname .. &quot;.html&quot;
-  local res = fulldata[ modname ]
-  local wbstr = string.format( '    { %s,\n      link = &quot;%s&quot;,\n      folder =\n      {\n', alllangs( function( x ) return res[ x ].wb.name end ), relfname )
-
-  -- Overview
-  wbstr = wbstr .. string.format( '        { %s,\n          link = &quot;%s#overview&quot;\n        },\n', alllangs( function( x ) return overview_tr[ x ] end ), relfname )
-
-  -- Data structures (if needed)
-  if res.en.wb.structs then
-    wbstr = wbstr .. string.format( '        { %s,\n          link = &quot;%s#structures&quot;,\n          folder =\n          {\n', alllangs( function( x ) return structures_tr[ x ] end ), relfname )
-    for i = 1, #res.en.wb.structs do
-      local v = res.en.wb.structs[ i ]
-      wbstr = wbstr .. string.format( '            { %s,\n              link = &quot;%s#%s&quot;,\n            },\n', alllangs( function( x ) return res[ x ].wb.structs[ i ] end ), relfname, name2link( v ) )
-    end
-    wbstr = wbstr .. &quot;          }\n        },\n&quot;
-  end
-
-  -- Functions
-  wbstr = wbstr .. string.format( '        { %s,\n          link = &quot;%s#funcs&quot;,\n          folder =\n          {\n', alllangs( function( x ) return functions_tr[ x ] end ), relfname )
-  for _, v in pairs( res.en.wb.funcs ) do
-    wbstr = wbstr .. string.format( '            { name = { en = &quot;%s&quot;, pt = &quot;%s&quot; },\n              link = &quot;%s#%s&quot;,\n            },\n', v, v, relfname, name2link( v ) )
-  end
-  wbstr = wbstr .. &quot;          }\n        },\n&quot;
-
-  -- Aux data (if needed)
-  if res.en.wb.auxdata then
-    for i = 1, #res.en.wb.auxdata do
-      local v = res.en.wb.auxdata[ i ]
-      wbstr = wbstr .. string.format(  '        { %s,\n          link = &quot;%s#%s&quot;\n        },\n', alllangs( function( x ) return res[ x ].wb.auxdata[ i ] end ), relfname, name2link( v ) )
-    end
-  end
-
-  -- Close the structure and return
-  wbstr = wbstr .. &quot;      }\n    },\n&quot;
-  return wbstr
-end
-
--- Read our complete template for wb_usr.lua
-local wbloc = &quot;wb/wb_usr_template.lua&quot;
-local realwbloc = &quot;wb/wb_usr.lua&quot;
-local wbf = io.open( wbloc, &quot;rb&quot; )
-if not wbf then
-  print( string.format( &quot;Cannot open %s for reading&quot;, wbloc ) )
-  return 1
-end
-local wbdata = wbf:read( &quot;*a&quot; )
-wbf:close()
--- Open the actual wb_usr.lua in write mode
-local realwbf = io.open( realwbloc, &quot;wb&quot; )
-if not realwbf then
-  print( string.format( &quot;Cannot open %s for writing&quot;, realwbloc ) )
-  return 1
-end
-
--- Generate documentation for each section in part
-for _, section in pairs( doc_sections ) do 
-
-  -- Check for pattern in wb_usr_template.lua
-  local pattern = &quot;%$%$&quot; .. section:upper() .. &quot;%$%$&quot;
-  if not wbdata:find( pattern ) then
-    print( string.format( &quot;$$%s$$ not found in wb_usr_template.lua&quot;, section:upper(), modname ) )
-    return 1
-  end
-
-  -- Generate documentation for each module in turn
-  local fulldata = {}
-  for _, modname in pairs( components[ section ] ) do
-    local descfname = string.format( &quot;luadoc/%s_%s.lua&quot;, section, modname )
-    local res, err = build_file( descfname )
-    if res then
-      fulldata[ modname ] = res
-      -- Write doc for each language
-      for _, lang in pairs( languages ) do
-        local fname = string.format( &quot;%s/%s_%s.html&quot;, lang, section, modname )
-        local f = io.open( fname, &quot;wb&quot; )
-        if not f then
-          print( string.format( &quot;Unable to open %s for writing&quot;, fname ) )
-          return 1
-        else
-          f:write( res[ lang ].page )
-          f:close()
-          print( ( &quot;Wrote %s&quot; ):format( fname ) )
-        end
-      end
-    else
-      print( string.format( &quot;Error processing module '%s': %s&quot;, modname, err ) )
-      return 1
-    end
-    print &quot;&quot;
-  end 
-
-  -- Now it's finally time to get our wb/wb_usr.lua
-  local fullwb = ''
-  for _, modname in pairs( components[ section ] ) do
-    local wbstr = wb2str( fulldata, modname, section )
-    fullwb = fullwb .. wbstr
-  end
-
-  -- Substitute our pattern and write everything back to disk
-  wbdata = wbdata:gsub( pattern, fullwb )
-end
-
--- Write wb_usr.lua to disk (finally)
-realwbf:write( wbdata )
-realwbf:close()
-
-print &quot;All done, remember to run 'lua wb_build.lua' in the 'wb' directory to build your navigation tree&quot;
-

Modified: branches/eagle_mmc/doc/eluadoc/refman_gen_uart.lua
===================================================================
--- branches/eagle_mmc/doc/eluadoc/refman_gen_uart.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/eluadoc/refman_gen_uart.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -30,13 +30,13 @@
     },
 
     { sig = &quot;#uart.write#( id, data1, [data2], ..., [datan] )&quot;,
-      desc = [[Write one or more strings or numbers to the serial port. If writing a number, its value must be between 0 and 255.]],
+      desc = [[Write one or more strings or 8-bit integers (raw data) to the serial port. If writing raw data, its value (represented by an integer) must be between 0 and 255.]],
       args = 
       {
         &quot;$id$ - the ID of the serial port.&quot;,
-        &quot;$data1$ - the first string/number to write.&quot;,
-        &quot;$data2 (optional)$ - the second string/number to write.&quot;,
-        &quot;$datan (optional)$ - the %n%-th string/number to write.&quot;
+        &quot;$data1$ - the first string/8-bit integer to write.&quot;,
+        &quot;$data2 (optional)$ - the second string/8-bit integer to write.&quot;,
+        &quot;$datan (optional)$ - the %n%-th string/8-bit integer to write.&quot;
       }
     },
 

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_adc.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_adc.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_adc.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,65 +0,0 @@
--- eLua platform interface - ADC
--- Make a full description for each language
-
-data_en = 
-{
-  -- Menu name
-  menu_name = &quot;ADC&quot;,
-
-  -- Title
-  title = &quot;eLua platform interface - ADC&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the ADC interface(s) of the MCU.&quot;,
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_adc_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the hardware ADC specified as argument. Implemented in %src/common.c%, it uses the $NUM_ADC$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_ADC   1      $// The platform has 1 ADC interface$~&lt;/p&gt; ]],
-      args = &quot;$id$ - SPI interface ID&quot;,
-      ret = &quot;1 if the SPI interface exists, 0 otherwise&quot;
-    },
-    
-    { sig = &quot;u32 #platform_adc_op#( unsigned id, int op, u32 data );&quot;,
-      desc = &quot;Executes an operation on an ADC channel&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID&quot;,
-        [[$op$ - the operation that must be executed. It can take any value from @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">adc_operations at this</A> enum@, as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$PLATFORM_ADC_GET_MAXVAL$: get the maximum conversion value the channel may supply (based on channel resolution)&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_ADC_SET_SMOOTHING$: sets the length of the moving average smoothing filter to $data$ &lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_ADC_SET_BLOCKING$: sets whether or not sample requests should block, waiting for additional samples&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_ADC_IS_DONE$: checks whether sampling has completed&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_ADC_OP_SET_TIMER$: selects a timer to control sampling frequency&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_ADC_OP_SET_CLOCK$: set the frequency of sample acquisition&lt;/li&gt;
-  &lt;/ul&gt;]],
-        &quot;$data$ - when used with $op$ == $PLATFORM_ADC_SET_SMOOTHING$, specifies the length of the moving average filter (must be a power of 2). If it is 1, filter is disabled.&quot;,
-        &quot;$data$ - when used with $op$ == $PLATFORM_ADC_SET_BLOCKING$, specifies whether or not sample requests block.  If 1, requests will block until enough samples are available or sampling has ended. If 0, requests will return immediately with up to the number of samples requested.&quot;,
-        &quot;$data$ - when used with $op$ == $PLATFORM_ADC_OP_SET_TIMER$, specifies the timer to use to control sampling frequency.&quot;,
-        &quot;$data$ - when used with $op$ == $PLATFORM_ADC_OP_SET_CLOCK$, specifies the frequency of sample collection in Hz (number of samples per second). If 0, timer is not used and samples are acquired as quickly as possible.&quot;
-      },
-      ret = 
-      {
-        &quot;the maximum possible conversion value when $op$ == $PLATFORM_ADC_GET_MAXVAL$&quot;,
-        &quot;whether or not sampling has completed (1: yes, 0: no) when $op$ == $PLATFORM_ADC_IS_DONE$. This will return 1 (yes), if no samples have been requested.&quot;,
-        &quot;the actual frequency of acquisition that will be used when $op$ == $PLATFORM_ADC_OP_SET_CLOCK$&quot;,
-        &quot;irellevant for other operations&quot;
-      }  
-    },
-    
-    { sig = &quot;int #platform_adc_check_timer_id#( unsigned id, unsigned timer_id );&quot;,
-      desc = &quot;Checks whether a timer may be used with a particular ADC channel&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID&quot;,
-        &quot;$timer_id$ - Timer ID&quot;,
-      },
-      ret = &quot;1 if the timer may be used to trigger the ADC channel, 0 if not&quot;,
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_cpu.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_cpu.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_cpu.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,31 +0,0 @@
--- eLua platform interface - CPU
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - CPU&quot;,
-
-  -- Menu name
-  menu_name = &quot;CPU&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the CPU and its functional modules (interrupt controller, memory controller and others).&quot;,
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;void #platform_cpu_enable_interrupts#();&quot;,
-      desc = &quot;Enable global interrupt on the CPU.&quot;
-    },
-
-    { sig = &quot;void #platform_cpu_disable_interrupts#();&quot;,
-      desc = &quot;Disable global interrupts on the CPU.&quot;
-    },
-
-    { sig = &quot;u32 #platform_cpu_get_frequency#();&quot;,
-      desc = &quot;Get the CPU frequency.&quot;,
-      ret = &quot;the CPU $core$ frequency (in hertz).&quot;
-    },
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_eth.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_eth.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_eth.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,95 +0,0 @@
--- eLua platform interface - Ethernet support
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - Ethernet support&quot;,
-
-  -- Menu name
-  menu_name = &quot;Ethernet&quot;,
-
-  -- Overview
-  overview = [[&lt;font color=&quot;red&quot;&gt;$NOTE$: TCP/IP support is experimental in eLua. Although functional, it's quite incomplete at the moment.&lt;/font&gt;&lt;/p&gt;
-  &lt;p&gt;This part of the platform interface groups functions related to accessing the Ethernet interface (internal or external) of the CPU. Note that unlike the
-  other parts of the platform interface this one is dedicated for TCP/IP support and thus it does not correspond directly to an eLua module, although
-  the @##@net module@ is implemented with functions that rely on this part of the platform interface. Currently only
-  the ^<A HREF="http://www.sics.se/~~adam/uip/index.php/Main_Page^uIP^">http://www.sics.se/~~adam/uip/index.php/Main_Page^uIP^</A> TCP/IP stack is supported by eLua.&lt;/p&gt;
-  &lt;p&gt;uIP is implemented in eLua using two hardware interrupts (that should be available on your platform): the Ethernet receive interrupt (to handle
-  incoming packets) and a timer interrupt (timers are used internally by uIP). However, the uIP main loop is only called from the Ethernet interrupt handler
-  in eLua, so in order to acknowledge the timer interrupt (as well as to provide some optimizations) a function that &quot;forces&quot; an Ethernet interrupt
-  must also be provided by the platform interface (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_eth_force_interrupt at here</A>@ for details).&lt;/p&gt;
-  &lt;p&gt;To put everything together, part of the Ethernet platform interface for the $lm3s$ platform is given below:&lt;/p&gt;
-  ~u32 platform_eth_get_elapsed_time()
-  {
-    if( eth_timer_fired )
-    {
-      eth_timer_fired = 0;
-      return SYSTICKMS;
-    }
-    else
-      return 0;
-  }
-
-  void SysTickIntHandler()
-  {
-    // Handle virtual timers
-    cmn_virtual_timer_cb();
-
-    // Indicate that a SysTick interrupt has occurred.
-    eth_timer_fired = 1;
-
-    // Generate a fake Ethernet interrupt.  This will perform the actual work
-    // of incrementing the timers and taking the appropriate actions.
-    &lt;b&gt;platform_eth_force_interrupt();&lt;/b&gt;
-  }
-
-  void EthernetIntHandler()
-  {
-    u32 temp;
-
-    // Read and Clear the interrupt.
-    temp = EthernetIntStatus( ETH_BASE, false );
-    EthernetIntClear( ETH_BASE, temp );
-
-    // Call the UIP main loop
-    &lt;b&gt;elua_uip_mainloop();&lt;/b&gt;
-  }~&lt;p&gt;]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;void #platform_eth_send_packet#( const void* src, u32 size )&quot;,
-      desc = &quot;Sends an Ethernet packet to the network&quot;,
-      args = 
-      {
-        &quot;$src$ - start address of the Ethernet packet&quot;,
-        &quot;$size$ - size of the Ethernet packet&quot;
-      },
-    },
-
-    { sig = &quot;u32 #platform_eth_get_packet_nb#( void* buf, u32 maxlen );&quot;,
-      desc = &quot;Non-blocking read of an Ethernet packet from the network&quot;,
-      args = 
-      {
-        &quot;$buf$ - start address of the receive buffer&quot;,
-        &quot;$maxlen$ - maximum length of the Ethernet packet&quot;,
-      },
-      ret = &quot;the size of the read packet or 0 if no packet is available&quot;
-    },
-
-    { sig = &quot;void #platform_eth_force_interrupt#();&quot;,
-      desc = &quot;Force the Ethernet interrupt on the platform (see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at overview</A>@ above for details)&quot;,
-    },
-
-    { sig = &quot;u32 #platform_eth_get_elapsed_time#();&quot;,
-      desc = [[Get the elapsed time (in ms) since the last invocation of the uIP main loop ($elua_uip_mainloop$, from which this function is called). See @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at overview</A>@ for a possible 
-  implementation of this function).]], 
-      ret = 
-      { 
-        &quot;0 if the uIP loop was called because of Ethernet activity, not because a timer expired&quot;,
-        &quot;the Ethernet timer perios in ms (which indicates timer activity)&quot;
-      },
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_ll.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_ll.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_ll.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,86 +0,0 @@
--- eLua platform interface - low level functions
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - low level functions&quot;,
-
-  -- Menu title
-  menu_name = &quot;Low-level&quot;,
-
-  -- Overview
-  overview = [[
-  This part of the platform interface deals contains a small set of &quot;low level functions&quot; that are used to &quot;couple&quot; the eLua port with the
-  target system. No eLua module exposes these functions, as they are strictly used for porting and do not provide any other functionality.
-  ]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// Error / status codes
-enum
-{
-  PLATFORM_ERR,
-  PLATFORM_OK,
-  PLATFORM_UNDERFLOW = -1
-};]],
-      name = &quot;Status codes&quot;,
-      desc = [[
-  This enum defines the possible return values of the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_init at platform_init</A>@ function (although only $PLATFORM_ERR$ and $PLATFORM_OK$ should be 
-  returned from $platform_init$).
-  ]]
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_init#();&quot;,
-      desc = [[This is the platform-specific initialization code. It is the first function called from %main()% ($src/main.c$) and it should handle
-  all the platform initialization sequence, included (but not limited to) setting up the proper clocks, initializing the interrupt subsystem,
-  setting up various peripherals and so on. Although platform specific, this function has a common part named %cmn_platform_init% (implemented 
-  in $src/common.c$) that initializes terminal support over serial connections, as well as the XMODEM and TERM components 
-  (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">building.html at here</A>@ for details). If you need any of these, you need to call %cmn_platform_init% at the end of your 
-  %platform_init% function, $after$ initializing all the peripherals (in particular the UART used for the serial connection).&lt;br&gt;
-  An implementation skeleton for this function is given below:&lt;/p&gt;
-  ~int platform_init()
-  {
-    ............. // perform all your initializations here
-    cmn_platform_init(); // call the common initialiation code
-    return PLATFORM_OK;
-  }~&lt;p&gt;]],
-      ret = 
-      {
-         &quot;$PLATFORM_OK$ for success&quot;,
-         [[$PLATFORM_ERR$ if an error occured. If $PLATFORM_ERR$ is returned,  %main% will block in an infinite loop right 
-  after calling this function, so you should return $PLATFORM_ERR$ only for serious errors]],
-      }, 
-    },
-
-    { sig = &quot;void* #platform_get_last_free_ram#( unsigned id );&quot;,
-      desc = [[Returns the start address of a free RAM area in the system (this is the RAM that will be used by any part of the code that uses malloc(), 
-  a good example being the Lua interpreter itself). There can be multiple free RAM areas in the system (for example the internal MCU RAM and external 
-  RAM chips).  Implemented in $src/common.c$, it uses the the $MEM_START_ADDRESS$ macro that must be defined in the platform's $platform_conf.h$
-  file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). This macro must be defined as an array that contains all the start addresses of 
-  free RAM in the system. For internal RAM, this is generally handled by a linker exported symbol (named $end$ in many eLua ports) which 
-  points to the firs RAM address after all the constant and non-constant program data. An example is given below:&lt;/p&gt;
-  ~#define MEM_START_ADDRESS     { ( void* )end }~&lt;p&gt;]],
-      args = &quot;$id$ - the identifier of the RAM area&quot;,
-      ret = &quot;the start address of the given memory area&quot;,   
-    },
-
-    { sig = &quot;void* #platform_get_last_free_ram#( unsigned id );&quot;,
-      desc = [[Returns the last address of a free RAM area in the system (this is the RAM that will be used by any part of the code that uses malloc(), 
-  a good example being the Lua interpreter itself). There can be multiple free RAM areas in the system (for example the internal MCU RAM and external 
-  RAM chips). Implemented in $src/common.c$, it uses the the $MEM_END_ADDRESS$ macro that must be defined in the platform's $platform_conf.h$
-  file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). This macro must be defined as an array that contains all the end addresses of 
-  free RAM in the system. For internal RAM, this is generally set as the last RAM memory address minus the size of the system stack(s). An example is 
-  given below:&lt;/p&gt;
-  ~#define MEM_END_ADDRESS       { ( void* )( SRAM_BASE + 0x10000 - STACK_SIZE_TOTAL - 1 ) }~&lt;p&gt;]],
-      args = &quot;$id$ - the identifier of the RAM area&quot;,
-      ret = &quot;the end address of the given memory area&quot;,   
-    },
-
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_pio.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_pio.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_pio.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,107 +0,0 @@
--- eLua platform interface - PIO
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - PIO&quot;,
-
-  -- Menu name
-  menu_name = &quot;PIO&quot;,
-
-  -- OverviewA
-  overview = &quot;This part of the platform interface deals with PIO (Programmable Input Output) operations, thus letting the user access the low level input/output facilities of the host MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[enum
-{
-  // Pin operations
-  PLATFORM_IO_PIN_SET,                  $// Set the pin to 1$
-  PLATFORM_IO_PIN_CLEAR,                $// Clear the pin (set it to 0)$
-  PLATFORM_IO_PIN_GET,                  $// Get the value of the pin$
-  PLATFORM_IO_PIN_DIR_INPUT,            $// Make the pin an input$
-  PLATFORM_IO_PIN_DIR_OUTPUT,           $// Make the pin an output$
-  PLATFORM_IO_PIN_PULLUP,               $// Activate the pullup on the pin$
-  PLATFORM_IO_PIN_PULLDOWN,             $// Activate the pulldown on the pin$
-  PLATFORM_IO_PIN_NOPULL,               $// Disable all pullups/pulldowns on the pin$
-  // Port operations
-  PLATFORM_IO_PORT_SET_VALUE,           $// Set port value$
-  PLATFORM_IO_PORT_GET_VALUE,           $// Get port value$
-  PLATFORM_IO_PORT_DIR_INPUT,           $// Set port as input$
-  PLATFORM_IO_PORT_DIR_OUTPUT           $// Set port as output$
-}; ]],
-      name = &quot;PIO operations&quot;,
-      desc = [[These are the operations that can be executed by the PIO subsystem on both ports and pins. They are given as arguments to the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_pio_op at platform_pio_op</A>@ function 
-  shown below. ##TODO: document read in/read out if we keep that]]
-    },
-
-    { text = &quot;typedef u32 pio_type;&quot;,
-      name = &quot;PIO data type&quot;,
-      desc = [[This is the type used for the actual I/O operations. Currently defined as an unsigned 32-bit type, thus no port can have more than 32 pins. If this happens, it is possible to split 
-  it in two or more parts and adding the new parts as &quot;virtual ports&quot; (logical ports that don't have a direct hardware equivalent). The &quot;virtual port&quot; technique is used in the AVR32 backend.]]
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_pio_has_port#( unsigned port );&quot;,
-      desc = [[Checks if the platform has the hardware port specified as argument. Implemented in %src/common.c%, it uses the $NUM_PIO$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_PIO   4      $// The platform has 4 hardware PIO ports$~&lt;p&gt; ]],
-      args = &quot;$port$ - the port ID&quot;,
-      ret = &quot;1 if the port exists, 0 otherwise&quot;,
-    },
-
-    { sig = &quot;int #platform_pio_has_pin#( unsigned port, unsigned pin );&quot;,
-      desc = [[Checks if the platform has the hardware port and pin specified as arguments. Implemented in %src/common.c%, it uses the $NUM_PIO$ macro to check the validity
-  of the port and the $PIO_PINS_PER_PORT$ or $PIO_PIN_ARRAY$ macros to check the validity of the pin. The macros must be defined in the platform's $platform_conf.h$ file
-  (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details).
-  &lt;ul&gt;
-    &lt;li&gt;use $PIO_PINS_PER_PORT$ when all the ports of the MCU have the same number of pins. For example:
-      ~#define PIO_PINS_PER_PORT    8   $// Each port has 8 pins$~&lt;/li&gt;
-    &lt;li&gt;use $PIO_PIN_ARRAY$ when different ports of the MCU have different number of pins. For example:
-      ~#define PIO_PIN_ARRAY    { 4, 4, 2, 6 } $// Port 0 has 4 pins, port 1 has 4 pins, port 2 has 2 pins, port 3 has 6 pins$~&lt;/li&gt;
-  &lt;/ul&gt;]],
-      args = 
-      {
-        &quot;$port$ - the port ID&quot;,
-        &quot;$pin$ - the pin number&quot;
-      },
-      ret = &quot;1 if the pin exists, 0 otherwise&quot;,
-    },
-
-    { sig = &quot;const char* #platform_pio_get_prefix#( unsigned port );&quot;,
-      desc = [[Get the port prefix. Used to establish if the port notation uses numbers (P0, P1, P2...) or letters (PA, PB, PC...). Implemented in %src/common.c%, it uses the 
-  $PIO_PREFIX$ macro that must be defined in the platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). The value of this macro can be either '0' (for
-  numeric notation) or 'A' (for letter notation). For example:
-  ~#define PIO_PREFIX    'A'   $// Use PA, PB, PC ... for port notation$~&lt;p&gt;]],
-      args = &quot;$port$ - the port ID&quot;,
-      ret = &quot;the port prefix (either '0' or 'A')&quot;,  
-    },
-
-    { sig = &quot;pio_type #platform_pio_op#( unsigned port, pio_type pinmask, int op );&quot;,
-      link = &quot;platform_pio_op&quot;,
-      desc = &quot;This is the function that does the actual I/O work. It is implemented in the platform's own porting layer (%platform.c%, see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">ports at here</A>@ for more details).&quot;,
-      args = 
-      {
-        &quot;$port$ - the port number&quot;,
-        [[$pinmask$ - has different meanings:
-  &lt;ul&gt;
-    &lt;li&gt;for $pin operations$ it is the mask of pins in the operation. Each pin on which the function action is executed is encoded with an 1 in the corresponding bit position 
-        of the pinmask.&lt;/li&gt;
-    &lt;li&gt;for $port operations$ it is only meaningful for $PLATFORM_IO_PORT_SET_VALUE$ and in this case it specifies the new value of the port.&lt;/li&gt;
-  &lt;/ul&gt;]],
-       &quot;$op$ - specifies the I/O operations, as specified @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pio_operations at here</A>@.&quot;
-      },
-     ret = 
-     {
-       &quot;an actual value for $PLATFORM_IO_PIN_GET$ (0 or 1) and $PLATFORM_IO_PORT_GET$ (the value of the port).&quot;,
-       [[an error flag for all the other operations: 1 if the operation succeeded, 0 otherwise. For example, a platform that doesn't have pulldowns on its ports will always return a 0
-        when caled with the $PLATFORM_IO_PIN_PULLDOWN$ operation.]]
-     }
-    },
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_pwm.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_pwm.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_pwm.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,76 +0,0 @@
--- eLua platform interface - PWM
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - PWM&quot;,
-
-  -- Menu name
-  menu_name = &quot;PWM&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the PWM channel(s) of the MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// PWM operations
-enum
-{
-  PLATFORM_PWM_OP_START,
-  PLATFORM_PWM_OP_STOP,
-  PLATFORM_PWM_OP_SET_CLOCK,
-  PLATFORM_PWM_OP_GET_CLOCK
-} ]],
-      name = &quot;PWM operations&quot;,
-      desc = &quot;This enum lists all the operations that can be executed on a given PWM channel.&quot;
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_pwm_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the PWM channel specified as argument. Implemented in %src/common.c%, it uses the $NUM_PWM$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_PWM   4      $// The platform has 4 PWM channels$~&lt;p&gt; ]],
-      args = &quot;$id$ - PWM channel ID&quot;,
-      ret = &quot;1 if the specified PWM channel exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;u32 #platform_pwm_setup#( unsigned id, u32 frequency, unsigned duty );&quot;,
-      desc = &quot;Sets up a PWM channel&quot;,
-      args = 
-      {
-        &quot;$id$ - PWM channel ID&quot;,
-        &quot;$frequency$ - PWM channel frequency (in hertz)&quot;,
-        &quot;$duty$ - PWM channel duty cycle, specified as percent (from 0 to 100). Note that some platform don't allow the full 0%-100% duty cycle&quot;
-      },
-      ret = &quot;The actual frequency set on the PWM channel, which might differ from the $frequency$ parameter, depeding on the hardware&quot;,
-    },
-
-    { sig = &quot;u32 #platform_pwm_op#( unsigned id, int op, u32 data );&quot;,
-      desc = &quot;Executes an operation on a PWM channel&quot;,
-      args = 
-      {
-        &quot;$id$ - PWM channel ID&quot;,
-        [[$op$ - the operation that must be executed. It can take any value from @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pwm_operations at this</A> enum@, as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$PLATFORM_PWM_OP_START$: starts PWM generation on the specified channel.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_PWM_OP_STOP$: stops PWM generation on the specified channel.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_PWM_OP_SET_CLOCK$: sets the $base$ clock of the specified PWM channel (which will be used to generate the frequencies requested by 
-        @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_pwm_setup at platform_pwm_setup</A>@) to $data$ hertz.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_PWM_OP_GET_CLOCK$: get the $base$ clock of the specified PWM channel.&lt;/liA&gt;
-  &lt;/ul&gt;]],
-        &quot;$data$ - when used with $op$ == $PLATFORM_PWM_OP_SET_CLOCK$ it is used to specify the value of the base clock. Not used with other operations.&quot;
-      },
-      ret = 
-      {
-        &quot;the actual value of the base clock when $op$ == $PLATFORM_PWM_OP_SET_CLOCK$, which might be different than $data$ depending on the hardware&quot;,
-        &quot;the value of the base clock when $op$ == $PLATFORM_PWM_OP_GET_CLOCK$&quot;,
-        &quot;irellevant for other operations&quot;
-      }  
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_spi.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_spi.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_spi.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,84 +0,0 @@
--- eLua platform interface - SPI
--- Make a full description for each language
-
-data_en = 
-{
-  -- Menu name
-  menu_name = &quot;SPI&quot;,
-
-  -- Title
-  title = &quot;eLua platform interface - SPI&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the SPI interface(s) of the MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// SPI mode
-#define PLATFORM_SPI_MASTER                   1
-#define PLATFORM_SPI_SLAVE                    0 ]],
-      name = &quot;Chip select&quot;,
-      desc = &quot;Constants used to select/deselect the SPI SS pin (if applicable).&quot;
-    },
-
-    { text = [[// SS values
-#define PLATFORM_SPI_SELECT_ON                1
-#define PLATFORM_SPI_SELECT_OFF               0]],
-      name = &quot;SPI mode&quot;,
-      desc = &quot;Constants used to select/deselect the SPI SS pin (if applicable).&quot;
-    }, 
-
-    { text = &quot;typedef u32 spi_data_type;&quot;,
-      name = &quot;SPI data type&quot;,
-      desc = &quot;This is the type of a SPI data word, thus limiting the maximum size of a SPI data work to 32 bits (which should be enough for all practical purposes).&quot;
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_spi_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the hardware SPI specified as argument. Implemented in %src/common.c%, it uses the $NUM_SPI$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_SPI   1      $// The platform has 1 SPI interface$~&lt;/p&gt; ]],
-      args = &quot;$id$ - SPI interface ID&quot;,
-      ret = &quot;1 if the SPI interface exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;u32 #platform_spi_setup#( unsigned id, int mode, u32 clock, unsigned cpol, unsigned cpha, unsigned databits );&quot;,
-      desc = [[This function is used to initialize the parameters of the SPI interface. &lt;br&gt;&lt;font color=&quot;red&quot;&gt;$NOTE$&lt;/font&gt;: currently, only master SPI mode is implemented in eLua.]],
-      args = 
-      {
-        &quot;$id$ - SPI interface ID&quot;,
-        &quot;$mode$ - SPI port mode ($PLATFORM_SPI_MASTER$ or $PLATFORM_SPI_SLAVE$, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">spi_mode at here</A>@.&quot;,
-        &quot;$clock$ - clock speed for the SPI interface in master mode.&quot;,
-        &quot;$cpol$ - SPI clock polarity&quot;,
-        &quot;$cpha$ - SPI clock phase&quot;,
-        &quot;$databits$ - length of the SPI data word in bits (usually 8, but configurable on some platforms).&quot;
-      },
-      ret = &quot;the actual clock set for the SPI interface. Depending on the hardware, this may have a different value than the $clock$ argument.&quot;
-    },
-
-    {  sig = &quot;spi_data_type #platform_spi_send_recv#( unsigned id, spi_data_type data );&quot;,
-       desc = &quot;Executes a SPI read/write cycle&quot;,
-       args = 
-       {
-         &quot;$id$ - SPI interface ID&quot;,
-         &quot;$data$ - data to be sent to the SPI interface&quot;,
-       },
-       ret = &quot;data read from the SPI interface&quot;
-    },
-
-    { sig = &quot;void #platform_spi_select#( unsigned id, int is_select );&quot;,
-      desc = [[For platforms that have a dedicates SS (Slave Select) pin in master SPI mode that can be controlled manually, this function should enable/disable this pin. If this functionality
-  does not exist in hardware this function does nothing.]],
-      args =
-      {
-        &quot;$id$ - SPI interface ID.&quot;,
-        &quot;$is_select$ - $PLATFORM_SPI_SELECT_ON$ to select, $PLATFORM_SPI_SELECT_OFF$ to deselect , see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">chip_select at here</A>@.&quot; 
-      },
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_timers.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_timers.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_timers.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,187 +0,0 @@
--- eLua platform interface - timers
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - timers&quot;,
-
-  -- Menu name
-  menu_name = &quot;Timers&quot;,
-
-  -- Overview
-  overview = [[This part of the platform interface groups functions related to the timers of the MCU. It also makes provisions for using $virtual timers$ on any platform, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">virtual at this</A> section@
-  for details. Keep in mind that in the following paragraphs a $timer id$ can reffer to both a hardware timer or a virtual timer.]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = &quot;typedef u32 timer_data_type;&quot;,
-      name = &quot;Timer data type&quot;,
-      desc = &quot;This defines the data type used to specify delays and time intervals (which are always specifide in $microseconds$).&quot;
-    },
-
-    { text = [[// Timer operations
-enum
-{
-  PLATFORM_TIMER_OP_START,
-  PLATFORM_TIMER_OP_READ,
-  PLATFORM_TIMER_OP_SET_CLOCK,
-  PLATFORM_TIMER_OP_GET_CLOCK,
-  PLATFORM_TIMER_OP_GET_MAX_DELAY,
-  PLATFORM_TIMER_OP_GET_MIN_DELAY
-};]], 
-      name = &quot;Timer operations&quot;,
-      desc = &quot;This enum lists all the operations that can be executed on a given timer.&quot;
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_timer_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the timer specified as argument. Implemented in %src/common.c%, it uses the $NUM_TIMER$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details) and the virtual timer configuration (@#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">virtual at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_TIMER   2      $// The platform has 2 hardware timers$~&lt;p&gt;]],
-      args = &quot;$id$ - the timer ID&quot;,
-      ret = &quot;1 if the timer exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;void #platform_timer_delay#( unsigned id, u32 delay_us );&quot;,
-      desc = [[Waits on a timer, then returns. This function is &quot;split&quot; in two parts: a platform-independent part implemented in %src/common.c% (that
-  handles virtual timers) and a platform-dependent part that must be implemented by each platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_timer_delay at platform_s_timer_delay</A>@. This function handles both
-  hardware timer IDs and virtual timer IDs.&lt;br&gt;
-  &lt;font color=&quot;red&quot;&gt;&lt;a name=&quot;limitations&quot;&gt;$IMPORTANT NOTE$&lt;/font&gt;&lt;/a&gt;: the real delay after executing this functions depends a number of variables, most notably the base clock of the timer 
-  and the size of the timer counter register (32 bits on some platforms, 16 bits on most platforms, other values are less common). To ensure that the delay you're requesting is achievable, use 
-  @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_op at platform_timer_op</A>@ with $PLATFORM_TIMER_OP_GET_MAX_DELAY$ and $PLATFORM_TIMER_OP_GET_MIN_DELAY$ to obtain the maximum and the minimum 
-  achievable wait times on your timer, respectively. Even if your delay is within these limits, the $precision$ of this function still varies a lot, mainly as a function of 
-  the timer base clock.]],
-      args = 
-      {
-        &quot;$id$ - the timer ID&quot;,
-        &quot;$delay_us$ - the delay time (in microseconds)&quot;
-      }
-    },
-
-    { sig = &quot;void #platform_s_timer_delay#( unsigned id, u32 delay_us );&quot;,
-      desc = [[This function is identical in functionality to @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_delay at platform_timer_delay</A>@, but this is the function that must actually be implemented by a platform port, 
-  and it must never handle virtual timer IDs, only hardware timer IDs. It has the same @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">limitations at limitations</A>@ as @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_delay at platform_timer_delay</A>@.]],
-      args = 
-      {
-        &quot;$id$ - the timer ID&quot;,
-        &quot;$delay_us$ - the delay time (in microseconds)&quot;
-      }
-    },
-
-    { sig = &quot;u32 #platform_timer_op#( unsigned id, int op, u32 data );&quot;,
-      desc = [[Executes an operation on a timer. This function is &quot;split&quot; in two parts: a platform-independent part implemented in %src/common.c% (that handles virtual timers) and a 
-  platform-dependent part that must be implemented by each platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_timer_op at platform_s_timer_op</A>@. This function handles both hardware timer IDs and virtual 
-  timer IDs.]],
-      args = 
-      {
-        &quot;$id$ - the timer ID&quot;,
-        [[$op$ - the operation. $op$ can take any value from the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">timer_operations at this</A> enum@, as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_START$: start the specified timer by setting its counter register to a predefined value.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_READ$: get the value of the specified timer's counter register.&lt;/li&gt; 
-    &lt;li&gt;$PLATFORM_TIMER_SET_CLOCK$: set the clock of the specified timer to $data$ (in hertz). You can never set the clock of a virtual timer, which is set at compile time.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_GET_CLOCK$: get the clock of the specified timer.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MAX_DELAY$: get the maximum achievable timeout on the specified timer (in us).&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MIN_DELAY$: get the minimum achievable timeout on the specified timer (in us).&lt;/li&gt;
-  &lt;/ul&gt;]],
-        &quot;$data$ - used to specify the timer clock value when $op = PLATFORM_TIMER_SET_CLOCK$, ignored otherwise&quot;,
-      },
-      ret = 
-      {
-        &quot;the predefined value used when starting the clock if $op = PLATFORM_TIMER_OP_START$&quot;,
-        &quot;the timer's counter register if $op = PLATFORM_TIMER_OP_READ$&quot;,
-        &quot;the actual clock set on the timer, which might be different than the request clock depending on the hardware if $op = PLATFORM_TIMER_SET_CLOCK$&quot;,
-        &quot;the timer clock if $op = PLATFORM_TIMER_GET_CLOCK$&quot;, 
-        &quot;the maximum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MAX_DELAY$&quot;,
-        &quot;the minimum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MIN_DELAY$&quot;
-      }
-    }, 
-
-    { sig = &quot;u32 #platform_s_timer_op#( unsigned id, int op, u32 data );&quot;,
-      desc = [[This function is identical in functionality to @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_timer_op at platform_timer_op</A>@, but this is the function that must actually be implemented by a platform port, and it must 
-  never handle virtual timer IDs, only hardware timer IDs.]],
-      args = 
-      {
-        &quot;$id$ - the timer ID&quot;,
-        [[$op$ - the operation. $op$ can take any value from the @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">opval at this</A> enum@, as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_START$: start the specified timer by setting its counter register to a predefined value.&lt;/li&gt;
-    &lt;li&gt;$PLATFORM_TIMER_OP_READ$: get the value of the specified timer's counter register.&lt;/li&gt; 
-    &lt;li&gt;$PLATFORM_TIMER_SET_CLOCK$: set the clock of the specified timer to $data$ (in hertz). You can never set the clock of a virtual timer, which is set at compile time.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_GET_CLOCK$: get the clock of the specified timer.&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MAX_DELAY$: get the maximum achievable timeout on the specified timer (in us).&lt;/li&gt;  
-    &lt;li&gt;$PLATFORM_TIMER_OP_GET_MIN_DELAY$: get the minimum achievable timeout on the specified timer (in us).&lt;/li&gt;
-  &lt;/ul&gt;]],
-        &quot;$data$ - used to specify the timer clock value when $op = PLATFORM_TIMER_SET_CLOCK$, ignored otherwise&quot;,
-      },
-      ret = 
-      {
-        &quot;the predefined value used when starting the clock if $op = PLATFORM_TIMER_OP_START$&quot;,
-        &quot;the timer's counter register if $op = PLATFORM_TIMER_OP_READ$&quot;,
-        &quot;the actual clock set on the timer, which might be different than the request clock depending on the hardware if $op = PLATFORM_TIMER_SET_CLOCK$&quot;,
-        &quot;the timer clock if $op = PLATFORM_TIMER_GET_CLOCK$&quot;, 
-        &quot;the maximum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MAX_DELAY$&quot;,
-        &quot;the minimum achievable delay (in microseconds) if $op = PLATFORM_TIMER_OP_GET_MIN_DELAY$&quot;
-      }
-    }, 
-
-    { sig = &quot;u32 #platform_timer_get_diff_us#( unsigned id, timer_data_type end, timer_data_type start );&quot;,
-      desc = [[Return the time difference (in us) betweeen two timer values. This function is generic for all platforms, thus it is implemented in %src/common.c%.]],
-      args = 
-      {
-        &quot;$id$ - the timer ID&quot;,
-        &quot;$end$ - the first timer value&quot;,
-        &quot;$start$ - the second timer value&quot;,
-      },
-      ret = &quot;the time difference (in microseconds)&quot;
-    }
-  },
-
-  auxdata = 
-  {
-    { title = &quot;Virtual timers&quot;,
-      desc = 
-  [[$Virtual timers$ were added to eLua to overcome some limitations:
-  &lt;ul&gt;
-    &lt;li&gt;there are generally few hardware timers available, some of which might be dedicated (thus not usable directly by eLua).&lt;/li&gt;
-    &lt;li&gt;many times it is difficult to share a hardware timer between different parts of an application because of conflicting requirements. Generally it's not possible to have timers that can
-        achieve long delays and high accuracy at the same time (this is especially true for systems that have 16 bit or even smaller timers).&lt;/li&gt;
-  &lt;/ul&gt;&lt;/p&gt;
-  &lt;p&gt;In this respect, $virtual timers$ are a set of timers that share a single hardware timer. It is possible, in this way, to have a hardware timer that can implement 4, 8 or more hardware
-  timers. There are a few drawbacks to this approach:
-  &lt;ul&gt;
-    &lt;li&gt;the hardware timer used to implement the virtual timers must generally be dedicated. In fact in cat be still used in &quot;read only mode&quot;, which means that the only operations that can
-        be executed on it are $PLATFORM_TIMER_OP_READ$, $PLATFORM_TIMER_GET_CLOCK$, $PLATFORM_TIMER_OP_GET_MAX_DELAY$ and $PLATFORM_TIMER_OP_GET_MIN_DELAY$. However,
-        since the &quot;read only mode&quot; is not enforced by the code, it is advisable to treat this timer as a dedicated resource and thus make it invisible to eLua by not associating it with 
-        an ID.&lt;/li&gt;
-    &lt;li&gt;the number of virtual timers and their base frequency are fixed at compile time.&lt;/li&gt;
-    &lt;li&gt;virtual timers are generally used for large delays with low accuracy, since their base frequency should be fairly low (see below).&lt;/li&gt;
-  &lt;/ul&gt;&lt;/p&gt;
-  &lt;p&gt;To $enable$ virtual timers:
-  &lt;ol&gt;
-    &lt;li&gt;edit $platform_conf.h$ (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details) and set $VTMR_NUM_TIMERS$ to the number of desired virtual timers and 
-       $VTMR_FREQ_HZ$ to the base frequency of the virtual timers (in hertz). For example:
-  ~#define VTMR_NUM_TIMERS       4 // we need 4 virtual timers
-#define VTMR_FREQ_HZ          4 // the base clock for the virtual timers is 4Hz~&lt;/li&gt;
-    &lt;li&gt;in your platform port setup a hardware timer to fire an interrupt at $VTMR_FREQ_HZ$ and call the $cmn_virtual_timer_cb$ function (defined in %src/common.c%) in the 
-       timer interrupt handler. For example, if the the interrupt handler is called $timer_int_handler$, do this:
-  ~void timer_int_handler( void )
-{
-  // add code to clear the timer interrupt flag here if needed
-  cmn_virtual_timer_cb();
-}~&lt;/li&gt;
-  &lt;/ol&gt;&lt;/p&gt;
-  &lt;p&gt;Note that because of step 2 above you are limited by practical constraints on the value of $VTMR_FREQ_HZ$. If set too high, the timer interrupt will fire too often, thus taking too much
-  CPU time. The maximum value depends largely on the hardware and the desired behaviour of the virtual timers, but in practice values larger than 10 might visibly change the behaviour of your 
-  system.&lt;/p&gt;
-  &lt;p&gt;To $use$ a virtual timer, identify it with the constant $VTMR_FIRST_ID$ (defined in %inc/common.h%) plus an offset. For example, $VTMR_FIRST_ID+0$ (or simply
-  $VTMR_FIRST_ID$) is the ID of the first virtual timer in the system, and $VTMR_FIRST_ID+2$ is the ID of the third virtual timer in the system.&lt;/p&gt;
-  ]]
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/arch_platform_uart.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/arch_platform_uart.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/arch_platform_uart.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,126 +0,0 @@
--- eLua platform interface - UART
-
-data_en = 
-{
-  -- Title
-  title = &quot;eLua platform interface - UART&quot;,
-
-  -- Menu name
-  menu_name = &quot;UART&quot;,
-
-  -- Overview
-  overview = &quot;This part of the platform interface groups functions related to the UART interface(s) of the MCU.&quot;,
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[// Parity
-enum
-{
-  PLATFORM_UART_PARITY_EVEN,
-  PLATFORM_UART_PARITY_ODD,
-  PLATFORM_UART_PARITY_NONE
-};]],
-      name = &quot;UART parity&quot;,
-      desc = &quot;Constants used to specify the UART parity mode.&quot;
-    },
-
-    { text = [[// Stop bits
-enum
-{
-  PLATFORM_UART_STOPBITS_1,
-  PLATFORM_UART_STOPBITS_1_5,
-  PLATFORM_UART_STOPBITS_2
-};]],
-      name = &quot;UART stop bits&quot;,
-      desc = &quot;Constants used to specify the number of UART stop bits.&quot;,
-    },
-
-    { text = [[// &quot;Infinite timeout&quot; constant for recv
-#define PLATFORM_UART_INFINITE_TIMEOUT        (-1)]],
-      name = &quot;UART timeout&quot;,
-      desc = &quot;This constant is used as a special timeout value (infinite timeout) in the UART functions that expect a timeout as argument.&quot;,
-    }
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;int #platform_uart_exists#( unsigned id );&quot;,
-      desc = [[Checks if the platform has the hardware UART specified as argument. Implemented in %src/common.c%, it uses the $NUM_UART$ macro that must be defined in the
-  platform's $platform_conf.h$ file (see @arch_overview.html#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platforms at here</A>@ for details). For example:&lt;/p&gt;
-  ~#define NUM_UART   2      $// The platform has 2 UART interfaces$~&lt;p&gt;]],
-      args = &quot;$id$ - UART interface ID&quot;,
-      ret = &quot;1 if the specified UART exists, 0 otherwise&quot;
-    },
-
-    { sig = &quot;u32 #platform_uart_setup#( unsigned id, u32 baud, int databits, int parity, int stopbits );&quot;,
-      desc = &quot;This function is used to initialize the parameters of the UART interface.&quot;,
-      args = 
-      {
-        &quot;$id$ - UART interface ID.&quot;,
-        &quot;$baud$ - baud rate.&quot;,
-        &quot;$databits$ - number of databits (maximum 8).&quot;,
-        &quot;$parity$ - parity type (can be either $PLATFORM_UART_PARITY_EVEN$, $PLATFORM_UART_PARITY_ODD$ or $PLATFORM_UART_PARITY_NONE$, see @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_parity at here</A>@).&quot;,
-        [[$stopbits$ - number of stop bits (can be either $PLATFORM_UART_STOPBITS_1$, $PLATFORM_UART_STOPBITS_1_5$ or $PLATFORM_UART_STOPBITS_2$, see
-           @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_stop_bits at here</A>@).]],
-      },
-      ret = &quot;the actual baud rate. Depending on the hardware, this may have a different value than the $baud$ argument.&quot;,
-    },
-
-    { sig = &quot;void #platform_uart_send#( unsigned id, u8 data );&quot;,
-      desc = &quot;Send data to an UART interface.&quot;,
-      args = 
-      {
-        &quot;$id$ - UART interface ID.&quot;,
-        &quot;$data$ - data to be sent.&quot;,
-      },
-    },
-
-    { sig = &quot;int #platform_uart_recv#( unsigned id, unsigned timer_id, s32 timeout );&quot;,
-      link = &quot;platform_uart_recv&quot;,
-      desc = [[Receive data from the UART interface (blocking/non blocking with timeout/immediate).&lt;br&gt;
-  This function is &quot;split&quot; in two parts: a platform-independent part that is implemented in %src/common.c%, and a platform-dependent part that must be implemented by each
-  platform in a function named @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_s_uart_recv at platform_s_uart_recv</A>@.]],
-      args = 
-      {
-        &quot;$id$ - UART interface ID.&quot;,
-        &quot;$timer_id$ - the ID of the timer used in this operation (see @<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">arch_platform_timers.html at here</A>@ for details). See also the description of the $timeout$ argument.&quot;,
-        [[$timeout$ - specifies a timeout for the receive operation as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$timeout &gt; 0$: the timer with the specified $timer_id$ will be used to timeout the receive operation after $timeout$ microseconds.&lt;/li&gt;
-    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not. $timer_id$ is ignored.&lt;/li&gt;
-    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it. In this mode the function doesn't 
-        time out, so $timer_id$ is ignored.&lt;/li&gt;
-  &lt;/ul&gt;]],
-      },
-      ret = 
-      {
-        &quot;if $timeout &gt; 0$ and data from the UART is available in $timeout$ microseconds of less it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
-      }
-    },
-
-    { sig = &quot;int #platform_s_uart_recv#( unsigned id, s32 timeout );&quot;,
-      link = &quot;platform_s_uart_recv&quot;,
-      desc = [[This is the platform-dependent part of the UART receive function @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@, and is in fact a &quot;subset&quot; of the full function 
-  (thus being easier to implement by each platform in part). In particular, it never needs to deal with the $timeout &gt; 0$ case, which is handled by @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">platform_uart_recv at platform_uart_recv</A>@.]],
-       args = 
-      {
-        &quot;$id$ - UART interface ID.&quot;,
-        [[$timeout$ - specifies a timeout for the receive operation as follows:
-  &lt;ul&gt;
-    &lt;li&gt;$timeout = 0$: the function returns immediately regardless of data being available or not.&lt;/li&gt;
-    &lt;li&gt;$timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INFINITE_TIMEOUT</A>@: the function waits indefinitely for UART data to be available and returns it.&lt;/li&gt;
-  &lt;/ul&gt;]],
-      },
-      ret = 
-      {
-        &quot;if $timeout = 0$ and data from the UART is available when the function is called it is returned, otherwise -1 is returned&quot;,
-        &quot;if $timeout$ = @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">uart_timeout at PLATFORM_UART_INIFINITE_TIMEOUT</A>@ it returns the data read from the UART after it becomes available&quot;
-      }
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/refman_gen_adc.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/refman_gen_adc.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/refman_gen_adc.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,97 +0,0 @@
--- eLua reference manual - ADC
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - ADC&quot;,
-
-  -- Menu name
-  menu_name = &quot;adc&quot;,
-
-  -- Overview
-  overview = [[This module contains functions that access analog to digital converter (ADC) peripherals. ]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#adc.sample#( id, count )&quot;,
-      desc = &quot;Request sample conversions.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID. Optionally, this may be a table containing a list of channel IDs (i.e.: {0, 2, 3}), allowing synchronization of acquisition. NOTE: This acceptance of mixed types is only for the sample function.&quot;,
-        &quot;$count$ - number of samples to acquire.&quot;
-      }
-    },
-    { sig = &quot;sample = #adc.getsample#( id )&quot;,
-      desc = &quot;Get converted samples.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;
-      },
-      ret = &quot;$sample$ - numeric value of conversion, or nil if sample was not available.&quot;
-    },
-    { sig = &quot;samples = #adc.getsamples#( id, count )&quot;,
-      desc = &quot;Get multiple converted samples.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$count$ - optional parameter to indicate number of samples to return. If not included, all available samples are returned.&quot;
-      },
-      ret = &quot;$samples$ - table containing integer conversion values. If not enough samples are available, remaining indices will be nil.&quot;
-    },
-    { sig = &quot;#adc.insertsamples#( id, table, idx, count )&quot;,
-      desc = &quot;Write multiple samples to a table.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$table$ - table to write samples to. Values at $table$[$idx$] to $table$[$idx$ + $count$ -1] will be overwritten with samples (or nil if not enough samples are available).&quot;,
-        &quot;$idx$ - first index to use for writing samples&quot;,
-        &quot;$count$ - number of samples to return. If not enough samples are available (after blocking, if enabled) remaining values will be nil.&quot;
-      }
-    },
-    { sig = &quot;maxval = #adc.maxval#( id )&quot;,
-      desc = &quot;Get maximum conversion value.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;
-      },
-      ret = &quot;$maxval$ - maximum conversion value (based on channel resolution)&quot;
-    },
-    { sig = &quot;clock = #adc.setclock#( id, clock, timer_id )&quot;,
-      desc = &quot;Set frequency of sample acquisition.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$clock$ - frequency to acquire samples at in Hz (number of samples per second), 0 to acquire as fast as possible.&quot;,
-        &quot;$timer_id$ - Timer channel ID to use to control ADC conversion. Note: At this time, a timer selection will apply to all channels on a given ADC peripheral.&quot;
-      },
-      ret = &quot;$clock$ - actual acquisition frequency to be used&quot;
-    },
-    { sig = &quot;status = #adc.isdone#( id )&quot;,
-      desc = &quot;Check if sampling is done.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;
-      },
-      ret = &quot;$status$ - 1 if no samples are being acquired, 0 if samples are pending acquisition.&quot;
-    },
-    { sig = &quot;#adc.setblocking#( id, mode )&quot;,
-      desc = &quot;Set whether or not to block waiting for requested samples.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$mode$ - 1 if requests to get samples should block until requested samples are available or sampling has completed, 0 to return immediately with available samples&quot;
-      },
-    },
-    { sig = &quot;#adc.setsmoothing#( id, length )&quot;,
-      desc = &quot;Set length of moving average filter.&quot;,
-      args = 
-      {
-        &quot;$id$ - ADC channel ID.&quot;,
-        &quot;$length$ - number of samples to include in moving average filter (must be a power of 2). If 1, filter is disabled.&quot;
-      }
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/refman_gen_bit.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/refman_gen_bit.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/refman_gen_bit.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,139 +0,0 @@
--- eLua reference manual - bit module
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - bit module&quot;,
-
-  -- Menu name
-  menu_name = &quot;bit&quot;,
-
-  -- Overview
-  overview = [[Since Lua doesn't have built-in capabilities for bit operations, the $bit$ module was added to eLua to fill this gap. It is based on the ^<A HREF="http://luaforge.net/projects/bitlib^bitlib^">http://luaforge.net/projects/bitlib^bitlib^</A>
-  library written by Reuben Thomas (slightly adapted to eLua) and provides basic bit operations (like setting and clearing bits) and bitwise operations.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;number = #bit.bit#( position )&quot;,
-      desc = &quot;Generate a number with a 1 bit (used for mask generation). Equivalent to %1 &lt;&lt;&lt;&lt; position% in C.&quot;,
-      args = &quot;$position$ - position of the bit that will be set to 1.&quot;,
-      ret = &quot;$number$ - a number with only one 1 bit at $position$ (the rest are set to 0.&quot;
-    },
-
-    { sig = &quot;flag = #bit.isset#( value, position )&quot;,
-      desc = &quot;Test if a given bit is set.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to test.&quot;,
-        &quot;$position$ - bit position to test.&quot;
-      },
-      ret = &quot;$flag$ - 1 if the bit at the given position is 1, 0 otherwise.&quot;
-    },
-
-    { sig = &quot;flag = #bit.isclear#( value, position )&quot;,
-      desc = &quot;Test if a given bit is cleared.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to test.&quot;,
-        &quot;$position$ - bit position to test.&quot;
-      },
-      ret = &quot;$flag$ - 1 if the bit at the given position is 0, 0 othewise.&quot;
-    },
-
-    { sig = &quot;number = #bit.set#( value, pos1, pos2, ..., posn )&quot;,
-      desc = &quot;Set bits in a number.&quot;,
-      args =
-      {
-        &quot;$value$ - the base number.&quot;,
-        &quot;$pos1$ - position of the first bit to set.&quot;,
-        &quot;$pos2$ - position of the second bit to set.&quot;,
-        &quot;$posn$ - position of the nth bit to set.&quot;
-      },
-      ret = &quot;$number$ - the number with the bit(s) set in the given position(s).&quot;
-    },
-
-    { sig = &quot;number = #bit.clear#( value, pos1, pos2, ..., posn )&quot;,
-      desc = &quot;Clear bits in a number.&quot;,
-      args = 
-      {
-        &quot;$value$ - the base number.&quot;,
-        &quot;$pos1$ - position of the first bit to clear.&quot;,
-        &quot;$pos2$ - position of the second bit to clear.&quot;,
-        &quot;$posn$ - position of thet nth bit to clear.&quot;,
-      },
-      ret = &quot;$number$ - the number with the bit(s) cleared in the given position(s).&quot;
-    },
-
-    { sig = &quot;number = #bit.bnot#( value )&quot;,
-      desc = &quot;Bitwise negation, equivalent to %~~value% in C.&quot;,
-      args = &quot;$value$ - the number to negate.&quot;,
-      ret = &quot;$number$ - the bitwise negated value of the number.&quot;,
-    },
-
-    { sig = &quot;number = #bit.band#( val1, val2, ... valn )&quot;,
-      desc = &quot;Bitwise AND, equivalent to %val1 &amp; val2 &amp; ... &amp; valn% in C.&quot;,
-      args = 
-      {
-        &quot;$val1$ - first AND argument.&quot;,
-        &quot;$val2$ - second AND argument.&quot;,
-        &quot;$valn$ - nth AND argument.&quot;,
-      },
-      ret = &quot;$number$ - the bitwise AND of all the arguments.&quot;
-    },
-
-    { sig = &quot;number = #bit.bor#( val1, val2, ... valn )&quot;,
-      desc = &quot;Bitwise OR, equivalent to %val1 | val2 | ... | valn% in C.&quot;,
-      args = 
-      {
-        &quot;$val1$ - first OR argument.&quot;,
-        &quot;$val2$ - second OR argument.&quot;,
-        &quot;$valn$ - nth OR argument.&quot;
-      },
-      ret = &quot;$number$ - the bitwise OR of all the arguments.&quot;
-    },
-
-    { sig = &quot;number = #bit.bxor#( val1, val2, ... valn )&quot;,
-      desc = &quot;Bitwise exclusive OR (XOR), equivalent to %val1 ^^ val2 ^^ ... ^^ valn% in C.&quot;,
-      args = 
-      {
-        &quot;$val1$ - first XOR argument.&quot;,
-        &quot;$val2$ - second XOR argument.&quot;,
-        &quot;$valn$ - nth XOR argument.&quot;
-      },
-      ret = &quot;$number$ - the bitwise exclusive OR of all the arguments.&quot;
-    },
-
-    { sig = &quot;number = #bit.lshift#( value, shift )&quot;,
-      desc = &quot;Left-shift a number, equivalent to %value &lt;&lt; shift% in C.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to shift.&quot;,
-        &quot;$shift$ - positions to shift.&quot;,
-      },
-      ret = &quot;$number$ - the number shifted left&quot;,
-    },
-
-    { sig = &quot;number = #bit.rshift#( value, shift )&quot;,
-      desc = &quot;Logical right shift a number, equivalent to %( unsigned )value &gt;&gt;&gt;&gt; shift% in C.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to shift.&quot;,
-        &quot;$shift$ - positions to shift.&quot;,
-      },
-      ret = &quot;$number$ - the number shifted right (logically).&quot;
-    },
-
-    { sig = &quot;number = #bit.arshift#( value, shift )&quot;,
-      desc = &quot;Arithmetic right shift a number equivalent to %value &gt;&gt;&gt;&gt; shift% in C.&quot;,
-      args = 
-      {
-        &quot;$value$ - the value to shift.&quot;,
-        &quot;$shift$ - positions to shift.&quot;
-      },
-      ret = &quot;$number$ - the number shifted right (arithmetically).&quot;
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/refman_gen_cpu.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/refman_gen_cpu.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/refman_gen_cpu.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,100 +0,0 @@
--- eLua reference manual - CPU module
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - CPU module&quot;,
-
-  -- Menu name
-  menu_name = &quot;cpu&quot;,
-
-  -- Overview
-  overview = [[This module deals with low-level access to CPU (and related modules) functionality, such as reading and writing memory, or 
-  enabling and disabling interrupts. It also offers access to platform specific CPU-related constants using a special macro defined in the
-  platform's $platform_conf.h$ file, as exaplained @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">cpu_constants at here</A>@.]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[cpu.INT_GPIOA
-cpu.INT_GPIOB
-.............
-cpu.INT_UDMA]],
-      name = &quot;CPU constants&quot;,
-      desc = [[eLua has a mechanism that lets the user export an unlimited number of constants to the $cpu$ module. Although in theory any kind of constant can be exposed by this module,
-one should only use constants related to the CPU and its subsystems (as shown above, where a number of CPU specific interrupt masks are exposed to Lua using this mechanism). To use this
-mechanism, just declare the $PLATFORM_CPU_CONSTANTS$ macro in your platform's $platform_conf.h$ file and list all your constants as part of this macro, each enclosed in a special macro called
-$_C$. For example, to get the constants listed above declare your $PLATFORM_CPU_CONSTANTS$ macro like this:&lt;/p&gt;
-~#define PLATFORM_CPU_CONSTANTS\
-  _C( INT_GPIOA ),\
-  _C( INT_GPIOB ),\
-  .................
-  _C( INT_UDMA )~&lt;p&gt;
-&lt;p&gt;It's worth to note that adding more constants does not increas RAM usage, only Flash usage, so you can expose as much constants as you need without worrying about RAM consumption.]]
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;#cpu.w32#( address, data )&quot;,
-      desc = &quot;Writes a 32-bit word to memory.&quot;,
-      args = 
-      {
-        &quot;$address$ - the memory address.&quot;,
-        &quot;$data$ - the 32-bit data to write.&quot;
-      },
-    },
-
-    { sig = &quot;data = #cpu.r32#( address )&quot;,
-      desc = &quot;Read a 32-bit word from memory.&quot;,
-      args = &quot;$address$ - the memory address.&quot;,
-      ret = &quot;$data$ - the 32-bit word read from memory.&quot;
-    },
-
-    { sig = &quot;#cpu.w16#( address, data )&quot;,
-      desc = &quot;Writes a 16-bit word to memory.&quot;,
-      args =
-      {
-        &quot;$address$ - the memory address.&quot;,
-        &quot;$data$ - the 16-bit data to write.&quot;
-      },
-    },
-
-    { sig = &quot;data = #cpu.r16#( address )&quot;,
-      desc = &quot;Reads a 16-bit word from memory.&quot;,
-      args = &quot;$address$ - the memory address.&quot;,
-      ret = &quot;$data$ - the 16-bit word read from memory.&quot;
-    },
-
-    { sig = &quot;#cpu.w8#( address, data )&quot;,
-      desc = &quot;Writes a byte to memory.&quot;,
-      args =
-      {
-        &quot;$address$ - the memory address.&quot;,
-        &quot;$data$ - the byte to write.&quot;
-      }
-    },
-
-    { sig = &quot;data = #cpu.r8#( address )&quot;,
-      desc = &quot;Reads a byte from memory.&quot;,
-      args = &quot;$address$ - the memory address&quot;,
-      ret = &quot;$data$ - the byte read from memory.&quot;
-    },
-
-    { sig = &quot;#cpu.cli#()&quot;,
-      desc = &quot;Disable CPU interrupts.&quot;
-    },
-
-    { sig = &quot;#cpu.sei#()&quot;,
-      desc = &quot;Enable CPU interrupts.&quot;
-    },
-
-    { sig = &quot;clock = #cpu.clock#()&quot;,
-      desc = &quot;Get the CPU core frequency.&quot;,
-      ret = &quot;$clock$ - the CPU clock (in Hertz).&quot;
-    }
-  },
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/refman_gen_pack.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/refman_gen_pack.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/refman_gen_pack.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,135 +0,0 @@
--- eLua reference manual - pack
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - pack&quot;,
-
-  -- Menu name
-  menu_name = &quot;pack&quot;,
-
-  -- Overview
-  overview = [[This module allows for arbitrary packing of data into Lua strings and unpacking data from Lua strings. In this way, a string can be used to store data in a platform-indepdendent 
-manner. It is based on the ^<A HREF="http://www.tecgraf.puc-rio.br/~~lhf/ftp/lua/#lpack^lpack^">http://www.tecgraf.puc-rio.br/~~lhf/ftp/lua/#lpack^lpack^</A> module from Luiz Henrique de Figueiredo (with some minor tweaks). &lt;/p&gt;
-&lt;p&gt;Both methods of this module (@#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">pack at pack</A>@ and @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">unpack at unpack</A>@) use a $format string$ to describe how to pack/unpack the data. The format string contains one or more $data specifiers$, each
-data specifier is applied to a single variable that must be packed/unpacked. The data specifier has the following general format:&lt;/p&gt;
-~[endianness]&lt;&lt;format specifier&gt;&gt;[count]~
-&lt;p&gt;where:
-&lt;ul&gt;
-  &lt;li&gt;$endianness$ is an optional endian flags that specifies how the numbers that are to be packed/unpacked are stored in memory. It can be either:
-  &lt;ol&gt;
-    &lt;li&gt;$'&lt;&lt;'$ for little endian.&lt;/li&gt;
-    &lt;li&gt;$'&gt;&gt;'$ for big endian.&lt;/li&gt;
-    &lt;li&gt;$'='$ for native endian (the platform's endian order, default).&lt;/li&gt;
-  &lt;/ol&gt;&lt;/li&gt;
-  &lt;li&gt;$format specifier$ describes what kind of variable will be packed/unpacked. $The format specifier is case-sensitive$. The possible values of this parameter are summarized in the table below:
-  &lt;p&gt;&lt;table class=&quot;table_center&quot;&gt;
-  &lt;tbody&gt;
-  &lt;tr&gt;
-    &lt;th&gt;Format specifier&lt;/th&gt;
-    &lt;th&gt;Corresponding variable type&lt;/th&gt;
-  &lt;/tr&gt;
-  &lt;tr&gt;
-    &lt;td&gt;'z'&lt;/td&gt;
-    &lt;td&gt;zero-terminated string&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'p'   &lt;/td&gt;
-    &lt;td&gt;string preceded by length byte&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'P'   &lt;/td&gt;
-    &lt;td&gt;string preceded by length word&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'a'   &lt;/td&gt;
-    &lt;td&gt;string preceded by length size_t&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'A'   &lt;/td&gt;
-    &lt;td&gt;string&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'f'   &lt;/td&gt;
-    &lt;td&gt;float&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'d'   &lt;/td&gt;
-    &lt;td&gt;double&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'n'   &lt;/td&gt;
-    &lt;td&gt;Lua number&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'c'   &lt;/td&gt;
-    &lt;td&gt;char&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'b'   &lt;/td&gt;
-    &lt;td&gt;byte = unsigned char&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'h'   &lt;/td&gt;
-    &lt;td&gt;short&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'H'   &lt;/td&gt;
-    &lt;td&gt;unsigned short&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'i'   &lt;/td&gt;
-    &lt;td&gt;int&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'I'   &lt;/td&gt;
-    &lt;td&gt;unsigned int&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'l'   &lt;/td&gt;
-    &lt;td&gt;long&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;tr&gt;
-    &lt;td&gt;'L'   &lt;/td&gt;
-    &lt;td&gt;unsigned long&lt;/td&gt;
-  &lt;/tr&gt;  
-  &lt;/table&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;
-  &lt;li&gt;$count$ is an optional counter for the $format specifier$. For example, $i5$ instructs the code to pack/unpack 5 integer variables, as opposed to $i$ that specifies a
-  single integer variable.&lt;/li&gt;
-&lt;/ul&gt;&lt;/p&gt;]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;packed = #pack.pack#( format, val1, val2, ..., valn )&quot;,
-      desc = &quot;Packs variables in a string.&quot;,
-      args = 
-      {
-        &quot;$format$ - format specifier (as described @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at here</A>@).&quot;,
-        &quot;$val1$ - first variable to pack.&quot;,
-        &quot;$val2$ - second variable to pack.&quot;,
-        &quot;$valn$ - nth variable to pack.&quot;,
-      },
-      ret = &quot;$packed$ - a string containing the packed representation of all variables according to the format.&quot;
-    },
-
-    { sig = &quot;nextpos, val1, val2, ..., valn = #pack.unpack#( string, format, [ init ] )&quot;,
-      desc = &quot;Unpacks a string&quot;,
-      args = 
-      {
-        &quot;$string$ - the string to unpack.&quot;,
-        &quot;$format$ - format specifier (as described @#<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">overview at here</A>@).&quot;,
-        &quot;$init$ - $(optional)$ marks where in $string$ the unpacking should start (1 if not specified).&quot;
-      },
-      ret = 
-      {
-        &quot;$nextpos$ - the position in the string after unpacking.&quot;,
-        &quot;$val1$ - the first unpacked value.&quot;,
-        &quot;$val2$ - the second unpacked value.&quot;,
-        &quot;$valn$ - the nth unpacked value.&quot;
-      }
-    }
-  },
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/refman_gen_pd.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/refman_gen_pd.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/refman_gen_pd.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,34 +0,0 @@
--- eLua reference manual - platform data
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - platform data&quot;,
-
-  -- Menu name
-  menu_name = &quot;Platform data (pd)&quot;,
-
-  -- Overview
-  overview = [[This module contains functions that access specific platform data. Useful if the code needs to know on which platform it runs.]],
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;platform = #pd.platform#()&quot;,
-      desc = &quot;Get platform name.&quot;,
-      ret = &quot;$platform$ - the name of the platform on which eLua is running.&quot;,
-    },
-
-    { sig = &quot;cpu = #pd.cpu#()&quot;,
-      desc = &quot;Get CPU name.&quot;,
-      ret = &quot;$cpu$ - the name of the CPU of the platform on which eLua is running.&quot;,
-    },
-
-    { sig = &quot;board = #pd.board#()&quot;,
-      desc = &quot;Get board name.&quot;,
-      ret = &quot;$board$ - the name of the board on which eLua is running.&quot;,
-    }
-  },
-}
-

Deleted: branches/eagle_mmc/doc/luadoc/refman_gen_pwm.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/refman_gen_pwm.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/refman_gen_pwm.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,60 +0,0 @@
--- eLua reference manual - platform data
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - PWM&quot;,
-
-  -- Menu name
-  menu_name = &quot;pwm&quot;,
-
-  -- Overview
-  overview = [[This module contains functions that control pulse-width modulation (PWM) peripherals.]],
-
-  -- Functions
-  funcs = 
-  {
-	  { sig = &quot;realfrequency = #pwm.setup#( id, frequency, duty )&quot;,
-      desc = &quot;Configure PWM channel.&quot;,
-      args = 
-      {
-        &quot;$id$ - PWM channel ID.&quot;,
-				&quot;$frequency$ - Frequency of PWM channel cycle (in hertz).&quot;,
-        &quot;$duty$ - PWM channel duty cycle, specified as percent (from 0 to 100). Note that some platform don't allow the full 0-100 duty cycle&quot;
-      },
-      ret = &quot;$realfrequency$ - actual PWM cycle frequency&quot;
-    },
-		{ sig = &quot;#pwm.start#( id )&quot;,
-      desc = &quot;Start PWM waveform generation.&quot;,
-      args = 
-      {
-        &quot;$id$ - PWM channel ID.&quot;,
-      }
-    },
-		{ sig = &quot;#pwm.stop#( id )&quot;,
-      desc = &quot;Stop PWM waveform generation.&quot;,
-      args = 
-      {
-        &quot;$id$ - PWM channel ID.&quot;,
-      }
-    },
-	  { sig = &quot;realfrequency = #pwm.setclock#( id, clock )&quot;,
-      desc = &quot;Set base PWM clock frequency&quot;,
-      args = 
-      {
-        &quot;$id$ - PWM channel ID.&quot;,
-				&quot;$clock$ - Frequency of base clock.&quot;,
-      },
-      ret = &quot;$realfrequency$ - actual base PWM clock.&quot;
-    },
-	  { sig = &quot;clock = #pwm.getclock#( id )&quot;,
-      desc = &quot;Get base PWM clock frequency&quot;,
-      args = 
-      {
-        &quot;$id$ - PWM channel ID.&quot;,
-      },
-      ret = &quot;$clock$ - base PWM clock.&quot;
-    },
-  },
-}
\ No newline at end of file

Deleted: branches/eagle_mmc/doc/luadoc/refman_gen_tmr.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/refman_gen_tmr.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/refman_gen_tmr.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,86 +0,0 @@
--- eLua reference manual - platform data
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua reference manual - Timer module&quot;,
-
-  -- Menu name
-  menu_name = &quot;tmr&quot;,
-
-  -- Overview
-  overview = [[This module contains functions that control timer peripherals.]],
-
-  -- Functions
-  funcs = 
-  {
-	  { sig = &quot;#tmr.delay#( id, period )&quot;,
-      desc = &quot;Block for a period of time (in microseconds)&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;,
-				&quot;$period$ - the delay time (in microseconds)&quot;
-      },
-    },
-	  { sig = &quot;timervalue = #tmr.read#( id )&quot;,
-      desc = &quot;Get the value of the specified timer's counter register.&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;,
-      },
-      ret = &quot;$timervalue$ - the timer's counter register&quot;
-    },
-	  { sig = &quot;timervalue = #tmr.start#( id )&quot;,
-      desc = &quot;Start the specified timer by setting its counter register to a predefined value.&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;,
-      },
-      ret = &quot;$timervalue$ - the timer's counter register&quot;
-    },
-	  { sig = &quot;time_us = #tmr.diff#( id, end, start )&quot;,
-      desc = &quot;Return the time difference (in us) betweeen two timer values.&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;,
-				&quot;$end$ - the first timer value&quot;,
-				&quot;$start$ - the second timer value&quot;
-      },
-      ret = &quot;$time_us$ - the time difference (in microseconds)&quot;
-    },
-	  { sig = &quot;mindelay_us = #tmr.mindelay#( id )&quot;,
-      desc = &quot;Get the minimum achievable timeout on the specified timer (in us).&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;,
-      },
-      ret = &quot;$mindelay_us$ - the minimum achievable delay (in microseconds)&quot;
-    },
-	  { sig = &quot;maxdelay_us = #tmr.maxdelay#( id )&quot;,
-      desc = &quot;Get the maximum achievable timeout on the specified timer (in us).&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;,
-      },
-      ret = &quot;$maxdelay_us$ - the maximum achievable delay (in microseconds)&quot;
-    },
-	  { sig = &quot;realclock = #tmr.setclock#( id, clock )&quot;,
-      desc = &quot;Set the clock of the specified timer.&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;,
-				&quot;$clock$ - desired clock (in hertz)&quot;
-      },
-      ret = &quot;$realclock$ - actual clock set on the timer&quot;
-    },
-	  { sig = &quot;clock = #tmr.getclock#( id )&quot;,
-      desc = &quot;Get the clock of the specified timer.&quot;,
-      args = 
-      {
-        &quot;$id$ - Timer channel ID.&quot;
-      },
-      ret = &quot;$clock$ - timer clock&quot;
-    },
-  },
-}
\ No newline at end of file

Deleted: branches/eagle_mmc/doc/luadoc/template.lua
===================================================================
--- branches/eagle_mmc/doc/luadoc/template.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/luadoc/template.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,52 +0,0 @@
--- eLua platform interface - name
-
-data_en = 
-{
-
-  -- Title
-  title = &quot;eLua platform interface - name&quot;,
-
-  -- Menu name
-  menu_name = &quot;name&quot;
-
-  -- Overview
-  overview = [[
-  ]],
-
-  -- Data structures, constants and types
-  structures = 
-  {
-    { text = [[ ]],
-      name = &quot;&quot;, 
-      desc = [[ ]]
-    },
-  },
-
-  -- Functions
-  funcs = 
-  {
-    { sig = &quot;void #functionname#( void )&quot;,
-      desc = [[ ]],
-      args = 
-      {
-        { name = &quot;&quot;, desc = &quot;&quot; },
-        { name = &quot;&quot;, desc = &quot;&quot; }
-      },
-      ret = 
-      {
-         &quot;&quot;,
-         [[ ]],
-      }, 
-    },
-
-  },
-
-  -- Aux data
-  auxdata = 
-  {
-    { title = &quot;&quot;,
-      desc = [[]]
-    }
-  }
-}
-

Deleted: branches/eagle_mmc/doc/wb/wb_usr_template.lua
===================================================================
--- branches/eagle_mmc/doc/wb/wb_usr_template.lua	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/doc/wb/wb_usr_template.lua	2009-11-06 02:10:25 UTC (rev 529)
@@ -1,462 +0,0 @@
--------------------------------------------------------------------------------
--- eLua Documentation Structure Definition
---
--- This is the configuration file for the WebBook html help generator.
--- It is used to generate the menu tree and it's links to the content pages.
--- More info about WebBook can be found @ <A HREF="http://www.tecgraf.puc-rio.br/webbook">http://www.tecgraf.puc-rio.br/webbook</A>
---
--------------------------------------------------------------------------------
-
-
--- General config parameters
-wb_usr = {
-   langs = {&quot;en&quot;,&quot;pt&quot; },
-   start_size = &quot;200&quot;,                            -- Menu tree initial width
-   title_bar_height = 80,                         -- Title bar initial height
-   title_bgcolor = &quot;midnightblue&quot;,
-   enable_search = true,
-   search_link = &quot;<A HREF="http://www.eluaproject.net">http://www.eluaproject.net</A>&quot;, 
---   search_label = &quot;Search: &quot;,
---   contact = &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">eluateam at eluaproject.net</A>&quot;,
---   copyright_name = &quot;eLua Team&quot;,
---   copyright_link = &quot;<A HREF="http://www.eluaproject.net">http://www.eluaproject.net</A>&quot;, 
-   file_title = &quot;wb&quot;,
-   start_open = &quot;1&quot;,
-   logo_image_file = &quot;eLuaLogo.png&quot;,
-   logo_onclick_link = &quot;&quot;
-} 
-
-
-
--- Page and Bar Titles
-wb_usr.messages = 
-{
-  en = 
-  {
-    title = &quot;eLua Doc&quot;,
-    bar_title = &quot;eLua - Embedded Lua&quot;
-  },
-  pt = 
-  {
-    title = &quot;eLua Doc&quot;,
-    bar_title = &quot;eLua - Embedded Lua&quot;
-  }
-} 
-
-
-
--- Menu Tree Definition
-wb_usr.tree =
-{
-  name = { nl = &quot;eLua&quot; },
-  link = &quot;news.html&quot;, 
-  footer = [[
-    &lt;p style=&quot;margin-left: 5px;&quot;&gt;&lt;a href=&quot;<A HREF="http://www.pax.com/free-counters.html">http://www.pax.com/free-counters.html</A>&quot;&gt;&lt;img src=&quot;<A HREF="http://counter.pax.com/counter/image?counter=ctr-zsg80nnmqt">http://counter.pax.com/counter/image?counter=ctr-zsg80nnmqt</A>&quot; alt=&quot;Free Hit Counter&quot; border=&quot;0&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
-  ]],
-  folder =
-  {
-    { name = {en = &quot;Overview&quot;, pt = &quot;Apresenta&#231;&#227;o&quot; },
-      link = &quot;overview.html&quot;,
-      folder =
-      {
-        {  name = { en = &quot;What is&quot;, pt = &quot;O que &#233; eLua ?&quot; },
-           link = &quot;overview.html#whatis&quot;,
-        },
-        {
-          name = { en = &quot;Features&quot;, pt = &quot;Caracter&#237;sticas&quot; },
-          link = &quot;overview.html#features&quot;,
-        },
-        {  name = { en = &quot;Audience&quot;, pt = &quot;P&#250;blico alvo&quot; },
-           link = &quot;overview.html#audience&quot;,
-        },
---[[
-        {  name = { en = &quot;Uses&quot;, pt = &quot;Aplica&#231;&#245;es&quot; },
-           link = &quot;overview.html#uses&quot;,
-        },
---]]        
-        {  name = { en = &quot;Authors&quot;, pt = &quot;Autores&quot; },
-           link = &quot;overview.html#authors&quot;,
-        },
-        {  name = { en = &quot;Contacts&quot;, pt = &quot;Contatos&quot; },
-           link = &quot;overview.html#contacts&quot;,
-        },
-        {  name = { en = &quot;License&quot;, pt = &quot;Licen&#231;a&quot; },
-           link = &quot;overview.html#license&quot;,
-        },
-      },
-    },
-
-    {
-      name = { en = &quot;Downloads&quot;, pt = &quot;Downloads&quot; },
-      link = &quot;downloads.html&quot;,
-      folder =
-      {
-        {
-          name = { en = &quot;Binaries&quot;, pt = &quot;Binaries&quot; },
-          link = &quot;downloads.html#binaries&quot;,
-        },     
-        { 
-          name = { en = &quot;Source Code&quot;, pt = &quot;Fontes&quot; },
-          link = &quot;downloads.html#source&quot;,
-          folder = 
-          {
-            { 
-              name = { en = &quot;Official Releases&quot;, pt = &quot;Vers&#245;es Oficiais[B&quot; },
-              link = &quot;downloads.html#official&quot;
-            },
-            { 
-              name = { en = &quot;SVN Public&quot;, pt = &quot;SVN P&#250;blico&quot; },
-              link = &quot;downloads.html#svnpublic&quot;
-            }, 
-            { 
-              name = { en = &quot;Developers&quot;, pt = &quot;Desenvolvedores&quot; },
-              link = &quot;downloads.html#svndev&quot;
-            },            
-          },
-        },
-        {
-          name = { en = &quot;eLua Logos&quot;, pt = &quot;Logotipos eLua&quot; },
-          link = &quot;downloads.html#elualogos&quot;,
-        },     
-        { 
-          name = { en = &quot;Old Versions&quot;, pt = &quot;Vers&#245;es Anteriores&quot; },
-          link = &quot;dl_old.html&quot;,
-          folder = 
-          {
-            { name = { en = &quot;0.4.1&quot;, pt = &quot;0.4.1&quot; },
-              link = &quot;dl_old.html#v041&quot;
-            },
-            { name = { en = &quot;0.4&quot;, pt = &quot;0.4&quot; },
-              link = &quot;dl_old.html#v04&quot;
-            },
-            { name = { en = &quot;0.3&quot;, pt = &quot;0.3&quot; },
-              link = &quot;dl_old.html#v03&quot;
-            },
-            { name = { en = &quot;0.2&quot;, pt = &quot;0.2&quot; },
-              link = &quot;dl_old.html#v02&quot;
-            },
-            { name = { en = &quot;0.1&quot;, pt = &quot;0.1&quot; },
-              link = &quot;dl_old.html#v01&quot;
-            },
-          },
-        },
-      },
-    },
-
-    {
-      name = {en = &quot;Community&quot;, pt = &quot;Comunidade&quot; },
-      link = &quot;comunity.html&quot;,
-      folder =
-      {
-        {  name = { en = &quot;Lists&quot;, pt = &quot;Listas&quot; },
-           link = &quot;comunity.html#lists&quot;,
-        },
-        { name = { en = &quot;Forums&quot;, pt = &quot;F&#243;rums&quot; },
-           link = &quot;comunity.html#forums&quot;,
-        },
-        {  name = { en = &quot;Credits&quot;, pt = &quot;Cr&#233;ditos&quot; },
-           link = &quot;comunity.html#credits&quot;,
-        },
---[[
-        {  name = { en = &quot;Galery&quot;, pt = &quot;Galeria&quot; },
-           link = &quot;comunity.html#galery&quot;,
-        },
-        {  name = { en = &quot;Projects&quot;, pt = &quot;Projetos&quot; },
-           link = &quot;comunity.html#projects&quot;,
-        },
---]]        
-      },
-    },
-    {
-      name = { en = &quot;News&quot;, pt = &quot;Not&#237;cias&quot; },
-      link = &quot;news.html&quot;,
-    },
-    {
-      name = {en = &quot;Status&quot;, pt = &quot;Status&quot; },
-      link = &quot;status.html&quot;,
-      folder =
-      {
-        {  name = { en = &quot;Platforms Supported&quot;, pt = &quot;Plataformas Suportadas&quot; },
-           link = &quot;status.html#platforms&quot;,
-        },
-        {  name = { en = &quot;Roadmap&quot;, pt = &quot;Futuro&quot; },
-           link = &quot;status.html#roadmap&quot;,
-        },
-      },
-    },
-
-    {
-      name = {en = &quot;Version History&quot;, pt = &quot;Hist&#243;rico de Vers&#245;es&quot; },
-      link = &quot;versionhistory.html&quot;,
-    },
-
-    {
-      name = { en = &quot;&quot;, pt = &quot;&quot; },       -- Horizontal Separator
-      link = &quot;&quot;
-    },
-    {
-      name = { en = &quot;Documentation&quot;, pt = &quot;Documenta&#231;&#227;o&quot; },
-      link = &quot;doc.html&quot;,
-      folder = 
-      {
-        {
-          name = { en = &quot;Building&quot;, pt = &quot;Building&quot; },
-          link = &quot;building.html&quot;,
-          folder = 
-          {
-            { name = { en = &quot;Toolchains&quot;, pt = &quot;Toolchains&quot; },
-              link = &quot;toolchains.html&quot;,
-            },
-          },
-        },
-        {
-          name = { en = &quot;Installing&quot;, pt = &quot;Instalando&quot; },
-          link = &quot;installing.html&quot;,
-          folder = 
-          {
-            {  name = { en = &quot;AT91SAM7X&quot;, pt = &quot;AT91SAM7X&quot; },
-               link = &quot;installing_at91sam7x.html&quot;,
-            },
-            {   name = { en = &quot;LM3S&quot;, pt = &quot;LM3S&quot; },
-               link = &quot;installing_lm3s.html&quot;,
-            },
-            {  name = { en = &quot;AVR32&quot;, pt = &quot;AVR32&quot; },
-               link = &quot;installing_avr32.html&quot;,
-            },
-            {  name = { en = &quot;LPC288x&quot;, pt = &quot;LPC288x&quot; },
-               link = &quot;installing_lpc2888.html&quot;,
-            },
-            {  name = { en = &quot;STR7&quot;, pt = &quot;STR7&quot; },
-               link = &quot;installing_str7.html&quot;,
-            },
-            {  name = { en = &quot;STR9&quot;, pt = &quot;STR9&quot; },
-               link = &quot;installing_str9.html&quot;,
-            },
-            {  name = { en = &quot;STM32&quot;, pt = &quot;STM32&quot; },
-               link = &quot;installing_stm32.html&quot;,
-            },
-            { name = { en = &quot;i386&quot;, pt = &quot;i386&quot; },
-               link = &quot;installing_i386.html&quot;
-            },
-          },
-        },
-        {
-          name = { en = &quot;Using&quot;, pt = &quot;Usando&quot; },
-          link = &quot;using.html&quot;,
-          folder = 
-          {
-            { name = { en = &quot;Over UART&quot;, pt = &quot;UART&quot; },
-              link = &quot;using.html#uart&quot;,
-            },
-            { name = { en = &quot;Over TCP/IP&quot;, pt = &quot;TCP/IP&quot; },
-              link = &quot;using.html#tcpip&quot;,
-            },
-            { name = { en = &quot;On PC&quot;, pt = &quot;no PC&quot; },
-              link = &quot;using.html#pc&quot;,
-            },
-            { name = { en = &quot;The shell&quot;, pt = &quot;O Shell&quot; },
-              link = &quot;using.html#shell&quot;,
-            },
-            { name = { en = &quot;Cross-compiling&quot;, pt = &quot;Cross Compiling&quot; },
-              link = &quot;using.html#cross&quot;,
-            },
-          },
-        },
-        {
-          name = { en = &quot;FAQ&quot;, pt = &quot;FAQ&quot; },
-          link = &quot;faq.html&quot;,
-        },
-        { name = { en = &quot;Architecture&quot;, pt = &quot;Arquitetura&quot; },
-          link = &quot;arch.html&quot;,
-          folder = 
-          {
-            { name = { en = &quot;Overview&quot;, pt = &quot;Vis&#227;o Geral&quot; },
-              link = &quot;arch_overview.html&quot;,
-              folder = 
-              {
-                { name = { en = &quot;Structure&quot;, pt = &quot;Estrutura&quot; },
-                  link = &quot;arch_overview.html#structure&quot;,
-                },
-                { name = { en = &quot;Common code&quot;, pt = &quot;C&#243;digo base&quot; },
-                  link = &quot;arch_overview.html#common&quot;,
-                },
-                { name = { en = &quot;Platform interface&quot;, pt = &quot;Plataformas&quot; },
-                  link = &quot;arch_overview.html#platform&quot;,
-                },
-                { name = { en = &quot;Platforms/ports&quot;, pt = &quot;Plataformas&quot; },
-                  link = &quot;arch_overview.html#platforms&quot;,
-                },
-                { name = { en = &quot;Booting eLua&quot;, pt = &quot;Bootando eLua&quot; },
-                  link = &quot;arch_overview.html#boot&quot;,
-                },
-              },
-            },
-            { name = { en = &quot;Platform interface&quot;, pt = &quot;M&#243;dulos&quot; },
-              link = &quot;arch_platform.html&quot;,
-              folder = {
-                $$ARCH_PLATFORM$$
-              }
-            },
-            { name = { en = &quot;ROM file system&quot;, pt = &quot;ROM File System&quot; },
-              link = &quot;arch_romfs.html&quot;,
-            },
-            { name = { en = &quot;Adding a new port&quot;, pt = &quot;Adicionando um novo Port&quot; },
-              link = &quot;arch_newport.html&quot;,
-            },
-            { name = { en = &quot;Modules and LTR&quot;, pt = &quot;M&#243;dulos e LTR&quot; },
-              link = &quot;arch_ltr.html&quot;,
-            },
-            { name = { en = &quot;Consoles and terminals&quot;, pt = &quot;Consoles e Terminais&quot;},
-              link = &quot;arch_con_term.html&quot;,
-            },
-            { name = { en = &quot;TCP/IP in eLua&quot;, pt = &quot;TCP/IP em eLua&quot; },
-              link = &quot;arch_tcpip.html&quot;,
-            },
-            { name = { en = &quot;eLua coding style&quot;, pt = &quot;Estilo de C&#243;digo&quot; },
-              link = &quot;arch_coding.html&quot;,
-            },
-          }
-        },
-        {
-          name = { en = &quot;Examples&quot;, pt = &quot;Exemplos&quot; },
-          link = &quot;examples.html&quot;,
-        },
-      },
-    },
-
-    {
-      name = { en = &quot;Tutorials&quot;, pt = &quot;Tutoriais&quot; },
-      link = &quot;tutorials.html&quot;,
-      folder =
-      {
-        {  name = { en = &quot;Booting on a PC&quot;, pt = &quot;Booting on a PC&quot; },
-           link = &quot;tut_bootpc.html&quot;,
-        },
-        {  name = { en = &quot;Booting from a Pendrive&quot;, pt = &quot;Booting from a Pendriv&quot; },
-           link = &quot;tut_bootstick.html&quot;,
-        },
-        {  name = { en = &quot;Toolchain Building&quot;, pt = &quot;Toolchain Building&quot; },
-           link = &quot;tchainbuild.html&quot;,
-           folder = 
-           {
-             { name = { en = &quot;ARM7 &amp; ARM9 Toolchains&quot;, pt = &quot;ARM 7 &amp; ARM9 Toolchains&quot; },
-               link = &quot;tc_arm.html&quot;,
-             },
-             { name = { en = &quot;ARM Cortex-M3&quot;, pt = &quot;ARM Cortex-M3&quot; },
-               link = &quot;tc_cortex.html&quot;,
-             },
-             { name = { en = &quot;i386&quot;, pt = &quot;i386&quot; },
-               link = &quot;tc_386.html&quot;,
-             },
-           },  
-        },
-        {  name = { en = &quot;Using OpenOCD&quot;, pt = &quot;Using OpenOC&quot; },
-           link = &quot;tut_openocd.html&quot;,
-        },
-      },
-    },
-
-
-    {
-      name = { en = &quot;Reference Manual&quot;, pt = &quot;Manual de Refer&#234;ncia&quot; },
-      link = &quot;refman.html&quot;,
-      folder = 
-      {
-        {
-          name = { en = &quot;Generic Modules&quot;, pt = &quot;M&#243;dulos Gen&#233;ricos&quot; },
-          link = &quot;refman_gen.html&quot;,
-          folder = {
-            $$REFMAN_GEN$$        
-          },
-        },
-        {
-          name = {en = &quot;Platform Dependent Modules&quot;, pt = &quot;Dependentes de Plataforma&quot; },
-          link = &quot;refman.html#platdepmodules&quot;,
-          folder =
-          {
-            {  name = { en = &quot;adc&quot;, pt = &quot;adc&quot; },
-               link = &quot;refman.html#adcmodule&quot;,
-               folder =
-               {
-                 {
-                   name ={ en = &quot;sample&quot;, pt = &quot;sample&quot; },
-                   link = &quot;refman.html#adc_sample&quot;
-                 },
-                 {
-                   name ={ en = &quot;getsamples&quot;, pt = &quot;getsamples&quot; },
-                   link = &quot;refman.html#adc_getsamples&quot;
-                 },
-                 {
-                   name = { en = &quot;maxval&quot;, pt = &quot;maxval&quot; },
-                   link = &quot;refman.html#adc_maxval&quot;
-                 },
-                 {
-                   name = { en = &quot;samplesready&quot;, pt = &quot;samplesready&quot; },
-                   link = &quot;refman.html#adc_samplesready&quot;
-                 },
-                 {
-                   name = { en = &quot;dataready&quot;, pt = &quot;dataready&quot; },
-                   link = &quot;refman.html#adc_dataready&quot;
-                 },
-                 {
-                   name = { en = &quot;setmode&quot;, pt = &quot;setmode&quot; },
-                   link = &quot;refman.html#adc_setmode&quot;
-                 },
-                 {
-                   name = { en = &quot;setsmoothing&quot;, pt = &quot;setsmoothing&quot; },
-                   link = &quot;refman.html#adc_setsmoothing&quot;
-                 },
-                 {
-                   name = { en = &quot;getsmoothing&quot;, pt = &quot;getsmoothing&quot; },
-                   link = &quot;refman.html#adc_getsmoothing&quot;
-                 },
-                 {
-                   name = { en = &quot;burst&quot;, pt = &quot;burst&quot; },
-                   link = &quot;refman.html#adc_burst&quot;
-                 },
-              },   
-            },
-            {  name = { en = &quot;disp&quot;, pt = &quot;disp&quot; },
-               link = &quot;refman.html#dispmodule&quot;,
-               folder =
-               {
-                 {
-                   name ={ en = &quot;init&quot;, pt = &quot;init&quot; },
-                   link = &quot;refman.html#disp_init&quot;
-                 },
-                 {
-                   name = { en = &quot;enable&quot;, pt = &quot;enable&quot; },
-                   link = &quot;refman.html#disp_enable&quot;
-                 },
-                 {
-                   name = { en = &quot;disable&quot;, pt = &quot;disable&quot; },
-                   link = &quot;refman.html#disp_disable&quot;
-                 },
-                 {
-                   name = { en = &quot;on&quot;, pt = &quot;on&quot; },
-                   link = &quot;refman.html#disp_on&quot;
-                 },
-                 {
-                   name = { en = &quot;off&quot;, pt = &quot;off&quot; },
-                   link = &quot;refman.html#disp_off&quot;
-                 },
-                 {
-                   name = { en = &quot;clear&quot;, pt = &quot;clear&quot; },
-                   link = &quot;refman.html#disp_clear&quot;
-                 },
-                 {
-                   name = { en = &quot;print&quot;, pt = &quot;print&quot; },
-                   link = &quot;refman.html#disp_print&quot;
-                 },
-                 {
-                   name = { en = &quot;draw&quot;, pt = &quot;draw&quot; },
-                   link = &quot;refman.html#disp_draw&quot;
-                 },
-              },   
-            },
-          },
-        },
-      },
-    },
-  },
-}

Modified: branches/eagle_mmc/src/lua/ldo.c
===================================================================
--- branches/eagle_mmc/src/lua/ldo.c	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/src/lua/ldo.c	2009-11-06 02:10:25 UTC (rev 529)
@@ -92,6 +92,8 @@
 
 
 void luaD_throw (lua_State *L, int errcode) {
+  unfixedstack(L); /* make sure the fixedstack &amp; block_gc flags get reset. */
+  unset_block_gc(L);
   if (L-&gt;errorJmp) {
     L-&gt;errorJmp-&gt;status = errcode;
     LUAI_THROW(L, L-&gt;errorJmp);

Modified: branches/eagle_mmc/src/lua/lgc.c
===================================================================
--- branches/eagle_mmc/src/lua/lgc.c	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/src/lua/lgc.c	2009-11-06 02:10:25 UTC (rev 529)
@@ -269,7 +269,8 @@
     markvalue(g, o);
   for (; o &lt;= lim; o++)
     setnilvalue(o);
-  checkstacksizes(l, lim);
+  if (!isfixedstack(l)) /* if stack size is fixed, can't resize it. */
+    checkstacksizes(l, lim);
 }
 
 
@@ -435,13 +436,12 @@
   if (g-&gt;strt.nuse &lt; cast(lu_int32, g-&gt;strt.size/4) &amp;&amp;
       g-&gt;strt.size &gt; MINSTRTABSIZE*2)
     luaS_resize(L, g-&gt;strt.size/2);  /* table is too big */
+  /* it is not safe to re-size the buffer if it is in use. */
+  if (luaZ_bufflen(&amp;g-&gt;buff) &gt; 0) return;
   /* check size of buffer */
   if (luaZ_sizebuffer(&amp;g-&gt;buff) &gt; LUA_MINBUFFER*2) {  /* buffer too big? */
     size_t newsize = luaZ_sizebuffer(&amp;g-&gt;buff) / 2;
-    /* make sure newsize is larger then the buffer's in use size. */
-    newsize = (luaZ_bufflen(&amp;g-&gt;buff) &gt; newsize) ? luaZ_bufflen(&amp;g-&gt;buff) : newsize;
-    if(newsize &lt; luaZ_sizebuffer(&amp;g-&gt;buff))
-      luaZ_resizebuffer(L, &amp;g-&gt;buff, newsize);
+    luaZ_resizebuffer(L, &amp;g-&gt;buff, newsize);
   }
 }
 

Modified: branches/eagle_mmc/src/lua/lgc.h
===================================================================
--- branches/eagle_mmc/src/lua/lgc.h	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/src/lua/lgc.h	2009-11-06 02:10:25 UTC (rev 529)
@@ -41,6 +41,7 @@
 ** Possible Garbage Collector flags.
 ** Layout for bit use in 'gsflags' field in global_State structure.
 ** bit 0 - Protect GC from recursive calls.
+** bit 1 - Don't try to shrink string table if EGC was called during a string table resize.
 */
 #define GCFlagsNone          0
 #define GCBlockGCBit         0
@@ -59,6 +60,7 @@
 ** bit 0 - object is white (type 0)
 ** bit 1 - object is white (type 1)
 ** bit 2 - object is black
+** bit 3 - for thread: Don't resize thread's stack
 ** bit 3 - for userdata: has been finalized
 ** bit 3 - for tables: has weak keys
 ** bit 4 - for tables: has weak values
@@ -70,6 +72,7 @@
 #define WHITE0BIT	0
 #define WHITE1BIT	1
 #define BLACKBIT	2
+#define FIXEDSTACKBIT	3
 #define FINALIZEDBIT	3
 #define KEYWEAKBIT	3
 #define VALUEWEAKBIT	4
@@ -92,6 +95,9 @@
 
 #define luaC_white(g)	cast(lu_byte, (g)-&gt;currentwhite &amp; WHITEBITS)
 
+#define isfixedstack(x)	testbit((x)-&gt;marked, FIXEDSTACKBIT)
+#define fixedstack(x)	l_setbit((x)-&gt;marked, FIXEDSTACKBIT)
+#define unfixedstack(x)	resetbit((x)-&gt;marked, FIXEDSTACKBIT)
 
 #define luaC_checkGC(L) { \
   condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - 1)); \

Modified: branches/eagle_mmc/src/lua/lobject.h
===================================================================
--- branches/eagle_mmc/src/lua/lobject.h	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/src/lua/lobject.h	2009-11-06 02:10:25 UTC (rev 529)
@@ -120,48 +120,54 @@
 #define setnilvalue(obj) ((obj)-&gt;tt=LUA_TNIL)
 
 #define setnvalue(obj,x) \
-  { TValue *i_o=(obj); i_o-&gt;value.n=(x); i_o-&gt;tt=LUA_TNUMBER; }
+  { lua_Number i_x = (x); TValue *i_o=(obj); i_o-&gt;value.n=i_x; i_o-&gt;tt=LUA_TNUMBER; }
 
 #define setpvalue(obj,x) \
-  { TValue *i_o=(obj); i_o-&gt;value.p=(x); i_o-&gt;tt=LUA_TLIGHTUSERDATA; }
+  { void *i_x = (x); TValue *i_o=(obj); i_o-&gt;value.p=i_x; i_o-&gt;tt=LUA_TLIGHTUSERDATA; }
   
 #define setrvalue(obj,x) \
-  { TValue *i_o=(obj); i_o-&gt;value.p=(x); i_o-&gt;tt=LUA_TROTABLE; }
+  { void *i_x = (x); TValue *i_o=(obj); i_o-&gt;value.p=i_x; i_o-&gt;tt=LUA_TROTABLE; }
   
 #define setfvalue(obj,x) \
-  { TValue *i_o=(obj); i_o-&gt;value.p=(x); i_o-&gt;tt=LUA_TLIGHTFUNCTION; }
+  { void *i_x = (x); TValue *i_o=(obj); i_o-&gt;value.p=i_x; i_o-&gt;tt=LUA_TLIGHTFUNCTION; }
 
 #define setbvalue(obj,x) \
-  { TValue *i_o=(obj); i_o-&gt;value.b=(x); i_o-&gt;tt=LUA_TBOOLEAN; }
+  { int i_x = (x); TValue *i_o=(obj); i_o-&gt;value.b=i_x; i_o-&gt;tt=LUA_TBOOLEAN; }
 
 #define setsvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TSTRING; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o-&gt;value.gc=i_x; i_o-&gt;tt=LUA_TSTRING; \
     checkliveness(G(L),i_o); }
 
 #define setuvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TUSERDATA; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o-&gt;value.gc=i_x; i_o-&gt;tt=LUA_TUSERDATA; \
     checkliveness(G(L),i_o); }
 
 #define setthvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TTHREAD; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o-&gt;value.gc=i_x; i_o-&gt;tt=LUA_TTHREAD; \
     checkliveness(G(L),i_o); }
 
 #define setclvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TFUNCTION; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o-&gt;value.gc=i_x; i_o-&gt;tt=LUA_TFUNCTION; \
     checkliveness(G(L),i_o); }
 
 #define sethvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TTABLE; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o-&gt;value.gc=i_x; i_o-&gt;tt=LUA_TTABLE; \
     checkliveness(G(L),i_o); }
 
 #define setptvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o-&gt;value.gc=cast(GCObject *, (x)); i_o-&gt;tt=LUA_TPROTO; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o-&gt;value.gc=i_x; i_o-&gt;tt=LUA_TPROTO; \
     checkliveness(G(L),i_o); }
 
 

Modified: branches/eagle_mmc/src/lua/lvm.c
===================================================================
--- branches/eagle_mmc/src/lua/lvm.c	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/src/lua/lvm.c	2009-11-06 02:10:25 UTC (rev 529)
@@ -152,6 +152,10 @@
 
 void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
   int loop;
+  TValue temp;
+  setnilvalue(L-&gt;top);
+  L-&gt;top++;
+  fixedstack(L);
   for (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
     const TValue *tm;
     if (ttistable(t) || ttisrotable(t)) {  /* `t' is a table? */
@@ -160,6 +164,8 @@
       if ((oldval &amp;&amp; !ttisnil(oldval)) ||  /* result is no nil? */
           (tm = fasttm(L, ttistable(t) ? ((Table*)h)-&gt;metatable : (Table*)luaR_getmeta(h), TM_NEWINDEX)) == NULL) { /* or no TM? */
         if(oldval) {
+          L-&gt;top--;
+          unfixedstack(L);
           setobj2t(L, oldval, val);
           luaC_barriert(L, (Table*)h, val);
         }
@@ -170,10 +176,15 @@
     else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
       luaG_typeerror(L, t, &quot;index&quot;);
     if (ttisfunction(tm) || ttislightfunction(tm)) {
+      L-&gt;top--;
+      unfixedstack(L);
       callTM(L, tm, t, key, val);
       return;
     }
-    t = tm;  /* else repeat with `tm' */ 
+    /* else repeat with `tm' */
+    setobj(L, &amp;temp, tm);  /* avoid pointing inside table (may rehash) */
+    t = &temp;
+    setobj2s(L, L-&gt;top-1, t);  /* need to protect value from EGC. */
   }
   luaG_runerror(L, &quot;loop in settable&quot;);
 }
@@ -300,6 +311,8 @@
 
 
 void luaV_concat (lua_State *L, int total, int last) {
+  lu_mem max_sizet = MAX_SIZET;
+  if (G(L)-&gt;memlimit &lt; max_sizet) max_sizet = G(L)-&gt;memlimit;
   do {
     StkId top = L-&gt;base + last + 1;
     int n = 2;  /* number of elements handled in this pass (at least 2) */
@@ -313,10 +326,11 @@
       size_t tl = tsvalue(top-1)-&gt;len;
       char *buffer;
       int i;
+      fixedstack(L);
       /* collect total length */
       for (n = 1; n &lt; total &amp;&amp; tostring(L, top-n-1); n++) {
         size_t l = tsvalue(top-n-1)-&gt;len;
-        if (l &gt;= MAX_SIZET - tl) luaG_runerror(L, &quot;string length overflow&quot;);
+        if (l &gt;= max_sizet - tl) luaG_runerror(L, &quot;string length overflow&quot;);
         tl += l;
       }
       G(L)-&gt;buff.n = tl;
@@ -329,6 +343,7 @@
       }
       setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
       luaZ_resetbuffer(&amp;G(L)-&gt;buff);
+      unfixedstack(L);
     }
     total -= n-1;  /* got `n' strings to create 1 new */
     last -= n-1;

Modified: branches/eagle_mmc/src/lua/lzio.h
===================================================================
--- branches/eagle_mmc/src/lua/lzio.h	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/src/lua/lzio.h	2009-11-06 02:10:25 UTC (rev 529)
@@ -27,7 +27,7 @@
   size_t buffsize;
 } Mbuffer;
 
-#define luaZ_initbuffer(L, buff) ((buff)-&gt;buffer = NULL, (buff)-&gt;buffsize = 0)
+#define luaZ_initbuffer(L, buff) ((buff)-&gt;buffer = NULL, (buff)-&gt;n = 0, (buff)-&gt;buffsize = 0)
 
 #define luaZ_buffer(buff)	((buff)-&gt;buffer)
 #define luaZ_sizebuffer(buff)	((buff)-&gt;buffsize)

Modified: branches/eagle_mmc/src/modules/uart.c
===================================================================
--- branches/eagle_mmc/src/modules/uart.c	2009-11-06 02:10:06 UTC (rev 528)
+++ branches/eagle_mmc/src/modules/uart.c	2009-11-06 02:10:25 UTC (rev 529)
@@ -47,7 +47,7 @@
   MOD_CHECK_ID( uart, id );
   for( s = 2; s &lt;= total; s ++ )
   {
-    if( lua_isnumber( L, s ) )
+    if( lua_type( L, s ) == LUA_TNUMBER )
     {
       len = lua_tointeger( L, s );
       if( ( len &lt; 0 ) || ( len &gt; 255 ) )
@@ -64,8 +64,6 @@
   }
   return 0;
 }
-
-// Lua: data = read( id, format, [ timeout ], [ timer_id ] )
 static int uart_read( lua_State* L )
 {
   int id, res, mode, issign;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000483.html">[Elua-svn] r528 - in branches/eagle_mmc/src: . platform/lm3s	platform/stm32
</A></li>
	<LI>Next message: <A HREF="000485.html">[Elua-svn] r530 - in branches/eagle_mmc/src: . platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#484">[ date ]</a>
              <a href="thread.html#484">[ thread ]</a>
              <a href="subject.html#484">[ subject ]</a>
              <a href="author.html#484">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
