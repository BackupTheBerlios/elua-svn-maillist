<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r505 - in branches/eagle_mmc/src: . fatfs platform/lm3s
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-October/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r505%20-%20in%20branches/eagle_mmc/src%3A%20.%20fatfs%20platform/lm3s&In-Reply-To=%3C200910302310.n9UNAQlB000817%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000460.html">
   <LINK REL="Next"  HREF="000462.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r505 - in branches/eagle_mmc/src: . fatfs platform/lm3s</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r505%20-%20in%20branches/eagle_mmc/src%3A%20.%20fatfs%20platform/lm3s&In-Reply-To=%3C200910302310.n9UNAQlB000817%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r505 - in branches/eagle_mmc/src: . fatfs platform/lm3s">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Sat Oct 31 00:10:26 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000460.html">[Elua-svn] r504 - in branches/lpc24xx: . romfs src/platform/lpc24xx
</A></li>
        <LI>Next message: <A HREF="000462.html">[Elua-svn] r506 - in branches/eagle_mmc/src: fatfs platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#461">[ date ]</a>
              <a href="thread.html#461">[ thread ]</a>
              <a href="subject.html#461">[ subject ]</a>
              <a href="author.html#461">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-10-31 00:10:23 +0100 (Sat, 31 Oct 2009)
New Revision: 505

Modified:
   branches/eagle_mmc/src/fatfs/diskio.h
   branches/eagle_mmc/src/fatfs/ff.c
   branches/eagle_mmc/src/fatfs/ff.h
   branches/eagle_mmc/src/mmcfs.c
   branches/eagle_mmc/src/platform/lm3s/mmc.c
Log:
Updated to R0.07c of FatFs.

Known Issues:
Remaining strange bug on startup for LM3S.  Sometimes stays in startup mode
repeating clock train? (this is true for the last committed version with an
older FatFs as well).

Modified: branches/eagle_mmc/src/fatfs/diskio.h
===================================================================
--- branches/eagle_mmc/src/fatfs/diskio.h	2009-10-30 17:42:31 UTC (rev 504)
+++ branches/eagle_mmc/src/fatfs/diskio.h	2009-10-30 23:10:23 UTC (rev 505)
@@ -1,10 +1,11 @@
 /*-----------------------------------------------------------------------
-/  Low level disk interface modlue include file  R0.04a   (C)ChaN, 2007
+/  Low level disk interface modlue include file  R0.07   (C)ChaN, 2009
 /-----------------------------------------------------------------------*/
 
 #ifndef _DISKIO
 
 #define _READONLY	0	/* 1: Read-only mode */
+#define _USE_IOCTL	1
 
 #include &quot;integer.h&quot;
 
@@ -25,6 +26,7 @@
 /*---------------------------------------*/
 /* Prototypes for disk control functions */
 
+BOOL assign_drives (int argc, char *argv[]);
 DSTATUS disk_initialize (BYTE);
 DSTATUS disk_status (BYTE);
 DRESULT disk_read (BYTE, BYTE*, DWORD, BYTE);
@@ -32,11 +34,9 @@
 DRESULT disk_write (BYTE, const BYTE*, DWORD, BYTE);
 #endif
 DRESULT disk_ioctl (BYTE, BYTE, void*);
-void	disk_timerproc (void);
 
 
 
-
 /* Disk Status Bits (DSTATUS) */
 
 #define STA_NOINIT		0x01	/* Drive not initialized */
@@ -46,15 +46,21 @@
 
 /* Command code for disk_ioctrl() */
 
-#define GET_SECTOR_COUNT	1
+/* Generic command */
+#define CTRL_SYNC			0	/* Mandatory for write functions */
+#define GET_SECTOR_COUNT	1	/* Mandatory for only f_mkfs() */
 #define GET_SECTOR_SIZE		2
-#define CTRL_SYNC			3
+#define GET_BLOCK_SIZE		3	/* Mandatory for only f_mkfs() */
 #define CTRL_POWER			4
 #define CTRL_LOCK			5
 #define CTRL_EJECT			6
-#define MMC_GET_CSD			10
-#define MMC_GET_CID			11
-#define MMC_GET_OCR			12
+/* MMC/SDC command */
+#define MMC_GET_TYPE		10
+#define MMC_GET_CSD			11
+#define MMC_GET_CID			12
+#define MMC_GET_OCR			13
+#define MMC_GET_SDSTAT		14
+/* ATA/CF command */
 #define ATA_GET_REV			20
 #define ATA_GET_MODEL		21
 #define ATA_GET_SN			22

Modified: branches/eagle_mmc/src/fatfs/ff.c
===================================================================
--- branches/eagle_mmc/src/fatfs/ff.c	2009-10-30 17:42:31 UTC (rev 504)
+++ branches/eagle_mmc/src/fatfs/ff.c	2009-10-30 23:10:23 UTC (rev 505)
@@ -1,96 +1,263 @@
-/*--------------------------------------------------------------------------/
-/  FatFs - FAT file system module  R0.04b                    (C)ChaN, 2007
-/---------------------------------------------------------------------------/
-/ The FatFs module is an experimenal project to implement FAT file system to
-/ cheap microcontrollers. This is a free software and is opened for education,
-/ research and development under license policy of following trems.
+/*----------------------------------------------------------------------------/
+/  FatFs - FAT file system module  R0.07c                    (C)ChaN, 2009
+/-----------------------------------------------------------------------------/
+/ FatFs module is an open source software to implement FAT file system to
+/ small embedded systems. This is a free software and is opened for education,
+/ research and commercial use under license policy of following trems.
 /
-/  Copyright (C) 2007, ChaN, all right reserved.
+/  Copyright (C) 2009, ChaN, all right reserved.
 /
-/ * The FatFs module is a free software and there is no warranty.
-/ * You can use, modify and/or redistribute it for personal, non-profit or
-/   profit use without any restriction under your responsibility.
+/ * The FatFs module is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
 / * Redistributions of source code must retain the above copyright notice.
 /
-/---------------------------------------------------------------------------/
-/  Feb 26, 2006  R0.00  Prototype.
-/  Apr 29, 2006  R0.01  First stable version.
-/  Jun 01, 2006  R0.02  Added FAT12 support.
-/                       Removed unbuffered mode.
-/                       Fixed a problem on small (&lt;32M) patition.
-/  Jun 10, 2006  R0.02a Added a configuration option (_FS_MINIMUM).
-/  Sep 22, 2006  R0.03  Added f_rename().
-/                       Changed option _FS_MINIMUM to _FS_MINIMIZE.
-/  Dec 11, 2006  R0.03a Improved cluster scan algolithm to write files fast.
-/                       Fixed f_mkdir() creates incorrect directory on FAT32.
-/  Feb 04, 2007  R0.04  Supported multiple drive system.
-/                       Changed some interfaces for multiple drive system.
-/                       Changed f_mountdrv() to f_mount().
-/                       Added f_mkfs().
-/  Apr 01, 2007  R0.04a Supported multiple partitions on a plysical drive.
-/                       Added a capability of extending file size to f_lseek().
-/                       Added minimization level 3.
-/                       Fixed an endian sensitive code in f_mkfs().
-/  May 05, 2007  R0.04b Added a configuration option _USE_NTFLAG.
-/                       Added FSInfo support.
-/                       Fixed DBCS name can result FR_INVALID_NAME.
-/                       Fixed short seek (&lt;= csize) collapses the file object.
+/-----------------------------------------------------------------------------/
+/ Feb 26,'06 R0.00  Prototype.
+/
+/ Apr 29,'06 R0.01  First stable version.
+/
+/ Jun 01,'06 R0.02  Added FAT12 support.
+/                   Removed unbuffered mode.
+/                   Fixed a problem on small (&lt;32M) patition.
+/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
+/
+/ Sep 22,'06 R0.03  Added f_rename().
+/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
+/ Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.
+/                   Fixed f_mkdir() creates incorrect directory on FAT32.
+/
+/ Feb 04,'07 R0.04  Supported multiple drive system.
+/                   Changed some interfaces for multiple drive system.
+/                   Changed f_mountdrv() to f_mount().
+/                   Added f_mkfs().
+/ Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.
+/                   Added a capability of extending file size to f_lseek().
+/                   Added minimization level 3.
+/                   Fixed an endian sensitive code in f_mkfs().
+/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
+/                   Added FSInfo support.
+/                   Fixed DBCS name can result FR_INVALID_NAME.
+/                   Fixed short seek (&lt;= csize) collapses the file object.
+/
+/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
+/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
+/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
+/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
+/                   Fixed off by one error at FAT sub-type determination.
+/                   Fixed btr in f_read() can be mistruncated.
+/                   Fixed cached sector is not flushed when create and close
+/                   without write.
+/
+/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
+/                   Improved performance of f_lseek() on moving to the same
+/                   or following cluster.
+/
+/ Apr 01,'09 R0.07  Merged Tiny-FatFs as a buffer configuration option.
+/                   Added long file name support.
+/                   Added multiple code page support.
+/                   Added re-entrancy for multitask operation.
+/                   Added auto cluster size selection to f_mkfs().
+/                   Added rewind option to f_readdir().
+/                   Changed result code of critical errors.
+/                   Renamed string functions to avoid name collision.
+/ Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
+/                   Added multiple sector size support.
+/ Jun 21,'09 R0.07c Fixed f_unlink() may return FR_OK on error.
+/                   Fixed wrong cache control in f_lseek().
+/                   Added relative path feature.
+/                   Added f_chdir() and f_chdrive().
+/                   Added proper case conversion to extended char.
 /---------------------------------------------------------------------------*/
 
-#include &lt;string.h&gt;
-#include &quot;ff.h&quot;            /* FatFs declarations */
-#include &quot;diskio.h&quot;        /* Include file for user provided disk functions */
+#include &quot;ff.h&quot;			/* FatFs configurations and declarations */
+#include &quot;diskio.h&quot;		/* Declarations of low level disk I/O functions */
 
+/*--------------------------------------------------------------------------
 
+   Module Private Definitions
+
+---------------------------------------------------------------------------*/
+
+#if _FS_REENTRANT
+#if _USE_LFN == 1
+#error Static LFN work area must not be used in re-entrant configuration.
+#endif
+#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
+#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
+
+#else
+#define	ENTER_FF(fs)
+#define LEAVE_FF(fs, res)	return res
+
+#endif
+
+#define	ABORT(fs, res)		{ fp-&gt;flag |= FA__ERROR; LEAVE_FF(fs, res); }
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+/* Name status flags */
+#define NS_LOSS		0x01	/* Lossy conversion */
+#define NS_LFN		0x02	/* Force to create LFN entry */
+#define NS_LAST		0x04	/* Last segment */
+#define NS_BODY		0x08	/* Lower case flag (body) */
+#define NS_EXT		0x10	/* Lower case flag (ext) */
+#define NS_DOT		0x20	/* Dot entry */
+
+
+
+
 /*--------------------------------------------------------------------------
 
-   Module Private Functions
+   Private Work Area
 
 ---------------------------------------------------------------------------*/
 
 static
-FATFS *FatFs[_DRIVES];    /* Pointer to the file system objects (logical drives) */
+FATFS *FatFs[_DRIVES];	/* Pointer to the file system objects (logical drives) */
+
 static
-WORD fsid;                /* File system mount ID */
+WORD Fsid;				/* File system mount ID */
 
+#if _FS_RPATH
+static
+BYTE Drive;				/* Current drive */
+#endif
 
 
+#if _USE_LFN == 1	/* LFN with static LFN working buffer */
+static
+WORD LfnBuf[_MAX_LFN + 1];
+#define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR *lp = LfnBuf
+#define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
+
+#elif _USE_LFN &gt; 1	/* LFN with dynamic LFN working buffer */
+#define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR lbuf[_MAX_LFN + 1], *lp = lbuf
+#define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
+
+#else				/* No LFN */
+#define	NAMEBUF(sp,lp)	BYTE sp[12]
+#define INITBUF(dj,sp,lp)	dj.fn = sp
+
+#endif
+
+
+
+
+/*--------------------------------------------------------------------------
+
+   Private Functions
+
+---------------------------------------------------------------------------*/
+
+
 /*-----------------------------------------------------------------------*/
+/* String functions                                                      */
+/*-----------------------------------------------------------------------*/
+
+/* Copy memory to memory */
+static
+void mem_cpy (void* dst, const void* src, int cnt) {
+	char *d = (char*)dst;
+	const char *s = (const char *)src;
+	while (cnt--) *d++ = *s++;
+}
+
+/* Fill memory */
+static
+void mem_set (void* dst, int val, int cnt) {
+	char *d = (char*)dst;
+	while (cnt--) *d++ = (char)val;
+}
+
+/* Compare memory to memory */
+static
+int mem_cmp (const void* dst, const void* src, int cnt) {
+	const char *d = (const char *)dst, *s = (const char *)src;
+	int r = 0;
+	while (cnt-- &amp;&amp; (r = *d++ - *s++) == 0) ;
+	return r;
+}
+
+/* Check if chr is contained in the string */
+static
+int chk_chr (const char* str, int chr) {
+	while (*str &amp;&amp; *str != chr) str++;
+	return *str;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Request/Release grant to access the volume                            */
+/*-----------------------------------------------------------------------*/
+#if _FS_REENTRANT
+
+static
+BOOL lock_fs (
+	FATFS *fs		/* File system object */
+)
+{
+	return ff_req_grant(fs-&gt;sobj);
+}
+
+
+static
+void unlock_fs (
+	FATFS *fs,		/* File system object */
+	FRESULT res		/* Result code to be returned */
+)
+{
+	if (res != FR_NOT_ENABLED &amp;&amp;
+		res != FR_INVALID_DRIVE &amp;&amp;
+		res != FR_INVALID_OBJECT &amp;&amp;
+		res != FR_TIMEOUT) {
+		ff_rel_grant(fs-&gt;sobj);
+	}
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
 /* Change window offset                                                  */
 /*-----------------------------------------------------------------------*/
 
 static
-BOOL move_window (        /* TRUE: successful, FALSE: failed */
-    FATFS *fs,            /* File system object */
-    DWORD sector        /* Sector number to make apperance in the fs-&gt;win[] */
-)                        /* Move to zero only writes back dirty window */
+FRESULT move_window (
+	FATFS *fs,		/* File system object */
+	DWORD sector	/* Sector number to make apperance in the fs-&gt;win[] */
+)					/* Move to zero only writes back dirty window */
 {
-    DWORD wsect;
+	DWORD wsect;
 
 
-    wsect = fs-&gt;winsect;
-    if (wsect != sector) {    /* Changed current window */
+	wsect = fs-&gt;winsect;
+	if (wsect != sector) {	/* Changed current window */
 #if !_FS_READONLY
-        BYTE n;
-        if (fs-&gt;winflag) {    /* Write back dirty window if needed */
-            if (disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1) != RES_OK)
-                return FALSE;
-            fs-&gt;winflag = 0;
-            if (wsect &lt; (fs-&gt;fatbase + fs-&gt;sects_fat)) {    /* In FAT area */
-                for (n = fs-&gt;n_fats; n &gt;= 2; n--) {    /* Refrect the change to FAT copy */
-                    wsect += fs-&gt;sects_fat;
-                    disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1);
-                }
-            }
-        }
+		if (fs-&gt;wflag) {	/* Write back dirty window if needed */
+			if (disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1) != RES_OK)
+				return FR_DISK_ERR;
+			fs-&gt;wflag = 0;
+			if (wsect &lt; (fs-&gt;fatbase + fs-&gt;sects_fat)) {	/* In FAT area */
+				BYTE nf;
+				for (nf = fs-&gt;n_fats; nf &gt; 1; nf--) {	/* Refrect the change to all FAT copies */
+					wsect += fs-&gt;sects_fat;
+					disk_write(fs-&gt;drive, fs-&gt;win, wsect, 1);
+				}
+			}
+		}
 #endif
-        if (sector) {
-            if (disk_read(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
-                return FALSE;
-            fs-&gt;winsect = sector;
-        }
-    }
-    return TRUE;
+		if (sector) {
+			if (disk_read(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
+				return FR_DISK_ERR;
+			fs-&gt;winsect = sector;
+		}
+	}
+
+	return FR_OK;
 }
 
 
@@ -99,30 +266,35 @@
 /*-----------------------------------------------------------------------*/
 /* Clean-up cached data                                                  */
 /*-----------------------------------------------------------------------*/
-
 #if !_FS_READONLY
 static
-FRESULT sync (            /* FR_OK: successful, FR_RW_ERROR: failed */
-    FATFS *fs            /* File system object */
+FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
+	FATFS *fs	/* File system object */
 )
 {
-    fs-&gt;winflag = 1;
-    if (!move_window(fs, 0)) return FR_RW_ERROR;
-#if _USE_FSINFO
-    if (fs-&gt;fs_type == FS_FAT32 &amp;&amp; fs-&gt;fsi_flag) {        /* Update FSInfo sector if needed */
-        fs-&gt;winsect = 0;
-        memset(fs-&gt;win, 0, 512);
-        ST_WORD(&amp;fs-&gt;win[BS_55AA], 0xAA55);
-        ST_DWORD(&amp;fs-&gt;win[FSI_LeadSig], 0x41615252);
-        ST_DWORD(&amp;fs-&gt;win[FSI_StrucSig], 0x61417272);
-        ST_DWORD(&amp;fs-&gt;win[FSI_Free_Count], fs-&gt;free_clust);
-        ST_DWORD(&amp;fs-&gt;win[FSI_Nxt_Free], fs-&gt;last_clust);
-        disk_write(0, fs-&gt;win, fs-&gt;fsi_sector, 1);
-        fs-&gt;fsi_flag = 0;
-    }
-#endif
-    if (disk_ioctl(fs-&gt;drive, CTRL_SYNC, NULL) != RES_OK) return FR_RW_ERROR;
-    return FR_OK;
+	FRESULT res;
+
+
+	res = move_window(fs, 0);
+	if (res == FR_OK) {
+		/* Update FSInfo sector if needed */
+		if (fs-&gt;fs_type == FS_FAT32 &amp;&amp; fs-&gt;fsi_flag) {
+			fs-&gt;winsect = 0;
+			mem_set(fs-&gt;win, 0, 512);
+			ST_WORD(fs-&gt;win+BS_55AA, 0xAA55);
+			ST_DWORD(fs-&gt;win+FSI_LeadSig, 0x41615252);
+			ST_DWORD(fs-&gt;win+FSI_StrucSig, 0x61417272);
+			ST_DWORD(fs-&gt;win+FSI_Free_Count, fs-&gt;free_clust);
+			ST_DWORD(fs-&gt;win+FSI_Nxt_Free, fs-&gt;last_clust);
+			disk_write(fs-&gt;drive, fs-&gt;win, fs-&gt;fsi_sector, 1);
+			fs-&gt;fsi_flag = 0;
+		}
+		/* Make sure that no pending write process in the physical drive */
+		if (disk_ioctl(fs-&gt;drive, CTRL_SYNC, (void*)NULL) != RES_OK)
+			res = FR_DISK_ERR;
+	}
+
+	return res;
 }
 #endif
 
@@ -130,92 +302,103 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Get a cluster status                                                  */
+/* FAT access - Read value of a FAT entry                                */
 /*-----------------------------------------------------------------------*/
 
 static
-DWORD get_cluster (        /* 0,&gt;=2: successful, 1: failed */
-    FATFS *fs,            /* File system object */
-    DWORD clust            /* Cluster# to get the link information */
+DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
+	FATFS *fs,	/* File system object */
+	DWORD clst	/* Cluster# to get the link information */
 )
 {
-    WORD wc, bc;
-    DWORD fatsect;
+	UINT wc, bc;
+	DWORD fsect;
 
 
-    if (clust &gt;= 2 &amp;&amp; clust &lt; fs-&gt;max_clust) {        /* Valid cluster# */
-        fatsect = fs-&gt;fatbase;
-        switch (fs-&gt;fs_type) {
-        case FS_FAT12 :
-            bc = (WORD)clust * 3 / 2;
-            if (!move_window(fs, fatsect + (bc / S_SIZ))) break;
-            wc = fs-&gt;win[bc &amp; (S_SIZ - 1)]; bc++;
-            if (!move_window(fs, fatsect + (bc / S_SIZ))) break;
-            wc |= (WORD)fs-&gt;win[bc &amp; (S_SIZ - 1)] &lt;&lt; 8;
-            return (clust &amp; 1) ? (wc &gt;&gt; 4) : (wc &amp; 0xFFF);
+	if (clst &lt; 2 || clst &gt;= fs-&gt;max_clust)	/* Range check */
+		return 1;
 
-        case FS_FAT16 :
-            if (!move_window(fs, fatsect + (clust / (S_SIZ / 2)))) break;
-            return LD_WORD(&amp;fs-&gt;win[((WORD)clust * 2) &amp; (S_SIZ - 1)]);
+	fsect = fs-&gt;fatbase;
+	switch (fs-&gt;fs_type) {
+	case FS_FAT12 :
+		bc = clst; bc += bc / 2;
+		if (move_window(fs, fsect + (bc / SS(fs)))) break;
+		wc = fs-&gt;win[bc &amp; (SS(fs) - 1)]; bc++;
+		if (move_window(fs, fsect + (bc / SS(fs)))) break;
+		wc |= (WORD)fs-&gt;win[bc &amp; (SS(fs) - 1)] &lt;&lt; 8;
+		return (clst &amp; 1) ? (wc &gt;&gt; 4) : (wc &amp; 0xFFF);
 
-        case FS_FAT32 :
-            if (!move_window(fs, fatsect + (clust / (S_SIZ / 4)))) break;
-            return LD_DWORD(&amp;fs-&gt;win[((WORD)clust * 4) &amp; (S_SIZ - 1)]) &amp; 0x0FFFFFFF;
-        }
-    }
+	case FS_FAT16 :
+		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
+		return LD_WORD(&amp;fs-&gt;win[((WORD)clst * 2) &amp; (SS(fs) - 1)]);
 
-    return 1;    /* There is no cluster information, or an error occured */
+	case FS_FAT32 :
+		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
+		return LD_DWORD(&amp;fs-&gt;win[((WORD)clst * 4) &amp; (SS(fs) - 1)]) &amp; 0x0FFFFFFF;
+	}
+
+	return 0xFFFFFFFF;	/* An error occured at the disk I/O layer */
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Change a cluster status                                               */
+/* FAT access - Change value of a FAT entry                              */
 /*-----------------------------------------------------------------------*/
-
 #if !_FS_READONLY
 static
-BOOL put_cluster (        /* TRUE: successful, FALSE: failed */
-    FATFS *fs,            /* File system object */
-    DWORD clust,        /* Cluster# to change */
-    DWORD val            /* New value to mark the cluster */
+FRESULT put_fat (
+	FATFS *fs,	/* File system object */
+	DWORD clst,	/* Cluster# to be changed in range of 2 to fs-&gt;max_clust - 1 */
+	DWORD val	/* New value to mark the cluster */
 )
 {
-    WORD bc;
-    BYTE *p;
-    DWORD fatsect;
+	UINT bc;
+	BYTE *p;
+	DWORD fsect;
+	FRESULT res;
 
 
-    fatsect = fs-&gt;fatbase;
-    switch (fs-&gt;fs_type) {
-    case FS_FAT12 :
-        bc = (WORD)clust * 3 / 2;
-        if (!move_window(fs, fatsect + (bc / S_SIZ))) return FALSE;
-        p = &amp;fs-&gt;win[bc &amp; (S_SIZ - 1)];
-        *p = (clust &amp; 1) ? ((*p &amp; 0x0F) | ((BYTE)val &lt;&lt; 4)) : (BYTE)val;
-        bc++;
-        fs-&gt;winflag = 1;
-        if (!move_window(fs, fatsect + (bc / S_SIZ))) return FALSE;
-        p = &amp;fs-&gt;win[bc &amp; (S_SIZ - 1)];
-        *p = (clust &amp; 1) ? (BYTE)(val &gt;&gt; 4) : ((*p &amp; 0xF0) | ((BYTE)(val &gt;&gt; 8) &amp; 0x0F));
-        break;
+	if (clst &lt; 2 || clst &gt;= fs-&gt;max_clust) {	/* Range check */
+		res = FR_INT_ERR;
 
-    case FS_FAT16 :
-        if (!move_window(fs, fatsect + (clust / (S_SIZ / 2)))) return FALSE;
-        ST_WORD(&amp;fs-&gt;win[((WORD)clust * 2) &amp; (S_SIZ - 1)], (WORD)val);
-        break;
+	} else {
+		fsect = fs-&gt;fatbase;
+		switch (fs-&gt;fs_type) {
+		case FS_FAT12 :
+			bc = clst; bc += bc / 2;
+			res = move_window(fs, fsect + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = &amp;fs-&gt;win[bc &amp; (SS(fs) - 1)];
+			*p = (clst &amp; 1) ? ((*p &amp; 0x0F) | ((BYTE)val &lt;&lt; 4)) : (BYTE)val;
+			bc++;
+			fs-&gt;wflag = 1;
+			res = move_window(fs, fsect + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = &amp;fs-&gt;win[bc &amp; (SS(fs) - 1)];
+			*p = (clst &amp; 1) ? (BYTE)(val &gt;&gt; 4) : ((*p &amp; 0xF0) | ((BYTE)(val &gt;&gt; 8) &amp; 0x0F));
+			break;
 
-    case FS_FAT32 :
-        if (!move_window(fs, fatsect + (clust / (S_SIZ / 4)))) return FALSE;
-        ST_DWORD(&amp;fs-&gt;win[((WORD)clust * 4) &amp; (S_SIZ - 1)], val);
-        break;
+		case FS_FAT16 :
+			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
+			if (res != FR_OK) break;
+			ST_WORD(&amp;fs-&gt;win[((WORD)clst * 2) &amp; (SS(fs) - 1)], (WORD)val);
+			break;
 
-    default :
-        return FALSE;
-    }
-    fs-&gt;winflag = 1;
-    return TRUE;
+		case FS_FAT32 :
+			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
+			if (res != FR_OK) break;
+			ST_DWORD(&amp;fs-&gt;win[((WORD)clst * 4) &amp; (SS(fs) - 1)], val);
+			break;
+
+		default :
+			res = FR_INT_ERR;
+		}
+		fs-&gt;wflag = 1;
+	}
+
+	return res;
 }
 #endif /* !_FS_READONLY */
 
@@ -223,32 +406,40 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Remove a cluster chain                                                */
+/* FAT handling - Remove a cluster chain                                 */
 /*-----------------------------------------------------------------------*/
-
 #if !_FS_READONLY
 static
-BOOL remove_chain (        /* TRUE: successful, FALSE: failed */
-    FATFS *fs,            /* File system object */
-    DWORD clust            /* Cluster# to remove chain from */
+FRESULT remove_chain (
+	FATFS *fs,			/* File system object */
+	DWORD clst			/* Cluster# to remove a chain from */
 )
 {
-    DWORD nxt;
+	FRESULT res;
+	DWORD nxt;
 
 
-    while (clust &gt;= 2 &amp;&amp; clust &lt; fs-&gt;max_clust) {
-        nxt = get_cluster(fs, clust);
-        if (nxt == 1) return FALSE;
-        if (!put_cluster(fs, clust, 0)) return FALSE;
-        if (fs-&gt;free_clust != 0xFFFFFFFF) {
-            fs-&gt;free_clust++;
-#if _USE_FSINFO
-            fs-&gt;fsi_flag = 1;
-#endif
-        }
-        clust = nxt;
-    }
-    return TRUE;
+	if (clst &lt; 2 || clst &gt;= fs-&gt;max_clust) {	/* Check the range of cluster# */
+		res = FR_INT_ERR;
+
+	} else {
+		res = FR_OK;
+		while (clst &lt; fs-&gt;max_clust) {			/* Not a last link? */
+			nxt = get_fat(fs, clst);			/* Get cluster status */
+			if (nxt == 0) break;				/* Empty cluster? */
+			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
+			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
+			res = put_fat(fs, clst, 0);			/* Mark the cluster &quot;empty&quot; */
+			if (res != FR_OK) break;
+			if (fs-&gt;free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
+				fs-&gt;free_clust++;
+				fs-&gt;fsi_flag = 1;
+			}
+			clst = nxt;	/* Next cluster */
+		}
+	}
+
+	return res;
 }
 #endif
 
@@ -256,55 +447,58 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Stretch or create a cluster chain                                     */
+/* FAT handling - Stretch or Create a cluster chain                      */
 /*-----------------------------------------------------------------------*/
-
 #if !_FS_READONLY
 static
-DWORD create_chain (    /* 0: no free cluster, 1: error, &gt;=2: new cluster number */
-    FATFS *fs,            /* File system object */
-    DWORD clust            /* Cluster# to stretch, 0 means create new */
+DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, &gt;=2:New cluster# */
+	FATFS *fs,			/* File system object */
+	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
 )
 {
-    DWORD cstat, ncl, scl, mcl = fs-&gt;max_clust;
+	DWORD cs, ncl, scl, mcl;
 
 
-    if (clust == 0) {        /* Create new chain */
-        scl = fs-&gt;last_clust;            /* Get suggested start point */
-        if (scl == 0 || scl &gt;= mcl) scl = 1;
-    }
-    else {                    /* Stretch existing chain */
-        cstat = get_cluster(fs, clust);    /* Check the cluster status */
-        if (cstat &lt; 2) return 1;        /* It is an invalid cluster */
-        if (cstat &lt; mcl) return cstat;    /* It is already followed by next cluster */
-        scl = clust;
-    }
+	mcl = fs-&gt;max_clust;
+	if (clst == 0) {		/* Create new chain */
+		scl = fs-&gt;last_clust;			/* Get suggested start point */
+		if (scl == 0 || scl &gt;= mcl) scl = 1;
+	}
+	else {					/* Stretch existing chain */
+		cs = get_fat(fs, clst);			/* Check the cluster status */
+		if (cs &lt; 2) return 1;			/* It is an invalid cluster */
+		if (cs &lt; mcl) return cs;		/* It is already followed by next cluster */
+		scl = clst;
+	}
 
-    ncl = scl;                /* Start cluster */
-    for (;;) {
-        ncl++;                            /* Next cluster */
-        if (ncl &gt;= mcl) {                /* Wrap around */
-            ncl = 2;
-            if (ncl &gt; scl) return 0;    /* No free custer */
-        }
-        cstat = get_cluster(fs, ncl);    /* Get the cluster status */
-        if (cstat == 0) break;            /* Found a free cluster */
-        if (cstat == 1) return 1;        /* Any error occured */
-        if (ncl == scl) return 0;        /* No free custer */
-    }
+	ncl = scl;				/* Start cluster */
+	for (;;) {
+		ncl++;							/* Next cluster */
+		if (ncl &gt;= mcl) {				/* Wrap around */
+			ncl = 2;
+			if (ncl &gt; scl) return 0;	/* No free custer */
+		}
+		cs = get_fat(fs, ncl);			/* Get the cluster status */
+		if (cs == 0) break;				/* Found a free cluster */
+		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
+			return cs;
+		if (ncl == scl) return 0;		/* No free custer */
+	}
 
-    if (!put_cluster(fs, ncl, 0x0FFFFFFF)) return 1;        /* Mark the new cluster &quot;in use&quot; */
-    if (clust &amp;&amp; !put_cluster(fs, clust, ncl)) return 1;    /* Link it to previous one if needed */
+	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster &quot;in use&quot; */
+		return 0xFFFFFFFF;
+	if (clst != 0) {					/* Link it to the previous one if needed */
+		if (put_fat(fs, clst, ncl))
+			return 0xFFFFFFFF;
+	}
 
-    fs-&gt;last_clust = ncl;                /* Update fsinfo */
-    if (fs-&gt;free_clust != 0xFFFFFFFF) {
-        fs-&gt;free_clust--;
-#if _USE_FSINFO
-        fs-&gt;fsi_flag = 1;
-#endif
-    }
+	fs-&gt;last_clust = ncl;				/* Update FSINFO */
+	if (fs-&gt;free_clust != 0xFFFFFFFF) {
+		fs-&gt;free_clust--;
+		fs-&gt;fsi_flag = 1;
+	}
 
-    return ncl;        /* Return new cluster number */
+	return ncl;		/* Return new cluster number */
 }
 #endif /* !_FS_READONLY */
 
@@ -316,273 +510,514 @@
 /*-----------------------------------------------------------------------*/
 
 static
-DWORD clust2sect (    /* !=0: sector number, 0: failed - invalid cluster# */
-    FATFS *fs,        /* File system object */
-    DWORD clust        /* Cluster# to be converted */
+DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
+	FATFS *fs,		/* File system object */
+	DWORD clst		/* Cluster# to be converted */
 )
 {
-    clust -= 2;
-    if (clust &gt;= (fs-&gt;max_clust - 2)) return 0;        /* Invalid cluster# */
-    return clust * fs-&gt;sects_clust + fs-&gt;database;
+	clst -= 2;
+	if (clst &gt;= (fs-&gt;max_clust - 2)) return 0;		/* Invalid cluster# */
+	return clst * fs-&gt;csize + fs-&gt;database;
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Move directory pointer to next                                        */
+/* Directory handling - Seek directory index                             */
 /*-----------------------------------------------------------------------*/
 
 static
-BOOL next_dir_entry (    /* TRUE: successful, FALSE: could not move next */
-    DIR *dirobj            /* Pointer to directory object */
+FRESULT dir_seek (
+	DIR *dj,		/* Pointer to directory object */
+	WORD idx		/* Directory index number */
 )
 {
-    DWORD clust;
-    WORD idx;
-    FATFS *fs = dirobj-&gt;fs;
+	DWORD clst;
+	WORD ic;
 
 
-    idx = dirobj-&gt;index + 1;
-    if ((idx &amp; ((S_SIZ - 1) / 32)) == 0) {        /* Table sector changed? */
-        dirobj-&gt;sect++;            /* Next sector */
-        if (!dirobj-&gt;clust) {        /* In static table */
-            if (idx &gt;= fs-&gt;n_rootdir) return FALSE;    /* Reached to end of table */
-        } else {                    /* In dynamic table */
-            if (((idx / (S_SIZ / 32)) &amp; (fs-&gt;sects_clust - 1)) == 0) {    /* Cluster changed? */
-                clust = get_cluster(fs, dirobj-&gt;clust);        /* Get next cluster */
-                if (clust &lt; 2 || clust &gt;= fs-&gt;max_clust)    /* Reached to end of table */
-                    return FALSE;
-                dirobj-&gt;clust = clust;                /* Initialize for new cluster */
-                dirobj-&gt;sect = clust2sect(fs, clust);
-            }
-        }
-    }
-    dirobj-&gt;index = idx;    /* Lower 4 bit of dirobj-&gt;index indicates offset in dirobj-&gt;sect */
-    return TRUE;
+	dj-&gt;index = idx;
+	clst = dj-&gt;sclust;
+	if (clst == 1 || clst &gt;= dj-&gt;fs-&gt;max_clust)	/* Check start cluster range */
+		return FR_INT_ERR;
+	if (!clst &amp;&amp; dj-&gt;fs-&gt;fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
+		clst = dj-&gt;fs-&gt;dirbase;
+
+	if (clst == 0) {	/* Static table */
+		dj-&gt;clust = clst;
+		if (idx &gt;= dj-&gt;fs-&gt;n_rootdir)		/* Index is out of range */
+			return FR_INT_ERR;
+		dj-&gt;sect = dj-&gt;fs-&gt;dirbase + idx / (SS(dj-&gt;fs) / 32);	/* Sector# */
+	}
+	else {				/* Dynamic table */
+		ic = SS(dj-&gt;fs) / 32 * dj-&gt;fs-&gt;csize;	/* Entries per cluster */
+		while (idx &gt;= ic) {	/* Follow cluster chain */
+			clst = get_fat(dj-&gt;fs, clst);				/* Get next cluster */
+			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
+			if (clst &lt; 2 || clst &gt;= dj-&gt;fs-&gt;max_clust)	/* Reached to end of table or int error */
+				return FR_INT_ERR;
+			idx -= ic;
+		}
+		dj-&gt;clust = clst;
+		dj-&gt;sect = clust2sect(dj-&gt;fs, clst) + idx / (SS(dj-&gt;fs) / 32);	/* Sector# */
+	}
+
+	dj-&gt;dir = dj-&gt;fs-&gt;win + (idx % (SS(dj-&gt;fs) / 32)) * 32;	/* Ptr to the entry in the sector */
+
+	return FR_OK;	/* Seek succeeded */
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Get file status from directory entry                                  */
+/* Directory handling - Move directory index next                        */
 /*-----------------------------------------------------------------------*/
 
-#if _FS_MINIMIZE &lt;= 1
 static
-void get_fileinfo (        /* No return code */
-    FILINFO *finfo,     /* Ptr to store the file information */
-    const BYTE *dir        /* Ptr to the directory entry */
+FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
+	DIR *dj,		/* Pointer to directory object */
+	BOOL streach	/* FALSE: Do not streach table, TRUE: Streach table if needed */
 )
 {
-    BYTE n, c, a;
-    char *p;
+	DWORD clst;
+	WORD i;
 
 
-    p = &amp;finfo-&gt;fname[0];
-    a = _USE_NTFLAG ? dir[DIR_NTres] : 0;        /* NT flag */
-    for (n = 0; n &lt; 8; n++) {    /* Convert file name (body) */
-        c = dir[n];
-        if (c == ' ') break;
-        if (c == 0x05) c = 0xE5;
-        if (a &amp; 0x08 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z') c += 0x20;
-        *p++ = c;
-    }
-    if (dir[8] != ' ') {        /* Convert file name (extension) */
-        *p++ = '.';
-        for (n = 8; n &lt; 11; n++) {
-            c = dir[n];
-            if (c == ' ') break;
-            if (a &amp; 0x10 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z') c += 0x20;
-            *p++ = c;
-        }
-    }
-    *p = '\0';
+	i = dj-&gt;index + 1;
+	if (!i || !dj-&gt;sect)	/* Report EOT when index has reached 65535 */
+		return FR_NO_FILE;
 
-    finfo-&gt;fattrib = dir[DIR_Attr];                    /* Attribute */
-    finfo-&gt;fsize = LD_DWORD(&amp;dir[DIR_FileSize]);    /* Size */
-    finfo-&gt;fdate = LD_WORD(&amp;dir[DIR_WrtDate]);        /* Date */
-    finfo-&gt;ftime = LD_WORD(&amp;dir[DIR_WrtTime]);        /* Time */
+	if (!(i % (SS(dj-&gt;fs) / 32))) {	/* Sector changed? */
+		dj-&gt;sect++;					/* Next sector */
+
+		if (dj-&gt;clust == 0) {	/* Static table */
+			if (i &gt;= dj-&gt;fs-&gt;n_rootdir)	/* Report EOT when end of table */
+				return FR_NO_FILE;
+		}
+		else {					/* Dynamic table */
+			if (((i / (SS(dj-&gt;fs) / 32)) &amp; (dj-&gt;fs-&gt;csize - 1)) == 0) {	/* Cluster changed? */
+				clst = get_fat(dj-&gt;fs, dj-&gt;clust);				/* Get next cluster */
+				if (clst &lt;= 1) return FR_INT_ERR;
+				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
+				if (clst &gt;= dj-&gt;fs-&gt;max_clust) {				/* When it reached end of dynamic table */
+#if !_FS_READONLY
+					BYTE c;
+					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
+					clst = create_chain(dj-&gt;fs, dj-&gt;clust);		/* Streach cluster chain */
+					if (clst == 0) return FR_DENIED;			/* No free cluster */
+					if (clst == 1) return FR_INT_ERR;
+					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
+					/* Clean-up streached table */
+					if (move_window(dj-&gt;fs, 0)) return FR_DISK_ERR;	/* Flush active window */
+					mem_set(dj-&gt;fs-&gt;win, 0, SS(dj-&gt;fs));			/* Clear window buffer */
+					dj-&gt;fs-&gt;winsect = clust2sect(dj-&gt;fs, clst);	/* Cluster start sector */
+					for (c = 0; c &lt; dj-&gt;fs-&gt;csize; c++) {		/* Fill the new cluster with 0 */
+						dj-&gt;fs-&gt;wflag = 1;
+						if (move_window(dj-&gt;fs, 0)) return FR_DISK_ERR;
+						dj-&gt;fs-&gt;winsect++;
+					}
+					dj-&gt;fs-&gt;winsect -= c;						/* Rewind window address */
+#else
+					return FR_NO_FILE;			/* Report EOT */
+#endif
+				}
+				dj-&gt;clust = clst;				/* Initialize data for new cluster */
+				dj-&gt;sect = clust2sect(dj-&gt;fs, clst);
+			}
+		}
+	}
+
+	dj-&gt;index = i;
+	dj-&gt;dir = dj-&gt;fs-&gt;win + (i % (SS(dj-&gt;fs) / 32)) * 32;
+
+	return FR_OK;
 }
-#endif /* _FS_MINIMIZE &lt;= 1 */
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Pick a paragraph and create the name in format of directory entry     */
+/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
 /*-----------------------------------------------------------------------*/
+#if _USE_LFN
+static
+const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
 
+
 static
-char make_dirfile (            /* 1: error - detected an invalid format, '\0'or'/': next character */
-    const char **path,        /* Pointer to the file path pointer */
-    char *dirname            /* Pointer to directory name buffer {Name(8), Ext(3), NT flag(1)} */
+BOOL cmp_lfn (			/* TRUE:Matched, FALSE:Not matched */
+	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
+	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
 )
 {
-    BYTE n, t, c, a, b;
+	int i, s;
+	WCHAR wc;
 
 
-    memset(dirname, ' ', 8+3);    /* Fill buffer with spaces */
-    a = 0; b = 0x18;    /* NT flag */
-    n = 0; t = 8;
-    for (;;) {
-        c = *(*path)++;
-        if (c == '\0' || c == '/') {        /* Reached to end of str or directory separator */
-            if (n == 0) break;
-            dirname[11] = _USE_NTFLAG ? (a &amp; b) : 0;
-            return c;
-        }
-        if (c &lt;= ' ' || c == 0x7F) break;        /* Reject invisible chars */
-        if (c == '.') {
-            if (!(a &amp; 1) &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 8) {    /* Enter extension part */
-                n = 8; t = 11; continue;
-            }
-            break;
-        }
-        if (_USE_SJIS &amp;&amp;
-            ((c &gt;= 0x81 &amp;&amp; c &lt;= 0x9F) ||    /* Accept S-JIS code */
-            (c &gt;= 0xE0 &amp;&amp; c &lt;= 0xFC))) {
-            if (n == 0 &amp;&amp; c == 0xE5)        /* Change heading \xE5 to \x05 */
-                c = 0x05;
-            a ^= 1; goto md_l2;
-        }
-        if (c == '&quot;') break;                /* Reject &quot; */
-        if (c &lt;= ')') goto md_l1;            /* Accept ! # $ % &amp; ' ( ) */
-        if (c &lt;= ',') break;                /* Reject * + , */
-        if (c &lt;= '9') goto md_l1;            /* Accept - 0-9 */
-        if (c &lt;= '?') break;                /* Reject : ; &lt; = &gt; ? */
-        if (!(a &amp; 1)) {    /* These checks are not applied to S-JIS 2nd byte */
-            if (c == '|') break;            /* Reject | */
-            if (c &gt;= '[' &amp;&amp; c &lt;= ']') break;/* Reject [ \ ] */
-            if (_USE_NTFLAG &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
-                (t == 8) ? (b &amp;= ~0x08) : (b &amp;= ~0x10);
-            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {        /* Convert to upper case */
-                c -= 0x20;
-                if (_USE_NTFLAG) (t == 8) ? (a |= 0x08) : (a |= 0x10);
-            }
-        }
-    md_l1:
-        a &amp;= ~1;
-    md_l2:
-        if (n &gt;= t) break;
-        dirname[n++] = c;
-    }
-    return 1;
+	i = ((dir[LDIR_Ord] &amp; 0xBF) - 1) * 13;	/* Get offset in the LFN buffer */
+	s = 0;
+	do {
+		wc = ff_wtoupper(LD_WORD(dir+LfnOfs[s]));	/* Get an LFN character */
+		if (i &gt;= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it with the reference character */
+			return FALSE;
+	} while (++s &lt; 13 &amp;&amp; wc);		/* Repeat until all chars in the entry or a NUL char is processed */
+
+	return TRUE;					/* The LFN entry matched */
 }
 
 
 
+static
+BOOL pick_lfn (			/* TRUE:Succeeded, FALSE:Buffer overflow */
+	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
+	BYTE *dir			/* Pointer to the directory entry */
+)
+{
+	int i, s;
+	WCHAR wc;
 
+
+	i = ((dir[LDIR_Ord] &amp; 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
+
+	s = 0;
+	do {
+		if (i &gt;= _MAX_LFN) return FALSE;	/* Buffer overflow? */
+		wc = LD_WORD(dir+LfnOfs[s]);		/* Get an LFN char */
+		if (!wc) break;						/* End of LFN? */
+		lfnbuf[i++] = wc;					/* Store it */
+	} while (++s &lt; 13);						/* Repeat until last char is copied */
+
+	if (dir[LDIR_Ord] &amp; 0x40) {				/* Put terminator if it is the last LFN part */
+		if (i &gt;= _MAX_LFN) return FALSE;	/* Buffer overflow? */
+		lfnbuf[i] = 0;
+	}
+
+	return TRUE;
+}
+
+
+#if !_FS_READONLY
+static
+void fit_lfn (
+	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
+	BYTE *dir,				/* Pointer to the directory entry */
+	BYTE ord,				/* LFN order (1-20) */
+	BYTE sum				/* SFN sum */
+)
+{
+	int i, s;
+	WCHAR wc;
+
+
+	dir[LDIR_Chksum] = sum;			/* Set check sum */
+	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
+	dir[LDIR_Type] = 0;
+	ST_WORD(dir+LDIR_FstClusLO, 0);
+
+	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
+	s = wc = 0;
+	do {
+		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
+		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
+		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
+	} while (++s &lt; 13);
+	if (wc == 0xFFFF || !lfnbuf[i]) ord |= 0x40;	/* Bottom LFN part is the start of LFN sequence */
+	dir[LDIR_Ord] = ord;			/* Set the LFN order */
+}
+
+#endif
+#endif
+
+
+
 /*-----------------------------------------------------------------------*/
-/* Trace a file path                                                     */
+/* Create numbered name                                                  */
 /*-----------------------------------------------------------------------*/
+#if _USE_LFN
+void gen_numname (
+	BYTE *dst,			/* Pointer to genartated SFN */
+	const BYTE *src,	/* Pointer to source SFN to be modified */
+	const WCHAR *lfn,	/* Pointer to LFN */
+	WORD num			/* Sequense number */
+)
+{
+	char ns[8];
+	int i, j;
 
+
+	mem_cpy(dst, src, 11);
+
+	if (num &gt; 5) {	/* On many collisions, generate a hash number instead of sequencial number */
+		do num = (num &gt;&gt; 1) + (num &lt;&lt; 15) + (WORD)*lfn++; while (*lfn);
+	}
+
+	/* itoa */
+	i = 7;
+	do {
+		ns[i--] = (num % 10) + '0';
+		num /= 10;
+	} while (num);
+	ns[i] = '~';
+
+	/* Append the number */
+	for (j = 0; j &lt; i &amp;&amp; dst[j] != ' '; j++) {
+		if (IsDBCS1(dst[j])) {
+			if (j == i - 1) break;
+			j++;
+		}
+	}
+	do {
+		dst[j++] = (i &lt; 8) ? ns[i++] : ' ';
+	} while (j &lt; 8);
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Calculate sum of an SFN                                               */
+/*-----------------------------------------------------------------------*/
+#if _USE_LFN
 static
-FRESULT trace_path (    /* FR_OK(0): successful, !=0: error code */
-    DIR *dirobj,        /* Pointer to directory object to return last directory */
-    char *fn,            /* Pointer to last segment name to return {file(8),ext(3),attr(1)} */
-    const char *path,    /* Full-path string to trace a file or directory */
-    BYTE **dir            /* Directory pointer in Win[] to retutn */
+BYTE sum_sfn (
+	const BYTE *dir		/* Ptr to directory entry */
 )
 {
-    DWORD clust;
-    char ds;
-    BYTE *dptr = NULL;
-    FATFS *fs = dirobj-&gt;fs;    /* Get logical drive from the given DIR structure */
+	BYTE sum = 0;
+	int n = 11;
 
+	do sum = (sum &gt;&gt; 1) + (sum &lt;&lt; 7) + *dir++; while (--n);
+	return sum;
+}
+#endif
 
-    /* Initialize directory object */
-    clust = fs-&gt;dirbase;
-    if (fs-&gt;fs_type == FS_FAT32) {
-        dirobj-&gt;clust = dirobj-&gt;sclust = clust;
-        dirobj-&gt;sect = clust2sect(fs, clust);
-    } else {
-        dirobj-&gt;clust = dirobj-&gt;sclust = 0;
-        dirobj-&gt;sect = clust;
-    }
-    dirobj-&gt;index = 0;
 
-    if (*path == '\0') {                    /* Null path means the root directory */
-        *dir = NULL; return FR_OK;
-    }
 
-    for (;;) {
-        ds = make_dirfile(&amp;path, fn);            /* Get a paragraph into fn[] */
-        if (ds == 1) return FR_INVALID_NAME;
-        for (;;) {
-            if (!move_window(fs, dirobj-&gt;sect)) return FR_RW_ERROR;
-            dptr = &amp;fs-&gt;win[(dirobj-&gt;index &amp; ((S_SIZ - 1) / 32)) * 32];    /* Pointer to the directory entry */
-            if (dptr[DIR_Name] == 0)                        /* Has it reached to end of dir? */
-                return !ds ? FR_NO_FILE : FR_NO_PATH;
-            if (dptr[DIR_Name] != 0xE5                        /* Matched? */
-                &amp;&amp; !(dptr[DIR_Attr] &amp; AM_VOL)
-                &amp;&amp; !memcmp(&amp;dptr[DIR_Name], fn, 8+3) ) break;
-            if (!next_dir_entry(dirobj))                    /* Next directory pointer */
-                return !ds ? FR_NO_FILE : FR_NO_PATH;
-        }
-        if (!ds) { *dir = dptr; return FR_OK; }                /* Matched with end of path */
-        if (!(dptr[DIR_Attr] &amp; AM_DIR)) return FR_NO_PATH;    /* Cannot trace because it is a file */
-        clust = ((DWORD)LD_WORD(&amp;dptr[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dptr[DIR_FstClusLO]); /* Get cluster# of the directory */
-        dirobj-&gt;clust = dirobj-&gt;sclust = clust;                /* Restart scanning at the new directory */
-        dirobj-&gt;sect = clust2sect(fs, clust);
-        dirobj-&gt;index = 2;
-    }
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Find an object in the directory                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_find (
+	DIR *dj			/* Pointer to the directory object linked to the file name */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN
+	BYTE a, lfen, ord, sum;
+#endif
+
+	res = dir_seek(dj, 0);			/* Rewind directory object */
+	if (res != FR_OK) return res;
+
+#if _USE_LFN
+	ord = sum = 0xFF; lfen = *(dj-&gt;fn+11) &amp; NS_LOSS;
+#endif
+	do {
+		res = move_window(dj-&gt;fs, dj-&gt;sect);
+		if (res != FR_OK) break;
+		dir = dj-&gt;dir;					/* Ptr to the directory entry of current index */
+		c = dir[DIR_Name];
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
+#if _USE_LFN	/* LFN configuration */
+		a = dir[DIR_Attr] &amp; AM_MASK;
+		if (c == 0xE5 || ((a &amp; AM_VOL) &amp;&amp; a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF;
+		} else {
+			if (a == AM_LFN) {			/* An LFN entry is found */
+				if (dj-&gt;lfn) {
+					if (c &amp; 0x40) {		/* Is it start of LFN sequence? */
+						sum = dir[LDIR_Chksum];
+						c &amp;= 0xBF; ord = c;		/* LFN start order */
+						dj-&gt;lfn_idx = dj-&gt;index;
+					}
+					/* Check LFN validity. Compare LFN if it is out of 8.3 format */
+					ord = (c == ord &amp;&amp; sum == dir[LDIR_Chksum] &amp;&amp; (!lfen || cmp_lfn(dj-&gt;lfn, dir))) ? ord - 1 : 0xFF;
+				}
+			} else {					/* An SFN entry is found */
+				if (ord || sum != sum_sfn(dir))	/* Did not LFN match? */
+					dj-&gt;lfn_idx = 0xFFFF;
+				if (lfen) {				/* Match LFN if it is out of 8.3 format */
+					if (ord == 0) break;
+				} else {				/* Match SFN if LFN is in 8.3 format */
+					if (!mem_cmp(dir, dj-&gt;fn, 11)) break;
+				}
+				ord = 0xFF;
+			}
+		}
+#else		/* Non LFN configuration */
+		if (!(dir[DIR_Attr] &amp; AM_VOL) &amp;&amp; !mem_cmp(dir, dj-&gt;fn, 11)) /* Is it a valid entry? */
+			break;
+#endif
+		res = dir_next(dj, FALSE);				/* Next entry */
+	} while (res == FR_OK);
+
+	return res;
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Reserve a directory entry                                             */
+/* Read an object from the directory                                     */
 /*-----------------------------------------------------------------------*/
+#if _FS_MINIMIZE &lt;= 1
+static
+FRESULT dir_read (
+	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN
+	BYTE a, ord = 0xFF, sum = 0xFF;
+#endif
 
+	res = FR_NO_FILE;
+	while (dj-&gt;sect) {
+		res = move_window(dj-&gt;fs, dj-&gt;sect);
+		if (res != FR_OK) break;
+		dir = dj-&gt;dir;					/* Ptr to the directory entry of current index */
+		c = dir[DIR_Name];
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
+#if _USE_LFN	/* LFN configuration */
+		a = dir[DIR_Attr] &amp; AM_MASK;
+		if (c == 0xE5 || (!_FS_RPATH &amp;&amp; c == '.') || ((a &amp; AM_VOL) &amp;&amp; a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF;
+		} else {
+			if (a == AM_LFN) {			/* An LFN entry is found */
+				if (c &amp; 0x40) {			/* Is it start of LFN sequence? */
+					sum = dir[LDIR_Chksum];
+					c &amp;= 0xBF; ord = c;
+					dj-&gt;lfn_idx = dj-&gt;index;
+				}
+				/* Check LFN validity and capture it */
+				ord = (c == ord &amp;&amp; sum == dir[LDIR_Chksum] &amp;&amp; pick_lfn(dj-&gt;lfn, dir)) ? ord - 1 : 0xFF;
+			} else {					/* An SFN entry is found */
+				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN entry? */
+					dj-&gt;lfn_idx = 0xFFFF;		/* No LFN. */
+				break;
+			}
+		}
+#else		/* Non LFN configuration */
+		if (c != 0xE5 &amp;&amp; (_FS_RPATH || c != '.') &amp;&amp; !(dir[DIR_Attr] &amp; AM_VOL))	/* Is it a valid entry? */
+			break;
+#endif
+		res = dir_next(dj, FALSE);				/* Next entry */
+		if (res != FR_OK) break;
+	}
+
+	if (res != FR_OK) dj-&gt;sect = 0;
+
+	return res;
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Register an object to the directory                                   */
+/*-----------------------------------------------------------------------*/
 #if !_FS_READONLY
 static
-FRESULT reserve_direntry (    /* FR_OK: successful, FR_DENIED: no free entry, FR_RW_ERROR: a disk error occured */
-    DIR *dirobj,            /* Target directory to create new entry */
-    BYTE **dir                /* Pointer to pointer to created entry to retutn */
+FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
+	DIR *dj				/* Target directory with object name to be created */
 )
 {
-    DWORD clust, sector;
-    BYTE c, n, *dptr;
-    FATFS *fs = dirobj-&gt;fs;
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN	/* LFN configuration */
+	WORD n, ne, is;
+	BYTE sn[12], *fn, sum;
+	WCHAR *lfn;
 
 
-    /* Re-initialize directory object */
-    clust = dirobj-&gt;sclust;
-    if (clust) {    /* Dyanmic directory table */
-        dirobj-&gt;clust = clust;
-        dirobj-&gt;sect = clust2sect(fs, clust);
-    } else {        /* Static directory table */
-        dirobj-&gt;sect = fs-&gt;dirbase;
-    }
-    dirobj-&gt;index = 0;
+	fn = dj-&gt;fn; lfn = dj-&gt;lfn;
+	mem_cpy(sn, fn, 12);
 
-    do {
-        if (!move_window(fs, dirobj-&gt;sect)) return FR_RW_ERROR;
-        dptr = &amp;fs-&gt;win[(dirobj-&gt;index &amp; ((S_SIZ - 1) / 32)) * 32];    /* Pointer to the directory entry */
-        c = dptr[DIR_Name];
-        if (c == 0 || c == 0xE5) {            /* Found an empty entry! */
-            *dir = dptr; return FR_OK;
-        }
-    } while (next_dir_entry(dirobj));                /* Next directory pointer */
-    /* Reached to end of the directory table */
+	if (_FS_RPATH &amp;&amp; (sn[11] &amp; NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */
 
-    /* Abort when static table or could not stretch dynamic table */
-    if (!clust || !(clust = create_chain(fs, dirobj-&gt;clust))) return FR_DENIED;
-    if (clust == 1 || !move_window(fs, 0)) return FR_RW_ERROR;
+	if (sn[11] &amp; NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
+		fn[11] = 0; dj-&gt;lfn = NULL;			/* Find only SFN */
+		for (n = 1; n &lt; 100; n++) {
+			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
+			res = dir_find(dj);				/* Check if the name collides with existing SFN */
+			if (res != FR_OK) break;
+		}
+		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
+		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
+		fn[11] = sn[11]; dj-&gt;lfn = lfn;
+	}
 
-    fs-&gt;winsect = sector = clust2sect(fs, clust);        /* Cleanup the expanded table */
-    memset(fs-&gt;win, 0, S_SIZ);
-    for (n = fs-&gt;sects_clust; n; n--) {
-        if (disk_write(fs-&gt;drive, fs-&gt;win, sector, 1) != RES_OK)
-            return FR_RW_ERROR;
-        sector++;
-    }
-    fs-&gt;winflag = 1;
-    *dir = fs-&gt;win;
-    return FR_OK;
+	if (sn[11] &amp; NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
+		for (ne = 0; lfn[ne]; ne++) ;
+		ne = (ne + 25) / 13;
+	} else {						/* Otherwise reserve only an SFN entry. */
+		ne = 1;
+	}
+
+	/* Reserve contiguous entries */
+	res = dir_seek(dj, 0);
+	if (res != FR_OK) return res;
+	n = is = 0;
+	do {
+		res = move_window(dj-&gt;fs, dj-&gt;sect);
+		if (res != FR_OK) break;
+		c = *dj-&gt;dir;				/* Check the entry status */
+		if (c == 0xE5 || c == 0) {	/* Is it a blank entry? */
+			if (n == 0) is = dj-&gt;index;	/* First index of the contigulus entry */
+			if (++n == ne) break;	/* A contiguous entry that requiered count is found */
+		} else {
+			n = 0;					/* Not a blank entry. Restart to search */
+		}
+		res = dir_next(dj, TRUE);	/* Next entry with table streach */
+	} while (res == FR_OK);
+
+	if (res == FR_OK &amp;&amp; ne &gt; 1) {	/* Initialize LFN entry if needed */
+		res = dir_seek(dj, is);
+		if (res == FR_OK) {
+			sum = sum_sfn(dj-&gt;fn);	/* Sum of the SFN tied to the LFN */
+			ne--;
+			do {					/* Store LFN entries in bottom first */
+				res = move_window(dj-&gt;fs, dj-&gt;sect);
+				if (res != FR_OK) break;
+				fit_lfn(dj-&gt;lfn, dj-&gt;dir, (BYTE)ne, sum);
+				dj-&gt;fs-&gt;wflag = 1;
+				res = dir_next(dj, FALSE);	/* Next entry */
+			} while (res == FR_OK &amp;&amp; --ne);
+		}
+	}
+
+#else	/* Non LFN configuration */
+	res = dir_seek(dj, 0);
+	if (res == FR_OK) {
+		do {	/* Find a blank entry for the SFN */
+			res = move_window(dj-&gt;fs, dj-&gt;sect);
+			if (res != FR_OK) break;
+			c = *dj-&gt;dir;
+			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
+			res = dir_next(dj, TRUE);		/* Next entry with table streach */
+		} while (res == FR_OK);
+	}
+#endif
+
+	if (res == FR_OK) {		/* Initialize the SFN entry */
+		res = move_window(dj-&gt;fs, dj-&gt;sect);
+		if (res == FR_OK) {
+			dir = dj-&gt;dir;
+			mem_set(dir, 0, 32);		/* Clean the entry */
+			mem_cpy(dir, dj-&gt;fn, 11);	/* Put SFN */
+			dir[DIR_NTres] = *(dj-&gt;fn+11) &amp; 0x18;	/* Put NT flag */
+			dj-&gt;fs-&gt;wflag = 1;
+		}
+	}
+
+	return res;
 }
 #endif /* !_FS_READONLY */
 
@@ -590,148 +1025,551 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Load boot record and check if it is a FAT boot record                 */
+/* Remove an object from the directory                                   */
 /*-----------------------------------------------------------------------*/
+#if !_FS_READONLY &amp;&amp; !_FS_MINIMIZE
+static
+FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
+	DIR *dj				/* Directory object pointing the entry to be removed */
+)
+{
+	FRESULT res;
+#if _USE_LFN	/* LFN configuration */
+	WORD i;
 
+	i = dj-&gt;index;	/* SFN index */
+	res = dir_seek(dj, (WORD)((dj-&gt;lfn_idx == 0xFFFF) ? i : dj-&gt;lfn_idx));	/* Goto the SFN or top of the LFN entries */
+	if (res == FR_OK) {
+		do {
+			res = move_window(dj-&gt;fs, dj-&gt;sect);
+			if (res != FR_OK) break;
+			*dj-&gt;dir = 0xE5;			/* Mark the entry &quot;deleted&quot; */
+			dj-&gt;fs-&gt;wflag = 1;
+			if (dj-&gt;index &gt;= i) break;	/* When reached SFN, all entries of the object has been deleted. */
+			res = dir_next(dj, FALSE);	/* Next entry */
+		} while (res == FR_OK);
+		if (res == FR_NO_FILE) res = FR_INT_ERR;
+	}
+
+#else			/* Non LFN configuration */
+	res = dir_seek(dj, dj-&gt;index);
+	if (res == FR_OK) {
+		res = move_window(dj-&gt;fs, dj-&gt;sect);
+		if (res == FR_OK) {
+			*dj-&gt;dir = 0xE5;			/* Mark the entry &quot;deleted&quot; */
+			dj-&gt;fs-&gt;wflag = 1;
+		}
+	}
+#endif
+
+	return res;
+}
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Pick a segment and create the object name in directory form           */
+/*-----------------------------------------------------------------------*/
+
+
 static
-BYTE check_fs (        /* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record or error */
-    FATFS *fs,        /* File system object */
-    DWORD sect        /* Sector# (lba) to check if it is a FAT boot record or not */
+FRESULT create_name (
+	DIR *dj,			/* Pointer to the directory object */
+	const XCHAR **path	/* Pointer to pointer to the segment in the path string */
 )
 {
-    if (disk_read(fs-&gt;drive, fs-&gt;win, sect, 1) != RES_OK)    /* Load boot record */
-        return 2;
-    if (LD_WORD(&amp;fs-&gt;win[BS_55AA]) != 0xAA55)                /* Check record signature (always offset 510) */
-        return 2;
+#ifdef _EXCVT
+	static const BYTE cvt[] = _EXCVT;
+#endif
+#if _USE_LFN	/* LFN configuration */
+	BYTE b, cf;
+	WCHAR w, *lfn;
+	int i, ni, si, di;
+	const XCHAR *p;
 
-    if (!memcmp(&amp;fs-&gt;win[BS_FilSysType], &quot;FAT&quot;, 3))            /* Check FAT signature */
-        return 0;
-    if (!memcmp(&amp;fs-&gt;win[BS_FilSysType32], &quot;FAT32&quot;, 5) &amp;&amp; !(fs-&gt;win[BPB_ExtFlags] &amp; 0x80))
-        return 0;
+	/* Create LFN in Unicode */
+	si = di = 0;
+	p = *path;
+	lfn = dj-&gt;lfn;
+	for (;;) {
+		w = p[si++];					/* Get a character */
+		if (w &lt; L' ' || w == L'/' || w == L'\\') break;	/* Break on end of segment */
+		if (di &gt;= _MAX_LFN)				/* Reject too long name */
+			return FR_INVALID_NAME;
+#if !_LFN_UNICODE
+		w &amp;= 0xFF;
+		if (IsDBCS1(w)) {				/* If it is a DBC 1st byte */
+			BYTE c = p[si++];			/* Get 2nd byte */
+			if (!IsDBCS2(c))			/* Reject invalid code for DBC */
+				return FR_INVALID_NAME;
+			w = (w &lt;&lt; 8) + c;
+		}
+		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
+		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
+#endif
+		if (w &lt; 0x80 &amp;&amp; chk_chr(&quot;\&quot;*:&lt;&gt;\?|\x7F&quot;, w)) /* Reject unallowable chars for LFN */
+			return FR_INVALID_NAME;
+		lfn[di++] = w;					/* Store the Unicode char */
+	}
+	*path = &amp;p[si];						/* Rerurn pointer to the next segment */
+	cf = (w &lt; L' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
+#if _FS_RPATH
+	if ((di == 1 &amp;&amp; lfn[di - 1] == L'.') || /* Is this a dot entry? */
+		(di == 2 &amp;&amp; lfn[di - 1] == L'.' &amp;&amp; lfn[di - 2] == L'.')) {
+		lfn[di] = 0;
+		for (i = 0; i &lt; 11; i++)
+			dj-&gt;fn[i] = (i &lt; di) ? '.' : ' ';
+		dj-&gt;fn[i] = cf | NS_DOT;		/* This is a dot entry */
+		return FR_OK;
+	}
+#endif
+	while (di) {						/* Strip trailing spaces and dots */
+		w = lfn[di - 1];
+		if (w != L' ' &amp;&amp; w != L'.') break;
+		di--;
+	}
+	if (!di) return FR_INVALID_NAME;	/* Reject null string */
 
-    return 1;
+	lfn[di] = 0;						/* LFN is created */
+
+	/* Create SFN in directory form */
+	mem_set(dj-&gt;fn, ' ', 11);
+	for (si = 0; lfn[si] == L' ' || lfn[si] == L'.'; si++) ;	/* Strip leading spaces and dots */
+	if (si) cf |= NS_LOSS | NS_LFN;
+	while (di &amp;&amp; lfn[di - 1] != '.') di--;	/* Find extension (di&lt;=si: no extension) */
+
+	b = i = 0; ni = 8;
+	for (;;) {
+		w = lfn[si++];					/* Get an LFN char */
+		if (!w) break;					/* Break when enf of the LFN */
+		if (w == L' ' || (w == L'.' &amp;&amp; si != di)) {	/* Remove spaces and dots */
+			cf |= NS_LOSS | NS_LFN; continue;
+		}
+
+		if (i &gt;= ni || si == di) {		/* Extension or end of SFN */
+			if (ni == 11) {				/* Long extension */
+				cf |= NS_LOSS | NS_LFN; break;
+			}
+			if (si != di) cf |= NS_LOSS | NS_LFN;	/* File name is longer than 8 bytes */
+			if (si &gt; di) break;			/* No extension */
+			si = di; i = 8; ni = 11;	/* Enter extension section */
+			b &lt;&lt;= 2; continue;
+		}
+
+		if (w &gt;= 0x80) {				/* Non ASCII char */
+#ifdef _EXCVT
+			w = ff_convert(w, 0);		/* Unicode -&gt; OEM code */
+			if (w) w = cvt[w - 0x80];	/* Convert extend char (SBCS) */
+#else
+			w = ff_convert(ff_wtoupper(w), 0);	/* Unicode (Caps) -&gt; OEM code */
+#endif
+			cf |= NS_LFN;				/* Force create an LFN */
+		}
+
+		if (_DF1S &amp;&amp; w &gt;= 0x100) {		/* Double byte char */
+			if (i &gt;= ni - 1) {
+				cf |= NS_LOSS | NS_LFN; i = ni; continue;
+			}
+			dj-&gt;fn[i++] = (BYTE)(w &gt;&gt; 8);
+		} else {						/* Single byte char */
+			if (!w || chk_chr(&quot;+,;[=]&quot;, w)) {	/* Replace unallowable chars for SFN */
+				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
+			} else {
+				if (IsUpper(w)) {		/* Large capital */
+					b |= 2;
+				} else {
+					if (IsLower(w)) {	/* Small capital */
+						b |= 1; w -= 0x20;
+					}
+				}
+			}
+		}
+		dj-&gt;fn[i++] = (BYTE)w;
+	}
+
+	if (dj-&gt;fn[0] == 0xE5) dj-&gt;fn[0] = 0x05;	/* If the first char collides with 0xE5, replace it with 0x05 */
+
+	if (ni == 8) b &lt;&lt;= 2;
+	if ((b &amp; 0x0C) == 0x0C || (b &amp; 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
+		cf |= NS_LFN;
+	if (!(cf &amp; NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
+		if ((b &amp; 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
+		if ((b &amp; 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
+	}
+
+	dj-&gt;fn[11] = cf;	/* SFN is created */
+
+
+#else	/* Non-LFN configuration */
+	BYTE b, c, d, *sfn;
+	int ni, si, i;
+	const char *p;
+
+	/* Create file name in directory form */
+	sfn = dj-&gt;fn;
+	mem_set(sfn, ' ', 11);
+	si = i = b = 0; ni = 8;
+	p = *path;
+#if _FS_RPATH
+	if (p[si] == '.') { /* Is this a dot entry? */
+		for (;;) {
+			c = p[si++];
+			if (c != '.' || si &gt;= 3) break;
+			sfn[i++] = c;
+		}
+		if (c != '/' &amp;&amp; c != '\\' &amp;&amp; c &gt;= ' ') return FR_INVALID_NAME;
+		*path = &amp;p[si];									/* Rerurn pointer to the next segment */
+		sfn[11] = (c &lt; ' ') ? NS_LAST|NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
+		return FR_OK;
+	}
+#endif
+	for (;;) {
+		c = p[si++];
+		if (c &lt; ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
+		if (c == '.' || i &gt;= ni) {
+			if (ni != 8 || c != '.') return FR_INVALID_NAME;
+			i = 8; ni = 11;
+			b &lt;&lt;= 2; continue;
+		}
+		if (c &gt;= 0x80) {				/* Extended char */
+#ifdef _EXCVT
+			c = cvt[c - 0x80];			/* Convert extend char (SBCS) */
+#else
+			b |= 3;						/* Eliminate NT flag if ext char is exist */
+#if !_DF1S	/* ASCII only cfg */
+			return FR_INVALID_NAME;
+#endif
+#endif
+		}
+		if (IsDBCS1(c)) {				/* If it is DBC 1st byte */
+			d = p[si++];				/* Get 2nd byte */
+			if (!IsDBCS2(d) || i &gt;= ni - 1)	/* Reject invalid DBC */
+				return FR_INVALID_NAME;
+			sfn[i++] = c;
+			sfn[i++] = d;
+		} else {
+			if (chk_chr(&quot; \&quot;*+,[=]|\x7F&quot;, c))	/* Reject unallowable chrs for SFN */
+				return FR_INVALID_NAME;
+			if (IsUpper(c)) {
+				b |= 2;
+			} else {
+				if (IsLower(c)) {
+					b |= 1; c -= 0x20;
+				}
+			}
+			sfn[i++] = c;
+		}
+	}
+	*path = &amp;p[si];						/* Rerurn pointer to the next segment */
+	c = (c &lt; ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
+
+	if (!i) return FR_INVALID_NAME;		/* Reject null string */
+	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
+
+	if (ni == 8) b &lt;&lt;= 2;
+	if ((b &amp; 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
+	if ((b &amp; 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
+
+	sfn[11] = c;		/* Store NT flag, File name is created */
+#endif
+
+	return FR_OK;
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
+/* Get file information from directory entry                             */
+/*-----------------------------------------------------------------------*/
+#if _FS_MINIMIZE &lt;= 1
+static
+void get_fileinfo (		/* No return code */
+	DIR *dj,			/* Pointer to the directory object */
+	FILINFO *fno	 	/* Pointer to store the file information */
+)
+{
+	int i;
+	BYTE c, nt, *dir;
+	char *p;
+#if _USE_LFN
+	XCHAR *tp;
+#endif
+
+
+	p = fno-&gt;fname;
+	if (dj-&gt;sect) {
+		dir = dj-&gt;dir;
+		nt = dir[DIR_NTres];		/* NT flag */
+		for (i = 0; i &lt; 8; i++) {	/* Copy name body */
+			c = dir[i];
+			if (c == ' ') break;
+			if (c == 0x05) c = 0xE5;
+			if ((nt &amp; 0x08) &amp;&amp; IsUpper(c)) c += 0x20;
+			*p++ = c;
+		}
+		if (dir[8] != ' ') {		/* Copy name extension */
+			*p++ = '.';
+			for (i = 8; i &lt; 11; i++) {
+				c = dir[i];
+				if (c == ' ') break;
+				if ((nt &amp; 0x10) &amp;&amp; IsUpper(c)) c += 0x20;
+				*p++ = c;
+			}
+		}
+		fno-&gt;fattrib = dir[DIR_Attr];				/* Attribute */
+		fno-&gt;fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
+		fno-&gt;fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
+		fno-&gt;ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
+	}
+	*p = 0;
+
+#if _USE_LFN
+	tp = fno-&gt;lfname;
+	if (tp) {
+		WCHAR w, *lfn;
+
+		i = 0;
+		if (dj-&gt;sect &amp;&amp; dj-&gt;lfn_idx != 0xFFFF) {/* Get LFN if available */
+			lfn = dj-&gt;lfn;
+			while ((w = *lfn++) != 0) {			/* Get an LFN char */
+#if !_LFN_UNICODE
+				w = ff_convert(w, 0);			/* Unicode -&gt; OEM conversion */
+				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
+				if (_DF1S &amp;&amp; w &gt;= 0x100)		/* Put 1st byte if it is a DBC */
+					tp[i++] = (XCHAR)(w &gt;&gt; 8);
+				if (i &gt;= fno-&gt;lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
+#endif
+				tp[i++] = (XCHAR)w;
+			}
+		}
+		tp[i] = 0;	/* Terminator */
+	}
+#endif
+}
+#endif /* _FS_MINIMIZE &lt;= 1 */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Follow a file path                                                    */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
+	DIR *dj,			/* Directory object to return last directory and found object */
+	const XCHAR *path	/* Full-path string to find a file or directory */
+)
+{
+	FRESULT res;
+	BYTE *dir, last;
+
+
+#if _FS_RPATH
+	if (*path == '/' || *path == '\\') { /* There is a heading separator */
+		path++;	dj-&gt;sclust = 0;		/* Strip it and start from the root dir */
+	} else {							/* No heading saparator */
+		dj-&gt;sclust = dj-&gt;fs-&gt;cdir;	/* Start from the current dir */
+	}
+#else
+	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
+		path++;
+	dj-&gt;sclust = 0;						/* Start from the root dir */
+#endif
+
+	if ((UINT)*path &lt; ' ') {			/* Null path means the start directory itself */
+		res = dir_seek(dj, 0);
+		dj-&gt;dir = NULL;
+
+	} else {							/* Follow path */
+		for (;;) {
+			res = create_name(dj, &amp;path);	/* Get a segment */
+			if (res != FR_OK) break;
+			res = dir_find(dj);				/* Find it */
+			last = *(dj-&gt;fn+11) &amp; NS_LAST;
+			if (res != FR_OK) {				/* Could not find the object */
+				if (res == FR_NO_FILE &amp;&amp; !last)
+					res = FR_NO_PATH;
+				break;
+			}
+			if (last) break;				/* Last segment match. Function completed. */
+			dir = dj-&gt;dir;					/* There is next segment. Follow the sub directory */
+			if (!(dir[DIR_Attr] &amp; AM_DIR)) { /* Cannot follow because it is a file */
+				res = FR_NO_PATH; break;
+			}
+			dj-&gt;sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
+		}
+	}
+
+	return res;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Load boot record and check if it is an FAT boot record                */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
+	FATFS *fs,	/* File system object */
+	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
+)
+{
+	static const char fatstr[] = &quot;FAT&quot;;
+
+
+	if (disk_read(fs-&gt;drive, fs-&gt;win, sect, 1) != RES_OK)	/* Load boot record */
+		return 3;
+	if (LD_WORD(&amp;fs-&gt;win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is &gt;512) */
+		return 2;
+
+	if (!mem_cmp(&amp;fs-&gt;win[BS_FilSysType], fatstr, 3))	/* Check FAT signature */
+		return 0;
+	if (!mem_cmp(&amp;fs-&gt;win[BS_FilSysType32], fatstr, 3) &amp;&amp; !(fs-&gt;win[BPB_ExtFlags] &amp; 0x80))
+		return 0;
+
+	return 1;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
 /* Make sure that the file system is valid                               */
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT auto_mount (        /* FR_OK(0): successful, !=0: any error occured */
-    const char **path,        /* Pointer to pointer to the path name (drive number) */
-    FATFS **rfs,            /* Pointer to pointer to the found file system object */
-    BYTE chk_wp                /* !=0: Check media write protection for wrinting fuctions */
+FRESULT auto_mount (	/* FR_OK(0): successful, !=0: any error occured */
+	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
+	FATFS **rfs,		/* Pointer to pointer to the found file system object */
+	BYTE chk_wp			/* !=0: Check media write protection for write access */
 )
 {
-    BYTE drv, fmt, *tbl;
-    DSTATUS stat;
-    DWORD bootsect, fatsize, totalsect, maxclust;
-    const char *p = *path;
-    FATFS *fs;
+	FRESULT res;
+	BYTE fmt, *tbl;
+	UINT vol;
+	DSTATUS stat;
+	DWORD bsect, fsize, tsect, mclst;
+	const XCHAR *p = *path;
+	FATFS *fs;
 
 
-    /* Get drive number from the path name */
-    while (*p == ' ') p++;        /* Strip leading spaces */
-    drv = p[0] - '0';            /* Is there a drive number? */
-    if (drv &lt;= 9 &amp;&amp; p[1] == ':')
-        p += 2;            /* Found a drive number, get and strip it */
-    else
-        drv = 0;        /* No drive number is given, select drive 0 in default */
-    if (*p == '/') p++;    /* Strip heading slash */
-    *path = p;            /* Return pointer to the path name */
+	/* Get logical drive number from the path name */
+	vol = p[0] - '0';				/* Is there a drive number? */
+	if (vol &lt;= 9 &amp;&amp; p[1] == ':') {	/* Found a drive number, get and strip it */
+		p += 2; *path = p;			/* Return pointer to the path name */
+	} else {						/* No drive number is given */
+#if _FS_RPATH
+		vol = Drive;				/* Use current drive */
+#else
+		vol = 0;					/* Use drive 0 */
+#endif
+	}
 
-    /* Check if the drive number is valid or not */
-    if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;    /* Is the drive number valid? */
-    if (!(fs = FatFs[drv])) return FR_NOT_ENABLED;    /* Is the file system object registered? */
-    *rfs = fs;            /* Returen pointer to the corresponding file system object */
+	/* Check if the logical drive is valid or not */
+	if (vol &gt;= _DRIVES) 			/* Is the drive number valid? */
+		return FR_INVALID_DRIVE;
+	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
+	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object registered? */
 
-    /* Check if the logical drive has been mounted or not */
-    if (fs-&gt;fs_type) {
-        stat = disk_status(fs-&gt;drive);
-        if (!(stat &amp; STA_NOINIT)) {                /* If the physical drive is kept initialized */
+	ENTER_FF(fs);					/* Lock file system */
+
+	if (fs-&gt;fs_type) {				/* If the logical drive has been mounted */
+		stat = disk_status(fs-&gt;drive);
+		if (!(stat &amp; STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
 #if !_FS_READONLY
-            if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))    /* Check write protection if needed */
-                return FR_WRITE_PROTECTED;
+			if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))	/* Check write protection if needed */
+				return FR_WRITE_PROTECTED;
 #endif
-            return FR_OK;                        /* The file system object is valid */
-        }
-    }
+			return FR_OK;			/* The file system object is valid */
+		}
+	}
 
-    /* The logical drive has not been mounted, following code attempts to mount the logical drive */
+	/* The logical drive must be mounted. Following code attempts to mount the volume */
 
-    memset(fs, 0, sizeof(FATFS));        /* Clean-up the file system object */
-    fs-&gt;drive = LD2PD(drv);                /* Bind the logical drive and a physical drive */
-    stat = disk_initialize(fs-&gt;drive);    /* Initialize low level disk I/O layer */
-    if (stat &amp; STA_NOINIT)                /* Check if the drive is ready */
-        return FR_NOT_READY;
-#if S_MAX_SIZ &gt; 512                        /* Check disk sector size */
-    if (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;S_SIZ) != RES_OK || S_SIZ &gt; S_MAX_SIZ)
-        return FR_NO_FILESYSTEM;
+	fs-&gt;fs_type = 0;					/* Clear the file system object */
+	fs-&gt;drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
+	stat = disk_initialize(fs-&gt;drive);	/* Initialize low level disk I/O layer */
+	if (stat &amp; STA_NOINIT)				/* Check if the drive is ready */
+		return FR_NOT_READY;
+#if _MAX_SS != 512						/* Get disk sector size if needed */
+	if (disk_ioctl(fs-&gt;drive, GET_SECTOR_SIZE, &amp;SS(fs)) != RES_OK || SS(fs) &gt; _MAX_SS)
+		return FR_NO_FILESYSTEM;
 #endif
 #if !_FS_READONLY
-    if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))    /* Check write protection if needed */
-        return FR_WRITE_PROTECTED;
+	if (chk_wp &amp;&amp; (stat &amp; STA_PROTECT))	/* Check disk write protection if needed */
+		return FR_WRITE_PROTECTED;
 #endif
-    /* Search FAT partition on the drive */
-    fmt = check_fs(fs, bootsect = 0);    /* Check sector 0 as an SFD format */
-    if (fmt == 1) {                        /* Not a FAT boot record, it may be patitioned */
-        /* Check a partition listed in top of the partition table */
-        tbl = &amp;fs-&gt;win[MBR_Table + LD2PT(drv) * 16];    /* Partition table */
-        if (tbl[4]) {                                /* Is the partition existing? */
-            bootsect = LD_DWORD(&amp;tbl[8]);            /* Partition offset in LBA */
-            fmt = check_fs(fs, bootsect);            /* Check the partition */
-        }
-    }
-    if (fmt || LD_WORD(&amp;fs-&gt;win[BPB_BytsPerSec]) != S_SIZ)    /* No valid FAT patition is found */
-        return FR_NO_FILESYSTEM;
+	/* Search FAT partition on the drive */
+	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
+	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
+		/* Check a partition listed in top of the partition table */
+		tbl = &amp;fs-&gt;win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
+		if (tbl[4]) {									/* Is the partition existing? */
+			bsect = LD_DWORD(&amp;tbl[8]);					/* Partition offset in LBA */
+			fmt = check_fs(fs, bsect);					/* Check the partition */
+		}
+	}
+	if (fmt == 3) return FR_DISK_ERR;
+	if (fmt || LD_WORD(fs-&gt;win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
+		return FR_NO_FILESYSTEM;
 
-    /* Initialize the file system object */
-    fatsize = LD_WORD(&amp;fs-&gt;win[BPB_FATSz16]);            /* Number of sectors per FAT */
-    if (!fatsize) fatsize = LD_DWORD(&amp;fs-&gt;win[BPB_FATSz32]);
-    fs-&gt;sects_fat = fatsize;
-    fs-&gt;n_fats = fs-&gt;win[BPB_NumFATs];                    /* Number of FAT copies */
-    fatsize *= fs-&gt;n_fats;                                /* (Number of sectors in FAT area) */
-    fs-&gt;fatbase = bootsect + LD_WORD(&amp;fs-&gt;win[BPB_RsvdSecCnt]); /* FAT start sector (lba) */
-    fs-&gt;sects_clust = fs-&gt;win[BPB_SecPerClus];            /* Number of sectors per cluster */
-    fs-&gt;n_rootdir = LD_WORD(&amp;fs-&gt;win[BPB_RootEntCnt]);    /* Nmuber of root directory entries */
-    totalsect = LD_WORD(&amp;fs-&gt;win[BPB_TotSec16]);        /* Number of sectors on the file system */
-    if (!totalsect) totalsect = LD_DWORD(&amp;fs-&gt;win[BPB_TotSec32]);
-    fs-&gt;max_clust = maxclust = (totalsect                /* Last cluster# + 1 */
-        - LD_WORD(&amp;fs-&gt;win[BPB_RsvdSecCnt]) - fatsize - fs-&gt;n_rootdir / (S_SIZ/32)
-        ) / fs-&gt;sects_clust + 2;
+	/* Initialize the file system object */
+	fsize = LD_WORD(fs-&gt;win+BPB_FATSz16);				/* Number of sectors per FAT */
+	if (!fsize) fsize = LD_DWORD(fs-&gt;win+BPB_FATSz32);
+	fs-&gt;sects_fat = fsize;
+	fs-&gt;n_fats = fs-&gt;win[BPB_NumFATs];					/* Number of FAT copies */
+	fsize *= fs-&gt;n_fats;								/* (Number of sectors in FAT area) */
+	fs-&gt;fatbase = bsect + LD_WORD(fs-&gt;win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
+	fs-&gt;csize = fs-&gt;win[BPB_SecPerClus];				/* Number of sectors per cluster */
+	fs-&gt;n_rootdir = LD_WORD(fs-&gt;win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
+	tsect = LD_WORD(fs-&gt;win+BPB_TotSec16);				/* Number of sectors on the file system */
+	if (!tsect) tsect = LD_DWORD(fs-&gt;win+BPB_TotSec32);
+	fs-&gt;max_clust = mclst = (tsect						/* Last cluster# + 1 */
+		- LD_WORD(fs-&gt;win+BPB_RsvdSecCnt) - fsize - fs-&gt;n_rootdir / (SS(fs)/32)
+		) / fs-&gt;csize + 2;
 
-    fmt = FS_FAT12;                                        /* Determine the FAT sub type */
-    if (maxclust &gt; 0xFF7) fmt = FS_FAT16;
-    if (maxclust &gt; 0xFFF7) fmt = FS_FAT32;
-    fs-&gt;fs_type = fmt;
+	fmt = FS_FAT12;										/* Determine the FAT sub type */
+	if (mclst &gt;= 0xFF7) fmt = FS_FAT16;					/* Number of clusters &gt;= 0xFF5 */
+	if (mclst &gt;= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters &gt;= 0xFFF5 */
 
-    if (fmt == FS_FAT32)
-        fs-&gt;dirbase = LD_DWORD(&amp;fs-&gt;win[BPB_RootClus]);    /* Root directory start cluster */
-    else
-        fs-&gt;dirbase = fs-&gt;fatbase + fatsize;            /* Root directory start sector (lba) */
-    fs-&gt;database = fs-&gt;fatbase + fatsize + fs-&gt;n_rootdir / (S_SIZ/32);    /* Data start sector (lba) */
+	if (fmt == FS_FAT32)
+		fs-&gt;dirbase = LD_DWORD(fs-&gt;win+BPB_RootClus);	/* Root directory start cluster */
+	else
+		fs-&gt;dirbase = fs-&gt;fatbase + fsize;				/* Root directory start sector (lba) */
+	fs-&gt;database = fs-&gt;fatbase + fsize + fs-&gt;n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
 
 #if !_FS_READONLY
-    fs-&gt;free_clust = 0xFFFFFFFF;
-#if _USE_FSINFO
-    /* Load fsinfo sector if needed */
-    if (fmt == FS_FAT32) {
-        fs-&gt;fsi_sector = bootsect + LD_WORD(&amp;fs-&gt;win[BPB_FSInfo]);
-        if (disk_read(0, fs-&gt;win, fs-&gt;fsi_sector, 1) == RES_OK &amp;&amp;
-            LD_WORD(&amp;fs-&gt;win[BS_55AA]) == 0xAA55 &amp;&amp;
-            LD_DWORD(&amp;fs-&gt;win[FSI_LeadSig]) == 0x41615252 &amp;&amp;
-            LD_DWORD(&amp;fs-&gt;win[FSI_StrucSig]) == 0x61417272) {
-            fs-&gt;last_clust = LD_DWORD(&amp;fs-&gt;win[FSI_Nxt_Free]);
-            fs-&gt;free_clust = LD_DWORD(&amp;fs-&gt;win[FSI_Free_Count]);
-        }
-    }
+	/* Initialize allocation information */
+	fs-&gt;free_clust = 0xFFFFFFFF;
+	fs-&gt;wflag = 0;
+	/* Get fsinfo if needed */
+	if (fmt == FS_FAT32) {
+	 	fs-&gt;fsi_flag = 0;
+		fs-&gt;fsi_sector = bsect + LD_WORD(fs-&gt;win+BPB_FSInfo);
+		if (disk_read(fs-&gt;drive, fs-&gt;win, fs-&gt;fsi_sector, 1) == RES_OK &amp;&amp;
+			LD_WORD(fs-&gt;win+BS_55AA) == 0xAA55 &amp;&amp;
+			LD_DWORD(fs-&gt;win+FSI_LeadSig) == 0x41615252 &amp;&amp;
+			LD_DWORD(fs-&gt;win+FSI_StrucSig) == 0x61417272) {
+			fs-&gt;last_clust = LD_DWORD(fs-&gt;win+FSI_Nxt_Free);
+			fs-&gt;free_clust = LD_DWORD(fs-&gt;win+FSI_Free_Count);
+		}
+	}
 #endif
+	fs-&gt;fs_type = fmt;		/* FAT sub-type */
+	fs-&gt;winsect = 0;		/* Invalidate sector cache */
+#if _FS_RPATH
+	fs-&gt;cdir = 0;			/* Current directory (root dir) */
 #endif
-    fs-&gt;id = ++fsid;                                    /* File system mount ID */
-    return FR_OK;
+	fs-&gt;id = ++Fsid;		/* File system mount ID */
+	res = FR_OK;
+
+	return res;
 }
 
 
@@ -742,17 +1580,20 @@
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT validate (        /* FR_OK(0): The object is valid, !=0: Not valid */
-    const FATFS *fs,    /* Pointer to the file system object */
-    WORD id                /* id member of the target object to be checked */
+FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
+	FATFS *fs,		/* Pointer to the file system object */
+	WORD id			/* Member id of the target object to be checked */
 )
 {
-    if (!fs || fs-&gt;id != id)
-        return FR_INVALID_OBJECT;
-    if (disk_status(fs-&gt;drive) &amp; STA_NOINIT)
-        return FR_NOT_READY;
+	if (!fs || !fs-&gt;fs_type || fs-&gt;id != id)
+		return FR_INVALID_OBJECT;
 
-    return FR_OK;
+	ENTER_FF(fs);		/* Lock file system */
+
+	if (disk_status(fs-&gt;drive) &amp; STA_NOINIT)
+		return FR_NOT_READY;
+
+	return FR_OK;
 }
 
 
@@ -771,20 +1612,33 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_mount (
-    BYTE drv,        /* Logical drive number to be mounted/unmounted */
-    FATFS *fs        /* Pointer to new file system object (NULL for unmount)*/
+	BYTE vol,		/* Logical drive number to be mounted/unmounted */
+	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
 )
 {
-    FATFS *fsobj;
+	FATFS *rfs;
 
 
-    if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
-    fsobj = FatFs[drv];
-    FatFs[drv] = fs;
-    if (fsobj) memset(fsobj, 0, sizeof(FATFS));
-    if (fs) memset(fs, 0, sizeof(FATFS));
+	if (vol &gt;= _DRIVES)				/* Check if the drive number is valid */
+		return FR_INVALID_DRIVE;
+	rfs = FatFs[vol];				/* Get current fs object */
 
-    return FR_OK;
+	if (rfs) {
+#if _FS_REENTRANT					/* Discard sync object of the current volume */
+		if (!ff_del_syncobj(rfs-&gt;sobj)) return FR_INT_ERR;
+#endif
+		rfs-&gt;fs_type = 0;			/* Clear old fs object */
+	}
+
+	if (fs) {
+		fs-&gt;fs_type = 0;			/* Clear new fs object */
+#if _FS_REENTRANT					/* Create sync object for the new volume */
+		if (!ff_cre_syncobj(vol, &amp;fs-&gt;sobj)) return FR_INT_ERR;
+#endif
+	}
+	FatFs[vol] = fs;				/* Register new fs object */
+
+	return FR_OK;
 }
 
 
@@ -795,92 +1649,94 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_open (
-    FIL *fp,            /* Pointer to the blank file object */
-    const char *path,    /* Pointer to the file name */
-    BYTE mode            /* Access mode and file open mode flags */
+	FIL *fp,			/* Pointer to the blank file object */
+	const XCHAR *path,	/* Pointer to the file name */
+	BYTE mode			/* Access mode and file open mode flags */
 )
 {
-    FRESULT res;
-    BYTE *dir;
-    DIR dirobj;
-    char fn[8+3+1];
-    FATFS *fs;
+	FRESULT res;
+	DIR dj;
+	NAMEBUF(sfn, lfn);
+	BYTE *dir;
 
 
-    fp-&gt;fs = NULL;
+	fp-&gt;fs = NULL;		/* Clear file object */
 #if !_FS_READONLY
-    mode &amp;= (FA_READ|FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW);
-    res = auto_mount(&amp;path, &amp;fs, (BYTE)(mode &amp; (FA_WRITE|FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)));
+	mode &amp;= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
+	res = auto_mount(&amp;path, &amp;dj.fs, (BYTE)(mode &amp; (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
 #else
-    mode &amp;= FA_READ;
-    res = auto_mount(&amp;path, &amp;fs, 0);
+	mode &amp;= FA_READ;
+	res = auto_mount(&amp;path, &amp;dj.fs, 0);
 #endif
-    if (res != FR_OK) return res;
-    dirobj.fs = fs;
+	if (res != FR_OK) LEAVE_FF(dj.fs, res);
+	INITBUF(dj, sfn, lfn);
+	res = follow_path(&amp;dj, path);	/* Follow the file path */
 
-    /* Trace the file path */
-    res = trace_path(&amp;dirobj, fn, path, &amp;dir);
 #if !_FS_READONLY
-    /* Create or Open a file */
-    if (mode &amp; (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS|FA_CREATE_NEW)) {
-        DWORD ps, rs;
-        if (res != FR_OK) {        /* No file, create new */
-            if (res != FR_NO_FILE) return res;
-            res = reserve_direntry(&amp;dirobj, &amp;dir);
-            if (res != FR_OK) return res;
-            memset(dir, 0, 32);                        /* Initialize the new entry with open name */
-            memcpy(&amp;dir[DIR_Name], fn, 8+3);
-            dir[DIR_NTres] = fn[11];
-            mode |= FA_CREATE_ALWAYS;
-        }
-        else {                    /* Any object is already existing */
-            if (mode &amp; FA_CREATE_NEW)            /* Cannot create new */
-                return FR_EXIST;
-            if (dir == NULL || (dir[DIR_Attr] &amp; (AM_RDO|AM_DIR)))    /* Cannot overwrite it (R/O or DIR) */
-                return FR_DENIED;
-            if (mode &amp; FA_CREATE_ALWAYS) {        /* Resize it to zero if needed */
-                rs = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);    /* Get start cluster */
-                ST_WORD(&amp;dir[DIR_FstClusHI], 0);    /* cluster = 0 */
-                ST_WORD(&amp;dir[DIR_FstClusLO], 0);
-                ST_DWORD(&amp;dir[DIR_FileSize], 0);    /* size = 0 */
-                fs-&gt;winflag = 1;
-                ps = fs-&gt;winsect;                /* Remove the cluster chain */
-                if (!remove_chain(fs, rs) || !move_window(fs, ps))
-                    return FR_RW_ERROR;
-                fs-&gt;last_clust = rs - 1;        /* Reuse the cluster hole */
-            }
-        }
-        if (mode &amp; FA_CREATE_ALWAYS) {
-            dir[DIR_Attr] = AM_ARC;                /* New attribute */
-            ps = get_fattime();
-            ST_DWORD(&amp;dir[DIR_WrtTime], ps);    /* Updated time */
-            ST_DWORD(&amp;dir[DIR_CrtTime], ps);    /* Created time */
-            fs-&gt;winflag = 1;
-        }
-    }
-    /* Open an existing file */
-    else {
+	/* Create or Open a file */
+	if (mode &amp; (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
+		DWORD ps, cl;
+
+		if (res != FR_OK) {			/* No file, create new */
+			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
+				res = dir_register(&amp;dj);
+			if (res != FR_OK) LEAVE_FF(dj.fs, res);
+			mode |= FA_CREATE_ALWAYS;
+			dir = dj.dir;			/* Created entry (SFN entry) */
+		}
+		else {						/* Any object is already existing */
+			if (mode &amp; FA_CREATE_NEW)			/* Cannot create new */
+				LEAVE_FF(dj.fs, FR_EXIST);
+			dir = dj.dir;
+			if (!dir || (dir[DIR_Attr] &amp; (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
+				LEAVE_FF(dj.fs, FR_DENIED);
+			if (mode &amp; FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
+				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
+				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
+				ST_WORD(dir+DIR_FstClusLO, 0);
+				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
+				dj.fs-&gt;wflag = 1;
+				ps = dj.fs-&gt;winsect;			/* Remove the cluster chain */
+				if (cl) {
+					res = remove_chain(dj.fs, cl);
+					if (res) LEAVE_FF(dj.fs, res);
+					dj.fs-&gt;last_clust = cl - 1;	/* Reuse the cluster hole */
+				}
+				res = move_window(dj.fs, ps);
+				if (res != FR_OK) LEAVE_FF(dj.fs, res);
+			}
+		}
+		if (mode &amp; FA_CREATE_ALWAYS) {
+			dir[DIR_Attr] = 0;					/* Reset attribute */
+			ps = get_fattime();
+			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
+			dj.fs-&gt;wflag = 1;
+			mode |= FA__WRITTEN;				/* Set file changed flag */
+		}
+	}
+	/* Open an existing file */
+	else {
 #endif /* !_FS_READONLY */
-        if (res != FR_OK) return res;        /* Trace failed */
-        if (dir == NULL || (dir[DIR_Attr] &amp; AM_DIR))    /* It is a directory */
-            return FR_NO_FILE;
+		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
+		dir = dj.dir;
+		if (!dir || (dir[DIR_Attr] &amp; AM_DIR))	/* It is a directory */
+			LEAVE_FF(dj.fs, FR_NO_FILE);
 #if !_FS_READONLY
-        if ((mode &amp; FA_WRITE) &amp;&amp; (dir[DIR_Attr] &amp; AM_RDO)) /* R/O violation */
-            return FR_DENIED;
-    }
-
-    fp-&gt;dir_sect = fs-&gt;winsect;            /* Pointer to the directory entry */
-    fp-&gt;dir_ptr = dir;
+		if ((mode &amp; FA_WRITE) &amp;&amp; (dir[DIR_Attr] &amp; AM_RDO)) /* R/O violation */
+			LEAVE_FF(dj.fs, FR_DENIED);
+	}
+	fp-&gt;dir_sect = dj.fs-&gt;winsect;		/* Pointer to the directory entry */
+	fp-&gt;dir_ptr = dj.dir;
 #endif
-    fp-&gt;flag = mode;                    /* File access mode */
-    fp-&gt;org_clust =                        /* File start cluster */
-        ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
-    fp-&gt;fsize = LD_DWORD(&amp;dir[DIR_FileSize]);    /* File size */
-    fp-&gt;fptr = 0;                        /* File ptr */
-    fp-&gt;sect_clust = 1;                    /* Sector counter */
-    fp-&gt;fs = fs; fp-&gt;id = fs-&gt;id;        /* Owner file system object of the file */
+	fp-&gt;flag = mode;					/* File access mode */
+	fp-&gt;org_clust =						/* File start cluster */
+		((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
+	fp-&gt;fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
+	fp-&gt;fptr = 0; fp-&gt;csect = 255;		/* File pointer */
+	fp-&gt;dsect = 0;
+	fp-&gt;fs = dj.fs; fp-&gt;id = dj.fs-&gt;id;	/* Owner file system object of the file */
 
-    return FR_OK;
+	LEAVE_FF(dj.fs, FR_OK);
 }
 
 
@@ -891,71 +1747,90 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_read (
-    FIL *fp,         /* Pointer to the file object */
-    void *buff,        /* Pointer to data buffer */
-    WORD btr,        /* Number of bytes to read */
-    WORD *br        /* Pointer to number of bytes read */
+	FIL *fp, 		/* Pointer to the file object */
+	void *buff,		/* Pointer to data buffer */
+	UINT btr,		/* Number of bytes to read */
+	UINT *br		/* Pointer to number of bytes read */
 )
 {
-    DWORD clust, sect, remain;
-    WORD rcnt;
-    BYTE cc, *rbuff = buff;
-    FRESULT res;
-    FATFS *fs = fp-&gt;fs;
+	FRESULT res;
+	DWORD clst, sect, remain;
+	UINT rcnt, cc;
+	BYTE *rbuff = buff;
 
 
-    *br = 0;
-    res = validate(fs, fp-&gt;id);                        /* Check validity of the object */
-    if (res) return res;
-    if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;    /* Check error flag */
-    if (!(fp-&gt;flag &amp; FA_READ)) return FR_DENIED;    /* Check access mode */
-    remain = fp-&gt;fsize - fp-&gt;fptr;
-    if (btr &gt; remain) btr = (WORD)remain;            /* Truncate read count by number of bytes left */
+	*br = 0;
 
-    for ( ;  btr;                                    /* Repeat until all data transferred */
-        rbuff += rcnt, fp-&gt;fptr += rcnt, *br += rcnt, btr -= rcnt) {
-        if ((fp-&gt;fptr &amp; (S_SIZ - 1)) == 0) {        /* On the sector boundary */
-            if (--fp-&gt;sect_clust) {                    /* Decrement left sector counter */
-                sect = fp-&gt;curr_sect + 1;            /* Get current sector */
-            } else {                                /* On the cluster boundary, get next cluster */
-                clust = (fp-&gt;fptr == 0) ?
-                    fp-&gt;org_clust : get_cluster(fs, fp-&gt;curr_clust);
-                if (clust &lt; 2 || clust &gt;= fs-&gt;max_clust)
-                    goto fr_error;
-                fp-&gt;curr_clust = clust;                /* Current cluster */
-                sect = clust2sect(fs, clust);        /* Get current sector */
-                fp-&gt;sect_clust = fs-&gt;sects_clust;    /* Re-initialize the left sector counter */
-            }
+	res = validate(fp-&gt;fs, fp-&gt;id);					/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
+	if (fp-&gt;flag &amp; FA__ERROR)						/* Check abort flag */
+		LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
+	if (!(fp-&gt;flag &amp; FA_READ)) 						/* Check access mode */
+		LEAVE_FF(fp-&gt;fs, FR_DENIED);
+	remain = fp-&gt;fsize - fp-&gt;fptr;
+	if (btr &gt; remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
+
+	for ( ;  btr;									/* Repeat until all data transferred */
+		rbuff += rcnt, fp-&gt;fptr += rcnt, *br += rcnt, btr -= rcnt) {
+		if ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {			/* On the sector boundary? */
+			if (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {		/* On the cluster boundary? */
+				clst = (fp-&gt;fptr == 0) ?			/* On the top of the file? */
+					fp-&gt;org_clust : get_fat(fp-&gt;fs, fp-&gt;curr_clust);
+				if (clst &lt;= 1) ABORT(fp-&gt;fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;curr_clust = clst;				/* Update current cluster */
+				fp-&gt;csect = 0;						/* Reset sector offset in the cluster */
+			}
+			sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust);	/* Get current sector */
+			if (!sect) ABORT(fp-&gt;fs, FR_INT_ERR);
+			sect += fp-&gt;csect;
+			cc = btr / SS(fp-&gt;fs);					/* When remaining bytes &gt;= sector size, */
+			if (cc) {								/* Read maximum contiguous sectors directly */
+				if (fp-&gt;csect + cc &gt; fp-&gt;fs-&gt;csize)	/* Clip at cluster boundary */
+					cc = fp-&gt;fs-&gt;csize - fp-&gt;csect;
+				if (disk_read(fp-&gt;fs-&gt;drive, rbuff, sect, (BYTE)cc) != RES_OK)
+					ABORT(fp-&gt;fs, FR_DISK_ERR);
+#if !_FS_READONLY &amp;&amp; _FS_MINIMIZE &lt;= 2
+#if _FS_TINY
+				if (fp-&gt;fs-&gt;wflag &amp;&amp; fp-&gt;fs-&gt;winsect - sect &lt; cc)		/* Replace one of the read sectors with cached data if it contains a dirty sector */
+					mem_cpy(rbuff + ((fp-&gt;fs-&gt;winsect - sect) * SS(fp-&gt;fs)), fp-&gt;fs-&gt;win, SS(fp-&gt;fs));
+#else
+				if ((fp-&gt;flag &amp; FA__DIRTY) &amp;&amp; fp-&gt;dsect - sect &lt; cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
+					mem_cpy(rbuff + ((fp-&gt;dsect - sect) * SS(fp-&gt;fs)), fp-&gt;buf, SS(fp-&gt;fs));
+#endif
+#endif
+				fp-&gt;csect += (BYTE)cc;				/* Next sector address in the cluster */
+				rcnt = SS(fp-&gt;fs) * cc;				/* Number of bytes transferred */
+				continue;
+			}
+#if !_FS_TINY
 #if !_FS_READONLY
-            if (fp-&gt;flag &amp; FA__DIRTY) {                /* Flush file I/O buffer if needed */
-                if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-                    goto fr_error;
-                fp-&gt;flag &amp;= ~FA__DIRTY;
-            }
+			if (fp-&gt;flag &amp; FA__DIRTY) {			/* Write sector I/O buffer if needed */
+				if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
+					ABORT(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;flag &amp;= ~FA__DIRTY;
+			}
 #endif
-            fp-&gt;curr_sect = sect;                    /* Update current sector */
-            cc = btr / S_SIZ;                        /* When left bytes &gt;= S_SIZ, */
-            if (cc) {                                /* Read maximum contiguous sectors directly */
-                if (cc &gt; fp-&gt;sect_clust) cc = fp-&gt;sect_clust;
-                if (disk_read(fs-&gt;drive, rbuff, sect, cc) != RES_OK)
-                    goto fr_error;
-                fp-&gt;sect_clust -= cc - 1;
-                fp-&gt;curr_sect += cc - 1;
-                rcnt = cc * S_SIZ; continue;
-            }
-            if (disk_read(fs-&gt;drive, fp-&gt;buffer, sect, 1) != RES_OK)    /* Load the sector into file I/O buffer */
-                goto fr_error;
-        }
-        rcnt = S_SIZ - ((WORD)fp-&gt;fptr &amp; (S_SIZ - 1));                /* Copy fractional bytes from file I/O buffer */
-        if (rcnt &gt; btr) rcnt = btr;
-        memcpy(rbuff, &amp;fp-&gt;buffer[fp-&gt;fptr &amp; (S_SIZ - 1)], rcnt);
-    }
+			if (fp-&gt;dsect != sect) {			/* Fill sector buffer with file data */
+				if (disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buf, sect, 1) != RES_OK)
+					ABORT(fp-&gt;fs, FR_DISK_ERR);
+			}
+#endif
+			fp-&gt;dsect = sect;
+			fp-&gt;csect++;							/* Next sector address in the cluster */
+		}
+		rcnt = SS(fp-&gt;fs) - (fp-&gt;fptr % SS(fp-&gt;fs));	/* Get partial sector data from sector buffer */
+		if (rcnt &gt; btr) rcnt = btr;
+#if _FS_TINY
+		if (move_window(fp-&gt;fs, fp-&gt;dsect))			/* Move sector window */
+			ABORT(fp-&gt;fs, FR_DISK_ERR);
+		mem_cpy(rbuff, &amp;fp-&gt;fs-&gt;win[fp-&gt;fptr % SS(fp-&gt;fs)], rcnt);	/* Pick partial sector */
+#else
+		mem_cpy(rbuff, &amp;fp-&gt;buf[fp-&gt;fptr % SS(fp-&gt;fs)], rcnt);	/* Pick partial sector */
+#endif
+	}
 
-    return FR_OK;
-
-fr_error:    /* Abort this file due to an unrecoverable error */
-    fp-&gt;flag |= FA__ERROR;
-    return FR_RW_ERROR;
+	LEAVE_FF(fp-&gt;fs, FR_OK);
 }
 
 
@@ -967,121 +1842,157 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_write (
-    FIL *fp,            /* Pointer to the file object */
-    const void *buff,    /* Pointer to the data to be written */
-    WORD btw,            /* Number of bytes to write */
-    WORD *bw            /* Pointer to number of bytes written */
+	FIL *fp,			/* Pointer to the file object */
+	const void *buff,	/* Pointer to the data to be written */
+	UINT btw,			/* Number of bytes to write */
+	UINT *bw			/* Pointer to number of bytes written */
 )
 {
-    DWORD clust, sect;
-    WORD wcnt;
-    BYTE cc;
-    FRESULT res;
-    const BYTE *wbuff = buff;
-    FATFS *fs = fp-&gt;fs;
+	FRESULT res;
+	DWORD clst, sect;
+	UINT wcnt, cc;
+	const BYTE *wbuff = buff;
 
 
-    *bw = 0;
-    res = validate(fs, fp-&gt;id);                        /* Check validity of the object */
-    if (res) return res;
-    if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;    /* Check error flag */
-    if (!(fp-&gt;flag &amp; FA_WRITE)) return FR_DENIED;    /* Check access mode */
-    if (fp-&gt;fsize + btw &lt; fp-&gt;fsize) return FR_OK;    /* File size cannot reach 4GB */
+	*bw = 0;
 
-    for ( ;  btw;                                    /* Repeat until all data transferred */
-        wbuff += wcnt, fp-&gt;fptr += wcnt, *bw += wcnt, btw -= wcnt) {
-        if ((fp-&gt;fptr &amp; (S_SIZ - 1)) == 0) {        /* On the sector boundary */
-            if (--fp-&gt;sect_clust) {                    /* Decrement left sector counter */
-                sect = fp-&gt;curr_sect + 1;            /* Get current sector */
-            } else {                                /* On the cluster boundary, get next cluster */
-                if (fp-&gt;fptr == 0) {                /* Is top of the file */
-                    clust = fp-&gt;org_clust;
-                    if (clust == 0)                    /* No cluster is created yet */
-                        fp-&gt;org_clust = clust = create_chain(fs, 0);    /* Create a new cluster chain */
-                } else {                            /* Middle or end of file */
-                    clust = create_chain(fs, fp-&gt;curr_clust);            /* Trace or streach cluster chain */
-                }
-                if (clust == 0) break;                /* Disk full */
-                if (clust == 1 || clust &gt;= fs-&gt;max_clust) goto fw_error;
-                fp-&gt;curr_clust = clust;                /* Current cluster */
-                sect = clust2sect(fs, clust);        /* Get current sector */
-                fp-&gt;sect_clust = fs-&gt;sects_clust;    /* Re-initialize the left sector counter */
-            }
-            if (fp-&gt;flag &amp; FA__DIRTY) {                /* Flush file I/O buffer if needed */
-                if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-                    goto fw_error;
-                fp-&gt;flag &amp;= ~FA__DIRTY;
-            }
-            fp-&gt;curr_sect = sect;                    /* Update current sector */
-            cc = btw / S_SIZ;                        /* When left bytes &gt;= S_SIZ, */
-            if (cc) {                                /* Write maximum contiguous sectors directly */
-                if (cc &gt; fp-&gt;sect_clust) cc = fp-&gt;sect_clust;
-                if (disk_write(fs-&gt;drive, wbuff, sect, cc) != RES_OK)
-                    goto fw_error;
-                fp-&gt;sect_clust -= cc - 1;
-                fp-&gt;curr_sect += cc - 1;
-                wcnt = cc * S_SIZ; continue;
-            }
-            if (fp-&gt;fptr &lt; fp-&gt;fsize &amp;&amp;              /* Fill sector buffer with file data if needed */
-                disk_read(fs-&gt;drive, fp-&gt;buffer, sect, 1) != RES_OK)
-                    goto fw_error;
-        }
-        wcnt = S_SIZ - ((WORD)fp-&gt;fptr &amp; (S_SIZ - 1));    /* Copy fractional bytes to file I/O buffer */
-        if (wcnt &gt; btw) wcnt = btw;
-        memcpy(&amp;fp-&gt;buffer[fp-&gt;fptr &amp; (S_SIZ - 1)], wbuff, wcnt);
-        fp-&gt;flag |= FA__DIRTY;
-    }
+	res = validate(fp-&gt;fs, fp-&gt;id);					/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
+	if (fp-&gt;flag &amp; FA__ERROR)						/* Check abort flag */
+		LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
+	if (!(fp-&gt;flag &amp; FA_WRITE))						/* Check access mode */
+		LEAVE_FF(fp-&gt;fs, FR_DENIED);
+	if (fp-&gt;fsize + btw &lt; fp-&gt;fsize) btw = 0;		/* File size cannot reach 4GB */
 
-    if (fp-&gt;fptr &gt; fp-&gt;fsize) fp-&gt;fsize = fp-&gt;fptr;    /* Update file size if needed */
-    fp-&gt;flag |= FA__WRITTEN;                        /* Set file changed flag */
-    return FR_OK;
+	for ( ;  btw;									/* Repeat until all data transferred */
+		wbuff += wcnt, fp-&gt;fptr += wcnt, *bw += wcnt, btw -= wcnt) {
+		if ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {			/* On the sector boundary? */
+			if (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {		/* On the cluster boundary? */
+				if (fp-&gt;fptr == 0) {				/* On the top of the file? */
+					clst = fp-&gt;org_clust;			/* Follow from the origin */
+					if (clst == 0)					/* When there is no cluster chain, */
+						fp-&gt;org_clust = clst = create_chain(fp-&gt;fs, 0);	/* Create a new cluster chain */
+				} else {							/* Middle or end of the file */
+					clst = create_chain(fp-&gt;fs, fp-&gt;curr_clust);			/* Follow or streach cluster chain */
+				}
+				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
+				if (clst == 1) ABORT(fp-&gt;fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;curr_clust = clst;				/* Update current cluster */
+				fp-&gt;csect = 0;						/* Reset sector address in the cluster */
+			}
+#if _FS_TINY
+			if (fp-&gt;fs-&gt;winsect == fp-&gt;dsect &amp;&amp; move_window(fp-&gt;fs, 0))	/* Write back data buffer prior to following direct transfer */
+				ABORT(fp-&gt;fs, FR_DISK_ERR);
+#else
+			if (fp-&gt;flag &amp; FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
+				if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
+					ABORT(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;flag &amp;= ~FA__DIRTY;
+			}
+#endif
+			sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust);	/* Get current sector */
+			if (!sect) ABORT(fp-&gt;fs, FR_INT_ERR);
+			sect += fp-&gt;csect;
+			cc = btw / SS(fp-&gt;fs);					/* When remaining bytes &gt;= sector size, */
+			if (cc) {								/* Write maximum contiguous sectors directly */
+				if (fp-&gt;csect + cc &gt; fp-&gt;fs-&gt;csize)	/* Clip at cluster boundary */
+					cc = fp-&gt;fs-&gt;csize - fp-&gt;csect;
+				if (disk_write(fp-&gt;fs-&gt;drive, wbuff, sect, (BYTE)cc) != RES_OK)
+					ABORT(fp-&gt;fs, FR_DISK_ERR);
+#if _FS_TINY
+				if (fp-&gt;fs-&gt;winsect - sect &lt; cc) {	/* Refill sector cache if it gets dirty by the direct write */
+					mem_cpy(fp-&gt;fs-&gt;win, wbuff + ((fp-&gt;fs-&gt;winsect - sect) * SS(fp-&gt;fs)), SS(fp-&gt;fs));
+					fp-&gt;fs-&gt;wflag = 0;
+				}
+#else
+				if (fp-&gt;dsect - sect &lt; cc) {		/* Refill sector cache if it gets dirty by the direct write */
+					mem_cpy(fp-&gt;buf, wbuff + ((fp-&gt;dsect - sect) * SS(fp-&gt;fs)), SS(fp-&gt;fs));
+					fp-&gt;flag &amp;= ~FA__DIRTY;
+				}
+#endif
+				fp-&gt;csect += (BYTE)cc;				/* Next sector address in the cluster */
+				wcnt = SS(fp-&gt;fs) * cc;				/* Number of bytes transferred */
+				continue;
+			}
+#if _FS_TINY
+			if (fp-&gt;fptr &gt;= fp-&gt;fsize) {			/* Avoid silly buffer filling at growing edge */
+				if (move_window(fp-&gt;fs, 0)) ABORT(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;fs-&gt;winsect = sect;
+			}
+#else
+			if (fp-&gt;dsect != sect) {				/* Fill sector buffer with file data */
+				if (fp-&gt;fptr &lt; fp-&gt;fsize &amp;&amp;
+					disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buf, sect, 1) != RES_OK)
+						ABORT(fp-&gt;fs, FR_DISK_ERR);
+			}
+#endif
+			fp-&gt;dsect = sect;
+			fp-&gt;csect++;							/* Next sector address in the cluster */
+		}
+		wcnt = SS(fp-&gt;fs) - (fp-&gt;fptr % SS(fp-&gt;fs));	/* Put partial sector into file I/O buffer */
+		if (wcnt &gt; btw) wcnt = btw;
+#if _FS_TINY
+		if (move_window(fp-&gt;fs, fp-&gt;dsect))			/* Move sector window */
+			ABORT(fp-&gt;fs, FR_DISK_ERR);
+		mem_cpy(&amp;fp-&gt;fs-&gt;win[fp-&gt;fptr % SS(fp-&gt;fs)], wbuff, wcnt);	/* Fit partial sector */
+		fp-&gt;fs-&gt;wflag = 1;
+#else
+		mem_cpy(&amp;fp-&gt;buf[fp-&gt;fptr % SS(fp-&gt;fs)], wbuff, wcnt);	/* Fit partial sector */
+		fp-&gt;flag |= FA__DIRTY;
+#endif
+	}
 
-fw_error:    /* Abort this file due to an unrecoverable error */
-    fp-&gt;flag |= FA__ERROR;
-    return FR_RW_ERROR;
+	if (fp-&gt;fptr &gt; fp-&gt;fsize) fp-&gt;fsize = fp-&gt;fptr;	/* Update file size if needed */
+	fp-&gt;flag |= FA__WRITTEN;						/* Set file changed flag */
+
+	LEAVE_FF(fp-&gt;fs, FR_OK);
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Synchronize between File and Disk                                     */
+/* Synchronize the File Object                                           */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_sync (
-    FIL *fp        /* Pointer to the file object */
+	FIL *fp		/* Pointer to the file object */
 )
 {
-    DWORD tim;
-    BYTE *dir;
-    FRESULT res;
-    FATFS *fs = fp-&gt;fs;
+	FRESULT res;
+	DWORD tim;
+	BYTE *dir;
 
 
-    res = validate(fs, fp-&gt;id);            /* Check validity of the object */
-    if (res == FR_OK) {
-        if (fp-&gt;flag &amp; FA__WRITTEN) {    /* Has the file been written? */
-            /* Write back data buffer if needed */
-            if (fp-&gt;flag &amp; FA__DIRTY) {
-                if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-                    return FR_RW_ERROR;
-                fp-&gt;flag &amp;= ~FA__DIRTY;
-            }
-            /* Update the directory entry */
-            if (!move_window(fs, fp-&gt;dir_sect))
-                return FR_RW_ERROR;
-            dir = fp-&gt;dir_ptr;
-            dir[DIR_Attr] |= AM_ARC;                        /* Set archive bit */
-            ST_DWORD(&amp;dir[DIR_FileSize], fp-&gt;fsize);        /* Update file size */
-            ST_WORD(&amp;dir[DIR_FstClusLO], fp-&gt;org_clust);    /* Update start cluster */
-            ST_WORD(&amp;dir[DIR_FstClusHI], fp-&gt;org_clust &gt;&gt; 16);
-            tim = get_fattime();                    /* Updated time */
-            ST_DWORD(&amp;dir[DIR_WrtTime], tim);
-            fp-&gt;flag &amp;= ~FA__WRITTEN;
-            res = sync(fs);
-        }
-    }
-    return res;
+	res = validate(fp-&gt;fs, fp-&gt;id);		/* Check validity of the object */
+	if (res == FR_OK) {
+		if (fp-&gt;flag &amp; FA__WRITTEN) {	/* Has the file been written? */
+#if !_FS_TINY	/* Write-back dirty buffer */
+			if (fp-&gt;flag &amp; FA__DIRTY) {
+				if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
+					LEAVE_FF(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;flag &amp;= ~FA__DIRTY;
+			}
+#endif
+			/* Update the directory entry */
+			res = move_window(fp-&gt;fs, fp-&gt;dir_sect);
+			if (res == FR_OK) {
+				dir = fp-&gt;dir_ptr;
+				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
+				ST_DWORD(dir+DIR_FileSize, fp-&gt;fsize);		/* Update file size */
+				ST_WORD(dir+DIR_FstClusLO, fp-&gt;org_clust);	/* Update start cluster */
+				ST_WORD(dir+DIR_FstClusHI, fp-&gt;org_clust &gt;&gt; 16);
+				tim = get_fattime();			/* Updated time */
+				ST_DWORD(dir+DIR_WrtTime, tim);
+				fp-&gt;flag &amp;= ~FA__WRITTEN;
+				fp-&gt;fs-&gt;wflag = 1;
+				res = sync(fp-&gt;fs);
+			}
+		}
+	}
+
+	LEAVE_FF(fp-&gt;fs, res);
 }
 
 #endif /* !_FS_READONLY */
@@ -1094,106 +2005,175 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_close (
-    FIL *fp        /* Pointer to the file object to be closed */
+	FIL *fp		/* Pointer to the file object to be closed */
 )
 {
-    FRESULT res;
+	FRESULT res;
 
 
-#if !_FS_READONLY
-    res = f_sync(fp);
+#if _FS_READONLY
+	res = validate(fp-&gt;fs, fp-&gt;id);
+	if (res == FR_OK) fp-&gt;fs = NULL;
+	LEAVE_FF(fp-&gt;fs, res);
 #else
-    res = validate(fp-&gt;fs, fp-&gt;id);
+	res = f_sync(fp);
+	if (res == FR_OK) fp-&gt;fs = NULL;
+	return res;
 #endif
-    if (res == FR_OK)
-        fp-&gt;fs = NULL;
-    return res;
 }
 
 
 
 
+/*-----------------------------------------------------------------------*/
+/* Change Current Drive/Directory                                        */
+/*-----------------------------------------------------------------------*/
+
+#if _FS_RPATH
+
+FRESULT f_chdrive (
+	BYTE drv		/* Drive number */
+)
+{
+	if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
+
+	Drive = drv;
+
+	return FR_OK;
+}
+
+
+
+
+FRESULT f_chdir (
+	const XCHAR *path	/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	NAMEBUF(sfn, lfn);
+	BYTE *dir;
+
+
+	res = auto_mount(&amp;path, &amp;dj.fs, 0);
+	if (res == FR_OK) {
+		INITBUF(dj, sfn, lfn);
+		res = follow_path(&amp;dj, path);		/* Follow the file path */
+		if (res == FR_OK) {					/* Follow completed */
+			dir = dj.dir;					/* Pointer to the entry */
+			if (!dir) {
+				dj.fs-&gt;cdir = 0;			/* No entry (root dir) */
+			} else {
+				if (dir[DIR_Attr] &amp; AM_DIR)	/* Reached to the dir */
+					dj.fs-&gt;cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
+				else
+					res = FR_NO_PATH;		/* Could not reach the dir (it is a file) */
+			}
+		}
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+#endif
+
+
+
 #if _FS_MINIMIZE &lt;= 2
 /*-----------------------------------------------------------------------*/
 /* Seek File R/W Pointer                                                 */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_lseek (
-    FIL *fp,        /* Pointer to the file object */
-    DWORD ofs        /* File pointer from top of file */
+	FIL *fp,		/* Pointer to the file object */
+	DWORD ofs		/* File pointer from top of file */
 )
 {
-    DWORD clust, csize;
-    BYTE csect;
-    FRESULT res;
-    FATFS *fs = fp-&gt;fs;
+	FRESULT res;
+	DWORD clst, bcs, nsect, ifptr;
 
 
-    res = validate(fs, fp-&gt;id);            /* Check validity of the object */
-    if (res) return res;
-    if (fp-&gt;flag &amp; FA__ERROR) return FR_RW_ERROR;
+	res = validate(fp-&gt;fs, fp-&gt;id);		/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
+	if (fp-&gt;flag &amp; FA__ERROR)			/* Check abort flag */
+		LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
+	if (ofs &gt; fp-&gt;fsize					/* In read-only mode, clip offset with the file size */
 #if !_FS_READONLY
-    if (fp-&gt;flag &amp; FA__DIRTY) {            /* Write-back dirty buffer if needed */
-        if (disk_write(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-            goto fk_error;
-        fp-&gt;flag &amp;= ~FA__DIRTY;
-    }
-    if (ofs &gt; fp-&gt;fsize &amp;&amp; !(fp-&gt;flag &amp; FA_WRITE))
-#else
-    if (ofs &gt; fp-&gt;fsize)
+		 &amp;&amp; !(fp-&gt;flag &amp; FA_WRITE)
 #endif
-        ofs = fp-&gt;fsize;
-    fp-&gt;fptr = 0; fp-&gt;sect_clust = 1;        /* Set file R/W pointer to top of the file */
+		) ofs = fp-&gt;fsize;
 
-    /* Move file R/W pointer if needed */
-    if (ofs) {
-        clust = fp-&gt;org_clust;    /* Get start cluster */
+	ifptr = fp-&gt;fptr;
+	fp-&gt;fptr = nsect = 0; fp-&gt;csect = 255;
+	if (ofs &gt; 0) {
+		bcs = (DWORD)fp-&gt;fs-&gt;csize * SS(fp-&gt;fs);	/* Cluster size (byte) */
+		if (ifptr &gt; 0 &amp;&amp;
+			(ofs - 1) / bcs &gt;= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
+			fp-&gt;fptr = (ifptr - 1) &amp; ~(bcs - 1);	/* start from the current cluster */
+			ofs -= fp-&gt;fptr;
+			clst = fp-&gt;curr_clust;
+		} else {									/* When seek to back cluster, */
+			clst = fp-&gt;org_clust;					/* start from the first cluster */
 #if !_FS_READONLY
-        if (!clust) {            /* If the file does not have a cluster chain, create new cluster chain */
-            clust = create_chain(fs, 0);
-            if (clust == 1) goto fk_error;
-            fp-&gt;org_clust = clust;
-        }
+			if (clst == 0) {						/* If no cluster chain, create a new chain */
+				clst = create_chain(fp-&gt;fs, 0);
+				if (clst == 1) ABORT(fp-&gt;fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;org_clust = clst;
+			}
 #endif
-        if (clust) {            /* If the file has a cluster chain, it can be followed */
-            csize = (DWORD)fs-&gt;sects_clust * S_SIZ;        /* Cluster size in unit of byte */
-            for (;;) {                                    /* Loop to skip leading clusters */
-                fp-&gt;curr_clust = clust;                    /* Update current cluster */
-                if (ofs &lt;= csize) break;
+			fp-&gt;curr_clust = clst;
+		}
+		if (clst != 0) {
+			while (ofs &gt; bcs) {						/* Cluster following loop */
 #if !_FS_READONLY
-                if (fp-&gt;flag &amp; FA_WRITE)                /* Check if in write mode or not */
-                    clust = create_chain(fs, clust);    /* Force streached if in write mode */
-                else
+				if (fp-&gt;flag &amp; FA_WRITE) {			/* Check if in write mode or not */
+					clst = create_chain(fp-&gt;fs, clst);	/* Force streached if in write mode */
+					if (clst == 0) {				/* When disk gets full, clip file size */
+						ofs = bcs; break;
+					}
+				} else
 #endif
-                    clust = get_cluster(fs, clust);        /* Only follow cluster chain if not in write mode */
-                if (clust == 0) {                        /* Stop if could not follow the cluster chain */
-                    ofs = csize; break;
-                }
-                if (clust == 1 || clust &gt;= fs-&gt;max_clust) goto fk_error;
-                fp-&gt;fptr += csize;                        /* Update R/W pointer */
-                ofs -= csize;
-            }
-            csect = (BYTE)((ofs - 1) / S_SIZ);            /* Sector offset in the cluster */
-            fp-&gt;curr_sect = clust2sect(fs, clust) + csect;    /* Current sector */
-            if ((ofs &amp; (S_SIZ - 1)) &amp;&amp;                    /* Load current sector if needed */
-                disk_read(fs-&gt;drive, fp-&gt;buffer, fp-&gt;curr_sect, 1) != RES_OK)
-                goto fk_error;
-            fp-&gt;sect_clust = fs-&gt;sects_clust - csect;    /* Left sector counter in the cluster */
-            fp-&gt;fptr += ofs;                            /* Update file R/W pointer */
-        }
-    }
+					clst = get_fat(fp-&gt;fs, clst);	/* Follow cluster chain if not in write mode */
+				if (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
+				if (clst &lt;= 1 || clst &gt;= fp-&gt;fs-&gt;max_clust) ABORT(fp-&gt;fs, FR_INT_ERR);
+				fp-&gt;curr_clust = clst;
+				fp-&gt;fptr += bcs;
+				ofs -= bcs;
+			}
+			fp-&gt;fptr += ofs;
+			fp-&gt;csect = (BYTE)(ofs / SS(fp-&gt;fs));	/* Sector offset in the cluster */
+			if (ofs % SS(fp-&gt;fs)) {
+				nsect = clust2sect(fp-&gt;fs, clst);	/* Current sector */
+				if (!nsect) ABORT(fp-&gt;fs, FR_INT_ERR);
+				nsect += fp-&gt;csect;
+				fp-&gt;csect++;
+			}
+		}
+	}
+	if (fp-&gt;fptr % SS(fp-&gt;fs) &amp;&amp; nsect != fp-&gt;dsect) {
+#if !_FS_TINY
 #if !_FS_READONLY
-    if ((fp-&gt;flag &amp; FA_WRITE) &amp;&amp; fp-&gt;fptr &gt; fp-&gt;fsize) {    /* Set updated flag if in write mode */
-        fp-&gt;fsize = fp-&gt;fptr;
-        fp-&gt;flag |= FA__WRITTEN;
-    }
+		if (fp-&gt;flag &amp; FA__DIRTY) {			/* Write-back dirty buffer if needed */
+			if (disk_write(fp-&gt;fs-&gt;drive, fp-&gt;buf, fp-&gt;dsect, 1) != RES_OK)
+				ABORT(fp-&gt;fs, FR_DISK_ERR);
+			fp-&gt;flag &amp;= ~FA__DIRTY;
+		}
 #endif
+		if (disk_read(fp-&gt;fs-&gt;drive, fp-&gt;buf, nsect, 1) != RES_OK)
+			ABORT(fp-&gt;fs, FR_DISK_ERR);
+#endif
+		fp-&gt;dsect = nsect;
+	}
+#if !_FS_READONLY
+	if (fp-&gt;fptr &gt; fp-&gt;fsize) {			/* Set changed flag if the file size is extended */
+		fp-&gt;fsize = fp-&gt;fptr;
+		fp-&gt;flag |= FA__WRITTEN;
+	}
+#endif
 
-    return FR_OK;
-
-fk_error:    /* Abort this file due to an unrecoverable error */
-    fp-&gt;flag |= FA__ERROR;
-    return FR_RW_ERROR;
+	LEAVE_FF(fp-&gt;fs, res);
 }
 
 
@@ -1201,38 +2181,41 @@
 
 #if _FS_MINIMIZE &lt;= 1
 /*-----------------------------------------------------------------------*/
-/* Create a directroy object                                             */
+/* Create a Directroy Object                                             */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_opendir (
-    DIR *dirobj,        /* Pointer to directory object to create */
-    const char *path    /* Pointer to the directory path */
+	DIR *dj,			/* Pointer to directory object to create */
+	const XCHAR *path	/* Pointer to the directory path */
 )
 {
-    BYTE *dir;
-    char fn[8+3+1];
-    FRESULT res;
-    FATFS *fs;
+	FRESULT res;
+	NAMEBUF(sfn, lfn);
+	BYTE *dir;
 
 
-    res = auto_mount(&amp;path, &amp;fs, 0);
-    if (res != FR_OK) return res;
-    dirobj-&gt;fs = fs;
+	res = auto_mount(&amp;path, &amp;dj-&gt;fs, 0);
+	if (res == FR_OK) {
+		INITBUF((*dj), sfn, lfn);
+		res = follow_path(dj, path);			/* Follow the path to the directory */
+		if (res == FR_OK) {						/* Follow completed */
+			dir = dj-&gt;dir;
+			if (dir) {							/* It is not the root dir */
+				if (dir[DIR_Attr] &amp; AM_DIR) {	/* The object is a directory */
+					dj-&gt;sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
+				} else {						/* The object is not a directory */
+					res = FR_NO_PATH;
+				}
+			}
+			if (res == FR_OK) {
+				dj-&gt;id = dj-&gt;fs-&gt;id;
+				res = dir_seek(dj, 0);			/* Rewind dir */
+			}
+		}
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+	}
 
-    res = trace_path(dirobj, fn, path, &amp;dir);    /* Trace the directory path */
-    if (res == FR_OK) {                        /* Trace completed */
-        if (dir != NULL) {                    /* It is not the root dir */
-            if (dir[DIR_Attr] &amp; AM_DIR) {        /* The entry is a directory */
-                dirobj-&gt;clust = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
-                dirobj-&gt;sect = clust2sect(fs, dirobj-&gt;clust);
-                dirobj-&gt;index = 2;
-            } else {                        /* The entry is not a directory */
-                res = FR_NO_FILE;
-            }
-        }
-        dirobj-&gt;id = fs-&gt;id;
-    }
-    return res;
+	LEAVE_FF(dj-&gt;fs, res);
 }
 
 
@@ -1243,66 +2226,69 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_readdir (
-    DIR *dirobj,        /* Pointer to the directory object */
-    FILINFO *finfo        /* Pointer to file information to return */
+	DIR *dj,			/* Pointer to the open directory object */
+	FILINFO *fno		/* Pointer to file information to return */
 )
 {
-    BYTE *dir, c, res;
-    FATFS *fs = dirobj-&gt;fs;
+	FRESULT res;
+	NAMEBUF(sfn, lfn);
 
 
-    res = validate(fs, dirobj-&gt;id);            /* Check validity of the object */
-    if (res) return res;
+	res = validate(dj-&gt;fs, dj-&gt;id);			/* Check validity of the object */
+	if (res == FR_OK) {
+		INITBUF((*dj), sfn, lfn);
+		if (!fno) {
+			res = dir_seek(dj, 0);
+		} else {
+			res = dir_read(dj);
+			if (res == FR_NO_FILE) {
+				dj-&gt;sect = 0;
+				res = FR_OK;
+			}
+			if (res == FR_OK) {				/* A valid entry is found */
+				get_fileinfo(dj, fno);		/* Get the object information */
+				res = dir_next(dj, FALSE);	/* Increment index for next */
+				if (res == FR_NO_FILE) {
+					dj-&gt;sect = 0;
+					res = FR_OK;
+				}
+			}
+		}
+	}
 
-    finfo-&gt;fname[0] = 0;
-    while (dirobj-&gt;sect) {
-        if (!move_window(fs, dirobj-&gt;sect))
-            return FR_RW_ERROR;
-        dir = &amp;fs-&gt;win[(dirobj-&gt;index &amp; ((S_SIZ - 1) &gt;&gt; 5)) * 32];    /* pointer to the directory entry */
-        c = *dir;
-        if (c == 0) break;                                /* Has it reached to end of dir? */
-        if (c != 0xE5 &amp;&amp; !(dir[DIR_Attr] &amp; AM_VOL))        /* Is it a valid entry? */
-            get_fileinfo(finfo, dir);
-        if (!next_dir_entry(dirobj)) dirobj-&gt;sect = 0;    /* Next entry */
-        if (finfo-&gt;fname[0]) break;                        /* Found valid entry */
-    }
-
-    return FR_OK;
+	LEAVE_FF(dj-&gt;fs, res);
 }
 
 
 
-
 #if _FS_MINIMIZE == 0
 /*-----------------------------------------------------------------------*/
 /* Get File Status                                                       */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_stat (
-    const char *path,    /* Pointer to the file path */
-    FILINFO *finfo        /* Pointer to file information to return */
+	const XCHAR *path,	/* Pointer to the file path */
+	FILINFO *fno		/* Pointer to file information to return */
 )
 {
-    BYTE *dir;
-    char fn[8+3+1];
-    FRESULT res;
-    DIR dirobj;
-    FATFS *fs;
+	FRESULT res;
+	DIR dj;
+	NAMEBUF(sfn, lfn);
 
 
-    res = auto_mount(&amp;path, &amp;fs, 0);
-    if (res != FR_OK) return res;
-    dirobj.fs = fs;
+	res = auto_mount(&amp;path, &amp;dj.fs, 0);
+	if (res == FR_OK) {
+		INITBUF(dj, sfn, lfn);
+		res = follow_path(&amp;dj, path);	/* Follow the file path */
+		if (res == FR_OK) {				/* Follwo completed */
+			if (dj.dir)	/* Found an object */
+				get_fileinfo(&amp;dj, fno);
+			else		/* It is root dir */
+				res = FR_INVALID_NAME;
+		}
+	}
 
-    res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
-    if (res == FR_OK) {                            /* Trace completed */
-        if (dir)    /* Found an object */
-            get_fileinfo(finfo, dir);
-        else        /* It is root dir */
-            res = FR_INVALID_NAME;
-    }
-
-    return res;
+	LEAVE_FF(dj.fs, res);
 }
 
 
@@ -1313,112 +2299,163 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_getfree (
-    const char *drv,    /* Logical drive number */
-    DWORD *nclust,        /* Pointer to the double word to return number of free clusters */
-    FATFS **fatfs        /* Pointer to pointer to the file system object to return */
+	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
+	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
+	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
 )
 {
-    DWORD n, clust, sect;
-    BYTE fat, f, *p;
-    FRESULT res;
-    FATFS *fs;
+	FRESULT res;
+	DWORD n, clst, sect, stat;
+	UINT i;
+	BYTE fat, *p;
 
 
-    /* Get drive number */
-    res = auto_mount(&amp;drv, &amp;fs, 0);
-    if (res != FR_OK) return res;
-    *fatfs = fs;
+	/* Get drive number */
+	res = auto_mount(&amp;path, fatfs, 0);
+	if (res != FR_OK) LEAVE_FF(*fatfs, res);
 
-    /* If number of free cluster is valid, return it without cluster scan. */
-    if (fs-&gt;free_clust &lt;= fs-&gt;max_clust - 2) {
-        *nclust = fs-&gt;free_clust;
-        return FR_OK;
-    }
+	/* If number of free cluster is valid, return it without cluster scan. */
+	if ((*fatfs)-&gt;free_clust &lt;= (*fatfs)-&gt;max_clust - 2) {
+		*nclst = (*fatfs)-&gt;free_clust;
+		LEAVE_FF(*fatfs, FR_OK);
+	}
 
-    /* Count number of free clusters */
-    fat = fs-&gt;fs_type;
-    n = 0;
-    if (fat == FS_FAT12) {
-        clust = 2;
-        do {
-            if ((WORD)get_cluster(fs, clust) == 0) n++;
-        } while (++clust &lt; fs-&gt;max_clust);
-    } else {
-        clust = fs-&gt;max_clust;
-        sect = fs-&gt;fatbase;
-        f = 0; p = 0;
-        do {
-            if (!f) {
-                if (!move_window(fs, sect++)) return FR_RW_ERROR;
-                p = fs-&gt;win;
-            }
-            if (fat == FS_FAT16) {
-                if (LD_WORD(p) == 0) n++;
-                p += 2; f += 1;
-            } else {
-                if (LD_DWORD(p) == 0) n++;
-                p += 4; f += 2;
-            }
-        } while (--clust);
-    }
-    fs-&gt;free_clust = n;
-#if _USE_FSINFO
-    if (fat == FS_FAT32) fs-&gt;fsi_flag = 1;
-#endif
+	/* Get number of free clusters */
+	fat = (*fatfs)-&gt;fs_type;
+	n = 0;
+	if (fat == FS_FAT12) {
+		clst = 2;
+		do {
+			stat = get_fat(*fatfs, clst);
+			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
+			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
+			if (stat == 0) n++;
+		} while (++clst &lt; (*fatfs)-&gt;max_clust);
+	} else {
+		clst = (*fatfs)-&gt;max_clust;
+		sect = (*fatfs)-&gt;fatbase;
+		i = 0; p = 0;
+		do {
+			if (!i) {
+				res = move_window(*fatfs, sect++);
+				if (res != FR_OK)
+					LEAVE_FF(*fatfs, res);
+				p = (*fatfs)-&gt;win;
+				i = SS(*fatfs);
+			}
+			if (fat == FS_FAT16) {
+				if (LD_WORD(p) == 0) n++;
+				p += 2; i -= 2;
+			} else {
+				if (LD_DWORD(p) == 0) n++;
+				p += 4; i -= 4;
+			}
+		} while (--clst);
+	}
+	(*fatfs)-&gt;free_clust = n;
+	if (fat == FS_FAT32) (*fatfs)-&gt;fsi_flag = 1;
+	*nclst = n;
 
-    *nclust = n;
-    return FR_OK;
+	LEAVE_FF(*fatfs, FR_OK);
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Delete a File or a Directory                                          */
+/* Truncate File                                                         */
 /*-----------------------------------------------------------------------*/
 
+FRESULT f_truncate (
+	FIL *fp		/* Pointer to the file object */
+)
+{
+	FRESULT res;
+	DWORD ncl;
+
+
+	res = validate(fp-&gt;fs, fp-&gt;id);		/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
+	if (fp-&gt;flag &amp; FA__ERROR)			/* Check abort flag */
+		LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
+	if (!(fp-&gt;flag &amp; FA_WRITE))			/* Check access mode */
+		LEAVE_FF(fp-&gt;fs, FR_DENIED);
+
+	if (fp-&gt;fsize &gt; fp-&gt;fptr) {
+		fp-&gt;fsize = fp-&gt;fptr;	/* Set file size to current R/W point */
+		fp-&gt;flag |= FA__WRITTEN;
+		if (fp-&gt;fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
+			res = remove_chain(fp-&gt;fs, fp-&gt;org_clust);
+			fp-&gt;org_clust = 0;
+		} else {				/* When truncate a part of the file, remove remaining clusters */
+			ncl = get_fat(fp-&gt;fs, fp-&gt;curr_clust);
+			res = FR_OK;
+			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
+			if (ncl == 1) res = FR_INT_ERR;
+			if (res == FR_OK &amp;&amp; ncl &lt; fp-&gt;fs-&gt;max_clust) {
+				res = put_fat(fp-&gt;fs, fp-&gt;curr_clust, 0x0FFFFFFF);
+				if (res == FR_OK) res = remove_chain(fp-&gt;fs, ncl);
+			}
+		}
+	}
+	if (res != FR_OK) fp-&gt;flag |= FA__ERROR;
+
+	LEAVE_FF(fp-&gt;fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Delete a File or Directory                                            */
+/*-----------------------------------------------------------------------*/
+
 FRESULT f_unlink (
-    const char *path            /* Pointer to the file or directory path */
+	const XCHAR *path		/* Pointer to the file or directory path */
 )
 {
-    BYTE *dir, *sdir;
-    DWORD dclust, dsect;
-    char fn[8+3+1];
-    FRESULT res;
-    DIR dirobj;
-    FATFS *fs;
+	FRESULT res;
+	DIR dj, sdj;
+	NAMEBUF(sfn, lfn);
+	BYTE *dir;
+	DWORD dclst;
 
 
-    res = auto_mount(&amp;path, &amp;fs, 1);
-    if (res != FR_OK) return res;
-    dirobj.fs = fs;
+	res = auto_mount(&amp;path, &amp;dj.fs, 1);
+	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 
-    res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
-    if (res != FR_OK) return res;                /* Trace failed */
-    if (dir == NULL) return FR_INVALID_NAME;    /* It is the root directory */
-    if (dir[DIR_Attr] &amp; AM_RDO) return FR_DENIED;    /* It is a R/O object */
-    dsect = fs-&gt;winsect;
-    dclust = ((DWORD)LD_WORD(&amp;dir[DIR_FstClusHI]) &lt;&lt; 16) | LD_WORD(&amp;dir[DIR_FstClusLO]);
+	INITBUF(dj, sfn, lfn);
+	res = follow_path(&amp;dj, path);			/* Follow the file path */
+	if (_FS_RPATH &amp;&amp; res == FR_OK &amp;&amp; (dj.fn[11] &amp; NS_DOT))
+		res = FR_INVALID_NAME;
+	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
 
-    if (dir[DIR_Attr] &amp; AM_DIR) {                /* It is a sub-directory */
-        dirobj.clust = dclust;                    /* Check if the sub-dir is empty or not */
-        dirobj.sect = clust2sect(fs, dclust);
-        dirobj.index = 2;
-        do {
-            if (!move_window(fs, dirobj.sect)) return FR_RW_ERROR;
-            sdir = &amp;fs-&gt;win[(dirobj.index &amp; ((S_SIZ - 1) &gt;&gt; 5)) * 32];
-            if (sdir[DIR_Name] == 0) break;
-            if (sdir[DIR_Name] != 0xE5 &amp;&amp; !(sdir[DIR_Attr] &amp; AM_VOL))
-                return FR_DENIED;    /* The directory is not empty */
-        } while (next_dir_entry(&amp;dirobj));
-    }
+	dir = dj.dir;
+	if (!dir)								/* Is it the root directory? */
+		LEAVE_FF(dj.fs, FR_INVALID_NAME);
+	if (dir[DIR_Attr] &amp; AM_RDO)				/* Is it a R/O object? */
+		LEAVE_FF(dj.fs, FR_DENIED);
+	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) &lt;&lt; 16) | LD_WORD(dir+DIR_FstClusLO);
 
-    if (!move_window(fs, dsect)) return FR_RW_ERROR;    /* Mark the directory entry 'deleted' */
-    dir[DIR_Name] = 0xE5;
-    fs-&gt;winflag = 1;
-    if (!remove_chain(fs, dclust)) return FR_RW_ERROR;    /* Remove the cluster chain */
+	if (dir[DIR_Attr] &amp; AM_DIR) {			/* It is a sub-directory */
+		if (dclst &lt; 2) LEAVE_FF(dj.fs, FR_INT_ERR);
+		mem_cpy(&amp;sdj, &amp;dj, sizeof(DIR));		/* Check if the sub-dir is empty or not */
+		sdj.sclust = dclst;
+		res = dir_seek(&amp;sdj, 0);
+		if (res != FR_OK) LEAVE_FF(dj.fs, res);
+		res = dir_read(&amp;sdj);
+		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
+		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
+	}
 
-    return sync(fs);
+	res = dir_remove(&amp;dj);					/* Remove directory entry */
+	if (res == FR_OK) {
+		if (dclst)
+			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
+		if (res == FR_OK) res = sync(dj.fs);
+	}
+
+	LEAVE_FF(dj.fs, res);
 }
 
 
@@ -1429,66 +2466,75 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_mkdir (
-    const char *path        /* Pointer to the directory path */
+	const XCHAR *path		/* Pointer to the directory path */
 )
 {
-    BYTE *dir, *fw, n;
-    char fn[8+3+1];
-    DWORD sect, dsect, dclust, pclust, tim;
-    FRESULT res;
-    DIR dirobj;
-    FATFS *fs;
+	FRESULT res;
+	DIR dj;
+	NAMEBUF(sfn, lfn);
+	BYTE *dir, n;
+	DWORD dsect, dclst, pclst, tim;
 
 
-    res = auto_mount(&amp;path, &amp;fs, 1);
-    if (res != FR_OK) return res;
-    dirobj.fs = fs;
+	res = auto_mount(&amp;path, &amp;dj.fs, 1);
+	if (res != FR_OK) LEAVE_FF(dj.fs, res);
 
-    res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
-    if (res == FR_OK) return FR_EXIST;            /* Any file or directory is already existing */
-    if (res != FR_NO_FILE) return res;
+	INITBUF(dj, sfn, lfn);
+	res = follow_path(&amp;dj, path);			/* Follow the file path */
+	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
+	if (_FS_RPATH &amp;&amp; res == FR_NO_FILE &amp;&amp; (dj.fn[11] &amp; NS_DOT))
+		res = FR_INVALID_NAME;
+	if (res != FR_NO_FILE)					/* Any error occured */
+		LEAVE_FF(dj.fs, res);
 
-    res = reserve_direntry(&amp;dirobj, &amp;dir);         /* Reserve a directory entry */
-    if (res != FR_OK) return res;
-    sect = fs-&gt;winsect;
-    dclust = create_chain(fs, 0);                /* Allocate a cluster for new directory table */
-    if (dclust == 1) return FR_RW_ERROR;
-    dsect = clust2sect(fs, dclust);
-    if (!dsect) return FR_DENIED;
-    if (!move_window(fs, dsect)) return FR_RW_ERROR;
+	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
+	res = FR_OK;
+	if (dclst == 0) res = FR_DENIED;
+	if (dclst == 1) res = FR_INT_ERR;
+	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
+	if (res == FR_OK)
+		res = move_window(dj.fs, 0);
+	if (res != FR_OK) LEAVE_FF(dj.fs, res);
+	dsect = clust2sect(dj.fs, dclst);
 
-    fw = fs-&gt;win;
-    memset(fw, 0, S_SIZ);                        /* Clear the new directory table */
-    for (n = 1; n &lt; fs-&gt;sects_clust; n++) {
-        if (disk_write(fs-&gt;drive, fw, ++dsect, 1) != RES_OK)
-            return FR_RW_ERROR;
-    }
-    memset(&amp;fw[DIR_Name], ' ', 8+3);            /* Create &quot;.&quot; entry */
-    fw[DIR_Name] = '.';
-    fw[DIR_Attr] = AM_DIR;
-    tim = get_fattime();
-    ST_DWORD(&amp;fw[DIR_WrtTime], tim);
-    memcpy(&amp;fw[32], &amp;fw[0], 32); fw[33] = '.';    /* Create &quot;..&quot; entry */
-    pclust = dirobj.sclust;
-#if _FAT32
-    ST_WORD(&amp;fw[   DIR_FstClusHI], dclust &gt;&gt; 16);
-    if (fs-&gt;fs_type == FS_FAT32 &amp;&amp; pclust == fs-&gt;dirbase) pclust = 0;
-    ST_WORD(&amp;fw[32+DIR_FstClusHI], pclust &gt;&gt; 16);
-#endif
-    ST_WORD(&amp;fw[   DIR_FstClusLO], dclust);
-    ST_WORD(&amp;fw[32+DIR_FstClusLO], pclust);
-    fs-&gt;winflag = 1;
+	dir = dj.fs-&gt;win;						/* Initialize the new directory table */
+	mem_set(dir, 0, SS(dj.fs));
+	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create &quot;.&quot; entry */
+	dir[DIR_Name] = '.';
+	dir[DIR_Attr] = AM_DIR;
+	tim = get_fattime();
+	ST_DWORD(dir+DIR_WrtTime, tim);
+	ST_WORD(dir+DIR_FstClusLO, dclst);
+	ST_WORD(dir+DIR_FstClusHI, dclst &gt;&gt; 16);
+	mem_cpy(dir+32, dir, 32); 			/* Create &quot;..&quot; entry */
+	dir[33] = '.';
+	pclst = dj.sclust;
+	if (dj.fs-&gt;fs_type == FS_FAT32 &amp;&amp; pclst == dj.fs-&gt;dirbase)
+		pclst = 0;
+	ST_WORD(dir+32+DIR_FstClusLO, pclst);
+	ST_WORD(dir+32+DIR_FstClusHI, pclst &gt;&gt; 16);
+	for (n = 0; n &lt; dj.fs-&gt;csize; n++) {	/* Write dot entries and clear left sectors */
+		dj.fs-&gt;winsect = dsect++;
+		dj.fs-&gt;wflag = 1;
+		res = move_window(dj.fs, 0);
+		if (res) LEAVE_FF(dj.fs, res);
+		mem_set(dir, 0, SS(dj.fs));
+	}
 
-    if (!move_window(fs, sect)) return FR_RW_ERROR;
-    memset(&amp;dir[0], 0, 32);                        /* Initialize the new entry */
-    memcpy(&amp;dir[DIR_Name], fn, 8+3);            /* Name */
-    dir[DIR_NTres] = fn[11];
-    dir[DIR_Attr] = AM_DIR;                        /* Attribute */
-    ST_DWORD(&amp;dir[DIR_WrtTime], tim);            /* Crated time */
-    ST_WORD(&amp;dir[DIR_FstClusLO], dclust);        /* Table start cluster */
-    ST_WORD(&amp;dir[DIR_FstClusHI], dclust &gt;&gt; 16);
+	res = dir_register(&amp;dj);
+	if (res != FR_OK) {
+		remove_chain(dj.fs, dclst);
+	} else {
+		dir = dj.dir;
+		dir[DIR_Attr] = AM_DIR;					/* Attribute */
+		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
+		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
+		ST_WORD(dir+DIR_FstClusHI, dclst &gt;&gt; 16);
+		dj.fs-&gt;wflag = 1;
+		res = sync(dj.fs);
+	}
 
-    return sync(fs);
+	LEAVE_FF(dj.fs, res);
 }
 
 
@@ -1499,279 +2545,595 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_chmod (
-    const char *path,    /* Pointer to the file path */
-    BYTE value,            /* Attribute bits */
-    BYTE mask            /* Attribute mask to change */
+	const XCHAR *path,	/* Pointer to the file path */
+	BYTE value,			/* Attribute bits */
+	BYTE mask			/* Attribute mask to change */
 )
 {
-    FRESULT res;
-    BYTE *dir;
-    DIR dirobj;
-    char fn[8+3+1];
-    FATFS *fs;
+	FRESULT res;
+	DIR dj;
+	NAMEBUF(sfn, lfn);
+	BYTE *dir;
 
 
-    res = auto_mount(&amp;path, &amp;fs, 1);
-    if (res == FR_OK) {
-        dirobj.fs = fs;
-        res = trace_path(&amp;dirobj, fn, path, &amp;dir);    /* Trace the file path */
-        if (res == FR_OK) {            /* Trace completed */
-            if (dir == NULL) {
-                res = FR_INVALID_NAME;
-            } else {
-                mask &amp;= AM_RDO|AM_HID|AM_SYS|AM_ARC;    /* Valid attribute mask */
-                dir[DIR_Attr] = (value &amp; mask) | (dir[DIR_Attr] &amp; (BYTE)~mask);    /* Apply attribute change */
-                res = sync(fs);
-            }
-        }
-    }
-    return res;
+	res = auto_mount(&amp;path, &amp;dj.fs, 1);
+	if (res == FR_OK) {
+		INITBUF(dj, sfn, lfn);
+		res = follow_path(&amp;dj, path);		/* Follow the file path */
+		if (_FS_RPATH &amp;&amp; res == FR_OK &amp;&amp; (dj.fn[11] &amp; NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_OK) {
+			dir = dj.dir;
+			if (!dir) {						/* Is it a root directory? */
+				res = FR_INVALID_NAME;
+			} else {						/* File or sub directory */
+				mask &amp;= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
+				dir[DIR_Attr] = (value &amp; mask) | (dir[DIR_Attr] &amp; (BYTE)~mask);	/* Apply attribute change */
+				dj.fs-&gt;wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+	}
+
+	LEAVE_FF(dj.fs, res);
 }
 
 
 
 
 /*-----------------------------------------------------------------------*/
+/* Change Timestamp                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_utime (
+	const XCHAR *path,	/* Pointer to the file/directory name */
+	const FILINFO *fno	/* Pointer to the timestamp to be set */
+)
+{
+	FRESULT res;
+	DIR dj;
+	NAMEBUF(sfn, lfn);
+	BYTE *dir;
+
+
+	res = auto_mount(&amp;path, &amp;dj.fs, 1);
+	if (res == FR_OK) {
+		INITBUF(dj, sfn, lfn);
+		res = follow_path(&amp;dj, path);	/* Follow the file path */
+		if (_FS_RPATH &amp;&amp; res == FR_OK &amp;&amp; (dj.fn[11] &amp; NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_OK) {
+			dir = dj.dir;
+			if (!dir) {				/* Root directory */
+				res = FR_INVALID_NAME;
+			} else {				/* File or sub-directory */
+				ST_WORD(dir+DIR_WrtTime, fno-&gt;ftime);
+				ST_WORD(dir+DIR_WrtDate, fno-&gt;fdate);
+				dj.fs-&gt;wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
 /* Rename File/Directory                                                 */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_rename (
-    const char *path_old,    /* Pointer to the old name */
-    const char *path_new    /* Pointer to the new name */
+	const XCHAR *path_old,	/* Pointer to the old name */
+	const XCHAR *path_new	/* Pointer to the new name */
 )
 {
-    FRESULT res;
-    DWORD sect_old;
-    BYTE *dir_old, *dir_new, direntry[32-11];
-    DIR dirobj;
-    char fn[8+3+1];
-    FATFS *fs;
+	FRESULT res;
+	DIR dj_old, dj_new;
+	NAMEBUF(sfn, lfn);
+	BYTE buf[21], *dir;
+	DWORD dw;
 
 
-    res = auto_mount(&amp;path_old, &amp;fs, 1);
-    if (res != FR_OK) return res;
-    dirobj.fs = fs;
+	INITBUF(dj_old, sfn, lfn);
+	res = auto_mount(&amp;path_old, &amp;dj_old.fs, 1);
+	if (res == FR_OK) {
+		dj_new.fs = dj_old.fs;
+		res = follow_path(&amp;dj_old, path_old);	/* Check old object */
+		if (_FS_RPATH &amp;&amp; res == FR_OK &amp;&amp; (dj_old.fn[11] &amp; NS_DOT))
+			res = FR_INVALID_NAME;
+	}
+	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
 
-    res = trace_path(&amp;dirobj, fn, path_old, &amp;dir_old);    /* Check old object */
-    if (res != FR_OK) return res;            /* The old object is not found */
-    if (!dir_old) return FR_NO_FILE;
-    sect_old = fs-&gt;winsect;                    /* Save the object information */
-    memcpy(direntry, &amp;dir_old[DIR_Attr], 32-11);
+	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
+	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
 
-    res = trace_path(&amp;dirobj, fn, path_new, &amp;dir_new);    /* Check new object */
-    if (res == FR_OK) return FR_EXIST;            /* The new object name is already existing */
-    if (res != FR_NO_FILE) return res;            /* Is there no old name? */
-    res = reserve_direntry(&amp;dirobj, &amp;dir_new);     /* Reserve a directory entry */
-    if (res != FR_OK) return res;
+	mem_cpy(&amp;dj_new, &amp;dj_old, sizeof(DIR));
+	res = follow_path(&amp;dj_new, path_new);		/* Check new object */
+	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
+	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
+		res = dir_register(&amp;dj_new);			/* Register the new object */
+		if (res == FR_OK) {
+			dir = dj_new.dir;					/* Copy object information into new entry */
+			mem_cpy(dir+13, buf+2, 19);
+			dir[DIR_Attr] = buf[0] | AM_ARC;
+			dj_old.fs-&gt;wflag = 1;
+			if (dir[DIR_Attr] &amp; AM_DIR) {		/* Update .. entry in the directory if needed */
+				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
+				if (!dw) {
+					res = FR_INT_ERR;
+				} else {
+					res = move_window(dj_new.fs, dw);
+					dir = dj_new.fs-&gt;win+32;
+					if (res == FR_OK &amp;&amp; dir[1] == '.') {
+						dw = (dj_new.fs-&gt;fs_type == FS_FAT32 &amp;&amp; dj_new.sclust == dj_new.fs-&gt;dirbase) ? 0 : dj_new.sclust;
+						ST_WORD(dir+DIR_FstClusLO, dw);
+						ST_WORD(dir+DIR_FstClusHI, dw &gt;&gt; 16);
+						dj_new.fs-&gt;wflag = 1;
+					}
+				}
+			}
+			if (res == FR_OK) {
+				res = dir_remove(&amp;dj_old);			/* Remove old entry */
+				if (res == FR_OK)
+					res = sync(dj_old.fs);
+			}
+		}
+	}
 
-    memcpy(&amp;dir_new[DIR_Attr], direntry, 32-11);    /* Create new entry */
-    memcpy(&amp;dir_new[DIR_Name], fn, 8+3);
-    dir_new[DIR_NTres] = fn[11];
-    fs-&gt;winflag = 1;
+	LEAVE_FF(dj_old.fs, res);
+}
 
-    if (!move_window(fs, sect_old)) return FR_RW_ERROR;    /* Remove old entry */
-    dir_old[DIR_Name] = 0xE5;
+#endif /* !_FS_READONLY */
+#endif /* _FS_MINIMIZE == 0 */
+#endif /* _FS_MINIMIZE &lt;= 1 */
+#endif /* _FS_MINIMIZE &lt;= 2 */
 
-    return sync(fs);
+
+
+/*-----------------------------------------------------------------------*/
+/* Forward data to the stream directly (Available on only _FS_TINY cfg)  */
+/*-----------------------------------------------------------------------*/
+#if _USE_FORWARD &amp;&amp; _FS_TINY
+
+FRESULT f_forward (
+	FIL *fp, 						/* Pointer to the file object */
+	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
+	UINT btr,						/* Number of bytes to forward */
+	UINT *bf						/* Pointer to number of bytes forwarded */
+)
+{
+	FRESULT res;
+	DWORD remain, clst, sect;
+	UINT rcnt;
+
+
+	*bf = 0;
+
+	res = validate(fp-&gt;fs, fp-&gt;id);					/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp-&gt;fs, res);
+	if (fp-&gt;flag &amp; FA__ERROR)						/* Check error flag */
+		LEAVE_FF(fp-&gt;fs, FR_INT_ERR);
+	if (!(fp-&gt;flag &amp; FA_READ))						/* Check access mode */
+		LEAVE_FF(fp-&gt;fs, FR_DENIED);
+
+	remain = fp-&gt;fsize - fp-&gt;fptr;
+	if (btr &gt; remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
+
+	for ( ;  btr &amp;&amp; (*func)(NULL, 0);				/* Repeat until all data transferred or stream becomes busy */
+		fp-&gt;fptr += rcnt, *bf += rcnt, btr -= rcnt) {
+		if ((fp-&gt;fptr % SS(fp-&gt;fs)) == 0) {			/* On the sector boundary? */
+			if (fp-&gt;csect &gt;= fp-&gt;fs-&gt;csize) {		/* On the cluster boundary? */
+				clst = (fp-&gt;fptr == 0) ?			/* On the top of the file? */
+					fp-&gt;org_clust : get_fat(fp-&gt;fs, fp-&gt;curr_clust);
+				if (clst &lt;= 1) ABORT(fp-&gt;fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp-&gt;fs, FR_DISK_ERR);
+				fp-&gt;curr_clust = clst;				/* Update current cluster */
+				fp-&gt;csect = 0;						/* Reset sector address in the cluster */
+			}
+			fp-&gt;csect++;							/* Next sector address in the cluster */
+		}
+		sect = clust2sect(fp-&gt;fs, fp-&gt;curr_clust);	/* Get current data sector */
+		if (!sect) ABORT(fp-&gt;fs, FR_INT_ERR);
+		sect += fp-&gt;csect - 1;
+		if (move_window(fp-&gt;fs, sect))				/* Move sector window */
+			ABORT(fp-&gt;fs, FR_DISK_ERR);
+		fp-&gt;dsect = sect;
+		rcnt = SS(fp-&gt;fs) - (WORD)(fp-&gt;fptr % SS(fp-&gt;fs));	/* Forward data from sector window */
+		if (rcnt &gt; btr) rcnt = btr;
+		rcnt = (*func)(&amp;fp-&gt;fs-&gt;win[(WORD)fp-&gt;fptr % SS(fp-&gt;fs)], rcnt);
+		if (!rcnt) ABORT(fp-&gt;fs, FR_INT_ERR);
+	}
+
+	LEAVE_FF(fp-&gt;fs, FR_OK);
 }
+#endif /* _USE_FORWARD */
 
 
 
-#if _USE_MKFS
+#if _USE_MKFS &amp;&amp; !_FS_READONLY
 /*-----------------------------------------------------------------------*/
 /* Create File System on the Drive                                       */
 /*-----------------------------------------------------------------------*/
+#define N_ROOTDIR	512			/* Multiple of 32 and &lt;= 2048 */
+#define N_FATS		1			/* 1 or 2 */
+#define MAX_SECTOR	131072000UL	/* Maximum partition size */
+#define MIN_SECTOR	2000UL		/* Minimum partition size */
 
-#define N_ROOTDIR 512
-#define N_FATS 1
-#define MAX_SECTOR 64000000UL
-#define MIN_SECTOR 2000UL
-#define ERASE_BLK 32
 
-
 FRESULT f_mkfs (
-    BYTE drv,            /* Logical drive number */
-    BYTE partition,        /* Partitioning rule 0:FDISK, 1:SFD */
-    BYTE allocsize        /* Allocation unit size [sectors] */
+	BYTE drv,			/* Logical drive number */
+	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
+	WORD allocsize		/* Allocation unit size [bytes] */
 )
 {
-    BYTE fmt, m, *tbl;
-    DWORD b_part, b_fat, b_dir, b_data;        /* Area offset (LBA) */
-    DWORD n_part, n_rsv, n_fat, n_dir;        /* Area size */
-    DWORD n_clust, n;
-    FATFS *fs;
-    DSTATUS stat;
+	static const DWORD sstbl[] = { 2048000, 1024000, 512000, 256000, 128000, 64000, 32000, 16000, 8000, 4000,   0 };
+	static const WORD cstbl[] =  {   32768,   16384,   8192,   4096,   2048, 16384,  8192,  4096, 2048, 1024, 512 };
+	BYTE fmt, m, *tbl;
+	DWORD b_part, b_fat, b_dir, b_data;		/* Area offset (LBA) */
+	DWORD n_part, n_rsv, n_fat, n_dir;		/* Area size */
+	DWORD n_clst, d, n;
+	WORD as;
+	FATFS *fs;
+	DSTATUS stat;
 
 
-    /* Check and mounted drive and clear work area */
-    if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
-    fs = FatFs[drv];
-    if (!fs) return FR_NOT_ENABLED;
-    memset(fs, 0, sizeof(FATFS));
-    drv = LD2PD(drv);
+	/* Check validity of the parameters */
+	if (drv &gt;= _DRIVES) return FR_INVALID_DRIVE;
+	if (partition &gt;= 2) return FR_MKFS_ABORTED;
 
-    /* Check validity of the parameters */
-    for (n = 1; n &lt;= 64 &amp;&amp; allocsize != n; n &lt;&lt;= 1);
-    if (n &gt; 64 || partition &gt;= 2) return FR_MKFS_ABORTED;
+	/* Check mounted drive and clear work area */
+	fs = FatFs[drv];
+	if (!fs) return FR_NOT_ENABLED;
+	fs-&gt;fs_type = 0;
+	drv = LD2PD(drv);
 
-    /* Get disk statics */
-    stat = disk_initialize(drv);
-    if (stat &amp; STA_NOINIT) return FR_NOT_READY;
-    if (stat &amp; STA_PROTECT) return FR_WRITE_PROTECTED;
-    if (disk_ioctl(drv, GET_SECTOR_COUNT, &amp;n_part) != RES_OK || n_part &lt; MIN_SECTOR)
-        return FR_MKFS_ABORTED;
-    if (n_part &gt; MAX_SECTOR) n_part = MAX_SECTOR;
-    b_part = (!partition) ? 63 : 0;
-    n_part -= b_part;
-#if S_MAX_SIZ &gt; 512                        /* Check disk sector size */
-    if (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;S_SIZ) != RES_OK
-        || S_SIZ &gt; S_MAX_SIZ
-        || (DWORD)S_SIZ * allocsize &gt; 32768U)
-        return FR_MKFS_ABORTED;
+	/* Get disk statics */
+	stat = disk_initialize(drv);
+	if (stat &amp; STA_NOINIT) return FR_NOT_READY;
+	if (stat &amp; STA_PROTECT) return FR_WRITE_PROTECTED;
+#if _MAX_SS != 512						/* Get disk sector size */
+	if (disk_ioctl(drv, GET_SECTOR_SIZE, &amp;SS(fs)) != RES_OK
+		|| SS(fs) &gt; _MAX_SS)
+		return FR_MKFS_ABORTED;
 #endif
+	if (disk_ioctl(drv, GET_SECTOR_COUNT, &amp;n_part) != RES_OK || n_part &lt; MIN_SECTOR)
+		return FR_MKFS_ABORTED;
+	if (n_part &gt; MAX_SECTOR) n_part = MAX_SECTOR;
+	b_part = (!partition) ? 63 : 0;		/* Boot sector */
+	n_part -= b_part;
+	for (d = 512; d &lt;= 32768U &amp;&amp; d != allocsize; d &lt;&lt;= 1) ;	/* Check validity of the allocation unit size */
+	if (d != allocsize) allocsize = 0;
+	if (!allocsize) {					/* Auto selection of cluster size */
+		d = n_part;
+		for (as = SS(fs); as &gt; 512U; as &gt;&gt;= 1) d &gt;&gt;= 1;
+		for (n = 0; d &lt; sstbl[n]; n++) ;
+		allocsize = cstbl[n];
+	}
+	if (allocsize &lt; SS(fs)) allocsize = SS(fs);
 
-    /* Pre-compute number of clusters and FAT type */
-    n_clust = n_part / allocsize;
-    fmt = FS_FAT12;
-    if (n_clust &gt;= 0xFF7) fmt = FS_FAT16;
-    if (n_clust &gt;= 0xFFF7) fmt = FS_FAT32;
-    switch (fmt) {
-    case FS_FAT12:
-        n_fat = ((n_clust * 3 + 1) / 2 + 3 + S_SIZ - 1) / S_SIZ;
-        n_rsv = 1 + partition;
-        n_dir = N_ROOTDIR * 32 / S_SIZ;
-        break;
-    case FS_FAT16:
-        n_fat = ((n_clust * 2) + 4 + S_SIZ - 1) / S_SIZ;
-        n_rsv = 1 + partition;
-        n_dir = N_ROOTDIR * 32 / S_SIZ;
-        break;
-    default:
-        n_fat = ((n_clust * 4) + 8 + S_SIZ - 1) / S_SIZ;
-        n_rsv = 33 - partition;
-        n_dir = 0;
-    }
-    b_fat = b_part + n_rsv;            /* FATs start sector */
-    b_dir = b_fat + n_fat * N_FATS;    /* Directory start sector */
-    b_data = b_dir + n_dir;            /* Data start sector */
+	allocsize /= SS(fs);		/* Number of sectors per cluster */
 
-#ifdef ERASE_BLK
-    /* Round up data start sector to erase block boundary */
-    n = (b_data + ERASE_BLK - 1) &amp; ~(ERASE_BLK - 1);
-    b_dir += n - b_data;
-    n_fat += (n - b_data) / N_FATS;
+	/* Pre-compute number of clusters and FAT type */
+	n_clst = n_part / allocsize;
+	fmt = FS_FAT12;
+	if (n_clst &gt;= 0xFF5) fmt = FS_FAT16;
+	if (n_clst &gt;= 0xFFF5) fmt = FS_FAT32;
+
+	/* Determine offset and size of FAT structure */
+	switch (fmt) {
+	case FS_FAT12:
+		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
+		n_rsv = 1 + partition;
+		n_dir = N_ROOTDIR * 32 / SS(fs);
+		break;
+	case FS_FAT16:
+		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
+		n_rsv = 1 + partition;
+		n_dir = N_ROOTDIR * 32 / SS(fs);
+		break;
+	default:
+		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
+		n_rsv = 33 - partition;
+		n_dir = 0;
+	}
+	b_fat = b_part + n_rsv;			/* FATs start sector */
+	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
+	b_data = b_dir + n_dir;			/* Data start sector */
+
+	/* Align data start sector to erase block boundary (for flash memory media) */
+	if (disk_ioctl(drv, GET_BLOCK_SIZE, &amp;n) != RES_OK) return FR_MKFS_ABORTED;
+	n = (b_data + n - 1) &amp; ~(n - 1);
+	n_fat += (n - b_data) / N_FATS;
+	/* b_dir and b_data are no longer used below */
+
+	/* Determine number of cluster and final check of validity of the FAT type */
+	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
+	if (   (fmt == FS_FAT16 &amp;&amp; n_clst &lt; 0xFF5)
+		|| (fmt == FS_FAT32 &amp;&amp; n_clst &lt; 0xFFF5))
+		return FR_MKFS_ABORTED;
+
+	/* Create partition table if needed */
+	if (!partition) {
+		DWORD n_disk = b_part + n_part;
+
+		mem_set(fs-&gt;win, 0, SS(fs));
+		tbl = fs-&gt;win+MBR_Table;
+		ST_DWORD(tbl, 0x00010180);		/* Partition start in CHS */
+		if (n_disk &lt; 63UL * 255 * 1024) {	/* Partition end in CHS */
+			n_disk = n_disk / 63 / 255;
+			tbl[7] = (BYTE)n_disk;
+			tbl[6] = (BYTE)((n_disk &gt;&gt; 2) | 63);
+		} else {
+			ST_WORD(&amp;tbl[6], 0xFFFF);
+		}
+		tbl[5] = 254;
+		if (fmt != FS_FAT32)			/* System ID */
+			tbl[4] = (n_part &lt; 0x10000) ? 0x04 : 0x06;
+		else
+			tbl[4] = 0x0c;
+		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
+		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
+		ST_WORD(tbl+64, 0xAA55);		/* Signature */
+		if (disk_write(drv, fs-&gt;win, 0, 1) != RES_OK)
+			return FR_DISK_ERR;
+		partition = 0xF8;
+	} else {
+		partition = 0xF0;
+	}
+
+	/* Create boot record */
+	tbl = fs-&gt;win;								/* Clear buffer */
+	mem_set(tbl, 0, SS(fs));
+	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
+	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
+	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
+	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
+	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
+	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
+	if (n_part &lt; 0x10000) {						/* Number of total sectors */
+		ST_WORD(tbl+BPB_TotSec16, n_part);
+	} else {
+		ST_DWORD(tbl+BPB_TotSec32, n_part);
+	}
+	tbl[BPB_Media] = partition;					/* Media descripter */
+	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
+	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
+	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
+	n = get_fattime();							/* Use current time as a VSN */
+	if (fmt != FS_FAT32) {
+		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
+		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of secters per FAT */
+		tbl[BS_DrvNum] = 0x80;					/* Drive number */
+		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
+		mem_cpy(tbl+BS_VolLab, &quot;NO NAME    FAT     &quot;, 19);	/* Volume lavel, FAT signature */
+	} else {
+		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
+		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of secters per FAT */
+		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
+		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
+		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
+		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
+		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
+		mem_cpy(tbl+BS_VolLab32, &quot;NO NAME    FAT32   &quot;, 19);	/* Volume lavel, FAT signature */
+	}
+	ST_WORD(tbl+BS_55AA, 0xAA55);				/* Signature */
+	if (SS(fs) &gt; 512U) {
+		ST_WORD(tbl+SS(fs)-2, 0xAA55);
+	}
+	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
+		return FR_DISK_ERR;
+	if (fmt == FS_FAT32)
+		disk_write(drv, tbl, b_part+6, 1);
+
+	/* Initialize FAT area */
+	for (m = 0; m &lt; N_FATS; m++) {
+		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
+		if (fmt != FS_FAT32) {
+			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
+			n |= partition;
+			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
+		} else {
+			ST_DWORD(tbl+0, 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
+			ST_DWORD(tbl+4, 0xFFFFFFFF);
+			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
+		}
+		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
+			return FR_DISK_ERR;
+		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
+		for (n = 1; n &lt; n_fat; n++) {
+			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
+				return FR_DISK_ERR;
+		}
+	}
+
+	/* Initialize Root directory */
+	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
+	do {
+		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
+			return FR_DISK_ERR;
+	} while (--m);
+
+	/* Create FSInfo record if needed */
+	if (fmt == FS_FAT32) {
+		ST_WORD(tbl+BS_55AA, 0xAA55);
+		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
+		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
+		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
+		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
+		disk_write(drv, tbl, b_part+1, 1);
+		disk_write(drv, tbl, b_part+7, 1);
+	}
+
+	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
+}
+
+#endif /* _USE_MKFS &amp;&amp; !_FS_READONLY */
+
+
+
+
+#if _USE_STRFUNC
+/*-----------------------------------------------------------------------*/
+/* Get a string from the file                                            */
+/*-----------------------------------------------------------------------*/
+char* f_gets (
+	char* buff,	/* Pointer to the string buffer to read */
+	int len,	/* Size of string buffer */
+	FIL* fil	/* Pointer to the file object */
+)
+{
+	int i = 0;
+	char *p = buff;
+	UINT rc;
+
+
+	while (i &lt; len - 1) {			/* Read bytes until buffer gets filled */
+		f_read(fil, p, 1, &amp;rc);
+		if (rc != 1) break;			/* Break when no data to read */
+#if _USE_STRFUNC &gt;= 2
+		if (*p == '\r') continue;	/* Strip '\r' */
 #endif
-    /* Determine number of cluster and final check of validity of the FAT type */
-    n_clust = (n_part - n_rsv - n_fat * 2 - n_dir) / allocsize;
-    if (   (fmt == FS_FAT16 &amp;&amp; n_clust &lt; 0xFF7)
-        || (fmt == FS_FAT32 &amp;&amp; n_clust &lt; 0xFFF7))
-        return FR_MKFS_ABORTED;
+		i++;
+		if (*p++ == '\n') break;	/* Break when reached end of line */
+	}
+	*p = 0;
+	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
+}
 
-    /* Create partition table if needed */
-    if (!partition) {
-        DWORD n_disk = b_part + n_part;
 
-        tbl = &amp;fs-&gt;win[MBR_Table];
-        ST_DWORD(&amp;tbl[0], 0x00010180);    /* Partition start in CHS */
-        if (n_disk &lt; 63UL * 255 * 1024) {    /* Partition end in CHS */
-            n_disk = n_disk / 63 / 255;
-            tbl[7] = (BYTE)n_disk;
-            tbl[6] = (BYTE)((n_disk &gt;&gt; 2) | 63);
-        } else {
-            ST_WORD(&amp;tbl[6], 0xFFFF);
-        }
-        tbl[5] = 254;
-        if (fmt != FS_FAT32)            /* System ID */
-            tbl[4] = (n_part &lt; 0x10000) ? 0x04 : 0x06;
-        else
-            tbl[4] = 0x0c;
-        ST_DWORD(&amp;tbl[8], 63);            /* Partition start in LBA */
-        ST_DWORD(&amp;tbl[12], n_part);        /* Partition size in LBA */
-        ST_WORD(&amp;tbl[64], 0xAA55);        /* Signature */
-        if (disk_write(drv, fs-&gt;win, 0, 1) != RES_OK)
-            return FR_RW_ERROR;
-    }
 
-    /* Create boot record */
-    memset(tbl = fs-&gt;win, 0, S_SIZ);
-    ST_DWORD(&amp;tbl[BS_jmpBoot], 0x90FEEB);        /* Boot code (jmp $, nop) */
-    ST_WORD(&amp;tbl[BPB_BytsPerSec], S_SIZ);        /* Sector size */
-    tbl[BPB_SecPerClus] = (BYTE)allocsize;        /* Sectors per cluster */
-    ST_WORD(&amp;tbl[BPB_RsvdSecCnt], n_rsv);        /* Reserved sectors */
-    tbl[BPB_NumFATs] = N_FATS;                    /* Number of FATs */
-    ST_WORD(&amp;tbl[BPB_RootEntCnt], S_SIZ / 32 * n_dir); /* Number of rootdir entries */
-    if (n_part &lt; 0x10000) {                        /* Number of total sectors */
-        ST_WORD(&amp;tbl[BPB_TotSec16], n_part);
-    } else {
-        ST_DWORD(&amp;tbl[BPB_TotSec32], n_part);
-    }
-    tbl[BPB_Media] = 0xF8;                        /* Media descripter */
-    ST_WORD(&amp;tbl[BPB_SecPerTrk], 63);            /* Number of sectors per track */
-    ST_WORD(&amp;tbl[BPB_NumHeads], 255);            /* Number of heads */
-    ST_DWORD(&amp;tbl[BPB_HiddSec], b_part);        /* Hidden sectors */
-    if (fmt != FS_FAT32) {
-        ST_WORD(&amp;tbl[BPB_FATSz16], n_fat);        /* Number of secters per FAT */
-        tbl[BS_DrvNum] = 0x80;                    /* Drive number */
-        tbl[BS_BootSig] = 0x29;                    /* Extended boot signature */
-        memcpy(&amp;tbl[BS_VolLab], &quot;NO NAME    FAT     &quot;, 19);    /* Volume lavel, FAT signature */
-    } else {
-        ST_DWORD(&amp;tbl[BPB_FATSz32], n_fat);        /* Number of secters per FAT */
-        ST_DWORD(&amp;tbl[BPB_RootClus], 2);        /* Root directory cluster (2) */
-        ST_WORD(&amp;tbl[BPB_FSInfo], 1);            /* FSInfo record (bs+1) */
-        ST_WORD(&amp;tbl[BPB_BkBootSec], 6);        /* Backup boot record (bs+6) */
-        tbl[BS_DrvNum32] = 0x80;                /* Drive number */
-        tbl[BS_BootSig32] = 0x29;                /* Extended boot signature */
-        memcpy(&amp;tbl[BS_VolLab32], &quot;NO NAME    FAT32   &quot;, 19);    /* Volume lavel, FAT signature */
-    }
-    ST_WORD(&amp;tbl[BS_55AA], 0xAA55);            /* Signature */
-    if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
-        return FR_RW_ERROR;
-    if (fmt == FS_FAT32)
-        disk_write(drv, tbl, b_part+6, 1);
+#if !_FS_READONLY
+#include &lt;stdarg.h&gt;
+/*-----------------------------------------------------------------------*/
+/* Put a character to the file                                           */
+/*-----------------------------------------------------------------------*/
+int f_putc (
+	int chr,	/* A character to be output */
+	FIL* fil	/* Ponter to the file object */
+)
+{
+	UINT bw;
+	char c;
 
-    /* Initialize FAT area */
-    for (m = 0; m &lt; N_FATS; m++) {
-        memset(tbl, 0, S_SIZ);        /* 1st sector of the FAT  */
-        if (fmt != FS_FAT32) {
-            n = (fmt == FS_FAT12) ? 0x00FFFFF8 : 0xFFFFFFF8;
-            ST_DWORD(&amp;tbl[0], n);            /* Reserve cluster #0-1 (FAT12/16) */
-        } else {
-            ST_DWORD(&amp;tbl[0], 0xFFFFFFF8);    /* Reserve cluster #0-1 (FAT32) */
-            ST_DWORD(&amp;tbl[4], 0xFFFFFFFF);
-            ST_DWORD(&amp;tbl[8], 0x0FFFFFFF);    /* Reserve cluster #2 for root dir */
-        }
-        if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
-            return FR_RW_ERROR;
-        memset(tbl, 0, S_SIZ);        /* Following FAT entries are filled by zero */
-        for (n = 1; n &lt; n_fat; n++) {
-            if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
-                return FR_RW_ERROR;
-        }
-    }
 
-    /* Initialize Root directory */
-    for (m = 0; m &lt; 64; m++) {
-        if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
-            return FR_RW_ERROR;
-    }
+#if _USE_STRFUNC &gt;= 2
+	if (chr == '\n') f_putc ('\r', fil);	/* LF -&gt; CRLF conversion */
+#endif
+	if (!fil) {	/* Special value may be used to switch the destination to any other device */
+	/*	put_console(chr);	*/
+		return chr;
+	}
+	c = (char)chr;
+	f_write(fil, &amp;c, 1, &amp;bw);	/* Write a byte to the file */
+	return bw ? chr : EOF;		/* Return the result */
+}
 
-    /* Create FSInfo record if needed */
-    if (fmt == FS_FAT32) {
-        ST_WORD(&amp;tbl[BS_55AA], 0xAA55);
-        ST_DWORD(&amp;tbl[FSI_LeadSig], 0x41615252);
-        ST_DWORD(&amp;tbl[FSI_StrucSig], 0x61417272);
-        ST_DWORD(&amp;tbl[FSI_Free_Count], n_clust - 1);
-        ST_DWORD(&amp;tbl[FSI_Nxt_Free], 0xFFFFFFFF);
-        disk_write(drv, tbl, b_part+1, 1);
-        disk_write(drv, tbl, b_part+7, 1);
-    }
 
-    return (disk_ioctl(drv, CTRL_SYNC, NULL) == RES_OK) ? FR_OK : FR_RW_ERROR;
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a string to the file                                              */
+/*-----------------------------------------------------------------------*/
+int f_puts (
+	const char* str,	/* Pointer to the string to be output */
+	FIL* fil			/* Pointer to the file object */
+)
+{
+	int n;
+
+
+	for (n = 0; *str; str++, n++) {
+		if (f_putc(*str, fil) == EOF) return EOF;
+	}
+	return n;
 }
 
-#endif /* _USE_MKFS */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a formatted string to the file                                    */
+/*-----------------------------------------------------------------------*/
+int f_printf (
+	FIL* fil,			/* Pointer to the file object */
+	const char* str,	/* Pointer to the format string */
+	...					/* Optional arguments... */
+)
+{
+	va_list arp;
+	UCHAR c, f, r;
+	ULONG val;
+	char s[16];
+	int i, w, res, cc;
+
+
+	va_start(arp, str);
+
+	for (cc = res = 0; cc != EOF; res += cc) {
+		c = *str++;
+		if (c == 0) break;			/* End of string */
+		if (c != '%') {				/* Non escape cahracter */
+			cc = f_putc(c, fil);
+			if (cc != EOF) cc = 1;
+			continue;
+		}
+		w = f = 0;
+		c = *str++;
+		if (c == '0') {				/* Flag: '0' padding */
+			f = 1; c = *str++;
+		}
+		while (c &gt;= '0' &amp;&amp; c &lt;= '9') {	/* Precision */
+			w = w * 10 + (c - '0');
+			c = *str++;
+		}
+		if (c == 'l') {				/* Prefix: Size is long int */
+			f |= 2; c = *str++;
+		}
+		if (c == 's') {				/* Type is string */
+			cc = f_puts(va_arg(arp, char*), fil);
+			continue;
+		}
+		if (c == 'c') {				/* Type is character */
+			cc = f_putc(va_arg(arp, int), fil);
+			if (cc != EOF) cc = 1;
+			continue;
+		}
+		r = 0;
+		if (c == 'd') r = 10;		/* Type is signed decimal */
+		if (c == 'u') r = 10;		/* Type is unsigned decimal */
+		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
+		if (r == 0) break;			/* Unknown type */
+		if (f &amp; 2) {				/* Get the value */
+			val = (ULONG)va_arg(arp, long);
+		} else {
+			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
+		}
+		/* Put numeral string */
+		if (c == 'd') {
+			if (val &amp; 0x80000000) {
+				val = 0 - val;
+				f |= 4;
+			}
+		}
+		i = sizeof(s) - 1; s[i] = 0;
+		do {
+			c = (UCHAR)(val % r + '0');
+			if (c &gt; '9') c += 7;
+			s[--i] = c;
+			val /= r;
+		} while (i &amp;&amp; val);
+		if (i &amp;&amp; (f &amp; 4)) s[--i] = '-';
+		w = sizeof(s) - 1 - w;
+		while (i &amp;&amp; i &gt; w) s[--i] = (f &amp; 1) ? '0' : ' ';
+		cc = f_puts(&amp;s[i], fil);
+	}
+
+	va_end(arp);
+	return (cc == EOF) ? cc : res;
+}
+
 #endif /* !_FS_READONLY */
-#endif /* _FS_MINIMIZE == 0 */
-#endif /* _FS_MINIMIZE &lt;= 1 */
-#endif /* _FS_MINIMIZE &lt;= 2 */
-
+#endif /* _USE_STRFUNC */

Modified: branches/eagle_mmc/src/fatfs/ff.h
===================================================================
--- branches/eagle_mmc/src/fatfs/ff.h	2009-10-30 17:42:31 UTC (rev 504)
+++ branches/eagle_mmc/src/fatfs/ff.h	2009-10-30 23:10:23 UTC (rev 505)
@@ -1,329 +1,726 @@
-/*--------------------------------------------------------------------------/
-/  FatFs - FAT file system module include file  R0.04b       (C)ChaN, 2007
-/---------------------------------------------------------------------------/
-/ FatFs module is an experimenal project to implement FAT file system to
-/ cheap microcontrollers. This is a free software and is opened for education,
-/ research and development under license policy of following trems.
+/*---------------------------------------------------------------------------/
+/  FatFs - FAT file system module include file  R0.07c       (C)ChaN, 2009
+/----------------------------------------------------------------------------/
+/ FatFs module is an open source software to implement FAT file system to
+/ small embedded systems. This is a free software and is opened for education,
+/ research and commercial developments under license policy of following trems.
 /
-/  Copyright (C) 2007, ChaN, all right reserved.
+/  Copyright (C) 2009, ChaN, all right reserved.
 /
-/ * The FatFs module is a free software and there is no warranty.
-/ * You can use, modify and/or redistribute it for personal, non-profit or
-/   profit use without any restriction under your responsibility.
+/ * The FatFs module is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
 / * Redistributions of source code must retain the above copyright notice.
+/----------------------------------------------------------------------------*/
+
+#include &quot;integer.h&quot;
+
+/*---------------------------------------------------------------------------/
+/ FatFs Configuration Options
 /
-/---------------------------------------------------------------------------*/
-
+/ CAUTION! Do not forget to make clean the project after any changes to
+/ the configuration options.
+/
+/----------------------------------------------------------------------------*/
 #ifndef _FATFS
+#define _FATFS	0x007C
 
-#define _MCU_ENDIAN        1
-/* The _MCU_ENDIAN defines which access method is used to the FAT structure.
-/  1: Enable word access.
-/  2: Disable word access and use byte-by-byte access instead.
-/  When the architectural byte order of the MCU is big-endian and/or address
-/  miss-aligned access is prohibited, the _MCU_ENDIAN must be set to 2.
-/  If it is not the case, it can be set to 1 for good code efficiency. */
+#define _WORD_ACCESS	0
+/* The _WORD_ACCESS option defines which access method is used to the word
+/  data in the FAT structure.
+/
+/   0: Byte-by-byte access. Always compatible with all platforms.
+/   1: Word access. Do not choose this unless following condition is met.
+/
+/  When the byte order on the memory is big-endian or address miss-aligned
+/  word access results incorrect behavior, the _WORD_ACCESS must be set to 0.
+/  If it is not the case, the value can also be set to 1 to improve the
+/  performance and code efficiency. */
 
-#define _FS_READONLY    0
+
+#define _FS_READONLY	0
 /* Setting _FS_READONLY to 1 defines read only configuration. This removes
-/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename
-/  and useless f_getfree. */
+/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
+/  f_truncate and useless f_getfree. */
 
-#define _FS_MINIMIZE    0
+
+#define _FS_MINIMIZE	0
 /* The _FS_MINIMIZE option defines minimization level to remove some functions.
-/  0: Full function.
-/  1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod and f_rename are removed.
-/  2: f_opendir and f_readdir are removed in addition to level 1.
-/  3: f_lseek is removed in addition to level 2. */
+/
+/   0: Full function.
+/   1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename
+/      are removed.
+/   2: f_opendir and f_readdir are removed in addition to level 1.
+/   3: f_lseek is removed in addition to level 2. */
 
-#define _DRIVES        2
-/* Number of logical drives to be used. This affects the size of internal table. */
 
-#define    _USE_MKFS    0
-/* When _USE_MKFS is set to 1 and _FS_READONLY is set to 0, f_mkfs function is
-/  enabled. */
+#define	_FS_TINY	0
+/* When _FS_TINY is set to 1, FatFs uses the sector buffer in the file system
+/  object instead of the sector buffer in the individual file object for file
+/  data transfer. This reduces memory consumption 512 bytes each file object. */
 
-#define    _MULTI_PARTITION    0
-/* When _MULTI_PARTITION is set to 0, each logical drive is bound to same
-/  physical drive number and can mount only 1st primaly partition. When it is
-/  set to 1, each logical drive can mount a partition listed in Drives[]. */
 
-#define _USE_FSINFO    0
-/* To enable FSInfo support on FAT32 volume, set _USE_FSINFO to 1. */
+#define	_USE_STRFUNC	0
+/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
 
-#define    _USE_SJIS    1
-/* When _USE_SJIS is set to 1, Shift-JIS code transparency is enabled, otherwise
-/  only US-ASCII(7bit) code can be accepted as file/directory name. */
 
-#define    _USE_NTFLAG    1
-/* When _USE_NTFLAG is set to 1, upper/lower case of the file name is preserved.
-/  Note that the files are always accessed in case insensitive. */
+#define	_USE_MKFS	0
+/* To enable f_mkfs function, set _USE_MKFS to 1 and set _FS_READONLY to 0 */
 
 
-#include &quot;integer.h&quot;
+#define	_USE_FORWARD	0
+/* To enable f_forward function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
 
 
+#define _CODE_PAGE	932
+/* The _CODE_PAGE specifies the OEM code page to be used on the target system.
+/
+/   932  - Japanese Shift-JIS (DBCS, OEM, Windows)
+/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
+/   949  - Korean (DBCS, OEM, Windows)
+/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
+/   1250 - Central Europe (Windows)
+/   1251 - Cyrillic (Windows)
+/   1252 - Latin 1 (Windows)
+/   1253 - Greek (Windows)
+/   1254 - Turkish (Windows)
+/   1255 - Hebrew (Windows)
+/   1256 - Arabic (Windows)
+/   1257 - Baltic (Windows)
+/   1258 - Vietnam (OEM, Windows)
+/   437  - U.S. (OEM)
+/   720  - Arabic (OEM)
+/   737  - Greek (OEM)
+/   775  - Baltic (OEM)
+/   850  - Multilingual Latin 1 (OEM)
+/   858  - Multilingual Latin 1 + Euro (OEM)
+/   852  - Latin 2 (OEM)
+/   855  - Cyrillic (OEM)
+/   866  - Russian (OEM)
+/   857  - Turkish (OEM)
+/   862  - Hebrew (OEM)
+/   874  - Thai (OEM, Windows)
+/	1 - ASCII (Valid for only non LFN cfg.)
+*/
 
-/* Definitions corresponds to multiple sector size (not tested) */
-#define    S_MAX_SIZ    512            /* Do not change */
-#if S_MAX_SIZ &gt; 512
-#define    S_SIZ    (fs-&gt;s_size)
+
+#define	_USE_LFN	0
+#define	_MAX_LFN	255		/* Maximum LFN length to handle (max:255) */
+/* The _USE_LFN option switches the LFN support.
+/
+/   0: Disable LFN.
+/   1: Enable LFN with static working buffer on the bss. NOT REENTRANT.
+/   2: Enable LFN with dynamic working buffer on the caller's STACK.
+/
+/  The working buffer occupies (_MAX_LFN + 1) * 2 bytes. When enable LFN,
+/  a Unicode handling functions ff_convert() and ff_wtoupper() must be added
+/  to the project. */
+
+
+#define _FS_RPATH	0
+/* When _FS_RPATH is set to 1, relative path feature is enabled and f_chdir,
+/  f_chdrive function are available.
+/  Note that output of the f_readdir fnction is affected by this option. */
+
+
+#define _FS_REENTRANT	0
+#define _TIMEOUT		1000	/* Timeout period in unit of time ticks of the OS */
+#define	_SYNC_t			HANDLE	/* Type of sync object used on the OS. e.g. HANDLE, OS_EVENT*, ID and etc.. */
+/* To make the FatFs module re-entrant, set _FS_REENTRANT to 1 and add user
+/  provided synchronization handlers, ff_req_grant, ff_rel_grant, ff_del_syncobj
+/  and ff_cre_syncobj function to the project. */
+
+
+#define _DRIVES		1
+/* Number of volumes (logical drives) to be used. */
+
+
+#define	_MAX_SS		512
+/* Maximum sector size to be handled. (512/1024/2048/4096) */
+/* Usually set 512 for memory card and hard disk but 1024 for floppy disk, 2048 for MO disk */
+/* When _MAX_SS &gt; 512, GET_SECTOR_SIZE must be implememted to disk_ioctl() */
+
+
+#define	_MULTI_PARTITION	0
+/* When _MULTI_PARTITION is set to 0, each volume is bound to the same physical
+/ drive number and can mount only first primaly partition. When it is set to 1,
+/ each volume is tied to the partitions listed in Drives[]. */
+
+
+
+/* End of configuration options. Do not change followings without care.     */
+/*--------------------------------------------------------------------------*/
+
+
+
+/* DBCS code ranges and SBCS extend char conversion table */
+
+#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
+#define _DF1S	0x81	/* DBC 1st byte range 1 start */
+#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
+#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
+#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
+#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
+#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
+#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
+#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
+
+#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0x80
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 949	/* Korean */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x41
+#define _DS1E	0x5A
+#define _DS2S	0x61
+#define _DS2E	0x7A
+#define _DS3S	0x81
+#define _DS3E	0xFE
+
+#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0xA1
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 437	/* U.S. (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 720	/* Arabic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 737	/* Greek (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
+				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 775	/* Baltic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
+
+#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
+				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
+				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 857	/* Turkish (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 866	/* Russian (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
+
+#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
+				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
+
+#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+
+#elif _CODE_PAGE == 1253 /* Greek (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
+				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
+
+#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+
+#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
+
+#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
+
+#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
+#define _DF1S	0
+
 #else
-#define    S_SIZ    512
+#error Unknown code page
+
 #endif
 
 
+
+/* Character code support macros */
+
+#define IsUpper(c)	(((c)&gt;='A')&amp;&amp;((c)&lt;='Z'))
+#define IsLower(c)	(((c)&gt;='a')&amp;&amp;((c)&lt;='z'))
+#define IsDigit(c)	(((c)&gt;='0')&amp;&amp;((c)&lt;='9'))
+
+#if _DF1S	/* DBCS configuration */
+
+#if _DF2S	/* Two 1st byte areas */
+#define IsDBCS1(c)	(((BYTE)(c) &gt;= _DF1S &amp;&amp; (BYTE)(c) &lt;= _DF1E) || ((BYTE)(c) &gt;= _DF2S &amp;&amp; (BYTE)(c) &lt;= _DF2E))
+#else		/* One 1st byte area */
+#define IsDBCS1(c)	((BYTE)(c) &gt;= _DF1S &amp;&amp; (BYTE)(c) &lt;= _DF1E)
+#endif
+
+#if _DS3S	/* Three 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) &gt;= _DS1S &amp;&amp; (BYTE)(c) &lt;= _DS1E) || ((BYTE)(c) &gt;= _DS2S &amp;&amp; (BYTE)(c) &lt;= _DS2E) || ((BYTE)(c) &gt;= _DS3S &amp;&amp; (BYTE)(c) &lt;= _DS3E))
+#else		/* Two 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) &gt;= _DS1S &amp;&amp; (BYTE)(c) &lt;= _DS1E) || ((BYTE)(c) &gt;= _DS2S &amp;&amp; (BYTE)(c) &lt;= _DS2E))
+#endif
+
+#else		/* SBCS configuration */
+
+#define IsDBCS1(c)	0
+#define IsDBCS2(c)	0
+
+#endif /* _DF1S */
+
+
+
+/* Definitions corresponds to multi partition */
+
+#if _MULTI_PARTITION		/* Multiple partition configuration */
+
+typedef struct _PARTITION {
+	BYTE pd;	/* Physical drive# */
+	BYTE pt;	/* Partition # (0-3) */
+} PARTITION;
+
+extern
+const PARTITION Drives[];			/* Logical drive# to physical location conversion table */
+#define LD2PD(drv) (Drives[drv].pd)	/* Get physical drive# */
+#define LD2PT(drv) (Drives[drv].pt)	/* Get partition# */
+
+#else						/* Single partition configuration */
+
+#define LD2PD(drv) (drv)	/* Physical drive# is equal to the logical drive# */
+#define LD2PT(drv) 0		/* Always mounts the 1st partition */
+
+#endif
+
+
+
+/* Definitions corresponds to multiple sector size */
+
+#if _MAX_SS == 512
+#define	SS(fs)	512U
+
+#elif _MAX_SS == 1024 || _MAX_SS == 2048 || _MAX_SS == 4096
+#define	SS(fs)	((fs)-&gt;s_size)
+
+#else
+#error Sector size must be 512, 1024, 2048 or 4096.
+
+#endif
+
+
+
+/* Type of file name on FatFs API */
+
+#if _LFN_UNICODE &amp;&amp; _USE_LFN
+typedef WCHAR XCHAR;	/* Unicode */
+#else
+typedef char XCHAR;		/* SBCS, DBCS */
+#endif
+
+
+
 /* File system object structure */
-typedef struct _FATFS {
-    WORD    id;                /* File system mount ID */
-    WORD    n_rootdir;        /* Number of root directory entries */
-    DWORD    winsect;        /* Current sector appearing in the win[] */
-    DWORD    sects_fat;        /* Sectors per fat */
-    DWORD    max_clust;        /* Maximum cluster# + 1 */
-    DWORD    fatbase;        /* FAT start sector */
-    DWORD    dirbase;        /* Root directory start sector (cluster# for FAT32) */
-    DWORD    database;        /* Data start sector */
+
+typedef struct _FATFS_ {
+	BYTE	fs_type;	/* FAT sub type */
+	BYTE	drive;		/* Physical drive number */
+	BYTE	csize;		/* Number of sectors per cluster */
+	BYTE	n_fats;		/* Number of FAT copies */
+	BYTE	wflag;		/* win[] dirty flag (1:must be written back) */
+	WORD	id;			/* File system mount ID */
+	WORD	n_rootdir;	/* Number of root directory entries (0 on FAT32) */
+#if _FS_REENTRANT
+	_SYNC_t	sobj;		/* Identifier of sync object */
+#endif
+#if _MAX_SS != 512
+	WORD	s_size;		/* Sector size */
+#endif
 #if !_FS_READONLY
-    DWORD    last_clust;        /* Last allocated cluster */
-    DWORD    free_clust;        /* Number of free clusters */
-#if _USE_FSINFO
-    DWORD    fsi_sector;        /* fsinfo sector */
-    BYTE    fsi_flag;        /* fsinfo dirty flag (1:must be written back) */
-    BYTE    pad2;
+	BYTE	fsi_flag;	/* fsinfo dirty flag (1:must be written back) */
+	DWORD	last_clust;	/* Last allocated cluster */
+	DWORD	free_clust;	/* Number of free clusters */
+	DWORD	fsi_sector;	/* fsinfo sector */
 #endif
+#if _FS_RPATH
+	DWORD	cdir;		/* Current directory (0:root)*/
 #endif
-    BYTE    fs_type;        /* FAT sub type */
-    BYTE    sects_clust;    /* Sectors per cluster */
-#if S_MAX_SIZ &gt; 512
-    WORD    s_size;            /* Sector size */
-#endif
-    BYTE    n_fats;            /* Number of FAT copies */
-    BYTE    drive;            /* Physical drive number */
-    BYTE    winflag;        /* win[] dirty flag (1:must be written back) */
-    BYTE    pad1;
-    BYTE    win[S_MAX_SIZ];    /* Disk access window for Directory/FAT */
+	DWORD	sects_fat;	/* Sectors per fat */
+	DWORD	max_clust;	/* Maximum cluster# + 1. Number of clusters is max_clust - 2 */
+	DWORD	fatbase;	/* FAT start sector */
+	DWORD	dirbase;	/* Root directory start sector (Cluster# on FAT32) */
+	DWORD	database;	/* Data start sector */
+	DWORD	winsect;	/* Current sector appearing in the win[] */
+	BYTE	win[_MAX_SS];/* Disk access window for Directory/FAT */
 } FATFS;
 
 
+
 /* Directory object structure */
-typedef struct _DIR {
-    WORD    id;            /* Owner file system mount ID */
-    WORD    index;        /* Current index */
-    FATFS*    fs;            /* Pointer to the owner file system object */
-    DWORD    sclust;        /* Start cluster */
-    DWORD    clust;        /* Current cluster */
-    DWORD    sect;        /* Current sector */
+
+typedef struct _DIR_ {
+	FATFS*	fs;			/* Pointer to the owner file system object */
+	WORD	id;			/* Owner file system mount ID */
+	WORD	index;		/* Current read/write index number */
+	DWORD	sclust;		/* Table start cluster (0:Static table) */
+	DWORD	clust;		/* Current cluster */
+	DWORD	sect;		/* Current sector */
+	BYTE*	dir;		/* Pointer to the current SFN entry in the win[] */
+	BYTE*	fn;			/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
+#if _USE_LFN
+	WCHAR*	lfn;		/* Pointer to the LFN working buffer */
+	WORD	lfn_idx;	/* Last matched LFN index number (0xFFFF:No LFN) */
+#endif
 } DIR;
 
 
+
 /* File object structure */
-typedef struct _FIL {
-    WORD    id;                /* Owner file system mount ID */
-    BYTE    flag;            /* File status flags */
-    BYTE    sect_clust;        /* Left sectors in cluster */
-    FATFS*    fs;                /* Pointer to the owner file system object */
-    DWORD    fptr;            /* File R/W pointer */
-    DWORD    fsize;            /* File size */
-    DWORD    org_clust;        /* File start cluster */
-    DWORD    curr_clust;        /* Current cluster */
-    DWORD    curr_sect;        /* Current sector */
-#if _FS_READONLY == 0
-    DWORD    dir_sect;        /* Sector containing the directory entry */
-    BYTE*    dir_ptr;        /* Ponter to the directory entry in the window */
+
+typedef struct _FIL_ {
+	FATFS*	fs;			/* Pointer to the owner file system object */
+	WORD	id;			/* Owner file system mount ID */
+	BYTE	flag;		/* File status flags */
+	BYTE	csect;		/* Sector address in the cluster */
+	DWORD	fptr;		/* File R/W pointer */
+	DWORD	fsize;		/* File size */
+	DWORD	org_clust;	/* File start cluster */
+	DWORD	curr_clust;	/* Current cluster */
+	DWORD	dsect;		/* Current data sector */
+#if !_FS_READONLY
+	DWORD	dir_sect;	/* Sector containing the directory entry */
+	BYTE*	dir_ptr;	/* Ponter to the directory entry in the window */
 #endif
-    BYTE    buffer[S_MAX_SIZ];    /* File R/W buffer */
+#if !_FS_TINY
+	BYTE	buf[_MAX_SS];/* File R/W buffer */
+#endif
 } FIL;
 
 
+
 /* File status structure */
-typedef struct _FILINFO {
-    DWORD fsize;            /* Size */
-    WORD fdate;                /* Date */
-    WORD ftime;                /* Time */
-    BYTE fattrib;            /* Attribute */
-    char fname[8+1+3+1];    /* Name (8.3 format) */
+
+typedef struct _FILINFO_ {
+	DWORD	fsize;		/* File size */
+	WORD	fdate;		/* Last modified date */
+	WORD	ftime;		/* Last modified time */
+	BYTE	fattrib;	/* Attribute */
+	char	fname[13];	/* Short file name (8.3 format) */
+#if _USE_LFN
+	XCHAR*	lfname;		/* Pointer to the LFN buffer */
+	int 	lfsize;		/* Size of LFN buffer [chrs] */
+#endif
 } FILINFO;
 
 
 
-/* Definitions corresponds to multi partition */
+/* File function return code (FRESULT) */
 
-#if _MULTI_PARTITION != 0    /* Multiple partition cfg */
+typedef enum {
+	FR_OK = 0,			/* 0 */
+	FR_DISK_ERR,		/* 1 */
+	FR_INT_ERR,			/* 2 */
+	FR_NOT_READY,		/* 3 */
+	FR_NO_FILE,			/* 4 */
+	FR_NO_PATH,			/* 5 */
+	FR_INVALID_NAME,	/* 6 */
+	FR_DENIED,			/* 7 */
+	FR_EXIST,			/* 8 */
+	FR_INVALID_OBJECT,	/* 9 */
+	FR_WRITE_PROTECTED,	/* 10 */
+	FR_INVALID_DRIVE,	/* 11 */
+	FR_NOT_ENABLED,		/* 12 */
+	FR_NO_FILESYSTEM,	/* 13 */
+	FR_MKFS_ABORTED,	/* 14 */
+	FR_TIMEOUT			/* 15 */
+} FRESULT;
 
-typedef struct _PARTITION {
-    BYTE pd;    /* Physical drive # (0-255) */
-    BYTE pt;    /* Partition # (0-3) */
-} PARTITION;
-extern
-const PARTITION Drives[];            /* Logical drive# to physical location conversion table */
-#define LD2PD(drv) (Drives[drv].pd)    /* Get physical drive# */
-#define LD2PT(drv) (Drives[drv].pt)    /* Get partition# */
 
-#else                        /* Single partition cfg */
 
-#define LD2PD(drv) (drv)        /* Physical drive# is equal to logical drive# */
-#define LD2PT(drv) 0            /* Always mounts the 1st partition */
+/*--------------------------------------------------------------*/
+/* FatFs module application interface                           */
 
+FRESULT f_mount (BYTE, FATFS*);						/* Mount/Unmount a logical drive */
+FRESULT f_open (FIL*, const XCHAR*, BYTE);			/* Open or create a file */
+FRESULT f_read (FIL*, void*, UINT, UINT*);			/* Read data from a file */
+FRESULT f_write (FIL*, const void*, UINT, UINT*);	/* Write data to a file */
+FRESULT f_lseek (FIL*, DWORD);						/* Move file pointer of a file object */
+FRESULT f_close (FIL*);								/* Close an open file object */
+FRESULT f_opendir (DIR*, const XCHAR*);				/* Open an existing directory */
+FRESULT f_readdir (DIR*, FILINFO*);					/* Read a directory item */
+FRESULT f_stat (const XCHAR*, FILINFO*);				/* Get file status */
+FRESULT f_getfree (const XCHAR*, DWORD*, FATFS**);	/* Get number of free clusters on the drive */
+FRESULT f_truncate (FIL*);							/* Truncate file */
+FRESULT f_sync (FIL*);								/* Flush cached data of a writing file */
+FRESULT f_unlink (const XCHAR*);						/* Delete an existing file or directory */
+FRESULT	f_mkdir (const XCHAR*);						/* Create a new directory */
+FRESULT f_chmod (const XCHAR*, BYTE, BYTE);			/* Change attriburte of the file/dir */
+FRESULT f_utime (const XCHAR*, const FILINFO*);		/* Change timestamp of the file/dir */
+FRESULT f_rename (const XCHAR*, const XCHAR*);		/* Rename/Move a file or directory */
+FRESULT f_forward (FIL*, UINT(*)(const BYTE*,UINT), UINT, UINT*);	/* Forward data to the stream */
+FRESULT f_mkfs (BYTE, BYTE, WORD);					/* Create a file system on the drive */
+FRESULT f_chdir (const XCHAR*);						/* Change current directory */
+FRESULT f_chdrive (BYTE);							/* Change current drive */
+
+#if _USE_STRFUNC
+int f_putc (int, FIL*);								/* Put a character to the file */
+int f_puts (const char*, FIL*);						/* Put a string to the file */
+int f_printf (FIL*, const char*, ...);				/* Put a formatted string to the file */
+char* f_gets (char*, int, FIL*);					/* Get a string from the file */
+#define f_eof(fp) (((fp)-&gt;fptr == (fp)-&gt;fsize) ? 1 : 0)
+#define f_error(fp) (((fp)-&gt;flag &amp; FA__ERROR) ? 1 : 0)
+#ifndef EOF
+#define EOF -1
 #endif
+#endif
 
 
-/* File function return code (FRESULT) */
 
-typedef enum {
-    FR_OK = 0,            /* 0 */
-    FR_NOT_READY,        /* 1 */
-    FR_NO_FILE,            /* 2 */
-    FR_NO_PATH,            /* 3 */
-    FR_INVALID_NAME,    /* 4 */
-    FR_INVALID_DRIVE,    /* 5 */
-    FR_DENIED,            /* 6 */
-    FR_EXIST,            /* 7 */
-    FR_RW_ERROR,        /* 8 */
-    FR_WRITE_PROTECTED,    /* 9 */
-    FR_NOT_ENABLED,        /* 10 */
-    FR_NO_FILESYSTEM,    /* 11 */
-    FR_INVALID_OBJECT,    /* 12 */
-    FR_MKFS_ABORTED        /* 13 */
-} FRESULT;
+/*--------------------------------------------------------------*/
+/* User defined functions                                       */
 
+/* Real time clock */
+#if !_FS_READONLY
+DWORD get_fattime (void);	/* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
+							/* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
+#endif
 
+/* Unicode - OEM code conversion */
+#if _USE_LFN
+WCHAR ff_convert (WCHAR, UINT);
+WCHAR ff_wtoupper (WCHAR);
+#endif
 
-/*-----------------------------------------------------*/
-/* FatFs module application interface                  */
+/* Sync functions */
+#if _FS_REENTRANT
+BOOL ff_cre_syncobj(BYTE, _SYNC_t*);
+BOOL ff_del_syncobj(_SYNC_t);
+BOOL ff_req_grant(_SYNC_t);
+void ff_rel_grant(_SYNC_t);
+#endif
 
-FRESULT f_mount (BYTE, FATFS*);                        /* Mount/Unmount a logical drive */
-FRESULT f_open (FIL*, const char*, BYTE);            /* Open or create a file */
-FRESULT f_read (FIL*, void*, WORD, WORD*);            /* Read data from a file */
-FRESULT f_write (FIL*, const void*, WORD, WORD*);    /* Write data to a file */
-FRESULT f_lseek (FIL*, DWORD);                        /* Move file pointer of a file object */
-FRESULT f_close (FIL*);                                /* Close an open file object */
-FRESULT f_opendir (DIR*, const char*);                /* Open an existing directory */
-FRESULT f_readdir (DIR*, FILINFO*);                    /* Read a directory item */
-FRESULT f_stat (const char*, FILINFO*);                /* Get file status */
-FRESULT f_getfree (const char*, DWORD*, FATFS**);    /* Get number of free clusters on the drive */
-FRESULT f_sync (FIL*);                                /* Flush cached data of a writing file */
-FRESULT f_unlink (const char*);                        /* Delete an existing file or directory */
-FRESULT    f_mkdir (const char*);                        /* Create a new directory */
-FRESULT f_chmod (const char*, BYTE, BYTE);            /* Change file/dir attriburte */
-FRESULT f_rename (const char*, const char*);        /* Rename/Move a file or directory */
-FRESULT f_mkfs (BYTE, BYTE, BYTE);                    /* Create a file system on the drive */
 
 
-/* User defined function to give a current time to fatfs module */
+/*--------------------------------------------------------------*/
+/* Flags and offset address                                     */
 
-DWORD get_fattime (void);    /* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
-                            /* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
 
-
-
 /* File access control and file status flags (FIL.flag) */
 
-#define    FA_READ                0x01
-#define    FA_OPEN_EXISTING    0x00
+#define	FA_READ				0x01
+#define	FA_OPEN_EXISTING	0x00
 #if _FS_READONLY == 0
-#define    FA_WRITE            0x02
-#define    FA_CREATE_NEW        0x04
-#define    FA_CREATE_ALWAYS    0x08
-#define    FA_OPEN_ALWAYS        0x10
-#define FA__WRITTEN            0x20
-#define FA__DIRTY            0x40
+#define	FA_WRITE			0x02
+#define	FA_CREATE_NEW		0x04
+#define	FA_CREATE_ALWAYS	0x08
+#define	FA_OPEN_ALWAYS		0x10
+#define FA__WRITTEN			0x20
+#define FA__DIRTY			0x40
 #endif
-#define FA__ERROR            0x80
+#define FA__ERROR			0x80
 
 
 /* FAT sub type (FATFS.fs_type) */
 
-#define FS_FAT12    1
-#define FS_FAT16    2
-#define FS_FAT32    3
+#define FS_FAT12	1
+#define FS_FAT16	2
+#define FS_FAT32	3
 
 
 /* File attribute bits for directory entry */
 
-#define    AM_RDO    0x01    /* Read only */
-#define    AM_HID    0x02    /* Hidden */
-#define    AM_SYS    0x04    /* System */
-#define    AM_VOL    0x08    /* Volume label */
-#define AM_LFN    0x0F    /* LFN entry */
-#define AM_DIR    0x10    /* Directory */
-#define AM_ARC    0x20    /* Archive */
+#define	AM_RDO	0x01	/* Read only */
+#define	AM_HID	0x02	/* Hidden */
+#define	AM_SYS	0x04	/* System */
+#define	AM_VOL	0x08	/* Volume label */
+#define AM_LFN	0x0F	/* LFN entry */
+#define AM_DIR	0x10	/* Directory */
+#define AM_ARC	0x20	/* Archive */
+#define AM_MASK	0x3F	/* Mask of defined bits */
 
 
+/* FatFs refers the members in the FAT structures with byte offset instead
+/ of structure member because there are incompatibility of the packing option
+/ between various compilers. */
 
-/* Offset of FAT structure members */
+#define BS_jmpBoot			0
+#define BS_OEMName			3
+#define BPB_BytsPerSec		11
+#define BPB_SecPerClus		13
+#define BPB_RsvdSecCnt		14
+#define BPB_NumFATs			16
+#define BPB_RootEntCnt		17
+#define BPB_TotSec16		19
+#define BPB_Media			21
+#define BPB_FATSz16			22
+#define BPB_SecPerTrk		24
+#define BPB_NumHeads		26
+#define BPB_HiddSec			28
+#define BPB_TotSec32		32
+#define BS_55AA				510
 
-#define BS_jmpBoot            0
-#define BS_OEMName            3
-#define BPB_BytsPerSec        11
-#define BPB_SecPerClus        13
-#define BPB_RsvdSecCnt        14
-#define BPB_NumFATs            16
-#define BPB_RootEntCnt        17
-#define BPB_TotSec16        19
-#define BPB_Media            21
-#define BPB_FATSz16            22
-#define BPB_SecPerTrk        24
-#define BPB_NumHeads        26
-#define BPB_HiddSec            28
-#define BPB_TotSec32        32
-#define BS_55AA                510
+#define BS_DrvNum			36
+#define BS_BootSig			38
+#define BS_VolID			39
+#define BS_VolLab			43
+#define BS_FilSysType		54
 
-#define BS_DrvNum            36
-#define BS_BootSig            38
-#define BS_VolID            39
-#define BS_VolLab            43
-#define BS_FilSysType        54
+#define BPB_FATSz32			36
+#define BPB_ExtFlags		40
+#define BPB_FSVer			42
+#define BPB_RootClus		44
+#define BPB_FSInfo			48
+#define BPB_BkBootSec		50
+#define BS_DrvNum32			64
+#define BS_BootSig32		66
+#define BS_VolID32			67
+#define BS_VolLab32			71
+#define BS_FilSysType32		82
 
-#define BPB_FATSz32            36
-#define BPB_ExtFlags        40
-#define BPB_FSVer            42
-#define BPB_RootClus        44
-#define BPB_FSInfo            48
-#define BPB_BkBootSec        50
-#define BS_DrvNum32            64
-#define BS_BootSig32        66
-#define BS_VolID32            67
-#define BS_VolLab32            71
-#define BS_FilSysType32        82
+#define	FSI_LeadSig			0
+#define	FSI_StrucSig		484
+#define	FSI_Free_Count		488
+#define	FSI_Nxt_Free		492
 
-#define    FSI_LeadSig            0
-#define    FSI_StrucSig        484
-#define    FSI_Free_Count        488
-#define    FSI_Nxt_Free        492
+#define MBR_Table			446
 
-#define MBR_Table            446
+#define	DIR_Name			0
+#define	DIR_Attr			11
+#define	DIR_NTres			12
+#define	DIR_CrtTime			14
+#define	DIR_CrtDate			16
+#define	DIR_FstClusHI		20
+#define	DIR_WrtTime			22
+#define	DIR_WrtDate			24
+#define	DIR_FstClusLO		26
+#define	DIR_FileSize		28
+#define	LDIR_Ord			0
+#define	LDIR_Attr			11
+#define	LDIR_Type			12
+#define	LDIR_Chksum			13
+#define	LDIR_FstClusLO		26
 
-#define    DIR_Name            0
-#define    DIR_Attr            11
-#define    DIR_NTres            12
-#define    DIR_CrtTime            14
-#define    DIR_CrtDate            16
-#define    DIR_FstClusHI        20
-#define    DIR_WrtTime            22
-#define    DIR_WrtDate            24
-#define    DIR_FstClusLO        26
-#define    DIR_FileSize        28
 
 
-
+/*--------------------------------*/
 /* Multi-byte word access macros  */
 
-#if _MCU_ENDIAN == 1    /* Use word access */
-#define    LD_WORD(ptr)        (WORD)(*(WORD*)(BYTE*)(ptr))
-#define    LD_DWORD(ptr)        (DWORD)(*(DWORD*)(BYTE*)(ptr))
-#define    ST_WORD(ptr,val)    *(WORD*)(BYTE*)(ptr)=(WORD)(val)
-#define    ST_DWORD(ptr,val)    *(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
-#else
-#if _MCU_ENDIAN == 2    /* Use byte-by-byte access */
-#define    LD_WORD(ptr)        (WORD)(((WORD)*(BYTE*)((ptr)+1)&lt;&lt;8)|(WORD)*(BYTE*)(ptr))
-#define    LD_DWORD(ptr)        (DWORD)(((DWORD)*(BYTE*)((ptr)+3)&lt;&lt;24)|((DWORD)*(BYTE*)((ptr)+2)&lt;&lt;16)|((WORD)*(BYTE*)((ptr)+1)&lt;&lt;8)|*(BYTE*)(ptr))
-#define    ST_WORD(ptr,val)    *(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8)
-#define    ST_DWORD(ptr,val)    *(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8); *(BYTE*)((ptr)+2)=(BYTE)((DWORD)(val)&gt;&gt;16); *(BYTE*)((ptr)+3)=(BYTE)((DWORD)(val)&gt;&gt;24)
-#else
-#error Do not forget to set _MCU_ENDIAN properly!
+#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
+#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
+#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
+#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
+#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
+#else					/* Use byte-by-byte access to the FAT structure */
+#define	LD_WORD(ptr)		(WORD)(((WORD)*(BYTE*)((ptr)+1)&lt;&lt;8)|(WORD)*(BYTE*)(ptr))
+#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*(BYTE*)((ptr)+3)&lt;&lt;24)|((DWORD)*(BYTE*)((ptr)+2)&lt;&lt;16)|((WORD)*(BYTE*)((ptr)+1)&lt;&lt;8)|*(BYTE*)(ptr))
+#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8)
+#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *(BYTE*)((ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8); *(BYTE*)((ptr)+2)=(BYTE)((DWORD)(val)&gt;&gt;16); *(BYTE*)((ptr)+3)=(BYTE)((DWORD)(val)&gt;&gt;24)
 #endif
-#endif
 
 
-#define _FATFS
 #endif /* _FATFS */

Modified: branches/eagle_mmc/src/mmcfs.c
===================================================================
--- branches/eagle_mmc/src/mmcfs.c	2009-10-30 17:42:31 UTC (rev 504)
+++ branches/eagle_mmc/src/mmcfs.c	2009-10-30 23:10:23 UTC (rev 505)
@@ -107,7 +107,7 @@
 
 static _ssize_t mmcfs_write_r( struct _reent *r, int fd, const void* ptr, size_t len )
 {
-  WORD bytesWritten;
+  UINT bytesWritten;
 
   if (f_write(mmcfs_fd_table + fd, ptr, len, &amp;bytesWritten) != FR_OK)
   {
@@ -120,7 +120,7 @@
 
 static _ssize_t mmcfs_read_r( struct _reent *r, int fd, void* ptr, size_t len )
 {
-  WORD bytesRead;
+  UINT bytesRead;
 
   if (f_read(mmcfs_fd_table + fd, ptr, len, &amp;bytesRead) != FR_OK)
   {

Modified: branches/eagle_mmc/src/platform/lm3s/mmc.c
===================================================================
--- branches/eagle_mmc/src/platform/lm3s/mmc.c	2009-10-30 17:42:31 UTC (rev 504)
+++ branches/eagle_mmc/src/platform/lm3s/mmc.c	2009-10-30 23:10:23 UTC (rev 505)
@@ -39,6 +39,8 @@
   #define SDC_CS_PORT                3
   #define SDC_CS_PIN                 0
   #define SDC_SPI_NUM                0
+  #define SDC_SPI_PORT               0
+  #define SDC_TX_PIN                 5
 #endif
 
 #ifdef FORLM3S8962
@@ -46,7 +48,8 @@
   #define SDC_CS_PORT                6
   #define SDC_CS_PIN                 0
   #define SDC_SPI_NUM                0
-  
+  #define SDC_SPI_PORT               0
+  #define SDC_TX_PIN                 5
 #endif
 
 #ifdef FORLM3S6918
@@ -54,6 +57,8 @@
   #define SDC_CS_PORT                6
   #define SDC_CS_PIN                 1
   #define SDC_SPI_NUM                0
+  #define SDC_SPI_PORT               0
+  #define SDC_TX_PIN                 5
 #endif
 
 #ifndef SDC_SPI_NUM
@@ -138,7 +143,6 @@
 {
     BYTE res;
 
-
     Timer2 = 50;    /* Wait for ready in timeout of 500ms */
     rcvr_spi();
     do
@@ -160,8 +164,8 @@
     DESELECT();
 
     /* Switch the SSI TX line to a GPIO and drive it high too. */
-    platform_pio_op( 0, ( ( u32 ) 1 &lt;&lt; 5 ), PLATFORM_IO_PIN_DIR_OUTPUT );
-    platform_pio_op( 0, ( ( u32 ) 1 &lt;&lt; 5 ), PLATFORM_IO_PIN_SET );
+    platform_pio_op( SDC_SPI_PORT, ( ( u32 ) 1 &lt;&lt; SDC_TX_PIN ), PLATFORM_IO_PIN_DIR_OUTPUT );
+    platform_pio_op( SDC_SPI_PORT, ( ( u32 ) 1 &lt;&lt; SDC_TX_PIN ), PLATFORM_IO_PIN_SET );
     
     /* Send 10 bytes over the SSI. This causes the clock to wiggle the */
     /* required number of times. */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000460.html">[Elua-svn] r504 - in branches/lpc24xx: . romfs src/platform/lpc24xx
</A></li>
	<LI>Next message: <A HREF="000462.html">[Elua-svn] r506 - in branches/eagle_mmc/src: fatfs platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#461">[ date ]</a>
              <a href="thread.html#461">[ thread ]</a>
              <a href="subject.html#461">[ subject ]</a>
              <a href="author.html#461">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
