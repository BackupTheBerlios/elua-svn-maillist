<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r220 - trunk/doc/en
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r220%20-%20trunk/doc/en&In-Reply-To=%3C200902242223.n1OMNww6017320%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000175.html">
   <LINK REL="Next"  HREF="000177.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r220 - trunk/doc/en</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r220%20-%20trunk/doc/en&In-Reply-To=%3C200902242223.n1OMNww6017320%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r220 - trunk/doc/en">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Tue Feb 24 23:23:58 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000175.html">[Elua-svn] r219 - in trunk: . doc doc/en doc/wb doc/wb_img inc
</A></li>
        <LI>Next message: <A HREF="000177.html">[Elua-svn] r221 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#176">[ date ]</a>
              <a href="thread.html#176">[ thread ]</a>
              <a href="subject.html#176">[ subject ]</a>
              <a href="author.html#176">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-02-24 23:23:58 +0100 (Tue, 24 Feb 2009)
New Revision: 220

Modified:
   trunk/doc/en/refman.html
Log:
Updated notes on adc functions.

Modified: trunk/doc/en/refman.html
===================================================================
--- trunk/doc/en/refman.html	2009-02-24 22:09:22 UTC (rev 219)
+++ trunk/doc/en/refman.html	2009-02-24 22:23:58 UTC (rev 220)
@@ -1,13 +1,10 @@
 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;
-&lt;html&gt;
-	&lt;head&gt;
+&lt;html&gt;&lt;head&gt;
 		&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
 		&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en-us&quot;&gt;
-		&lt;title&gt;
-			Product
-		&lt;/title&gt;
-		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;
-	&lt;/head&gt;
+		
+		&lt;title&gt;Product&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../style.css&quot;&gt;&lt;/head&gt;
+
 	&lt;body&gt;
 		&lt;h3&gt;
 			eLua Modules Reference Manual
@@ -232,8 +229,12 @@
 			Some notes on PIO:
 		&lt;/p&gt;
 		&lt;ul&gt;
-			&lt;li&gt;pio: only some platform have internal pullups for the pio pins, while Cortex is the only platform that also provides pulldowns for its pios. However, in this case you're safe, as eLua will signal an error if you try to execute a pullup operatin on a platform that does not support it.
-			&lt;/li&gt;
+			&lt;li&gt;pio:
+only some platform have internal pullups for the pio pins, while Cortex
+is the only platform that also provides pulldowns for its pios.
+However, in this case you're safe, as eLua will signal an error if you
+try to execute a pullup operatin on a platform that does not support
+it. &lt;/li&gt;
 		&lt;/ul&gt;
 		&lt;p&gt;
 			&lt;br&gt;
@@ -275,8 +276,10 @@
 			returns their values.
 		&lt;/p&gt;
 		&lt;p&gt;
-			&lt;a name=&quot;gpio_getportname&quot; id=&quot;gpio_getportname&quot;&gt;&lt;/a&gt; [pio.getportname] Port = pio.port( code ): return the physical port number associated with the given code. For example, &quot;pio.port( pio.P0_20 )&quot; will return 0.
-		&lt;/p&gt;
+			&lt;a name=&quot;gpio_getportname&quot; id=&quot;gpio_getportname&quot;&gt;&lt;/a&gt;
+[pio.getportname] Port = pio.port( code ): return the physical port
+number associated with the given code. For example, &quot;pio.port(
+pio.P0_20 )&quot; will return 0. &lt;/p&gt;
 		&lt;p&gt;
 			&lt;a name=&quot;gpio_getpinnumber&quot; id=&quot;gpio_getpinnumber&quot;&gt;&lt;/a&gt; [pio.getpinnumber] Pin = pio.pin( code ): return the physical pin number associated with the
 		&lt;/p&gt;
@@ -297,21 +300,22 @@
 			&lt;br&gt;
 		&lt;/p&gt;
 		&lt;p&gt;
-			[pio.configport(pio.DIR, pio.DIR_INPUT, [Port1], [Port2], ...)] pio.port_input( Port1, Port2, ... ): set the specified port(s) as input(s).
-		&lt;/p&gt;
+[pio.configport(pio.DIR, pio.DIR_INPUT, [Port1], [Port2], ...)]
+pio.port_input( Port1, Port2, ... ): set the specified port(s) as
+input(s). &lt;/p&gt;
+		&lt;p&gt; [pio.configport(pio.DIR, pio.DIR_OUTPUT, [Port1],
+[Port2], ...)] pio.port_output( Port1, Port2, ... ): set the specified
+port(s) as output(s). &lt;/p&gt;
+		&lt;p&gt; [pio.configpin(pio.PULL, pio.PULL_UP, [Pin1], [Pin2],
+...)] pio.pullup( Pin1, Pin2, ... ): enable internal pullups on the
+specified pins.Note that some CPUs might not provide this feature. &lt;/p&gt;
+		&lt;p&gt; [pio.configpin(pio.PULL, pio.PULL_DOWN, [Pin1], [Pin2],
+...)] pio.pulldown( Pin1, Pin2, ... ): enable internal pulldowns on the
+specified pins. Note that some CPUs might not provide this feature. &lt;/p&gt;
+		&lt;p&gt; [pio.configpin(pio.PULL, pio.PULL_NO, [Pin1], [Pin2],
+...)] pio.nopull( Pin1, Pin2, ... ): disable the pullups/pulldowns on
+the specifiedpins. Note that some CPUs might not provide this feature. &lt;/p&gt;
 		&lt;p&gt;
-			[pio.configport(pio.DIR, pio.DIR_OUTPUT, [Port1], [Port2], ...)] pio.port_output( Port1, Port2, ... ): set the specified port(s) as output(s).
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configpin(pio.PULL, pio.PULL_UP, [Pin1], [Pin2], ...)] pio.pullup( Pin1, Pin2, ... ): enable internal pullups on the specified pins.Note that some CPUs might not provide this feature.
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configpin(pio.PULL, pio.PULL_DOWN, [Pin1], [Pin2], ...)] pio.pulldown( Pin1, Pin2, ... ): enable internal pulldowns on the specified pins. Note that some CPUs might not provide this feature.
-		&lt;/p&gt;
-		&lt;p&gt;
-			[pio.configpin(pio.PULL, pio.PULL_NO, [Pin1], [Pin2], ...)] pio.nopull( Pin1, Pin2, ... ): disable the pullups/pulldowns on the specifiedpins. Note that some CPUs might not provide this feature.
-		&lt;/p&gt;
-		&lt;p&gt;
 			&lt;br&gt;
 		&lt;/p&gt;
 		&lt;h3&gt;
@@ -330,8 +334,12 @@
 			It allows Lua to use the PWM blocks on the target CPU.
 		&lt;/p&gt;
 		&lt;p&gt;
-			&lt;strike&gt;&lt;a name=&quot;pwm_setup&quot; id=&quot;pwm_setup&quot;&gt;&lt;/a&gt;[pwm.setup]&lt;/strike&gt;(pwm.setup( id, frequency, Active Cycle ) Data = pwm.setup( id, frequency, duty ): sets the PWM block 'id' to generate the specified frequency with the specified duty cycle (duty is an integer number from 0 to 100, specifying the duty cycle in percents). It returns the actual frequency set on the PWM block.
-		&lt;/p&gt;
+			&lt;strike&gt;&lt;a name=&quot;pwm_setup&quot; id=&quot;pwm_setup&quot;&gt;&lt;/a&gt;[pwm.setup]&lt;/strike&gt;(pwm.setup(
+id, frequency, Active Cycle ) Data = pwm.setup( id, frequency, duty ):
+sets the PWM block 'id' to generate the specified frequency with the
+specified duty cycle (duty is an integer number from 0 to 100,
+specifying the duty cycle in percents). It returns the actual frequency
+set on the PWM block. &lt;/p&gt;
 		&lt;p&gt;
 			Here there is a bigger change on the proposal.
 		&lt;/p&gt;
@@ -373,7 +381,7 @@
 		&lt;/h3&gt;
 		&lt;p&gt;
 			&lt;br&gt;
-			&lt;big&gt;Actual_clock = spi.setup( id, spi.MASTER | spi.SLAVE, clock, cpol, cpha,&lt;br&gt;
+			Actual_clock = spi.setup( id, spi.MASTER | spi.SLAVE, clock, cpol, cpha,&lt;br&gt;
 			databits): set the SPI interface with the given parameters, returns the clock&lt;br&gt;
 			that was set for the interface.&lt;br&gt;
 			&lt;br&gt;
@@ -384,14 +392,20 @@
 			&lt;a name=&quot;spi_send&quot; id=&quot;spi_send&quot;&gt;&lt;/a&gt;spi.send( id, Data1, Data2, ... ): sends all the data to the specified SPI&lt;br&gt;
 			interface.&lt;br&gt;
 			&lt;br&gt;
-			&lt;a name=&quot;spi_sendrecv&quot; id=&quot;spi_sendrecv&quot;&gt;&lt;/a&gt;[spi.sendrecv(id, Out1, Out2, ...)] In1, In2, ... = spi.send_recv( id, Out1, Out2, ... ): sends all the &quot;out&quot; bytes to the specified SPI interface and returts the data read after each sent byte.&lt;br&gt;
+			&lt;a name=&quot;spi_sendrecv&quot; id=&quot;spi_sendrecv&quot;&gt;&lt;/a&gt;[spi.sendrecv(id,
+Out1, Out2, ...)] In1, In2, ... = spi.send_recv( id, Out1, Out2, ... ):
+sends all the &quot;out&quot; bytes to the specified SPI interface and returts
+the data read after each sent byte.&lt;br&gt;
+			&lt;br&gt; Returning several
+values in this blocking way would not complicate some queued send
+implementations ? (ok, this could be another function :)&lt;br&gt;
 			&lt;br&gt;
-			Returning several values in this blocking way would not complicate some queued send implementations ? (ok, this could be another function :)&lt;br&gt;
+Sending multiple data/chars in a single call and not in a table
+argument does not allow the data to be built in run time (without some
+string massage, of course :)&lt;br&gt;
 			&lt;br&gt;
-			Sending multiple data/chars in a single call and not in a table argument does not allow the data to be built in run time (without some string massage, of course :)&lt;br&gt;
 			&lt;br&gt;
 			&lt;br&gt;
-			&lt;br&gt;&lt;/big&gt;
 		&lt;/p&gt;
 		&lt;h3&gt;
 			&lt;a name=&quot;sysmodule&quot; id=&quot;sysmodule&quot;&gt;&lt;/a&gt;sys
@@ -488,12 +502,29 @@
 			Some notes on timers:
 		&lt;/p&gt;
 		&lt;ul&gt;
-			&lt;li&gt;timers: from all the platforms on which eLua runs, only the Luminary Cortex CPUs has rock solid 32-bit timers. You can do pretty much everything you need with them. All the other platforms have 16-bit timers, which imposes some limits on the range of delays you can achieve with them. Make sure to use tmr.mindelay(id) and tmr.maxdelay(id) to check the actual resolution of your timers, and adapt your code accordingly. To 'compensate' for this, it's not possible to change the base timer frequency on the Cortex CPUs, but it is possible on most other platforms :) So be sure to also check the result of tmr.setclock(id)
-			&lt;/li&gt;
-			&lt;li&gt;also, when using timers, remember that if you're using XMODEM and/or the &quot;term&quot; module, TMR0 is used by both of them. So, if you change the TMR0 base clock in your code, be sure to restore the original setting before returning to the shell. You can change this static timer assignment by modifying src/main.c. It might also be possible to change it dynamically in the future, although I see little use for this.
-			&lt;/li&gt;
-			&lt;li&gt;PWM: the Cortex CPUs have 6 PWM channels, but channels 0/1, 2/3 and 4/5 respectively share the same base clock setting. So, when you're changing the base clock for channel 1, you're also changing the base clock for channel 0; if channel 0 was already running, you won't like what will happen next. This time no eLua function can save you, you simply need you know your CPU architecture.
-			&lt;/li&gt;
+			&lt;li&gt;timers:
+from all the platforms on which eLua runs, only the Luminary Cortex
+CPUs has rock solid 32-bit timers. You can do pretty much everything
+you need with them. All the other platforms have 16-bit timers, which
+imposes some limits on the range of delays you can achieve with them.
+Make sure to use tmr.mindelay(id) and tmr.maxdelay(id) to check the
+actual resolution of your timers, and adapt your code accordingly. To
+'compensate' for this, it's not possible to change the base timer
+frequency on the Cortex CPUs, but it is possible on most other
+platforms :) So be sure to also check the result of tmr.setclock(id) &lt;/li&gt;
+			&lt;li&gt;also, when using timers, remember that if you're
+using XMODEM and/or the &quot;term&quot; module, TMR0 is used by both of them.
+So, if you change the TMR0 base clock in your code, be sure to restore
+the original setting before returning to the shell. You can change this
+static timer assignment by modifying src/main.c. It might also be
+possible to change it dynamically in the future, although I see little
+use for this. &lt;/li&gt;
+			&lt;li&gt;PWM: the Cortex CPUs have 6 PWM channels, but
+channels 0/1, 2/3 and 4/5 respectively share the same base clock
+setting. So, when you're changing the base clock for channel 1, you're
+also changing the base clock for channel 0; if channel 0 was already
+running, you won't like what will happen next. This time no eLua
+function can save you, you simply need you know your CPU architecture. &lt;/li&gt;
 		&lt;/ul&gt;
 		&lt;p&gt;
 			&lt;a name=&quot;tmr_delay&quot; id=&quot;tmr_delay&quot;&gt;&lt;/a&gt;tmr.delay( id, delay ): uses timer 'id' to wait for 'delay' us.
@@ -581,7 +612,9 @@
 		&lt;/h2&gt;
 		&lt;p&gt;
 			A Platform Dependent eLua Module is a module that runs only on one or on a few &lt;a href=&quot;status.html#platforms&quot;&gt;supported eLua platforms&lt;/a&gt;.&lt;br&gt;
-			These modules make use of specifical devices and features offered by some kits and allow eLua aplications to make the best use of the external hardware on your platforms.&lt;br&gt;
+These modules make use of specifical devices and features offered by
+some kits and allow eLua aplications to make the best use of the
+external hardware on your platforms.&lt;br&gt;
 		&lt;/p&gt;
 		&lt;h3&gt;
 			&lt;a name=&quot;adcmodule&quot; id=&quot;adcmodule&quot;&gt;&lt;/a&gt;adc - Analog to Digital Conversion Module
@@ -591,41 +624,15 @@
 			&lt;br&gt;
 			The ADC module handles the Analog to Digital Conversion Peripherals.&lt;br&gt;
 			&lt;br&gt;
+			&lt;a name=&quot;adc_sample&quot; id=&quot;adc_sample&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.sample(channel_id, count)&lt;/strong&gt;&lt;br&gt;Request that &lt;em&gt;count&lt;/em&gt; samples be converted from &lt;em&gt;channel_id&lt;/em&gt;. &lt;em&gt;count&lt;/em&gt; must be greater than zero and a power of 2&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_flush&quot; id=&quot;adc_getsamples&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.flush(channel_id)&lt;/strong&gt;&lt;br&gt;Empty sample and smoothing buffers.&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_getsample&quot; id=&quot;adc_getsamples&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.getsample(channel_id)&lt;/strong&gt;&lt;br&gt;
+			Request a single sample from the buffer.&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;a name=&quot;adc_getsamples&quot; id=&quot;adc_getsamples&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.getsamples(channel_id, [count])&lt;/strong&gt;&lt;br&gt;Request &lt;em&gt;count&lt;/em&gt; samples from the buffer, in a table. If &lt;em&gt;count&lt;/em&gt; is either zero or omitted, all available samples are returned.&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_maxval&quot; id=&quot;adc_maxval&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.maxval(channel_id)&lt;/strong&gt;&lt;br&gt;Returns the largest integer one can expect fromr this channel on a given platform (based on bit depth).&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_setclock&quot; id=&quot;adc_maxval&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setclock(channel_id, frequency, [timer_id])&lt;/strong&gt;&lt;br&gt;Sets the frequency and clock source for sample collection. If &lt;span style=&quot;font-style: italic;&quot;&gt;frequency&lt;/span&gt; is zero (timer_id not needed), samples on &lt;span style=&quot;font-style: italic;&quot;&gt;channel_id&lt;/span&gt; are collected as fast as possible. &nbsp;If &lt;span style=&quot;font-style: italic;&quot;&gt;frequency&lt;/span&gt; is non-zero,&lt;span style=&quot;font-style: italic;&quot;&gt; timer_id&lt;/span&gt; is conf!
 igured to trigger sampling on &lt;span style=&quot;font-style: italic;&quot;&gt;channel_id&lt;/span&gt; at &lt;span style=&quot;font-style: italic;&quot;&gt;frequency.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_samplesready&quot; id=&quot;adc_samplesready&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.samplesready(channel_id)&lt;/strong&gt;&lt;br&gt;Returns the number of samples waiting in the buffer.&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_setfreerunning&quot; id=&quot;adc_samplesready&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setfreerunning(channel_id, mode)&lt;/strong&gt;&lt;br&gt;&lt;span style=&quot;font-style: italic;&quot;&gt;&lt;span style=&quot;font-style: italic;&quot;&gt;mode&lt;/span&gt;&lt;/span&gt; 0 disables freerunning mode (default), &lt;span style=&quot;font-style: italic;&quot;&gt;&lt;span style=&quot;font-style: italic;&quot;&gt;mode&lt;/span&gt;&lt;/span&gt;
+1 enables freerunning mode. &nbsp;If enabled and samples are requested,
+sampling will continue after the buffer fills, replacing the oldest
+sample each time a new sample is taken.&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_setmode&quot; id=&quot;adc_setmode&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setblocking(channel_id, mode)&lt;br&gt;&lt;/strong&gt; &lt;em style=&quot;font-style: italic;&quot;&gt;mode&lt;/em&gt; 1 sets blocking mode (default). adc.getsample(s) will wait for requested samples to be captured before returning.&lt;em&gt; mode&lt;/em&gt; 0 sets non-blocking mode&lt;br&gt;
 			&lt;br&gt;
-			&lt;a name=&quot;adc_sample&quot; id=&quot;adc_sample&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.sample(channel_id)&lt;/strong&gt;&lt;br&gt;
-			Generate one processed sample.&lt;br&gt;
+			&lt;a name=&quot;adc_setsmoothing&quot; id=&quot;adc_setsmoothing&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setsmoothing(channel_id, length)&lt;br&gt;&lt;/strong&gt; Set the &lt;span style=&quot;font-style: italic;&quot;&gt;length&lt;/span&gt; of the smoothing filter on &lt;span style=&quot;font-style: italic;&quot;&gt;channel_id&lt;/span&gt;. &nbsp;When greater than 1, and samples are requested, smoothing filter will fill to &lt;span style=&quot;font-style: italic;&quot;&gt;length&lt;/span&gt; with samples, and then put the requested number of samples into the adc buffer.&lt;br&gt;
+			&lt;span style=&quot;font-style: italic;&quot;&gt;length&lt;/span&gt; must be a power of 2 (maximum = 64)&lt;/p&gt;&lt;p&gt;&lt;a name=&quot;adc_getsmoothing&quot; id=&quot;adc_getsmoothing&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.getsmoothing(channel_id)&lt;br&gt;&lt;/strong&gt; Get the current smoothing length in use.&lt;br&gt;
 			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_getsamples&quot; id=&quot;adc_getsamples&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.getsamples(channel_id, [count])&lt;/strong&gt;&lt;br&gt;
-			Request &lt;em&gt;count&lt;/em&gt; samples from the buffer.&lt;br&gt;
-			if singular, an integer is returned. if multiple, a table of integers is returned. If &lt;em&gt;count&lt;/em&gt; is either zero or omitted, all available samples are returned.&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_maxval&quot; id=&quot;adc_maxval&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.maxval(channel_id)&lt;/strong&gt;&lt;br&gt;
-			Returns the largest integer one can expect fromr this channel on a given platform (based on bit depth).&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_samplesready&quot; id=&quot;adc_samplesready&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.samplesready(channel_id)&lt;br&gt;&lt;/strong&gt; Returns the number of samples waiting in the buffer.&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_dataready&quot; id=&quot;adc_dataready&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.dataready(channel_id)&lt;br&gt;&lt;/strong&gt; If running in non-blocking mode, this will indicate if all of the samples requested from the last sample or&lt;br&gt;
-			burst have been acquired and are waiting in the buffer.&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_setmode&quot; id=&quot;adc_setmode&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setmode(channel_id, mode)&lt;br&gt;&lt;/strong&gt; &lt;em&gt;mode&lt;/em&gt; 0 sets blocking mode. adc.getsamples will wait for requested samples to be captured before returning.&lt;br&gt;
-			&lt;em&gt;mode&lt;/em&gt; 1 sets non-blocking mode&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_setsmoothing&quot; id=&quot;adc_setsmoothing&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.setsmoothing(channel_id, length)&lt;br&gt;&lt;/strong&gt; Set the length of the smoothing filter.&lt;br&gt;
-			This must be a power of 2 (maximum = 128)&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_getsmoothing&quot; id=&quot;adc_getsmoothing&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.getsmoothing(channel_id)&lt;br&gt;&lt;/strong&gt; Get the current smoothing length in use.&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
-			&lt;a name=&quot;adc_burst&quot; id=&quot;adc_burst&quot;&gt;&lt;/a&gt;&lt;strong&gt;adc.burst( channel_id, count, timer_id, frequency)&lt;br&gt;&lt;/strong&gt; Request that &lt;em&gt;count&lt;/em&gt; samples be converted from &lt;em&gt;channel_id&lt;/em&gt;, using &lt;em&gt;timer_id&lt;/em&gt; at &lt;em&gt;frequency.&lt;/em&gt; &lt;em&gt;count&lt;/em&gt; must be greater than zero and a power of 2&lt;br&gt;
-			&lt;br&gt;
-			&lt;br&gt;
 		&lt;/p&gt;
 		&lt;h3&gt;
 			&lt;a name=&quot;dispmodule&quot; id=&quot;dispmodule&quot;&gt;&lt;/a&gt;disp
@@ -672,7 +679,10 @@
 		&lt;/p&gt;
 		&lt;p&gt;
 			Turns off the OLED display&lt;br&gt;
-			This function will turn off the OLED display. This will stop the scanning of the panel and turn off the on-chip DC-DC converter, preventing damage to the panel due to burn-in (it has similar characters to a CRT in this respect).&lt;br&gt;
+This function will turn off the OLED display. This will stop the
+scanning of the panel and turn off the on-chip DC-DC converter,
+preventing damage to the panel due to burn-in (it has similar
+characters to a CRT in this respect).&lt;br&gt;
 			&lt;br&gt;
 		&lt;/p&gt;
 		&lt;p&gt;
@@ -693,8 +703,15 @@
 			y is the vertical position to display the string, specified in rows from the top edge of the display.&lt;br&gt;
 			gray is the 4-bit gray scale (intensity) value to be used for displayed text.&lt;br&gt;
 			&lt;br&gt;
-			This function will draw a string on the display. Only the ASCII characters between 32 (space) and 126 (tilde) are supported; other characters will result in random data being draw on the display (based on whatever appears before/after the font in memory). The font is mono-spaced, so characters such as ``i'' and ``l'' have more white space around them than characters such as ``m'' or ``w''.&lt;br&gt;
-			If the drawing of the string reaches the right edge of the display, no more characters will be drawn. Therefore, special care is not required to avoid supplying a string that is ``too long'' to display.&lt;br&gt;
+This function will draw a string on the display. Only the ASCII
+characters between 32 (space) and 126 (tilde) are supported; other
+characters will result in random data being draw on the display (based
+on whatever appears before/after the font in memory). The font is
+mono-spaced, so characters such as ``i'' and ``l'' have more white
+space around them than characters such as ``m'' or ``w''.&lt;br&gt;
+If the drawing of the string reaches the right edge of the display, no
+more characters will be drawn. Therefore, special care is not required
+to avoid supplying a string that is ``too long'' to display.&lt;br&gt;
 			&lt;br&gt;
 			Because the OLED display packs 2 pixels of data in a single byte, the&lt;br&gt;
 			parameter \e ulX must be an even column number (for example, 0, 2, 4, and&lt;br&gt;
@@ -714,42 +731,20 @@
 			width is the width of the image, specified in columns.&lt;br&gt;
 			height is the height of the image, specified in rows.&lt;br&gt;
 			&lt;br&gt;
-			This function will display a bitmap graphic on the display. Because of the format of the display RAM, the starting column x and the number of columns y must be an integer multiple of two.&lt;br&gt;
-			The image data is organized with the first row of image data appearing left to right, followed immediately by the second row of image data. Each byte contains the data for two columns in the current row, with the leftmost column being contained in bits 7:4 and the rightmost column being contained in bits 3:0.&lt;br&gt;
-			For example, an image six columns wide and seven scan lines tall would be arranged as follows (showing how the twenty one bytes of the image would appear on the display):&lt;br&gt;
+This function will display a bitmap graphic on the display. Because of
+the format of the display RAM, the starting column x and the number of
+columns y must be an integer multiple of two.&lt;br&gt;
+The image data is organized with the first row of image data appearing
+left to right, followed immediately by the second row of image data.
+Each byte contains the data for two columns in the current row, with
+the leftmost column being contained in bits 7:4 and the rightmost
+column being contained in bits 3:0.&lt;br&gt;
+For example, an image six columns wide and seven scan lines tall would
+be arranged as follows (showing how the twenty one bytes of the image
+would appear on the display):&lt;br&gt;
 			&lt;br&gt;
-			Because the OLED display packs 2 pixels of data in a single byte, the parameter x must be an even column number (for example, 0, 2, 4, and so on).
-		&lt;/p&gt;
-		&lt;pre&gt;
-+-------------------+-------------------+-------------------+
-|      Byte 0       |      Byte 1       |      Byte 2       |
-+---------+---------+---------+---------+---------+---------+
-| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
-+---------+---------+---------+---------+---------+---------+
-|      Byte 3       |      Byte 4       |      Byte 5       |
-+---------+---------+---------+---------+---------+---------+
-| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
-+---------+---------+---------+---------+---------+---------+
-|      Byte 6       |      Byte 7       |      Byte 8       |
-+---------+---------+---------+---------+---------+---------+
-| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
-+---------+---------+---------+---------+---------+---------+
-|      Byte 9       |      Byte 10      |      Byte 11      |
-+---------+---------+---------+---------+---------+---------+
-| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
-+---------+---------+---------+---------+---------+---------+
-|      Byte 12      |      Byte 13      |      Byte 14      |
-+---------+---------+---------+---------+---------+---------+
-| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
-+---------+---------+---------+---------+---------+---------+
-|      Byte 15      |      Byte 16      |      Byte 17      |
-+---------+---------+---------+---------+---------+---------+
-| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
-+---------+---------+---------+---------+---------+---------+
-|      Byte 18      |      Byte 19      |      Byte 20      |
-+---------+---------+---------+---------+---------+---------+
-| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |
-+---------+---------+---------+---------+---------+---------+
-&lt;/pre&gt;
-	&lt;/body&gt;
-&lt;/html&gt;
+Because the OLED display packs 2 pixels of data in a single byte, the
+parameter x must be an even column number (for example, 0, 2, 4, and so
+on). &lt;/p&gt;
+		&lt;pre&gt;+-------------------+-------------------+-------------------+&lt;br&gt;|      Byte 0       |      Byte 1       |      Byte 2       |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 3       |      Byte 4       |      Byte 5       |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 6       |      Byte 7       |      Byte 8       |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 9       |      Byte 10      |      Byte 11      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 !
 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 12      |      Byte 13      |      Byte 14      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 15      |      Byte 16      |      Byte 17      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;|      Byte 18      |      Byte 19      |      Byte 20      |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;| 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 | 7 6 5 4 | 3 2 1 0 |&lt;br&gt;+---------+---------+---------+---------+---------+---------+&lt;br&gt;&lt;/pre&gt;
+	&lt;/body&gt;&lt;/html&gt;
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000175.html">[Elua-svn] r219 - in trunk: . doc doc/en doc/wb doc/wb_img inc
</A></li>
	<LI>Next message: <A HREF="000177.html">[Elua-svn] r221 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#176">[ date ]</a>
              <a href="thread.html#176">[ thread ]</a>
              <a href="subject.html#176">[ subject ]</a>
              <a href="author.html#176">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
