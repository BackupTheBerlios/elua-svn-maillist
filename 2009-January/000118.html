<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r162 - in trunk: . inc src src/lua src/modules	src/newlib src/platform/at91sam7x src/platform/avr32	src/platform/i386 src/platform/lm3s src/platform/lpc288x	src/platform/stm32 src/platform/str7 src/platform/str9
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r162%20-%20in%20trunk%3A%20.%20inc%20src%20src/lua%20src/modules%0A%09src/newlib%20src/platform/at91sam7x%20src/platform/avr32%0A%09src/platform/i386%20src/platform/lm3s%20src/platform/lpc288x%0A%09src/platform/stm32%20src/platform/str7%20src/platform/str9&In-Reply-To=%3C200901221946.n0MJkq2g004364%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000117.html">
   <LINK REL="Next"  HREF="000119.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r162 - in trunk: . inc src src/lua src/modules	src/newlib src/platform/at91sam7x src/platform/avr32	src/platform/i386 src/platform/lm3s src/platform/lpc288x	src/platform/stm32 src/platform/str7 src/platform/str9</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r162%20-%20in%20trunk%3A%20.%20inc%20src%20src/lua%20src/modules%0A%09src/newlib%20src/platform/at91sam7x%20src/platform/avr32%0A%09src/platform/i386%20src/platform/lm3s%20src/platform/lpc288x%0A%09src/platform/stm32%20src/platform/str7%20src/platform/str9&In-Reply-To=%3C200901221946.n0MJkq2g004364%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r162 - in trunk: . inc src src/lua src/modules	src/newlib src/platform/at91sam7x src/platform/avr32	src/platform/i386 src/platform/lm3s src/platform/lpc288x	src/platform/stm32 src/platform/str7 src/platform/str9">bogdanm at mail.berlios.de
       </A><BR>
    <I>Thu Jan 22 20:46:52 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000117.html">[Elua-svn] r161 - trunk/src/platform/lm3s
</A></li>
        <LI>Next message: <A HREF="000119.html">[Elua-svn] r163 - trunk/src/platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#118">[ date ]</a>
              <a href="thread.html#118">[ thread ]</a>
              <a href="subject.html#118">[ subject ]</a>
              <a href="author.html#118">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2009-01-22 20:46:47 +0100 (Thu, 22 Jan 2009)
New Revision: 162

Added:
   trunk/inc/buf.h
   trunk/src/buf.c
   trunk/src/platform/avr32/mt48lc16m16a2tg7e.h
   trunk/src/platform/avr32/sdramc.c
   trunk/src/platform/avr32/sdramc.h
   trunk/src/platform/str9/91x_it.h
   trunk/src/platform/str9/91x_vic.c
   trunk/src/platform/str9/91x_vic.h
   trunk/src/platform/str9/interrupt.c
Modified:
   trunk/SConstruct
   trunk/inc/dlmalloc.h
   trunk/inc/platform.h
   trunk/inc/xmodem.h
   trunk/src/common.c
   trunk/src/lua/lparser.c
   trunk/src/lua/lstrlib.c
   trunk/src/modules/uart.c
   trunk/src/newlib/stubs.c
   trunk/src/platform/at91sam7x/platform.c
   trunk/src/platform/at91sam7x/platform_conf.h
   trunk/src/platform/at91sam7x/stacks.h
   trunk/src/platform/avr32/conf.py
   trunk/src/platform/avr32/evk1100.h
   trunk/src/platform/avr32/platform.c
   trunk/src/platform/avr32/platform_conf.h
   trunk/src/platform/avr32/stacks.h
   trunk/src/platform/i386/platform.c
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/stacks.h
   trunk/src/platform/lpc288x/platform.c
   trunk/src/platform/lpc288x/stacks.h
   trunk/src/platform/stm32/platform.c
   trunk/src/platform/stm32/stm32.ld
   trunk/src/platform/str7/platform.c
   trunk/src/platform/str7/stacks.h
   trunk/src/platform/str9/conf.py
   trunk/src/platform/str9/platform.c
   trunk/src/platform/str9/platform_conf.h
   trunk/src/platform/str9/stacks.h
   trunk/src/platform/str9/startup912.s
   trunk/src/shell.c
   trunk/src/xmodem.c
Log:
- lua parsing: lparser.c was modified to allocate some of its structures to
  the heap instead of the stack. Also, the stack size was bumped to at least
  2048 bytes on all backends. Hopefully this will take care of most issues
  related to stack overflows.

- new buffering system available. Originally I planned to make it fully
  generic, but I came to the conclusions that this would take too much
  development work and system resources (RAM/Flash) if done properly, so
  currently it's only used on UART RX (although it could be easily extended
  for other peripherals). For an example of use check the AT91SAM7X and
  AVR32 backend (platform_init and associated interrupt handlers and also
  platform_conf.h).

- new XMODEM implementation. Better, cleaner, bug fixed, and BSD instead of
  GPL.

- AVR32 can use the huge (32MBytes) SDRAM on the board as system memory now.

- fixed an error in elua_sbrk/_sbrk_r (and revised the compilation options
  for dlmalloc).

- added the CPU module and interrupt support on the STR9 platform.

- uart module changes: 'sendstr' is out, but the regular 'send' will send
  strings instead of simple chars (which makes sense since Lua doesn't have
  a &quot;char&quot; type). Also, the 'timer_id' and 'timout' parameters of the 'recv'
  function are now optional.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/SConstruct	2009-01-22 19:46:47 UTC (rev 162)
@@ -107,7 +107,7 @@
 
 # CPU/allocator mapping (if allocator not specified)
 if allocator == '':
-  if cputype == 'LPC2888':
+  if boardname == 'LPC-H2888' or boardname == 'ATEVK1100':
     allocator = 'multiple'
   else:
     allocator = 'newlib'
@@ -154,7 +154,7 @@
 local_libs = ''
 
 # Application files
-app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/dlmalloc.c src/common.c &quot;
+app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/dlmalloc.c src/common.c src/buf.c &quot;
 
 # Newlib related files
 newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c src/newlib/stdtcp.c&quot;

Added: trunk/inc/buf.h
===================================================================
--- trunk/inc/buf.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/inc/buf.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,54 @@
+// eLua &quot;char device&quot; buffering system
+
+#ifndef __BUF_H__
+#define __BUF_H__
+
+#include &quot;type.h&quot;
+
+// [TODO] the buffer data type is currently u8, is this OK?
+typedef u8 t_buf_data;
+
+// IDs of &quot;bufferable&quot; devices
+enum
+{
+  BUF_ID_UART = 0,
+  BUF_ID_FIRST = BUF_ID_UART,
+  BUF_ID_LAST = BUF_ID_UART,
+  BUF_ID_TOTAL = BUF_ID_LAST - BUF_ID_FIRST + 1
+};
+
+// This structure describes a buffer
+typedef struct 
+{
+  u8 logsize;
+  volatile u16 wptr, rptr, count;
+  t_buf_data *buf;
+} buf_desc;
+
+// Buffer sizes (there are power of 2 to speed up modulo operations)
+enum
+{
+  BUF_SIZE_NONE = 0,
+  BUF_SIZE_16 = 4,
+  BUF_SIZE_32,
+  BUF_SIZE_64,
+  BUF_SIZE_128,
+  BUF_SIZE_256,
+  BUF_SIZE_512,
+  BUF_SIZE_1024,
+  BUF_SIZE_2048,
+  BUF_SIZE_4096,
+  BUF_SIZE_8192,
+  BUF_SIZE_16384,
+  BUF_SIZE_32768
+};
+
+// Buffer API
+int buf_set( unsigned resid, unsigned resnum, u8 logsize );
+int buf_is_enabled( unsigned resid, unsigned resnum );
+unsigned buf_get_size( unsigned resid, unsigned resnum );
+unsigned buf_get_count( unsigned resid, unsigned resnum );
+int buf_get_char( unsigned resid, unsigned resnum );
+void buf_rx_cb( unsigned resid, unsigned resnum, t_buf_data data );
+
+#endif

Modified: trunk/inc/dlmalloc.h
===================================================================
--- trunk/inc/dlmalloc.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/inc/dlmalloc.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -5,16 +5,18 @@
 
 #include &lt;unistd.h&gt;
 extern void* elua_sbrk( ptrdiff_t incr );
-#define MORECORE                  elua_sbrk 
+#define MORECORE                  elua_sbrk  
 #define USE_DL_PREFIX 
-#define HAVE_MORECORE             1 
-#define MORECORE_CONTIGUOUS       1 
+#define MSPACES                   0
+#define HAVE_MORECORE             1
+#define MORECORE_CONTIGUOUS       1
 #define MORECORE_CANNOT_TRIM 
 #define HAVE_MMAP                 0 
 #define HAVE_MREMAP               0 
 #define MMAP_CLEARS               0 
 #define DEFAULT_GRANULARITY       256 
 #define malloc_getpagesize        256
+#define REALLOC_ZERO_BYTES_FREES
 
 /*
   This is a version (aka dlmalloc) of malloc/free/realloc written by

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/inc/platform.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -116,8 +116,8 @@
 int platform_uart_exists( unsigned id );
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits );
 void platform_uart_send( unsigned id, u8 data );
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout );
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout );
+int platform_uart_recv( unsigned id, unsigned timer_id, s32 timeout );
+int platform_s_uart_recv( unsigned id, s32 timeout );
 
 // *****************************************************************************
 // Timer subsection

Modified: trunk/inc/xmodem.h
===================================================================
--- trunk/inc/xmodem.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/inc/xmodem.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -1,75 +1,27 @@
-/*! \file xmodem.h \brief XModem Transmit/Receive Implementation with CRC and 1K support. */
-//*****************************************************************************
-//
-// File Name  : 'xmodem.h'
-// Title    : XModem Transmit/Receive Implementation with CRC and 1K support
-// Author     : Pascal Stang - Copyright (C) 2006
-// Created    : 4/22/2006
-// Revised    : 7/22/2006
-// Version    : 0.1
-// Target MCU   : AVR processors
-// Editor Tabs  : 4
-//
-///   \ingroup general
-/// \defgroup xmodem XModem Transmit/Receive Implementation with CRC and 1K support (xmodem.c)
-/// \code #include &quot;xmodem.h&quot; \endcode
-/// \par Overview
-///     This XModem implementation supports both 128b and 1K packets with or
-///     without CRC checking.  The xmodem library must be initialized to use
-///     a particular I/O stream by passing appropriate getbyte() and sendbyte()
-///     functions to xmodemInit().  The xmodem transfer routines also expect
-///     function pointers to read and write data blocks on the local system.
-///     While this use of function pointers increases code size, it has great
-///     adaptability.  The generalized read/write data functions mean that it
-///     is easy to pipe data to/from any storage device like EEPROMs or flash
-///     cards, rather than being limited to just processor RAM.
-//
-// This code is distributed under the GNU Public License
-//    which can be found at <A HREF="http://www.gnu.org/licenses/gpl.txt">http://www.gnu.org/licenses/gpl.txt</A>
-//
-//*****************************************************************************
-// Modified by BogdanM for the eLua project
-//*****************************************************************************
-//@{
+// XMODEM for eLua
 
-#ifndef XMODEM_H
-#define XMODEM_H
+#ifndef __XMODEM_H__
+#define __XMODEM_H__
 
 #include &quot;type.h&quot;
 
 // XMODEM constants
 #define XMODEM_INITIAL_BUFFER_SIZE    1024
 #define XMODEM_INCREMENT_AMMOUNT      512
-#define XMODEM_BUFFER_SIZE            128
 
-#define SOH       0x01
-#define STX       0x02
-#define EOT       0x04
-#define ACK       0x06
-#define NAK       0x15
-#define XMODEM_CAN  0x18
-#define CTRLZ     0x1A
-
 // xmodem timeout/retry parameters
-#define XMODEM_TIMEOUT_DELAY  1000000
-#define XMODEM_RETRY_LIMIT    16
+#define XMODEM_TIMEOUT                1000000
+#define XMODEM_RETRY_LIMIT            20
 
 // error return codes
-#define XMODEM_ERROR_REMOTECANCEL (-1)
-#define XMODEM_ERROR_OUTOFSYNC    (-2)
-#define XMODEM_ERROR_RETRYEXCEED  (-3)
-#define XMODEM_ERROR_OUTOFMEM     (-4)
+#define XMODEM_ERROR_REMOTECANCEL     (-1)
+#define XMODEM_ERROR_OUTOFSYNC        (-2)
+#define XMODEM_ERROR_RETRYEXCEED      (-3)
+#define XMODEM_ERROR_OUTOFMEM         (-4)
 
-// Send/recv functions
 typedef void ( *p_xm_send_func )( u8 );
 typedef int ( *p_xm_recv_func )( u32 );
-
-//! xmodem receive
 long xmodem_receive( char** dest );
-
-//! initialize xmodem stream I/O routines
 void xmodem_init( p_xm_send_func send_func, p_xm_recv_func recv_func );
 
-#endif // #ifndef XMODEM_H
-
-//@}
+#endif // #ifndef __XMODEM_H__

Added: trunk/src/buf.c
===================================================================
--- trunk/src/buf.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/buf.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,122 @@
+// eLua &quot;char device&quot; buffering system
+
+#include &quot;platform_conf.h&quot;
+
+#if defined( BUF_ENABLE_UART )
+#define BUF_ENABLE
+#endif
+
+#ifdef BUF_ENABLE
+
+#include &quot;buf.h&quot;
+#include &quot;type.h&quot;
+#include &quot;platform.h&quot;
+#include &quot;utils.h&quot;
+#include &lt;stdlib.h&gt;
+
+// [TODO]? Following code might need a C99 compiler (for 0-sized arrays)
+#ifdef BUF_ENABLE_UART
+  static buf_desc buf_desc_uart[ NUM_UART ];
+#else
+  static buf_desc buf_desc_uart[ 0 ];
+#endif
+
+// NOTE: the order of descriptors here MUST match the order of the BUF_ID_xx
+// enum in inc/buf.h
+static const buf_desc* buf_desc_array[ BUF_ID_TOTAL ] = 
+{
+  buf_desc_uart
+};
+
+// Helper macros
+#define BUF_MOD_INCR( p, m ) p-&gt;m = ( p-&gt;m + 1 ) &amp; ( ( ( u16 )1 &lt;&lt; p-&gt;logsize ) - 1 )
+#define BUF_REALSIZE( p ) ( ( u16 )1 &lt;&lt; p-&gt;logsize )
+#define BUF_GETPTR( resid, resnum ) buf_desc *pbuf = ( buf_desc* )buf_desc_array[ resid ] + resnum
+
+// READ16 and WRITE16 macros are here to ensure _atomic_ reads and writes of 
+// 16-bits data. Might have to be changed for an 8-bit architecture.
+#define READ16( p )     p
+#define WRITE16( p, x ) p = x
+
+// Initialize the buffer of the specified resource
+// resid - resource ID (BUF_ID_UART ...)
+// resnum - resource number (0, 1, 2...)
+// bufsize - new size of the buffer (one of the BUF_SIZE_xxx constants from
+//   buf.h, or BUF_SIZE_NONE to disable buffering
+// Returns 1 on success, 0 on failure
+int buf_set( unsigned resid, unsigned resnum, u8 logsize )
+{
+  BUF_GETPTR( resid, resnum );
+  
+  pbuf-&gt;logsize = logsize;
+  if( ( pbuf-&gt;buf = ( t_buf_data* )realloc( pbuf-&gt;buf, BUF_REALSIZE( pbuf ) * sizeof( t_buf_data ) ) ) == NULL )
+  {
+    pbuf-&gt;logsize = BUF_SIZE_NONE;
+    pbuf-&gt;rptr = pbuf-&gt;wptr = pbuf-&gt;count = 0;
+    if( logsize != BUF_SIZE_NONE )
+      return PLATFORM_ERR;
+  }
+  return PLATFORM_OK;
+}
+
+// Callback for RX buffer
+// resid - resource ID (BUF_ID_UART ...)
+// resnum - resource number (0, 1, 2...)
+// data - the new data
+// Returns 1 on success, 0 on failure
+// [TODO] maybe add a buffer overflow flag
+void buf_rx_cb( unsigned resid, unsigned resnum, t_buf_data data )
+{
+  BUF_GETPTR( resid, resnum );
+    
+  pbuf-&gt;buf[ pbuf-&gt;wptr ] = data;
+  BUF_MOD_INCR( pbuf, wptr );
+  if( pbuf-&gt;count == BUF_REALSIZE( pbuf ) )
+    BUF_MOD_INCR( pbuf, rptr );
+  else
+    pbuf-&gt;count ++;
+}
+
+// Returns 1 if the specified device is buffered, 0 otherwise
+// resid - resource ID (BUF_ID_UART ...)
+// resnum - resource number (0, 1, 2...)
+int buf_is_enabled( unsigned resid, unsigned resnum )
+{
+  BUF_GETPTR( resid, resnum );
+    
+  return pbuf-&gt;logsize != BUF_SIZE_NONE;
+}
+
+// Return the size of the buffer 
+unsigned buf_get_size( unsigned resid, unsigned resnum )
+{
+  BUF_GETPTR( resid, resnum );
+    
+  return BUF_REALSIZE( pbuf );
+}
+
+// Return the size of the data in the buffer
+unsigned buf_get_count( unsigned resid, unsigned resnum )
+{
+  BUF_GETPTR( resid, resnum );
+  
+  return READ16( pbuf-&gt;count );  
+}
+
+// Returns a char from the RX buffer (-1 if not available)
+int buf_get_char( unsigned resid, unsigned resnum )
+{
+  BUF_GETPTR( resid, resnum );
+  t_buf_data data;
+  
+  if( READ16( pbuf-&gt;count ) == 0 )
+    return -1;
+  data = pbuf-&gt;buf[ pbuf-&gt;rptr ];
+  platform_cpu_disable_interrupts();
+  pbuf-&gt;count --;
+  BUF_MOD_INCR( pbuf, rptr );
+  platform_cpu_enable_interrupts();
+  return ( int )data;  
+}
+
+#endif // #ifdef BUF_ENALE

Modified: trunk/src/common.c
===================================================================
--- trunk/src/common.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/common.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -1,10 +1,11 @@
-// Common platform functions
+// Common code for all backends
 
 #include &quot;platform.h&quot;
 #include &quot;platform_conf.h&quot;
 #include &quot;type.h&quot;
 #include &quot;genstd.h&quot;
 #include &quot;common.h&quot;
+#include &quot;buf.h&quot;
 #include &lt;stdio.h&gt;
 
 // *****************************************************************************
@@ -65,22 +66,42 @@
   return id &lt; NUM_UART;
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+// Helper function for buffers
+static int cmn_recv_helper( unsigned id, s32 timeout )
 {
+#ifdef BUF_ENABLE_UART
+  int res;
+  if( buf_is_enabled( BUF_ID_UART, id ) )
+  {
+    if( timeout == 0 )
+      return buf_get_char( BUF_ID_UART, id );
+    else
+    {
+      while( ( res = buf_get_char( BUF_ID_UART, id ) ) == -1 );
+      return res;
+    }
+  }
+  else
+#endif
+  return platform_s_uart_recv( id, timeout );
+}
+
+int platform_uart_recv( unsigned id, unsigned timer_id, s32 timeout )
+{
   timer_data_type tmr_start, tmr_crt;
   int res;
   
   if( timeout == 0 )
-    return platform_s_uart_recv( id, timer_id, timeout );
+    return cmn_recv_helper( id, timeout );
   else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-    return platform_s_uart_recv( id, timer_id, timeout );
+    return cmn_recv_helper( id, timeout );
   else
   {
     // Receive char with the specified timeout
     tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START, 0 );
     while( 1 )
     {
-      if( ( res = platform_s_uart_recv( id, timer_id, 0 ) ) &gt;= 0 )
+      if( ( res = cmn_recv_helper( id, 0 ) ) &gt;= 0 )
         break;
       tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
       if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )

Modified: trunk/src/lua/lparser.c
===================================================================
--- trunk/src/lua/lparser.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/lua/lparser.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -6,6 +6,7 @@
 
 
 #include &lt;string.h&gt;
+#include &lt;stdlib.h&gt;
 
 #define lparser_c
 #define LUA_CORE
@@ -382,19 +383,22 @@
 
 Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
   struct LexState lexstate;
-  struct FuncState funcstate;
+  struct FuncState *pfuncstate = (struct FuncState*)malloc(sizeof(struct FuncState));
+  Proto *res;
   lexstate.buff = buff;
   luaX_setinput(L, &amp;lexstate, z, luaS_new(L, name));
-  open_func(&amp;lexstate, &amp;funcstate);
-  funcstate.f-&gt;is_vararg = VARARG_ISVARARG;  /* main func. is always vararg */
+  open_func(&amp;lexstate, pfuncstate);
+  pfuncstate-&gt;f-&gt;is_vararg = VARARG_ISVARARG;  /* main func. is always vararg */
   luaX_next(&amp;lexstate);  /* read first token */
   chunk(&amp;lexstate);
   check(&amp;lexstate, TK_EOS);
   close_func(&amp;lexstate);
-  lua_assert(funcstate.prev == NULL);
-  lua_assert(funcstate.f-&gt;nups == 0);
+  lua_assert(pfuncstate-&gt;prev == NULL);
+  lua_assert(pfuncstate-&gt;f-&gt;nups == 0);
   lua_assert(lexstate.fs == NULL);
-  return funcstate.f;
+  res = pfuncstate-&gt;f;
+  free(pfuncstate);
+  return res;
 }
 
 
@@ -575,9 +579,9 @@
 
 static void body (LexState *ls, expdesc *e, int needself, int line) {
   /* body -&gt;  `(' parlist `)' chunk END */
-  FuncState new_fs;
-  open_func(ls, &amp;new_fs);
-  new_fs.f-&gt;linedefined = line;
+  FuncState *pnew_fs = (FuncState*)malloc(sizeof(FuncState));
+  open_func(ls, pnew_fs);
+  pnew_fs-&gt;f-&gt;linedefined = line;
   checknext(ls, '(');
   if (needself) {
     new_localvarliteral(ls, &quot;self&quot;, 0);
@@ -586,10 +590,11 @@
   parlist(ls);
   checknext(ls, ')');
   chunk(ls);
-  new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;
+  pnew_fs-&gt;f-&gt;lastlinedefined = ls-&gt;linenumber;
   check_match(ls, TK_END, TK_FUNCTION, line);
   close_func(ls);
-  pushclosure(ls, &amp;new_fs, e);
+  pushclosure(ls, pnew_fs, e);
+  free(pnew_fs);
 }
 
 
@@ -881,11 +886,12 @@
 static void block (LexState *ls) {
   /* block -&gt; chunk */
   FuncState *fs = ls-&gt;fs;
-  BlockCnt bl;
-  enterblock(fs, &amp;bl, 0);
+  BlockCnt *pbl = (BlockCnt*)malloc(sizeof(BlockCnt));
+  enterblock(fs, pbl, 0);
   chunk(ls);
-  lua_assert(bl.breaklist == NO_JUMP);
+  lua_assert(pbl-&gt;breaklist == NO_JUMP);
   leaveblock(fs);
+  free(pbl);
 }
 
 
@@ -993,17 +999,18 @@
   FuncState *fs = ls-&gt;fs;
   int whileinit;
   int condexit;
-  BlockCnt bl;
+  BlockCnt *pbl = (BlockCnt*)malloc(sizeof(BlockCnt));
   luaX_next(ls);  /* skip WHILE */
   whileinit = luaK_getlabel(fs);
   condexit = cond(ls);
-  enterblock(fs, &amp;bl, 1);
+  enterblock(fs, pbl, 1);
   checknext(ls, TK_DO);
   block(ls);
   luaK_patchlist(fs, luaK_jump(fs), whileinit);
   check_match(ls, TK_END, TK_WHILE, line);
   leaveblock(fs);
   luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
+  free(pbl);
 }
 
 
@@ -1012,14 +1019,14 @@
   int condexit;
   FuncState *fs = ls-&gt;fs;
   int repeat_init = luaK_getlabel(fs);
-  BlockCnt bl1, bl2;
-  enterblock(fs, &amp;bl1, 1);  /* loop block */
-  enterblock(fs, &amp;bl2, 0);  /* scope block */
+  BlockCnt *pbl1 = (BlockCnt*)malloc(sizeof(BlockCnt)), *pbl2 = (BlockCnt*)malloc(sizeof(BlockCnt));
+  enterblock(fs, pbl1, 1);  /* loop block */
+  enterblock(fs, pbl2, 0);  /* scope block */
   luaX_next(ls);  /* skip REPEAT */
   chunk(ls);
   check_match(ls, TK_UNTIL, TK_REPEAT, line);
   condexit = cond(ls);  /* read condition (inside scope block) */
-  if (!bl2.upval) {  /* no upvalues? */
+  if (!pbl2-&gt;upval) {  /* no upvalues? */
     leaveblock(fs);  /* finish scope */
     luaK_patchlist(ls-&gt;fs, condexit, repeat_init);  /* close the loop */
   }
@@ -1030,6 +1037,8 @@
     luaK_patchlist(ls-&gt;fs, luaK_jump(fs), repeat_init);  /* and repeat */
   }
   leaveblock(fs);  /* finish loop */
+  free(pbl1);
+  free(pbl2);
 }
 
 
@@ -1045,13 +1054,13 @@
 
 static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
   /* forbody -&gt; DO block */
-  BlockCnt bl;
+  BlockCnt *pbl = (BlockCnt*)malloc(sizeof(BlockCnt));
   FuncState *fs = ls-&gt;fs;
   int prep, endfor;
   adjustlocalvars(ls, 3);  /* control variables */
   checknext(ls, TK_DO);
   prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
-  enterblock(fs, &amp;bl, 0);  /* scope for declared variables */
+  enterblock(fs, pbl, 0);  /* scope for declared variables */
   adjustlocalvars(ls, nvars);
   luaK_reserveregs(fs, nvars);
   block(ls);
@@ -1061,6 +1070,7 @@
                      luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars);
   luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
   luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1);
+  free(pbl);
 }
 
 
@@ -1113,8 +1123,8 @@
   /* forstat -&gt; FOR (fornum | forlist) END */
   FuncState *fs = ls-&gt;fs;
   TString *varname;
-  BlockCnt bl;
-  enterblock(fs, &amp;bl, 1);  /* scope for loop and control variables */
+  BlockCnt *pbl = (BlockCnt*)malloc(sizeof(BlockCnt));
+  enterblock(fs, pbl, 1);  /* scope for loop and control variables */
   luaX_next(ls);  /* skip `for' */
   varname = str_checkname(ls);  /* first variable name */
   switch (ls-&gt;t.token) {
@@ -1124,6 +1134,7 @@
   }
   check_match(ls, TK_END, TK_FOR, line);
   leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+  free(pbl);
 }
 
 

Modified: trunk/src/lua/lstrlib.c
===================================================================
--- trunk/src/lua/lstrlib.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/lua/lstrlib.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -685,7 +685,8 @@
 
 
 /* maximum size of each formatted item (&gt; len(format('%99.99f', -1e308))) */
-#define MAX_ITEM	512
+/* was 512, modified to 128 for eLua */
+#define MAX_ITEM	128
 /* valid flags in a format specification */
 #define FLAGS	&quot;-+ #0&quot;
 /*

Modified: trunk/src/modules/uart.c
===================================================================
--- trunk/src/modules/uart.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/modules/uart.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -24,25 +24,9 @@
   return 1;
 }
 
-// Lua: send( id, out1, out2, ... )
+// Lua: send( id, string1, string2, ... )
 static int uart_send( lua_State* L )
 {
-  u8 value;
-  int total = lua_gettop( L ), i, id;
-  
-  id = luaL_checkinteger( L, 1 );
-  MOD_CHECK_ID( uart, id );
-  for( i = 2; i &lt;= total; i ++ )
-  {
-    value = luaL_checkinteger( L, i );  
-    platform_uart_send( id, value );
-  }
-  return 0;
-}
-
-// Lua: sendstr( id, string1, string2, ... )
-static int uart_sendstr( lua_State* L )
-{
   int id;
   const char* buf;
   size_t len, i;
@@ -60,15 +44,22 @@
   return 0;
 }
 
-// Lua: data = recv( id, timer_id, timeout )
+// Lua: data = recv( id, [ timer_id, timeout ] )
 static int uart_recv( lua_State* L )
 {
-  int id, timer_id, timeout, res;
+  int id, res;
+  unsigned timer_id = 0;
+  s32 timeout = PLATFORM_UART_INFINITE_TIMEOUT;
   
   id = luaL_checkinteger( L, 1 );
   MOD_CHECK_ID( uart, id );
-  timer_id = luaL_checkinteger( L, 2 );
-  timeout = luaL_checkinteger( L, 3 );
+  if( lua_gettop( L ) &gt;= 2 )
+  {
+    timer_id = luaL_checkinteger( L, 2 );
+    timeout = luaL_checkinteger( L, 3 );    
+    if( ( timeout &lt; 0 ) &amp;&amp; ( timeout != PLATFORM_UART_INFINITE_TIMEOUT ) )
+      timeout = 0x7FFFFFFF; // force timeout to its maximum value
+  }
   res = platform_uart_recv( id, timer_id, timeout );
   lua_pushinteger( L, res );
   return 1;  
@@ -82,7 +73,6 @@
   { LSTRKEY( &quot;setup&quot; ),  LFUNCVAL( uart_setup ) },
   { LSTRKEY( &quot;send&quot; ), LFUNCVAL( uart_send) },
   { LSTRKEY( &quot;recv&quot; ), LFUNCVAL( uart_recv ) },
-  { LSTRKEY( &quot;sendstr&quot; ), LFUNCVAL( uart_sendstr ) },
 #if LUA_OPTIMIZE_MEMORY &gt; 0
   { LSTRKEY( &quot;PAR_EVEN&quot; ), LNUMVAL( PLATFORM_UART_PARITY_EVEN ) },
   { LSTRKEY( &quot;PAR_ODD&quot; ), LNUMVAL( PLATFORM_UART_PARITY_ODD ) },

Modified: trunk/src/newlib/stubs.c
===================================================================
--- trunk/src/newlib/stubs.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/newlib/stubs.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -11,6 +11,7 @@
 #include &quot;platform.h&quot;
 #include &quot;platform_conf.h&quot;
 #include &quot;genstd.h&quot;
+#include &quot;utils.h&quot;
 
 #ifdef USE_MULTIPLE_ALLOCATOR
 #include &quot;dlmalloc.h&quot;
@@ -184,60 +185,6 @@
 }
 
 // *****************************************************************************
-// _sbrk_r (newlib) / elua_sbrk (multiple)
-static char *heap_ptr; 
-static int mem_index;
-
-#ifdef USE_MULTIPLE_ALLOCATOR
-void* elua_sbrk( ptrdiff_t incr )
-#else
-void* _sbrk_r( struct _reent* r, ptrdiff_t incr )
-#endif
-{
-  void* ptr;
-  
-  // If increment is 0 return the current break   
-  if( incr == 0 )
-    return heap_ptr;
-    
-  // If increment is negative, return -1
-  if( incr &lt; 0 )
-    return ( void* )-1;
-    
-  // Otherwise ask the platform about our memory space (if needed)
-  // We do this for all our memory spaces
-  while( 1 )
-  {
-    if( heap_ptr == NULL )  
-      heap_ptr = ( char* )platform_get_first_free_ram( mem_index );
-      
-    // If no more memory spaces are available, return with error    
-    if( heap_ptr == NULL )
-    {
-      ptr = ( void* )-1;
-      break;
-    }
-    
-    // Do we have space in the current memory space?
-    if( heap_ptr + incr &gt; ( char* )platform_get_last_free_ram( mem_index ) ) 
-    {
-      // We don't, so try the next memory space
-      heap_ptr = NULL;
-      mem_index ++;
-    }
-    else
-    {
-      // Memory found in the current space
-      ptr = heap_ptr;
-      heap_ptr += incr;
-      break;
-    }
-  }
-  
-  return ptr;
-}  
-
-// *****************************************************************************
 // _lseek_r
 _off_t _lseek_r( struct _reent *r, int file, _off_t ptr, int dir )
 {
@@ -252,16 +199,8 @@
     return seek.off;
 }
 
-// *****************************************************************************
-// mallinfo()
-struct mallinfo mallinfo()
-{
-#ifdef USE_MULTIPLE_ALLOCATOR
-  return dlmallinfo();
-#else
-  return _mallinfo_r( _REENT );
-#endif
-}
+// ****************************************************************************
+// Miscalenous functions
 
 int _isatty_r( struct _reent* r, int fd )
 {
@@ -329,7 +268,8 @@
 }
 #endif
 
-// If LUA_NUMBER_INTEGRAL is defined, &quot;redirect&quot; printf/scanf calls to their integer counterparts
+// If LUA_NUMBER_INTEGRAL is defined, &quot;redirect&quot; printf/scanf calls to their 
+// integer counterparts
 #ifdef LUA_NUMBER_INTEGRAL
 int _vfprintf_r( struct _reent *r, FILE *stream, const char *format, va_list ap )
 {
@@ -343,8 +283,68 @@
 }
 #endif // #ifdef LUA_NUMBER_INTEGRAL
 
+// ****************************************************************************
+// Allocator support
+
+// _sbrk_r (newlib) / elua_sbrk (multiple)
+static char *heap_ptr; 
+static int mem_index;
+
 #ifdef USE_MULTIPLE_ALLOCATOR
+void* elua_sbrk( ptrdiff_t incr )
+#else
+void* _sbrk_r( struct _reent* r, ptrdiff_t incr )
+#endif
+{
+  void* ptr;
+      
+  // If increment is negative, return -1
+  if( incr &lt; 0 )
+    return ( void* )-1;
+    
+  // Otherwise ask the platform about our memory space (if needed)
+  // We do this for all our memory spaces
+  while( 1 )
+  {
+    if( heap_ptr == NULL )  
+    {
+      if( ( heap_ptr = ( char* )platform_get_first_free_ram( mem_index ) ) == NULL )
+      {
+        ptr = ( void* )-1;
+        break;
+      }
+    }
+      
+    // Do we have space in the current memory space?
+    if( heap_ptr + incr &gt; ( char* )platform_get_last_free_ram( mem_index )  ) 
+    {
+      // We don't, so try the next memory space
+      heap_ptr = NULL;
+      mem_index ++;
+    }
+    else
+    {
+      // Memory found in the current space
+      ptr = heap_ptr;
+      heap_ptr += incr;
+      break;
+    }
+  }  
 
+  return ptr;
+} 
+
+// mallinfo()
+struct mallinfo mallinfo()
+{
+#ifdef USE_MULTIPLE_ALLOCATOR
+  return dlmallinfo();
+#else
+  return _mallinfo_r( _REENT );
+#endif
+} 
+
+#ifdef USE_MULTIPLE_ALLOCATOR
 // Redirect all allocator calls to our dlmalloc
 void* _malloc_r( struct _reent* r, size_t size )
 {
@@ -370,7 +370,6 @@
 {
   return dlmemalign( align, nbytes );
 }
-
 #endif // #ifdef USE_MULTIPLE_ALLOCATOR
 
 // *****************************************************************************
@@ -394,6 +393,8 @@
 
 #endif // #if !defined( BUILD_CON_GENERIC ) &amp;&amp; !defined( BUILD_CON_TCP )
 
+// ****************************************************************************
+// memcpy is broken on AVR32's Newlib, so impolement a simple version here
 #ifdef FORAVR32
 void* memcpy( void *dst, const void* src, size_t len )
 {
@@ -408,4 +409,3 @@
   return dst;
 }
 #endif // #ifdef FORAVR32
-

Modified: trunk/src/platform/at91sam7x/platform.c
===================================================================
--- trunk/src/platform/at91sam7x/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/at91sam7x/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -20,6 +20,7 @@
 #include &quot;common.h&quot;
 #include &quot;aic.h&quot;
 #include &quot;platform_conf.h&quot;
+#include &quot;buf.h&quot;
 
 // ****************************************************************************
 // Platform initialization
@@ -41,13 +42,26 @@
 }
 #endif
 
+// Buffered UART support
+#ifdef BUF_ENABLE_UART
+static void uart_rx_handler()
+{
+  int c;
+  AT91S_USART* base = CON_UART_ID == 0 ? AT91C_BASE_US0 : AT91C_BASE_US1;    
+  
+  c = USART_Read( base, 0 );
+  buf_rx_cb( BUF_ID_UART, CON_UART_ID, ( t_buf_data )c );
+  asm( &quot;pop {r0}&quot;:: );  
+  asm( &quot;bx  r0&quot;:: );  
+}
+#endif
+
 int platform_init()
 {
   int i;
    
   unsigned int mode = AT91C_US_USMODE_NORMAL | AT91C_US_CLKS_CLOCK | AT91C_US_CHRL_8_BITS | 
       AT91C_US_PAR_NONE | AT91C_US_NBSTOP_1_BIT | AT91C_US_CHMODE_NORMAL;
-      
   // Enable the peripherals we use in the PMC
   PMC_EnablePeripheral( AT91C_ID_US0 );  
   PMC_EnablePeripheral( AT91C_ID_US1 );
@@ -62,11 +76,21 @@
   PIO_Configure(platform_uart_pins[ 0 ], PIO_LISTSIZE(platform_uart_pins[ 0 ]));
     
   // Configure the USART in the desired mode @115200 bauds
-  USART_Configure(AT91C_BASE_US0, mode, CON_UART_SPEED, BOARD_MCK);
-  
+  USART_Configure(AT91C_BASE_US0, mode, CON_UART_SPEED, BOARD_MCK);  
   // Enable receiver &amp; transmitter
   USART_SetTransmitterEnabled(AT91C_BASE_US0, 1);
   USART_SetReceiverEnabled(AT91C_BASE_US0, 1);  
+#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
+  // Enable buffering on the console UART
+  buf_set( BUF_ID_UART, CON_UART_ID, CON_BUF_SIZE );
+  // Set interrupt handler and interrupt flag on UART
+  unsigned uart_id = CON_UART_ID == 0 ? AT91C_ID_US0 : AT91C_ID_US1;
+  AT91S_USART* base = CON_UART_ID == 0 ? AT91C_BASE_US0 : AT91C_BASE_US1;        
+  AIC_DisableIT( uart_id );
+  AIC_ConfigureIT( uart_id, 0, uart_rx_handler );
+  base-&gt;US_IER = AT91C_US_RXRDY;
+  AIC_EnableIT( uart_id );  
+#endif  
   
   // Configure the timers
   AT91C_BASE_TCB-&gt;TCB_BMR = 0x15;
@@ -224,7 +248,7 @@
   USART_Write( base, data, 0 );
 }
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   AT91S_USART* base = id == 0 ? AT91C_BASE_US0 : AT91C_BASE_US1;  
     

Modified: trunk/src/platform/at91sam7x/platform_conf.h
===================================================================
--- trunk/src/platform/at91sam7x/platform_conf.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/at91sam7x/platform_conf.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -61,6 +61,10 @@
 #define NUM_PWM               4
 #define NUM_ADC               0
 
+// Enable RX buffering on UART
+#define BUF_ENABLE_UART
+#define CON_BUF_SIZE          BUF_SIZE_128
+
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         BOARD_MCK
 

Modified: trunk/src/platform/at91sam7x/stacks.h
===================================================================
--- trunk/src/platform/at91sam7x/stacks.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/at91sam7x/stacks.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -3,7 +3,7 @@
 #ifndef __STACKS_H__
 #define __STACKS_H__
 
-#define  STACK_SIZE_USR   512
+#define  STACK_SIZE_USR   2048
 #define  STACK_SIZE_IRQ   64
 #define  STACK_SIZE_TOTAL ( STACK_SIZE_USR + STACK_SIZE_IRQ )
 

Modified: trunk/src/platform/avr32/conf.py
===================================================================
--- trunk/src/platform/avr32/conf.py	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/conf.py	2009-01-22 19:46:47 UTC (rev 162)
@@ -1,8 +1,9 @@
 # Configuration file for the AVR32 microcontroller
 
-specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c tc.c&quot;
+specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c tc.c sdramc.c&quot;
 ldscript = &quot;at32uc3a0512.ld&quot;
-cdefs = cdefs + &quot; -DFORAVR32&quot;
+# [TODO] the next line assumes that the board is an ATEVK1100 (see src/platform/avr32/board.h)
+cdefs = cdefs + &quot; -DFORAVR32 -DBOARD=1&quot;
 
 # Prepend with path
 specific_files = &quot; &quot;.join( [ &quot;src/platform/%s/%s&quot; % ( platform, f ) for f in specific_files.split() ] )

Modified: trunk/src/platform/avr32/evk1100.h
===================================================================
--- trunk/src/platform/avr32/evk1100.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/evk1100.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -83,7 +83,7 @@
 //! @{
 
 //! Part header file of used SDRAM(s).
-#define SDRAM_PART_HDR  &quot;MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h&quot;
+#define SDRAM_PART_HDR  &quot;mt48lc16m16a2tg7e.h&quot;
 
 //! Data bus width to use the SDRAM(s) with (16 or 32 bits; always 16 bits on
 //! UC3).

Added: trunk/src/platform/avr32/mt48lc16m16a2tg7e.h
===================================================================
--- trunk/src/platform/avr32/mt48lc16m16a2tg7e.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/mt48lc16m16a2tg7e.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,117 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief MT48LC16M16A2TG-7E SDRAM driver for AVR32 UC3 SDRAMC on EBI.
+ *
+ * \note The values defined in this file are device-specific. See the device
+ *       datasheet for further information.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _MT48LC16M16A2TG7E_H_
+#define _MT48LC16M16A2TG7E_H_
+
+
+//! The number of bank bits for this SDRAM (1 or 2).
+#define SDRAM_BANK_BITS                 2
+
+//! The number of row bits for this SDRAM (11 to 13).
+#define SDRAM_ROW_BITS                  13
+
+//! The number of column bits for this SDRAM (8 to 11).
+#define SDRAM_COL_BITS                  9
+
+//! The minimal column address select (READ) latency for this SDRAM (1 to 3 SDRAM cycles).
+//! Unit: tCK (SDRAM cycle period).
+#define SDRAM_CAS                       2
+
+//! The minimal write recovery time for this SDRAM (0 to 15 SDRAM cycles).
+//! Unit: ns.
+#define SDRAM_TWR                       14
+
+//! The minimal row cycle time for this SDRAM (0 to 15 SDRAM cycles).
+//! ACTIVE-to-ACTIVE command delay.
+//! Unit: ns.
+#define SDRAM_TRC                       60
+
+//! The minimal row precharge time for this SDRAM (0 to 15 SDRAM cycles).
+//! PRECHARGE command period.
+//! Unit: ns.
+#define SDRAM_TRP                       15
+
+//! The minimal row to column delay time for this SDRAM (0 to 15 SDRAM cycles).
+//! ACTIVE-to-READ/WRITE command delay.
+//! Unit: ns.
+#define SDRAM_TRCD                      15
+
+//! The minimal row address select time for this SDRAM (0 to 15 SDRAM cycles).
+//! ACTIVE-to-PRECHARGE command delay.
+//! Unit: ns.
+#define SDRAM_TRAS                      37
+
+//! The minimal exit self refresh time for this SDRAM (0 to 15 SDRAM cycles).
+//! Exit SELF REFRESH to ACTIVE command delay.
+//! Unit: ns.
+#define SDRAM_TXSR                      67
+
+//! The maximal refresh time for this SDRAM (0 to 4095 SDRAM cycles).
+//! Refresh period.
+//! Unit: ns.
+#define SDRAM_TR                        7812
+
+//! The minimal refresh cycle time for this SDRAM.
+//! AUTO REFRESH command period.
+//! Unit: ns.
+#define SDRAM_TRFC                      66
+
+//! The minimal mode register delay time for this SDRAM.
+//! LOAD MODE REGISTER command to ACTIVE or REFRESH command delay.
+//! Unit: tCK (SDRAM cycle period).
+#define SDRAM_TMRD                      2
+
+//! The minimal stable-clock initialization delay for this SDRAM.
+//! Unit: us.
+#define SDRAM_STABLE_CLOCK_INIT_DELAY   100
+
+//! The minimal number of AUTO REFRESH commands required during initialization for this SDRAM.
+#define SDRAM_INIT_AUTO_REFRESH_COUNT   2
+
+
+#endif  // _MT48LC16M16A2TG7E_H_

Modified: trunk/src/platform/avr32/platform.c
===================================================================
--- trunk/src/platform/avr32/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -13,6 +13,7 @@
 #include &quot;utils.h&quot;
 #include &quot;platform_conf.h&quot;
 #include &quot;common.h&quot;
+#include &quot;buf.h&quot;
 
 // Platform-specific includes
 #include &lt;avr32/io.h&gt;
@@ -24,14 +25,15 @@
 #include &quot;gpio.h&quot;
 #include &quot;tc.h&quot;
 #include &quot;intc.h&quot;
+#include &quot;sdramc.h&quot;
 
 // ****************************************************************************
 // Platform initialization
 
 extern int pm_configure_clocks( pm_freq_param_t *param );
 
+// Virtual timers support
 #if VTMR_NUM_TIMERS &gt; 0
-
 #define VTMR_CH     (2)
 
 __attribute__((__interrupt__)) static void tmr_int_handler()
@@ -43,6 +45,22 @@
 }                                
 #endif
 
+static const u32 uart_base_addr[ NUM_UART ] = { AVR32_USART0_ADDRESS, AVR32_USART1_ADDRESS, AVR32_USART2_ADDRESS, AVR32_USART3_ADDRESS };
+
+// Buffered UART support
+#ifdef BUF_ENABLE_UART
+__attribute__((__interrupt__)) static void uart_rx_handler()
+{
+  int c;
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];    
+  
+  usart_read_char( pusart, &amp;c );
+  buf_rx_cb( BUF_ID_UART, CON_UART_ID, ( t_buf_data )c );
+}
+#endif
+
+extern void alloc_init();
+
 int platform_init()
 {
   pm_freq_param_t pm_freq_param =
@@ -82,7 +100,7 @@
          
   Disable_global_interrupt();  
   INTC_init_interrupts();
-  
+    
   // Setup clocks
   if( PM_FREQ_STATUS_FAIL == pm_configure_clocks( &amp;pm_freq_param ) )
     return PLATFORM_ERR;  
@@ -91,9 +109,21 @@
   // Enable the 32-kHz clock
   pm_enable_clk32_no_wait( &amp;AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC );    
   
+  // Initialize external memory
+  sdramc_init( REQ_CPU_FREQ );
+  
   // Setup UART for eLua
   platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );  
-  
+#if defined( BUF_ENABLE_UART ) &amp;&amp; defined( CON_BUF_SIZE )
+  // Enable buffering on the console UART
+  buf_set( BUF_ID_UART, CON_UART_ID, CON_BUF_SIZE );
+  // Set interrupt handler and interrupt flag on UART
+  INTC_register_interrupt( &amp;uart_rx_handler, CON_UART_IRQ, AVR32_INTC_INT0 );  
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];      
+  pusart-&gt;ier = AVR32_USART_IER_RXRDY_MASK;  
+  Enable_global_interrupt();
+#endif
+    
   // Setup timers
   for( i = 0; i &lt; 3; i ++ )
   {
@@ -123,7 +153,7 @@
   Enable_global_interrupt();
   tc_start( tc, VTMR_CH );  
 #endif
-  
+
   cmn_platform_init();
     
   // All done  
@@ -313,7 +343,7 @@
 // ****************************************************************************
 // UART functions
 
-static const u32 uart_base_addr[ NUM_UART ] = { AVR32_USART0_ADDRESS, AVR32_USART1_ADDRESS, AVR32_USART2_ADDRESS, AVR32_USART3_ADDRESS };
+
 static const gpio_map_t uart_pins = 
 {
   // UART 0
@@ -368,9 +398,9 @@
   volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
   
   usart_putchar( pusart, data );
-}
+}    
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
   int temp;

Modified: trunk/src/platform/avr32/platform_conf.h
===================================================================
--- trunk/src/platform/avr32/platform_conf.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/platform_conf.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -6,6 +6,7 @@
 #include &quot;auxmods.h&quot;
 #include &quot;board.h&quot;
 #include &quot;stacks.h&quot;
+#include &quot;sdramc.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -20,7 +21,7 @@
 // UART/Timer IDs configuration data (used in main.c)
 
 #define CON_UART_ID         0
-#define CON_UART_SPEED      38400
+#define CON_UART_SPEED      115200
 #define XMODEM_TIMER_ID     0
 #define TERM_TIMER_ID       0
 #define TERM_LINES          25
@@ -60,6 +61,12 @@
 #define NUM_PWM               0
 #define NUM_ADC               0
 
+// Enable RX buffering on UART
+#define BUF_ENABLE_UART
+#define CON_BUF_SIZE          BUF_SIZE_128
+// REMEMBER to change next line if buffering is enabled and CON_UART_ID is not 0!
+#define CON_UART_IRQ          AVR32_USART0_IRQ
+
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         REQ_CPU_FREQ
 
@@ -73,8 +80,8 @@
 
 // Allocator data: define your free memory zones here in two arrays
 // (start address and end address)
-#define MEM_START_ADDRESS     { ( void* )end }
-#define MEM_END_ADDRESS       { ( void* )( 0x10000 - STACK_SIZE_TOTAL - 1 ) }
+#define MEM_START_ADDRESS     { ( void* )end, ( void* )SDRAM }
+#define MEM_END_ADDRESS       { ( void* )( 0x10000 - STACK_SIZE_TOTAL - 1 ), ( void* )( SDRAM + SDRAM_SIZE - 1 ) }
 
 // *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module

Added: trunk/src/platform/avr32/sdramc.c
===================================================================
--- trunk/src/platform/avr32/sdramc.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/sdramc.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,262 @@
+/* This source file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief SDRAMC on EBI driver for AVR32 UC3.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include &quot;compiler.h&quot;
+#include &quot;preprocessor.h&quot;
+#include &quot;gpio.h&quot;
+#include &quot;sdramc.h&quot;
+
+
+/*! \brief Waits during at least the specified delay before returning.
+ *
+ * \param ck Number of HSB clock cycles to wait.
+ */
+static void sdramc_ck_delay(unsigned long ck)
+{
+  // Use the CPU cycle counter (CPU and HSB clocks are the same).
+  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
+  unsigned long delay_end_cycle = delay_start_cycle + ck;
+
+  // To be safer, the end of wait is based on an inequality test, so CPU cycle
+  // counter wrap around is checked.
+  if (delay_start_cycle &lt;= delay_end_cycle)
+  {
+    while ((unsigned long)Get_system_register(AVR32_COUNT) &lt; delay_end_cycle);
+  }
+  else
+  {
+    while ((unsigned long)Get_system_register(AVR32_COUNT) &gt; delay_end_cycle);
+  }
+}
+
+
+/*! \brief Waits during at least the specified delay before returning.
+ *
+ * \param ns Number of nanoseconds to wait.
+ * \param hsb_mhz_up Rounded-up HSB frequency in MHz.
+ */
+#define sdramc_ns_delay(ns, hsb_mhz_up)   sdramc_ck_delay(((ns) * (hsb_mhz_up) + 999) / 1000)
+
+
+/*! \brief Waits during at least the specified delay before returning.
+ *
+ * \param us Number of microseconds to wait.
+ * \param hsb_mhz_up Rounded-up HSB frequency in MHz.
+ */
+#define sdramc_us_delay(us, hsb_mhz_up)   sdramc_ck_delay((us) * (hsb_mhz_up))
+
+
+/*! \brief Puts the multiplexed MCU pins used for the SDRAM under control of the
+ *         SDRAMC.
+ */
+#if BOARD == EVK1100
+static void sdramc_enable_muxed_pins(void)
+{
+  static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
+  {
+    // Enable data pins.
+#define SDRAMC_ENABLE_DATA_PIN(DATA_BIT, unused) \
+    {AVR32_EBI_DATA_##DATA_BIT##_PIN, AVR32_EBI_DATA_##DATA_BIT##_FUNCTION},
+    MREPEAT(SDRAM_DBW, SDRAMC_ENABLE_DATA_PIN, ~)
+#undef SDRAMC_ENABLE_DATA_PIN
+
+    // Enable row/column address pins.
+    {AVR32_EBI_ADDR_2_PIN,            AVR32_EBI_ADDR_2_FUNCTION           },
+    {AVR32_EBI_ADDR_3_PIN,            AVR32_EBI_ADDR_3_FUNCTION           },
+    {AVR32_EBI_ADDR_4_PIN,            AVR32_EBI_ADDR_4_FUNCTION           },
+    {AVR32_EBI_ADDR_5_PIN,            AVR32_EBI_ADDR_5_FUNCTION           },
+    {AVR32_EBI_ADDR_6_PIN,            AVR32_EBI_ADDR_6_FUNCTION           },
+    {AVR32_EBI_ADDR_7_PIN,            AVR32_EBI_ADDR_7_FUNCTION           },
+    {AVR32_EBI_ADDR_8_PIN,            AVR32_EBI_ADDR_8_FUNCTION           },
+    {AVR32_EBI_ADDR_9_PIN,            AVR32_EBI_ADDR_9_FUNCTION           },
+    {AVR32_EBI_ADDR_10_PIN,           AVR32_EBI_ADDR_10_FUNCTION          },
+    {AVR32_EBI_ADDR_11_PIN,           AVR32_EBI_ADDR_11_FUNCTION          },
+    {AVR32_EBI_SDA10_0_PIN,           AVR32_EBI_SDA10_0_FUNCTION          },
+#if SDRAM_ROW_BITS &gt;= 12
+    {AVR32_EBI_ADDR_13_PIN,           AVR32_EBI_ADDR_13_FUNCTION          },
+  #if SDRAM_ROW_BITS &gt;= 13
+    {AVR32_EBI_ADDR_14_PIN,           AVR32_EBI_ADDR_14_FUNCTION          },
+  #endif
+#endif
+
+    // Enable bank address pins.
+    {AVR32_EBI_ADDR_16_PIN,           AVR32_EBI_ADDR_16_FUNCTION          },
+#if SDRAM_BANK_BITS &gt;= 2
+    {AVR32_EBI_ADDR_17_PIN,           AVR32_EBI_ADDR_17_FUNCTION          },
+#endif
+
+    // Enable data mask pins.
+    {AVR32_EBI_ADDR_0_PIN,            AVR32_EBI_ADDR_0_FUNCTION           },
+    {AVR32_EBI_NWE1_0_PIN,            AVR32_EBI_NWE1_0_FUNCTION           },
+#if SDRAM_DBW &gt;= 32
+    {AVR32_EBI_NWE2_0_PIN,            AVR32_EBI_NWE2_0_FUNCTION           },
+    {AVR32_EBI_NWE3_0_PIN,            AVR32_EBI_NWE3_0_FUNCTION           },
+#endif
+
+    // Enable control pins.
+    {AVR32_EBI_SDWE_0_PIN,            AVR32_EBI_SDWE_0_FUNCTION           },
+    {AVR32_EBI_CAS_0_PIN,             AVR32_EBI_CAS_0_FUNCTION            },
+    {AVR32_EBI_RAS_0_PIN,             AVR32_EBI_RAS_0_FUNCTION            },
+    {AVR32_EBI_NCS_1_PIN,             AVR32_EBI_NCS_1_FUNCTION            },
+
+    // Enable clock-related pins.
+    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
+    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
+  };
+
+  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
+}
+#elif BOARD == STK1000
+static void sdramc_enable_muxed_pins(void)
+{
+  volatile avr32_hmatrix_t *hmatrix = &amp;AVR32_HMATRIX;
+
+  // Enable SDRAM mode for CS1 in the BAMBI mux 
+  hmatrix-&gt;sfr[4] |= 0x0002;
+  hmatrix-&gt;sfr[4] |= 0x0100;
+
+  static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
+  {
+    // Enable DATA 16 through 31 pins, which is muxed with LCD
+    {AVR32_EBI_DATA_16_PIN,           AVR32_EBI_DATA_16_FUNCTION          },
+    {AVR32_EBI_DATA_17_PIN,           AVR32_EBI_DATA_17_FUNCTION          },
+    {AVR32_EBI_DATA_18_PIN,           AVR32_EBI_DATA_18_FUNCTION          },
+    {AVR32_EBI_DATA_19_PIN,           AVR32_EBI_DATA_19_FUNCTION          },
+    {AVR32_EBI_DATA_20_PIN,           AVR32_EBI_DATA_20_FUNCTION          },
+    {AVR32_EBI_DATA_21_PIN,           AVR32_EBI_DATA_21_FUNCTION          },
+    {AVR32_EBI_DATA_22_PIN,           AVR32_EBI_DATA_22_FUNCTION          },
+    {AVR32_EBI_DATA_23_PIN,           AVR32_EBI_DATA_23_FUNCTION          },
+    {AVR32_EBI_DATA_24_PIN,           AVR32_EBI_DATA_24_FUNCTION          },
+    {AVR32_EBI_DATA_25_PIN,           AVR32_EBI_DATA_25_FUNCTION          },
+    {AVR32_EBI_DATA_26_PIN,           AVR32_EBI_DATA_26_FUNCTION          },
+    {AVR32_EBI_DATA_27_PIN,           AVR32_EBI_DATA_27_FUNCTION          },
+    {AVR32_EBI_DATA_28_PIN,           AVR32_EBI_DATA_28_FUNCTION          },
+    {AVR32_EBI_DATA_29_PIN,           AVR32_EBI_DATA_29_FUNCTION          },
+    {AVR32_EBI_DATA_30_PIN,           AVR32_EBI_DATA_30_FUNCTION          },
+    {AVR32_EBI_DATA_31_PIN,           AVR32_EBI_DATA_31_FUNCTION          }
+  };
+
+  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
+
+
+}
+
+#endif
+
+void sdramc_init(unsigned long hsb_hz)
+{
+  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
+  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
+  volatile ATPASTE2(U, SDRAM_DBW) *sdram = SDRAM;
+  unsigned int i;
+
+  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
+  sdramc_enable_muxed_pins();
+
+  // Enable SDRAM mode for CS1.
+  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 &lt;&lt; AVR32_EBI_SDRAM_CS;
+  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
+
+  // Configure the SDRAM Controller with SDRAM setup and timing information.
+  // All timings below are rounded up because they are minimal values.
+  AVR32_SDRAMC.cr =
+      ((( SDRAM_COL_BITS                 -    8) &lt;&lt; AVR32_SDRAMC_CR_NC_OFFSET  ) &amp; AVR32_SDRAMC_CR_NC_MASK  ) |
+      ((( SDRAM_ROW_BITS                 -   11) &lt;&lt; AVR32_SDRAMC_CR_NR_OFFSET  ) &amp; AVR32_SDRAMC_CR_NR_MASK  ) |
+      ((( SDRAM_BANK_BITS                -    1) &lt;&lt; AVR32_SDRAMC_CR_NB_OFFSET  ) &amp; AVR32_SDRAMC_CR_NB_MASK  ) |
+      ((  SDRAM_CAS                              &lt;&lt; AVR32_SDRAMC_CR_CAS_OFFSET ) &amp; AVR32_SDRAMC_CR_CAS_MASK ) |
+      ((( SDRAM_DBW                      &gt;&gt;   4) &lt;&lt; AVR32_SDRAMC_CR_DBW_OFFSET ) &amp; AVR32_SDRAMC_CR_DBW_MASK ) |
+      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TWR_OFFSET ) &amp; AVR32_SDRAMC_CR_TWR_MASK ) |
+      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRC_OFFSET ) &amp; AVR32_SDRAMC_CR_TRC_MASK ) |
+      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRP_OFFSET ) &amp; AVR32_SDRAMC_CR_TRP_MASK ) |
+      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRCD_OFFSET) &amp; AVR32_SDRAMC_CR_TRCD_MASK) |
+      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TRAS_OFFSET) &amp; AVR32_SDRAMC_CR_TRAS_MASK) |
+      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) &lt;&lt; AVR32_SDRAMC_CR_TXSR_OFFSET) &amp; AVR32_SDRAMC_CR_TXSR_MASK);
+  AVR32_SDRAMC.cr;
+
+  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+
+  // Wait during the SDRAM stable-clock initialization delay.
+  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
+
+  // Issue a PRECHARGE ALL command to the SDRAM.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
+
+  // Issue initialization AUTO REFRESH commands to the SDRAM.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
+  AVR32_SDRAMC.mr;
+  for (i = 0; i &lt; SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
+  {
+    sdram[0];
+    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
+  }
+
+  // Issue a LOAD MODE REGISTER command to the SDRAM.
+  // This configures the SDRAM with the following parameters in the mode register:
+  //  - bits 0 to 2: burst length: 1 (000b);
+  //  - bit 3: burst type: sequential (0b);
+  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
+  //  - bits 7 to 8: operating mode: standard operation (00b);
+  //  - bit 9: write burst mode: programmed burst length (0b);
+  //  - all other bits: reserved: 0b.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
+
+  // Switch the SDRAM Controller to normal mode.
+  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
+  AVR32_SDRAMC.mr;
+  sdram[0];
+
+  // Write the refresh period into the SDRAMC Refresh Timer Register.
+  // tR is rounded down because it is a maximal value.
+  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
+  AVR32_SDRAMC.tr;
+}

Added: trunk/src/platform/avr32/sdramc.h
===================================================================
--- trunk/src/platform/avr32/sdramc.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/sdramc.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,84 @@
+/* This header file is part of the ATMEL AVR32-SoftwareFramework-1.3.0-AT32UC3A Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief SDRAMC on EBI driver for AVR32 UC3.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 devices with an SDRAMC module can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: <A HREF="http://www.atmel.com">http://www.atmel.com</A> \n
+ *                       Support and FAQ: <A HREF="http://support.atmel.no/">http://support.atmel.no/</A>
+ *
+ ******************************************************************************/
+
+/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of ATMEL may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
+ * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef _SDRAMC_H_
+#define _SDRAMC_H_
+
+#include &lt;avr32/io.h&gt;
+#include &quot;board.h&quot;
+
+#ifdef SDRAM_PART_HDR
+  #include SDRAM_PART_HDR
+#else
+  #error No SDRAM header file defined
+#endif
+
+
+//! Pointer to SDRAM.
+#define SDRAM           ((void *)AVR32_EBI_CS1_ADDRESS)
+
+//! SDRAM size.
+#define SDRAM_SIZE      (1 &lt;&lt; (SDRAM_BANK_BITS + \
+                               SDRAM_ROW_BITS  + \
+                               SDRAM_COL_BITS  + \
+                               (SDRAM_DBW &gt;&gt; 4)))
+
+
+/*! \brief Initializes the AVR32 SDRAM Controller and the connected SDRAM(s).
+ *
+ * \param hsb_hz HSB frequency in Hz (the HSB frequency is applied to the SDRAMC
+ *               and to the SDRAM).
+ *
+ * \note HMATRIX and SDRAMC registers are always read with a dummy load
+ *       operation after having been written to, in order to force write-back
+ *       before executing the following accesses, which depend on the values set
+ *       in these registers.
+ *
+ * \note Each access to the SDRAM address space validates the mode of the SDRAMC
+ *       and generates an operation corresponding to this mode.
+ */
+extern void sdramc_init(unsigned long hsb_hz);
+
+
+#endif  // _SDRAMC_H_

Modified: trunk/src/platform/avr32/stacks.h
===================================================================
--- trunk/src/platform/avr32/stacks.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/avr32/stacks.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -3,7 +3,7 @@
 #ifndef __STACKS_H__
 #define __STACKS_H__
 
-#define  STACK_SIZE       512
+#define  STACK_SIZE       8192
 #define  STACK_SIZE_TOTAL ( STACK_SIZE )
 
 #endif

Modified: trunk/src/platform/i386/platform.c
===================================================================
--- trunk/src/platform/i386/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/i386/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -92,7 +92,7 @@
 {
 }
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   return -1;
 }

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/lm3s/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -293,7 +293,7 @@
   UARTCharPut( uart_base[ id ], data );
 }
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   u32 base = uart_base[ id ];
 

Modified: trunk/src/platform/lm3s/stacks.h
===================================================================
--- trunk/src/platform/lm3s/stacks.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/lm3s/stacks.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -3,7 +3,7 @@
 #ifndef __STACKS_H__
 #define __STACKS_H__
 
-#define  STACK_SIZE       512
+#define  STACK_SIZE       2048
 #define  STACK_SIZE_TOTAL ( STACK_SIZE )
 
 #endif

Modified: trunk/src/platform/lpc288x/platform.c
===================================================================
--- trunk/src/platform/lpc288x/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/lpc288x/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -120,7 +120,7 @@
   uart_write( data );
 }
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   if( timeout == 0 )
   {

Modified: trunk/src/platform/lpc288x/stacks.h
===================================================================
--- trunk/src/platform/lpc288x/stacks.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/lpc288x/stacks.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -3,7 +3,7 @@
 #ifndef __STACKS_H__
 #define __STACKS_H__
 
-#define STACK_SIZE_SVC   512
+#define STACK_SIZE_SVC   8192
 #define STACK_SIZE_IRQ   32
 #define STACK_SIZE_TOTAL ( STACK_SIZE_SVC + STACK_SIZE_IRQ )
 

Modified: trunk/src/platform/stm32/platform.c
===================================================================
--- trunk/src/platform/stm32/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/stm32/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -485,7 +485,7 @@
   USART_SendData(usart[id], data);
 }
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   if( timeout == 0 )
   {

Modified: trunk/src/platform/stm32/stm32.ld
===================================================================
--- trunk/src/platform/stm32/stm32.ld	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/stm32/stm32.ld	2009-01-22 19:46:47 UTC (rev 162)
@@ -13,7 +13,7 @@
 These are used by the startup in order to allocate stacks for the different modes.
 */
 
-__Stack_Size = 1024 ;
+__Stack_Size = 2048 ;
 
 PROVIDE ( _Stack_Size = __Stack_Size ) ;
 

Modified: trunk/src/platform/str7/platform.c
===================================================================
--- trunk/src/platform/str7/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str7/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -180,7 +180,7 @@
   UART_ByteSend( pport, &amp;data );
 }
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   UART_TypeDef* pport = ( UART_TypeDef* )uart_periph[ id ];    
   

Modified: trunk/src/platform/str7/stacks.h
===================================================================
--- trunk/src/platform/str7/stacks.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str7/stacks.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -3,7 +3,7 @@
 #ifndef __STACKS_H__
 #define __STACKS_H__
 
-#define  STACK_SIZE_USR   512
+#define  STACK_SIZE_USR   2048
 #define  STACK_SIZE_TOTAL ( STACK_SIZE_USR )
 
 #endif

Added: trunk/src/platform/str9/91x_it.h
===================================================================
--- trunk/src/platform/str9/91x_it.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/91x_it.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,73 @@
+/******************** (C) COPYRIGHT 2006 STMicroelectronics ********************
+* File Name          : 91x_it.h
+* Author             : MCD Application Team
+* Date First Issued  : 05/18/2006 : Version 1.0
+* Description        : This file contains the headers of the interrupt
+*                      handlers'routines
+********************************************************************************
+* History:
+* 05/24/2006 : Version 1.1
+* 05/18/2006 : Version 1.0
+********************************************************************************
+* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH
+* CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS
+* A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
+* OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT
+* OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION
+* CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Define to prevent recursive inclusion ------------------------------------ */
+#ifndef _91x_IT_H
+#define _91x_IT_H
+
+/* Includes ------------------------------------------------------------------*/
+//#include &quot;91x_lib.h&quot;
+
+/* Exported types ------------------------------------------------------------*/
+/* Exported constants --------------------------------------------------------*/
+/* Module private variables --------------------------------------------------*/
+/* Exported macro ------------------------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+/* Exported functions ------------------------------------------------------- */
+void Undefined_Handler  (void);
+void SWI_Handler        (void);
+void Prefetch_Handler   (void);
+void Abort_Handler      (void);
+void FIQ_Handler      (void);
+void WDG_IRQHandler      (void);
+void SW_IRQHandler       (void);
+void ARMRX_IRQHandler    (void);
+void ARMTX_IRQHandler    (void);
+void TIM0_IRQHandler     (void);
+void TIM1_IRQHandler     (void);
+void TIM2_IRQHandler     (void);
+void TIM3_IRQHandler     (void);
+void USBHP_IRQHandler    (void);
+void USBLP_IRQHandler    (void);
+void SCU_IRQHandler      (void);
+void ENET_IRQHandler    (void);
+void DMA_IRQHandler      (void);
+void CAN_IRQHandler      (void);
+void MC_IRQHandler       (void);
+void ADC_IRQHandler      (void);
+void UART0_IRQHandler    (void);
+void UART1_IRQHandler    (void);
+void UART2_IRQHandler    (void);
+void I2C0_IRQHandler     (void);
+void I2C1_IRQHandler     (void);
+void SSP0_IRQHandler     (void);
+void SSP1_IRQHandler     (void);
+void LVD_IRQHandler      (void);
+void RTC_IRQHandler      (void);
+void WIU_IRQHandler      (void);
+void EXTIT0_IRQHandler   (void);
+void EXTIT1_IRQHandler   (void);
+void EXTIT2_IRQHandler   (void);
+void EXTIT3_IRQHandler   (void);
+void USBWU_IRQHandler    (void);
+void PFQBC_IRQHandler    (void);
+
+#endif /* _91x_IT_H */
+
+/******************* (C) COPYRIGHT 2006 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/str9/91x_vic.c
===================================================================
--- trunk/src/platform/str9/91x_vic.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/91x_vic.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,834 @@
+/******************** (C) COPYRIGHT 2006 STMicroelectronics ********************
+* File Name          : 91x_vic.c
+* Author             : MCD Application Team
+* Date First Issued  : 05/18/2006 : Version 1.0
+* Description        : This file provides all the VIC software functions.
+********************************************************************************
+* History:
+* 05/24/2006 : Version 1.1
+* 05/18/2006 : Version 1.0
+********************************************************************************
+* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH
+* CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS
+* A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
+* OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT
+* OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION
+* CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+
+/* Standard include ----------------------------------------------------------*/
+#include &quot;91x_vic.h&quot;
+#include &quot;91x_scu.h&quot;
+
+/* Include of other module interface headers ---------------------------------*/
+/* Local includes ------------------------------------------------------------*/
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+#define VIC_REGISTER_NUMBER              16
+#define VIC_PROTECTION_ENABLE_MASK       0x1
+#define VIC_PROTECTION_DISABLE_MASK      0xFFFFFFFE
+#define VIC_VECTOR_ENABLE_MASK           0x20
+#define VIC_IT_SOURCE_MASK               0xFFFFFFE0
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+
+static void VIC_ITModeConfig(u16 VIC_Source, VIC_ITLineMode VIC_LineMode);
+static void VIC_ISRVectAddConfig(u16 VIC_Source, u16 VIC_Priority, \
+                                 void (*VIC_VectAddress)(void));
+static void VIC_VectEnableConfig(u16 VIC_Source, u16 VIC_Priority);
+static void VIC_ITSourceConfig(u16 VIC_Source, u16 VIC_Priority);
+
+/* Interface functions -------------------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : VIC_DeInit
+* Description    : Deinitialize the VIC module registers to their default reset
+*                  values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void VIC_DeInit(void)
+{
+  SCU_AHBPeriphReset(__VIC, ENABLE);     /* VIC peripheral is under Reset */
+  SCU_AHBPeriphReset(__VIC, DISABLE);    /* VIC peripheral Reset off */
+}
+
+/*******************************************************************************
+* Function Name  : VIC_GetIRQStatus
+* Description    : Get the status of interrupts after IRQ masking.
+* Input          : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Output         : None
+* Return         : The status of the IRQ interrupt after masking (SET or RESET).
+*******************************************************************************/
+FlagStatus VIC_GetIRQStatus(u16 VIC_Source)
+{
+  u32 VIC_Mask = 1;
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER)
+  {
+    if ((VIC0-&gt;ISR | VIC_Mask &lt;&lt; VIC_Source) != RESET)
+      return SET;
+    else
+      return RESET;
+  }
+  else
+  {
+    if ((VIC1-&gt;ISR | VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER)) != RESET)
+      return SET;
+    else
+      return RESET;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_GetFIQStatus
+* Description    : Get the status of interrupts after FIQ masking
+* Input          : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Output         : None
+* Return         : The status of the FIQ interrupt after masking (SET or RESET)
+*******************************************************************************/
+FlagStatus VIC_GetFIQStatus(u16 VIC_Source)
+{
+  u32 VIC_Mask = 1;
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER)
+  {
+    if ((VIC0-&gt;RINTSR | VIC_Mask &lt;&lt; VIC_Source) != RESET)
+      return SET;
+    else
+      return RESET;
+  }
+  else
+  {
+    if ((VIC1-&gt;RINTSR | VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER)) != RESET)
+      return SET;
+    else
+      return RESET;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_GetSourceITStatus
+* Description    : Get the status of the source interrupts before masking.
+* Input          : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Output         : None
+* Return         : The status of the source interrupt before masking
+*******************************************************************************/
+FlagStatus VIC_GetSourceITStatus(u16 VIC_Source)
+{
+  u32 VIC_Mask = 1;
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER)
+  {
+    if ((VIC0-&gt;FSR | VIC_Mask &lt;&lt; VIC_Source) != RESET)
+      return SET;
+    else
+      return RESET;
+  }
+  else
+  {
+    if ((VIC1-&gt;FSR | VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER)) != RESET)
+      return SET;
+    else
+      return RESET;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_ITModeConfig
+* Description    : Select the type of interrupt (IRQ or FIQ)
+* Input1         : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Input2         : VIC_LineMode :specifies the type of interrupt of the source
+*                  line. This parameter can be one of the following values:
+*                     - VIC_IRQ: the correspondent line is configured as IRQ.
+*                     - VIC_FIQ: the correspondent line is configured as FIQ.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void VIC_ITModeConfig(u16 VIC_Source, VIC_ITLineMode VIC_LineMode)
+{
+  u32 VIC_Mask = 1;
+
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER) /* VIC0 */
+  {
+    if (VIC_LineMode == VIC_IRQ)
+      VIC0-&gt;INTSR &amp;= ~(VIC_Mask &lt;&lt; VIC_Source);
+    else /* VIC_LineMode == VIC_FIQ */
+      VIC0-&gt;INTSR |= (VIC_Mask &lt;&lt; VIC_Source);
+  }
+  else /* VIC1 */
+  {
+    if (VIC_LineMode == VIC_IRQ)
+      VIC1-&gt;INTSR &amp;= ~(VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER));
+    else /* VIC_LineMode == VIC_FIQ */
+      VIC1-&gt;INTSR |= (VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER));
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_ITCmd
+* Description    : Enable or disable the interrupt request lines.
+* Input1         : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Input2         : FMI_NewState: specifies the line status.
+*                  This parameter can be one of the following values:
+*                     - ENABLE:  The line is enabled.
+*                     - DISABLE: The line is disabled.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void VIC_ITCmd(u16 VIC_Source, FunctionalState VIC_NewState)
+{
+  u32 VIC_Mask = 1;
+
+  if (VIC_NewState == ENABLE)
+  {
+    if (VIC_Source &lt; VIC_REGISTER_NUMBER)  /* VIC0 */
+      VIC0-&gt;INTER |= (VIC_Mask &lt;&lt; VIC_Source);
+    else /* VIC1 */
+      VIC1-&gt;INTER |= (VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER));
+  }
+  else /* VIC_NewState == DISABLE */
+  {
+    if (VIC_Source &lt; VIC_REGISTER_NUMBER)  /* VIC0 */
+      VIC0-&gt;INTECR |= (VIC_Mask &lt;&lt; VIC_Source);
+    else /* VIC1 */
+      VIC1-&gt;INTECR |= (VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER));
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_SWITCmd
+* Description    : Generate a software interrupt for the specific source 
+*                  interrupt.
+* Input1         : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Input2         : FMI_NewState: specifies the software interrupt status.
+*                  This parameter can be one of the following values:
+*                     - ENABLE:  The software interrupt is enabled.
+*                     - DISABLE: The software interrupt is disabled.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void VIC_SWITCmd(u16 VIC_Source, FunctionalState VIC_NewState)
+{
+  u32 VIC_Mask = 1;
+
+  if (VIC_NewState == ENABLE)
+  {
+    if (VIC_Source &lt; VIC_REGISTER_NUMBER)  /* VIC0 */
+      VIC0-&gt;SWINTR |= (VIC_Mask &lt;&lt; VIC_Source);
+    else /* VIC1 */
+      VIC1-&gt;SWINTR |= (VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER));
+  }
+  else /* VIC_NewState == DISABLE */
+  {
+    if (VIC_Source &lt; VIC_REGISTER_NUMBER)  /* VIC0 */
+      VIC0-&gt;SWINTCR = (VIC_Mask &lt;&lt; VIC_Source);
+    else /* VIC1 */
+      VIC1-&gt;SWINTCR = (VIC_Mask &lt;&lt; (VIC_Source - VIC_REGISTER_NUMBER));
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_ProtectionCmd
+* Description    : Enable or Disable the register access protection.
+* Input          : FMI_NewState: specifies the protection status.
+*                  This parameter can be one of the following values:
+*                     - ENABLE:  The protection is enabled.
+*                     - DISABLE: The protection is disabled.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void VIC_ProtectionCmd(FunctionalState VIC_NewState)
+{
+  if (VIC_NewState == ENABLE)
+  {
+    VIC0-&gt;PER |= VIC_PROTECTION_ENABLE_MASK;
+    VIC1-&gt;PER |= VIC_PROTECTION_ENABLE_MASK;
+  }
+  else
+  {
+    VIC0-&gt;PER &amp;= VIC_PROTECTION_DISABLE_MASK;
+    VIC1-&gt;PER &amp;= VIC_PROTECTION_DISABLE_MASK;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_GetCurrentISRAdd
+* Description    : Get the address of the current active ISR.
+* Input          : VICx: specifies the VIC peripheral
+*                  This parameter can be one of the following values:
+*                     - VIC0: To select VIC0.
+*                     - VIC1: To select VIC1.
+* Output         : None
+* Return         : The Address of the active ISR.
+*******************************************************************************/
+u32 VIC_GetCurrentISRAdd(VIC_TypeDef* VICx)
+{
+  return VICx-&gt;VAR;
+}
+
+/*******************************************************************************
+* Function Name  : VIC_ISRVectAddConfig
+* Description    : Configuration of the ISR vector address.
+* Input1         : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Input2         : VIC_Priority: specifies the priority of the interrupt.
+*                  It can be a value from 0 to 15. 0 is the highest priority.
+* Input3         : void (*VIC_VectAddress)(void): specifies the ISR vector 
+*                  address pointer.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void VIC_ISRVectAddConfig(u16 VIC_Source, u16 VIC_Priority, \
+                          void (*VIC_VectAddress)(void))
+{
+/* fix for GCC adress error on __attribute__ ((interrupt (&quot;IRQ&quot;))) void int_handler(void) */
+//  if (*(u32 *)VIC_VectAddress == 0xe24ee004)
+//     VIC_VectAddress += 4;
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER) /* VIC0 */
+    VIC0-&gt;VAiR[VIC_Priority] = (u32)VIC_VectAddress;
+  else /* VIC1 */
+    VIC1-&gt;VAiR[VIC_Priority] = (u32)VIC_VectAddress;
+}
+
+/*******************************************************************************
+* Function Name  : VIC_GetISRVectAdd
+* Description    : Get the ISR vector address of the correspondent line.
+* Input          : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Output         : None
+* Return         : The correspondent ISR vector address.
+*******************************************************************************/
+u32 VIC_GetISRVectAdd(u16 VIC_Source)
+{
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER) /* VIC0 */
+    return VIC0-&gt;VAiR[VIC_Source];
+  else /* VIC1 */
+    return VIC1-&gt;VAiR[VIC_Source - VIC_REGISTER_NUMBER];
+}
+
+/*******************************************************************************
+* Function Name  : VIC_VectEnableConfig
+* Description    : Enable the vector interrupt.
+* Input1         : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Input2         : VIC_Priority: specifies the priority of the interrupt.
+*                  It can be a value from 0 to 15. 0 is the highest priority.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void VIC_VectEnableConfig(u16 VIC_Source, u16 VIC_Priority)
+{
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER) /* VIC0 */
+    VIC0-&gt;VCiR[VIC_Priority] |= VIC_VECTOR_ENABLE_MASK;
+  else /* VIC1 */
+    VIC1-&gt;VCiR[VIC_Priority] |= VIC_VECTOR_ENABLE_MASK;
+}
+
+/*******************************************************************************
+* Function Name  : VIC_ITSourceConfig
+* Description    : Select the interrupt source.
+* Input1         : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Input2         : VIC_Priority: specifies the priority of the interrupt.
+*                  It can be a value from 0 to 15. 0 is the highest priority.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void VIC_ITSourceConfig(u16 VIC_Source, u16 VIC_Priority)
+{
+  if (VIC_Source &lt; VIC_REGISTER_NUMBER) /* VIC0 */
+  {
+    VIC0-&gt;VCiR[VIC_Priority] &amp;= VIC_IT_SOURCE_MASK;
+    VIC0-&gt;VCiR[VIC_Priority] |= VIC_Source;
+  }
+  else /* VIC1 */
+  {
+    VIC1-&gt;VCiR[VIC_Priority] &amp;= VIC_IT_SOURCE_MASK;
+    VIC1-&gt;VCiR[VIC_Priority] |= VIC_Source - VIC_REGISTER_NUMBER;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : VIC_Config
+* Description    : Configure the ISR, the line, the mode and the priority for 
+*                  each interrupt source line.
+* Input1         : VIC_Source: specifies the number of the source line.
+*                  This parameter can be one of the following values:
+*                     - WDG_ITLine   : VIC source 0
+*                     - SW_ITLine    : VIC source 1
+*                     - ARMRX_ITLine : VIC source 2
+*                     - ARMTX_ITLine : VIC source 3
+*                     - TIM0_ITLine  : VIC source 4
+*                     - TIM1_ITLine  : VIC source 5
+*                     - TIM2_ITLine  : VIC source 6
+*                     - TIM3_ITLine  : VIC source 7
+*                     - USBHP_ITLine : VIC source 8
+*                     - USBLP_ITLine : VIC source 9
+*                     - SCU_ITLine   : VIC source 10
+*                     - ENET_ITLine  : VIC source 11
+*                     - DMA_ITLine   : VIC source 12
+*                     - CAN_ITLine   : VIC source 13
+*                     - MC_ITLine    : VIC source 14
+*                     - ADC_ITLine   : VIC source 15
+*                     - UART0_ITLine : VIC source 16
+*                     - UART1_ITLine : VIC source 17
+*                     - UART2_ITLine : VIC source 18
+*                     - I2C0_ITLine  : VIC source 19
+*                     - I2C1_ITLine  : VIC source 20
+*                     - SSP0_ITLine  : VIC source 21
+*                     - SSP1_ITLine  : VIC source 22
+*                     - LVD_ITLine   : VIC source 23
+*                     - RTC_ITLine   : VIC source 24
+*                     - WIU_ITLine   : VIC source 25
+*                     - EXTIT0_ITLine: VIC source 26
+*                     - EXTIT1_ITLine: VIC source 27
+*                     - EXTIT2_ITLine: VIC source 28
+*                     - EXTIT3_ITLine: VIC source 29
+*                     - USBWU_ITLine : VIC source 30
+*                     - PFQBC_ITLine : VIC source 31
+* Input2         : VIC_LineMode :specifies the type of interrupt of the source
+*                  line. This parameter can be one of the following values:
+*                     - VIC_IRQ: the correspondent line is configured as IRQ.
+*                     - VIC_FIQ: the correspondent line is configured as FIQ.
+* Input3         : VIC_Priority: specifies the priority of the interrupt.
+*                  It can be a value from 0 to 15. 0 is the highest priority.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void VIC_Config(u16 VIC_Source, VIC_ITLineMode VIC_LineMode, u8 VIC_Priority)
+{
+  switch (VIC_Source)
+  {
+    case 0:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, WDG_IRQHandler);
+             break;
+
+    case 1:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, SW_IRQHandler);
+             break;
+
+    case 2:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, ARMRX_IRQHandler);
+             break;
+
+    case 3:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, ARMTX_IRQHandler);
+             break;
+
+    case 4:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, TIM0_IRQHandler);
+             break;
+
+    case 5:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, TIM1_IRQHandler);
+             break;
+
+    case 6:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, TIM2_IRQHandler);
+             break;
+
+    case 7:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, TIM3_IRQHandler);
+             break;
+
+    case 8:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, USBHP_IRQHandler);
+             break;
+
+    case 9:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, USBLP_IRQHandler);
+             break;
+
+    case 10:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, SCU_IRQHandler);
+              break;
+
+    case 11:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, ENET_IRQHandler);
+              break;
+
+    case 12:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, DMA_IRQHandler);
+              break;
+
+    case 13:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, CAN_IRQHandler);
+              break;
+
+    case 14:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, MC_IRQHandler);
+              break;
+
+    case 15:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, ADC_IRQHandler);
+              break;
+
+    case 16:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, UART0_IRQHandler);
+              break;
+
+    case 17:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, UART1_IRQHandler);
+              break;
+
+    case 18:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, UART2_IRQHandler);
+              break;
+
+    case 19:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, I2C0_IRQHandler);
+              break;
+
+    case 20:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, I2C1_IRQHandler);
+              break;
+
+    case 21:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, SSP0_IRQHandler);
+              break;
+
+    case 22:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, SSP1_IRQHandler);
+              break;
+
+    case 23:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, LVD_IRQHandler);
+              break;
+
+    case 24:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, RTC_IRQHandler);
+              break;
+
+    case 25:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, WIU_IRQHandler);
+              break;
+
+    case 26:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, EXTIT0_IRQHandler);
+              break;
+
+    case 27:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, EXTIT1_IRQHandler);
+              break;
+
+    case 28:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, EXTIT2_IRQHandler);
+              break;
+
+    case 29:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, EXTIT3_IRQHandler);
+              break;
+
+    case 30:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, USBWU_IRQHandler);
+              break;
+
+    case 31:  VIC_ISRVectAddConfig(VIC_Source, VIC_Priority, PFQBC_IRQHandler);
+              break;
+
+    default:  break;
+  }
+  VIC_ITModeConfig(VIC_Source, VIC_LineMode);
+  VIC_VectEnableConfig(VIC_Source, VIC_Priority);
+  VIC_ITSourceConfig(VIC_Source, VIC_Priority);
+}
+
+/******************* (C) COPYRIGHT 2006 STMicroelectronics *****END OF FILE****/

Added: trunk/src/platform/str9/91x_vic.h
===================================================================
--- trunk/src/platform/str9/91x_vic.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/91x_vic.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,94 @@
+/******************** (C) COPYRIGHT 2006 STMicroelectronics ********************
+* File Name          : 91x_vic.h
+* Author             : MCD Application Team
+* Date First Issued  : 05/18/2006 : Version 1.0
+* Description        : This file contains all the functions prototypes for the
+*                      VIC software library.
+********************************************************************************
+* History:
+* 05/24/2006 : Version 1.1
+* 05/18/2006 : Version 1.0
+********************************************************************************
+* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH
+* CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS
+* A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
+* OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT
+* OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION
+* CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+
+/* Define to prevent recursive inclusion ------------------------------------ */
+#ifndef __91x_VIC_H
+#define __91x_VIC_H
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;91x_map.h&quot;
+#include &quot;91x_it.h&quot;
+
+/* Exported types ------------------------------------------------------------*/
+/* Type of interrupt */
+typedef enum
+{
+ VIC_IRQ,
+ VIC_FIQ
+} VIC_ITLineMode;
+
+/* Exported constants --------------------------------------------------------*/
+
+/* VIC sources*/
+
+#define WDG_ITLine        0
+#define SW_ITLine         1
+#define ARMRX_ITLine      2
+#define ARMTX_ITLine      3
+#define TIM0_ITLine       4
+#define TIM1_ITLine       5
+#define TIM2_ITLine       6
+#define TIM3_ITLine       7
+#define USBHP_ITLine      8
+#define USBLP_ITLine      9
+#define SCU_ITLine        10
+#define ENET_ITLine      11
+#define DMA_ITLine        12
+#define CAN_ITLine        13
+#define MC_ITLine         14
+#define ADC_ITLine        15
+#define UART0_ITLine      16
+#define UART1_ITLine      17
+#define UART2_ITLine      18
+#define I2C0_ITLine       19
+#define I2C1_ITLine       20
+#define SSP0_ITLine       21
+#define SSP1_ITLine       22
+#define LVD_ITLine        23
+#define RTC_ITLine        24
+#define WIU_ITLine        25
+#define EXTIT0_ITLine     26
+#define EXTIT1_ITLine     27
+#define EXTIT2_ITLine     28
+#define EXTIT3_ITLine     29
+#define USBWU_ITLine      30
+#define PFQBC_ITLine      31
+
+
+/* Module private variables --------------------------------------------------*/
+/* Exported macro ------------------------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+/* Exported functions ------------------------------------------------------- */
+
+void VIC_DeInit(void);
+FlagStatus VIC_GetIRQStatus(u16 VIC_Source);
+FlagStatus VIC_GetFIQStatus(u16 VIC_Source);
+FlagStatus VIC_GetSourceITStatus(u16 VIC_Source);
+void VIC_ITCmd(u16 VIC_Source, FunctionalState VIC_NewState);
+void VIC_SWITCmd(u16 VIC_Source, FunctionalState VIC_NewState);
+void VIC_ProtectionCmd(FunctionalState VIC_NewState);
+u32 VIC_GetCurrentISRAdd(VIC_TypeDef* VICx);
+u32 VIC_GetISRVectAdd(u16 VIC_Source);
+void VIC_Config(u16 VIC_Source, VIC_ITLineMode VIC_LineMode, u8 VIC_Priority);
+
+#endif /* __91x_VIC_H */
+
+/******************* (C) COPYRIGHT 2006 STMicroelectronics *****END OF FILE****/
+

Modified: trunk/src/platform/str9/conf.py
===================================================================
--- trunk/src/platform/str9/conf.py	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/conf.py	2009-01-22 19:46:47 UTC (rev 162)
@@ -2,7 +2,7 @@
 
 cpumode = ARGUMENTS.get( 'cpumode', 'arm' ).lower()
 
-specific_files = &quot;startup912.s startup_generic.s platform.c 91x_scu.c 91x_fmi.c 91x_gpio.c 91x_uart.c 91x_tim.c&quot;
+specific_files = &quot;startup912.s startup_generic.s platform.c 91x_scu.c 91x_fmi.c 91x_gpio.c 91x_uart.c 91x_tim.c 91x_vic.c interrupt.c&quot;
 
 # Check CPU
 if cputype == 'STR912FW44':

Added: trunk/src/platform/str9/interrupt.c
===================================================================
--- trunk/src/platform/str9/interrupt.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/interrupt.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -0,0 +1,292 @@
+/********************************************************************
+ * Project:    GNU-Str9-ComStick
+ * File:       interrupt.c
+ *
+ * System:     ARM9TDMI 32 Bit (STR912FW44X)
+ * Compiler:   GCC 4.0.3
+ *
+ * Date:       2006-12-20
+ * Author:     <A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">Application at Hitex.de</A>
+ *
+ * Rights:     Hitex Development Tools GmbH
+ *             Greschbachstr. 12
+ *             D-76229 Karlsruhe
+ ********************************************************************
+ * Description:
+ *
+ * This file is part of the GNU Example chain
+ * The code is based on usage of the STmicro library functions
+ * This is a small implementation of different features
+ * The application runs in ARM mode with high optimization level.
+ *
+ ********************************************************************
+ * History:
+ *
+ *    Revision 1.1    2007/02/17      Gn
+ *    Revision 1.0    2006/12/20      Gn
+ *    Initial revision
+ ********************************************************************
+ * This is a preliminary version.
+ *
+ * WARRANTY:  HITEX warrants that the media on which the SOFTWARE is
+ * furnished is free from defects in materials and workmanship under
+ * normal use and service for a period of ninety (90) days. HITEX entire
+ * liability and your exclusive remedy shall be the replacement of the
+ * SOFTWARE if the media is defective. This Warranty is void if failure
+ * of the media resulted from unauthorized modification, accident, abuse,
+ * or misapplication.
+ *
+ * DISCLAIMER:  OTHER THAN THE ABOVE WARRANTY, THE SOFTWARE IS FURNISHED
+ * &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND. HITEX DISCLAIMS ALL OTHER WARRANTIES,
+ * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * NEITHER HITEX NOR ITS AFFILIATES SHALL BE LIABLE FOR ANY DAMAGES ARISING
+ * OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE, INCLUDING DAMAGES FOR
+ * LOSS OF PROFITS, BUSINESS INTERRUPTION, OR ANY SPECIAL, INCIDENTAL, INDIRECT
+ * OR CONSEQUENTIAL DAMAGES EVEN IF HITEX HAS BEEN ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGES.
+ ********************************************************************/
+
+#define global extern   /* to declare external variables and functions      */
+
+/* switch to SYS mode and enable interrupts */
+#define SWITCH_IRQ_TO_SVC asm(&quot; mrs r2, spsr \n stmfd sp!,{r2,r14} \n msr CPSR_c,#0x13 \n stmfd sp!,{lr}&quot; )
+
+/* switch back to IRQ mode with IRQ disabled */
+#define SWITCH_SVC_TO_IRQ asm (&quot; ldmfd sp!,{lr} \n msr CPSR_c,#0x12|0x80 \n ldmfd sp!,{r2,r14} \n msr spsr, r2 &quot;)
+
+#define VICVectAddr (*((volatile unsigned long*)0xFFFFF030))
+
+/*******************************************************************************
+* Function Name  : Prefetch_Handler
+* Description    : This function handles preftetch abort exception.
+*******************************************************************************/
+void Prefetch_Handler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : WDG_IRQHandler
+* Description    : This function handles the WDG interrupt request
+*******************************************************************************/
+void WDG_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : SW_IRQHandler
+* Description    : This function handles the SW interrupt request
+*******************************************************************************/
+void SW_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : ARMRX_IRQHandler
+* Description    : This function handles the ARMRX interrupt request
+*******************************************************************************/
+void ARMRX_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : ARMTX_IRQHandler
+* Description    : This function handles the ARMTX interrupt request
+*******************************************************************************/
+void ARMTX_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : TIM0_IRQHandler
+* Description    : This function handles the TIM0 interrupt request
+*******************************************************************************/
+void TIM0_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : TIM1_IRQHandler
+* Description    : This function handles the TIM1 interrupt request
+*******************************************************************************/
+void TIM1_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : TIM2_IRQHandler
+* Description    : This function handles the TIM2 interrupt request
+*******************************************************************************/
+void TIM2_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : TIM3_IRQHandler
+* Description    : This function handles the TIM3 interrupt request
+*******************************************************************************/
+void TIM3_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : USBHP_IRQHandler
+* Description    : This function handles the USBHP interrupt request
+*******************************************************************************/
+void USBHP_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : USBLP_IRQHandler
+* Description    : This function handles the USBLP interrupt request
+*******************************************************************************/
+void USBLP_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : SCU_IRQHandler
+* Description    : This function handles the SCU interrupt request
+*******************************************************************************/
+void SCU_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : ENET_IRQHandler
+* Description    : This function handles the DENET interrupt request
+*******************************************************************************/
+void ENET_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : DMA_IRQHandler
+* Description    : This function handles the DMA interrupt request
+*******************************************************************************/
+void DMA_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : CAN_IRQHandler
+* Description    : This function handles the CAN interrupt request
+*******************************************************************************/
+void CAN_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : MC_IRQHandler
+* Description    : This function handles the MC interrupt request
+*******************************************************************************/
+void MC_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : ADC_IRQHandler
+* Description    : This function handles the ADC interrupt request
+*******************************************************************************/
+void ADC_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : UART0_IRQHandler
+* Description    : This function handles the UART0 interrupt request
+*******************************************************************************/
+void UART0_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : UART1_IRQHandler
+* Description    : This function handles the UART1 interrupt request
+*******************************************************************************/
+void UART1_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : UART2_IRQHandler
+* Description    : This function handles the UART2 interrupt request
+*******************************************************************************/
+void UART2_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : I2C0_IRQHandler
+* Description    : This function handles the I2C0 interrupt request
+*******************************************************************************/
+void I2C0_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : I2C1_IRQHandler
+* Description    : This function handles the I2C1 interrupt request
+*******************************************************************************/
+void I2C1_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : SSP0_IRQHandler
+* Description    : This function handles the SSP0 interrupt request
+*******************************************************************************/
+void SSP0_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : SSP1_IRQHandler
+* Description    : This function handles the SSP1 interrupt request
+*******************************************************************************/
+void SSP1_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : LVD_IRQHandler
+* Description    : This function handles the LVD interrupt request
+*******************************************************************************/
+void LVD_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : RTC_IRQHandler
+* Description    : This function handles the RTC interrupt request
+*******************************************************************************/
+void RTC_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : WIU_IRQHandler
+* Description    : This function handles the WIU interrupt request
+*******************************************************************************/
+void WIU_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : EXTIT0_IRQHandler
+* Description    : This function handles the EXTIT0 interrupt request
+*******************************************************************************/
+void EXTIT0_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : EXTIT1_IRQHandler
+* Description    : This function handles the EXTIT1 interrupt request
+*******************************************************************************/
+void EXTIT1_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : EXTIT2_IRQHandler
+* Description    : This function handles the EXTIT2 interrupt request
+*******************************************************************************/
+void EXTIT2_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : EXTIT3_IRQHandler
+* Description    : This function handles the EXTIT3 interrupt request
+*******************************************************************************/
+void EXTIT3_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : USBWU_IRQHandler
+* Description    : This function handles the USBWU interrupt request
+*******************************************************************************/
+void USBWU_IRQHandler(void)
+{
+}
+/*******************************************************************************
+* Function Name  : PFQBC_IRQHandler
+* Description    : This function handles the PFQBC interrupt request
+*******************************************************************************/
+void PFQBC_IRQHandler(void)
+{
+}
+

Modified: trunk/src/platform/str9/platform.c
===================================================================
--- trunk/src/platform/str9/platform.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/platform.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -17,6 +17,7 @@
 #include &quot;91x_tim.h&quot;
 #include &quot;common.h&quot;
 #include &quot;platform_conf.h&quot;
+#include &quot;91x_vic.h&quot;
 
 // We define here the UART used by this porting layer
 #define STR9_UART         UART1
@@ -75,10 +76,13 @@
   // PIO setup
   for( i = 0; i &lt; 10; i ++ )
     GPIO_DeInit( ( GPIO_TypeDef* )port_data[ i ] );
+    
+  // Initialize VIC
+  VIC_DeInit();
   
   // UART setup (only STR9_UART is used in this example)
   platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
-  
+
   // Initialize timers
   for( i = 0; i &lt; 4; i ++ )
   {
@@ -204,7 +208,7 @@
   UART_InitStructure.UART_BaudRate = baud;
   UART_InitStructure.UART_HardwareFlowControl = UART_HardwareFlowControl_None;
   UART_InitStructure.UART_Mode = UART_Mode_Tx_Rx;
-  UART_InitStructure.UART_FIFO = UART_FIFO_Enable; //UART_FIFO_Enable;
+  UART_InitStructure.UART_FIFO = UART_FIFO_Enable;
   UART_InitStructure.UART_TxFIFOLevel = UART_FIFOLevel_1_2; /* FIFO size 16 bytes, FIFO level 8 bytes */
   UART_InitStructure.UART_RxFIFOLevel = UART_FIFOLevel_1_2; /* FIFO size 16 bytes, FIFO level 8 bytes */
 
@@ -218,21 +222,22 @@
 void platform_uart_send( unsigned id, u8 data )
 {
   id = id;
-  while( UART_GetFlagStatus(STR9_UART, UART_FLAG_TxFIFOFull) == SET );
+//  while( UART_GetFlagStatus( STR9_UART, UART_FLAG_TxFIFOFull ) == SET );
   UART_SendData( STR9_UART, data );
+  while( UART_GetFlagStatus( STR9_UART, UART_FLAG_TxFIFOFull ) != RESET );  
 }
 
-int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, s32 timeout )
 {
   if( timeout == 0 )
   {
     // Return data only if already available
-    if( UART_GetFlagStatus(STR9_UART, UART_FLAG_RxFIFOEmpty) != SET )
+    if( UART_GetFlagStatus( STR9_UART, UART_FLAG_RxFIFOEmpty ) != SET )
       return UART_ReceiveData( STR9_UART );
     else
       return -1;
   }
-  while( UART_GetFlagStatus(STR9_UART, UART_FLAG_RxFIFOEmpty) == SET );
+  while( UART_GetFlagStatus( STR9_UART, UART_FLAG_RxFIFOEmpty ) == SET );
   return UART_ReceiveData( STR9_UART );
 }
 
@@ -319,3 +324,19 @@
   }
   return res;
 }
+
+// ****************************************************************************
+// CPU functions
+
+extern void enable_ints();
+extern void disable_ints();
+
+void platform_cpu_enable_interrupts()
+{
+  enable_ints();
+}
+
+void platform_cpu_disable_interrupts()
+{
+  disable_ints();
+}

Modified: trunk/src/platform/str9/platform_conf.h
===================================================================
--- trunk/src/platform/str9/platform_conf.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/platform_conf.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -72,6 +72,7 @@
   _ROM( AUXLIB_TERM, luaopen_term, term_map )\
   _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
+  _ROM( AUXLIB_CPU, luaopen_cpu, cpu_map)\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
 
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/str9/stacks.h
===================================================================
--- trunk/src/platform/str9/stacks.h	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/stacks.h	2009-01-22 19:46:47 UTC (rev 162)
@@ -3,8 +3,8 @@
 #ifndef __STACKS_H__
 #define __STACKS_H__
 
-#define STACK_SIZE_SVC   512
-#define STACK_SIZE_IRQ   32
+#define STACK_SIZE_SVC   2048
+#define STACK_SIZE_IRQ   64
 #define STACK_SIZE_TOTAL ( STACK_SIZE_SVC + STACK_SIZE_IRQ )
 
 #endif

Modified: trunk/src/platform/str9/startup912.s
===================================================================
--- trunk/src/platform/str9/startup912.s	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/platform/str9/startup912.s	2009-01-22 19:46:47 UTC (rev 162)
@@ -251,7 +251,7 @@
               sub     r0, r0, #STACK_SIZE_IRQ                  
 
 #    Set up Supervisor Mode and set Supervisor Mode Stack
-              msr     CPSR_c, #Mode_SVC
+              msr     CPSR_c, #Mode_SVC|F_BIT
               mov     r13, r0
 
 #*************************************************************************
@@ -278,6 +278,26 @@
 forever:
        B      forever
 
+# enable interrupts
+     .global    enable_ints
+enable_ints:
+      stmfd   sp!,  {r1}
+      mrs     r1, CPSR
+      bic     r1, r1, #I_BIT
+      msr     CPSR_c, r1
+      ldmfd   sp!, {r1}
+      mov     pc, r14
+
+# disable interrupts
+     .global disable_ints
+disable_ints:
+      stmfd    sp!, {r1}
+      mrs      r1, CPSR
+      orr      r1, r1, #I_BIT
+      msr      CPSR_c, r1
+      ldmfd    sp!, {r1}
+      mov      pc, r14
+
 #*************************************************************************
 # END
 #*************************************************************************   

Modified: trunk/src/shell.c
===================================================================
--- trunk/src/shell.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/shell.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -166,7 +166,6 @@
   printf( &quot;For more information go to <A HREF="http://www.eluaproject.net\n">http://www.eluaproject.net\n</A>&quot; );
 }
 
-
 // 'ls' and 'dir' handler
 static void shell_ls( char* args )
 {
@@ -189,8 +188,6 @@
   printf( &quot;\n\nTotal = %d bytes\n\n&quot;, total );
 }
 
-
-
 // Insert shell commands here
 static const SHELL_COMMAND shell_commands[] = 
 {
@@ -204,7 +201,6 @@
   { NULL, NULL }
 };
 
-
 // Execute the eLua &quot;shell&quot; in an infinite loop
 void shell_start()
 {

Modified: trunk/src/xmodem.c
===================================================================
--- trunk/src/xmodem.c	2009-01-22 03:25:09 UTC (rev 161)
+++ trunk/src/xmodem.c	2009-01-22 19:46:47 UTC (rev 162)
@@ -1,22 +1,35 @@
-/*! \file xmodem.c \brief XModem Transmit/Receive Implementation with CRC and 1K support. */
-//*****************************************************************************
-//
-// File Name  : 'xmodem.c'
-// Title    : XModem Transmit/Receive Implementation with CRC and 1K support
-// Author     : Pascal Stang - Copyright (C) 2006
-// Created    : 4/22/2006
-// Revised    : 7/22/2006
-// Version    : 0.1
-// Target MCU   : AVR processors
-// Editor Tabs  : 4
-//
-// This code is distributed under the GNU Public License
-//    which can be found at <A HREF="http://www.gnu.org/licenses/gpl.txt">http://www.gnu.org/licenses/gpl.txt</A>
-//
-//*****************************************************************************
-// Modified by BogdanM for the eLua project
-//*****************************************************************************
+/*-
+ * Copyright (c) 2006 M. Warner Losh.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This software is derived from software provide by Kwikbyte who specifically
+ * disclaimed copyright on the code.  This version of xmodem has been nearly
+ * completely rewritten, but the CRC is from the original.
+ *
+ * $FreeBSD: src/sys/boot/arm/at91/libat91/xmodem.c,v 1.1 2006/04/19 17:16:49 imp Exp $
+ */
 
+// Modified by BogdanM for eLua
+
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 #include &quot;xmodem.h&quot;
@@ -25,213 +38,146 @@
 #include &quot;platform_conf.h&quot;
 #ifdef BUILD_XMODEM
 
-#define XMODEM_BUFFER_SIZE    128
+#define PACKET_SIZE    128
 static p_xm_send_func xmodem_out_func;
 static p_xm_recv_func xmodem_in_func;
 
-typedef u16 uint16_t;
-typedef u8 uint8_t;
+// Line control codes
+#define SOH  0x01
+#define ACK  0x06
+#define NAK  0x15
+#define CAN  0x18
+#define EOT  0x04
 
-static uint16_t crc_xmodem_update(uint16_t crc, uint8_t data)
+// Arguments to xmodem_flush
+#define XMODEM_FLUSH_ONLY       0
+#define XMODEM_FLUSH_AND_CAN    1
+
+// Delay in &quot;flush packet&quot; mode
+#define XMODEM_PACKET_DELAY     10000UL
+
+void xmodem_init( p_xm_send_func send_func, p_xm_recv_func recv_func )
 {
-  int i;
+  xmodem_out_func = send_func;
+  xmodem_in_func = recv_func;
+}
 
-  crc = crc ^ ((uint16_t)data &lt;&lt; 8);
-  for (i=0; i&lt;8; i++)
+// Utility function: flush the receive buffer
+static void xmodem_flush( int how )
+{
+  while( xmodem_in_func( XMODEM_PACKET_DELAY ) != -1 );
+  if( how == XMODEM_FLUSH_AND_CAN )
   {
-    if(crc &amp; 0x8000)
-      crc = (crc &lt;&lt; 1) ^ 0x1021;
-    else
-      crc &lt;&lt;= 1;
+    xmodem_out_func( CAN );
+    xmodem_out_func( CAN );
+    xmodem_out_func( CAN );
   }
-
-  return crc;
 }
 
-static int xmodem_crc_check( int crcflag, const unsigned char *buffer, int size )
+// This private function receives a x-modem record to the pointer and
+// returns 1 on success and 0 on error
+static int xmodem_get_record( unsigned char blocknum, unsigned char *pbuf )
 {
-  // crcflag=0 - do regular checksum
-  // crcflag=1 - do CRC checksum
-
-  if(crcflag)
+  unsigned chk, j, size;
+  int ch;
+  
+  // Read packet
+  for( j = 0; j &lt; PACKET_SIZE + 4; j ++ )
   {
-    unsigned short crc=0;
-    unsigned short pktcrc = (buffer[size]&lt;&lt;8)+buffer[size+1];
-    // do CRC checksum
-    while(size--)
-      crc = crc_xmodem_update(crc, *buffer++);
-    // check checksum against packet
-    if(crc == pktcrc)
-      return 1;
+    if( ( ch = xmodem_in_func( XMODEM_TIMEOUT ) ) == -1 )
+      goto err;
+    pbuf[ j ] = ( unsigned char )ch;
   }
-  else
+
+  // Check block number
+  if( *pbuf ++ != blocknum )
+    goto err;
+  if( *pbuf ++ != ( unsigned char )~blocknum )
+    goto err;
+  // Check CRC
+  for( size = chk = 0; size &lt; PACKET_SIZE; size++, pbuf ++ ) 
   {
-    int i;
-    unsigned char cksum = 0;
-    // do regular checksum
-    for(i=0; i&lt;size; ++i)
+    chk = chk ^ *pbuf &lt;&lt; 8;
+    for( j = 0; j &lt; 8; j ++ ) 
     {
-      cksum += buffer[i];
+      if( chk &amp; 0x8000 )
+        chk = chk &lt;&lt; 1 ^ 0x1021;
+      else
+        chk = chk &lt;&lt; 1;
     }
-    // check checksum against packet
-    if(cksum == buffer[size])
-      return 1;
   }
-
+  chk &amp;= 0xFFFF;
+  if( *pbuf ++ != ( ( chk &gt;&gt; 8 ) &amp; 0xFF ) )
+    goto err;
+  if( *pbuf ++ != ( chk &amp; 0xFF ) )
+    goto err;
+  return 1;
+  
+err:
+  xmodem_out_func( NAK );
   return 0;
 }
 
-static void xmodem_flush(void)
+// This global function receives a x-modem transmission consisting of
+// (potentially) several blocks.  Returns the number of bytes received or
+// an error code an error
+long xmodem_receive( char **dest )
 {
-  while( xmodem_in_func( XMODEM_TIMEOUT_DELAY ) &gt;= 0 );
-}
-
-void xmodem_init( p_xm_send_func send_func, p_xm_recv_func recv_func )
-{
-  xmodem_out_func = send_func;
-  xmodem_in_func = recv_func;
-}
-
-long xmodem_receive( char** dest )
-{
-  unsigned char xmbuf[XMODEM_BUFFER_SIZE+6];
-  unsigned char seqnum=1;     // xmodem sequence number starts at 1
-  unsigned short pktsize=128;   // default packet size is 128 bytes
-  unsigned char response='C';   // solicit a connection with CRC
-  char retry=XMODEM_RETRY_LIMIT;
-  unsigned char crcflag=0;
-  unsigned long totalbytes=0;
-  int i,c;
-  u32 limit = XMODEM_INITIAL_BUFFER_SIZE;
+  int starting = 1, ch;
+  unsigned char packnum = 1, buf[ PACKET_SIZE + 4 ];
+  unsigned retries = XMODEM_RETRY_LIMIT;
+  u32 limit = XMODEM_INITIAL_BUFFER_SIZE, size = 0;
+  void *p;
   
-  while(retry &gt; 0)
+  while( retries-- ) 
   {
-    // solicit a connection/packet
-    xmodem_out_func(response);
-    // wait for start of packet
-    if( (c = xmodem_in_func(XMODEM_TIMEOUT_DELAY)) &gt;= 0)
+    if( starting )
+      xmodem_out_func( 'C' );
+    if( ( ( ch = xmodem_in_func( XMODEM_TIMEOUT ) ) == -1 ) || ( ch != SOH &amp;&amp; ch != EOT &amp;&amp; ch != CAN ) )
+      continue;
+    if( ch == EOT ) 
     {
-      switch(c)
-      {
-      case SOH:
-        pktsize = 128;
-        break;
-      case EOT:
-        xmodem_flush();
-        xmodem_out_func(ACK);
-        // completed transmission normally
-        return totalbytes;
-      case XMODEM_CAN:
-        if((c = xmodem_in_func(XMODEM_TIMEOUT_DELAY)) == XMODEM_CAN)
-        {
-          xmodem_flush();
-          xmodem_out_func(ACK);
-          // transaction cancelled by remote node
-          return XMODEM_ERROR_REMOTECANCEL;
-        }
-      default:
-        break;
-      }
+      // End of transmission
+      xmodem_out_func( ACK );
+      xmodem_flush( XMODEM_FLUSH_ONLY );
+      return size;
     }
-    else
+    else if( ch == CAN )
     {
-      // timed out, try again
-      // no need to flush because receive buffer is already empty
-      retry--;
-      //response = NAK;
-      continue;
+      // The remote part ended the transmission
+      xmodem_out_func( ACK );
+      xmodem_flush( XMODEM_FLUSH_ONLY );
+      return XMODEM_ERROR_REMOTECANCEL;      
     }
-
-    // check if CRC mode was accepted
-    if(response == 'C') crcflag = 1;
-    // got SOH/STX, add it to processing buffer
-    xmbuf[0] = c;
-    // try to get rest of packet
-    for(i=0; i&lt;(pktsize+crcflag+4-1); i++)
+    starting = 0;
+    
+    // Get XMODEM packet
+    if( !xmodem_get_record( packnum, buf ) )
+      continue; // allow for retransmission
+    xmodem_flush( XMODEM_FLUSH_ONLY );      
+    retries = XMODEM_RETRY_LIMIT;
+    packnum ++;
+      
+    // Got a valid packet
+    if( size + PACKET_SIZE &gt; limit )
     {
-      if((c = xmodem_in_func(XMODEM_TIMEOUT_DELAY)) &gt;= 0)
+      limit += XMODEM_INCREMENT_AMMOUNT;
+      if( ( p = realloc( *dest, limit ) ) == NULL )
       {
-        xmbuf[1+i] = c;
+        // Not enough memory, force cancel and return
+        xmodem_flush( XMODEM_FLUSH_AND_CAN );
+        return XMODEM_ERROR_OUTOFMEM;
       }
-      else
-      {
-        // timed out, try again
-        retry--;
-        xmodem_flush();
-        response = NAK;
-        break;
-      }
-    }
-    // packet was too small, retry
-    if(i&lt;(pktsize+crcflag+4-1))
-      continue;
-
-    // got whole packet
-    // check validity of packet
-    if(   (xmbuf[1] == (unsigned char)(~xmbuf[2])) &amp;&amp;     // sequence number was transmitted w/o error
-      xmodem_crc_check(crcflag, &amp;xmbuf[3], pktsize) ) // packet is not corrupt
-    {
-      // is this the packet we were waiting for?
-      if(xmbuf[1] == seqnum)
-      {
-        // write/deliver data
-        if( totalbytes + pktsize &gt; limit )
-        {
-          limit += XMODEM_INCREMENT_AMMOUNT;
-          if( ( *dest = realloc( *dest, limit ) ) == NULL )
-          {
-            // Cancel transmission
-            xmodem_flush();
-            xmodem_out_func(XMODEM_CAN);
-            xmodem_out_func(XMODEM_CAN);
-            xmodem_out_func(XMODEM_CAN);    
-            return XMODEM_ERROR_OUTOFMEM;   
-          }
-        }
-        memcpy( *dest + totalbytes, xmbuf + 3, pktsize );
-        totalbytes += pktsize;
-        // next sequence number
-        seqnum++;
-        // reset retries
-        retry = XMODEM_RETRY_LIMIT;
-        // reply with ACK
-        response = ACK;
-        continue;
-      }
-      else if(xmbuf[1] == (unsigned char)(seqnum-1))
-      {
-        // this is a retransmission of the last packet
-        // ACK and move on
-        response = ACK;
-        continue;
-      }
-      else
-      {
-        // we are completely out of sync
-        // cancel transmission
-        xmodem_flush();
-        xmodem_out_func(XMODEM_CAN);
-        xmodem_out_func(XMODEM_CAN);
-        xmodem_out_func(XMODEM_CAN);
-        return XMODEM_ERROR_OUTOFSYNC;
-      }
-    }
-    else
-    {
-      // packet was corrupt
-      // NAK it and try again
-      retry--;
-      xmodem_flush();
-      response = NAK;
-      continue;
-    }
+      *dest = ( char* )p;
+    }    
+    // Acknowledge and consume packet
+    xmodem_out_func( ACK );
+    memcpy( *dest + size, buf + 2, PACKET_SIZE );
+    size += PACKET_SIZE;
   }
-
-  // exceeded retry count
-  xmodem_flush();
-  xmodem_out_func(XMODEM_CAN);
-  xmodem_out_func(XMODEM_CAN);
-  xmodem_out_func(XMODEM_CAN);
+  
+  // Exceeded retry count
+  xmodem_flush( XMODEM_FLUSH_AND_CAN );
   return XMODEM_ERROR_RETRYEXCEED;
 }
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000117.html">[Elua-svn] r161 - trunk/src/platform/lm3s
</A></li>
	<LI>Next message: <A HREF="000119.html">[Elua-svn] r163 - trunk/src/platform/lm3s
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#118">[ date ]</a>
              <a href="thread.html#118">[ thread ]</a>
              <a href="subject.html#118">[ subject ]</a>
              <a href="author.html#118">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
