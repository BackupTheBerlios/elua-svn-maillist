<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r159 - in trunk: . inc src src/modules	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc288x src/platform/stm32	src/platform/str7 src/platform/str9
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r159%20-%20in%20trunk%3A%20.%20inc%20src%20src/modules%0A%09src/platform/at91sam7x%20src/platform/avr32%20src/platform/i386%0A%09src/platform/lm3s%20src/platform/lpc288x%20src/platform/stm32%0A%09src/platform/str7%20src/platform/str9&In-Reply-To=%3C200901212340.n0LNeaRn000655%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000114.html">
   <LINK REL="Next"  HREF="000116.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r159 - in trunk: . inc src src/modules	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc288x src/platform/stm32	src/platform/str7 src/platform/str9</H1>
    <B>jbsnyder at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r159%20-%20in%20trunk%3A%20.%20inc%20src%20src/modules%0A%09src/platform/at91sam7x%20src/platform/avr32%20src/platform/i386%0A%09src/platform/lm3s%20src/platform/lpc288x%20src/platform/stm32%0A%09src/platform/str7%20src/platform/str9&In-Reply-To=%3C200901212340.n0LNeaRn000655%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r159 - in trunk: . inc src src/modules	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc288x src/platform/stm32	src/platform/str7 src/platform/str9">jbsnyder at mail.berlios.de
       </A><BR>
    <I>Thu Jan 22 00:40:36 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000114.html">[Elua-svn] r158 - trunk/src/modules
</A></li>
        <LI>Next message: <A HREF="000116.html">[Elua-svn] r160 - trunk/romfs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#115">[ date ]</a>
              <a href="thread.html#115">[ thread ]</a>
              <a href="subject.html#115">[ subject ]</a>
              <a href="author.html#115">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jbsnyder
Date: 2009-01-22 00:40:34 +0100 (Thu, 22 Jan 2009)
New Revision: 159

Added:
   trunk/src/modules/adc.c
   trunk/src/platform/lm3s/adc.c
   trunk/src/platform/lm3s/adc.h
   trunk/src/platform/lm3s/hw_adc.h
Modified:
   trunk/CHANGELOG
   trunk/SConstruct
   trunk/inc/platform.h
   trunk/src/common.c
   trunk/src/modules/auxmods.h
   trunk/src/platform/at91sam7x/platform_conf.h
   trunk/src/platform/avr32/platform_conf.h
   trunk/src/platform/i386/platform_conf.h
   trunk/src/platform/lm3s/conf.py
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/platform_conf.h
   trunk/src/platform/lpc288x/platform_conf.h
   trunk/src/platform/stm32/platform_conf.h
   trunk/src/platform/str7/platform_conf.h
   trunk/src/platform/str9/platform_conf.h
Log:
Initial ADC implementation.

Modified: trunk/CHANGELOG
===================================================================
--- trunk/CHANGELOG	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/CHANGELOG	2009-01-21 23:40:34 UTC (rev 159)
@@ -1,13 +1,14 @@
 Trunk Dev  Bogdan Marinescu &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">bogdanm at eluaproject.net</A>&gt;
            Dado Sutter      &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">dado at eluaproject.net</A>&gt;
+           James Snyder     &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">jbsnyder at fanplastic.org</A>&gt;
 
   * Added an ls (or dir) shell command
   * Added support for STM32
   * Examples added pong, (morse on RIT128x96x4 ?, snake ?)
   * Documentation now in PDF format (work in progress)
+  * added ADC module
   *
   *
-  *
 
 
 

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/SConstruct	2009-01-21 23:40:34 UTC (rev 159)
@@ -17,7 +17,8 @@
           'hello' : [ 'hello.lua' ],
           'info' : [ 'info.lua' ],
           'morse' : [ 'morse.lua' ],
-          'dualpwm' : [ 'dualpwm.lua' ]
+          'dualpwm' : [ 'dualpwm.lua' ],
+          'adcscope' : [ 'adcscope.lua' ]
         }
 
 # List of platform/CPU combinations
@@ -45,8 +46,8 @@
 
 # List of board/romfs data combinations
 file_list = { 'SAM7-EX256' : [ 'bisect', 'hangman' , 'led', 'piano', 'hello', 'info', 'morse' ],
-              'EK-LM3S8962' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse' ],
-              'EK-LM3S6965' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse' ],
+              'EK-LM3S8962' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
+              'EK-LM3S6965' : [ 'bisect', 'hangman', 'lhttpd', 'pong', 'led', 'piano', 'pwmled', 'tvbgone', 'hello', 'info', 'morse', 'adcscope' ],
               'STR9-COMSTICK' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
               'PC' : [ 'bisect', 'hello', 'info' ],
               'LPC-H2888' : [ 'bisect', 'hangman', 'led', 'hello', 'info' ],
@@ -164,7 +165,7 @@
 local_include = local_include + &quot; -Isrc/uip&quot;
 
 # Lua module files
-module_names = &quot;pio.c spi.c tmr.c pd.c uart.c term.c pwm.c lpack.c bit.c net.c cpu.c&quot;
+module_names = &quot;pio.c spi.c tmr.c pd.c uart.c term.c pwm.c lpack.c bit.c net.c cpu.c adc.c&quot;
 module_files = &quot; &quot; + &quot; &quot;.join( [ &quot;src/modules/%s&quot; % name for name in module_names.split() ] )
 
 # Optimizer flags (speed or size)

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/inc/platform.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -175,6 +175,16 @@
 u32 platform_cpu_get_frequency();
 
 // *****************************************************************************
+// The platform ADC functions
+int platform_adc_exists( unsigned id );
+u16 platform_adc_sample( unsigned id );
+u16 platform_adc_maxval( unsigned id );
+void platform_adc_start( unsigned id );
+int platform_adc_is_done( unsigned id );
+void platform_adc_set_mode( unsigned id, int mode );
+void platform_adc_burst( unsigned id, u16* buf, unsigned count, u32 frequency );
+
+// *****************************************************************************
 // Ethernet specific functions
 
 void platform_eth_send_packet( const void* src, u32 size );

Modified: trunk/src/common.c
===================================================================
--- trunk/src/common.c	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/common.c	2009-01-21 23:40:34 UTC (rev 159)
@@ -231,6 +231,13 @@
 }
 
 // ****************************************************************************
+// ADC functions
+int platform_adc_exists( unsigned id )
+{
+  return id &lt; NUM_ADC;
+}
+
+// ****************************************************************************
 // Allocator support
 
 extern char end[];

Added: trunk/src/modules/adc.c
===================================================================
--- trunk/src/modules/adc.c	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/modules/adc.c	2009-01-21 23:40:34 UTC (rev 159)
@@ -0,0 +1,89 @@
+// Module for interfacing with ADC
+
+#include &quot;lua.h&quot;
+#include &quot;lualib.h&quot;
+#include &quot;lauxlib.h&quot;
+#include &quot;platform.h&quot;
+#include &quot;auxmods.h&quot;
+#include &quot;lrotable.h&quot;
+#include &quot;platform_conf.h&quot;
+
+// Lua: sample( id )
+static int adc_sample( lua_State* L )
+{
+  unsigned id;
+  u16 res;
+  
+  id = luaL_checkinteger( L, 1 );
+  MOD_CHECK_ID( adc, id );
+  res = platform_adc_sample( id );
+  lua_pushinteger( L, res );
+  return 1;
+}
+
+// Lua: start( id )
+static int adc_start( lua_State* L )
+{
+  unsigned id;
+  
+  id = luaL_checkinteger( L, 1 );
+  MOD_CHECK_ID( adc, id );
+  platform_adc_start( id );
+  return 0;
+}
+
+// Lua: maxval( id )
+static int adc_maxval( lua_State* L)
+{
+  unsigned id;
+  u16 res;
+  
+  id = luaL_checkinteger( L, 1 );
+  MOD_CHECK_ID( adc, id );
+  res = platform_adc_maxval( id );
+  lua_pushinteger( L, res );
+  return 1;
+}
+
+// Lua: is_done( id )
+static int adc_is_done( lua_State* L )
+{
+  unsigned id;
+  int res;
+  
+  id = luaL_checkinteger( L, 1 );
+  MOD_CHECK_ID( adc, id );
+  res = platform_adc_is_done( id );
+  lua_pushinteger( L, res );
+  return 1;
+}
+
+// Lua: set_mode( id, mode )
+static int adc_set_mode( lua_State* L )
+{
+  unsigned id, mode;
+  
+  id = luaL_checkinteger( L, 1 );
+  MOD_CHECK_ID( adc, id );
+  mode = luaL_checkinteger( L, 2 );
+  platform_adc_set_mode( id, mode );
+  return 0;
+}
+
+// Module function map
+#define MIN_OPT_LEVEL 2
+#include &quot;lrodefs.h&quot;
+const LUA_REG_TYPE adc_map[] = 
+{
+  { LSTRKEY( &quot;sample&quot; ), LFUNCVAL( adc_sample ) },
+  { LSTRKEY( &quot;start&quot; ), LFUNCVAL( adc_start ) },
+  { LSTRKEY( &quot;maxval&quot; ), LFUNCVAL( adc_maxval ) },
+  { LSTRKEY( &quot;isdone&quot; ), LFUNCVAL( adc_is_done ) },
+  { LSTRKEY( &quot;setmode&quot; ), LFUNCVAL( adc_set_mode ) },
+  { LNILKEY, LNILVAL }
+};
+
+LUALIB_API int luaopen_adc( lua_State *L )
+{
+  LREGISTER( L, AUXLIB_ADC, adc_map );
+}
\ No newline at end of file

Modified: trunk/src/modules/auxmods.h
===================================================================
--- trunk/src/modules/auxmods.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/modules/auxmods.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -39,6 +39,9 @@
 #define AUXLIB_CPU      &quot;cpu&quot;
 LUALIB_API int ( luaopen_cpu )( lua_State* L );
 
+#define AUXLIB_ADC      &quot;adc&quot;
+LUALIB_API int ( luaopen_adc )( lua_State *L );
+
 // Helper macros
 
 #define MOD_CHECK_ID( mod, id )\

Modified: trunk/src/platform/at91sam7x/platform_conf.h
===================================================================
--- trunk/src/platform/at91sam7x/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/at91sam7x/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -41,7 +41,7 @@
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
   _ROM( AUXLIB_CPU, luaopen_cpu, cpu_map )\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
-  
+
 // *****************************************************************************
 // Configuration data
 
@@ -59,6 +59,7 @@
 #define NUM_TIMER             2
 #endif
 #define NUM_PWM               4
+#define NUM_ADC               0
 
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         BOARD_MCK
@@ -80,6 +81,6 @@
   #define SRAM_SIZE           0x20000
 #endif
 #define MEM_START_ADDRESS     { ( void* )end }
-#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }  
-  
+#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }
+
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/avr32/platform_conf.h
===================================================================
--- trunk/src/platform/avr32/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/avr32/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -39,8 +39,8 @@
   _ROM( AUXLIB_CPU, luaopen_cpu, cpu_map )\
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
   _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
-  _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )  
-  
+  _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
+
 // *****************************************************************************
 // Configuration data
 
@@ -56,8 +56,9 @@
 #define NUM_TIMER             2
 #else
 #define NUM_TIMER             3
-#endif      
+#endif
 #define NUM_PWM               0
+#define NUM_ADC               0
 
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         REQ_CPU_FREQ

Modified: trunk/src/platform/i386/platform_conf.h
===================================================================
--- trunk/src/platform/i386/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/i386/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -19,9 +19,9 @@
 #define LUA_PLATFORM_LIBS_ROM\
   _ROM( AUXLIB_PD, luaopen_pd, pd_map )\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
-  
+
 #define CON_UART_ID           0
-  
+
 // *****************************************************************************
 // Configuration data
 
@@ -34,6 +34,7 @@
 #define NUM_UART              0
 #define NUM_TIMER             0
 #define NUM_PWM               0
+#define NUM_ADC               0
 
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         0
@@ -50,6 +51,6 @@
 // (start address and end address)
 u32 platform_get_lastmem();
 #define MEM_START_ADDRESS     { ( void* )end }
-#define MEM_END_ADDRESS       { ( void* )( platform_get_lastmem() - 16384 - 1 ) }  
-  
+#define MEM_END_ADDRESS       { ( void* )( platform_get_lastmem() - 16384 - 1 ) }
+
 #endif // #ifndef __PLATFORM_CONF_H__

Added: trunk/src/platform/lm3s/adc.c
===================================================================
--- trunk/src/platform/lm3s/adc.c	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/lm3s/adc.c	2009-01-21 23:40:34 UTC (rev 159)
@@ -0,0 +1,979 @@
+//*****************************************************************************
+//
+// adc.c - Driver for the ADC.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+//! \addtogroup adc_api
+//! @{
+//
+//*****************************************************************************
+
+#include &quot;hw_adc.h&quot;
+#include &quot;hw_ints.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;adc.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;interrupt.h&quot;
+
+//*****************************************************************************
+//
+// These defines are used by the ADC driver to simplify access to the ADC
+// sequencer's registers.
+//
+//*****************************************************************************
+#define ADC_SEQ                 (ADC_O_SSMUX0)
+#define ADC_SEQ_STEP            (ADC_O_SSMUX1 - ADC_O_SSMUX0)
+#define ADC_SSMUX               (ADC_O_SSMUX0 - ADC_O_SSMUX0)
+#define ADC_SSCTL               (ADC_O_SSCTL0 - ADC_O_SSMUX0)
+#define ADC_SSFIFO              (ADC_O_SSFIFO0 - ADC_O_SSMUX0)
+#define ADC_SSFSTAT             (ADC_O_SSFSTAT0 - ADC_O_SSMUX0)
+
+//*****************************************************************************
+//
+// The currently configured software oversampling factor for each of the ADC
+// sequencers.
+//
+//*****************************************************************************
+static unsigned char g_pucOversampleFactor[3];
+
+//*****************************************************************************
+//
+//! Registers an interrupt handler for an ADC interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param pfnHandler is a pointer to the function to be called when the
+//! ADC sample sequence interrupt occurs.
+//!
+//! This function sets the handler to be called when a sample sequence
+//! interrupt occurs.  This will enable the global interrupt in the interrupt
+//! controller; the sequence interrupt must be enabled with ADCIntEnable().  It
+//! is the interrupt handler's responsibility to clear the interrupt source via
+//! ADCIntClear().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntRegister(unsigned long ulBase, unsigned long ulSequenceNum,
+               void (*pfnHandler)(void))
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine the interrupt to register based on the sequence number.
+    //
+    ulInt = INT_ADC0 + ulSequenceNum;
+
+    //
+    // Register the interrupt handler.
+    //
+    IntRegister(ulInt, pfnHandler);
+
+    //
+    // Enable the timer interrupt.
+    //
+    IntEnable(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Unregisters the interrupt handler for an ADC interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function unregisters the interrupt handler.  This will disable the
+//! global interrupt in the interrupt controller; the sequence interrupt must
+//! be disabled via ADCIntDisable().
+//!
+//! \sa IntRegister() for important information about registering interrupt
+//! handlers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntUnregister(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    unsigned long ulInt;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine the interrupt to unregister based on the sequence number.
+    //
+    ulInt = INT_ADC0 + ulSequenceNum;
+
+    //
+    // Disable the interrupt.
+    //
+    IntDisable(ulInt);
+
+    //
+    // Unregister the interrupt handler.
+    //
+    IntUnregister(ulInt);
+}
+
+//*****************************************************************************
+//
+//! Disables a sample sequence interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function disables the requested sample sequence interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntDisable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Disable this sample sequence interrupt.
+    //
+    HWREG(ulBase + ADC_O_IM) &amp;= ~(1 &lt;&lt; ulSequenceNum);
+}
+
+//*****************************************************************************
+//
+//! Enables a sample sequence interrupt.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function enables the requested sample sequence interrupt.  Any
+//! outstanding interrupts are cleared before enabling the sample sequence
+//! interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntEnable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear any outstanding interrupts on this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_ISC) = 1 &lt;&lt; ulSequenceNum;
+
+    //
+    // Enable this sample sequence interrupt.
+    //
+    HWREG(ulBase + ADC_O_IM) |= 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Gets the current interrupt status.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param bMasked is false if the raw interrupt status is required and true if
+//! the masked interrupt status is required.
+//!
+//! This returns the interrupt status for the specified sample sequence.
+//! Either the raw interrupt status or the status of interrupts that are
+//! allowed to reflect to the processor can be returned.
+//!
+//! \return The current raw or masked interrupt status.
+//
+//*****************************************************************************
+unsigned long
+ADCIntStatus(unsigned long ulBase, unsigned long ulSequenceNum,
+             tBoolean bMasked)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Return either the interrupt status or the raw interrupt status as
+    // requested.
+    //
+    if(bMasked)
+    {
+        return(HWREG(ulBase + ADC_O_ISC) &amp; (1 &lt;&lt; ulSequenceNum));
+    }
+    else
+    {
+        return(HWREG(ulBase + ADC_O_RIS) &amp; (1 &lt;&lt; ulSequenceNum));
+    }
+}
+
+//*****************************************************************************
+//
+//! Clears sample sequence interrupt source.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! The specified sample sequence interrupt is cleared, so that it no longer
+//! asserts.  This must be done in the interrupt handler to keep it from being
+//! called again immediately upon exit.
+//!
+//! \note Since there is a write buffer in the Cortex-M3 processor, it may take
+//! several clock cycles before the interrupt source is actually cleared.
+//! Therefore, it is recommended that the interrupt source be cleared early in
+//! the interrupt handler (as opposed to the very last action) to avoid
+//! returning from the interrupt handler before the interrupt source is
+//! actually cleared.  Failure to do so may result in the interrupt handler
+//! being immediately reentered (since NVIC still sees the interrupt source
+//! asserted).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCIntClear(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear the interrupt.
+    //
+    HWREG(ulBase + ADC_O_ISC) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Enables a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! Allows the specified sample sequence to be captured when its trigger is
+//! detected.  A sample sequence must be configured before it is enabled.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceEnable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Enable the specified sequence.
+    //
+    HWREG(ulBase + ADC_O_ACTSS) |= 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Disables a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! Prevents the specified sample sequence from being captured when its trigger
+//! is detected.  A sample sequence should be disabled before it is configured.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceDisable(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Disable the specified sequences.
+    //
+    HWREG(ulBase + ADC_O_ACTSS) &amp;= ~(1 &lt;&lt; ulSequenceNum);
+}
+
+//*****************************************************************************
+//
+//! Configures the trigger source and priority of a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulTrigger is the trigger source that initiates the sample sequence;
+//! must be one of the \b ADC_TRIGGER_* values.
+//! \param ulPriority is the relative priority of the sample sequence with
+//! respect to the other sample sequences.
+//!
+//! This function configures the initiation criteria for a sample sequence.
+//! Valid sample sequences range from zero to three; sequence zero will capture
+//! up to eight samples, sequences one and two will capture up to four samples,
+//! and sequence three will capture a single sample.  The trigger condition and
+//! priority (with respect to other sample sequence execution) is set.
+//!
+//! The \e ulTrigger parameter can take on the following values:
+//!
+//! - \b ADC_TRIGGER_PROCESSOR - A trigger generated by the processor, via the
+//!                              ADCProcessorTrigger() function.
+//! - \b ADC_TRIGGER_COMP0 - A trigger generated by the first analog
+//!                          comparator; configured with ComparatorConfigure().
+//! - \b ADC_TRIGGER_COMP1 - A trigger generated by the second analog
+//!                          comparator; configured with ComparatorConfigure().
+//! - \b ADC_TRIGGER_COMP2 - A trigger generated by the third analog
+//!                          comparator; configured with ComparatorConfigure().
+//! - \b ADC_TRIGGER_EXTERNAL - A trigger generated by an input from the Port
+//!                             B4 pin.
+//! - \b ADC_TRIGGER_TIMER - A trigger generated by a timer; configured with
+//!                          TimerControlTrigger().
+//! - \b ADC_TRIGGER_PWM0 - A trigger generated by the first PWM generator;
+//!                         configured with PWMGenIntTrigEnable().
+//! - \b ADC_TRIGGER_PWM1 - A trigger generated by the second PWM generator;
+//!                         configured with PWMGenIntTrigEnable().
+//! - \b ADC_TRIGGER_PWM2 - A trigger generated by the third PWM generator;
+//!                         configured with PWMGenIntTrigEnable().
+//! - \b ADC_TRIGGER_ALWAYS - A trigger that is always asserted, causing the
+//!                           sample sequence to capture repeatedly (so long as
+//!                           there is not a higher priority source active).
+//!
+//! Note that not all trigger sources are available on all Stellaris family
+//! members; consult the data sheet for the device in question to determine the
+//! availability of triggers.
+//!
+//! The \e ulPriority parameter is a value between 0 and 3, where 0 represents
+//! the highest priority and 3 the lowest.  Note that when programming the
+//! priority among a set of sample sequences, each must have unique priority;
+//! it is up to the caller to guarantee the uniqueness of the priorities.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceConfigure(unsigned long ulBase, unsigned long ulSequenceNum,
+                     unsigned long ulTrigger, unsigned long ulPriority)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+    ASSERT((ulTrigger == ADC_TRIGGER_PROCESSOR) ||
+           (ulTrigger == ADC_TRIGGER_COMP0) ||
+           (ulTrigger == ADC_TRIGGER_COMP1) ||
+           (ulTrigger == ADC_TRIGGER_COMP2) ||
+           (ulTrigger == ADC_TRIGGER_EXTERNAL) ||
+           (ulTrigger == ADC_TRIGGER_TIMER) ||
+           (ulTrigger == ADC_TRIGGER_PWM0) ||
+           (ulTrigger == ADC_TRIGGER_PWM1) ||
+           (ulTrigger == ADC_TRIGGER_PWM2) ||
+           (ulTrigger == ADC_TRIGGER_ALWAYS));
+    ASSERT(ulPriority &lt; 4);
+
+    //
+    // Compute the shift for the bits that control this sample sequence.
+    //
+    ulSequenceNum *= 4;
+
+    //
+    // Set the trigger event for this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_EMUX) = ((HWREG(ulBase + ADC_O_EMUX) &amp;
+                                   ~(0xf &lt;&lt; ulSequenceNum)) |
+                                  ((ulTrigger &amp; 0xf) &lt;&lt; ulSequenceNum));
+
+    //
+    // Set the priority for this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_SSPRI) = ((HWREG(ulBase + ADC_O_SSPRI) &amp;
+                                    ~(0xf &lt;&lt; ulSequenceNum)) |
+                                   ((ulPriority &amp; 0x3) &lt;&lt; ulSequenceNum));
+}
+
+//*****************************************************************************
+//
+//! Configure a step of the sample sequencer.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulStep is the step to be configured.
+//! \param ulConfig is the configuration of this step; must be a logical OR of
+//! \b ADC_CTL_TS, \b ADC_CTL_IE, \b ADC_CTL_END, \b ADC_CTL_D, and one of the
+//! input channel selects (\b ADC_CTL_CH0 through \b ADC_CTL_CH7).
+//!
+//! This function will set the configuration of the ADC for one step of a
+//! sample sequence.  The ADC can be configured for single-ended or
+//! differential operation (the \b ADC_CTL_D bit selects differential
+//! operation when set), the channel to be sampled can be chosen (the
+//! \b ADC_CTL_CH0 through \b ADC_CTL_CH7 values), and the internal temperature
+//! sensor can be selected (the \b ADC_CTL_TS bit).  Additionally, this step
+//! can be defined as the last in the sequence (the \b ADC_CTL_END bit) and it
+//! can be configured to cause an interrupt when the step is complete (the
+//! \b ADC_CTL_IE bit).  The configuration is used by the ADC at the
+//! appropriate time when the trigger for this sequence occurs.
+//!
+//! The \e ulStep parameter determines the order in which the samples are
+//! captured by the ADC when the trigger occurs.  It can range from zero to
+//! seven for the first sample sequence, from zero to three for the second and
+//! third sample sequence, and can only be zero for the fourth sample sequence.
+//!
+//! Differential mode only works with adjacent channel pairs (for example, 0
+//! and 1).  The channel select must be the number of the channel pair to
+//! sample (for example, \b ADC_CTL_CH0 for 0 and 1, or \b ADC_CTL_CH1 for 2
+//! and 3) or undefined results will be returned by the ADC.  Additionally, if
+//! differential mode is selected when the temperature sensor is being sampled,
+//! undefined results will be returned by the ADC.
+//!
+//! It is the responsibility of the caller to ensure that a valid configuration
+//! is specified; this function does not check the validity of the specified
+//! configuration.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceStepConfigure(unsigned long ulBase, unsigned long ulSequenceNum,
+                         unsigned long ulStep, unsigned long ulConfig)
+{
+    //
+    // Check the arugments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+    ASSERT(((ulSequenceNum == 0) &amp;&amp; (ulStep &lt; 8)) ||
+           ((ulSequenceNum == 1) &amp;&amp; (ulStep &lt; 4)) ||
+           ((ulSequenceNum == 2) &amp;&amp; (ulStep &lt; 4)) ||
+           ((ulSequenceNum == 3) &amp;&amp; (ulStep &lt; 1)));
+
+    //
+    // Get the offset of the sequence to be configured.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Compute the shift for the bits that control this step.
+    //
+    ulStep *= 4;
+
+    //
+    // Set the analog mux value for this step.
+    //
+    HWREG(ulBase + ADC_SSMUX) = ((HWREG(ulBase + ADC_SSMUX) &amp;
+                                  ~(0x0000000f &lt;&lt; ulStep)) |
+                                 ((ulConfig &amp; 0x0f) &lt;&lt; ulStep));
+
+    //
+    // Set the control value for this step.
+    //
+    HWREG(ulBase + ADC_SSCTL) = ((HWREG(ulBase + ADC_SSCTL) &amp;
+                                  ~(0x0000000f &lt;&lt; ulStep)) |
+                                 (((ulConfig &amp; 0xf0) &gt;&gt; 4) &lt;&lt; ulStep));
+}
+
+//*****************************************************************************
+//
+//! Determines if a sample sequence overflow occurred.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This determines if a sample sequence overflow has occurred.  This will
+//! happen if the captured samples are not read from the FIFO before the next
+//! trigger occurs.
+//!
+//! \return Returns zero if there was not an overflow, and non-zero if there
+//! was.
+//
+//*****************************************************************************
+long
+ADCSequenceOverflow(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine if there was an overflow on this sequence.
+    //
+    return(HWREG(ulBase + ADC_O_OSTAT) &amp; (1 &lt;&lt; ulSequenceNum));
+}
+
+//*****************************************************************************
+//
+//! Clears the overflow condition on a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This will clear an overflow condition on one of the sample sequences.  The
+//! overflow condition must be cleared in order to detect a subsequent overflow
+//! condition (it otherwise causes no harm).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceOverflowClear(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear the overflow condition for this sequence.
+    //
+    HWREG(ulBase + ADC_O_OSTAT) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Determines if a sample sequence underflow occurred.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This determines if a sample sequence underflow has occurred.  This will
+//! happen if too many samples are read from the FIFO.
+//!
+//! \return Returns zero if there was not an underflow, and non-zero if there
+//! was.
+//
+//*****************************************************************************
+long
+ADCSequenceUnderflow(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Determine if there was an underflow on this sequence.
+    //
+    return(HWREG(ulBase + ADC_O_USTAT) &amp; (1 &lt;&lt; ulSequenceNum));
+}
+
+//*****************************************************************************
+//
+//! Clears the underflow condition on a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This will clear an underflow condition on one of the sample sequences.  The
+//! underflow condition must be cleared in order to detect a subsequent
+//! underflow condition (it otherwise causes no harm).
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSequenceUnderflowClear(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Clear the underflow condition for this sequence.
+    //
+    HWREG(ulBase + ADC_O_USTAT) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Gets the captured data for a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param pulBuffer is the address where the data is stored.
+//!
+//! This function copies data from the specified sample sequence output FIFO to
+//! a memory resident buffer.  The number of samples available in the hardware
+//! FIFO are copied into the buffer, which is assumed to be large enough to
+//! hold that many samples.  This will only return the samples that are
+//! presently available, which may not be the entire sample sequence if it is
+//! in the process of being executed.
+//!
+//! \return Returns the number of samples copied to the buffer.
+//
+//*****************************************************************************
+long
+ADCSequenceDataGet(unsigned long ulBase, unsigned long ulSequenceNum,
+                   unsigned long *pulBuffer)
+{
+    unsigned long ulCount;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Get the offset of the sequence to be read.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Read samples from the FIFO until it is empty.
+    //
+    ulCount = 0;
+    while(!(HWREG(ulBase + ADC_SSFSTAT) &amp; ADC_SSFSTAT0_EMPTY) &amp;&amp; (ulCount &lt; 8))
+    {
+        //
+        // Read the FIFO and copy it to the destination.
+        //
+        *pulBuffer++ = HWREG(ulBase + ADC_SSFIFO);
+
+        //
+        // Increment the count of samples read.
+        //
+        ulCount++;
+    }
+
+    //
+    // Return the number of samples read.
+    //
+    return(ulCount);
+}
+
+//*****************************************************************************
+//
+//! Causes a processor trigger for a sample sequence.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//!
+//! This function triggers a processor-initiated sample sequence if the sample
+//! sequence trigger is configured to \b ADC_TRIGGER_PROCESSOR.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCProcessorTrigger(unsigned long ulBase, unsigned long ulSequenceNum)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 4);
+
+    //
+    // Generate a processor trigger for this sample sequence.
+    //
+    HWREG(ulBase + ADC_O_PSSI) = 1 &lt;&lt; ulSequenceNum;
+}
+
+//*****************************************************************************
+//
+//! Configures the software oversampling factor of the ADC.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulFactor is the number of samples to be averaged.
+//!
+//! This function configures the software oversampling for the ADC, which can
+//! be used to provide better resolution on the sampled data.  Oversampling is
+//! accomplished by averaging multiple samples from the same analog input.
+//! Three different oversampling rates are supported; 2x, 4x, and 8x.
+//!
+//! Oversampling is only supported on the sample sequencers that are more than
+//! one sample in depth (that is, the fourth sample sequencer is not
+//! supported).  Oversampling by 2x (for example) divides the depth of the
+//! sample sequencer by two; so 2x oversampling on the first sample sequencer
+//! can only provide four samples per trigger.  This also means that 8x
+//! oversampling is only available on the first sample sequencer.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSoftwareOversampleConfigure(unsigned long ulBase,
+                               unsigned long ulSequenceNum,
+                               unsigned long ulFactor)
+{
+    unsigned long ulValue;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 3);
+    ASSERT(((ulFactor == 2) || (ulFactor == 4) || (ulFactor == 8)) &amp;&amp;
+           ((ulSequenceNum == 0) || (ulFactor != 8)));
+
+    //
+    // Convert the oversampling factor to a shift factor.
+    //
+    for(ulValue = 0, ulFactor &gt;&gt;= 1; ulFactor; ulValue++, ulFactor &gt;&gt;= 1)
+    {
+    }
+
+    //
+    // Save the sfiht factor.
+    //
+    g_pucOversampleFactor[ulSequenceNum] = ulValue;
+}
+
+//*****************************************************************************
+//
+//! Configures a step of the software oversampled sequencer.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param ulStep is the step to be configured.
+//! \param ulConfig is the configuration of this step.
+//!
+//! This function configures a step of the sample sequencer when using the
+//! software oversampling feature.  The number of steps available depends on
+//! the oversampling factor set by ADCSoftwareOversampleConfigure().  The value
+//! of \e ulConfig is the same as defined for ADCSequenceStepConfigure().
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSoftwareOversampleStepConfigure(unsigned long ulBase,
+                                   unsigned long ulSequenceNum,
+                                   unsigned long ulStep,
+                                   unsigned long ulConfig)
+{
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 3);
+    ASSERT(((ulSequenceNum == 0) &amp;&amp;
+            (ulStep &lt; (8 &gt;&gt; g_pucOversampleFactor[ulSequenceNum]))) ||
+           (ulStep &lt; (4 &gt;&gt; g_pucOversampleFactor[ulSequenceNum])));
+
+    //
+    // Get the offset of the sequence to be configured.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Compute the shift for the bits that control this step.
+    //
+    ulStep *= 4 &lt;&lt; g_pucOversampleFactor[ulSequenceNum];
+
+    //
+    // Loop through the hardware steps that make up this step of the software
+    // oversampled sequence.
+    //
+    for(ulSequenceNum = 1 &lt;&lt; g_pucOversampleFactor[ulSequenceNum];
+        ulSequenceNum; ulSequenceNum--)
+    {
+        //
+        // Set the analog mux value for this step.
+        //
+        HWREG(ulBase + ADC_SSMUX) = ((HWREG(ulBase + ADC_SSMUX) &amp;
+                                      ~(0x0000000f &lt;&lt; ulStep)) |
+                                     ((ulConfig &amp; 0x0f) &lt;&lt; ulStep));
+
+        //
+        // Set the control value for this step.
+        //
+        HWREG(ulBase + ADC_SSCTL) = ((HWREG(ulBase + ADC_SSCTL) &amp;
+                                      ~(0x0000000f &lt;&lt; ulStep)) |
+                                     (((ulConfig &amp; 0xf0) &gt;&gt; 4) &lt;&lt; ulStep));
+        if(ulSequenceNum != 1)
+        {
+            HWREG(ulBase + ADC_SSCTL) &amp;= ~((ADC_SSCTL0_IE0 |
+                                            ADC_SSCTL0_END0) &lt;&lt; ulStep);
+        }
+
+        //
+        // Go to the next hardware step.
+        //
+        ulStep += 4;
+    }
+}
+
+//*****************************************************************************
+//
+//! Gets the captured data for a sample sequence using software oversampling.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulSequenceNum is the sample sequence number.
+//! \param pulBuffer is the address where the data is stored.
+//! \param ulCount is the number of samples to be read.
+//!
+//! This function copies data from the specified sample sequence output FIFO to
+//! a memory resident buffer with software oversampling applied.  The requested
+//! number of samples are copied into the data buffer; if there are not enough
+//! samples in the hardware FIFO to satisfy this many oversampled data items
+//! then incorrect results will be returned.  It is the caller's responsibility
+//! to read only the samples that are available and wait until enough data is
+//! available, for example as a result of receiving an interrupt.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCSoftwareOversampleDataGet(unsigned long ulBase, unsigned long ulSequenceNum,
+                             unsigned long *pulBuffer, unsigned long ulCount)
+{
+    unsigned long ulIdx, ulAccum;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(ulSequenceNum &lt; 3);
+    ASSERT(((ulSequenceNum == 0) &amp;&amp;
+            (ulCount &lt; (8 &gt;&gt; g_pucOversampleFactor[ulSequenceNum]))) ||
+           (ulCount &lt; (4 &gt;&gt; g_pucOversampleFactor[ulSequenceNum])));
+
+    //
+    // Get the offset of the sequence to be read.
+    //
+    ulBase += ADC_SEQ + (ADC_SEQ_STEP * ulSequenceNum);
+
+    //
+    // Read the samples from the FIFO until it is empty.
+    //
+    while(ulCount--)
+    {
+        //
+        // Compute the sum of the samples.
+        //
+        ulAccum = 0;
+        for(ulIdx = 1 &lt;&lt; g_pucOversampleFactor[ulSequenceNum]; ulIdx; ulIdx--)
+        {
+            //
+            // Read the FIFO and add it to the accumulator.
+            //
+            ulAccum += HWREG(ulBase + ADC_SSFIFO);
+        }
+
+        //
+        // Write the averaged sample to the output buffer.
+        //
+        *pulBuffer++ = ulAccum &gt;&gt; g_pucOversampleFactor[ulSequenceNum];
+    }
+}
+
+//*****************************************************************************
+//
+//! Configures the hardware oversampling factor of the ADC.
+//!
+//! \param ulBase is the base address of the ADC module.
+//! \param ulFactor is the number of samples to be averaged.
+//!
+//! This function configures the hardware oversampling for the ADC, which can
+//! be used to provide better resolution on the sampled data.  Oversampling is
+//! accomplished by averaging multiple samples from the same analog input.  Six
+//! different oversampling rates are supported; 2x, 4x, 8x, 16x, 32x, and 64x.
+//! Specifying an oversampling factor of zero will disable hardware
+//! oversampling.
+//!
+//! Hardware oversampling applies uniformly to all sample sequencers.  It does
+//! not reduce the depth of the sample sequencers like the software
+//! oversampling APIs; each sample written into the sample sequence FIFO is a
+//! fully oversampled analog input reading.
+//!
+//! Enabling hardware averaging increases the precision of the ADC at the cost
+//! of throughput.  For example, enabling 4x oversampling reduces the
+//! throughput of a 250 Ksps ADC to 62.5 Ksps.
+//!
+//! \note Hardware oversampling is available beginning with Rev C0 of the
+//! Stellaris microcontroller.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ADCHardwareOversampleConfigure(unsigned long ulBase, unsigned long ulFactor)
+{
+    unsigned long ulValue;
+
+    //
+    // Check the arguments.
+    //
+    ASSERT(ulBase == ADC_BASE);
+    ASSERT(((ulFactor == 0) || (ulFactor == 2) || (ulFactor == 4) ||
+           (ulFactor == 8) || (ulFactor == 16) || (ulFactor == 32) ||
+           (ulFactor == 64)));
+
+    //
+    // Convert the oversampling factor to a shift factor.
+    //
+    for(ulValue = 0, ulFactor &gt;&gt;= 1; ulFactor; ulValue++, ulFactor &gt;&gt;= 1)
+    {
+    }
+
+    //
+    // Write the shift factor to the ADC to configure the hardware oversampler.
+    //
+    HWREG(ulBase + ADC_O_SAC) = ulValue;
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************

Added: trunk/src/platform/lm3s/adc.h
===================================================================
--- trunk/src/platform/lm3s/adc.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/lm3s/adc.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -0,0 +1,141 @@
+//*****************************************************************************
+//
+// adc.h - ADC headers for using the ADC driver functions.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 3740 of the Stellaris Peripheral Driver Library.
+//
+//*****************************************************************************
+
+#ifndef __ADC_H__
+#define __ADC_H__
+
+//*****************************************************************************
+//
+// If building with a C++ compiler, make all of the definitions in this header
+// have a C binding.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+extern &quot;C&quot;
+{
+#endif
+
+//*****************************************************************************
+//
+// Values that can be passed to ADCSequenceConfigure as the ulTrigger
+// parameter.
+//
+//*****************************************************************************
+#define ADC_TRIGGER_PROCESSOR   0x00000000  // Processor event
+#define ADC_TRIGGER_COMP0       0x00000001  // Analog comparator 0 event
+#define ADC_TRIGGER_COMP1       0x00000002  // Analog comparator 1 event
+#define ADC_TRIGGER_COMP2       0x00000003  // Analog comparator 2 event
+#define ADC_TRIGGER_EXTERNAL    0x00000004  // External event
+#define ADC_TRIGGER_TIMER       0x00000005  // Timer event
+#define ADC_TRIGGER_PWM0        0x00000006  // PWM0 event
+#define ADC_TRIGGER_PWM1        0x00000007  // PWM1 event
+#define ADC_TRIGGER_PWM2        0x00000008  // PWM2 event
+#define ADC_TRIGGER_ALWAYS      0x0000000F  // Always event
+
+//*****************************************************************************
+//
+// Values that can be passed to ADCSequenceStepConfigure as the ulConfig
+// parameter.
+//
+//*****************************************************************************
+#define ADC_CTL_TS              0x00000080  // Temperature sensor select
+#define ADC_CTL_IE              0x00000040  // Interrupt enable
+#define ADC_CTL_END             0x00000020  // Sequence end select
+#define ADC_CTL_D               0x00000010  // Differential select
+#define ADC_CTL_CH0             0x00000000  // Input channel 0
+#define ADC_CTL_CH1             0x00000001  // Input channel 1
+#define ADC_CTL_CH2             0x00000002  // Input channel 2
+#define ADC_CTL_CH3             0x00000003  // Input channel 3
+#define ADC_CTL_CH4             0x00000004  // Input channel 4
+#define ADC_CTL_CH5             0x00000005  // Input channel 5
+#define ADC_CTL_CH6             0x00000006  // Input channel 6
+#define ADC_CTL_CH7             0x00000007  // Input channel 7
+
+//*****************************************************************************
+//
+// Prototypes for the APIs.
+//
+//*****************************************************************************
+extern void ADCIntRegister(unsigned long ulBase, unsigned long ulSequenceNum,
+                           void (*pfnHandler)(void));
+extern void ADCIntUnregister(unsigned long ulBase,
+                             unsigned long ulSequenceNum);
+extern void ADCIntDisable(unsigned long ulBase, unsigned long ulSequenceNum);
+extern void ADCIntEnable(unsigned long ulBase, unsigned long ulSequenceNum);
+extern unsigned long ADCIntStatus(unsigned long ulBase,
+                                  unsigned long ulSequenceNum,
+                                  tBoolean bMasked);
+extern void ADCIntClear(unsigned long ulBase, unsigned long ulSequenceNum);
+extern void ADCSequenceEnable(unsigned long ulBase,
+                              unsigned long ulSequenceNum);
+extern void ADCSequenceDisable(unsigned long ulBase,
+                               unsigned long ulSequenceNum);
+extern void ADCSequenceConfigure(unsigned long ulBase,
+                                 unsigned long ulSequenceNum,
+                                 unsigned long ulTrigger,
+                                 unsigned long ulPriority);
+extern void ADCSequenceStepConfigure(unsigned long ulBase,
+                                     unsigned long ulSequenceNum,
+                                     unsigned long ulStep,
+                                     unsigned long ulConfig);
+extern long ADCSequenceOverflow(unsigned long ulBase,
+                                unsigned long ulSequenceNum);
+extern void ADCSequenceOverflowClear(unsigned long ulBase,
+                                     unsigned long ulSequenceNum);
+extern long ADCSequenceUnderflow(unsigned long ulBase,
+                                 unsigned long ulSequenceNum);
+extern void ADCSequenceUnderflowClear(unsigned long ulBase,
+                                      unsigned long ulSequenceNum);
+extern long ADCSequenceDataGet(unsigned long ulBase,
+                               unsigned long ulSequenceNum,
+                               unsigned long *pulBuffer);
+extern void ADCProcessorTrigger(unsigned long ulBase,
+                                unsigned long ulSequenceNum);
+extern void ADCSoftwareOversampleConfigure(unsigned long ulBase,
+                                           unsigned long ulSequenceNum,
+                                           unsigned long ulFactor);
+extern void ADCSoftwareOversampleStepConfigure(unsigned long ulBase,
+                                               unsigned long ulSequenceNum,
+                                               unsigned long ulStep,
+                                               unsigned long ulConfig);
+extern void ADCSoftwareOversampleDataGet(unsigned long ulBase,
+                                         unsigned long ulSequenceNum,
+                                         unsigned long *pulBuffer,
+                                         unsigned long ulCount);
+extern void ADCHardwareOversampleConfigure(unsigned long ulBase,
+                                           unsigned long ulFactor);
+
+//*****************************************************************************
+//
+// Mark the end of the C bindings section for C++ compilers.
+//
+//*****************************************************************************
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __ADC_H__

Modified: trunk/src/platform/lm3s/conf.py
===================================================================
--- trunk/src/platform/lm3s/conf.py	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/lm3s/conf.py	2009-01-21 23:40:34 UTC (rev 159)
@@ -1,6 +1,6 @@
 # Configuration file for the LM3S microcontroller
 
-specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c flash.c interrupt.c cpu.c rit128x96x4.c disp.c&quot;
+specific_files = &quot;startup_gcc.c platform.c usart.c sysctl.c gpio.c ssi.c timer.c pwm.c ethernet.c systick.c flash.c interrupt.c cpu.c rit128x96x4.c disp.c adc.c&quot;
 ldscript = &quot;lm3s.ld&quot;
   
 # Prepend with path

Added: trunk/src/platform/lm3s/hw_adc.h
===================================================================
--- trunk/src/platform/lm3s/hw_adc.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/lm3s/hw_adc.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -0,0 +1,634 @@
+//*****************************************************************************
+//
+// hw_adc.h - Macros used when accessing the ADC hardware.
+//
+// Copyright (c) 2005-2008 Luminary Micro, Inc.  All rights reserved.
+// Software License Agreement
+// 
+// Luminary Micro, Inc. (LMI) is supplying this software for use solely and
+// exclusively on LMI's microcontroller products.
+// 
+// The software is owned by LMI and/or its suppliers, and is protected under
+// applicable copyright laws.  All rights are reserved.  You may not combine
+// this software with &quot;viral&quot; open-source software in order to form a larger
+// program.  Any use in violation of the foregoing restrictions may subject
+// the user to criminal sanctions under applicable laws, as well as to civil
+// liability for the breach of the terms and conditions of this license.
+// 
+// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot;.  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
+// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
+// LMI SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
+// CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 3740 of the Stellaris Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __HW_ADC_H__
+#define __HW_ADC_H__
+
+//*****************************************************************************
+//
+// The following are defines for the ADC register offsets.
+//
+//*****************************************************************************
+#define ADC_O_ACTSS             0x00000000  // Active sample register
+#define ADC_O_RIS               0x00000004  // Raw interrupt status register
+#define ADC_O_IM                0x00000008  // Interrupt mask register
+#define ADC_O_ISC               0x0000000C  // Interrupt status/clear register
+#define ADC_O_OSTAT             0x00000010  // Overflow status register
+#define ADC_O_EMUX              0x00000014  // Event multiplexer select reg.
+#define ADC_O_USTAT             0x00000018  // Underflow status register
+#define ADC_O_SSPRI             0x00000020  // Channel priority register
+#define ADC_O_PSSI              0x00000028  // Processor sample initiate reg.
+#define ADC_O_SAC               0x00000030  // Sample Averaging Control reg.
+#define ADC_O_SSMUX0            0x00000040  // Multiplexer select 0 register
+#define ADC_O_SSCTL0            0x00000044  // Sample sequence control 0 reg.
+#define ADC_O_SSFIFO0           0x00000048  // Result FIFO 0 register
+#define ADC_O_SSFSTAT0          0x0000004C  // FIFO 0 status register
+#define ADC_O_SSMUX1            0x00000060  // Multiplexer select 1 register
+#define ADC_O_SSCTL1            0x00000064  // Sample sequence control 1 reg.
+#define ADC_O_SSFIFO1           0x00000068  // Result FIFO 1 register
+#define ADC_O_SSFSTAT1          0x0000006C  // FIFO 1 status register
+#define ADC_O_SSMUX2            0x00000080  // Multiplexer select 2 register
+#define ADC_O_SSCTL2            0x00000084  // Sample sequence control 2 reg.
+#define ADC_O_SSFIFO2           0x00000088  // Result FIFO 2 register
+#define ADC_O_SSFSTAT2          0x0000008C  // FIFO 2 status register
+#define ADC_O_SSMUX3            0x000000A0  // Multiplexer select 3 register
+#define ADC_O_SSCTL3            0x000000A4  // Sample sequence control 3 reg.
+#define ADC_O_SSFIFO3           0x000000A8  // Result FIFO 3 register
+#define ADC_O_SSFSTAT3          0x000000AC  // FIFO 3 status register
+#define ADC_O_TMLB              0x00000100  // Test mode loopback register
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_ACTSS register.
+//
+//*****************************************************************************
+#define ADC_ACTSS_ASEN3         0x00000008  // Sample sequence 3 enable
+#define ADC_ACTSS_ASEN2         0x00000004  // Sample sequence 2 enable
+#define ADC_ACTSS_ASEN1         0x00000002  // Sample sequence 1 enable
+#define ADC_ACTSS_ASEN0         0x00000001  // Sample sequence 0 enable
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_RIS register.
+//
+//*****************************************************************************
+#define ADC_RIS_INR3            0x00000008  // Sample sequence 3 interrupt
+#define ADC_RIS_INR2            0x00000004  // Sample sequence 2 interrupt
+#define ADC_RIS_INR1            0x00000002  // Sample sequence 1 interrupt
+#define ADC_RIS_INR0            0x00000001  // Sample sequence 0 interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_IM register.
+//
+//*****************************************************************************
+#define ADC_IM_MASK3            0x00000008  // Sample sequence 3 mask
+#define ADC_IM_MASK2            0x00000004  // Sample sequence 2 mask
+#define ADC_IM_MASK1            0x00000002  // Sample sequence 1 mask
+#define ADC_IM_MASK0            0x00000001  // Sample sequence 0 mask
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_ISC register.
+//
+//*****************************************************************************
+#define ADC_ISC_IN3             0x00000008  // Sample sequence 3 interrupt
+#define ADC_ISC_IN2             0x00000004  // Sample sequence 2 interrupt
+#define ADC_ISC_IN1             0x00000002  // Sample sequence 1 interrupt
+#define ADC_ISC_IN0             0x00000001  // Sample sequence 0 interrupt
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_OSTAT register.
+//
+//*****************************************************************************
+#define ADC_OSTAT_OV3           0x00000008  // Sample sequence 3 overflow
+#define ADC_OSTAT_OV2           0x00000004  // Sample sequence 2 overflow
+#define ADC_OSTAT_OV1           0x00000002  // Sample sequence 1 overflow
+#define ADC_OSTAT_OV0           0x00000001  // Sample sequence 0 overflow
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_EMUX register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_M          0x0000F000  // Event mux 3 mask
+#define ADC_EMUX_EM3_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM3_COMP0      0x00001000  // Analog comparator 0 event
+#define ADC_EMUX_EM3_COMP1      0x00002000  // Analog comparator 1 event
+#define ADC_EMUX_EM3_COMP2      0x00003000  // Analog comparator 2 event
+#define ADC_EMUX_EM3_EXTERNAL   0x00004000  // External event
+#define ADC_EMUX_EM3_TIMER      0x00005000  // Timer event
+#define ADC_EMUX_EM3_PWM0       0x00006000  // PWM0 event
+#define ADC_EMUX_EM3_PWM1       0x00007000  // PWM1 event
+#define ADC_EMUX_EM3_PWM2       0x00008000  // PWM2 event
+#define ADC_EMUX_EM3_ALWAYS     0x0000F000  // Always event
+#define ADC_EMUX_EM2_M          0x00000F00  // Event mux 2 mask
+#define ADC_EMUX_EM2_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM2_COMP0      0x00000100  // Analog comparator 0 event
+#define ADC_EMUX_EM2_COMP1      0x00000200  // Analog comparator 1 event
+#define ADC_EMUX_EM2_COMP2      0x00000300  // Analog comparator 2 event
+#define ADC_EMUX_EM2_EXTERNAL   0x00000400  // External event
+#define ADC_EMUX_EM2_TIMER      0x00000500  // Timer event
+#define ADC_EMUX_EM2_PWM0       0x00000600  // PWM0 event
+#define ADC_EMUX_EM2_PWM1       0x00000700  // PWM1 event
+#define ADC_EMUX_EM2_PWM2       0x00000800  // PWM2 event
+#define ADC_EMUX_EM2_ALWAYS     0x00000F00  // Always event
+#define ADC_EMUX_EM1_M          0x000000F0  // Event mux 1 mask
+#define ADC_EMUX_EM1_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM1_COMP0      0x00000010  // Analog comparator 0 event
+#define ADC_EMUX_EM1_COMP1      0x00000020  // Analog comparator 1 event
+#define ADC_EMUX_EM1_COMP2      0x00000030  // Analog comparator 2 event
+#define ADC_EMUX_EM1_EXTERNAL   0x00000040  // External event
+#define ADC_EMUX_EM1_TIMER      0x00000050  // Timer event
+#define ADC_EMUX_EM1_PWM0       0x00000060  // PWM0 event
+#define ADC_EMUX_EM1_PWM1       0x00000070  // PWM1 event
+#define ADC_EMUX_EM1_PWM2       0x00000080  // PWM2 event
+#define ADC_EMUX_EM1_ALWAYS     0x000000F0  // Always event
+#define ADC_EMUX_EM0_M          0x0000000F  // Event mux 0 mask
+#define ADC_EMUX_EM0_PROCESSOR  0x00000000  // Processor event
+#define ADC_EMUX_EM0_COMP0      0x00000001  // Analog comparator 0 event
+#define ADC_EMUX_EM0_COMP1      0x00000002  // Analog comparator 1 event
+#define ADC_EMUX_EM0_COMP2      0x00000003  // Analog comparator 2 event
+#define ADC_EMUX_EM0_EXTERNAL   0x00000004  // External event
+#define ADC_EMUX_EM0_TIMER      0x00000005  // Timer event
+#define ADC_EMUX_EM0_PWM0       0x00000006  // PWM0 event
+#define ADC_EMUX_EM0_PWM1       0x00000007  // PWM1 event
+#define ADC_EMUX_EM0_PWM2       0x00000008  // PWM2 event
+#define ADC_EMUX_EM0_ALWAYS     0x0000000F  // Always event
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_USTAT register.
+//
+//*****************************************************************************
+#define ADC_USTAT_UV3           0x00000008  // Sample sequence 3 underflow
+#define ADC_USTAT_UV2           0x00000004  // Sample sequence 2 underflow
+#define ADC_USTAT_UV1           0x00000002  // Sample sequence 1 underflow
+#define ADC_USTAT_UV0           0x00000001  // Sample sequence 0 underflow
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_SSPRI register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_M         0x00003000  // Sequencer 3 priority mask
+#define ADC_SSPRI_SS3_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS3_2ND       0x00001000  // Second priority
+#define ADC_SSPRI_SS3_3RD       0x00002000  // Third priority
+#define ADC_SSPRI_SS3_4TH       0x00003000  // Fourth priority
+#define ADC_SSPRI_SS2_M         0x00000300  // Sequencer 2 priority mask
+#define ADC_SSPRI_SS2_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS2_2ND       0x00000100  // Second priority
+#define ADC_SSPRI_SS2_3RD       0x00000200  // Third priority
+#define ADC_SSPRI_SS2_4TH       0x00000300  // Fourth priority
+#define ADC_SSPRI_SS1_M         0x00000030  // Sequencer 1 priority mask
+#define ADC_SSPRI_SS1_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS1_2ND       0x00000010  // Second priority
+#define ADC_SSPRI_SS1_3RD       0x00000020  // Third priority
+#define ADC_SSPRI_SS1_4TH       0x00000030  // Fourth priority
+#define ADC_SSPRI_SS0_M         0x00000003  // Sequencer 0 priority mask
+#define ADC_SSPRI_SS0_1ST       0x00000000  // First priority
+#define ADC_SSPRI_SS0_2ND       0x00000001  // Second priority
+#define ADC_SSPRI_SS0_3RD       0x00000002  // Third priority
+#define ADC_SSPRI_SS0_4TH       0x00000003  // Fourth priority
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_PSSI register.
+//
+//*****************************************************************************
+#define ADC_PSSI_SS3            0x00000008  // Trigger sample sequencer 3
+#define ADC_PSSI_SS2            0x00000004  // Trigger sample sequencer 2
+#define ADC_PSSI_SS1            0x00000002  // Trigger sample sequencer 1
+#define ADC_PSSI_SS0            0x00000001  // Trigger sample sequencer 0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_SAC register.
+//
+//*****************************************************************************
+#define ADC_SAC_AVG_M           0x00000007  // Hardware Averaging Control.
+#define ADC_SAC_AVG_64X         0x00000006  // 64x hardware oversampling
+#define ADC_SAC_AVG_32X         0x00000005  // 32x hardware oversampling
+#define ADC_SAC_AVG_16X         0x00000004  // 16x hardware oversampling
+#define ADC_SAC_AVG_8X          0x00000003  // 8x hardware oversampling
+#define ADC_SAC_AVG_4X          0x00000002  // 4x hardware oversampling
+#define ADC_SAC_AVG_2X          0x00000001  // 2x hardware oversampling
+#define ADC_SAC_AVG_OFF         0x00000000  // No hardware oversampling
+
+//*****************************************************************************
+//
+// The following are defines for the the interpretation of the data in the
+// SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_TMLB_CNT_M   0x000003C0  // Continuous Sample Counter.
+#define ADC_SSFIFO_TMLB_CONT    0x00000020  // Continuation Sample Indicator.
+#define ADC_SSFIFO_TMLB_DIFF    0x00000010  // Differential Sample Indicator.
+#define ADC_SSFIFO_TMLB_TS      0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_SSFIFO_TMLB_MUX_M   0x00000007  // Analog Input Indicator.
+#define ADC_SSFIFO_TMLB_CNT_S   6           // Sample counter shift
+#define ADC_SSFIFO_TMLB_MUX_S   0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_TMLB register.
+//
+//*****************************************************************************
+#define ADC_TMLB_LB             0x00000001  // Loopback control signals
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX0 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX0_MUX7_M       0x70000000  // 8th Sample Input Select.
+#define ADC_SSMUX0_MUX6_M       0x07000000  // 7th Sample Input Select.
+#define ADC_SSMUX0_MUX5_M       0x00700000  // 6th Sample Input Select.
+#define ADC_SSMUX0_MUX4_M       0x00070000  // 5th Sample Input Select.
+#define ADC_SSMUX0_MUX3_M       0x00007000  // 4th Sample Input Select.
+#define ADC_SSMUX0_MUX2_M       0x00000700  // 3rd Sample Input Select.
+#define ADC_SSMUX0_MUX1_M       0x00000070  // 2nd Sample Input Select.
+#define ADC_SSMUX0_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX0_MUX7_S       28
+#define ADC_SSMUX0_MUX6_S       24
+#define ADC_SSMUX0_MUX5_S       20
+#define ADC_SSMUX0_MUX4_S       16
+#define ADC_SSMUX0_MUX3_S       12
+#define ADC_SSMUX0_MUX2_S       8
+#define ADC_SSMUX0_MUX1_S       4
+#define ADC_SSMUX0_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL0 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL0_TS7          0x80000000  // 8th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE7          0x40000000  // 8th Sample Interrupt Enable.
+#define ADC_SSCTL0_END7         0x20000000  // 8th Sample is End of Sequence.
+#define ADC_SSCTL0_D7           0x10000000  // 8th Sample Diff Input Select.
+#define ADC_SSCTL0_TS6          0x08000000  // 7th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE6          0x04000000  // 7th Sample Interrupt Enable.
+#define ADC_SSCTL0_END6         0x02000000  // 7th Sample is End of Sequence.
+#define ADC_SSCTL0_D6           0x01000000  // 7th Sample Diff Input Select.
+#define ADC_SSCTL0_TS5          0x00800000  // 6th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE5          0x00400000  // 6th Sample Interrupt Enable.
+#define ADC_SSCTL0_END5         0x00200000  // 6th Sample is End of Sequence.
+#define ADC_SSCTL0_D5           0x00100000  // 6th Sample Diff Input Select.
+#define ADC_SSCTL0_TS4          0x00080000  // 5th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE4          0x00040000  // 5th Sample Interrupt Enable.
+#define ADC_SSCTL0_END4         0x00020000  // 5th Sample is End of Sequence.
+#define ADC_SSCTL0_D4           0x00010000  // 5th Sample Diff Input Select.
+#define ADC_SSCTL0_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL0_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL0_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL0_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL0_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL0_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL0_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL0_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL0_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL0_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL0_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL0_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL0_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO0_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO0_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT0_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT0_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT0_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT0_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT0_HPTR_S     4
+#define ADC_SSFSTAT0_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX1 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX1_MUX3_M       0x00007000  // 4th Sample Input Select.
+#define ADC_SSMUX1_MUX2_M       0x00000700  // 3rd Sample Input Select.
+#define ADC_SSMUX1_MUX1_M       0x00000070  // 2nd Sample Input Select.
+#define ADC_SSMUX1_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX1_MUX3_S       12
+#define ADC_SSMUX1_MUX2_S       8
+#define ADC_SSMUX1_MUX1_S       4
+#define ADC_SSMUX1_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL1 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL1_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL1_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL1_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL1_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL1_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL1_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL1_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL1_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL1_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL1_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL1_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL1_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL1_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO1_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO1_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT1_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT1_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT1_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT1_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT1_HPTR_S     4
+#define ADC_SSFSTAT1_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX2 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX2_MUX3_M       0x00007000  // 4th Sample Input Select.
+#define ADC_SSMUX2_MUX2_M       0x00000700  // 3rd Sample Input Select.
+#define ADC_SSMUX2_MUX1_M       0x00000070  // 2nd Sample Input Select.
+#define ADC_SSMUX2_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX2_MUX3_S       12
+#define ADC_SSMUX2_MUX2_S       8
+#define ADC_SSMUX2_MUX1_S       4
+#define ADC_SSMUX2_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL2 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL2_TS3          0x00008000  // 4th Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE3          0x00004000  // 4th Sample Interrupt Enable.
+#define ADC_SSCTL2_END3         0x00002000  // 4th Sample is End of Sequence.
+#define ADC_SSCTL2_D3           0x00001000  // 4th Sample Diff Input Select.
+#define ADC_SSCTL2_TS2          0x00000800  // 3rd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE2          0x00000400  // 3rd Sample Interrupt Enable.
+#define ADC_SSCTL2_END2         0x00000200  // 3rd Sample is End of Sequence.
+#define ADC_SSCTL2_D2           0x00000100  // 3rd Sample Diff Input Select.
+#define ADC_SSCTL2_TS1          0x00000080  // 2nd Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE1          0x00000040  // 2nd Sample Interrupt Enable.
+#define ADC_SSCTL2_END1         0x00000020  // 2nd Sample is End of Sequence.
+#define ADC_SSCTL2_D1           0x00000010  // 2nd Sample Diff Input Select.
+#define ADC_SSCTL2_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL2_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL2_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL2_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO2_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO2_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT2_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT2_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT2_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT2_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT2_HPTR_S     4
+#define ADC_SSFSTAT2_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSMUX3 register.
+//
+//*****************************************************************************
+#define ADC_SSMUX3_MUX0_M       0x00000007  // 1st Sample Input Select.
+#define ADC_SSMUX3_MUX0_S       0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSCTL3 register.
+//
+//*****************************************************************************
+#define ADC_SSCTL3_TS0          0x00000008  // 1st Sample Temp Sensor Select.
+#define ADC_SSCTL3_IE0          0x00000004  // 1st Sample Interrupt Enable.
+#define ADC_SSCTL3_END0         0x00000002  // 1st Sample is End of Sequence.
+#define ADC_SSCTL3_D0           0x00000001  // 1st Sample Diff Input Select.
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.
+//
+//*****************************************************************************
+#define ADC_SSFIFO3_DATA_M      0x000003FF  // Conversion Result Data.
+#define ADC_SSFIFO3_DATA_S      0
+
+//*****************************************************************************
+//
+// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT3_FULL       0x00001000  // FIFO Full.
+#define ADC_SSFSTAT3_EMPTY      0x00000100  // FIFO Empty.
+#define ADC_SSFSTAT3_HPTR_M     0x000000F0  // FIFO Head Pointer.
+#define ADC_SSFSTAT3_TPTR_M     0x0000000F  // FIFO Tail Pointer.
+#define ADC_SSFSTAT3_HPTR_S     4
+#define ADC_SSFSTAT3_TPTR_S     0
+
+//*****************************************************************************
+//
+// The following definitions are deprecated.
+//
+//*****************************************************************************
+#ifndef DEPRECATED
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the ADC sequence register offsets.
+//
+//*****************************************************************************
+#define ADC_O_SEQ               0x00000040  // Offset to the first sequence
+#define ADC_O_SEQ_STEP          0x00000020  // Increment to the next sequence
+#define ADC_O_X_SSFSTAT         0x0000000C  // FIFO status register
+#define ADC_O_X_SSFIFO          0x00000008  // Result FIFO register
+#define ADC_O_X_SSCTL           0x00000004  // Sample sequence control register
+#define ADC_O_X_SSMUX           0x00000000  // Multiplexer select register
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_EMUX
+// register.
+//
+//*****************************************************************************
+#define ADC_EMUX_EM3_MASK       0x0000F000  // Event mux 3 mask
+#define ADC_EMUX_EM2_MASK       0x00000F00  // Event mux 2 mask
+#define ADC_EMUX_EM1_MASK       0x000000F0  // Event mux 1 mask
+#define ADC_EMUX_EM0_MASK       0x0000000F  // Event mux 0 mask
+#define ADC_EMUX_EM3_SHIFT      12          // The shift for the fourth event
+#define ADC_EMUX_EM2_SHIFT      8           // The shift for the third event
+#define ADC_EMUX_EM1_SHIFT      4           // The shift for the second event
+#define ADC_EMUX_EM0_SHIFT      0           // The shift for the first event
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSPRI
+// register.
+//
+//*****************************************************************************
+#define ADC_SSPRI_SS3_MASK      0x00003000  // Sequencer 3 priority mask
+#define ADC_SSPRI_SS2_MASK      0x00000300  // Sequencer 2 priority mask
+#define ADC_SSPRI_SS1_MASK      0x00000030  // Sequencer 1 priority mask
+#define ADC_SSPRI_SS0_MASK      0x00000003  // Sequencer 0 priority mask
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSMUX0,
+// ADC_SSMUX1, ADC_SSMUX2, and ADC_SSMUX3 registers. Not all fields are present
+// in all registers.
+//
+//*****************************************************************************
+#define ADC_SSMUX_MUX7_MASK     0x70000000  // 8th mux select mask
+#define ADC_SSMUX_MUX6_MASK     0x07000000  // 7th mux select mask
+#define ADC_SSMUX_MUX5_MASK     0x00700000  // 6th mux select mask
+#define ADC_SSMUX_MUX4_MASK     0x00070000  // 5th mux select mask
+#define ADC_SSMUX_MUX3_MASK     0x00007000  // 4th mux select mask
+#define ADC_SSMUX_MUX2_MASK     0x00000700  // 3rd mux select mask
+#define ADC_SSMUX_MUX1_MASK     0x00000070  // 2nd mux select mask
+#define ADC_SSMUX_MUX0_MASK     0x00000007  // 1st mux select mask
+#define ADC_SSMUX_MUX7_SHIFT    28
+#define ADC_SSMUX_MUX6_SHIFT    24
+#define ADC_SSMUX_MUX5_SHIFT    20
+#define ADC_SSMUX_MUX4_SHIFT    16
+#define ADC_SSMUX_MUX3_SHIFT    12
+#define ADC_SSMUX_MUX2_SHIFT    8
+#define ADC_SSMUX_MUX1_SHIFT    4
+#define ADC_SSMUX_MUX0_SHIFT    0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSCTL0,
+// ADC_SSCTL1, ADC_SSCTL2, and ADC_SSCTL3 registers. Not all fields are present
+// in all registers.
+//
+//*****************************************************************************
+#define ADC_SSCTL_TS7           0x80000000  // 8th temperature sensor select
+#define ADC_SSCTL_IE7           0x40000000  // 8th interrupt enable
+#define ADC_SSCTL_END7          0x20000000  // 8th sequence end select
+#define ADC_SSCTL_D7            0x10000000  // 8th differential select
+#define ADC_SSCTL_TS6           0x08000000  // 7th temperature sensor select
+#define ADC_SSCTL_IE6           0x04000000  // 7th interrupt enable
+#define ADC_SSCTL_END6          0x02000000  // 7th sequence end select
+#define ADC_SSCTL_D6            0x01000000  // 7th differential select
+#define ADC_SSCTL_TS5           0x00800000  // 6th temperature sensor select
+#define ADC_SSCTL_IE5           0x00400000  // 6th interrupt enable
+#define ADC_SSCTL_END5          0x00200000  // 6th sequence end select
+#define ADC_SSCTL_D5            0x00100000  // 6th differential select
+#define ADC_SSCTL_TS4           0x00080000  // 5th temperature sensor select
+#define ADC_SSCTL_IE4           0x00040000  // 5th interrupt enable
+#define ADC_SSCTL_END4          0x00020000  // 5th sequence end select
+#define ADC_SSCTL_D4            0x00010000  // 5th differential select
+#define ADC_SSCTL_TS3           0x00008000  // 4th temperature sensor select
+#define ADC_SSCTL_IE3           0x00004000  // 4th interrupt enable
+#define ADC_SSCTL_END3          0x00002000  // 4th sequence end select
+#define ADC_SSCTL_D3            0x00001000  // 4th differential select
+#define ADC_SSCTL_TS2           0x00000800  // 3rd temperature sensor select
+#define ADC_SSCTL_IE2           0x00000400  // 3rd interrupt enable
+#define ADC_SSCTL_END2          0x00000200  // 3rd sequence end select
+#define ADC_SSCTL_D2            0x00000100  // 3rd differential select
+#define ADC_SSCTL_TS1           0x00000080  // 2nd temperature sensor select
+#define ADC_SSCTL_IE1           0x00000040  // 2nd interrupt enable
+#define ADC_SSCTL_END1          0x00000020  // 2nd sequence end select
+#define ADC_SSCTL_D1            0x00000010  // 2nd differential select
+#define ADC_SSCTL_TS0           0x00000008  // 1st temperature sensor select
+#define ADC_SSCTL_IE0           0x00000004  // 1st interrupt enable
+#define ADC_SSCTL_END0          0x00000002  // 1st sequence end select
+#define ADC_SSCTL_D0            0x00000001  // 1st differential select
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSFIFO0,
+// ADC_SSFIFO1, ADC_SSFIFO2, and ADC_SSFIFO3 registers.
+//
+//*****************************************************************************
+#define ADC_SSFIFO_DATA_MASK    0x000003FF  // Sample data
+#define ADC_SSFIFO_DATA_SHIFT   0
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the ADC_SSFSTAT0,
+// ADC_SSFSTAT1, ADC_SSFSTAT2, and ADC_SSFSTAT3 registers.
+//
+//*****************************************************************************
+#define ADC_SSFSTAT_FULL        0x00001000  // FIFO is full
+#define ADC_SSFSTAT_EMPTY       0x00000100  // FIFO is empty
+#define ADC_SSFSTAT_HPTR        0x000000F0  // FIFO head pointer
+#define ADC_SSFSTAT_TPTR        0x0000000F  // FIFO tail pointer
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the the interpretation of the data
+// in the SSFIFOx when the ADC TMLB is enabled.
+//
+//*****************************************************************************
+#define ADC_TMLB_CNT_M          0x000003C0  // Continuous Sample Counter.
+#define ADC_TMLB_CONT           0x00000020  // Continuation Sample Indicator.
+#define ADC_TMLB_DIFF           0x00000010  // Differential Sample Indicator.
+#define ADC_TMLB_TS             0x00000008  // Temp Sensor Sample Indicator.
+#define ADC_TMLB_MUX_M          0x00000007  // Analog Input Indicator.
+#define ADC_TMLB_CNT_S          6           // Sample counter shift
+#define ADC_TMLB_MUX_S          0           // Input channel number shift
+
+//*****************************************************************************
+//
+// The following are deprecated defines for the bit fields in the loopback ADC
+// data.
+//
+//*****************************************************************************
+#define ADC_LB_CNT_MASK         0x000003C0  // Sample counter mask
+#define ADC_LB_CONT             0x00000020  // Continuation sample
+#define ADC_LB_DIFF             0x00000010  // Differential sample
+#define ADC_LB_TS               0x00000008  // Temperature sensor sample
+#define ADC_LB_MUX_MASK         0x00000007  // Input channel number mask
+#define ADC_LB_CNT_SHIFT        6           // Sample counter shift
+#define ADC_LB_MUX_SHIFT        0           // Input channel number shift
+
+#endif
+
+#endif // __HW_ADC_H__

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/lm3s/platform.c	2009-01-21 23:40:34 UTC (rev 159)
@@ -10,10 +10,11 @@
 #include &lt;ctype.h&gt;
 #include &lt;stdio.h&gt;
 #include &quot;uip_arp.h&quot;
-#include &quot;elua_uip.h&quot; 
+#include &quot;elua_uip.h&quot;
 #include &quot;uip-conf.h&quot;
 #include &quot;platform_conf.h&quot;
 #include &quot;common.h&quot;
+#include &quot;math.h&quot;
 
 // Platform specific includes
 #include &quot;hw_ints.h&quot;
@@ -38,6 +39,7 @@
 #include &quot;dhcpc.h&quot;
 #include &quot;rit128x96x4.h&quot;
 #include &quot;disp.h&quot;
+#include &quot;adc.h&quot;
 
 // UIP sys tick data
 // NOTE: when using virtual timers, SYSTICKHZ and VTMR_FREQ_HZ should have the
@@ -55,12 +57,13 @@
 static void pios_init();
 static void pwms_init();
 static void eth_init();
+static void adcs_init();
 
 int platform_init()
-{ 
+{
   // Set the clocking to run from PLL
   SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_8MHZ);
-  
+
   // Setup PIO
   pios_init();
 
@@ -69,40 +72,43 @@
 
   // Setup UARTs
   uarts_init();
-  
+
   // Setup timers
-  timers_init();        
-  
+  timers_init();
+
   // Setup PWMs
-  pwms_init();                 
-  
+  pwms_init();
+
+  // Setup ADCs
+	adcs_init();
+
   // Setup ethernet (TCP/IP)
   eth_init();
 
   // Common platform initialization code
   cmn_platform_init();
-  
+
   // Virtual timers
-  // If the ethernet controller is used the timer is already initialized, so skip this sequence  
+  // If the ethernet controller is used the timer is already initialized, so skip this sequence
 #if VTMR_NUM_TIMERS &gt; 0 &amp;&amp; !defined( BUILD_UIP )
   // Configure SysTick for a periodic interrupt.
   SysTickPeriodSet( SysCtlClockGet() / SYSTICKHZ );
   SysTickEnable();
-  SysTickIntEnable();  
+  SysTickIntEnable();
   IntMasterEnable();
 #endif
-  
+
   // All done
   return PLATFORM_OK;
-} 
+}
 
 // ****************************************************************************
 // PIO
 // Same configuration on LM3S8962 and LM3S6965
 
-static const u32 pio_base[] = { GPIO_PORTA_BASE, GPIO_PORTB_BASE, GPIO_PORTC_BASE, GPIO_PORTD_BASE, 
+static const u32 pio_base[] = { GPIO_PORTA_BASE, GPIO_PORTB_BASE, GPIO_PORTC_BASE, GPIO_PORTD_BASE,
                                 GPIO_PORTE_BASE, GPIO_PORTF_BASE, GPIO_PORTG_BASE, GPIO_PORTH_BASE };
-static const u32 pio_sysctl[] = { SYSCTL_PERIPH_GPIOA, SYSCTL_PERIPH_GPIOB, SYSCTL_PERIPH_GPIOC, SYSCTL_PERIPH_GPIOD, 
+static const u32 pio_sysctl[] = { SYSCTL_PERIPH_GPIOA, SYSCTL_PERIPH_GPIOB, SYSCTL_PERIPH_GPIOC, SYSCTL_PERIPH_GPIOD,
                                   SYSCTL_PERIPH_GPIOE, SYSCTL_PERIPH_GPIOF, SYSCTL_PERIPH_GPIOG, SYSCTL_PERIPH_GPIOH };
 
 static void pios_init()
@@ -116,50 +122,50 @@
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
   pio_type retval = 1, base = pio_base[ port ];
-  
+
   switch( op )
   {
-    case PLATFORM_IO_PORT_SET_VALUE:    
+    case PLATFORM_IO_PORT_SET_VALUE:
       GPIOPinWrite( base, 0xFF, pinmask );
       break;
-      
+
     case PLATFORM_IO_PIN_SET:
       GPIOPinWrite( base, pinmask, pinmask );
       break;
-      
+
     case PLATFORM_IO_PIN_CLEAR:
       GPIOPinWrite( base, pinmask, 0 );
       break;
-      
+
     case PLATFORM_IO_PORT_DIR_INPUT:
-      pinmask = 0xFF;      
+      pinmask = 0xFF;
     case PLATFORM_IO_PIN_DIR_INPUT:
       GPIOPinTypeGPIOInput( base, pinmask );
       break;
-      
-    case PLATFORM_IO_PORT_DIR_OUTPUT:      
+
+    case PLATFORM_IO_PORT_DIR_OUTPUT:
       pinmask = 0xFF;
     case PLATFORM_IO_PIN_DIR_OUTPUT:
       GPIOPinTypeGPIOOutput( base, pinmask );
-      break;      
-            
+      break;
+
     case PLATFORM_IO_PORT_GET_VALUE:
       retval = GPIOPinRead( base, 0xFF );
       break;
-      
+
     case PLATFORM_IO_PIN_GET:
       retval = GPIOPinRead( base, pinmask ) ? 1 : 0;
       break;
-      
+
     case PLATFORM_IO_PIN_PULLUP:
     case PLATFORM_IO_PIN_PULLDOWN:
       GPIOPadConfigSet( base, pinmask, GPIO_STRENGTH_8MA, op == PLATFORM_IO_PIN_PULLUP ? GPIO_PIN_TYPE_STD_WPU : GPIO_PIN_TYPE_STD_WPD );
       break;
-      
+
     case PLATFORM_IO_PIN_NOPULL:
       GPIOPadConfigSet( base, pinmask, GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD );
       break;
-      
+
     default:
       retval = 0;
       break;
@@ -193,18 +199,18 @@
 u32 platform_spi_setup( unsigned id, int mode, u32 clock, unsigned cpol, unsigned cpha, unsigned databits )
 {
   unsigned protocol;
-  
+
   if( cpol == 0 )
     protocol = cpha ? SSI_FRF_MOTO_MODE_1 : SSI_FRF_MOTO_MODE_0;
   else
     protocol = cpha ? SSI_FRF_MOTO_MODE_3 : SSI_FRF_MOTO_MODE_2;
-  mode = mode == PLATFORM_SPI_MASTER ? SSI_MODE_MASTER : SSI_MODE_SLAVE;  
+  mode = mode == PLATFORM_SPI_MASTER ? SSI_MODE_MASTER : SSI_MODE_SLAVE;
   SSIDisable( spi_base[ id ] );
 
   GPIOPinTypeSSI( spi_gpio_base[ id ], spi_gpio_pins[ id ] );
-  
+
   // FIXME: not sure this is always &quot;right&quot;
-  GPIOPadConfigSet(spi_gpio_base[ id ], spi_gpio_clk_pin[ id ], GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD_WPU);    
+  GPIOPadConfigSet(spi_gpio_base[ id ], spi_gpio_clk_pin[ id ], GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD_WPU);
 
   SSIConfigSetExpClk( spi_base[ id ], SysCtlClockGet(), protocol, mode, clock, databits );
   SSIEnable( spi_base[ id ] );
@@ -220,7 +226,7 @@
 
 void platform_spi_select( unsigned id, int is_select )
 {
-  // This platform doesn't have a hardware SS pin, so there's nothing to do here  
+  // This platform doesn't have a hardware SS pin, so there's nothing to do here
   id = id;
   is_select = is_select;
 }
@@ -247,13 +253,13 @@
   GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
   UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), CON_UART_SPEED,
                      (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
-                      UART_CONFIG_PAR_NONE)); 
+                      UART_CONFIG_PAR_NONE));
 }
 
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   u32 config;
-  
+
   GPIOPinTypeUART(uart_gpio_base [ id ], uart_gpio_pins[ id ]);
 
   switch( databits )
@@ -278,7 +284,7 @@
     config |= UART_CONFIG_PAR_ODD;
   else
     config |= UART_CONFIG_PAR_NONE;
-    
+
   return UARTConfigSetExpClk(uart_base[ id ], SysCtlClockGet(), baud, config);
 }
 
@@ -290,9 +296,9 @@
 int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
   u32 base = uart_base[ id ];
-  
+
   if( timeout == 0 )
-    return UARTCharGetNonBlocking( base );  
+    return UARTCharGetNonBlocking( base );
   return UARTCharGet( base );
 }
 
@@ -320,17 +326,17 @@
 {
   timer_data_type final;
   u32 base = timer_base[ id ];
-  
+
   final = 0xFFFFFFFF - ( ( ( u64 )delay_us * SysCtlClockGet() ) / 1000000 );
   TimerLoadSet( base, TIMER_A, 0xFFFFFFFF );
   while( TimerValueGet( base, TIMER_A ) &gt; final );
 }
-      
+
 u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
-  u32 base = timer_base[ id ]; 
-  
+  u32 base = timer_base[ id ];
+
   data = data;
   switch( op )
   {
@@ -338,24 +344,24 @@
       res = 0xFFFFFFFF;
       TimerLoadSet( base, TIMER_A, 0xFFFFFFFF );
       break;
-      
+
     case PLATFORM_TIMER_OP_READ:
       res = TimerValueGet( base, TIMER_A );
       break;
-      
+
     case PLATFORM_TIMER_OP_GET_MAX_DELAY:
       res = platform_timer_get_diff_us( id, 0, 0xFFFFFFFF );
       break;
-      
+
     case PLATFORM_TIMER_OP_GET_MIN_DELAY:
       res = platform_timer_get_diff_us( id, 0, 1 );
       break;
-      
+
     case PLATFORM_TIMER_OP_SET_CLOCK:
     case PLATFORM_TIMER_OP_GET_CLOCK:
       res = SysCtlClockGet();
       break;
-      
+
   }
   return res;
 }
@@ -369,7 +375,7 @@
 const static u8 pwm_div_data[] = { 1, 2, 4, 8, 16, 32, 64 };
 // Port/pin information for all channels
 #ifdef FORLM3S6965
-  const static u32 pwm_ports[] =  { GPIO_PORTF_BASE, GPIO_PORTD_BASE, GPIO_PORTB_BASE, GPIO_PORTB_BASE, GPIO_PORTE_BASE, GPIO_PORTE_BASE };  
+  const static u32 pwm_ports[] =  { GPIO_PORTF_BASE, GPIO_PORTD_BASE, GPIO_PORTB_BASE, GPIO_PORTB_BASE, GPIO_PORTE_BASE, GPIO_PORTE_BASE };
 #else
   const static u32 pwm_ports[] =  { GPIO_PORTF_BASE, GPIO_PORTG_BASE, GPIO_PORTB_BASE, GPIO_PORTB_BASE, GPIO_PORTE_BASE, GPIO_PORTE_BASE };
 #endif
@@ -390,7 +396,7 @@
 {
   unsigned i;
   u32 clk;
-  
+
   clk = SysCtlPWMClockGet();
   for( i = 0; i &lt; sizeof( pwm_div_ctl ) / sizeof( u32 ); i ++ )
     if( clk == pwm_div_ctl[ i ] )
@@ -403,7 +409,7 @@
 {
   unsigned i, min_i;
   u32 sysclk;
-  
+
   sysclk = SysCtlClockGet();
   for( i = min_i = 0; i &lt; sizeof( pwm_div_data ) / sizeof( u8 ); i ++ )
     if( ABSDIFF( clock, sysclk / pwm_div_data[ i ] ) &lt; ABSDIFF( clock, sysclk / pwm_div_data[ min_i ] ) )
@@ -416,7 +422,7 @@
 {
   u32 pwmclk = platform_pwm_get_clock();
   u32 period;
-  
+
   // Set pin as PWM
   GPIOPinTypePWM( pwm_ports[ id ], pwm_pins[ id ] );
   // Compute period
@@ -433,28 +439,28 @@
 u32 platform_pwm_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
-  
+
   switch( op )
   {
     case PLATFORM_PWM_OP_SET_CLOCK:
       res = platform_pwm_set_clock( data );
       break;
-            
+
     case PLATFORM_PWM_OP_GET_CLOCK:
       res = platform_pwm_get_clock();
       break;
-      
+
     case PLATFORM_PWM_OP_START:
       PWMOutputState( PWM_BASE, 1 &lt;&lt; id, true );
       PWMGenEnable( PWM_BASE, pwm_gens[ id &gt;&gt; 1 ] );
       break;
-      
+
     case PLATFORM_PWM_OP_STOP:
       PWMOutputState( PWM_BASE, 1 &lt;&lt; id, false );
       PWMGenDisable( PWM_BASE, pwm_gens[ id &gt;&gt; 1 ] );
       break;
   }
-  
+
   return res;
 }
 
@@ -471,50 +477,112 @@
   IntMasterDisable();
 }
 
+
+// *****************************************************************************
+// ADC specific functions
+
+/*int platform_adc_exists( unsigned id ); generic, it will be part of src/common.c */
+
+static void adcs_init(unsigned id)
+{
+	SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC);
+}
+
+
+u16 platform_adc_sample( unsigned id ) /* sample the specified ADC channel */
+{
+  u16 samplevalue;
+
+  /* Wait for data if not ready */
+  while(!ADCIntStatus(ADC_BASE, id, false))
+  {
+  }
+
+  /* Get sample, comes back as unsigned long... */
+  ADCSequenceDataGet(ADC_BASE, id, &amp;samplevalue);
+
+  return samplevalue;
+}
+
+void platform_adc_start( unsigned id ) /* starts a conversion on the specified ADC channel and returns immediately */
+{
+  ADCSequenceEnable(ADC_BASE, id);
+  ADCProcessorTrigger(ADC_BASE, id);
+}
+
+u16 platform_adc_maxval( unsigned id ) /* Returns maximum possible conversion value from ADC */
+{
+  return pow(2,ADC_BIT_RESOLUTION)-1;
+}
+
+int platform_adc_is_done( unsigned id ) /* returns 1 if the conversion on the specified channel ended, 0 otherwise */
+{
+  return !ADCIntStatus(ADC_BASE, id, false);
+}
+
+void platform_adc_set_mode( unsigned id, int mode ) /* sets the mode on the specified ADC channel to either &quot;single shot&quot; or &quot;continuous&quot; */
+{
+  /* currently mode is ignored... acquisition is currently just single-shot */
+
+  /* Stop sequencer we're going to adjust */
+  ADCSequenceDisable(ADC_BASE, id);
+
+  /* Set sequence id to be triggered by processor, with priority 0  */
+  /* Not sure what happens if priority is nonzero, just make priority tied to id number */
+  ADCSequenceConfigure(ADC_BASE, id, ADC_TRIGGER_PROCESSOR, id);
+
+  ADCSequenceStepConfigure(ADC_BASE, id, 0, ADC_CTL_IE | ADC_CTL_END | ADC_CTL_CH0);
+}
+
+void platform_adc_burst( unsigned id, u16* buf, unsigned count, u32 frequency ) /* burst conversion: read &quot;count&quot; samples from the ADC channel &quot;id&quot;, storing the results in &quot;buf&quot;. The samples are read at periodic intervals, the period is given by &quot;frequency&quot;. */
+{
+  /* not yet implemented */
+}
+
 // ****************************************************************************
 // OLED Display specific functions
-// 
+//
 // Initially immplementing the funcionalities offered by the RIT128x96x4
 // OLED display driver.
 
-void lm3s_disp_init( unsigned long freq ) 
+void lm3s_disp_init( unsigned long freq )
 {
   RIT128x96x4Init( freq );
 }
-    
-void lm3s_disp_clear() 
-{  
+
+void lm3s_disp_clear()
+{
   RIT128x96x4Clear();
 }
 
-void lm3s_disp_stringDraw( const char *str, unsigned long x, unsigned long y, unsigned char level ) 
+void lm3s_disp_stringDraw( const char *str, unsigned long x, unsigned long y, unsigned char level )
 {
   RIT128x96x4StringDraw( str, x, y, level );
 }
 
-void lm3s_disp_imageDraw( const unsigned char *img, unsigned long x, unsigned long y, 
-                              unsigned long width, unsigned long height ) 
+void lm3s_disp_imageDraw( const unsigned char *img, unsigned long x, unsigned long y,
+                              unsigned long width, unsigned long height )
 {
   RIT128x96x4ImageDraw( img, x, y, width, height );
 }
 
 
-void lm3s_disp_enable( unsigned long freq ) 
+void lm3s_disp_enable( unsigned long freq )
 {
   RIT128x96x4Enable( freq );
 }
 
-void lm3s_disp_disable() 
+void lm3s_disp_disable()
 {
   RIT128x96x4Disable();
 }
 
-void lm3s_disp_displayOn() 
+void lm3s_disp_displayOn()
 {
   RIT128x96x4DisplayOn();
 }
 
-void lm3s_disp_displayOff() 
+void lm3s_disp_displayOff()
 {
   RIT128x96x4DisplayOff();
 }
@@ -526,12 +594,12 @@
 {
 #ifdef BUILD_UIP
   u32 user0, user1, temp;
-  static struct uip_eth_addr sTempAddr;     
-  
+  static struct uip_eth_addr sTempAddr;
+
   // Enable and reset the controller
   SysCtlPeripheralEnable( SYSCTL_PERIPH_ETH );
   SysCtlPeripheralReset( SYSCTL_PERIPH_ETH );
-  
+
   // Enable Ethernet LEDs
   GPIODirModeSet( GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_3, GPIO_DIR_MODE_HW );
   GPIOPadConfigSet( GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_3, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD );
@@ -540,13 +608,13 @@
   SysTickPeriodSet(SysCtlClockGet() / SYSTICKHZ);
   SysTickEnable();
   SysTickIntEnable();
-  
+
   // Intialize the Ethernet Controller and disable all Ethernet Controller interrupt sources.
   EthernetIntDisable(ETH_BASE, (ETH_INT_PHY | ETH_INT_MDIO | ETH_INT_RXER |
                      ETH_INT_RXOF | ETH_INT_TX | ETH_INT_TXER | ETH_INT_RX));
   temp = EthernetIntStatus(ETH_BASE, false);
-  EthernetIntClear(ETH_BASE, temp);  
-  
+  EthernetIntClear(ETH_BASE, temp);
+
   // Initialize the Ethernet Controller for operation.
   EthernetInitExpClk(ETH_BASE, SysCtlClockGet());
 
@@ -564,7 +632,7 @@
   IntEnable(INT_ETH);
 
   // Enable the Ethernet RX Packet interrupt source.
-  EthernetIntEnable(ETH_BASE, ETH_INT_RX);  
+  EthernetIntEnable(ETH_BASE, ETH_INT_RX);
 
   // Enable all processor interrupts.
   IntMasterEnable();
@@ -576,7 +644,7 @@
   // non-volatile USER0 and USER1 registers.  These registers can be read
   // using the FlashUserGet function, as illustrated below.
   FlashUserGet(&amp;user0, &amp;user1);
-  
+
   // Convert the 24/24 split MAC address from NV ram into a 32/16 split MAC
   // address needed to program the hardware registers, then program the MAC
   // address into the Ethernet Controller registers.
@@ -585,10 +653,10 @@
   sTempAddr.addr[2] = ((user0 &gt;&gt; 16) &amp; 0xff);
   sTempAddr.addr[3] = ((user1 &gt;&gt;  0) &amp; 0xff);
   sTempAddr.addr[4] = ((user1 &gt;&gt;  8) &amp; 0xff);
-  sTempAddr.addr[5] = ((user1 &gt;&gt; 16) &amp; 0xff);  
+  sTempAddr.addr[5] = ((user1 &gt;&gt; 16) &amp; 0xff);
 
   // Program the hardware with it's MAC address (for filtering).
-  EthernetMACAddrSet(ETH_BASE, (unsigned char *)&amp;sTempAddr);  
+  EthernetMACAddrSet(ETH_BASE, (unsigned char *)&amp;sTempAddr);
 
   // Initialize the eLua uIP layer
   elua_uip_init( &amp;sTempAddr );
@@ -600,7 +668,7 @@
 
 void platform_eth_send_packet( const void* src, u32 size )
 {
-  EthernetPacketPut( ETH_BASE, uip_buf, uip_len );    
+  EthernetPacketPut( ETH_BASE, uip_buf, uip_len );
 }
 
 u32 platform_eth_get_packet_nb( void* buf, u32 maxlen )
@@ -610,7 +678,7 @@
 
 void platform_eth_force_interrupt()
 {
-  HWREG( NVIC_SW_TRIG) |= INT_ETH - 16;  
+  HWREG( NVIC_SW_TRIG) |= INT_ETH - 16;
 }
 
 u32 platform_eth_get_elapsed_time()
@@ -628,7 +696,7 @@
 {
   // Handle virtual timers
   cmn_virtual_timer_cb();
-  
+
   // Indicate that a SysTick interrupt has occurred.
   eth_timer_fired = 1;
 
@@ -640,12 +708,12 @@
 void EthernetIntHandler()
 {
   u32 temp;
-  
+
   // Read and Clear the interrupt.
   temp = EthernetIntStatus( ETH_BASE, false );
   EthernetIntClear( ETH_BASE, temp );
 
-  // Call the UIP main loop  
+  // Call the UIP main loop
   elua_uip_mainloop();
 }
 

Modified: trunk/src/platform/lm3s/platform_conf.h
===================================================================
--- trunk/src/platform/lm3s/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/lm3s/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -51,6 +51,7 @@
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
   _ROM( AUXLIB_NET, luaopen_net, net_map )\
   _ROM( AUXLIB_CPU, luaopen_cpu, cpu_map )\
+  _ROM( AUXLIB_ADC, luaopen_adc, adc_map )\
   _ROM( AUXLIB_DISP, luaopen_disp, disp_map )\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
   
@@ -95,7 +96,11 @@
 #endif
 #define NUM_TIMER             4
 #define NUM_PWM               6
+#define NUM_ADC               4
 
+// ADC Bit Depth for Built-in ADCs
+#define ADC_BIT_RESOLUTION    10
+
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         SysCtlClockGet()
 

Modified: trunk/src/platform/lpc288x/platform_conf.h
===================================================================
--- trunk/src/platform/lpc288x/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/lpc288x/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -39,6 +39,7 @@
 #define NUM_UART              1
 #define NUM_TIMER             2
 #define NUM_PWM               0
+#define NUM_ADC               0
 
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         Fcclk
@@ -70,5 +71,5 @@
   _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
-  
+
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/stm32/platform_conf.h
===================================================================
--- trunk/src/platform/stm32/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/stm32/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -101,6 +101,7 @@
 #define NUM_UART              4
 #define NUM_TIMER             0
 #define NUM_PWM               0
+#define NUM_ADC               0
 
 // CPU frequency (needed by the CPU module, 0 if not used)
 u32 platform_s_cpu_get_frequency();
@@ -177,5 +178,5 @@
   _C( INT_UDMA ),\
   _C( INT_UDMAERR )
 #endif
-  
+
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/str7/platform_conf.h
===================================================================
--- trunk/src/platform/str7/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/str7/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -54,6 +54,7 @@
 #define NUM_UART              4
 #define NUM_TIMER             4
 #define NUM_PWM               3
+#define NUM_ADC               0
 
 // CPU frequency (needed by the CPU module, 0 if not used)
 #define CPU_FREQUENCY         0
@@ -71,6 +72,6 @@
 #define SRAM_ORIGIN           0x20000000
 #define SRAM_SIZE             0x10000
 #define MEM_START_ADDRESS     { ( void* )end }
-#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }  
+#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }
 
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/str9/platform_conf.h
===================================================================
--- trunk/src/platform/str9/platform_conf.h	2009-01-21 23:40:03 UTC (rev 158)
+++ trunk/src/platform/str9/platform_conf.h	2009-01-21 23:40:34 UTC (rev 159)
@@ -40,6 +40,7 @@
 #define NUM_UART              1
 #define NUM_TIMER             4
 #define NUM_PWM               0
+#define NUM_ADC               0
 
 // CPU frequency (needed by the CPU module, 0 if not used)
 u32 SCU_GetMCLKFreqValue();
@@ -72,5 +73,5 @@
   _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
   _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
   _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
-  
+
 #endif // #ifndef __PLATFORM_CONF_H__


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000114.html">[Elua-svn] r158 - trunk/src/modules
</A></li>
	<LI>Next message: <A HREF="000116.html">[Elua-svn] r160 - trunk/romfs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#115">[ date ]</a>
              <a href="thread.html#115">[ thread ]</a>
              <a href="subject.html#115">[ subject ]</a>
              <a href="author.html#115">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
