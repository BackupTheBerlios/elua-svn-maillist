<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Elua-svn] r143 - in trunk: . inc src src/modules src/newlib	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc288x src/platform/stm32	src/platform/stm32/FWLib/library/src src/platform/str7	src/platform/str9
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-svn/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r143%20-%20in%20trunk%3A%20.%20inc%20src%20src/modules%20src/newlib%0A%09src/platform/at91sam7x%20src/platform/avr32%20src/platform/i386%0A%09src/platform/lm3s%20src/platform/lpc288x%20src/platform/stm32%0A%09src/platform/stm32/FWLib/library/src%20src/platform/str7%0A%09src/platform/str9&In-Reply-To=%3C200901072018.n07KI0ft000256%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000098.html">
   <LINK REL="Next"  HREF="000100.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Elua-svn] r143 - in trunk: . inc src src/modules src/newlib	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc288x src/platform/stm32	src/platform/stm32/FWLib/library/src src/platform/str7	src/platform/str9</H1>
    <B>bogdanm at BerliOS</B> 
    <A HREF="mailto:elua-svn%40lists.berlios.de?Subject=Re%3A%20%5BElua-svn%5D%20r143%20-%20in%20trunk%3A%20.%20inc%20src%20src/modules%20src/newlib%0A%09src/platform/at91sam7x%20src/platform/avr32%20src/platform/i386%0A%09src/platform/lm3s%20src/platform/lpc288x%20src/platform/stm32%0A%09src/platform/stm32/FWLib/library/src%20src/platform/str7%0A%09src/platform/str9&In-Reply-To=%3C200901072018.n07KI0ft000256%40sheep.berlios.de%3E"
       TITLE="[Elua-svn] r143 - in trunk: . inc src src/modules src/newlib	src/platform/at91sam7x src/platform/avr32 src/platform/i386	src/platform/lm3s src/platform/lpc288x src/platform/stm32	src/platform/stm32/FWLib/library/src src/platform/str7	src/platform/str9">bogdanm at mail.berlios.de
       </A><BR>
    <I>Wed Jan  7 21:18:00 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000098.html">[Elua-svn] r142 - trunk/src/newlib
</A></li>
        <LI>Next message: <A HREF="000100.html">[Elua-svn] r144 - trunk/src/modules
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bogdanm
Date: 2009-01-07 21:17:18 +0100 (Wed, 07 Jan 2009)
New Revision: 143

Added:
   trunk/inc/common.h
   trunk/src/common.c
   trunk/src/platform/at91sam7x/aic.c
   trunk/src/platform/at91sam7x/aic.h
   trunk/src/platform/lm3s/stacks.h
Removed:
   trunk/src/platform/str9/main.c
Modified:
   trunk/SConstruct
   trunk/inc/platform.h
   trunk/inc/xmodem.h
   trunk/src/main.c
   trunk/src/modules/tmr.c
   trunk/src/newlib/stubs.c
   trunk/src/platform/at91sam7x/board_cstartup.s
   trunk/src/platform/at91sam7x/board_lowlevel.c
   trunk/src/platform/at91sam7x/conf.py
   trunk/src/platform/at91sam7x/platform.c
   trunk/src/platform/at91sam7x/platform_conf.h
   trunk/src/platform/at91sam7x/stacks.h
   trunk/src/platform/avr32/conf.py
   trunk/src/platform/avr32/platform.c
   trunk/src/platform/avr32/platform_conf.h
   trunk/src/platform/i386/conf.py
   trunk/src/platform/i386/platform.c
   trunk/src/platform/i386/platform_conf.h
   trunk/src/platform/lm3s/conf.py
   trunk/src/platform/lm3s/platform.c
   trunk/src/platform/lm3s/platform_conf.h
   trunk/src/platform/lpc288x/lpc2888.lds
   trunk/src/platform/lpc288x/lpc28xx.s
   trunk/src/platform/lpc288x/platform.c
   trunk/src/platform/lpc288x/platform_conf.h
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c
   trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c
   trunk/src/platform/stm32/conf.py
   trunk/src/platform/stm32/lua_lcd.c
   trunk/src/platform/stm32/platform.c
   trunk/src/platform/stm32/platform_conf.h
   trunk/src/platform/stm32/type.h
   trunk/src/platform/str7/platform.c
   trunk/src/platform/str7/platform_conf.h
   trunk/src/platform/str9/platform.c
   trunk/src/platform/str9/platform_conf.h
   trunk/src/platform/str9/startup912.s
   trunk/src/platform/str9/str912fw44.lds
   trunk/src/xmodem.c
Log:
- factored out common code from all backends in src/common.c
- added virtual timers (on LM3S, AVR32 and AT91SAM7 for now)
- added interrupt handling code for AT91SAM7 and AVR32
- fixed two serious bugs that prevented the eLua image to run on both STR9 and LPC2888 (linker command file issues)
- fixed line endings (DOS-&gt;UNIX) in the STM32 library files
- fixed preprocessor errors (hopefully all of them) like #if ELUA_CPU == LM3S8962
- other minor or less than minor fixes :)



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/SConstruct	2009-01-07 20:17:18 UTC (rev 143)
@@ -123,7 +123,7 @@
 local_libs = ''
 
 # Application files
-app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/dlmalloc.c &quot;
+app_files = &quot; src/main.c src/romfs.c src/xmodem.c src/shell.c src/term.c src/dlmalloc.c src/common.c &quot;
 
 # Newlib related files
 newlib_files = &quot; src/newlib/devman.c src/newlib/stubs.c src/newlib/genstd.c src/newlib/stdtcp.c&quot;

Added: trunk/inc/common.h
===================================================================
--- trunk/inc/common.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/inc/common.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -0,0 +1,15 @@
+// Common platform functions
+
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+// Virtual timers data
+#define VTMR_FIRST_ID           ( 32 )
+#define VTMR_GET_ID( x )        ( ( x ) - VTMR_FIRST_ID )
+#define TIMER_IS_VIRTUAL( x )   ( ( VTMR_NUM_TIMERS &gt; 0 ) &amp;&amp; ( ( x ) &gt;= VTMR_FIRST_ID ) &amp;&amp; ( ( x ) &lt; VTMR_NUM_TIMERS + VTMR_FIRST_ID ) )
+
+// Functions exported by the common platform layer
+void cmn_platform_init();
+void cmn_virtual_timer_cb();
+
+#endif // #ifndef __COMMON_H__

Modified: trunk/inc/platform.h
===================================================================
--- trunk/inc/platform.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/inc/platform.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -117,6 +117,7 @@
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits );
 void platform_uart_send( unsigned id, u8 data );
 int platform_uart_recv( unsigned id, unsigned timer_id, int timeout );
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout );
 
 // *****************************************************************************
 // Timer subsection
@@ -141,10 +142,11 @@
 // The platform timer functions
 int platform_timer_exists( unsigned id );
 void platform_timer_delay( unsigned id, u32 delay_us );
+void platform_s_timer_delay( unsigned id, u32 delay_us );
 u32 platform_timer_op( unsigned id, int op, u32 data );
+u32 platform_s_timer_op( unsigned id, int op, u32 data );
 u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start );
 
-
 // *****************************************************************************
 // OLED DISP subsection
 

Modified: trunk/inc/xmodem.h
===================================================================
--- trunk/inc/xmodem.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/inc/xmodem.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -42,13 +42,12 @@
 #define XMODEM_INCREMENT_AMMOUNT      512
 #define XMODEM_BUFFER_SIZE            128
 
-// xmodem control characters
 #define SOH       0x01
 #define STX       0x02
 #define EOT       0x04
 #define ACK       0x06
 #define NAK       0x15
-#define CAN       0x18
+#define XMODEM_CAN  0x18
 #define CTRLZ     0x1A
 
 // xmodem timeout/retry parameters

Added: trunk/src/common.c
===================================================================
--- trunk/src/common.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/common.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -0,0 +1,250 @@
+// Common platform functions
+
+#include &quot;platform.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;type.h&quot;
+#include &quot;genstd.h&quot;
+#include &quot;common.h&quot;
+#include &lt;stdio.h&gt;
+
+// *****************************************************************************
+// std functions and platform initialization
+
+static void uart_send( int fd, char c )
+{
+  fd = fd;
+  platform_uart_send( CON_UART_ID, c );
+}
+
+static int uart_recv()
+{
+  return platform_uart_recv( CON_UART_ID, 0, PLATFORM_UART_INFINITE_TIMEOUT );
+}
+
+void cmn_platform_init()
+{
+  // Set the send/recv functions                          
+  std_set_send_func( uart_send );
+  std_set_get_func( uart_recv );  
+}
+
+// ****************************************************************************
+// PIO functions
+
+int platform_pio_has_port( unsigned port )
+{
+  return port &lt; NUM_PIO;
+}
+
+const char* platform_pio_get_prefix( unsigned port )
+{
+  static char c[ 3 ];
+  
+  sprintf( c, &quot;P%c&quot;, ( char )( port + PIO_PREFIX ) );
+  return c;
+}
+
+int platform_pio_has_pin( unsigned port, unsigned pin )
+{
+#if defined( PIO_PINS_PER_PORT )
+  return port &lt; NUM_PIO &amp;&amp; pin &lt; PIO_PINS_PER_PORT;
+#elif defined( PIO_PIN_ARRAY )
+  const u8 pio_port_pins[] = PIO_PIN_ARRAY;
+  return port &lt; NUM_PIO &amp;&amp; pin &lt; pio_port_pins[ port ];
+#else
+  #error &quot;You must define either PIO_PINS_PER_PORT of PIO_PIN_ARRAY in platform_conf.h&quot;
+#endif
+}
+ 
+// ****************************************************************************
+// UART functions
+
+// The platform UART functions
+int platform_uart_exists( unsigned id )
+{
+  return id &lt; NUM_UART;
+}
+
+int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+{
+  timer_data_type tmr_start, tmr_crt;
+  int res;
+  
+  if( timeout == 0 )
+    return platform_s_uart_recv( id, timer_id, timeout );
+  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
+    return platform_s_uart_recv( id, timer_id, timeout );
+  else
+  {
+    // Receive char with the specified timeout
+    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START, 0 );
+    while( 1 )
+    {
+      if( ( res = platform_s_uart_recv( id, timer_id, 0 ) ) &gt;= 0 )
+        break;
+      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
+      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
+        break;
+    }
+    return res;
+  }
+}
+
+// ****************************************************************************
+// Timers (and vtimers) functions
+
+#if VTMR_NUM_TIMERS &gt; 0
+static volatile u32 vtmr_counters[ VTMR_NUM_TIMERS ];
+static volatile s8 vtmr_reset_idx = -1;
+
+// This should be called from the platform's timer interrupt at VTMR_FREQ_HZ
+void cmn_virtual_timer_cb()
+{
+  unsigned i;
+
+  for( i = 0; i &lt; VTMR_NUM_TIMERS; i ++ )
+    vtmr_counters[ i ] ++;  
+  if( vtmr_reset_idx != -1 )
+  {
+    vtmr_counters[ vtmr_reset_idx ] = 0;
+    vtmr_reset_idx = -1;
+  }
+}
+
+static void vtmr_reset_timer( unsigned vid )
+{
+  unsigned id = VTMR_GET_ID( vid );
+
+  vtmr_reset_idx = ( s8 )id;
+  while( vtmr_reset_idx != -1 );  
+}
+
+static void vtmr_delay( unsigned vid, u32 delay_us )
+{
+  timer_data_type final;
+  unsigned id = VTMR_GET_ID( vid );
+  
+  final = ( ( u64 )delay_us * VTMR_FREQ_HZ ) / 1000000;
+  vtmr_reset_timer( vid );
+  while( vtmr_counters[ id ] &lt; final );  
+}
+
+#else // #if VTMR_NUM_TIMERS &gt; 0
+
+void cmn_virtual_timer_cb()
+{
+}
+#endif // #if VTMR_NUM_TIMERS &gt; 0
+
+int platform_timer_exists( unsigned id )
+{
+#if VTMR_NUM_TIMERS &gt; 0
+  if( TIMER_IS_VIRTUAL( id ) )
+    return TIMER_IS_VIRTUAL( id );
+  else
+#endif
+    return id &lt; NUM_TIMER;
+}
+
+void platform_timer_delay( unsigned id, u32 delay_us )
+{
+#if VTMR_NUM_TIMERS &gt; 0
+  if( TIMER_IS_VIRTUAL( id ) )
+    vtmr_delay( id, delay_us );
+  else
+#endif
+    platform_s_timer_delay( id, delay_us );
+}
+      
+u32 platform_timer_op( unsigned id, int op, u32 data )
+{
+  u32 res = 0;
+
+  if( ( VTMR_NUM_TIMERS == 0 ) || ( !TIMER_IS_VIRTUAL( id ) ) )
+    return platform_s_timer_op( id, op, data );
+#if VTMR_NUM_TIMERS &gt; 0
+  switch( op )
+  {
+    case PLATFORM_TIMER_OP_START:
+      vtmr_reset_timer( id );
+      res = 0;
+      break;
+      
+    case PLATFORM_TIMER_OP_READ:
+      res = vtmr_counters[ VTMR_GET_ID( id ) ];
+      break;
+      
+    case PLATFORM_TIMER_OP_GET_MAX_DELAY:
+      res = platform_timer_get_diff_us( id, 0, 0xFFFFFFFF );
+      break;
+      
+    case PLATFORM_TIMER_OP_GET_MIN_DELAY:
+      res = platform_timer_get_diff_us( id, 0, 1 );
+      break;
+      
+    case PLATFORM_TIMER_OP_SET_CLOCK:
+    case PLATFORM_TIMER_OP_GET_CLOCK:
+      res = VTMR_FREQ_HZ;
+      break;      
+  }
+#endif
+  return res;
+}
+
+u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
+{
+  timer_data_type temp;
+  u32 freq;
+    
+  freq = platform_timer_op( id, PLATFORM_TIMER_OP_GET_CLOCK, 0 );
+  if( start &lt; end )
+  {
+    temp = end;
+    end = start;
+    start = temp;
+  }
+  return ( ( u64 )( start - end ) * 1000000 ) / freq;
+}
+
+// ****************************************************************************
+// SPI functions
+
+int platform_spi_exists( unsigned id )
+{
+  return id &lt; NUM_SPI;
+}
+
+// ****************************************************************************
+// PWM functions
+
+int platform_pwm_exists( unsigned id )
+{
+  return id &lt; NUM_PWM;
+}
+
+// ****************************************************************************
+// CPU functions
+
+u32 platform_cpu_get_frequency()
+{
+  return CPU_FREQUENCY;
+}
+
+// ****************************************************************************
+// Allocator support
+
+extern char end[];
+
+void* platform_get_first_free_ram( unsigned id )
+{
+  void* mstart[] = MEM_START_ADDRESS;
+  
+  return id &gt;= sizeof( mstart ) / sizeof( void* ) ? NULL : mstart[ id ];
+}
+
+void* platform_get_last_free_ram( unsigned id )
+{
+  void* mend[] = MEM_END_ADDRESS;
+  
+  return id &gt;= sizeof( mend ) / sizeof( void* ) ? NULL : mend[ id ];
+}

Modified: trunk/src/main.c
===================================================================
--- trunk/src/main.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/main.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -24,12 +24,12 @@
 
 static void xmodem_send( u8 data )
 {
-  platform_uart_send( XMODEM_UART_ID, data );
+  platform_uart_send( CON_UART_ID, data );
 }
 
 static int xmodem_recv( u32 timeout )
 {
-  return platform_uart_recv( XMODEM_UART_ID, XMODEM_TIMER_ID, timeout );
+  return platform_uart_recv( CON_UART_ID, XMODEM_TIMER_ID, timeout );
 }
 
 #endif // #ifdef BUILD_XMODEM
@@ -41,15 +41,15 @@
 
 static void term_out( u8 data )
 {
-  platform_uart_send( TERM_UART_ID, data );
+  platform_uart_send( CON_UART_ID, data );
 }
 
 static int term_in( int mode )
 {
   if( mode == TERM_INPUT_DONT_WAIT )
-    return platform_uart_recv( TERM_UART_ID, TERM_TIMER_ID, 0 );
+    return platform_uart_recv( CON_UART_ID, TERM_TIMER_ID, 0 );
   else
-    return platform_uart_recv( TERM_UART_ID, TERM_TIMER_ID, PLATFORM_UART_INFINITE_TIMEOUT );
+    return platform_uart_recv( CON_UART_ID, TERM_TIMER_ID, PLATFORM_UART_INFINITE_TIMEOUT );
 }
 
 static int term_translate( u8 data )
@@ -62,9 +62,9 @@
   {
     // If we don't get a second char, we got a simple &quot;ESC&quot;, so return KC_ESC
     // If we get a second char it must be '[', the next one is relevant for us
-    if( platform_uart_recv( TERM_UART_ID, TERM_TIMER_ID, TERM_TIMEOUT ) == -1 )
+    if( platform_uart_recv( CON_UART_ID, TERM_TIMER_ID, TERM_TIMEOUT ) == -1 )
       return KC_ESC;
-    if( ( c = platform_uart_recv( TERM_UART_ID, TERM_TIMER_ID, TERM_TIMEOUT ) ) == -1 )
+    if( ( c = platform_uart_recv( CON_UART_ID, TERM_TIMER_ID, TERM_TIMEOUT ) ) == -1 )
       return KC_UNKNOWN;
     switch( c )
     {
@@ -81,7 +81,7 @@
   else if( data == 0x0D )
   {
     // CR/LF sequence, read the second char (LF) if applicable
-    platform_uart_recv( TERM_UART_ID, TERM_TIMER_ID, TERM_TIMEOUT );
+    platform_uart_recv( CON_UART_ID, TERM_TIMER_ID, TERM_TIMEOUT );
     return KC_ENTER;
   }
   else

Modified: trunk/src/modules/tmr.c
===================================================================
--- trunk/src/modules/tmr.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/modules/tmr.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -5,6 +5,8 @@
 #include &quot;lauxlib.h&quot;
 #include &quot;platform.h&quot;
 #include &quot;auxmods.h&quot;
+#include &quot;platform_conf.h&quot;
+#include &quot;common.h&quot;
 
 // Helper function for the read/start functions
 static int tmrh_timer_op( lua_State* L, int op )
@@ -129,5 +131,9 @@
 LUALIB_API int luaopen_tmr( lua_State *L )
 {
   luaL_register( L, AUXLIB_TMR, tmr_map );
+#if VTMR_NUM_TIMERS &gt; 0
+  lua_pushnumber( L, VTMR_FIRST_ID );
+  lua_setfield( L, -2, &quot;VIRT0&quot; );  
+#endif
   return 1;
 }

Modified: trunk/src/newlib/stubs.c
===================================================================
--- trunk/src/newlib/stubs.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/newlib/stubs.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -307,7 +307,7 @@
 }
 
 #include &lt;sys/time.h&gt;
-#ifdef AVR32
+#ifdef FORAVR32
 int _gettimeofday_r( struct _reent *r, struct timeval *tp, struct timezone *tzp )
 #else
 int _gettimeofday_r( struct _reent *r, struct timeval *tv, void *tz )
@@ -394,7 +394,7 @@
 
 #endif // #if !defined( BUILD_CON_GENERIC ) &amp;&amp; !defined( BUILD_CON_TCP )
 
-#ifdef AVR32
+#ifdef FORAVR32
 void* memcpy( void *dst, const void* src, size_t len )
 {
   char *pdest = ( char* )dst;
@@ -407,4 +407,5 @@
   }
   return dst;
 }
-#endif // #if ELUA_PLATFORM == AVR32
+#endif // #ifdef FORAVR32
+

Added: trunk/src/platform/at91sam7x/aic.c
===================================================================
--- trunk/src/platform/at91sam7x/aic.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/aic.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -0,0 +1,80 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support 
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ----------------------------------------------------------------------------
+ */
+
+//------------------------------------------------------------------------------
+//         Headers
+//------------------------------------------------------------------------------
+
+#include &quot;aic.h&quot;
+#include &lt;board.h&gt;
+
+//------------------------------------------------------------------------------
+//         Exported functions
+//------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------
+/// Configures the interrupt associated with the given source, using the
+/// specified mode and interrupt handler.
+/// \param source  Interrupt source to configure.
+/// \param mode  Triggering mode of the interrupt.
+/// \param handler  Interrupt handler function.
+//------------------------------------------------------------------------------
+void AIC_ConfigureIT(unsigned int source,
+                            unsigned int mode,
+                            void (*handler)( void ))
+{
+    // Disable the interrupt first
+    AT91C_BASE_AIC-&gt;AIC_IDCR = 1 &lt;&lt; source;
+
+    // Configure mode and handler
+    AT91C_BASE_AIC-&gt;AIC_SMR[source] = mode;
+    AT91C_BASE_AIC-&gt;AIC_SVR[source] = (unsigned int) handler;
+
+    // Clear interrupt
+    AT91C_BASE_AIC-&gt;AIC_ICCR = 1 &lt;&lt; source;
+}
+
+//------------------------------------------------------------------------------
+/// Enables interrupts coming from the given (unique) source.
+/// \param source  Interrupt source to enable.
+//------------------------------------------------------------------------------
+void AIC_EnableIT(unsigned int source)
+{
+    AT91C_BASE_AIC-&gt;AIC_IECR = 1 &lt;&lt; source;
+}
+
+//------------------------------------------------------------------------------
+/// Disables interrupts coming from the given (unique) source.
+/// \param source  Interrupt source to enable.
+//------------------------------------------------------------------------------
+void AIC_DisableIT(unsigned int source)
+{
+    AT91C_BASE_AIC-&gt;AIC_IDCR = 1 &lt;&lt; source;
+}
+

Added: trunk/src/platform/at91sam7x/aic.h
===================================================================
--- trunk/src/platform/at91sam7x/aic.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/aic.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support 
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2008, Atmel Corporation
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ----------------------------------------------------------------------------
+ */
+
+//------------------------------------------------------------------------------
+/// \dir
+/// !Purpose
+/// 
+/// Methods and definitions for configuring interrupts using the Advanced
+/// Interrupt Controller (AIC).
+/// 
+/// !Usage
+/// -# Configure an interrupt source using AIC_ConfigureIT
+/// -# Enable or disable interrupt generation of a particular source with
+///    AIC_EnableIT and AIC_DisableIT.
+//------------------------------------------------------------------------------
+
+#ifndef AIC_H
+#define AIC_H
+
+//------------------------------------------------------------------------------
+//         Headers
+//------------------------------------------------------------------------------
+
+#include &lt;board.h&gt;
+
+//------------------------------------------------------------------------------
+//         Definitions
+//------------------------------------------------------------------------------
+
+#ifndef AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL
+    /// Redefinition of missing constant.
+    #define AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE
+#endif
+
+//------------------------------------------------------------------------------
+//         Global functions
+//------------------------------------------------------------------------------
+
+extern void AIC_ConfigureIT(unsigned int source,
+                                   unsigned int mode,
+                                   void (*handler)( void ));
+
+extern void AIC_EnableIT(unsigned int source);
+
+extern void AIC_DisableIT(unsigned int source);
+
+#endif //#ifndef AIC_H
+

Modified: trunk/src/platform/at91sam7x/board_cstartup.s
===================================================================
--- trunk/src/platform/at91sam7x/board_cstartup.s	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/board_cstartup.s	2009-01-07 20:17:18 UTC (rev 143)
@@ -133,7 +133,7 @@
 1:
         ldr     r4, =_sstack
         mov     sp, r4
-	    ldr     r0, =LowLevelInit
+        ldr     r0, =LowLevelInit
         mov     lr, pc
         bx      r0
 

Modified: trunk/src/platform/at91sam7x/board_lowlevel.c
===================================================================
--- trunk/src/platform/at91sam7x/board_lowlevel.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/board_lowlevel.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -69,7 +69,6 @@
  */
 void defaultSpuriousHandler( void )
 {
-    while (1);
 }
 
 /*!

Modified: trunk/src/platform/at91sam7x/conf.py
===================================================================
--- trunk/src/platform/at91sam7x/conf.py	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/conf.py	2009-01-07 20:17:18 UTC (rev 143)
@@ -2,7 +2,7 @@
 
 cpumode = ARGUMENTS.get( 'cpumode', 'thumb' ).lower()
 
-specific_files = &quot;board_cstartup.s board_lowlevel.c board_memories.c usart.c pmc.c pio.c platform.c tc.c pwmc.c&quot;
+specific_files = &quot;board_cstartup.s board_lowlevel.c board_memories.c usart.c pmc.c pio.c platform.c tc.c pwmc.c aic.c&quot;
 if cputype == 'AT91SAM7X256':
   ldscript = &quot;flash256.lds&quot;
   cdefs = cdefs + &quot; -Dat91sam7x256&quot;

Modified: trunk/src/platform/at91sam7x/platform.c
===================================================================
--- trunk/src/platform/at91sam7x/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -17,21 +17,10 @@
 #include &lt;ctype.h&gt;
 #include &lt;stdio.h&gt;
 #include &quot;utils.h&quot;
+#include &quot;common.h&quot;
+#include &quot;aic.h&quot;
+#include &quot;platform_conf.h&quot;
 
-// *****************************************************************************
-// std functions
-
-static void uart_send( int fd, char c )
-{
-  fd = fd;
-  USART_Write( AT91C_BASE_US0, c, 0 );  
-}
-
-static int uart_recv()
-{
-  return USART_Read( AT91C_BASE_US0, 0 );
-}
-
 // ****************************************************************************
 // Platform initialization
 
@@ -42,6 +31,16 @@
 };
 static const AT91S_TC* timer_base[] = { AT91C_BASE_TC0, AT91C_BASE_TC1, AT91C_BASE_TC2 };
 
+#if VTMR_NUM_TIMERS &gt; 0
+static void ISR_Tc2()
+{
+  cmn_virtual_timer_cb();
+  AT91C_BASE_TC2-&gt;TC_SR;
+  asm( &quot;pop {r0}&quot;:: );  
+  asm( &quot;bx  r0&quot;:: );
+}
+#endif
+
 int platform_init()
 {
   int i;
@@ -63,14 +62,14 @@
   PIO_Configure(platform_uart_pins[ 0 ], PIO_LISTSIZE(platform_uart_pins[ 0 ]));
     
   // Configure the USART in the desired mode @115200 bauds
-  USART_Configure(AT91C_BASE_US0, mode, 115200, BOARD_MCK);
+  USART_Configure(AT91C_BASE_US0, mode, CON_UART_SPEED, BOARD_MCK);
   
   // Enable receiver &amp; transmitter
   USART_SetTransmitterEnabled(AT91C_BASE_US0, 1);
   USART_SetReceiverEnabled(AT91C_BASE_US0, 1);  
   
   // Configure the timers
-  AT91C_BASE_TCB-&gt;TCB_BMR = 7;
+  AT91C_BASE_TCB-&gt;TCB_BMR = 0x15;
   for( i = 0; i &lt; 3; i ++ )
     TC_Configure( ( AT91S_TC* )timer_base[ i ], AT91C_TC_CLKS_TIMER_DIV5_CLOCK | AT91C_TC_WAVE );
         
@@ -85,10 +84,19 @@
     PWMC_EnableChannel( i );
     PWMC_EnableChannelIt( i );
   }
+
+  cmn_platform_init();
   
-  // Set the send/recv functions                          
-  std_set_send_func( uart_send );
-  std_set_get_func( uart_recv );
+#if VTMR_NUM_TIMERS &gt; 0
+  // Virtual timer initialization
+  TC_Configure( AT91C_BASE_TC2, AT91C_TC_CLKS_TIMER_DIV5_CLOCK | AT91C_TC_WAVE | AT91C_TC_WAVESEL_UP_AUTO );
+  AT91C_BASE_TC2-&gt;TC_RC = ( BOARD_MCK / 1024 ) / VTMR_FREQ_HZ;
+  AIC_DisableIT( AT91C_ID_TC2 );
+  AIC_ConfigureIT( AT91C_ID_TC2, 0, ISR_Tc2 );
+  AT91C_BASE_TC2-&gt;TC_IER = AT91C_TC_CPCS;
+  AIC_EnableIT( AT91C_ID_TC2 );  
+  TC_Start( AT91C_BASE_TC2 );
+#endif
     
   return PLATFORM_OK;
 } 
@@ -102,24 +110,6 @@
   { 0, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT }
 };
 
-int platform_pio_has_port( unsigned port )
-{
-  return port &lt;= 1;
-}
-
-const char* platform_pio_get_prefix( unsigned port )
-{
-  static char c[ 3 ];
-  
-  sprintf( c, &quot;P%c&quot;, ( char )( port + 'A' ) );
-  return c;
-}
-
-int platform_pio_has_pin( unsigned port, unsigned pin )
-{
-  return port &lt;= 1 &amp;&amp; pin &lt;= 30;
-}
-
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
   Pin* pin;
@@ -178,12 +168,6 @@
 // ****************************************************************************
 // UART functions
 
-// The platform UART functions
-int platform_uart_exists( unsigned id )
-{
-  return id &lt;= 1;
-}
-
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   unsigned int mode;
@@ -240,11 +224,9 @@
   USART_Write( base, data, 0 );
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
   AT91S_USART* base = id == 0 ? AT91C_BASE_US0 : AT91C_BASE_US1;  
-  timer_data_type tmr_start, tmr_crt;
-  int res;
     
   if( timeout == 0 )
   {
@@ -254,30 +236,7 @@
     else
       return -1;
   }
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-  {
-    // Wait for data
-    return USART_Read( base, 0 );
-  }
-  else
-  {
-    // Receive char with the specified timeout
-    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START,0 );
-    while( 1 )
-    {
-      if( USART_IsDataAvailable( base ) )
-      {
-        res = USART_Read( base, 0 );
-        break;
-      }
-      else
-        res = -1;
-      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
-      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
-        break;
-    }
-    return res;    
-  }
+  return USART_Read( base, 0 );
 }
 
 // ****************************************************************************
@@ -308,13 +267,8 @@
   return BOARD_MCK / clkdivs[ mini ];
 }
 
-int platform_timer_exists( unsigned id )
+void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
-  return id &lt; 3;
-}
-
-void platform_timer_delay( unsigned id, u32 delay_us )
-{
   AT91S_TC* base = ( AT91S_TC* )timer_base[ id ];  
   u32 freq;
   timer_data_type final;
@@ -329,7 +283,7 @@
   while( base-&gt;TC_CV &lt; final );  
 }
 
-u32 platform_timer_op( unsigned id, int op, u32 data )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   AT91S_TC* base = ( AT91S_TC* )timer_base[ id ];
@@ -366,29 +320,12 @@
   return res;
 }
 
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
-{
-  timer_data_type temp;
-  u32 freq;
-    
-  freq = platform_timer_get_clock( id );
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / freq;
-}
-
 // ****************************************************************************
 // PWMs
 
 // PWM0, PWM1 -&gt; they can modify CLKA and are statically assigned to CLKA
 // PWM2, PWM3 -&gt; they can modify CLKB and are statically assigned to CLKB
 
-#define PLATFORM_NUM_PWMS               4
-
 // PWM pins
 static const Pin pwm_pins[] = { PIN_PWMC_PWM0, PIN_PWMC_PWM1, PIN_PWMC_PWM2, PIN_PWMC_PWM3 };
 
@@ -422,11 +359,6 @@
   return platform_pwm_get_clock( id );
 }
 
-int platform_pwm_exists( unsigned id )
-{
-  return id &lt; PLATFORM_NUM_PWMS; 
-}
-
 u32 platform_pwm_setup( unsigned id, u32 frequency, unsigned duty )
 {
   u32 pwmclk = platform_pwm_get_clock( id );
@@ -471,32 +403,3 @@
   
   return res;
 }
-
-// ****************************************************************************
-// CPU functions
-
-u32 platform_cpu_get_frequency()
-{
-  return BOARD_MCK;
-}
-
-// ****************************************************************************
-// Allocator support
-extern char end[];
-
-void* platform_get_first_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )end;
-}
-
-#define SRAM_ORIGIN 0x200000
-#ifdef at91sam7x256
-  #define SRAM_SIZE 0x10000
-#else
-  #define SRAM_SIZE 0x20000
-#endif
-
-void* platform_get_last_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 );
-}

Modified: trunk/src/platform/at91sam7x/platform_conf.h
===================================================================
--- trunk/src/platform/at91sam7x/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,8 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;board.h&quot;
+#include &quot;stacks.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -17,9 +19,9 @@
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define XMODEM_UART_ID        0
+#define CON_UART_ID           0
+#define CON_UART_SPEED        115200
 #define XMODEM_TIMER_ID       0
-#define TERM_UART_ID          0
 #define TERM_TIMER_ID         0
 #define TERM_LINES            25
 #define TERM_COLS             80
@@ -39,4 +41,44 @@
   { AUXLIB_BIT, luaopen_bit },\
   { LUA_MATHLIBNAME, luaopen_math }
   
+// *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       4
+#define VTMR_FREQ_HZ          4
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               2
+#define NUM_SPI               0
+#define NUM_UART              2
+#if VTMR_NUM_TIMERS &gt; 0
+#define NUM_TIMER             3
+#else
+#define NUM_TIMER             2
+#endif
+#define NUM_PWM               4
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+#define CPU_FREQUENCY         BOARD_MCK
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            'A'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PINS_PER_PORT     31
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define SRAM_ORIGIN           0x200000
+#ifdef at91sam7x256
+  #define SRAM_SIZE           0x10000
+#else
+  #define SRAM_SIZE           0x20000
+#endif
+#define MEM_START_ADDRESS     { ( void* )end }
+#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }  
+  
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/at91sam7x/stacks.h
===================================================================
--- trunk/src/platform/at91sam7x/stacks.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/at91sam7x/stacks.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,7 +4,7 @@
 #define __STACKS_H__
 
 #define  STACK_SIZE_USR   256
-#define  STACK_SIZE_IRQ   32
+#define  STACK_SIZE_IRQ   64
 #define  STACK_SIZE_TOTAL ( STACK_SIZE_USR + STACK_SIZE_IRQ )
 
 #endif

Modified: trunk/src/platform/avr32/conf.py
===================================================================
--- trunk/src/platform/avr32/conf.py	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/avr32/conf.py	2009-01-07 20:17:18 UTC (rev 143)
@@ -2,7 +2,7 @@
 
 specific_files = &quot;crt0.s trampoline.s platform.c exception.s intc.c pm.c flashc.c pm_conf_clocks.c usart.c gpio.c tc.c&quot;
 ldscript = &quot;at32uc3a0512.ld&quot;
-cdefs = cdefs + &quot; -DAVR32&quot;
+cdefs = cdefs + &quot; -DFORAVR32&quot;
 
 # Prepend with path
 specific_files = &quot; &quot;.join( [ &quot;src/platform/%s/%s&quot; % ( platform, f ) for f in specific_files.split() ] )

Modified: trunk/src/platform/avr32/platform.c
===================================================================
--- trunk/src/platform/avr32/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/avr32/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -12,6 +12,7 @@
 #include &lt;stdio.h&gt;
 #include &quot;utils.h&quot;
 #include &quot;platform_conf.h&quot;
+#include &quot;common.h&quot;
 
 // Platform-specific includes
 #include &lt;avr32/io.h&gt;
@@ -22,26 +23,26 @@
 #include &quot;usart.h&quot;
 #include &quot;gpio.h&quot;
 #include &quot;tc.h&quot;
+#include &quot;intc.h&quot;
 
-// *****************************************************************************
-// std functions
-
-static void uart_send( int fd, char c )
-{
-  fd = fd;
-  platform_uart_send( CON_UART_ID, c );
-}
-
-static int uart_recv()
-{
-  return platform_uart_recv( CON_UART_ID, 0, PLATFORM_UART_INFINITE_TIMEOUT );
-}
-
 // ****************************************************************************
 // Platform initialization
 
 extern int pm_configure_clocks( pm_freq_param_t *param );
 
+#if VTMR_NUM_TIMERS &gt; 0
+
+#define VTMR_CH     (2)
+
+__attribute__((__interrupt__)) static void tmr_int_handler()
+{
+  volatile avr32_tc_t *tc = &amp;AVR32_TC;
+  
+  tc_read_sr( tc, VTMR_CH );
+  cmn_virtual_timer_cb();
+}                                
+#endif
+
 int platform_init()
 {
   pm_freq_param_t pm_freq_param =
@@ -80,6 +81,7 @@
   unsigned i;
          
   Disable_global_interrupt();  
+  INTC_init_interrupts();
   
   // Setup clocks
   if( PM_FREQ_STATUS_FAIL == pm_configure_clocks( &amp;pm_freq_param ) )
@@ -99,10 +101,31 @@
     tc_init_waveform( tc, &amp;tmropt );
   }
   
-  // Set the send/recv functions                          
-  std_set_send_func( uart_send );
-  std_set_get_func( uart_recv );  
+  // Setup timer interrupt for the virtual timers if needed
+#if VTMR_NUM_TIMERS &gt; 0
+  INTC_register_interrupt( &amp;tmr_int_handler, AVR32_TC_IRQ2, AVR32_INTC_INT0 );  
+  tmropt.channel = VTMR_CH;
+  tmropt.wavsel = TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER;
+  tc_init_waveform( tc, &amp;tmropt );
+  tc_interrupt_t tmrint = 
+  {
+    0,              // External trigger interrupt.
+    0,              // RB load interrupt.
+    0,              // RA load interrupt.
+    1,              // RC compare interrupt.
+    0,              // RB compare interrupt.
+    0,              // RA compare interrupt.
+    0,              // Load overrun interrupt.
+    0               // Counter overflow interrupt.
+  };
+  tc_write_rc( tc, VTMR_CH, 32768 / VTMR_FREQ_HZ );
+  tc_configure_interrupts( tc, VTMR_CH, &amp;tmrint );
+  Enable_global_interrupt();
+  tc_start( tc, VTMR_CH );  
+#endif
   
+  cmn_platform_init();
+    
   // All done  
   return PLATFORM_OK;
 } 
@@ -132,7 +155,6 @@
 */
 
 // Port data
-#define NUM_PORTS     5
 #define PA            0
 #define PB            1
 #define PC            2
@@ -147,26 +169,6 @@
 
 #define GPIO          AVR32_GPIO
 
-static const u8 pio_port_pins[ NUM_PORTS ] = { 31, 32, 6, 32, 8 };
-
-int platform_pio_has_port( unsigned port )
-{
-  return port &lt; NUM_PORTS;
-}
-
-const char* platform_pio_get_prefix( unsigned port )
-{
-  static char c[ 3 ];
-  
-  sprintf( c, &quot;P%c&quot;, ( char )( port + 'A' ) );
-  return c;
-}
-
-int platform_pio_has_pin( unsigned port, unsigned pin )
-{
-  return port &lt; NUM_PORTS &amp;&amp; pin &lt; pio_port_pins[ port ];
-}
-
 // Helper function: for a given port, return the address of a specific register (value, direction, pullup ...)
 static volatile unsigned long* platform_pio_get_port_reg_addr( unsigned port, int regtype )
 {
@@ -311,9 +313,7 @@
 // ****************************************************************************
 // UART functions
 
-#define NUM_UARTS     4
-
-static const u32 uart_base_addr[ NUM_UARTS ] = { AVR32_USART0_ADDRESS, AVR32_USART1_ADDRESS, AVR32_USART2_ADDRESS, AVR32_USART3_ADDRESS };
+static const u32 uart_base_addr[ NUM_UART ] = { AVR32_USART0_ADDRESS, AVR32_USART1_ADDRESS, AVR32_USART2_ADDRESS, AVR32_USART3_ADDRESS };
 static const gpio_map_t uart_pins = 
 {
   // UART 0
@@ -330,12 +330,6 @@
   { AVR32_USART3_TXD_0_0_PIN, AVR32_USART3_TXD_0_0_FUNCTION }
 };
 
-// The platform UART functions
-int platform_uart_exists( unsigned id )
-{
-  return id &lt; NUM_UARTS;
-}
-
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
@@ -376,7 +370,7 @@
   usart_putchar( pusart, data );
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
   volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
   int temp;
@@ -388,20 +382,13 @@
     else
       return temp;
   }
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-  {
-    return usart_getchar( pusart );
-  }
   else
-  {
-    return -1;
-  }  
+    return usart_getchar( pusart );
 }
 
 // ****************************************************************************
 // Timer functions
 
-#define NUM_TIMERS 3
 static const u16 clkdivs[] = { 0xFFFF, 2, 8, 32, 128 };
 
 // Helper: get timer clock
@@ -427,13 +414,8 @@
   return mini == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ mini ];
 }
 
-int platform_timer_exists( unsigned id )
+void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
-  return id &lt; NUM_TIMERS;
-}
-
-void platform_timer_delay( unsigned id, u32 delay_us )
-{
   volatile avr32_tc_t *tc = &amp;AVR32_TC;  
   u32 freq;
   timer_data_type final;
@@ -450,7 +432,7 @@
   while( ( tc_read_tc( tc, id ) &lt; final ) &amp;&amp; !sr-&gt;covfs );  
 }
 
-u32 platform_timer_op( unsigned id, int op, u32 data )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   volatile int i;
@@ -487,42 +469,16 @@
   return res;
 }
 
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
-{
-  timer_data_type temp;
-  u32 freq;
-    
-  freq = platform_timer_get_clock( id );
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / freq;
-}
-
 // ****************************************************************************
 // CPU functions
 
-u32 platform_cpu_get_frequency()
+void platform_cpu_enable_interrupts()
 {
-  return REQ_CPU_FREQ;
+  Enable_global_interrupt();
 }
 
-// ****************************************************************************
-// Allocator support
-extern char end[];
-
-void* platform_get_first_free_ram( unsigned id )
+void platform_cpu_disable_interrupts()
 {
-  return id &gt; 0 ? NULL : ( void* )end;
+  Disable_global_interrupt();
 }
 
-#define SRAM_ORIGIN 0x0
-#define SRAM_SIZE 0x10000
-
-void* platform_get_last_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 );
-}

Modified: trunk/src/platform/avr32/platform_conf.h
===================================================================
--- trunk/src/platform/avr32/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/avr32/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,8 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;board.h&quot;
+#include &quot;stacks.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -12,24 +14,18 @@
 #define BUILD_SHELL
 #define BUILD_ROMFS
 #define BUILD_TERM
-//#define BUILD_UIP
-//#define BUILD_DNS
 #define BUILD_CON_GENERIC
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-// [TODO] added CON_UART_xxxx below, add it to all backends, and probably remove
-// XMODEM_UART_ID (although this isn't strictly required)
-#define CON_UART_ID           0
-#define CON_UART_SPEED        38400
-#define XMODEM_UART_ID        0
-#define XMODEM_TIMER_ID       0
-#define TERM_UART_ID          0
-#define TERM_TIMER_ID         0
-#define TERM_LINES            25
-#define TERM_COLS             80
-#define TERM_TIMEOUT          100000
+#define CON_UART_ID         0
+#define CON_UART_SPEED      38400
+#define XMODEM_TIMER_ID     0
+#define TERM_TIMER_ID       0
+#define TERM_LINES          25
+#define TERM_COLS           80
+#define TERM_TIMEOUT        100000
 
 // *****************************************************************************
 // Auxiliary libraries that will be compiled for this platform
@@ -42,32 +38,43 @@
   { AUXLIB_TERM, luaopen_term },\
   { AUXLIB_PACK, luaopen_pack },\
   { AUXLIB_BIT, luaopen_bit },\
+  { AUXLIB_CPU, luaopen_cpu },\
   { LUA_MATHLIBNAME, luaopen_math }
 
 // *****************************************************************************
 // Configuration data
 
-// Static TCP/IP configuration
-#define ELUA_CONF_IPADDR0         192
-#define ELUA_CONF_IPADDR1         168
-#define ELUA_CONF_IPADDR2         1
-#define ELUA_CONF_IPADDR3         218
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       4
+#define VTMR_FREQ_HZ          4
 
-#define ELUA_CONF_NETMASK0        255
-#define ELUA_CONF_NETMASK1        255
-#define ELUA_CONF_NETMASK2        255
-#define ELUA_CONF_NETMASK3        0
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               5
+#define NUM_SPI               0
+#define NUM_UART              4
+#if VTMR_NUM_TIMERS &gt; 0
+#define NUM_TIMER             2
+#else
+#define NUM_TIMER             3
+#endif      
+#define NUM_PWM               0
 
-#define ELUA_CONF_DEFGW0          192
-#define ELUA_CONF_DEFGW1          168
-#define ELUA_CONF_DEFGW2          1
-#define ELUA_CONF_DEFGW3          1
+// CPU frequency (needed by the CPU module, 0 if not used)
+#define CPU_FREQUENCY         REQ_CPU_FREQ
 
-#define ELUA_CONF_DNS0            192
-#define ELUA_CONF_DNS1            168
-#define ELUA_CONF_DNS2            1
-#define ELUA_CONF_DNS3            1
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            'A'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PIN_ARRAY         { 31, 32, 6, 32, 8 }
 
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define MEM_START_ADDRESS     { ( void* )end }
+#define MEM_END_ADDRESS       { ( void* )( 0x10000 - STACK_SIZE_TOTAL - 1 ) }
+
 // *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module
 

Modified: trunk/src/platform/i386/conf.py
===================================================================
--- trunk/src/platform/i386/conf.py	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/i386/conf.py	2009-01-07 20:17:18 UTC (rev 143)
@@ -17,6 +17,6 @@
 def progfunc_i386( target, source, env ):
   outname = output + &quot;.elf&quot;
   os.system( &quot;i686-elf-size %s&quot; % outname )
-  print &quot;Visit <A HREF="http://elua.berlios.de">http://elua.berlios.de</A> for instructions on how to use your eLua ELF file&quot;
+  print &quot;Visit <A HREF="http://www.eluaproject.net">http://www.eluaproject.net</A> for instructions on how to use your eLua ELF file&quot;
   
 tools[ 'i386' ][ 'progfunc' ] = progfunc_i386

Modified: trunk/src/platform/i386/platform.c
===================================================================
--- trunk/src/platform/i386/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/i386/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -83,11 +83,6 @@
 // ****************************************************************************
 // &quot;Dummy&quot; UART functions
 
-int platform_uart_exists( unsigned id )
-{
-  return 0;
-}
-
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   return 0;
@@ -97,22 +92,27 @@
 {
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
   return -1;
 }
 
 // ****************************************************************************
-// Allocator support
-extern char end[];
+// &quot;Dummy&quot; timer functions
 
-void* platform_get_first_free_ram( unsigned id )
+void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
-  return id &gt; 0  ? NULL : ( void* )end;
 }
 
-#define MY_STACK_SIZE ( 16 * 1024 ) 
-void* platform_get_last_free_ram( unsigned id )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
-  return id &gt; 0 ? NULL : ( void* )( lastmem - MY_STACK_SIZE - 1 );
+  return 0;
 }
+
+// ****************************************************************************
+// Allocator support
+
+u32 platform_get_lastmem()
+{
+  return lastmem;
+}

Modified: trunk/src/platform/i386/platform_conf.h
===================================================================
--- trunk/src/platform/i386/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/i386/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,7 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;type.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -19,4 +20,36 @@
   { AUXLIB_PD, luaopen_pd },\
   { LUA_MATHLIBNAME, luaopen_math }
   
+#define CON_UART_ID           0
+  
+// *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       0
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               0
+#define NUM_SPI               0
+#define NUM_UART              0
+#define NUM_TIMER             0
+#define NUM_PWM               0
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+#define CPU_FREQUENCY         0
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            'A'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PINS_PER_PORT     0
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+u32 platform_get_lastmem();
+#define MEM_START_ADDRESS     { ( void* )end }
+#define MEM_END_ADDRESS       { ( void* )( platform_get_lastmem() - 16384 - 1 ) }  
+  
 #endif // #ifndef __PLATFORM_CONF_H__

Modified: trunk/src/platform/lm3s/conf.py
===================================================================
--- trunk/src/platform/lm3s/conf.py	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lm3s/conf.py	2009-01-07 20:17:18 UTC (rev 143)
@@ -7,6 +7,11 @@
 specific_files = &quot; &quot;.join( [ &quot;src/platform/%s/%s&quot; % ( platform, f ) for f in specific_files.split() ] )
 ldscript = &quot;src/platform/%s/%s&quot; % ( platform, ldscript )
 
+if cputype == 'LM3S8962':
+  cdefs = cdefs + &quot; -DFORLM3S8962&quot;
+else:
+  cdefs = cdefs + &quot; -DFORLM3S6965&quot;
+
 cdefs = cdefs + &quot; -Dgcc&quot;
 
 # Toolset data

Modified: trunk/src/platform/lm3s/platform.c
===================================================================
--- trunk/src/platform/lm3s/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lm3s/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -13,6 +13,7 @@
 #include &quot;elua_uip.h&quot; 
 #include &quot;uip-conf.h&quot;
 #include &quot;platform_conf.h&quot;
+#include &quot;common.h&quot;
 
 // Platform specific includes
 #include &quot;hw_ints.h&quot;
@@ -38,22 +39,11 @@
 #include &quot;rit128x96x4.h&quot;
 
 // UIP sys tick data
+// NOTE: when using virtual timers, SYSTICKHZ and VTMR_FREQ_HZ should have the
+// same value, as they're served by the same timer (the systick)
 #define SYSTICKHZ               4
 #define SYSTICKMS               (1000 / SYSTICKHZ)
 
-// *****************************************************************************
-// std function
-static void uart_send( int fd, char c )
-{
-  fd = fd;
-  UARTCharPut( UART0_BASE, c );
-}
-
-static int uart_recv()
-{
-  return UARTCharGet( UART0_BASE );
-}
-
 // ****************************************************************************
 // Platform initialization
 
@@ -88,10 +78,19 @@
   // Setup ethernet (TCP/IP)
   eth_init();
 
-  // Set the send/recv functions                          
-  std_set_send_func( uart_send );
-  std_set_get_func( uart_recv );      
+  // Common platform initialization code
+  cmn_platform_init();
   
+  // Virtual timers
+  // If the ethernet controller is used the timer is already initialized, so skip this sequence  
+#if VTMR_NUM_TIMERS &gt; 0 &amp;&amp; !defined( BUILD_UIP )
+  // Configure SysTick for a periodic interrupt.
+  SysTickPeriodSet( SysCtlClockGet() / SYSTICKHZ );
+  SysTickEnable();
+  SysTickIntEnable();  
+  IntMasterEnable();
+#endif
+  
   // All done
   return PLATFORM_OK;
 } 
@@ -104,38 +103,15 @@
                                 GPIO_PORTE_BASE, GPIO_PORTF_BASE, GPIO_PORTG_BASE, GPIO_PORTH_BASE };
 static const u32 pio_sysctl[] = { SYSCTL_PERIPH_GPIOA, SYSCTL_PERIPH_GPIOB, SYSCTL_PERIPH_GPIOC, SYSCTL_PERIPH_GPIOD, 
                                   SYSCTL_PERIPH_GPIOE, SYSCTL_PERIPH_GPIOF, SYSCTL_PERIPH_GPIOG, SYSCTL_PERIPH_GPIOH };
-static const u8 pio_port_pins[] = { 8, 8, 8, 8, 4, 4, 2, 0 };
-#define PIOS_COUNT 42
-#define PIOS_PORT_COUNT 7
 
 static void pios_init()
 {
   unsigned i;
 
-  for( i = 0; i &lt; PIOS_PORT_COUNT; i ++ )
-  {
+  for( i = 0; i &lt; NUM_PIO; i ++ )
     SysCtlPeripheralEnable(pio_sysctl[ i ]);
-  }
 }
 
-int platform_pio_has_port( unsigned port )
-{
-  return port &lt; PIOS_PORT_COUNT;
-}
-
-const char* platform_pio_get_prefix( unsigned port )
-{
-  static char c[ 3 ];
-  
-  sprintf( c, &quot;P%c&quot;, ( char )( port + 'A' ) );
-  return c;
-}
-
-int platform_pio_has_pin( unsigned port, unsigned pin )
-{
-  return pin &lt; pio_port_pins[ port ];
-}
-
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
   pio_type retval = 1, base = pio_base[ port ];
@@ -204,23 +180,15 @@
                                     GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 };
 //                                  SSIxClk      SSIxFss      SSIxRx       SSIxTx
 static const u8 spi_gpio_clk_pin[] = { GPIO_PIN_2, GPIO_PIN_0 };
-#define SPIS_COUNT 		1
 
 static void spis_init()
 {
   unsigned i;
 
-  for( i = 0; i &lt; SPIS_COUNT; i ++ )
-  {
+  for( i = 0; i &lt; NUM_SPI; i ++ )
     SysCtlPeripheralEnable(spi_sysctl[ i ]);
-  }
 }
 
-int platform_spi_exists( unsigned id )
-{
-  return id &lt; SPIS_COUNT;
-}
-
 u32 platform_spi_setup( unsigned id, int mode, u32 clock, unsigned cpol, unsigned cpha, unsigned databits )
 {
   unsigned protocol;
@@ -260,12 +228,6 @@
 // UART
 // Different configurations for LM3S8962 (2 UARTs) and LM3S6965 (3 UARTs)
 
-#if ELUA_CPU == LM3S8962
-  #define UARTS_COUNT 2
-#elif ELUA_CPU == LM3S6965
-  #define UARTS_COUNT 3
-#endif
-
 // All possible LM3S uarts defs
 static const u32 uart_base[] = { UART0_BASE, UART1_BASE, UART2_BASE };
 static const u32 uart_sysctl[] = { SYSCTL_PERIPH_UART0, SYSCTL_PERIPH_UART1, SYSCTL_PERIPH_UART2 };
@@ -276,24 +238,17 @@
 {
   unsigned i;
 
-  for( i = 0; i &lt; UARTS_COUNT; i ++ )
-  {
+  for( i = 0; i &lt; NUM_UART; i ++ )
     SysCtlPeripheralEnable(uart_sysctl[ i ]);
-  }
 
   // Special case for UART 0
   // Configure the UART for 115,200, 8-N-1 operation.
   GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
-  UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 115200,
+  UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), CON_UART_SPEED,
                      (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                       UART_CONFIG_PAR_NONE)); 
 }
 
-int platform_uart_exists( unsigned id )
-{
-  return id &lt; UARTS_COUNT;
-}
-
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   u32 config;
@@ -331,35 +286,13 @@
   UARTCharPut( uart_base[ id ], data );
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
   u32 base = uart_base[ id ];
-  timer_data_type tmr_start, tmr_crt;
-  int res;
   
   if( timeout == 0 )
-  {
     return UARTCharGetNonBlocking( base );  
-  }
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-  {
-    // Receive char blocking
-    return UARTCharGet( base );
-  }
-  else
-  {
-    // Receive char with the specified timeout
-    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START, 0 );
-    while( 1 )
-    {
-      if( ( res = UARTCharGetNonBlocking( base ) ) &gt;= 0 )
-        break;
-      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
-      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
-        break;
-    }
-    return res;
-  }
+  return UARTCharGet( base );
 }
 
 // ****************************************************************************
@@ -369,27 +302,21 @@
 // All possible LM3S timers defs
 static const u32 timer_base[] = { TIMER0_BASE, TIMER1_BASE, TIMER2_BASE, TIMER3_BASE };
 static const u32 timer_sysctl[] = { SYSCTL_PERIPH_TIMER0, SYSCTL_PERIPH_TIMER1, SYSCTL_PERIPH_TIMER2, SYSCTL_PERIPH_TIMER3 };
-#define TIMERS_COUNT			4
 
 static void timers_init()
 {
   unsigned i;
 
-  for( i = 0; i &lt; TIMERS_COUNT; i ++ )
+  for( i = 0; i &lt; NUM_TIMER; i ++ )
   {
-	SysCtlPeripheralEnable(timer_sysctl[ i ]);
+    SysCtlPeripheralEnable(timer_sysctl[ i ]);
     TimerConfigure(timer_base[ i ], TIMER_CFG_32_BIT_PER);
     TimerEnable(timer_base[ i ], TIMER_A);
   }
 }
 
-int platform_timer_exists( unsigned id )
+void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
-  return id &lt; TIMERS_COUNT;
-}
-
-void platform_timer_delay( unsigned id, u32 delay_us )
-{
   timer_data_type final;
   u32 base = timer_base[ id ];
   
@@ -398,7 +325,7 @@
   while( TimerValueGet( base, TIMER_A ) &gt; final );
 }
       
-u32 platform_timer_op( unsigned id, int op, u32 data )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   u32 base = timer_base[ id ]; 
@@ -432,26 +359,10 @@
   return res;
 }
 
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
-{
-  timer_data_type temp;
-  
-  id = id;
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / SysCtlClockGet();
-}
-
 // ****************************************************************************
 // PWMs
 // Same on LM3S8962 and LM3S6965
 
-#define PLATFORM_NUM_PWMS               6
-
 // SYSCTL div data and actual div factors
 const static u32 pwm_div_ctl[] = { SYSCTL_PWMDIV_1, SYSCTL_PWMDIV_2, SYSCTL_PWMDIV_4, SYSCTL_PWMDIV_8, SYSCTL_PWMDIV_16, SYSCTL_PWMDIV_32, SYSCTL_PWMDIV_64 };
 const static u8 pwm_div_data[] = { 1, 2, 4, 8, 16, 32, 64 };
@@ -496,11 +407,6 @@
   return sysclk / pwm_div_data[ min_i ];
 }
 
-int platform_pwm_exists( unsigned id )
-{
-  return id &lt; PLATFORM_NUM_PWMS; 
-}
-
 u32 platform_pwm_setup( unsigned id, u32 frequency, unsigned duty )
 {
   u32 pwmclk = platform_pwm_get_clock();
@@ -560,11 +466,6 @@
   IntMasterDisable();
 }
 
-u32 platform_cpu_get_frequency()
-{
-  return SysCtlClockGet();
-}
-
 // ****************************************************************************
 // OLED Display specific functions
 // 
@@ -720,6 +621,9 @@
 
 void SysTickIntHandler()
 {
+  // Handle virtual timers
+  cmn_virtual_timer_cb();
+  
   // Indicate that a SysTick interrupt has occurred.
   eth_timer_fired = 1;
 
@@ -744,26 +648,10 @@
 
 void SysTickIntHandler()
 {
+  cmn_virtual_timer_cb();
 }
 
 void EthernetIntHandler()
 {
 }
 #endif // #ifdef ELUA_UIP
-
-// ****************************************************************************
-// Allocator support
-
-extern char end[];
-
-void* platform_get_first_free_ram( unsigned id )
-{
-  return id &gt; 0 ?  NULL : ( void* )end;
-}
-
-#define STACK_SIZE 256
-#define SRAM_SIZE ( 64 * 1024 )
-void* platform_get_last_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )( SRAM_BASE + SRAM_SIZE - STACK_SIZE - 1 );
-}

Modified: trunk/src/platform/lm3s/platform_conf.h
===================================================================
--- trunk/src/platform/lm3s/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lm3s/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,10 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;hw_memmap.h&quot;
+#include &quot;hw_types.h&quot;
+#include &quot;stacks.h&quot;
+#include &quot;sysctl.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -21,9 +25,9 @@
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define XMODEM_UART_ID        0
+#define CON_UART_ID           0
+#define CON_UART_SPEED        115200
 #define XMODEM_TIMER_ID       0
-#define TERM_UART_ID          0
 #define TERM_TIMER_ID         0
 #define TERM_LINES            25
 #define TERM_COLS             80
@@ -51,27 +55,61 @@
 // Configuration data
 
 // Static TCP/IP configuration
-#define ELUA_CONF_IPADDR0         192
-#define ELUA_CONF_IPADDR1         168
-#define ELUA_CONF_IPADDR2         1
-#define ELUA_CONF_IPADDR3         218
+#define ELUA_CONF_IPADDR0     192
+#define ELUA_CONF_IPADDR1     168
+#define ELUA_CONF_IPADDR2     1
+#define ELUA_CONF_IPADDR3     218
 
-#define ELUA_CONF_NETMASK0        255
-#define ELUA_CONF_NETMASK1        255
-#define ELUA_CONF_NETMASK2        255
-#define ELUA_CONF_NETMASK3        0
+#define ELUA_CONF_NETMASK0    255
+#define ELUA_CONF_NETMASK1    255
+#define ELUA_CONF_NETMASK2    255
+#define ELUA_CONF_NETMASK3    0
 
-#define ELUA_CONF_DEFGW0          192
-#define ELUA_CONF_DEFGW1          168
-#define ELUA_CONF_DEFGW2          1
-#define ELUA_CONF_DEFGW3          1
+#define ELUA_CONF_DEFGW0      192
+#define ELUA_CONF_DEFGW1      168
+#define ELUA_CONF_DEFGW2      1
+#define ELUA_CONF_DEFGW3      1
 
-#define ELUA_CONF_DNS0            192
-#define ELUA_CONF_DNS1            168
-#define ELUA_CONF_DNS2            1
-#define ELUA_CONF_DNS3            1
+#define ELUA_CONF_DNS0        192
+#define ELUA_CONF_DNS1        168
+#define ELUA_CONF_DNS2        1
+#define ELUA_CONF_DNS3        1
 
 // *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       4
+#define VTMR_FREQ_HZ          4
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               7
+#define NUM_SPI               1
+#ifdef FORLM3S8962
+  #define NUM_UART            2
+#else
+  #define NUM_UART            3
+#endif
+#define NUM_TIMER             4
+#define NUM_PWM               6
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+#define CPU_FREQUENCY         SysCtlClockGet()
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            'A'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array 
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PIN_ARRAY         { 8, 8, 8, 8, 4, 4, 2 }
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define MEM_START_ADDRESS     { ( void* )end }
+#define MEM_END_ADDRESS       { ( void* )( SRAM_BASE + 0x10000 - STACK_SIZE_TOTAL - 1 ) }
+
+// *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module
 
 #include &quot;hw_ints.h&quot;

Added: trunk/src/platform/lm3s/stacks.h
===================================================================
--- trunk/src/platform/lm3s/stacks.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lm3s/stacks.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -0,0 +1,9 @@
+// Stack size definitions
+
+#ifndef __STACKS_H__
+#define __STACKS_H__
+
+#define  STACK_SIZE       512
+#define  STACK_SIZE_TOTAL ( STACK_SIZE )
+
+#endif

Modified: trunk/src/platform/lpc288x/lpc2888.lds
===================================================================
--- trunk/src/platform/lpc288x/lpc2888.lds	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lpc288x/lpc2888.lds	2009-01-07 20:17:18 UTC (rev 143)
@@ -13,6 +13,7 @@
     {
         . = ALIGN(4);
         _sfixed = .;
+        KEEP(*(.vectors))
         *(.text .text.*)        
         *(.rodata .rodata.*)        
         *(.gnu.linkonce.t.*)

Modified: trunk/src/platform/lpc288x/lpc28xx.s
===================================================================
--- trunk/src/platform/lpc288x/lpc28xx.s	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lpc288x/lpc28xx.s	2009-01-07 20:17:18 UTC (rev 143)
@@ -159,10 +159,12 @@
 @ Area Definition and Entry Point
 @ Startup Code must be linked first at Address at which it expects to run.
 
-            .section .text
             .arm
+            .align 4
             .global HardReset
 
+            .section  .vectors, &quot;a&quot;
+
 HardReset:
 
 @ Exception Vectors
@@ -195,6 +197,8 @@
 
 @ ==============================================================================
 @ Reset handler
+
+            .text
                         
 Reset_Handler:   
 

Modified: trunk/src/platform/lpc288x/platform.c
===================================================================
--- trunk/src/platform/lpc288x/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lpc288x/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -14,20 +14,9 @@
 #include &quot;target.h&quot;
 #include &quot;uart.h&quot;
 #include &quot;utils.h&quot;
+#include &quot;common.h&quot;
+#include &quot;platform_conf.h&quot;
 
-// *****************************************************************************
-// std functions
-
-static void uart_send( int fd, char c )
-{
-  uart_write( c );
-}
-
-static int uart_recv()
-{
-  return uart_read();
-}
-
 // ****************************************************************************
 // Platform initialization
 
@@ -37,7 +26,7 @@
   lpc288x_init();
   
   // Initialize UART
-  uart_init( 115200, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
+  uart_init( CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
   
   // Initialize timers
   T0CTRL = 0;
@@ -45,9 +34,7 @@
   INT_REQ5 = ( 1 &lt;&lt; 28 ) | ( 1 &lt;&lt; 27 ) | ( 1 &lt;&lt; 26 ) | ( 1 &lt;&lt; 16 ) | 0x1;
   INT_REQ6 = ( 1 &lt;&lt; 28 ) | ( 1 &lt;&lt; 27 ) | ( 1 &lt;&lt; 26 ) | ( 1 &lt;&lt; 16 ) | 0x1;    
   
-  // Set the send/recv functions                          
-  std_set_send_func( uart_send );
-  std_set_get_func( uart_recv );  
+  cmn_platform_init();
   
   return PLATFORM_OK;
 } 
@@ -66,26 +53,6 @@
 static const vu_ptr pio_m1_regs[] = { &amp;MODE1_0, &amp;MODE1_1, &amp;MODE1_2, &amp;MODE1_3, &amp;MODE1_4, &amp;MODE1_5, &amp;MODE1_6, &amp;MODE1_7 };
 static const vu_ptr pio_pin_regs[] = { &amp;PINS_0, &amp;PINS_1, &amp;PINS_2, &amp;PINS_3, &amp;PINS_4, &amp;PINS_5, &amp;PINS_6, &amp;PINS_7 };
 
-int platform_pio_has_port( unsigned port )
-{
-  return port &lt; 8;
-}
-
-const char* platform_pio_get_prefix( unsigned port )
-{
-  static char c[ 3 ];
-  
-  sprintf( c, &quot;P%d&quot;, port );
-  return c;
-}
-
-// Maximum number of pins per port
-static const unsigned pins_per_port[] = { 32, 20, 4, 6, 12, 6, 4, 1 };
-int platform_pio_has_pin( unsigned port, unsigned pin )
-{
-  return port &lt; 8 &amp;&amp; pin &lt; pins_per_port[ port ];
-}
-
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
   pio_type retval = 1;
@@ -140,11 +107,6 @@
 // ****************************************************************************
 // UART
 
-int platform_uart_exists( unsigned id )
-{
-  return id &lt; 1;
-}
-
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   return uart_init( baud, databits, parity, stopbits );
@@ -155,35 +117,14 @@
   uart_write( data );
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
-  timer_data_type tmr_start, tmr_crt;
-  int res;
-    
   if( timeout == 0 )
   {
     // Return data only if already available
     return uart_read_nb();
   }
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-  {
-    // Wait for data
-    return uart_read();
-  }
-  else
-  {
-    // Receive char with the specified timeout
-    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START,0 );
-    while( 1 )
-    {
-      if( ( res = uart_read_nb() ) &gt; 0 )
-        break;
-      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
-      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
-        break;
-    }
-    return res;    
-  }  
+  return uart_read();
 }
 
 // ****************************************************************************
@@ -212,12 +153,8 @@
   *tmr_ctrl[ id ] = ( *tmr_ctrl[ id ] &amp; ~0xB ) | ( mini &lt;&lt; 2 );
   return MAIN_CLOCK / tmr_prescale[ mini ];
 }
-int platform_timer_exists( unsigned id )
-{
-  return id &lt; 2;
-}
 
-void platform_timer_delay( unsigned id, u32 delay_us )
+void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
   u32 freq;
   u64 final;
@@ -234,7 +171,7 @@
   while( ( INT_PENDING &amp; mask ) == 0 );
 }
       
-u32 platform_timer_op( unsigned id, int op, u32 data )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   
@@ -270,50 +207,3 @@
   return res;
 }
 
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
-{
-  timer_data_type temp;
-  u32 freq;
-    
-  freq = platform_timer_get_clock( id );
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / freq;
-}
-
-// ****************************************************************************
-// CPU functions
-
-u32 platform_cpu_get_frequency()
-{
-  return Fcclk;
-}
-
-// ****************************************************************************
-// Allocator support
-
-extern char end[];
-
-void* platform_get_first_free_ram( unsigned id )
-{
-  if( id &gt; 1 )
-    return NULL;
-  else
-    return id == 0 ? ( void* )end : ( void* )SDRAM_BASE_ADDR;
-}
-
-#define SRAM_ORIGIN 0x00400000
-#define SRAM_SIZE 0x10000
-
-void* platform_get_last_free_ram( unsigned id )
-{
-  if( id &gt; 1 )
-    return NULL;
-  else
-    return id == 0 ? ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) : 
-                     ( void* )( SDRAM_BASE_ADDR + SDRAM_SIZE - 1 );
-}

Modified: trunk/src/platform/lpc288x/platform_conf.h
===================================================================
--- trunk/src/platform/lpc288x/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/lpc288x/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,8 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;stacks.h&quot;
+#include &quot;target.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -17,15 +19,46 @@
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define XMODEM_UART_ID        0
+#define CON_UART_ID           0
+#define CON_UART_SPEED        115200
 #define XMODEM_TIMER_ID       0
-#define TERM_UART_ID          0
 #define TERM_TIMER_ID         0
 #define TERM_LINES            25
 #define TERM_COLS             80
 #define TERM_TIMEOUT          100000
 
 // *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       0
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               8
+#define NUM_SPI               0
+#define NUM_UART              1
+#define NUM_TIMER             2
+#define NUM_PWM               0
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+#define CPU_FREQUENCY         Fcclk
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            '0'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PIN_ARRAY         { 32, 20, 4, 6, 12, 6, 4, 1 }
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define SRAM_ORIGIN           0x00400000
+#define SRAM_SIZE             0x10000
+#define MEM_START_ADDRESS     { ( void* )end, ( void* )SDRAM_BASE_ADDR }
+#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ), ( void* )( SDRAM_BASE_ADDR + SDRAM_SIZE - 1 ) }
+
+// *****************************************************************************
 // Auxiliary libraries that will be compiled for this platform
 
 #define LUA_PLATFORM_LIBS\

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_adc.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,1402 +1,1402 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_adc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the ADC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_adc.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ADC DISCNUM mask */
-#define CR1_DISCNUM_Reset           ((u32)0xFFFF1FFF)
-
-/* ADC DISCEN mask */
-#define CR1_DISCEN_Set              ((u32)0x00000800)
-#define CR1_DISCEN_Reset            ((u32)0xFFFFF7FF)
-
-/* ADC JAUTO mask */
-#define CR1_JAUTO_Set               ((u32)0x00000400)
-#define CR1_JAUTO_Reset             ((u32)0xFFFFFBFF)
-
-/* ADC JDISCEN mask */
-#define CR1_JDISCEN_Set             ((u32)0x00001000)
-#define CR1_JDISCEN_Reset           ((u32)0xFFFFEFFF)
-
-/* ADC AWDCH mask */
-#define CR1_AWDCH_Reset             ((u32)0xFFFFFFE0)
-
-/* ADC Analog watchdog enable mode mask */
-#define CR1_AWDMode_Reset           ((u32)0xFF3FFDFF)
-
-/* CR1 register Mask */
-#define CR1_CLEAR_Mask              ((u32)0xFFF0FEFF)
-
-/* ADC ADON mask */
-#define CR2_ADON_Set                ((u32)0x00000001)
-#define CR2_ADON_Reset              ((u32)0xFFFFFFFE)
-
-/* ADC DMA mask */
-#define CR2_DMA_Set                 ((u32)0x00000100)
-#define CR2_DMA_Reset               ((u32)0xFFFFFEFF)
-
-/* ADC RSTCAL mask */
-#define CR2_RSTCAL_Set              ((u32)0x00000008)
-
-/* ADC CAL mask */
-#define CR2_CAL_Set                 ((u32)0x00000004)
-
-/* ADC SWSTART mask */
-#define CR2_SWSTART_Set             ((u32)0x00400000)
-
-/* ADC EXTTRIG mask */
-#define CR2_EXTTRIG_Set             ((u32)0x00100000)
-#define CR2_EXTTRIG_Reset           ((u32)0xFFEFFFFF)
-
-/* ADC Software start mask */
-#define CR2_EXTTRIG_SWSTART_Set     ((u32)0x00500000)
-#define CR2_EXTTRIG_SWSTART_Reset   ((u32)0xFFAFFFFF)
-
-/* ADC JEXTSEL mask */
-#define CR2_JEXTSEL_Reset           ((u32)0xFFFF8FFF)
-
-/* ADC JEXTTRIG mask */
-#define CR2_JEXTTRIG_Set            ((u32)0x00008000)
-#define CR2_JEXTTRIG_Reset          ((u32)0xFFFF7FFF)
-
-/* ADC JSWSTART mask */
-#define CR2_JSWSTART_Set            ((u32)0x00200000)
-
-/* ADC injected software start mask */
-#define CR2_JEXTTRIG_JSWSTART_Set   ((u32)0x00208000)
-#define CR2_JEXTTRIG_JSWSTART_Reset ((u32)0xFFDF7FFF)
-
-/* ADC TSPD mask */
-#define CR2_TSVREFE_Set             ((u32)0x00800000)
-#define CR2_TSVREFE_Reset           ((u32)0xFF7FFFFF)
-
-/* CR2 register Mask */
-#define CR2_CLEAR_Mask              ((u32)0xFFF1F7FD)
-
-/* ADC SQx mask */
-#define SQR3_SQ_Set                 ((u32)0x0000001F)
-#define SQR2_SQ_Set                 ((u32)0x0000001F)
-#define SQR1_SQ_Set                 ((u32)0x0000001F)
-
-/* SQR1 register Mask */
-#define SQR1_CLEAR_Mask             ((u32)0xFF0FFFFF)
-
-/* ADC JSQx mask */
-#define JSQR_JSQ_Set                ((u32)0x0000001F)
-
-/* ADC JL mask */
-#define JSQR_JL_Set                 ((u32)0x00300000)
-#define JSQR_JL_Reset               ((u32)0xFFCFFFFF)
-
-/* ADC SMPx mask */
-#define SMPR1_SMP_Set               ((u32)0x00000007)
-#define SMPR2_SMP_Set               ((u32)0x00000007)
-
-/* ADC JDRx registers offset */
-#define JDR_Offset                  ((u8)0x28)
-
-/* ADC1 DR register base address */
-#define DR_ADDRESS                  ((u32)0x4001244C)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : ADC_DeInit
-* Description    : Deinitializes the ADCx peripheral registers to their default
-*                  reset values.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DeInit(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  switch (*(u32*)&amp;ADCx)
-  {
-    case ADC1_BASE:
-      /* Enable ADC1 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
-      /* Release ADC1 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
-      break;
-    
-    case ADC2_BASE:
-      /* Enable ADC2 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
-      /* Release ADC2 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
-      break;
-      
-    case ADC3_BASE:
-      /* Enable ADC3 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
-      /* Release ADC3 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
-      break; 
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_Init
-* Description    : Initializes the ADCx peripheral according to the specified parameters
-*                  in the ADC_InitStruct.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_InitStruct: pointer to an ADC_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    ADC peripheral.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
-{
-  u32 tmpreg1 = 0;
-  u8 tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_MODE(ADC_InitStruct-&gt;ADC_Mode));
-  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ScanConvMode));
-  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ContinuousConvMode));  		    
-  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct-&gt;ADC_ExternalTrigConv));   
-  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct-&gt;ADC_DataAlign)); 
-  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct-&gt;ADC_NbrOfChannel));
-
-  /*---------------------------- ADCx CR1 Configuration -----------------*/
-  /* Get the ADCx CR1 value */
-  tmpreg1 = ADCx-&gt;CR1;
-  /* Clear DUALMOD and SCAN bits */
-  tmpreg1 &amp;= CR1_CLEAR_Mask;
-  /* Configure ADCx: Dual mode and scan conversion mode */
-  /* Set DUALMOD bits according to ADC_Mode value */
-  /* Set SCAN bit according to ADC_ScanConvMode value */
-  tmpreg1 |= (u32)(ADC_InitStruct-&gt;ADC_Mode | ((u32)ADC_InitStruct-&gt;ADC_ScanConvMode &lt;&lt; 8));
-  /* Write to ADCx CR1 */
-  ADCx-&gt;CR1 = tmpreg1;
-
-  /*---------------------------- ADCx CR2 Configuration -----------------*/
-  /* Get the ADCx CR2 value */
-  tmpreg1 = ADCx-&gt;CR2;
-  /* Clear CONT, ALIGN and EXTSEL bits */
-  tmpreg1 &amp;= CR2_CLEAR_Mask;
-  /* Configure ADCx: external trigger event and continuous conversion mode */
-  /* Set ALIGN bit according to ADC_DataAlign value */
-  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
-  /* Set CONT bit according to ADC_ContinuousConvMode value */
-  tmpreg1 |= (u32)(ADC_InitStruct-&gt;ADC_DataAlign | ADC_InitStruct-&gt;ADC_ExternalTrigConv |
-            ((u32)ADC_InitStruct-&gt;ADC_ContinuousConvMode &lt;&lt; 1));
-  /* Write to ADCx CR2 */
-  ADCx-&gt;CR2 = tmpreg1;
-
-  /*---------------------------- ADCx SQR1 Configuration -----------------*/
-  /* Get the ADCx SQR1 value */
-  tmpreg1 = ADCx-&gt;SQR1;
-  /* Clear L bits */
-  tmpreg1 &amp;= SQR1_CLEAR_Mask;
-  /* Configure ADCx: regular channel sequence length */
-  /* Set L bits according to ADC_NbrOfChannel value */
-  tmpreg2 |= (ADC_InitStruct-&gt;ADC_NbrOfChannel - 1);
-  tmpreg1 |= ((u32)tmpreg2 &lt;&lt; 20);
-  /* Write to ADCx SQR1 */
-  ADCx-&gt;SQR1 = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_StructInit
-* Description    : Fills each ADC_InitStruct member with its default value.
-* Input          : ADC_InitStruct : pointer to an ADC_InitTypeDef structure
-*                  which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
-{
-  /* Reset ADC init structure parameters values */
-  /* Initialize the ADC_Mode member */
-  ADC_InitStruct-&gt;ADC_Mode = ADC_Mode_Independent;
-
-  /* initialize the ADC_ScanConvMode member */
-  ADC_InitStruct-&gt;ADC_ScanConvMode = DISABLE;
-
-  /* Initialize the ADC_ContinuousConvMode member */
-  ADC_InitStruct-&gt;ADC_ContinuousConvMode = DISABLE;
-
-  /* Initialize the ADC_ExternalTrigConv member */
-  ADC_InitStruct-&gt;ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
-
-  /* Initialize the ADC_DataAlign member */
-  ADC_InitStruct-&gt;ADC_DataAlign = ADC_DataAlign_Right;
-
-  /* Initialize the ADC_NbrOfChannel member */
-  ADC_InitStruct-&gt;ADC_NbrOfChannel = 1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_Cmd
-* Description    : Enables or disables the specified ADC peripheral.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the ADCx peripheral. This parameter
-*                    can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the ADON bit to wake up the ADC from power down mode */
-    ADCx-&gt;CR2 |= CR2_ADON_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC peripheral */
-    ADCx-&gt;CR2 &amp;= CR2_ADON_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_DMACmd
-* Description    : Enables or disables the specified ADC DMA request.
-* Input          : - ADCx: where x can be 1 or 3 to select the ADC peripheral.
-*                    Note: ADC2 hasn't a DMA capability.
-*                  - NewState: new state of the selected ADC DMA transfer.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_DMA_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC DMA request */
-    ADCx-&gt;CR2 |= CR2_DMA_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC DMA request */
-    ADCx-&gt;CR2 &amp;= CR2_DMA_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ITConfig
-* Description    : Enables or disables the specified ADC interrupts.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_IT: specifies the ADC interrupt sources to be enabled
-*                    or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - ADC_IT_EOC: End of conversion interrupt mask
-*                       - ADC_IT_AWD: Analog watchdog interrupt mask
-*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
-*                  - NewState: new state of the specified ADC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
-{
-  u8 itmask = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_ADC_IT(ADC_IT));
-
-  /* Get the ADC IT index */
-  itmask = (u8)ADC_IT;
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC interrupts */
-    ADCx-&gt;CR1 |= itmask;
-  }
-  else
-  {
-    /* Disable the selected ADC interrupts */
-    ADCx-&gt;CR1 &amp;= (~(u32)itmask);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ResetCalibration
-* Description    : Resets the selected ADC calibration registers.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ResetCalibration(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Resets the selected ADC calibartion registers */  
-  ADCx-&gt;CR2 |= CR2_RSTCAL_Set;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetResetCalibrationStatus
-* Description    : Gets the selected ADC reset calibration registers status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC reset calibration registers (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of RSTCAL bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_RSTCAL_Set) != (u32)RESET)
-  {
-    /* RSTCAL bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* RSTCAL bit is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the RSTCAL bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_StartCalibration
-* Description    : Starts the selected ADC calibration process.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_StartCalibration(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Enable the selected ADC calibration process */  
-  ADCx-&gt;CR2 |= CR2_CAL_Set;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetCalibrationStatus
-* Description    : Gets the selected ADC calibration status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC calibration (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of CAL bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_CAL_Set) != (u32)RESET)
-  {
-    /* CAL bit is set: calibration on going */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* CAL bit is reset: end of calibration */
-    bitstatus = RESET;
-  }
-
-  /* Return the CAL bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_SoftwareStartConvCmd
-* Description    : Enables or disables the selected ADC software start conversion .
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC software start conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion on external event and start the selected
-       ADC conversion */
-    ADCx-&gt;CR2 |= CR2_EXTTRIG_SWSTART_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event and stop the selected
-       ADC conversion */
-    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_SWSTART_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetSoftwareStartConvStatus
-* Description    : Gets the selected ADC Software start conversion Status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC software start conversion (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of SWSTART bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_SWSTART_Set) != (u32)RESET)
-  {
-    /* SWSTART bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SWSTART bit is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the SWSTART bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_DiscModeChannelCountConfig
-* Description    : Configures the discontinuous mode for the selected ADC regular
-*                  group channel.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - Number: specifies the discontinuous mode regular channel
-*                    count value. This number must be between 1 and 8.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
-{
-  u32 tmpreg1 = 0;
-  u32 tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
-
-  /* Get the old register value */
-  tmpreg1 = ADCx-&gt;CR1;
-  /* Clear the old discontinuous mode channel count */
-  tmpreg1 &amp;= CR1_DISCNUM_Reset;
-  /* Set the discontinuous mode channel count */
-  tmpreg2 = Number - 1;
-  tmpreg1 |= tmpreg2 &lt;&lt; 13;
-  /* Store the new register value */
-  ADCx-&gt;CR1 = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_DiscModeCmd
-* Description    : Enables or disables the discontinuous mode on regular group
-*                  channel for the specified ADC
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC discontinuous mode
-*                    on regular group channel.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC regular discontinuous mode */
-    ADCx-&gt;CR1 |= CR1_DISCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC regular discontinuous mode */
-    ADCx-&gt;CR1 &amp;= CR1_DISCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_RegularChannelConfig
-* Description    : Configures for the selected ADC regular channel its corresponding
-*                  rank in the sequencer and its sample time.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_Channel: the ADC channel to configure. 
-*                    This parameter can be one of the following values:
-*                       - ADC_Channel_0: ADC Channel0 selected
-*                       - ADC_Channel_1: ADC Channel1 selected
-*                       - ADC_Channel_2: ADC Channel2 selected
-*                       - ADC_Channel_3: ADC Channel3 selected
-*                       - ADC_Channel_4: ADC Channel4 selected
-*                       - ADC_Channel_5: ADC Channel5 selected
-*                       - ADC_Channel_6: ADC Channel6 selected
-*                       - ADC_Channel_7: ADC Channel7 selected
-*                       - ADC_Channel_8: ADC Channel8 selected
-*                       - ADC_Channel_9: ADC Channel9 selected
-*                       - ADC_Channel_10: ADC Channel10 selected
-*                       - ADC_Channel_11: ADC Channel11 selected
-*                       - ADC_Channel_12: ADC Channel12 selected
-*                       - ADC_Channel_13: ADC Channel13 selected
-*                       - ADC_Channel_14: ADC Channel14 selected
-*                       - ADC_Channel_15: ADC Channel15 selected
-*                       - ADC_Channel_16: ADC Channel16 selected
-*                       - ADC_Channel_17: ADC Channel17 selected
-*                  - Rank: The rank in the regular group sequencer. This parameter
-*                    must be between 1 to 16.
-*                  - ADC_SampleTime: The sample time value to be set for the
-*                    selected channel. 
-*                    This parameter can be one of the following values:
-*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
-*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
-*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
-*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
-*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
-*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
-*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
-*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
-{
-  u32 tmpreg1 = 0, tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-  assert_param(IS_ADC_REGULAR_RANK(Rank));
-  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
-
-  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
-  if (ADC_Channel &gt; ADC_Channel_9)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3 * (ADC_Channel - 10));
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * (ADC_Channel - 10));
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR1 = tmpreg1;
-  }
-  else /* ADC_Channel include in ADC_Channel_[0..9] */
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR2 = tmpreg1;
-  }
-  /* For Rank 1 to 6 */
-  if (Rank &lt; 7)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SQR3;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR3_SQ_Set &lt;&lt; (5 * (Rank - 1));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 1));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SQR3 = tmpreg1;
-  }
-  /* For Rank 7 to 12 */
-  else if (Rank &lt; 13)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SQR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR2_SQ_Set &lt;&lt; (5 * (Rank - 7));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 7));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SQR2 = tmpreg1;
-  }
-  /* For Rank 13 to 16 */
-  else
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SQR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR1_SQ_Set &lt;&lt; (5 * (Rank - 13));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 13));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SQR1 = tmpreg1;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ExternalTrigConvCmd
-* Description    : Enables or disables the ADCx conversion through external trigger.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC external trigger
-*                    start of conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion on external event */
-    ADCx-&gt;CR2 |= CR2_EXTTRIG_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event */
-    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetConversionValue
-* Description    : Returns the last ADCx conversion result data for regular channel.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The Data conversion value.
-*******************************************************************************/
-u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Return the selected ADC conversion value */
-  return (u16) ADCx-&gt;DR;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetDualModeConversionValue
-* Description    : Returns the last ADC1 and ADC2 conversion result data in dual mode.
-* Output         : None
-* Return         : The Data conversion value.
-*******************************************************************************/
-u32 ADC_GetDualModeConversionValue(void)
-{
-  /* Return the dual mode conversion value */
-  return (*(vu32 *) DR_ADDRESS);
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AutoInjectedConvCmd
-* Description    : Enables or disables the selected ADC automatic injected group
-*                  conversion after regular one.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC auto injected
-*                    conversion
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC automatic injected group conversion */
-    ADCx-&gt;CR1 |= CR1_JAUTO_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC automatic injected group conversion */
-    ADCx-&gt;CR1 &amp;= CR1_JAUTO_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_InjectedDiscModeCmd
-* Description    : Enables or disables the discontinuous mode for injected group
-*                  channel for the specified ADC
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC discontinuous mode
-*                    on injected group channel.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC injected discontinuous mode */
-    ADCx-&gt;CR1 |= CR1_JDISCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC injected discontinuous mode */
-    ADCx-&gt;CR1 &amp;= CR1_JDISCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ExternalTrigInjectedConvConfig
-* Description    : Configures the ADCx external trigger for injected channels conversion.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_ExternalTrigInjecConv: specifies the ADC trigger to
-*                    start injected conversion. 
-*                    This parameter can be one of the following values:
-*                       - ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event 
-*                         selected (for ADC1, ADC2 and ADC3)
-*                       - ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture
-*                         compare4 selected (for ADC1, ADC2 and ADC3)
-*                       - ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event
-*                         selected (for ADC1 and ADC2)
-*                       - ADC_External TrigInjecConv_T2_CC1: Timer2 capture
-*                         compare1 selected (for ADC1 and ADC2)
-*                       - ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture
-*                         compare4 selected (for ADC1 and ADC2)
-*                       - ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event
-*                         selected (for ADC1 and ADC2)
-*                       - ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External
-*                         interrupt line 15 or Timer8 capture compare4 event selected
-*                         (for ADC1 and ADC2)                       
-*                       - ADC_External TrigInjecConv_T4_CC3: Timer4 capture
-*                         compare3 selected (for ADC3 only)
-*                       - ADC_External TrigInjecConv_T8_CC2: Timer8 capture
-*                         compare2 selected (for ADC3 only)                         
-*                       - ADC_External TrigInjecConv_T8_CC4: Timer8 capture
-*                         compare4 selected (for ADC3 only)
-*                       - ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event
-*                         selected (for ADC3 only)                         
-*                       - ADC_External TrigInjecConv_T5_CC4: Timer5 capture
-*                         compare4 selected (for ADC3 only)                        
-*                       - ADC_ExternalTrigInjecConv_None: Injected conversion
-*                         started by software and not by external trigger (for 
-*                         ADC1, ADC2 and ADC3)
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
-
-  /* Get the old register value */
-  tmpreg = ADCx-&gt;CR2;
-  /* Clear the old external event selection for injected group */
-  tmpreg &amp;= CR2_JEXTSEL_Reset;
-  /* Set the external event selection for injected group */
-  tmpreg |= ADC_ExternalTrigInjecConv;
-  /* Store the new register value */
-  ADCx-&gt;CR2 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ExternalTrigInjectedConvCmd
-* Description    : Enables or disables the ADCx injected channels conversion
-*                  through external trigger
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC external trigger
-*                    start of injected conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC external event selection for injected group */
-    ADCx-&gt;CR2 |= CR2_JEXTTRIG_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC external event selection for injected group */
-    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_SoftwareStartInjectedConvCmd
-* Description    : Enables or disables the selected ADC start of the injected 
-*                  channels conversion.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - NewState: new state of the selected ADC software start
-*                    injected conversion.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion for injected group on external event and start the selected
-       ADC injected conversion */
-    ADCx-&gt;CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event for injected group and stop the selected
-       ADC injected conversion */
-    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_JSWSTART_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetSoftwareStartInjectedConvCmdStatus
-* Description    : Gets the selected ADC Software start injected conversion Status.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-* Output         : None
-* Return         : The new state of ADC software start injected conversion (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-
-  /* Check the status of JSWSTART bit */
-  if ((ADCx-&gt;CR2 &amp; CR2_JSWSTART_Set) != (u32)RESET)
-  {
-    /* JSWSTART bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* JSWSTART bit is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the JSWSTART bit status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_InjectedChannelConfig
-* Description    : Configures for the selected ADC injected channel its corresponding
-*                  rank in the sequencer and its sample time.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_Channel: the ADC channel to configure. 
-*                    This parameter can be one of the following values:
-*                       - ADC_Channel_0: ADC Channel0 selected
-*                       - ADC_Channel_1: ADC Channel1 selected
-*                       - ADC_Channel_2: ADC Channel2 selected
-*                       - ADC_Channel_3: ADC Channel3 selected
-*                       - ADC_Channel_4: ADC Channel4 selected
-*                       - ADC_Channel_5: ADC Channel5 selected
-*                       - ADC_Channel_6: ADC Channel6 selected
-*                       - ADC_Channel_7: ADC Channel7 selected
-*                       - ADC_Channel_8: ADC Channel8 selected
-*                       - ADC_Channel_9: ADC Channel9 selected
-*                       - ADC_Channel_10: ADC Channel10 selected
-*                       - ADC_Channel_11: ADC Channel11 selected
-*                       - ADC_Channel_12: ADC Channel12 selected
-*                       - ADC_Channel_13: ADC Channel13 selected
-*                       - ADC_Channel_14: ADC Channel14 selected
-*                       - ADC_Channel_15: ADC Channel15 selected
-*                       - ADC_Channel_16: ADC Channel16 selected
-*                       - ADC_Channel_17: ADC Channel17 selected
-*                  - Rank: The rank in the injected group sequencer. This parameter
-*                    must be between 1 to 4.
-*                  - ADC_SampleTime: The sample time value to be set for the
-*                    selected channel. 
-*                    This parameter can be one of the following values:
-*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
-*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
-*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
-*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
-*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
-*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
-*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
-*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
-{
-  u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-  assert_param(IS_ADC_INJECTED_RANK(Rank));
-  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
-
-  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
-  if (ADC_Channel &gt; ADC_Channel_9)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3*(ADC_Channel - 10));
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3*(ADC_Channel - 10));
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR1 = tmpreg1;
-  }
-  else /* ADC_Channel include in ADC_Channel_[0..9] */
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx-&gt;SMPR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
-    /* Clear the old discontinuous mode channel count */
-    tmpreg1 &amp;= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
-    /* Set the discontinuous mode channel count */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx-&gt;SMPR2 = tmpreg1;
-  }
-
-  /* Rank configuration */
-  /* Get the old register value */
-  tmpreg1 = ADCx-&gt;JSQR;
-  /* Get JL value: Number = JL+1 */
-  tmpreg3 =  (tmpreg1 &amp; JSQR_JL_Set)&gt;&gt; 20;
-  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
-  tmpreg2 = JSQR_JSQ_Set &lt;&lt; (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
-  /* Clear the old JSQx bits for the selected rank */
-  tmpreg1 &amp;= ~tmpreg2;
-  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
-  tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
-  /* Set the JSQx bits for the selected rank */
-  tmpreg1 |= tmpreg2;
-  /* Store the new register value */
-  ADCx-&gt;JSQR = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_InjectedSequencerLengthConfig
-* Description    : Configures the sequencer length for injected channels
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - Length: The sequencer length. 
-*                    This parameter must be a number between 1 to 4.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
-{
-  u32 tmpreg1 = 0;
-  u32 tmpreg2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_LENGTH(Length));
-  
-  /* Get the old register value */
-  tmpreg1 = ADCx-&gt;JSQR;
-  /* Clear the old injected sequnence lenght JL bits */
-  tmpreg1 &amp;= JSQR_JL_Reset;
-  /* Set the injected sequnence lenght JL bits */
-  tmpreg2 = Length - 1; 
-  tmpreg1 |= tmpreg2 &lt;&lt; 20;
-  /* Store the new register value */
-  ADCx-&gt;JSQR = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_SetInjectedOffset
-* Description    : Set the injected channels conversion value offset
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_InjectedChannel: the ADC injected channel to set its
-*                    offset. 
-*                    This parameter can be one of the following values:
-*                       - ADC_InjectedChannel_1: Injected Channel1 selected
-*                       - ADC_InjectedChannel_2: Injected Channel2 selected
-*                       - ADC_InjectedChannel_3: Injected Channel3 selected
-*                       - ADC_InjectedChannel_4: Injected Channel4 selected
-*                  - Offset: the offset value for the selected ADC injected channel
-*                    This parameter must be a 12bit value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
-  assert_param(IS_ADC_OFFSET(Offset));  
-
-  /* Set the selected injected channel data offset */
-  *((vu32 *)((*(u32*)&amp;ADCx) + ADC_InjectedChannel)) = (u32)Offset;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetInjectedConversionValue
-* Description    : Returns the ADC injected channel conversion result
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_InjectedChannel: the converted ADC injected channel.
-*                    This parameter can be one of the following values:
-*                       - ADC_InjectedChannel_1: Injected Channel1 selected
-*                       - ADC_InjectedChannel_2: Injected Channel2 selected
-*                       - ADC_InjectedChannel_3: Injected Channel3 selected
-*                       - ADC_InjectedChannel_4: Injected Channel4 selected
-* Output         : None
-* Return         : The Data conversion value.
-*******************************************************************************/
-u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
-
-  /* Returns the selected injected channel conversion data value */
-  return (u16) (*(vu32*) (((*(u32*)&amp;ADCx) + ADC_InjectedChannel + JDR_Offset)));
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AnalogWatchdogCmd
-* Description    : Enables or disables the analog watchdog on single/all regular
-*                  or injected channels
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_AnalogWatchdog: the ADC analog watchdog configuration.
-*                    This parameter can be one of the following values:
-*                       - ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on
-*                         a single regular channel
-*                       - ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on
-*                         a single injected channel
-*                       - ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog 
-*                         watchdog on a single regular or injected channel
-*                       - ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on
-*                         all regular channel
-*                       - ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on
-*                         all injected channel
-*                       - ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog
-*                         on all regular and injected channels
-*                       - ADC_AnalogWatchdog_None: No channel guarded by the
-*                         analog watchdog
-* Output         : None
-* Return         : None	  
-*******************************************************************************/
-void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
-
-  /* Get the old register value */
-  tmpreg = ADCx-&gt;CR1;
-  /* Clear AWDEN, AWDENJ and AWDSGL bits */
-  tmpreg &amp;= CR1_AWDMode_Reset;
-  /* Set the analog watchdog enable mode */
-  tmpreg |= ADC_AnalogWatchdog;
-  /* Store the new register value */
-  ADCx-&gt;CR1 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AnalogWatchdogThresholdsConfig
-* Description    : Configures the high and low thresholds of the analog watchdog.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - HighThreshold: the ADC analog watchdog High threshold value.
-*                    This parameter must be a 12bit value.
-*                  - LowThreshold: the ADC analog watchdog Low threshold value.
-*                    This parameter must be a 12bit value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
-                                        u16 LowThreshold)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_THRESHOLD(HighThreshold));
-  assert_param(IS_ADC_THRESHOLD(LowThreshold));
-
-  /* Set the ADCx high threshold */
-  ADCx-&gt;HTR = HighThreshold;
-  /* Set the ADCx low threshold */
-  ADCx-&gt;LTR = LowThreshold;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_AnalogWatchdogSingleChannelConfig
-* Description    : Configures the analog watchdog guarded single channel
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_Channel: the ADC channel to configure for the analog
-*                    watchdog. 
-*                    This parameter can be one of the following values:
-*                       - ADC_Channel_0: ADC Channel0 selected
-*                       - ADC_Channel_1: ADC Channel1 selected
-*                       - ADC_Channel_2: ADC Channel2 selected
-*                       - ADC_Channel_3: ADC Channel3 selected
-*                       - ADC_Channel_4: ADC Channel4 selected
-*                       - ADC_Channel_5: ADC Channel5 selected
-*                       - ADC_Channel_6: ADC Channel6 selected
-*                       - ADC_Channel_7: ADC Channel7 selected
-*                       - ADC_Channel_8: ADC Channel8 selected
-*                       - ADC_Channel_9: ADC Channel9 selected
-*                       - ADC_Channel_10: ADC Channel10 selected
-*                       - ADC_Channel_11: ADC Channel11 selected
-*                       - ADC_Channel_12: ADC Channel12 selected
-*                       - ADC_Channel_13: ADC Channel13 selected
-*                       - ADC_Channel_14: ADC Channel14 selected
-*                       - ADC_Channel_15: ADC Channel15 selected
-*                       - ADC_Channel_16: ADC Channel16 selected
-*                       - ADC_Channel_17: ADC Channel17 selected
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-
-  /* Get the old register value */
-  tmpreg = ADCx-&gt;CR1;
-  /* Clear the Analog watchdog channel select bits */
-  tmpreg &amp;= CR1_AWDCH_Reset;
-  /* Set the Analog watchdog channel */
-  tmpreg |= ADC_Channel;
-  /* Store the new register value */
-  ADCx-&gt;CR1 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_TempSensorVrefintCmd
-* Description    : Enables or disables the temperature sensor and Vrefint channel.
-* Input          : - NewState: new state of the temperature sensor.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_TempSensorVrefintCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the temperature sensor and Vrefint channel*/
-    ADC1-&gt;CR2 |= CR2_TSVREFE_Set;
-  }
-  else
-  {
-    /* Disable the temperature sensor and Vrefint channel*/
-    ADC1-&gt;CR2 &amp;= CR2_TSVREFE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetFlagStatus
-* Description    : Checks whether the specified ADC flag is set or not.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_FLAG: specifies the flag to check. 
-*                    This parameter can be one of the following values:
-*                       - ADC_FLAG_AWD: Analog watchdog flag
-*                       - ADC_FLAG_EOC: End of conversion flag
-*                       - ADC_FLAG_JEOC: End of injected group conversion flag
-*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
-*                       - ADC_FLAG_STRT: Start of regular group conversion flag
-* Output         : None
-* Return         : The new state of ADC_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
-
-  /* Check the status of the specified ADC flag */
-  if ((ADCx-&gt;SR &amp; ADC_FLAG) != (u8)RESET)
-  {
-    /* ADC_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* ADC_FLAG is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the ADC_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ClearFlag
-* Description    : Clears the ADCx's pending flags.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_FLAG: specifies the flag to clear. 
-*                    This parameter can be any combination of the following values:
-*                       - ADC_FLAG_AWD: Analog watchdog flag
-*                       - ADC_FLAG_EOC: End of conversion flag
-*                       - ADC_FLAG_JEOC: End of injected group conversion flag
-*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
-*                       - ADC_FLAG_STRT: Start of regular group conversion flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
-
-  /* Clear the selected ADC flags */
-  ADCx-&gt;SR = ~(u32)ADC_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_GetITStatus
-* Description    : Checks whether the specified ADC interrupt has occurred or not.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_IT: specifies the ADC interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - ADC_IT_EOC: End of conversion interrupt mask
-*                       - ADC_IT_AWD: Analog watchdog interrupt mask
-*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
-* Output         : None
-* Return         : The new state of ADC_IT (SET or RESET).
-*******************************************************************************/
-ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 itmask = 0, enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_GET_IT(ADC_IT));
-
-  /* Get the ADC IT index */
-  itmask = ADC_IT &gt;&gt; 8;
-
-  /* Get the ADC_IT enable bit status */
-  enablestatus = (ADCx-&gt;CR1 &amp; (u8)ADC_IT) ;
-
-  /* Check the status of the specified ADC interrupt */
-  if (((ADCx-&gt;SR &amp; itmask) != (u32)RESET) &amp;&amp; enablestatus)
-  {
-    /* ADC_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* ADC_IT is reset */
-    bitstatus = RESET;
-  }
-
-  /* Return the ADC_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : ADC_ClearITPendingBit
-* Description    : Clears the ADCx&#146;s interrupt pending bits.
-* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-*                  - ADC_IT: specifies the ADC interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - ADC_IT_EOC: End of conversion interrupt mask
-*                       - ADC_IT_AWD: Analog watchdog interrupt mask
-*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
-{
-  u8 itmask = 0;
-
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_IT(ADC_IT));
-
-  /* Get the ADC IT index */
-  itmask = (u8)(ADC_IT &gt;&gt; 8);
-
-  /* Clear the selected ADC interrupt pending bits */
-  ADCx-&gt;SR = ~(u32)itmask;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_adc.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the ADC firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_adc.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ADC DISCNUM mask */
+#define CR1_DISCNUM_Reset           ((u32)0xFFFF1FFF)
+
+/* ADC DISCEN mask */
+#define CR1_DISCEN_Set              ((u32)0x00000800)
+#define CR1_DISCEN_Reset            ((u32)0xFFFFF7FF)
+
+/* ADC JAUTO mask */
+#define CR1_JAUTO_Set               ((u32)0x00000400)
+#define CR1_JAUTO_Reset             ((u32)0xFFFFFBFF)
+
+/* ADC JDISCEN mask */
+#define CR1_JDISCEN_Set             ((u32)0x00001000)
+#define CR1_JDISCEN_Reset           ((u32)0xFFFFEFFF)
+
+/* ADC AWDCH mask */
+#define CR1_AWDCH_Reset             ((u32)0xFFFFFFE0)
+
+/* ADC Analog watchdog enable mode mask */
+#define CR1_AWDMode_Reset           ((u32)0xFF3FFDFF)
+
+/* CR1 register Mask */
+#define CR1_CLEAR_Mask              ((u32)0xFFF0FEFF)
+
+/* ADC ADON mask */
+#define CR2_ADON_Set                ((u32)0x00000001)
+#define CR2_ADON_Reset              ((u32)0xFFFFFFFE)
+
+/* ADC DMA mask */
+#define CR2_DMA_Set                 ((u32)0x00000100)
+#define CR2_DMA_Reset               ((u32)0xFFFFFEFF)
+
+/* ADC RSTCAL mask */
+#define CR2_RSTCAL_Set              ((u32)0x00000008)
+
+/* ADC CAL mask */
+#define CR2_CAL_Set                 ((u32)0x00000004)
+
+/* ADC SWSTART mask */
+#define CR2_SWSTART_Set             ((u32)0x00400000)
+
+/* ADC EXTTRIG mask */
+#define CR2_EXTTRIG_Set             ((u32)0x00100000)
+#define CR2_EXTTRIG_Reset           ((u32)0xFFEFFFFF)
+
+/* ADC Software start mask */
+#define CR2_EXTTRIG_SWSTART_Set     ((u32)0x00500000)
+#define CR2_EXTTRIG_SWSTART_Reset   ((u32)0xFFAFFFFF)
+
+/* ADC JEXTSEL mask */
+#define CR2_JEXTSEL_Reset           ((u32)0xFFFF8FFF)
+
+/* ADC JEXTTRIG mask */
+#define CR2_JEXTTRIG_Set            ((u32)0x00008000)
+#define CR2_JEXTTRIG_Reset          ((u32)0xFFFF7FFF)
+
+/* ADC JSWSTART mask */
+#define CR2_JSWSTART_Set            ((u32)0x00200000)
+
+/* ADC injected software start mask */
+#define CR2_JEXTTRIG_JSWSTART_Set   ((u32)0x00208000)
+#define CR2_JEXTTRIG_JSWSTART_Reset ((u32)0xFFDF7FFF)
+
+/* ADC TSPD mask */
+#define CR2_TSVREFE_Set             ((u32)0x00800000)
+#define CR2_TSVREFE_Reset           ((u32)0xFF7FFFFF)
+
+/* CR2 register Mask */
+#define CR2_CLEAR_Mask              ((u32)0xFFF1F7FD)
+
+/* ADC SQx mask */
+#define SQR3_SQ_Set                 ((u32)0x0000001F)
+#define SQR2_SQ_Set                 ((u32)0x0000001F)
+#define SQR1_SQ_Set                 ((u32)0x0000001F)
+
+/* SQR1 register Mask */
+#define SQR1_CLEAR_Mask             ((u32)0xFF0FFFFF)
+
+/* ADC JSQx mask */
+#define JSQR_JSQ_Set                ((u32)0x0000001F)
+
+/* ADC JL mask */
+#define JSQR_JL_Set                 ((u32)0x00300000)
+#define JSQR_JL_Reset               ((u32)0xFFCFFFFF)
+
+/* ADC SMPx mask */
+#define SMPR1_SMP_Set               ((u32)0x00000007)
+#define SMPR2_SMP_Set               ((u32)0x00000007)
+
+/* ADC JDRx registers offset */
+#define JDR_Offset                  ((u8)0x28)
+
+/* ADC1 DR register base address */
+#define DR_ADDRESS                  ((u32)0x4001244C)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : ADC_DeInit
+* Description    : Deinitializes the ADCx peripheral registers to their default
+*                  reset values.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_DeInit(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  switch (*(u32*)&amp;ADCx)
+  {
+    case ADC1_BASE:
+      /* Enable ADC1 reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
+      /* Release ADC1 from reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
+      break;
+    
+    case ADC2_BASE:
+      /* Enable ADC2 reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
+      /* Release ADC2 from reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
+      break;
+      
+    case ADC3_BASE:
+      /* Enable ADC3 reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
+      /* Release ADC3 from reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
+      break; 
+
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_Init
+* Description    : Initializes the ADCx peripheral according to the specified parameters
+*                  in the ADC_InitStruct.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_InitStruct: pointer to an ADC_InitTypeDef structure that
+*                    contains the configuration information for the specified
+*                    ADC peripheral.
+* Output         : None
+* Return         : None
+******************************************************************************/
+void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
+{
+  u32 tmpreg1 = 0;
+  u8 tmpreg2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_MODE(ADC_InitStruct-&gt;ADC_Mode));
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ScanConvMode));
+  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct-&gt;ADC_ContinuousConvMode));  		    
+  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct-&gt;ADC_ExternalTrigConv));   
+  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct-&gt;ADC_DataAlign)); 
+  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct-&gt;ADC_NbrOfChannel));
+
+  /*---------------------------- ADCx CR1 Configuration -----------------*/
+  /* Get the ADCx CR1 value */
+  tmpreg1 = ADCx-&gt;CR1;
+  /* Clear DUALMOD and SCAN bits */
+  tmpreg1 &amp;= CR1_CLEAR_Mask;
+  /* Configure ADCx: Dual mode and scan conversion mode */
+  /* Set DUALMOD bits according to ADC_Mode value */
+  /* Set SCAN bit according to ADC_ScanConvMode value */
+  tmpreg1 |= (u32)(ADC_InitStruct-&gt;ADC_Mode | ((u32)ADC_InitStruct-&gt;ADC_ScanConvMode &lt;&lt; 8));
+  /* Write to ADCx CR1 */
+  ADCx-&gt;CR1 = tmpreg1;
+
+  /*---------------------------- ADCx CR2 Configuration -----------------*/
+  /* Get the ADCx CR2 value */
+  tmpreg1 = ADCx-&gt;CR2;
+  /* Clear CONT, ALIGN and EXTSEL bits */
+  tmpreg1 &amp;= CR2_CLEAR_Mask;
+  /* Configure ADCx: external trigger event and continuous conversion mode */
+  /* Set ALIGN bit according to ADC_DataAlign value */
+  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
+  /* Set CONT bit according to ADC_ContinuousConvMode value */
+  tmpreg1 |= (u32)(ADC_InitStruct-&gt;ADC_DataAlign | ADC_InitStruct-&gt;ADC_ExternalTrigConv |
+            ((u32)ADC_InitStruct-&gt;ADC_ContinuousConvMode &lt;&lt; 1));
+  /* Write to ADCx CR2 */
+  ADCx-&gt;CR2 = tmpreg1;
+
+  /*---------------------------- ADCx SQR1 Configuration -----------------*/
+  /* Get the ADCx SQR1 value */
+  tmpreg1 = ADCx-&gt;SQR1;
+  /* Clear L bits */
+  tmpreg1 &amp;= SQR1_CLEAR_Mask;
+  /* Configure ADCx: regular channel sequence length */
+  /* Set L bits according to ADC_NbrOfChannel value */
+  tmpreg2 |= (ADC_InitStruct-&gt;ADC_NbrOfChannel - 1);
+  tmpreg1 |= ((u32)tmpreg2 &lt;&lt; 20);
+  /* Write to ADCx SQR1 */
+  ADCx-&gt;SQR1 = tmpreg1;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_StructInit
+* Description    : Fills each ADC_InitStruct member with its default value.
+* Input          : ADC_InitStruct : pointer to an ADC_InitTypeDef structure
+*                  which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
+{
+  /* Reset ADC init structure parameters values */
+  /* Initialize the ADC_Mode member */
+  ADC_InitStruct-&gt;ADC_Mode = ADC_Mode_Independent;
+
+  /* initialize the ADC_ScanConvMode member */
+  ADC_InitStruct-&gt;ADC_ScanConvMode = DISABLE;
+
+  /* Initialize the ADC_ContinuousConvMode member */
+  ADC_InitStruct-&gt;ADC_ContinuousConvMode = DISABLE;
+
+  /* Initialize the ADC_ExternalTrigConv member */
+  ADC_InitStruct-&gt;ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
+
+  /* Initialize the ADC_DataAlign member */
+  ADC_InitStruct-&gt;ADC_DataAlign = ADC_DataAlign_Right;
+
+  /* Initialize the ADC_NbrOfChannel member */
+  ADC_InitStruct-&gt;ADC_NbrOfChannel = 1;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_Cmd
+* Description    : Enables or disables the specified ADC peripheral.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the ADCx peripheral. This parameter
+*                    can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the ADON bit to wake up the ADC from power down mode */
+    ADCx-&gt;CR2 |= CR2_ADON_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC peripheral */
+    ADCx-&gt;CR2 &amp;= CR2_ADON_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_DMACmd
+* Description    : Enables or disables the specified ADC DMA request.
+* Input          : - ADCx: where x can be 1 or 3 to select the ADC peripheral.
+*                    Note: ADC2 hasn't a DMA capability.
+*                  - NewState: new state of the selected ADC DMA transfer.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_DMA_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC DMA request */
+    ADCx-&gt;CR2 |= CR2_DMA_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC DMA request */
+    ADCx-&gt;CR2 &amp;= CR2_DMA_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_ITConfig
+* Description    : Enables or disables the specified ADC interrupts.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_IT: specifies the ADC interrupt sources to be enabled
+*                    or disabled. 
+*                    This parameter can be any combination of the following values:
+*                       - ADC_IT_EOC: End of conversion interrupt mask
+*                       - ADC_IT_AWD: Analog watchdog interrupt mask
+*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
+*                  - NewState: new state of the specified ADC interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
+{
+  u8 itmask = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_ADC_IT(ADC_IT));
+
+  /* Get the ADC IT index */
+  itmask = (u8)ADC_IT;
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC interrupts */
+    ADCx-&gt;CR1 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected ADC interrupts */
+    ADCx-&gt;CR1 &amp;= (~(u32)itmask);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_ResetCalibration
+* Description    : Resets the selected ADC calibration registers.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_ResetCalibration(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  /* Resets the selected ADC calibartion registers */  
+  ADCx-&gt;CR2 |= CR2_RSTCAL_Set;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetResetCalibrationStatus
+* Description    : Gets the selected ADC reset calibration registers status.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : The new state of ADC reset calibration registers (SET or RESET).
+*******************************************************************************/
+FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  /* Check the status of RSTCAL bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_RSTCAL_Set) != (u32)RESET)
+  {
+    /* RSTCAL bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* RSTCAL bit is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the RSTCAL bit status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_StartCalibration
+* Description    : Starts the selected ADC calibration process.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_StartCalibration(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  /* Enable the selected ADC calibration process */  
+  ADCx-&gt;CR2 |= CR2_CAL_Set;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetCalibrationStatus
+* Description    : Gets the selected ADC calibration status.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : The new state of ADC calibration (SET or RESET).
+*******************************************************************************/
+FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  /* Check the status of CAL bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_CAL_Set) != (u32)RESET)
+  {
+    /* CAL bit is set: calibration on going */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CAL bit is reset: end of calibration */
+    bitstatus = RESET;
+  }
+
+  /* Return the CAL bit status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_SoftwareStartConvCmd
+* Description    : Enables or disables the selected ADC software start conversion .
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the selected ADC software start conversion.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion on external event and start the selected
+       ADC conversion */
+    ADCx-&gt;CR2 |= CR2_EXTTRIG_SWSTART_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event and stop the selected
+       ADC conversion */
+    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_SWSTART_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetSoftwareStartConvStatus
+* Description    : Gets the selected ADC Software start conversion Status.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : The new state of ADC software start conversion (SET or RESET).
+*******************************************************************************/
+FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  /* Check the status of SWSTART bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_SWSTART_Set) != (u32)RESET)
+  {
+    /* SWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SWSTART bit is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the SWSTART bit status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_DiscModeChannelCountConfig
+* Description    : Configures the discontinuous mode for the selected ADC regular
+*                  group channel.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - Number: specifies the discontinuous mode regular channel
+*                    count value. This number must be between 1 and 8.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
+{
+  u32 tmpreg1 = 0;
+  u32 tmpreg2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
+
+  /* Get the old register value */
+  tmpreg1 = ADCx-&gt;CR1;
+  /* Clear the old discontinuous mode channel count */
+  tmpreg1 &amp;= CR1_DISCNUM_Reset;
+  /* Set the discontinuous mode channel count */
+  tmpreg2 = Number - 1;
+  tmpreg1 |= tmpreg2 &lt;&lt; 13;
+  /* Store the new register value */
+  ADCx-&gt;CR1 = tmpreg1;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_DiscModeCmd
+* Description    : Enables or disables the discontinuous mode on regular group
+*                  channel for the specified ADC
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the selected ADC discontinuous mode
+*                    on regular group channel.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC regular discontinuous mode */
+    ADCx-&gt;CR1 |= CR1_DISCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC regular discontinuous mode */
+    ADCx-&gt;CR1 &amp;= CR1_DISCEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_RegularChannelConfig
+* Description    : Configures for the selected ADC regular channel its corresponding
+*                  rank in the sequencer and its sample time.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_Channel: the ADC channel to configure. 
+*                    This parameter can be one of the following values:
+*                       - ADC_Channel_0: ADC Channel0 selected
+*                       - ADC_Channel_1: ADC Channel1 selected
+*                       - ADC_Channel_2: ADC Channel2 selected
+*                       - ADC_Channel_3: ADC Channel3 selected
+*                       - ADC_Channel_4: ADC Channel4 selected
+*                       - ADC_Channel_5: ADC Channel5 selected
+*                       - ADC_Channel_6: ADC Channel6 selected
+*                       - ADC_Channel_7: ADC Channel7 selected
+*                       - ADC_Channel_8: ADC Channel8 selected
+*                       - ADC_Channel_9: ADC Channel9 selected
+*                       - ADC_Channel_10: ADC Channel10 selected
+*                       - ADC_Channel_11: ADC Channel11 selected
+*                       - ADC_Channel_12: ADC Channel12 selected
+*                       - ADC_Channel_13: ADC Channel13 selected
+*                       - ADC_Channel_14: ADC Channel14 selected
+*                       - ADC_Channel_15: ADC Channel15 selected
+*                       - ADC_Channel_16: ADC Channel16 selected
+*                       - ADC_Channel_17: ADC Channel17 selected
+*                  - Rank: The rank in the regular group sequencer. This parameter
+*                    must be between 1 to 16.
+*                  - ADC_SampleTime: The sample time value to be set for the
+*                    selected channel. 
+*                    This parameter can be one of the following values:
+*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
+*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
+*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
+*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
+*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
+*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
+*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
+*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
+{
+  u32 tmpreg1 = 0, tmpreg2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_REGULAR_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+
+  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
+  if (ADC_Channel &gt; ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3 * (ADC_Channel - 10));
+    /* Clear the old discontinuous mode channel count */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * (ADC_Channel - 10));
+    /* Set the discontinuous mode channel count */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
+    /* Clear the old discontinuous mode channel count */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
+    /* Set the discontinuous mode channel count */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR2 = tmpreg1;
+  }
+  /* For Rank 1 to 6 */
+  if (Rank &lt; 7)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SQR3;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR3_SQ_Set &lt;&lt; (5 * (Rank - 1));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 1));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SQR3 = tmpreg1;
+  }
+  /* For Rank 7 to 12 */
+  else if (Rank &lt; 13)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SQR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR2_SQ_Set &lt;&lt; (5 * (Rank - 7));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 7));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SQR2 = tmpreg1;
+  }
+  /* For Rank 13 to 16 */
+  else
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SQR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SQR1_SQ_Set &lt;&lt; (5 * (Rank - 13));
+    /* Clear the old SQx bits for the selected rank */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (Rank - 13));
+    /* Set the SQx bits for the selected rank */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SQR1 = tmpreg1;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_ExternalTrigConvCmd
+* Description    : Enables or disables the ADCx conversion through external trigger.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the selected ADC external trigger
+*                    start of conversion.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion on external event */
+    ADCx-&gt;CR2 |= CR2_EXTTRIG_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event */
+    ADCx-&gt;CR2 &amp;= CR2_EXTTRIG_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetConversionValue
+* Description    : Returns the last ADCx conversion result data for regular channel.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : The Data conversion value.
+*******************************************************************************/
+u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  /* Return the selected ADC conversion value */
+  return (u16) ADCx-&gt;DR;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetDualModeConversionValue
+* Description    : Returns the last ADC1 and ADC2 conversion result data in dual mode.
+* Output         : None
+* Return         : The Data conversion value.
+*******************************************************************************/
+u32 ADC_GetDualModeConversionValue(void)
+{
+  /* Return the dual mode conversion value */
+  return (*(vu32 *) DR_ADDRESS);
+}
+
+/*******************************************************************************
+* Function Name  : ADC_AutoInjectedConvCmd
+* Description    : Enables or disables the selected ADC automatic injected group
+*                  conversion after regular one.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the selected ADC auto injected
+*                    conversion
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC automatic injected group conversion */
+    ADCx-&gt;CR1 |= CR1_JAUTO_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC automatic injected group conversion */
+    ADCx-&gt;CR1 &amp;= CR1_JAUTO_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_InjectedDiscModeCmd
+* Description    : Enables or disables the discontinuous mode for injected group
+*                  channel for the specified ADC
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the selected ADC discontinuous mode
+*                    on injected group channel.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC injected discontinuous mode */
+    ADCx-&gt;CR1 |= CR1_JDISCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC injected discontinuous mode */
+    ADCx-&gt;CR1 &amp;= CR1_JDISCEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_ExternalTrigInjectedConvConfig
+* Description    : Configures the ADCx external trigger for injected channels conversion.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_ExternalTrigInjecConv: specifies the ADC trigger to
+*                    start injected conversion. 
+*                    This parameter can be one of the following values:
+*                       - ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event 
+*                         selected (for ADC1, ADC2 and ADC3)
+*                       - ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture
+*                         compare4 selected (for ADC1, ADC2 and ADC3)
+*                       - ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event
+*                         selected (for ADC1 and ADC2)
+*                       - ADC_External TrigInjecConv_T2_CC1: Timer2 capture
+*                         compare1 selected (for ADC1 and ADC2)
+*                       - ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture
+*                         compare4 selected (for ADC1 and ADC2)
+*                       - ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event
+*                         selected (for ADC1 and ADC2)
+*                       - ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External
+*                         interrupt line 15 or Timer8 capture compare4 event selected
+*                         (for ADC1 and ADC2)                       
+*                       - ADC_External TrigInjecConv_T4_CC3: Timer4 capture
+*                         compare3 selected (for ADC3 only)
+*                       - ADC_External TrigInjecConv_T8_CC2: Timer8 capture
+*                         compare2 selected (for ADC3 only)                         
+*                       - ADC_External TrigInjecConv_T8_CC4: Timer8 capture
+*                         compare4 selected (for ADC3 only)
+*                       - ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event
+*                         selected (for ADC3 only)                         
+*                       - ADC_External TrigInjecConv_T5_CC4: Timer5 capture
+*                         compare4 selected (for ADC3 only)                        
+*                       - ADC_ExternalTrigInjecConv_None: Injected conversion
+*                         started by software and not by external trigger (for 
+*                         ADC1, ADC2 and ADC3)
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
+
+  /* Get the old register value */
+  tmpreg = ADCx-&gt;CR2;
+  /* Clear the old external event selection for injected group */
+  tmpreg &amp;= CR2_JEXTSEL_Reset;
+  /* Set the external event selection for injected group */
+  tmpreg |= ADC_ExternalTrigInjecConv;
+  /* Store the new register value */
+  ADCx-&gt;CR2 = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_ExternalTrigInjectedConvCmd
+* Description    : Enables or disables the ADCx injected channels conversion
+*                  through external trigger
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the selected ADC external trigger
+*                    start of injected conversion.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC external event selection for injected group */
+    ADCx-&gt;CR2 |= CR2_JEXTTRIG_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC external event selection for injected group */
+    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_SoftwareStartInjectedConvCmd
+* Description    : Enables or disables the selected ADC start of the injected 
+*                  channels conversion.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - NewState: new state of the selected ADC software start
+*                    injected conversion.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected ADC conversion for injected group on external event and start the selected
+       ADC injected conversion */
+    ADCx-&gt;CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
+  }
+  else
+  {
+    /* Disable the selected ADC conversion on external event for injected group and stop the selected
+       ADC injected conversion */
+    ADCx-&gt;CR2 &amp;= CR2_JEXTTRIG_JSWSTART_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetSoftwareStartInjectedConvCmdStatus
+* Description    : Gets the selected ADC Software start injected conversion Status.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+* Output         : None
+* Return         : The new state of ADC software start injected conversion (SET or RESET).
+*******************************************************************************/
+FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+
+  /* Check the status of JSWSTART bit */
+  if ((ADCx-&gt;CR2 &amp; CR2_JSWSTART_Set) != (u32)RESET)
+  {
+    /* JSWSTART bit is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* JSWSTART bit is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the JSWSTART bit status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_InjectedChannelConfig
+* Description    : Configures for the selected ADC injected channel its corresponding
+*                  rank in the sequencer and its sample time.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_Channel: the ADC channel to configure. 
+*                    This parameter can be one of the following values:
+*                       - ADC_Channel_0: ADC Channel0 selected
+*                       - ADC_Channel_1: ADC Channel1 selected
+*                       - ADC_Channel_2: ADC Channel2 selected
+*                       - ADC_Channel_3: ADC Channel3 selected
+*                       - ADC_Channel_4: ADC Channel4 selected
+*                       - ADC_Channel_5: ADC Channel5 selected
+*                       - ADC_Channel_6: ADC Channel6 selected
+*                       - ADC_Channel_7: ADC Channel7 selected
+*                       - ADC_Channel_8: ADC Channel8 selected
+*                       - ADC_Channel_9: ADC Channel9 selected
+*                       - ADC_Channel_10: ADC Channel10 selected
+*                       - ADC_Channel_11: ADC Channel11 selected
+*                       - ADC_Channel_12: ADC Channel12 selected
+*                       - ADC_Channel_13: ADC Channel13 selected
+*                       - ADC_Channel_14: ADC Channel14 selected
+*                       - ADC_Channel_15: ADC Channel15 selected
+*                       - ADC_Channel_16: ADC Channel16 selected
+*                       - ADC_Channel_17: ADC Channel17 selected
+*                  - Rank: The rank in the injected group sequencer. This parameter
+*                    must be between 1 to 4.
+*                  - ADC_SampleTime: The sample time value to be set for the
+*                    selected channel. 
+*                    This parameter can be one of the following values:
+*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
+*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
+*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
+*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
+*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
+*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
+*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
+*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
+{
+  u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+  assert_param(IS_ADC_INJECTED_RANK(Rank));
+  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
+
+  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
+  if (ADC_Channel &gt; ADC_Channel_9)
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR1;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR1_SMP_Set &lt;&lt; (3*(ADC_Channel - 10));
+    /* Clear the old discontinuous mode channel count */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3*(ADC_Channel - 10));
+    /* Set the discontinuous mode channel count */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR1 = tmpreg1;
+  }
+  else /* ADC_Channel include in ADC_Channel_[0..9] */
+  {
+    /* Get the old register value */
+    tmpreg1 = ADCx-&gt;SMPR2;
+    /* Calculate the mask to clear */
+    tmpreg2 = SMPR2_SMP_Set &lt;&lt; (3 * ADC_Channel);
+    /* Clear the old discontinuous mode channel count */
+    tmpreg1 &amp;= ~tmpreg2;
+    /* Calculate the mask to set */
+    tmpreg2 = (u32)ADC_SampleTime &lt;&lt; (3 * ADC_Channel);
+    /* Set the discontinuous mode channel count */
+    tmpreg1 |= tmpreg2;
+    /* Store the new register value */
+    ADCx-&gt;SMPR2 = tmpreg1;
+  }
+
+  /* Rank configuration */
+  /* Get the old register value */
+  tmpreg1 = ADCx-&gt;JSQR;
+  /* Get JL value: Number = JL+1 */
+  tmpreg3 =  (tmpreg1 &amp; JSQR_JL_Set)&gt;&gt; 20;
+  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = JSQR_JSQ_Set &lt;&lt; (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
+  /* Clear the old JSQx bits for the selected rank */
+  tmpreg1 &amp;= ~tmpreg2;
+  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
+  tmpreg2 = (u32)ADC_Channel &lt;&lt; (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
+  /* Set the JSQx bits for the selected rank */
+  tmpreg1 |= tmpreg2;
+  /* Store the new register value */
+  ADCx-&gt;JSQR = tmpreg1;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_InjectedSequencerLengthConfig
+* Description    : Configures the sequencer length for injected channels
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - Length: The sequencer length. 
+*                    This parameter must be a number between 1 to 4.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
+{
+  u32 tmpreg1 = 0;
+  u32 tmpreg2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_LENGTH(Length));
+  
+  /* Get the old register value */
+  tmpreg1 = ADCx-&gt;JSQR;
+  /* Clear the old injected sequnence lenght JL bits */
+  tmpreg1 &amp;= JSQR_JL_Reset;
+  /* Set the injected sequnence lenght JL bits */
+  tmpreg2 = Length - 1; 
+  tmpreg1 |= tmpreg2 &lt;&lt; 20;
+  /* Store the new register value */
+  ADCx-&gt;JSQR = tmpreg1;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_SetInjectedOffset
+* Description    : Set the injected channels conversion value offset
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_InjectedChannel: the ADC injected channel to set its
+*                    offset. 
+*                    This parameter can be one of the following values:
+*                       - ADC_InjectedChannel_1: Injected Channel1 selected
+*                       - ADC_InjectedChannel_2: Injected Channel2 selected
+*                       - ADC_InjectedChannel_3: Injected Channel3 selected
+*                       - ADC_InjectedChannel_4: Injected Channel4 selected
+*                  - Offset: the offset value for the selected ADC injected channel
+*                    This parameter must be a 12bit value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+  assert_param(IS_ADC_OFFSET(Offset));  
+
+  /* Set the selected injected channel data offset */
+  *((vu32 *)((*(u32*)&amp;ADCx) + ADC_InjectedChannel)) = (u32)Offset;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetInjectedConversionValue
+* Description    : Returns the ADC injected channel conversion result
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_InjectedChannel: the converted ADC injected channel.
+*                    This parameter can be one of the following values:
+*                       - ADC_InjectedChannel_1: Injected Channel1 selected
+*                       - ADC_InjectedChannel_2: Injected Channel2 selected
+*                       - ADC_InjectedChannel_3: Injected Channel3 selected
+*                       - ADC_InjectedChannel_4: Injected Channel4 selected
+* Output         : None
+* Return         : The Data conversion value.
+*******************************************************************************/
+u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
+
+  /* Returns the selected injected channel conversion data value */
+  return (u16) (*(vu32*) (((*(u32*)&amp;ADCx) + ADC_InjectedChannel + JDR_Offset)));
+}
+
+/*******************************************************************************
+* Function Name  : ADC_AnalogWatchdogCmd
+* Description    : Enables or disables the analog watchdog on single/all regular
+*                  or injected channels
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_AnalogWatchdog: the ADC analog watchdog configuration.
+*                    This parameter can be one of the following values:
+*                       - ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on
+*                         a single regular channel
+*                       - ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on
+*                         a single injected channel
+*                       - ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog 
+*                         watchdog on a single regular or injected channel
+*                       - ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on
+*                         all regular channel
+*                       - ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on
+*                         all injected channel
+*                       - ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog
+*                         on all regular and injected channels
+*                       - ADC_AnalogWatchdog_None: No channel guarded by the
+*                         analog watchdog
+* Output         : None
+* Return         : None	  
+*******************************************************************************/
+void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
+
+  /* Get the old register value */
+  tmpreg = ADCx-&gt;CR1;
+  /* Clear AWDEN, AWDENJ and AWDSGL bits */
+  tmpreg &amp;= CR1_AWDMode_Reset;
+  /* Set the analog watchdog enable mode */
+  tmpreg |= ADC_AnalogWatchdog;
+  /* Store the new register value */
+  ADCx-&gt;CR1 = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_AnalogWatchdogThresholdsConfig
+* Description    : Configures the high and low thresholds of the analog watchdog.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - HighThreshold: the ADC analog watchdog High threshold value.
+*                    This parameter must be a 12bit value.
+*                  - LowThreshold: the ADC analog watchdog Low threshold value.
+*                    This parameter must be a 12bit value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
+                                        u16 LowThreshold)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_THRESHOLD(HighThreshold));
+  assert_param(IS_ADC_THRESHOLD(LowThreshold));
+
+  /* Set the ADCx high threshold */
+  ADCx-&gt;HTR = HighThreshold;
+  /* Set the ADCx low threshold */
+  ADCx-&gt;LTR = LowThreshold;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_AnalogWatchdogSingleChannelConfig
+* Description    : Configures the analog watchdog guarded single channel
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_Channel: the ADC channel to configure for the analog
+*                    watchdog. 
+*                    This parameter can be one of the following values:
+*                       - ADC_Channel_0: ADC Channel0 selected
+*                       - ADC_Channel_1: ADC Channel1 selected
+*                       - ADC_Channel_2: ADC Channel2 selected
+*                       - ADC_Channel_3: ADC Channel3 selected
+*                       - ADC_Channel_4: ADC Channel4 selected
+*                       - ADC_Channel_5: ADC Channel5 selected
+*                       - ADC_Channel_6: ADC Channel6 selected
+*                       - ADC_Channel_7: ADC Channel7 selected
+*                       - ADC_Channel_8: ADC Channel8 selected
+*                       - ADC_Channel_9: ADC Channel9 selected
+*                       - ADC_Channel_10: ADC Channel10 selected
+*                       - ADC_Channel_11: ADC Channel11 selected
+*                       - ADC_Channel_12: ADC Channel12 selected
+*                       - ADC_Channel_13: ADC Channel13 selected
+*                       - ADC_Channel_14: ADC Channel14 selected
+*                       - ADC_Channel_15: ADC Channel15 selected
+*                       - ADC_Channel_16: ADC Channel16 selected
+*                       - ADC_Channel_17: ADC Channel17 selected
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CHANNEL(ADC_Channel));
+
+  /* Get the old register value */
+  tmpreg = ADCx-&gt;CR1;
+  /* Clear the Analog watchdog channel select bits */
+  tmpreg &amp;= CR1_AWDCH_Reset;
+  /* Set the Analog watchdog channel */
+  tmpreg |= ADC_Channel;
+  /* Store the new register value */
+  ADCx-&gt;CR1 = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_TempSensorVrefintCmd
+* Description    : Enables or disables the temperature sensor and Vrefint channel.
+* Input          : - NewState: new state of the temperature sensor.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_TempSensorVrefintCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the temperature sensor and Vrefint channel*/
+    ADC1-&gt;CR2 |= CR2_TSVREFE_Set;
+  }
+  else
+  {
+    /* Disable the temperature sensor and Vrefint channel*/
+    ADC1-&gt;CR2 &amp;= CR2_TSVREFE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetFlagStatus
+* Description    : Checks whether the specified ADC flag is set or not.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_FLAG: specifies the flag to check. 
+*                    This parameter can be one of the following values:
+*                       - ADC_FLAG_AWD: Analog watchdog flag
+*                       - ADC_FLAG_EOC: End of conversion flag
+*                       - ADC_FLAG_JEOC: End of injected group conversion flag
+*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
+*                       - ADC_FLAG_STRT: Start of regular group conversion flag
+* Output         : None
+* Return         : The new state of ADC_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
+
+  /* Check the status of the specified ADC flag */
+  if ((ADCx-&gt;SR &amp; ADC_FLAG) != (u8)RESET)
+  {
+    /* ADC_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_FLAG is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the ADC_FLAG status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_ClearFlag
+* Description    : Clears the ADCx's pending flags.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_FLAG: specifies the flag to clear. 
+*                    This parameter can be any combination of the following values:
+*                       - ADC_FLAG_AWD: Analog watchdog flag
+*                       - ADC_FLAG_EOC: End of conversion flag
+*                       - ADC_FLAG_JEOC: End of injected group conversion flag
+*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
+*                       - ADC_FLAG_STRT: Start of regular group conversion flag
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
+
+  /* Clear the selected ADC flags */
+  ADCx-&gt;SR = ~(u32)ADC_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_GetITStatus
+* Description    : Checks whether the specified ADC interrupt has occurred or not.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_IT: specifies the ADC interrupt source to check. 
+*                    This parameter can be one of the following values:
+*                       - ADC_IT_EOC: End of conversion interrupt mask
+*                       - ADC_IT_AWD: Analog watchdog interrupt mask
+*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
+* Output         : None
+* Return         : The new state of ADC_IT (SET or RESET).
+*******************************************************************************/
+ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
+{
+  ITStatus bitstatus = RESET;
+  u32 itmask = 0, enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_GET_IT(ADC_IT));
+
+  /* Get the ADC IT index */
+  itmask = ADC_IT &gt;&gt; 8;
+
+  /* Get the ADC_IT enable bit status */
+  enablestatus = (ADCx-&gt;CR1 &amp; (u8)ADC_IT) ;
+
+  /* Check the status of the specified ADC interrupt */
+  if (((ADCx-&gt;SR &amp; itmask) != (u32)RESET) &amp;&amp; enablestatus)
+  {
+    /* ADC_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* ADC_IT is reset */
+    bitstatus = RESET;
+  }
+
+  /* Return the ADC_IT status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : ADC_ClearITPendingBit
+* Description    : Clears the ADCx's interrupt pending bits.
+* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
+*                  - ADC_IT: specifies the ADC interrupt pending bit to clear.
+*                    This parameter can be any combination of the following values:
+*                       - ADC_IT_EOC: End of conversion interrupt mask
+*                       - ADC_IT_AWD: Analog watchdog interrupt mask
+*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
+{
+  u8 itmask = 0;
+
+  /* Check the parameters */
+  assert_param(IS_ADC_ALL_PERIPH(ADCx));
+  assert_param(IS_ADC_IT(ADC_IT));
+
+  /* Get the ADC IT index */
+  itmask = (u8)(ADC_IT &gt;&gt; 8);
+
+  /* Clear the selected ADC interrupt pending bits */
+  ADCx-&gt;SR = ~(u32)itmask;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_bkp.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,272 +1,272 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_bkp.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the BKP firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_bkp.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ------------ BKP registers bit address in the alias region ----------- */
-#define BKP_OFFSET        (BKP_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-/* Alias word address of TPAL bit */
-#define CR_OFFSET         (BKP_OFFSET + 0x30)
-#define TPAL_BitNumber    0x01
-#define CR_TPAL_BB        (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPAL_BitNumber * 4))
-
-/* Alias word address of TPE bit */
-#define TPE_BitNumber     0x00
-#define CR_TPE_BB         (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPE_BitNumber * 4))
-
-/* --- CSR Register ---*/
-/* Alias word address of TPIE bit */
-#define CSR_OFFSET        (BKP_OFFSET + 0x34)
-#define TPIE_BitNumber    0x02
-#define CSR_TPIE_BB       (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TPIE_BitNumber * 4))
-
-/* Alias word address of TIF bit */
-#define TIF_BitNumber     0x09
-#define CSR_TIF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TIF_BitNumber * 4))
-
-/* Alias word address of TEF bit */
-#define TEF_BitNumber     0x08
-#define CSR_TEF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEF_BitNumber * 4))
-
-
-/* ---------------------- BKP registers bit mask ------------------------ */
-/* RTCCR register bit mask */
-#define RTCCR_CAL_Mask    ((u16)0xFF80)
-#define RTCCR_Mask        ((u16)0xFC7F)
-
-/* CSR register bit mask */
-#define CSR_CTE_Set       ((u16)0x0001)
-#define CSR_CTI_Set       ((u16)0x0002)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : BKP_DeInit
-* Description    : Deinitializes the BKP peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_DeInit(void)
-{
-  RCC_BackupResetCmd(ENABLE);
-  RCC_BackupResetCmd(DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : BKP_TamperPinLevelConfig
-* Description    : Configures the Tamper Pin active level.
-* Input          : - BKP_TamperPinLevel: specifies the Tamper Pin active level.
-*                    This parameter can be one of the following values:
-*                       - BKP_TamperPinLevel_High: Tamper pin active on high level
-*                       - BKP_TamperPinLevel_Low: Tamper pin active on low level
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_TamperPinLevelConfig(u16 BKP_TamperPinLevel)
-{
-  /* Check the parameters */
-  assert_param(IS_BKP_TAMPER_PIN_LEVEL(BKP_TamperPinLevel));
-
-  *(vu32 *) CR_TPAL_BB = BKP_TamperPinLevel;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_TamperPinCmd
-* Description    : Enables or disables the Tamper Pin activation.
-* Input          : - NewState: new state of the Tamper Pin activation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_TamperPinCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_TPE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ITConfig
-* Description    : Enables or disables the Tamper Pin Interrupt.
-* Input          : - NewState: new state of the Tamper Pin Interrupt.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_ITConfig(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CSR_TPIE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_RTCOutputConfig
-* Description    : Select the RTC output source to output on the Tamper pin.
-* Input          : - BKP_RTCOutputSource: specifies the RTC output source.
-*                    This parameter can be one of the following values:
-*                       - BKP_RTCOutputSource_None: no RTC output on the Tamper pin.
-*                       - BKP_RTCOutputSource_CalibClock: output the RTC clock
-*                         with frequency divided by 64 on the Tamper pin.
-*                       - BKP_RTCOutputSource_Alarm: output the RTC Alarm pulse 
-*                         signal on the Tamper pin.
-*                       - BKP_RTCOutputSource_Second: output the RTC Second pulse 
-*                         signal on the Tamper pin.  
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_RTCOutputConfig(u16 BKP_RTCOutputSource)
-{
-  u16 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
-
-  tmpreg = BKP-&gt;RTCCR;
-
-  /* Clear CCO, ASOE and ASOS bits */
-  tmpreg &amp;= RTCCR_Mask;
-  
-  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
-  tmpreg |= BKP_RTCOutputSource;
-
-  /* Store the new value */
-  BKP-&gt;RTCCR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_SetRTCCalibrationValue
-* Description    : Sets RTC Clock Calibration value.
-* Input          : - CalibrationValue: specifies the RTC Clock Calibration value.
-*                    This parameter must be a number between 0 and 0x7F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_SetRTCCalibrationValue(u8 CalibrationValue)
-{
-  u16 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_BKP_CALIBRATION_VALUE(CalibrationValue));
-
-  tmpreg = BKP-&gt;RTCCR;
-
-  /* Clear CAL[6:0] bits */
-  tmpreg &amp;= RTCCR_CAL_Mask;
-
-  /* Set CAL[6:0] bits according to CalibrationValue value */
-  tmpreg |= CalibrationValue;
-
-  /* Store the new value */
-  BKP-&gt;RTCCR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_WriteBackupRegister
-* Description    : Writes user data to the specified Data Backup Register.
-* Input          : - BKP_DR: specifies the Data Backup Register.
-*                    This parameter can be BKP_DRx where x:[1, 42]
-*                  - Data: data to write
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_WriteBackupRegister(u16 BKP_DR, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_BKP_DR(BKP_DR));
-
-  *(vu16 *) (BKP_BASE + BKP_DR) = Data;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ReadBackupRegister
-* Description    : Reads data from the specified Data Backup Register.
-* Input          : - BKP_DR: specifies the Data Backup Register.
-*                    This parameter can be BKP_DRx where x:[1, 42]
-* Output         : None
-* Return         : The content of the specified Data Backup Register
-*******************************************************************************/
-u16 BKP_ReadBackupRegister(u16 BKP_DR)
-{
-  /* Check the parameters */
-  assert_param(IS_BKP_DR(BKP_DR));
-
-  return (*(vu16 *) (BKP_BASE + BKP_DR));
-}
-
-/*******************************************************************************
-* Function Name  : BKP_GetFlagStatus
-* Description    : Checks whether the Tamper Pin Event flag is set or not.
-* Input          : None
-* Output         : None
-* Return         : The new state of the Tamper Pin Event flag (SET or RESET).
-*******************************************************************************/
-FlagStatus BKP_GetFlagStatus(void)
-{
-  return (FlagStatus)(*(vu32 *) CSR_TEF_BB);
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ClearFlag
-* Description    : Clears Tamper Pin Event pending flag.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_ClearFlag(void)
-{
-  /* Set CTE bit to clear Tamper Pin Event flag */
-  BKP-&gt;CSR |= CSR_CTE_Set;
-}
-
-/*******************************************************************************
-* Function Name  : BKP_GetITStatus
-* Description    : Checks whether the Tamper Pin Interrupt has occurred or not.
-* Input          : None
-* Output         : None
-* Return         : The new state of the Tamper Pin Interrupt (SET or RESET).
-*******************************************************************************/
-ITStatus BKP_GetITStatus(void)
-{
-  return (ITStatus)(*(vu32 *) CSR_TIF_BB);
-}
-
-/*******************************************************************************
-* Function Name  : BKP_ClearITPendingBit
-* Description    : Clears Tamper Pin Interrupt pending bit.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void BKP_ClearITPendingBit(void)
-{
-  /* Set CTI bit to clear Tamper Pin Interrupt pending bit */
-  BKP-&gt;CSR |= CSR_CTI_Set;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_bkp.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the BKP firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_bkp.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ------------ BKP registers bit address in the alias region ----------- */
+#define BKP_OFFSET        (BKP_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+/* Alias word address of TPAL bit */
+#define CR_OFFSET         (BKP_OFFSET + 0x30)
+#define TPAL_BitNumber    0x01
+#define CR_TPAL_BB        (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPAL_BitNumber * 4))
+
+/* Alias word address of TPE bit */
+#define TPE_BitNumber     0x00
+#define CR_TPE_BB         (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPE_BitNumber * 4))
+
+/* --- CSR Register ---*/
+/* Alias word address of TPIE bit */
+#define CSR_OFFSET        (BKP_OFFSET + 0x34)
+#define TPIE_BitNumber    0x02
+#define CSR_TPIE_BB       (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TPIE_BitNumber * 4))
+
+/* Alias word address of TIF bit */
+#define TIF_BitNumber     0x09
+#define CSR_TIF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TIF_BitNumber * 4))
+
+/* Alias word address of TEF bit */
+#define TEF_BitNumber     0x08
+#define CSR_TEF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEF_BitNumber * 4))
+
+
+/* ---------------------- BKP registers bit mask ------------------------ */
+/* RTCCR register bit mask */
+#define RTCCR_CAL_Mask    ((u16)0xFF80)
+#define RTCCR_Mask        ((u16)0xFC7F)
+
+/* CSR register bit mask */
+#define CSR_CTE_Set       ((u16)0x0001)
+#define CSR_CTI_Set       ((u16)0x0002)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : BKP_DeInit
+* Description    : Deinitializes the BKP peripheral registers to their default
+*                  reset values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_DeInit(void)
+{
+  RCC_BackupResetCmd(ENABLE);
+  RCC_BackupResetCmd(DISABLE);
+}
+
+/*******************************************************************************
+* Function Name  : BKP_TamperPinLevelConfig
+* Description    : Configures the Tamper Pin active level.
+* Input          : - BKP_TamperPinLevel: specifies the Tamper Pin active level.
+*                    This parameter can be one of the following values:
+*                       - BKP_TamperPinLevel_High: Tamper pin active on high level
+*                       - BKP_TamperPinLevel_Low: Tamper pin active on low level
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_TamperPinLevelConfig(u16 BKP_TamperPinLevel)
+{
+  /* Check the parameters */
+  assert_param(IS_BKP_TAMPER_PIN_LEVEL(BKP_TamperPinLevel));
+
+  *(vu32 *) CR_TPAL_BB = BKP_TamperPinLevel;
+}
+
+/*******************************************************************************
+* Function Name  : BKP_TamperPinCmd
+* Description    : Enables or disables the Tamper Pin activation.
+* Input          : - NewState: new state of the Tamper Pin activation.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_TamperPinCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CR_TPE_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : BKP_ITConfig
+* Description    : Enables or disables the Tamper Pin Interrupt.
+* Input          : - NewState: new state of the Tamper Pin Interrupt.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_ITConfig(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CSR_TPIE_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : BKP_RTCOutputConfig
+* Description    : Select the RTC output source to output on the Tamper pin.
+* Input          : - BKP_RTCOutputSource: specifies the RTC output source.
+*                    This parameter can be one of the following values:
+*                       - BKP_RTCOutputSource_None: no RTC output on the Tamper pin.
+*                       - BKP_RTCOutputSource_CalibClock: output the RTC clock
+*                         with frequency divided by 64 on the Tamper pin.
+*                       - BKP_RTCOutputSource_Alarm: output the RTC Alarm pulse 
+*                         signal on the Tamper pin.
+*                       - BKP_RTCOutputSource_Second: output the RTC Second pulse 
+*                         signal on the Tamper pin.  
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_RTCOutputConfig(u16 BKP_RTCOutputSource)
+{
+  u16 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
+
+  tmpreg = BKP-&gt;RTCCR;
+
+  /* Clear CCO, ASOE and ASOS bits */
+  tmpreg &amp;= RTCCR_Mask;
+  
+  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
+  tmpreg |= BKP_RTCOutputSource;
+
+  /* Store the new value */
+  BKP-&gt;RTCCR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : BKP_SetRTCCalibrationValue
+* Description    : Sets RTC Clock Calibration value.
+* Input          : - CalibrationValue: specifies the RTC Clock Calibration value.
+*                    This parameter must be a number between 0 and 0x7F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_SetRTCCalibrationValue(u8 CalibrationValue)
+{
+  u16 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_BKP_CALIBRATION_VALUE(CalibrationValue));
+
+  tmpreg = BKP-&gt;RTCCR;
+
+  /* Clear CAL[6:0] bits */
+  tmpreg &amp;= RTCCR_CAL_Mask;
+
+  /* Set CAL[6:0] bits according to CalibrationValue value */
+  tmpreg |= CalibrationValue;
+
+  /* Store the new value */
+  BKP-&gt;RTCCR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : BKP_WriteBackupRegister
+* Description    : Writes user data to the specified Data Backup Register.
+* Input          : - BKP_DR: specifies the Data Backup Register.
+*                    This parameter can be BKP_DRx where x:[1, 42]
+*                  - Data: data to write
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_WriteBackupRegister(u16 BKP_DR, u16 Data)
+{
+  /* Check the parameters */
+  assert_param(IS_BKP_DR(BKP_DR));
+
+  *(vu16 *) (BKP_BASE + BKP_DR) = Data;
+}
+
+/*******************************************************************************
+* Function Name  : BKP_ReadBackupRegister
+* Description    : Reads data from the specified Data Backup Register.
+* Input          : - BKP_DR: specifies the Data Backup Register.
+*                    This parameter can be BKP_DRx where x:[1, 42]
+* Output         : None
+* Return         : The content of the specified Data Backup Register
+*******************************************************************************/
+u16 BKP_ReadBackupRegister(u16 BKP_DR)
+{
+  /* Check the parameters */
+  assert_param(IS_BKP_DR(BKP_DR));
+
+  return (*(vu16 *) (BKP_BASE + BKP_DR));
+}
+
+/*******************************************************************************
+* Function Name  : BKP_GetFlagStatus
+* Description    : Checks whether the Tamper Pin Event flag is set or not.
+* Input          : None
+* Output         : None
+* Return         : The new state of the Tamper Pin Event flag (SET or RESET).
+*******************************************************************************/
+FlagStatus BKP_GetFlagStatus(void)
+{
+  return (FlagStatus)(*(vu32 *) CSR_TEF_BB);
+}
+
+/*******************************************************************************
+* Function Name  : BKP_ClearFlag
+* Description    : Clears Tamper Pin Event pending flag.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_ClearFlag(void)
+{
+  /* Set CTE bit to clear Tamper Pin Event flag */
+  BKP-&gt;CSR |= CSR_CTE_Set;
+}
+
+/*******************************************************************************
+* Function Name  : BKP_GetITStatus
+* Description    : Checks whether the Tamper Pin Interrupt has occurred or not.
+* Input          : None
+* Output         : None
+* Return         : The new state of the Tamper Pin Interrupt (SET or RESET).
+*******************************************************************************/
+ITStatus BKP_GetITStatus(void)
+{
+  return (ITStatus)(*(vu32 *) CSR_TIF_BB);
+}
+
+/*******************************************************************************
+* Function Name  : BKP_ClearITPendingBit
+* Description    : Clears Tamper Pin Interrupt pending bit.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void BKP_ClearITPendingBit(void)
+{
+  /* Set CTI bit to clear Tamper Pin Interrupt pending bit */
+  BKP-&gt;CSR |= CSR_CTI_Set;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_can.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,907 +1,907 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_can.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the CAN firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_can.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-
-/* Private define ------------------------------------------------------------*/
-/* CAN Master Control Register bits */
-#define MCR_INRQ     ((u32)0x00000001) /* Initialization request */
-#define MCR_SLEEP    ((u32)0x00000002) /* Sleep mode request */
-#define MCR_TXFP     ((u32)0x00000004) /* Transmit FIFO priority */
-#define MCR_RFLM     ((u32)0x00000008) /* Receive FIFO locked mode */
-#define MCR_NART     ((u32)0x00000010) /* No automatic retransmission */
-#define MCR_AWUM     ((u32)0x00000020) /* Automatic wake up mode */
-#define MCR_ABOM     ((u32)0x00000040) /* Automatic bus-off management */
-#define MCR_TTCM     ((u32)0x00000080) /* time triggered communication */
-
-/* CAN Master Status Register bits */
-#define MSR_INAK     ((u32)0x00000001)    /* Initialization acknowledge */
-#define MSR_WKUI     ((u32)0x00000008)    /* Wake-up interrupt */
-#define MSR_SLAKI    ((u32)0x00000010)    /* Sleep acknowledge interrupt */
-
-/* CAN Transmit Status Register bits */
-#define TSR_RQCP0    ((u32)0x00000001)    /* Request completed mailbox0 */
-#define TSR_TXOK0    ((u32)0x00000002)    /* Transmission OK of mailbox0 */
-#define TSR_ABRQ0    ((u32)0x00000080)    /* Abort request for mailbox0 */
-#define TSR_RQCP1    ((u32)0x00000100)    /* Request completed mailbox1 */
-#define TSR_TXOK1    ((u32)0x00000200)    /* Transmission OK of mailbox1 */
-#define TSR_ABRQ1    ((u32)0x00008000)    /* Abort request for mailbox1 */
-#define TSR_RQCP2    ((u32)0x00010000)    /* Request completed mailbox2 */
-#define TSR_TXOK2    ((u32)0x00020000)    /* Transmission OK of mailbox2 */
-#define TSR_ABRQ2    ((u32)0x00800000)    /* Abort request for mailbox2 */
-#define TSR_TME0     ((u32)0x04000000)    /* Transmit mailbox 0 empty */
-#define TSR_TME1     ((u32)0x08000000)    /* Transmit mailbox 1 empty */
-#define TSR_TME2     ((u32)0x10000000)    /* Transmit mailbox 2 empty */
-
-/* CAN Receive FIFO 0 Register bits */
-#define RF0R_FULL0   ((u32)0x00000008)    /* FIFO 0 full */
-#define RF0R_FOVR0   ((u32)0x00000010)    /* FIFO 0 overrun */
-#define RF0R_RFOM0   ((u32)0x00000020)    /* Release FIFO 0 output mailbox */
-
-/* CAN Receive FIFO 1 Register bits */
-#define RF1R_FULL1   ((u32)0x00000008)    /* FIFO 1 full */
-#define RF1R_FOVR1   ((u32)0x00000010)    /* FIFO 1 overrun */
-#define RF1R_RFOM1   ((u32)0x00000020)    /* Release FIFO 1 output mailbox */
-
-/* CAN Error Status Register bits */
-#define ESR_EWGF     ((u32)0x00000001)    /* Error warning flag */
-#define ESR_EPVF     ((u32)0x00000002)    /* Error passive flag */
-#define ESR_BOFF     ((u32)0x00000004)    /* Bus-off flag */
-
-/* CAN Mailbox Transmit Request */
-#define TMIDxR_TXRQ  ((u32)0x00000001) /* Transmit mailbox request */
-
-/* CAN Filter Master Register bits */
-#define FMR_FINIT    ((u32)0x00000001) /* Filter init mode */
-
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit);
-
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-* Function Name  : CAN_DeInit
-* Description    : Deinitializes the CAN peripheral registers to their default
-*                  reset values.
-* Input          : None.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_DeInit(void)
-{
-  /* Enable CAN reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
-  /* Release CAN from reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Init
-* Description    : Initializes the CAN peripheral according to the specified
-*                  parameters in the CAN_InitStruct.
-* Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
-                   contains the configuration information for the CAN peripheral.
-* Output         : None.
-* Return         : Constant indicates initialization succeed which will be 
-*                  CANINITFAILED or CANINITOK.
-*******************************************************************************/
-u8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct)
-{
-  u8 InitStatus = 0;
-  u16 WaitAck = 0;
-
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TTCM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_ABOM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_AWUM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_NART));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_RFLM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TXFP));
-  assert_param(IS_CAN_MODE(CAN_InitStruct-&gt;CAN_Mode));
-  assert_param(IS_CAN_SJW(CAN_InitStruct-&gt;CAN_SJW));
-  assert_param(IS_CAN_BS1(CAN_InitStruct-&gt;CAN_BS1));
-  assert_param(IS_CAN_BS2(CAN_InitStruct-&gt;CAN_BS2));
-  assert_param(IS_CAN_PRESCALER(CAN_InitStruct-&gt;CAN_Prescaler));
-
-  /* Request initialisation */
-  CAN-&gt;MCR = MCR_INRQ;
-
-  /* ...and check acknowledged */
-  if ((CAN-&gt;MSR &amp; MSR_INAK) == 0)
-  {
-    InitStatus = CANINITFAILED;
-  }
-  else
-  {
-    /* Set the time triggered communication mode */
-    if (CAN_InitStruct-&gt;CAN_TTCM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_TTCM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_TTCM;
-    }
-
-    /* Set the automatic bus-off management */
-    if (CAN_InitStruct-&gt;CAN_ABOM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_ABOM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_ABOM;
-    }
-
-    /* Set the automatic wake-up mode */
-    if (CAN_InitStruct-&gt;CAN_AWUM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_AWUM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_AWUM;
-    }
-
-    /* Set the no automatic retransmission */
-    if (CAN_InitStruct-&gt;CAN_NART == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_NART;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_NART;
-    }
-
-    /* Set the receive FIFO locked mode */
-    if (CAN_InitStruct-&gt;CAN_RFLM == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_RFLM;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_RFLM;
-    }
-
-    /* Set the transmit FIFO priority */
-    if (CAN_InitStruct-&gt;CAN_TXFP == ENABLE)
-    {
-      CAN-&gt;MCR |= MCR_TXFP;
-    }
-    else
-    {
-      CAN-&gt;MCR &amp;= ~MCR_TXFP;
-    }
-
-    /* Set the bit timing register */
-    CAN-&gt;BTR = (u32)((u32)CAN_InitStruct-&gt;CAN_Mode &lt;&lt; 30) | ((u32)CAN_InitStruct-&gt;CAN_SJW &lt;&lt; 24) |
-               ((u32)CAN_InitStruct-&gt;CAN_BS1 &lt;&lt; 16) | ((u32)CAN_InitStruct-&gt;CAN_BS2 &lt;&lt; 20) |
-               ((u32)CAN_InitStruct-&gt;CAN_Prescaler - 1);
-
-    InitStatus = CANINITOK;
-
-    /* Request leave initialisation */
-    CAN-&gt;MCR &amp;= ~MCR_INRQ;
-
-    /* Wait the acknowledge */
-    for(WaitAck = 0x400; WaitAck &gt; 0x0; WaitAck--)
-    {
-    }
-    
-    /* ...and check acknowledged */
-    if ((CAN-&gt;MSR &amp; MSR_INAK) == MSR_INAK)
-    {
-      InitStatus = CANINITFAILED;
-    }
-  }
-
-  /* At this step, return the status of initialization */
-  return InitStatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_FilterInit
-* Description    : Initializes the CAN peripheral according to the specified
-*                  parameters in the CAN_FilterInitStruct.
-* Input          : CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
-*                  structure that contains the configuration information.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
-{
-  u16 FilterNumber_BitPos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct-&gt;CAN_FilterNumber));
-  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct-&gt;CAN_FilterMode));
-  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct-&gt;CAN_FilterScale));
-  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct-&gt;CAN_FilterActivation));
-
-  FilterNumber_BitPos = 
-  (u16)(((u16)0x0001) &lt;&lt; ((u16)CAN_FilterInitStruct-&gt;CAN_FilterNumber));
-
-  /* Initialisation mode for the filter */
-  CAN-&gt;FMR |= FMR_FINIT;
-
-  /* Filter Deactivation */
-  CAN-&gt;FA1R &amp;= ~(u32)FilterNumber_BitPos;
-
-  /* Filter Scale */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_16bit)
-  {
-    /* 16-bit scale for the filter */
-    CAN-&gt;FS1R &amp;= ~(u32)FilterNumber_BitPos;
-
-    /* First 16-bit identifier and First 16-bit mask */
-    /* Or First 16-bit identifier and Second 16-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
-
-    /* Second 16-bit identifier and Second 16-bit mask */
-    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdHigh);
-  }
-  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_32bit)
-  {
-    /* 32-bit scale for the filter */
-    CAN-&gt;FS1R |= FilterNumber_BitPos;
-
-    /* 32-bit identifier or First 32-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdHigh) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
-
-    /* 32-bit mask or Second 32-bit identifier */
-    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
-    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
-        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow);
-
-  }
-
-  /* Filter Mode */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdMask)
-  {
-    /*Id/Mask mode for the filter*/
-    CAN-&gt;FM1R &amp;= ~(u32)FilterNumber_BitPos;
-  }
-  else /* CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdList */
-  {
-    /*Identifier list mode for the filter*/
-    CAN-&gt;FM1R |= (u32)FilterNumber_BitPos;
-  }
-
-  /* Filter FIFO assignment */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
-  {
-    /* FIFO 0 assignation for the filter */
-    CAN-&gt;FFA1R &amp;= ~(u32)FilterNumber_BitPos;
-  }
-  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
-  {
-    /* FIFO 1 assignation for the filter */
-    CAN-&gt;FFA1R |= (u32)FilterNumber_BitPos;
-  }
-  
-  /* Filter activation */
-  if (CAN_FilterInitStruct-&gt;CAN_FilterActivation == ENABLE)
-  {
-    CAN-&gt;FA1R |= FilterNumber_BitPos;
-  }
-
-  /* Leave the initialisation mode for the filter */
-  CAN-&gt;FMR &amp;= ~FMR_FINIT;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_StructInit
-* Description    : Fills each CAN_InitStruct member with its default value.
-* Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
-*                  will be initialized.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
-{
-  /* Reset CAN init structure parameters values */
-
-  /* Initialize the time triggered communication mode */
-  CAN_InitStruct-&gt;CAN_TTCM = DISABLE;
-
-  /* Initialize the automatic bus-off management */
-  CAN_InitStruct-&gt;CAN_ABOM = DISABLE;
-
-  /* Initialize the automatic wake-up mode */
-  CAN_InitStruct-&gt;CAN_AWUM = DISABLE;
-
-  /* Initialize the no automatic retransmission */
-  CAN_InitStruct-&gt;CAN_NART = DISABLE;
-
-  /* Initialize the receive FIFO locked mode */
-  CAN_InitStruct-&gt;CAN_RFLM = DISABLE;
-
-  /* Initialize the transmit FIFO priority */
-  CAN_InitStruct-&gt;CAN_TXFP = DISABLE;
-
-  /* Initialize the CAN_Mode member */
-  CAN_InitStruct-&gt;CAN_Mode = CAN_Mode_Normal;
-
-  /* Initialize the CAN_SJW member */
-  CAN_InitStruct-&gt;CAN_SJW = CAN_SJW_1tq;
-
-  /* Initialize the CAN_BS1 member */
-  CAN_InitStruct-&gt;CAN_BS1 = CAN_BS1_4tq;
-
-  /* Initialize the CAN_BS2 member */
-  CAN_InitStruct-&gt;CAN_BS2 = CAN_BS2_3tq;
-
-  /* Initialize the CAN_Prescaler member */
-  CAN_InitStruct-&gt;CAN_Prescaler = 1;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_ITConfig
-* Description    : Enables or disables the specified CAN interrupts.
-* Input          : - CAN_IT: specifies the CAN interrupt sources to be enabled or
-*                    disabled.
-*                    This parameter can be: CAN_IT_TME, CAN_IT_FMP0, CAN_IT_FF0,
-*                                           CAN_IT_FOV0, CAN_IT_FMP1, CAN_IT_FF1,
-*                                           CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV,
-*                                           CAN_IT_LEC, CAN_IT_ERR, CAN_IT_WKU or
-*                                           CAN_IT_SLK.
-*                  - NewState: new state of the CAN interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_ITConfig(u32 CAN_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ITConfig(CAN_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected CAN interrupt */
-    CAN-&gt;IER |= CAN_IT;
-  }
-  else
-  {
-    /* Disable the selected CAN interrupt */
-    CAN-&gt;IER &amp;= ~CAN_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Transmit
-* Description    : Initiates the transmission of a message.
-* Input          : TxMessage: pointer to a structure which contains CAN Id, CAN
-*                  DLC and CAN datas.
-* Output         : None.
-* Return         : The number of the mailbox that is used for transmission
-*                  or CAN_NO_MB if there is no empty mailbox.
-*******************************************************************************/
-u8 CAN_Transmit(CanTxMsg* TxMessage)
-{
-  u8 TransmitMailbox = 0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_STDID(TxMessage-&gt;StdId));
-  assert_param(IS_CAN_EXTID(TxMessage-&gt;StdId));
-  assert_param(IS_CAN_IDTYPE(TxMessage-&gt;IDE));
-  assert_param(IS_CAN_RTR(TxMessage-&gt;RTR));
-  assert_param(IS_CAN_DLC(TxMessage-&gt;DLC));
-
-  /* Select one empty transmit mailbox */
-  if ((CAN-&gt;TSR&amp;TSR_TME0) == TSR_TME0)
-  {
-    TransmitMailbox = 0;
-  }
-  else if ((CAN-&gt;TSR&amp;TSR_TME1) == TSR_TME1)
-  {
-    TransmitMailbox = 1;
-  }
-  else if ((CAN-&gt;TSR&amp;TSR_TME2) == TSR_TME2)
-  {
-    TransmitMailbox = 2;
-  }
-  else
-  {
-    TransmitMailbox = CAN_NO_MB;
-  }
-
-  if (TransmitMailbox != CAN_NO_MB)
-  {
-    /* Set up the Id */
-    CAN-&gt;sTxMailBox[TransmitMailbox].TIR &amp;= TMIDxR_TXRQ;
-    if (TxMessage-&gt;IDE == CAN_ID_STD)
-    {
-      TxMessage-&gt;StdId &amp;= (u32)0x000007FF;
-      TxMessage-&gt;StdId = TxMessage-&gt;StdId &lt;&lt; 21;
-      
-      CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= (TxMessage-&gt;StdId | TxMessage-&gt;IDE |
-                                               TxMessage-&gt;RTR);
-    }
-    else
-    {
-      TxMessage-&gt;ExtId &amp;= (u32)0x1FFFFFFF;
-      TxMessage-&gt;ExtId &lt;&lt;= 3;
-
-      CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= (TxMessage-&gt;ExtId | TxMessage-&gt;IDE | 
-                                               TxMessage-&gt;RTR);
-    }
-    
-    /* Set up the DLC */
-    TxMessage-&gt;DLC &amp;= (u8)0x0000000F;
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDTR &amp;= (u32)0xFFFFFFF0;
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDTR |= TxMessage-&gt;DLC;
-
-    /* Set up the data field */
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDLR = (((u32)TxMessage-&gt;Data[3] &lt;&lt; 24) | 
-                                             ((u32)TxMessage-&gt;Data[2] &lt;&lt; 16) |
-                                             ((u32)TxMessage-&gt;Data[1] &lt;&lt; 8) | 
-                                             ((u32)TxMessage-&gt;Data[0]));
-    CAN-&gt;sTxMailBox[TransmitMailbox].TDHR = (((u32)TxMessage-&gt;Data[7] &lt;&lt; 24) | 
-                                             ((u32)TxMessage-&gt;Data[6] &lt;&lt; 16) |
-                                             ((u32)TxMessage-&gt;Data[5] &lt;&lt; 8) |
-                                             ((u32)TxMessage-&gt;Data[4]));
-
-    /* Request transmission */
-    CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= TMIDxR_TXRQ;
-  }
-
-  return TransmitMailbox;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_TransmitStatus
-* Description    : Checks the transmission of a message.
-* Input          : TransmitMailbox: the number of the mailbox that is used for
-*                  transmission.
-* Output         : None.
-* Return         : CANTXOK if the CAN driver transmits the message, CANTXFAILED
-*                  in an other case.
-*******************************************************************************/
-u8 CAN_TransmitStatus(u8 TransmitMailbox)
-{
-  /* RQCP, TXOK and TME bits */
-  u8 State = 0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
-
-  switch (TransmitMailbox)
-  {
-    case (0): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP0) &lt;&lt; 2);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK0) &gt;&gt; 0);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME0) &gt;&gt; 26);
-      break;
-    case (1): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP1) &gt;&gt; 6);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK1) &gt;&gt; 8);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME1) &gt;&gt; 27);
-      break;
-    case (2): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP2) &gt;&gt; 14);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK2) &gt;&gt; 16);
-      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME2) &gt;&gt; 28);
-      break;
-    default:
-      State = CANTXFAILED;
-      break;
-  }
-
-  switch (State)
-  {
-      /* transmit pending  */
-    case (0x0): State = CANTXPENDING;
-      break;
-      /* transmit failed  */
-    case (0x5): State = CANTXFAILED;
-      break;
-      /* transmit succedeed  */
-    case (0x7): State = CANTXOK;
-      break;
-    default:
-      State = CANTXFAILED;
-      break;
-  }
-
-  return State;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_CancelTransmit
-* Description    : Cancels a transmit request.
-* Input          : Mailbox number.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_CancelTransmit(u8 Mailbox)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
-
-  /* abort transmission */
-  switch (Mailbox)
-  {
-    case (0): CAN-&gt;TSR |= TSR_ABRQ0;
-      break;
-    case (1): CAN-&gt;TSR |= TSR_ABRQ1;
-      break;
-    case (2): CAN-&gt;TSR |= TSR_ABRQ2;
-      break;
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CAN_FIFORelease
-* Description    : Releases a FIFO.
-* Input          : FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_FIFORelease(u8 FIFONumber)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_FIFO(FIFONumber));
-
-  /* Release FIFO0 */
-  if (FIFONumber == CAN_FIFO0)
-  {
-    CAN-&gt;RF0R = RF0R_RFOM0;
-  }
-  /* Release FIFO1 */
-  else /* FIFONumber == CAN_FIFO1 */
-  {
-    CAN-&gt;RF1R = RF1R_RFOM1;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CAN_MessagePending
-* Description    : Returns the number of pending messages.
-* Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
-* Output         : None.
-* Return         : NbMessage which is the number of pending message.
-*******************************************************************************/
-u8 CAN_MessagePending(u8 FIFONumber)
-{
-  u8 MessagePending=0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_FIFO(FIFONumber));
-
-  if (FIFONumber == CAN_FIFO0)
-  {
-    MessagePending = (u8)(CAN-&gt;RF0R&amp;(u32)0x03);
-  }
-  else if (FIFONumber == CAN_FIFO1)
-  {
-    MessagePending = (u8)(CAN-&gt;RF1R&amp;(u32)0x03);
-  }
-  else
-  {
-    MessagePending = 0;
-  }
-  return MessagePending;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Receive
-* Description    : Receives a message.
-* Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
-* Output         : RxMessage: pointer to a structure which contains CAN Id,
-*                  CAN DLC, CAN datas and FMI number.
-* Return         : None.
-*******************************************************************************/
-void CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_FIFO(FIFONumber));
-
-  /* Get the Id */
-  RxMessage-&gt;IDE = (u8)0x04 &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RIR;
-  if (RxMessage-&gt;IDE == CAN_ID_STD)
-  {
-    RxMessage-&gt;StdId = (u32)0x000007FF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 21);
-  }
-  else
-  {
-    RxMessage-&gt;ExtId = (u32)0x1FFFFFFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 3);
-  }
-  
-  RxMessage-&gt;RTR = (u8)0x02 &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RIR;
-
-  /* Get the DLC */
-  RxMessage-&gt;DLC = (u8)0x0F &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDTR;
-
-  /* Get the FMI */
-  RxMessage-&gt;FMI = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDTR &gt;&gt; 8);
-
-  /* Get the data field */
-  RxMessage-&gt;Data[0] = (u8)0xFF &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDLR;
-  RxMessage-&gt;Data[1] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 8);
-  RxMessage-&gt;Data[2] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 16);
-  RxMessage-&gt;Data[3] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 24);
-
-  RxMessage-&gt;Data[4] = (u8)0xFF &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDHR;
-  RxMessage-&gt;Data[5] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 8);
-  RxMessage-&gt;Data[6] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 16);
-  RxMessage-&gt;Data[7] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 24);
-
-  /* Release the FIFO */
-  CAN_FIFORelease(FIFONumber);
-}
-
-/*******************************************************************************
-* Function Name  : CAN_Sleep
-* Description    : Enters the low power mode.
-* Input          : None.
-* Output         : None.
-* Return         : CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
-*******************************************************************************/
-u8 CAN_Sleep(void)
-{
-  u8 SleepStatus = 0;
-
-  /* Sleep mode entering request */
-  CAN-&gt;MCR |= MCR_SLEEP;
-  SleepStatus = CANSLEEPOK;
-
-  /* Sleep mode status */
-  if ((CAN-&gt;MCR&amp;MCR_SLEEP) == 0)
-  {
-    /* Sleep mode not entered */
-    SleepStatus = CANSLEEPFAILED;
-  }
-
-  /* At this step, sleep mode status */
-  return SleepStatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_WakeUp
-* Description    : Wakes the CAN up.
-* Input          : None.
-* Output         : None.
-* Return         : CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other
-*                  case.
-*******************************************************************************/
-u8 CAN_WakeUp(void)
-{
-  u8 WakeUpStatus = 0;
-
-  /* Wake up request */
-  CAN-&gt;MCR &amp;= ~MCR_SLEEP;
-  WakeUpStatus = CANWAKEUPFAILED;
-
-  /* Sleep mode status */
-  if ((CAN-&gt;MCR&amp;MCR_SLEEP) == 0)
-  {
-    /* Sleep mode exited */
-    WakeUpStatus = CANWAKEUPOK;
-  }
-
-  /* At this step, sleep mode status */
-  return WakeUpStatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_GetFlagStatus
-* Description    : Checks whether the specified CAN flag is set or not.
-* Input          : CAN_FLAG: specifies the flag to check.
-*                  This parameter can be: CAN_FLAG_EWG, CAN_FLAG_EPV or
-*                                         CAN_FLAG_BOF.
-* Output         : None.
-* Return         : The new state of CAN_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus CAN_GetFlagStatus(u32 CAN_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_FLAG(CAN_FLAG));
-
-  /* Check the status of the specified CAN flag */
-  if ((CAN-&gt;ESR &amp; CAN_FLAG) != (u32)RESET)
-  {
-    /* CAN_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* CAN_FLAG is reset */
-    bitstatus = RESET;
-  }
-  /* Return the CAN_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_ClearFlag
-* Description    : Clears the CAN's pending flags.
-* Input          : CAN_FLAG: specifies the flag to clear.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_ClearFlag(u32 CAN_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_FLAG(CAN_FLAG));
-
-  /* Clear the selected CAN flags */
-  CAN-&gt;ESR &amp;= ~CAN_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_GetITStatus
-* Description    : Checks whether the specified CAN interrupt has occurred or 
-*                  not.
-* Input          : CAN_IT: specifies the CAN interrupt source to check.
-*                  This parameter can be: CAN_IT_RQCP0, CAN_IT_RQCP1, CAN_IT_RQCP2,
-*                                         CAN_IT_FF0, CAN_IT_FOV0, CAN_IT_FF1,
-*                                         CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV, 
-*                                         CAN_IT_BOF, CAN_IT_WKU or CAN_IT_SLK.
-* Output         : None.
-* Return         : The new state of CAN_IT (SET or RESET).
-*******************************************************************************/
-ITStatus CAN_GetITStatus(u32 CAN_IT)
-{
-  ITStatus pendingbitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_ITStatus(CAN_IT));
-
-  switch (CAN_IT)
-  {
-    case CAN_IT_RQCP0:
-      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP0);
-      break;
-    case CAN_IT_RQCP1:
-      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP1);
-      break;
-    case CAN_IT_RQCP2:
-      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP2);
-      break;
-    case CAN_IT_FF0:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF0R, RF0R_FULL0);
-      break;
-    case CAN_IT_FOV0:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF0R, RF0R_FOVR0);
-      break;
-    case CAN_IT_FF1:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF1R, RF1R_FULL1);
-      break;
-    case CAN_IT_FOV1:
-      pendingbitstatus = CheckITStatus(CAN-&gt;RF1R, RF1R_FOVR1);
-      break;
-    case CAN_IT_EWG:
-      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_EWGF);
-      break;
-    case CAN_IT_EPV:
-      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_EPVF);
-      break;
-    case CAN_IT_BOF:
-      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_BOFF);
-      break;
-    case CAN_IT_SLK:
-      pendingbitstatus = CheckITStatus(CAN-&gt;MSR, MSR_SLAKI);
-      break;
-    case CAN_IT_WKU:
-      pendingbitstatus = CheckITStatus(CAN-&gt;MSR, MSR_WKUI);
-      break;
-
-    default :
-      pendingbitstatus = RESET;
-      break;
-  }
-
-  /* Return the CAN_IT status */
-  return  pendingbitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : CAN_ClearITPendingBit
-* Description    : Clears the CAN&#146;s interrupt pending bits.
-* Input          : CAN_IT: specifies the interrupt pending bit to clear.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CAN_ClearITPendingBit(u32 CAN_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ITStatus(CAN_IT));
-
-  switch (CAN_IT)
-  {
-    case CAN_IT_RQCP0:
-      CAN-&gt;TSR = TSR_RQCP0; /* rc_w1*/
-      break;
-    case CAN_IT_RQCP1:
-      CAN-&gt;TSR = TSR_RQCP1; /* rc_w1*/
-      break;
-    case CAN_IT_RQCP2:
-      CAN-&gt;TSR = TSR_RQCP2; /* rc_w1*/
-      break;
-    case CAN_IT_FF0:
-      CAN-&gt;RF0R = RF0R_FULL0; /* rc_w1*/
-      break;
-    case CAN_IT_FOV0:
-      CAN-&gt;RF0R = RF0R_FOVR0; /* rc_w1*/
-      break;
-    case CAN_IT_FF1:
-      CAN-&gt;RF1R = RF1R_FULL1; /* rc_w1*/
-      break;
-    case CAN_IT_FOV1:
-      CAN-&gt;RF1R = RF1R_FOVR1; /* rc_w1*/
-      break;
-    case CAN_IT_EWG:
-      CAN-&gt;ESR &amp;= ~ ESR_EWGF; /* rw */
-      break;
-    case CAN_IT_EPV:
-      CAN-&gt;ESR &amp;= ~ ESR_EPVF; /* rw */
-      break;
-    case CAN_IT_BOF:
-      CAN-&gt;ESR &amp;= ~ ESR_BOFF; /* rw */
-      break;
-    case CAN_IT_WKU:
-      CAN-&gt;MSR = MSR_WKUI;  /* rc_w1*/
-      break;
-    case CAN_IT_SLK:
-      CAN-&gt;MSR = MSR_SLAKI;  /* rc_w1*/
-      break;
-    default :
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : CheckITStatus
-* Description    : Checks whether the CAN interrupt has occurred or not.
-* Input          : CAN_Reg: specifies the CAN interrupt register to check.
-*                  It_Bit: specifies the interrupt source bit to check.
-* Output         : None.
-* Return         : The new state of the CAN Interrupt (SET or RESET).
-*******************************************************************************/
-static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit)
-{
-  ITStatus pendingbitstatus = RESET;
-
-  if ((CAN_Reg &amp; It_Bit) != (u32)RESET)
-  {
-    /* CAN_IT is set */
-    pendingbitstatus = SET;
-  }
-  else
-  {
-    /* CAN_IT is reset */
-    pendingbitstatus = RESET;
-  }
-
-  return pendingbitstatus;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_can.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the CAN firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_can.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+
+/* Private define ------------------------------------------------------------*/
+/* CAN Master Control Register bits */
+#define MCR_INRQ     ((u32)0x00000001) /* Initialization request */
+#define MCR_SLEEP    ((u32)0x00000002) /* Sleep mode request */
+#define MCR_TXFP     ((u32)0x00000004) /* Transmit FIFO priority */
+#define MCR_RFLM     ((u32)0x00000008) /* Receive FIFO locked mode */
+#define MCR_NART     ((u32)0x00000010) /* No automatic retransmission */
+#define MCR_AWUM     ((u32)0x00000020) /* Automatic wake up mode */
+#define MCR_ABOM     ((u32)0x00000040) /* Automatic bus-off management */
+#define MCR_TTCM     ((u32)0x00000080) /* time triggered communication */
+
+/* CAN Master Status Register bits */
+#define MSR_INAK     ((u32)0x00000001)    /* Initialization acknowledge */
+#define MSR_WKUI     ((u32)0x00000008)    /* Wake-up interrupt */
+#define MSR_SLAKI    ((u32)0x00000010)    /* Sleep acknowledge interrupt */
+
+/* CAN Transmit Status Register bits */
+#define TSR_RQCP0    ((u32)0x00000001)    /* Request completed mailbox0 */
+#define TSR_TXOK0    ((u32)0x00000002)    /* Transmission OK of mailbox0 */
+#define TSR_ABRQ0    ((u32)0x00000080)    /* Abort request for mailbox0 */
+#define TSR_RQCP1    ((u32)0x00000100)    /* Request completed mailbox1 */
+#define TSR_TXOK1    ((u32)0x00000200)    /* Transmission OK of mailbox1 */
+#define TSR_ABRQ1    ((u32)0x00008000)    /* Abort request for mailbox1 */
+#define TSR_RQCP2    ((u32)0x00010000)    /* Request completed mailbox2 */
+#define TSR_TXOK2    ((u32)0x00020000)    /* Transmission OK of mailbox2 */
+#define TSR_ABRQ2    ((u32)0x00800000)    /* Abort request for mailbox2 */
+#define TSR_TME0     ((u32)0x04000000)    /* Transmit mailbox 0 empty */
+#define TSR_TME1     ((u32)0x08000000)    /* Transmit mailbox 1 empty */
+#define TSR_TME2     ((u32)0x10000000)    /* Transmit mailbox 2 empty */
+
+/* CAN Receive FIFO 0 Register bits */
+#define RF0R_FULL0   ((u32)0x00000008)    /* FIFO 0 full */
+#define RF0R_FOVR0   ((u32)0x00000010)    /* FIFO 0 overrun */
+#define RF0R_RFOM0   ((u32)0x00000020)    /* Release FIFO 0 output mailbox */
+
+/* CAN Receive FIFO 1 Register bits */
+#define RF1R_FULL1   ((u32)0x00000008)    /* FIFO 1 full */
+#define RF1R_FOVR1   ((u32)0x00000010)    /* FIFO 1 overrun */
+#define RF1R_RFOM1   ((u32)0x00000020)    /* Release FIFO 1 output mailbox */
+
+/* CAN Error Status Register bits */
+#define ESR_EWGF     ((u32)0x00000001)    /* Error warning flag */
+#define ESR_EPVF     ((u32)0x00000002)    /* Error passive flag */
+#define ESR_BOFF     ((u32)0x00000004)    /* Bus-off flag */
+
+/* CAN Mailbox Transmit Request */
+#define TMIDxR_TXRQ  ((u32)0x00000001) /* Transmit mailbox request */
+
+/* CAN Filter Master Register bits */
+#define FMR_FINIT    ((u32)0x00000001) /* Filter init mode */
+
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit);
+
+/* Private functions ---------------------------------------------------------*/
+/*******************************************************************************
+* Function Name  : CAN_DeInit
+* Description    : Deinitializes the CAN peripheral registers to their default
+*                  reset values.
+* Input          : None.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_DeInit(void)
+{
+  /* Enable CAN reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
+  /* Release CAN from reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
+}
+
+/*******************************************************************************
+* Function Name  : CAN_Init
+* Description    : Initializes the CAN peripheral according to the specified
+*                  parameters in the CAN_InitStruct.
+* Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
+                   contains the configuration information for the CAN peripheral.
+* Output         : None.
+* Return         : Constant indicates initialization succeed which will be 
+*                  CANINITFAILED or CANINITOK.
+*******************************************************************************/
+u8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct)
+{
+  u8 InitStatus = 0;
+  u16 WaitAck = 0;
+
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TTCM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_ABOM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_AWUM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_NART));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_RFLM));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct-&gt;CAN_TXFP));
+  assert_param(IS_CAN_MODE(CAN_InitStruct-&gt;CAN_Mode));
+  assert_param(IS_CAN_SJW(CAN_InitStruct-&gt;CAN_SJW));
+  assert_param(IS_CAN_BS1(CAN_InitStruct-&gt;CAN_BS1));
+  assert_param(IS_CAN_BS2(CAN_InitStruct-&gt;CAN_BS2));
+  assert_param(IS_CAN_PRESCALER(CAN_InitStruct-&gt;CAN_Prescaler));
+
+  /* Request initialisation */
+  CAN-&gt;MCR = MCR_INRQ;
+
+  /* ...and check acknowledged */
+  if ((CAN-&gt;MSR &amp; MSR_INAK) == 0)
+  {
+    InitStatus = CANINITFAILED;
+  }
+  else
+  {
+    /* Set the time triggered communication mode */
+    if (CAN_InitStruct-&gt;CAN_TTCM == ENABLE)
+    {
+      CAN-&gt;MCR |= MCR_TTCM;
+    }
+    else
+    {
+      CAN-&gt;MCR &amp;= ~MCR_TTCM;
+    }
+
+    /* Set the automatic bus-off management */
+    if (CAN_InitStruct-&gt;CAN_ABOM == ENABLE)
+    {
+      CAN-&gt;MCR |= MCR_ABOM;
+    }
+    else
+    {
+      CAN-&gt;MCR &amp;= ~MCR_ABOM;
+    }
+
+    /* Set the automatic wake-up mode */
+    if (CAN_InitStruct-&gt;CAN_AWUM == ENABLE)
+    {
+      CAN-&gt;MCR |= MCR_AWUM;
+    }
+    else
+    {
+      CAN-&gt;MCR &amp;= ~MCR_AWUM;
+    }
+
+    /* Set the no automatic retransmission */
+    if (CAN_InitStruct-&gt;CAN_NART == ENABLE)
+    {
+      CAN-&gt;MCR |= MCR_NART;
+    }
+    else
+    {
+      CAN-&gt;MCR &amp;= ~MCR_NART;
+    }
+
+    /* Set the receive FIFO locked mode */
+    if (CAN_InitStruct-&gt;CAN_RFLM == ENABLE)
+    {
+      CAN-&gt;MCR |= MCR_RFLM;
+    }
+    else
+    {
+      CAN-&gt;MCR &amp;= ~MCR_RFLM;
+    }
+
+    /* Set the transmit FIFO priority */
+    if (CAN_InitStruct-&gt;CAN_TXFP == ENABLE)
+    {
+      CAN-&gt;MCR |= MCR_TXFP;
+    }
+    else
+    {
+      CAN-&gt;MCR &amp;= ~MCR_TXFP;
+    }
+
+    /* Set the bit timing register */
+    CAN-&gt;BTR = (u32)((u32)CAN_InitStruct-&gt;CAN_Mode &lt;&lt; 30) | ((u32)CAN_InitStruct-&gt;CAN_SJW &lt;&lt; 24) |
+               ((u32)CAN_InitStruct-&gt;CAN_BS1 &lt;&lt; 16) | ((u32)CAN_InitStruct-&gt;CAN_BS2 &lt;&lt; 20) |
+               ((u32)CAN_InitStruct-&gt;CAN_Prescaler - 1);
+
+    InitStatus = CANINITOK;
+
+    /* Request leave initialisation */
+    CAN-&gt;MCR &amp;= ~MCR_INRQ;
+
+    /* Wait the acknowledge */
+    for(WaitAck = 0x400; WaitAck &gt; 0x0; WaitAck--)
+    {
+    }
+    
+    /* ...and check acknowledged */
+    if ((CAN-&gt;MSR &amp; MSR_INAK) == MSR_INAK)
+    {
+      InitStatus = CANINITFAILED;
+    }
+  }
+
+  /* At this step, return the status of initialization */
+  return InitStatus;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_FilterInit
+* Description    : Initializes the CAN peripheral according to the specified
+*                  parameters in the CAN_FilterInitStruct.
+* Input          : CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
+*                  structure that contains the configuration information.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
+{
+  u16 FilterNumber_BitPos = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct-&gt;CAN_FilterNumber));
+  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct-&gt;CAN_FilterMode));
+  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct-&gt;CAN_FilterScale));
+  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment));
+  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct-&gt;CAN_FilterActivation));
+
+  FilterNumber_BitPos = 
+  (u16)(((u16)0x0001) &lt;&lt; ((u16)CAN_FilterInitStruct-&gt;CAN_FilterNumber));
+
+  /* Initialisation mode for the filter */
+  CAN-&gt;FMR |= FMR_FINIT;
+
+  /* Filter Deactivation */
+  CAN-&gt;FA1R &amp;= ~(u32)FilterNumber_BitPos;
+
+  /* Filter Scale */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_16bit)
+  {
+    /* 16-bit scale for the filter */
+    CAN-&gt;FS1R &amp;= ~(u32)FilterNumber_BitPos;
+
+    /* First 16-bit identifier and First 16-bit mask */
+    /* Or First 16-bit identifier and Second 16-bit identifier */
+    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
+    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow) &lt;&lt; 16) |
+        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
+
+    /* Second 16-bit identifier and Second 16-bit mask */
+    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
+    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
+    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
+        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdHigh);
+  }
+  if (CAN_FilterInitStruct-&gt;CAN_FilterScale == CAN_FilterScale_32bit)
+  {
+    /* 32-bit scale for the filter */
+    CAN-&gt;FS1R |= FilterNumber_BitPos;
+
+    /* 32-bit identifier or First 32-bit identifier */
+    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR1 = 
+    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdHigh) &lt;&lt; 16) |
+        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterIdLow);
+
+    /* 32-bit mask or Second 32-bit identifier */
+    CAN-&gt;sFilterRegister[CAN_FilterInitStruct-&gt;CAN_FilterNumber].FR2 = 
+    ((u32)((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdHigh) &lt;&lt; 16) |
+        ((u32)0x0000FFFF &amp; CAN_FilterInitStruct-&gt;CAN_FilterMaskIdLow);
+
+  }
+
+  /* Filter Mode */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdMask)
+  {
+    /*Id/Mask mode for the filter*/
+    CAN-&gt;FM1R &amp;= ~(u32)FilterNumber_BitPos;
+  }
+  else /* CAN_FilterInitStruct-&gt;CAN_FilterMode == CAN_FilterMode_IdList */
+  {
+    /*Identifier list mode for the filter*/
+    CAN-&gt;FM1R |= (u32)FilterNumber_BitPos;
+  }
+
+  /* Filter FIFO assignment */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
+  {
+    /* FIFO 0 assignation for the filter */
+    CAN-&gt;FFA1R &amp;= ~(u32)FilterNumber_BitPos;
+  }
+  if (CAN_FilterInitStruct-&gt;CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
+  {
+    /* FIFO 1 assignation for the filter */
+    CAN-&gt;FFA1R |= (u32)FilterNumber_BitPos;
+  }
+  
+  /* Filter activation */
+  if (CAN_FilterInitStruct-&gt;CAN_FilterActivation == ENABLE)
+  {
+    CAN-&gt;FA1R |= FilterNumber_BitPos;
+  }
+
+  /* Leave the initialisation mode for the filter */
+  CAN-&gt;FMR &amp;= ~FMR_FINIT;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_StructInit
+* Description    : Fills each CAN_InitStruct member with its default value.
+* Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
+*                  will be initialized.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
+{
+  /* Reset CAN init structure parameters values */
+
+  /* Initialize the time triggered communication mode */
+  CAN_InitStruct-&gt;CAN_TTCM = DISABLE;
+
+  /* Initialize the automatic bus-off management */
+  CAN_InitStruct-&gt;CAN_ABOM = DISABLE;
+
+  /* Initialize the automatic wake-up mode */
+  CAN_InitStruct-&gt;CAN_AWUM = DISABLE;
+
+  /* Initialize the no automatic retransmission */
+  CAN_InitStruct-&gt;CAN_NART = DISABLE;
+
+  /* Initialize the receive FIFO locked mode */
+  CAN_InitStruct-&gt;CAN_RFLM = DISABLE;
+
+  /* Initialize the transmit FIFO priority */
+  CAN_InitStruct-&gt;CAN_TXFP = DISABLE;
+
+  /* Initialize the CAN_Mode member */
+  CAN_InitStruct-&gt;CAN_Mode = CAN_Mode_Normal;
+
+  /* Initialize the CAN_SJW member */
+  CAN_InitStruct-&gt;CAN_SJW = CAN_SJW_1tq;
+
+  /* Initialize the CAN_BS1 member */
+  CAN_InitStruct-&gt;CAN_BS1 = CAN_BS1_4tq;
+
+  /* Initialize the CAN_BS2 member */
+  CAN_InitStruct-&gt;CAN_BS2 = CAN_BS2_3tq;
+
+  /* Initialize the CAN_Prescaler member */
+  CAN_InitStruct-&gt;CAN_Prescaler = 1;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_ITConfig
+* Description    : Enables or disables the specified CAN interrupts.
+* Input          : - CAN_IT: specifies the CAN interrupt sources to be enabled or
+*                    disabled.
+*                    This parameter can be: CAN_IT_TME, CAN_IT_FMP0, CAN_IT_FF0,
+*                                           CAN_IT_FOV0, CAN_IT_FMP1, CAN_IT_FF1,
+*                                           CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV,
+*                                           CAN_IT_LEC, CAN_IT_ERR, CAN_IT_WKU or
+*                                           CAN_IT_SLK.
+*                  - NewState: new state of the CAN interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_ITConfig(u32 CAN_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ITConfig(CAN_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected CAN interrupt */
+    CAN-&gt;IER |= CAN_IT;
+  }
+  else
+  {
+    /* Disable the selected CAN interrupt */
+    CAN-&gt;IER &amp;= ~CAN_IT;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : CAN_Transmit
+* Description    : Initiates the transmission of a message.
+* Input          : TxMessage: pointer to a structure which contains CAN Id, CAN
+*                  DLC and CAN datas.
+* Output         : None.
+* Return         : The number of the mailbox that is used for transmission
+*                  or CAN_NO_MB if there is no empty mailbox.
+*******************************************************************************/
+u8 CAN_Transmit(CanTxMsg* TxMessage)
+{
+  u8 TransmitMailbox = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_STDID(TxMessage-&gt;StdId));
+  assert_param(IS_CAN_EXTID(TxMessage-&gt;StdId));
+  assert_param(IS_CAN_IDTYPE(TxMessage-&gt;IDE));
+  assert_param(IS_CAN_RTR(TxMessage-&gt;RTR));
+  assert_param(IS_CAN_DLC(TxMessage-&gt;DLC));
+
+  /* Select one empty transmit mailbox */
+  if ((CAN-&gt;TSR&amp;TSR_TME0) == TSR_TME0)
+  {
+    TransmitMailbox = 0;
+  }
+  else if ((CAN-&gt;TSR&amp;TSR_TME1) == TSR_TME1)
+  {
+    TransmitMailbox = 1;
+  }
+  else if ((CAN-&gt;TSR&amp;TSR_TME2) == TSR_TME2)
+  {
+    TransmitMailbox = 2;
+  }
+  else
+  {
+    TransmitMailbox = CAN_NO_MB;
+  }
+
+  if (TransmitMailbox != CAN_NO_MB)
+  {
+    /* Set up the Id */
+    CAN-&gt;sTxMailBox[TransmitMailbox].TIR &amp;= TMIDxR_TXRQ;
+    if (TxMessage-&gt;IDE == CAN_ID_STD)
+    {
+      TxMessage-&gt;StdId &amp;= (u32)0x000007FF;
+      TxMessage-&gt;StdId = TxMessage-&gt;StdId &lt;&lt; 21;
+      
+      CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= (TxMessage-&gt;StdId | TxMessage-&gt;IDE |
+                                               TxMessage-&gt;RTR);
+    }
+    else
+    {
+      TxMessage-&gt;ExtId &amp;= (u32)0x1FFFFFFF;
+      TxMessage-&gt;ExtId &lt;&lt;= 3;
+
+      CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= (TxMessage-&gt;ExtId | TxMessage-&gt;IDE | 
+                                               TxMessage-&gt;RTR);
+    }
+    
+    /* Set up the DLC */
+    TxMessage-&gt;DLC &amp;= (u8)0x0000000F;
+    CAN-&gt;sTxMailBox[TransmitMailbox].TDTR &amp;= (u32)0xFFFFFFF0;
+    CAN-&gt;sTxMailBox[TransmitMailbox].TDTR |= TxMessage-&gt;DLC;
+
+    /* Set up the data field */
+    CAN-&gt;sTxMailBox[TransmitMailbox].TDLR = (((u32)TxMessage-&gt;Data[3] &lt;&lt; 24) | 
+                                             ((u32)TxMessage-&gt;Data[2] &lt;&lt; 16) |
+                                             ((u32)TxMessage-&gt;Data[1] &lt;&lt; 8) | 
+                                             ((u32)TxMessage-&gt;Data[0]));
+    CAN-&gt;sTxMailBox[TransmitMailbox].TDHR = (((u32)TxMessage-&gt;Data[7] &lt;&lt; 24) | 
+                                             ((u32)TxMessage-&gt;Data[6] &lt;&lt; 16) |
+                                             ((u32)TxMessage-&gt;Data[5] &lt;&lt; 8) |
+                                             ((u32)TxMessage-&gt;Data[4]));
+
+    /* Request transmission */
+    CAN-&gt;sTxMailBox[TransmitMailbox].TIR |= TMIDxR_TXRQ;
+  }
+
+  return TransmitMailbox;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_TransmitStatus
+* Description    : Checks the transmission of a message.
+* Input          : TransmitMailbox: the number of the mailbox that is used for
+*                  transmission.
+* Output         : None.
+* Return         : CANTXOK if the CAN driver transmits the message, CANTXFAILED
+*                  in an other case.
+*******************************************************************************/
+u8 CAN_TransmitStatus(u8 TransmitMailbox)
+{
+  /* RQCP, TXOK and TME bits */
+  u8 State = 0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
+
+  switch (TransmitMailbox)
+  {
+    case (0): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP0) &lt;&lt; 2);
+      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK0) &gt;&gt; 0);
+      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME0) &gt;&gt; 26);
+      break;
+    case (1): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP1) &gt;&gt; 6);
+      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK1) &gt;&gt; 8);
+      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME1) &gt;&gt; 27);
+      break;
+    case (2): State |= (u8)((CAN-&gt;TSR &amp; TSR_RQCP2) &gt;&gt; 14);
+      State |= (u8)((CAN-&gt;TSR &amp; TSR_TXOK2) &gt;&gt; 16);
+      State |= (u8)((CAN-&gt;TSR &amp; TSR_TME2) &gt;&gt; 28);
+      break;
+    default:
+      State = CANTXFAILED;
+      break;
+  }
+
+  switch (State)
+  {
+      /* transmit pending  */
+    case (0x0): State = CANTXPENDING;
+      break;
+      /* transmit failed  */
+    case (0x5): State = CANTXFAILED;
+      break;
+      /* transmit succedeed  */
+    case (0x7): State = CANTXOK;
+      break;
+    default:
+      State = CANTXFAILED;
+      break;
+  }
+
+  return State;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_CancelTransmit
+* Description    : Cancels a transmit request.
+* Input          : Mailbox number.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_CancelTransmit(u8 Mailbox)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
+
+  /* abort transmission */
+  switch (Mailbox)
+  {
+    case (0): CAN-&gt;TSR |= TSR_ABRQ0;
+      break;
+    case (1): CAN-&gt;TSR |= TSR_ABRQ1;
+      break;
+    case (2): CAN-&gt;TSR |= TSR_ABRQ2;
+      break;
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : CAN_FIFORelease
+* Description    : Releases a FIFO.
+* Input          : FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_FIFORelease(u8 FIFONumber)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_FIFO(FIFONumber));
+
+  /* Release FIFO0 */
+  if (FIFONumber == CAN_FIFO0)
+  {
+    CAN-&gt;RF0R = RF0R_RFOM0;
+  }
+  /* Release FIFO1 */
+  else /* FIFONumber == CAN_FIFO1 */
+  {
+    CAN-&gt;RF1R = RF1R_RFOM1;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : CAN_MessagePending
+* Description    : Returns the number of pending messages.
+* Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+* Output         : None.
+* Return         : NbMessage which is the number of pending message.
+*******************************************************************************/
+u8 CAN_MessagePending(u8 FIFONumber)
+{
+  u8 MessagePending=0;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_FIFO(FIFONumber));
+
+  if (FIFONumber == CAN_FIFO0)
+  {
+    MessagePending = (u8)(CAN-&gt;RF0R&amp;(u32)0x03);
+  }
+  else if (FIFONumber == CAN_FIFO1)
+  {
+    MessagePending = (u8)(CAN-&gt;RF1R&amp;(u32)0x03);
+  }
+  else
+  {
+    MessagePending = 0;
+  }
+  return MessagePending;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_Receive
+* Description    : Receives a message.
+* Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
+* Output         : RxMessage: pointer to a structure which contains CAN Id,
+*                  CAN DLC, CAN datas and FMI number.
+* Return         : None.
+*******************************************************************************/
+void CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_FIFO(FIFONumber));
+
+  /* Get the Id */
+  RxMessage-&gt;IDE = (u8)0x04 &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RIR;
+  if (RxMessage-&gt;IDE == CAN_ID_STD)
+  {
+    RxMessage-&gt;StdId = (u32)0x000007FF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 21);
+  }
+  else
+  {
+    RxMessage-&gt;ExtId = (u32)0x1FFFFFFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RIR &gt;&gt; 3);
+  }
+  
+  RxMessage-&gt;RTR = (u8)0x02 &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RIR;
+
+  /* Get the DLC */
+  RxMessage-&gt;DLC = (u8)0x0F &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDTR;
+
+  /* Get the FMI */
+  RxMessage-&gt;FMI = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDTR &gt;&gt; 8);
+
+  /* Get the data field */
+  RxMessage-&gt;Data[0] = (u8)0xFF &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDLR;
+  RxMessage-&gt;Data[1] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 8);
+  RxMessage-&gt;Data[2] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 16);
+  RxMessage-&gt;Data[3] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDLR &gt;&gt; 24);
+
+  RxMessage-&gt;Data[4] = (u8)0xFF &amp; CAN-&gt;sFIFOMailBox[FIFONumber].RDHR;
+  RxMessage-&gt;Data[5] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 8);
+  RxMessage-&gt;Data[6] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 16);
+  RxMessage-&gt;Data[7] = (u8)0xFF &amp; (CAN-&gt;sFIFOMailBox[FIFONumber].RDHR &gt;&gt; 24);
+
+  /* Release the FIFO */
+  CAN_FIFORelease(FIFONumber);
+}
+
+/*******************************************************************************
+* Function Name  : CAN_Sleep
+* Description    : Enters the low power mode.
+* Input          : None.
+* Output         : None.
+* Return         : CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
+*******************************************************************************/
+u8 CAN_Sleep(void)
+{
+  u8 SleepStatus = 0;
+
+  /* Sleep mode entering request */
+  CAN-&gt;MCR |= MCR_SLEEP;
+  SleepStatus = CANSLEEPOK;
+
+  /* Sleep mode status */
+  if ((CAN-&gt;MCR&amp;MCR_SLEEP) == 0)
+  {
+    /* Sleep mode not entered */
+    SleepStatus = CANSLEEPFAILED;
+  }
+
+  /* At this step, sleep mode status */
+  return SleepStatus;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_WakeUp
+* Description    : Wakes the CAN up.
+* Input          : None.
+* Output         : None.
+* Return         : CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other
+*                  case.
+*******************************************************************************/
+u8 CAN_WakeUp(void)
+{
+  u8 WakeUpStatus = 0;
+
+  /* Wake up request */
+  CAN-&gt;MCR &amp;= ~MCR_SLEEP;
+  WakeUpStatus = CANWAKEUPFAILED;
+
+  /* Sleep mode status */
+  if ((CAN-&gt;MCR&amp;MCR_SLEEP) == 0)
+  {
+    /* Sleep mode exited */
+    WakeUpStatus = CANWAKEUPOK;
+  }
+
+  /* At this step, sleep mode status */
+  return WakeUpStatus;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_GetFlagStatus
+* Description    : Checks whether the specified CAN flag is set or not.
+* Input          : CAN_FLAG: specifies the flag to check.
+*                  This parameter can be: CAN_FLAG_EWG, CAN_FLAG_EPV or
+*                                         CAN_FLAG_BOF.
+* Output         : None.
+* Return         : The new state of CAN_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus CAN_GetFlagStatus(u32 CAN_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_FLAG(CAN_FLAG));
+
+  /* Check the status of the specified CAN flag */
+  if ((CAN-&gt;ESR &amp; CAN_FLAG) != (u32)RESET)
+  {
+    /* CAN_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* CAN_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the CAN_FLAG status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_ClearFlag
+* Description    : Clears the CAN's pending flags.
+* Input          : CAN_FLAG: specifies the flag to clear.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_ClearFlag(u32 CAN_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_FLAG(CAN_FLAG));
+
+  /* Clear the selected CAN flags */
+  CAN-&gt;ESR &amp;= ~CAN_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_GetITStatus
+* Description    : Checks whether the specified CAN interrupt has occurred or 
+*                  not.
+* Input          : CAN_IT: specifies the CAN interrupt source to check.
+*                  This parameter can be: CAN_IT_RQCP0, CAN_IT_RQCP1, CAN_IT_RQCP2,
+*                                         CAN_IT_FF0, CAN_IT_FOV0, CAN_IT_FF1,
+*                                         CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV, 
+*                                         CAN_IT_BOF, CAN_IT_WKU or CAN_IT_SLK.
+* Output         : None.
+* Return         : The new state of CAN_IT (SET or RESET).
+*******************************************************************************/
+ITStatus CAN_GetITStatus(u32 CAN_IT)
+{
+  ITStatus pendingbitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_CAN_ITStatus(CAN_IT));
+
+  switch (CAN_IT)
+  {
+    case CAN_IT_RQCP0:
+      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP0);
+      break;
+    case CAN_IT_RQCP1:
+      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP1);
+      break;
+    case CAN_IT_RQCP2:
+      pendingbitstatus = CheckITStatus(CAN-&gt;TSR, TSR_RQCP2);
+      break;
+    case CAN_IT_FF0:
+      pendingbitstatus = CheckITStatus(CAN-&gt;RF0R, RF0R_FULL0);
+      break;
+    case CAN_IT_FOV0:
+      pendingbitstatus = CheckITStatus(CAN-&gt;RF0R, RF0R_FOVR0);
+      break;
+    case CAN_IT_FF1:
+      pendingbitstatus = CheckITStatus(CAN-&gt;RF1R, RF1R_FULL1);
+      break;
+    case CAN_IT_FOV1:
+      pendingbitstatus = CheckITStatus(CAN-&gt;RF1R, RF1R_FOVR1);
+      break;
+    case CAN_IT_EWG:
+      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_EWGF);
+      break;
+    case CAN_IT_EPV:
+      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_EPVF);
+      break;
+    case CAN_IT_BOF:
+      pendingbitstatus = CheckITStatus(CAN-&gt;ESR, ESR_BOFF);
+      break;
+    case CAN_IT_SLK:
+      pendingbitstatus = CheckITStatus(CAN-&gt;MSR, MSR_SLAKI);
+      break;
+    case CAN_IT_WKU:
+      pendingbitstatus = CheckITStatus(CAN-&gt;MSR, MSR_WKUI);
+      break;
+
+    default :
+      pendingbitstatus = RESET;
+      break;
+  }
+
+  /* Return the CAN_IT status */
+  return  pendingbitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : CAN_ClearITPendingBit
+* Description    : Clears the CAN's interrupt pending bits.
+* Input          : CAN_IT: specifies the interrupt pending bit to clear.
+* Output         : None.
+* Return         : None.
+*******************************************************************************/
+void CAN_ClearITPendingBit(u32 CAN_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_CAN_ITStatus(CAN_IT));
+
+  switch (CAN_IT)
+  {
+    case CAN_IT_RQCP0:
+      CAN-&gt;TSR = TSR_RQCP0; /* rc_w1*/
+      break;
+    case CAN_IT_RQCP1:
+      CAN-&gt;TSR = TSR_RQCP1; /* rc_w1*/
+      break;
+    case CAN_IT_RQCP2:
+      CAN-&gt;TSR = TSR_RQCP2; /* rc_w1*/
+      break;
+    case CAN_IT_FF0:
+      CAN-&gt;RF0R = RF0R_FULL0; /* rc_w1*/
+      break;
+    case CAN_IT_FOV0:
+      CAN-&gt;RF0R = RF0R_FOVR0; /* rc_w1*/
+      break;
+    case CAN_IT_FF1:
+      CAN-&gt;RF1R = RF1R_FULL1; /* rc_w1*/
+      break;
+    case CAN_IT_FOV1:
+      CAN-&gt;RF1R = RF1R_FOVR1; /* rc_w1*/
+      break;
+    case CAN_IT_EWG:
+      CAN-&gt;ESR &amp;= ~ ESR_EWGF; /* rw */
+      break;
+    case CAN_IT_EPV:
+      CAN-&gt;ESR &amp;= ~ ESR_EPVF; /* rw */
+      break;
+    case CAN_IT_BOF:
+      CAN-&gt;ESR &amp;= ~ ESR_BOFF; /* rw */
+      break;
+    case CAN_IT_WKU:
+      CAN-&gt;MSR = MSR_WKUI;  /* rc_w1*/
+      break;
+    case CAN_IT_SLK:
+      CAN-&gt;MSR = MSR_SLAKI;  /* rc_w1*/
+      break;
+    default :
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : CheckITStatus
+* Description    : Checks whether the CAN interrupt has occurred or not.
+* Input          : CAN_Reg: specifies the CAN interrupt register to check.
+*                  It_Bit: specifies the interrupt source bit to check.
+* Output         : None.
+* Return         : The new state of the CAN Interrupt (SET or RESET).
+*******************************************************************************/
+static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit)
+{
+  ITStatus pendingbitstatus = RESET;
+
+  if ((CAN_Reg &amp; It_Bit) != (u32)RESET)
+  {
+    /* CAN_IT is set */
+    pendingbitstatus = SET;
+  }
+  else
+  {
+    /* CAN_IT is reset */
+    pendingbitstatus = RESET;
+  }
+
+  return pendingbitstatus;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_crc.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,114 +1,114 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_crc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the CRC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_crc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-
-/* CR register bit mask */
-#define CR_RESET_Set    ((u32)0x00000001)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : CRC_ResetDR
-* Description    : Resets the CRC Data register (DR).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void CRC_ResetDR(void)
-{
-  /* Reset CRC generator */
-  CRC-&gt;CR = CR_RESET_Set;
-}
-
-/*******************************************************************************
-* Function Name  : CRC_CalcCRC
-* Description    : Computes the 32-bit CRC of a given data word(32-bit).
-* Input          : - Data: data word(32-bit) to compute its CRC
-* Output         : None
-* Return         : 32-bit CRC
-*******************************************************************************/
-u32 CRC_CalcCRC(u32 Data)
-{
-  CRC-&gt;DR = Data;
-  
-  return (CRC-&gt;DR);
-}
-
-/*******************************************************************************
-* Function Name  : CRC_CalcBlockCRC
-* Description    : Computes the 32-bit CRC of a given buffer of data word(32-bit).
-* Input          : - pBuffer: pointer to the buffer containing the data to be 
-*                    computed
-*                  - BufferLength: length of the buffer to be computed					
-* Output         : None
-* Return         : 32-bit CRC
-*******************************************************************************/
-u32 CRC_CalcBlockCRC(u32 pBuffer[], u32 BufferLength)
-{
-  u32 index = 0;
-  
-  for(index = 0; index &lt; BufferLength; index++)
-  {
-    CRC-&gt;DR = pBuffer[index];
-  }
-
-  return (CRC-&gt;DR);
-}
-
-/*******************************************************************************
-* Function Name  : CRC_GetCRC
-* Description    : Returns the current CRC value.
-* Input          : None
-* Output         : None
-* Return         : 32-bit CRC
-*******************************************************************************/
-u32 CRC_GetCRC(void)
-{
-  return (CRC-&gt;DR);
-}
-
-/*******************************************************************************
-* Function Name  : CRC_SetIDRegister
-* Description    : Stores a 8-bit data in the Independent Data(ID) register.
-* Input          : - IDValue: 8-bit value to be stored in the ID register 					
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void CRC_SetIDRegister(u8 IDValue)
-{
-  CRC-&gt;IDR = IDValue;
-}
-
-/*******************************************************************************
-* Function Name  : CRC_GetIDRegister
-* Description    : Returns the 8-bit data stored in the Independent Data(ID) register
-* Input          : None
-* Output         : None
-* Return         : 8-bit value of the ID register 
-*******************************************************************************/
-u8 CRC_GetIDRegister(void)
-{
-  return (CRC-&gt;IDR);
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_crc.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the CRC firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_crc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+
+/* CR register bit mask */
+#define CR_RESET_Set    ((u32)0x00000001)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : CRC_ResetDR
+* Description    : Resets the CRC Data register (DR).
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void CRC_ResetDR(void)
+{
+  /* Reset CRC generator */
+  CRC-&gt;CR = CR_RESET_Set;
+}
+
+/*******************************************************************************
+* Function Name  : CRC_CalcCRC
+* Description    : Computes the 32-bit CRC of a given data word(32-bit).
+* Input          : - Data: data word(32-bit) to compute its CRC
+* Output         : None
+* Return         : 32-bit CRC
+*******************************************************************************/
+u32 CRC_CalcCRC(u32 Data)
+{
+  CRC-&gt;DR = Data;
+  
+  return (CRC-&gt;DR);
+}
+
+/*******************************************************************************
+* Function Name  : CRC_CalcBlockCRC
+* Description    : Computes the 32-bit CRC of a given buffer of data word(32-bit).
+* Input          : - pBuffer: pointer to the buffer containing the data to be 
+*                    computed
+*                  - BufferLength: length of the buffer to be computed					
+* Output         : None
+* Return         : 32-bit CRC
+*******************************************************************************/
+u32 CRC_CalcBlockCRC(u32 pBuffer[], u32 BufferLength)
+{
+  u32 index = 0;
+  
+  for(index = 0; index &lt; BufferLength; index++)
+  {
+    CRC-&gt;DR = pBuffer[index];
+  }
+
+  return (CRC-&gt;DR);
+}
+
+/*******************************************************************************
+* Function Name  : CRC_GetCRC
+* Description    : Returns the current CRC value.
+* Input          : None
+* Output         : None
+* Return         : 32-bit CRC
+*******************************************************************************/
+u32 CRC_GetCRC(void)
+{
+  return (CRC-&gt;DR);
+}
+
+/*******************************************************************************
+* Function Name  : CRC_SetIDRegister
+* Description    : Stores a 8-bit data in the Independent Data(ID) register.
+* Input          : - IDValue: 8-bit value to be stored in the ID register 					
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void CRC_SetIDRegister(u8 IDValue)
+{
+  CRC-&gt;IDR = IDValue;
+}
+
+/*******************************************************************************
+* Function Name  : CRC_GetIDRegister
+* Description    : Returns the 8-bit data stored in the Independent Data(ID) register
+* Input          : None
+* Output         : None
+* Return         : 8-bit value of the ID register 
+*******************************************************************************/
+u8 CRC_GetIDRegister(void)
+{
+  return (CRC-&gt;IDR);
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dac.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,389 +1,389 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dac.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the DAC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_dac.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* DAC EN mask */
-#define CR_EN_Set                  ((u32)0x00000001)
-
-/* DAC DMAEN mask */
-#define CR_DMAEN_Set               ((u32)0x00001000)
-
-/* CR register Mask */
-#define CR_CLEAR_Mask              ((u32)0x00000FFE)
-
-/* DAC SWTRIG mask */
-#define SWTRIGR_SWTRIG_Set         ((u32)0x00000001)
-
-/* DAC Dual Channels SWTRIG masks */
-#define DUAL_SWTRIG_Set            ((u32)0x00000003)
-#define DUAL_SWTRIG_Reset          ((u32)0xFFFFFFFC)
-
-/* DHR registers offsets */
-#define DHR12R1_Offset             ((u32)0x00000008)
-#define DHR12R2_Offset             ((u32)0x00000014)
-#define DHR12RD_Offset             ((u32)0x00000020)
-
-/* DOR register offset */
-#define DOR_Offset                 ((u32)0x0000002C)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : DAC_DeInit
-* Description    : Deinitializes the DAC peripheral registers to their default
-*                  reset values.
-* Input          : None.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_DeInit(void)
-{
-  /* Enable DAC reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
-  /* Release DAC from reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : DAC_Init
-* Description    : Initializes the DAC peripheral according to the specified 
-*                  parameters in the DAC_InitStruct.
-* Input          : - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    DAC channel.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_Init(u32 DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
-{
-  u32 tmpreg1 = 0, tmpreg2 = 0;
-
-  /* Check the DAC parameters */
-  assert_param(IS_DAC_TRIGGER(DAC_InitStruct-&gt;DAC_Trigger));
-  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct-&gt;DAC_WaveGeneration));
-  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude));
-  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct-&gt;DAC_OutputBuffer));
-
-/*---------------------------- DAC CR Configuration --------------------------*/
-  /* Get the DAC CR value */
-  tmpreg1 = DAC-&gt;CR;
-  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
-  tmpreg1 &amp;= ~(CR_CLEAR_Mask &lt;&lt; DAC_Channel);
-  /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
-     mask/amplitude for wave genration */
-  /* Set TSELx and TENx bits according to DAC_Trigger value */
-  /* Set WAVEx bits according to DAC_WaveGeneration value */
-  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
-  /* Set BOFFx bit according to DAC_OutputBuffer value */   
-  tmpreg2 = (DAC_InitStruct-&gt;DAC_Trigger | DAC_InitStruct-&gt;DAC_WaveGeneration |
-             DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct-&gt;DAC_OutputBuffer);
-  /* Calculate CR register value depending on DAC_Channel */
-  tmpreg1 |= tmpreg2 &lt;&lt; DAC_Channel;
-  /* Write to DAC CR */
-  DAC-&gt;CR = tmpreg1;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_StructInit
-* Description    : Fills each DAC_InitStruct member with its default value.
-* Input          : - DAC_InitStruct : pointer to a DAC_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
-{
-/*--------------- Reset DAC init structure parameters values -----------------*/
-  /* Initialize the DAC_Trigger member */
-  DAC_InitStruct-&gt;DAC_Trigger = DAC_Trigger_None;
-
-  /* Initialize the DAC_WaveGeneration member */
-  DAC_InitStruct-&gt;DAC_WaveGeneration = DAC_WaveGeneration_None;
-
-  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
-  DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
-
-  /* Initialize the DAC_OutputBuffer member */
-  DAC_InitStruct-&gt;DAC_OutputBuffer = DAC_OutputBuffer_Enable;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_Cmd
-* Description    : Enables or disables the specified DAC channel.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - NewState: new state of the DAC channel. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_Cmd(u32 DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DAC channel */
-    DAC-&gt;CR |= CR_EN_Set &lt;&lt; DAC_Channel;
-  }
-  else
-  {
-    /* Disable the selected DAC channel */
-    DAC-&gt;CR &amp;= ~(CR_EN_Set &lt;&lt; DAC_Channel);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_DMACmd
-* Description    : Enables or disables the specified DAC channel DMA request.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - NewState: new state of the selected DAC channel DMA request.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_DMACmd(u32 DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DAC channel DMA request */
-    DAC-&gt;CR |= CR_DMAEN_Set &lt;&lt; DAC_Channel;
-  }
-  else
-  {
-    /* Disable the selected DAC channel DMA request */
-    DAC-&gt;CR &amp;= ~(CR_DMAEN_Set &lt;&lt; DAC_Channel);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SoftwareTriggerCmd
-* Description    : Enables or disables the selected DAC channel software trigger.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - NewState: new state of the selected DAC channel software trigger.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SoftwareTriggerCmd(u32 DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable software trigger for the selected DAC channel */
-    DAC-&gt;SWTRIGR |= SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4);
-  }
-  else
-  {
-    /* Disable software trigger for the selected DAC channel */
-    DAC-&gt;SWTRIGR &amp;= ~(SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4));
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_DualSoftwareTriggerCmd
-* Description    : Enables or disables simultaneously the two DAC channels software
-*                  triggers.
-* Input            - NewState: new state of the DAC channels software triggers.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable software trigger for both DAC channels */
-    DAC-&gt;SWTRIGR |= DUAL_SWTRIG_Set ;
-  }
-  else
-  {
-    /* Disable software trigger for both DAC channels */
-    DAC-&gt;SWTRIGR &amp;= DUAL_SWTRIG_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_WaveGenerationCmd
-* Description    : Enables or disables the selected DAC channel wave generation.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-*                  - DAC_Wave: Specifies the wave type to enable or disable.
-*                    This parameter can be one of the following values:
-*                       - DAC_Wave_Noise: noise wave generation
-*                       - DAC_Wave_Triangle: triangle wave generation
-*                  - NewState: new state of the selected DAC channel wave generation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_WaveGenerationCmd(u32 DAC_Channel, u32 DAC_Wave, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_DAC_WAVE(DAC_Wave)); 
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected wave generation for the selected DAC channel */
-    DAC-&gt;CR |= DAC_Wave &lt;&lt; DAC_Channel;
-  }
-  else
-  {
-    /* Disable the selected wave generation for the selected DAC channel */
-    DAC-&gt;CR &amp;= ~(DAC_Wave &lt;&lt; DAC_Channel);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SetChannel1Data
-* Description    : Set the specified data holding register value for DAC channel1.
-* Input          : - DAC_Align: Specifies the data alignement for DAC channel1.
-*                    This parameter can be one of the following values:
-*                       - DAC_Align_8b_R: 8bit right data alignement selected
-*                       - DAC_Align_12b_L: 12bit left data alignement selected
-*                       - DAC_Align_12b_R: 12bit right data alignement selected
-*                  - Data : Data to be loaded in the selected data holding 
-*                    register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SetChannel1Data(u32 DAC_Align, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data));
-
-  /* Set the DAC channel1 selected data holding register */
-  *((vu32 *)(DAC_BASE + DHR12R1_Offset + DAC_Align)) = (u32)Data;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SetChannel2Data
-* Description    : Set the specified data holding register value for DAC channel2.
-* Input          : - DAC_Align: Specifies the data alignement for DAC channel2.
-*                    This parameter can be one of the following values:
-*                       - DAC_Align_8b_R: 8bit right data alignement selected
-*                       - DAC_Align_12b_L: 12bit left data alignement selected
-*                       - DAC_Align_12b_R: 12bit right data alignement selected
-*                  - Data : Data to be loaded in the selected data holding 
-*                    register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SetChannel2Data(u32 DAC_Align, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data));
-
-  /* Set the DAC channel2 selected data holding register */
-  *((vu32 *)(DAC_BASE + DHR12R2_Offset + DAC_Align)) = (u32)Data;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_SetDualChannelData
-* Description    : Set the specified data holding register value for dual channel
-*                  DAC.
-* Input          : - DAC_Align: Specifies the data alignement for dual channel DAC.
-*                    This parameter can be one of the following values:
-*                       - DAC_Align_8b_R: 8bit right data alignement selected
-*                       - DAC_Align_12b_L: 12bit left data alignement selected
-*                       - DAC_Align_12b_R: 12bit right data alignement selected
-*                  - Data2: Data for DAC Channel2 to be loaded in the selected data 
-*                    holding register.
-*                  - Data1: Data for DAC Channel1 to be loaded in the selected data 
-*                    holding register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DAC_SetDualChannelData(u32 DAC_Align, u16 Data2, u16 Data1)
-{
-  u32 data = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data1));
-  assert_param(IS_DAC_DATA(Data2));
-  
-  /* Calculate and set dual DAC data holding register value */
-  if (DAC_Align == DAC_Align_8b_R)
-  {
-    data = ((u32)Data2 &lt;&lt; 8) | Data1; 
-  }
-  else
-  {
-    data = ((u32)Data2 &lt;&lt; 16) | Data1;
-  }
-
-  /* Set the dual DAC selected data holding register */
-  *((vu32 *)(DAC_BASE + DHR12RD_Offset + DAC_Align)) = data;
-}
-
-/*******************************************************************************
-* Function Name  : DAC_GetDataOutputValue
-* Description    : Returns the last data output value of the selected DAC cahnnel.
-* Input            - DAC_Channel: the selected DAC channel. 
-*                    This parameter can be one of the following values:
-*                       - DAC_Channel_1: DAC Channel1 selected
-*                       - DAC_Channel_2: DAC Channel2 selected
-* Output         : None
-* Return         : The selected DAC channel data output value.
-*******************************************************************************/
-u16 DAC_GetDataOutputValue(u32 DAC_Channel)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-
-  /* Returns the DAC channel data output register value */
-  return (u16) (*(vu32*)(DAC_BASE + DOR_Offset + ((u32)DAC_Channel &gt;&gt; 2)));
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_dac.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the DAC firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_dac.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* DAC EN mask */
+#define CR_EN_Set                  ((u32)0x00000001)
+
+/* DAC DMAEN mask */
+#define CR_DMAEN_Set               ((u32)0x00001000)
+
+/* CR register Mask */
+#define CR_CLEAR_Mask              ((u32)0x00000FFE)
+
+/* DAC SWTRIG mask */
+#define SWTRIGR_SWTRIG_Set         ((u32)0x00000001)
+
+/* DAC Dual Channels SWTRIG masks */
+#define DUAL_SWTRIG_Set            ((u32)0x00000003)
+#define DUAL_SWTRIG_Reset          ((u32)0xFFFFFFFC)
+
+/* DHR registers offsets */
+#define DHR12R1_Offset             ((u32)0x00000008)
+#define DHR12R2_Offset             ((u32)0x00000014)
+#define DHR12RD_Offset             ((u32)0x00000020)
+
+/* DOR register offset */
+#define DOR_Offset                 ((u32)0x0000002C)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : DAC_DeInit
+* Description    : Deinitializes the DAC peripheral registers to their default
+*                  reset values.
+* Input          : None.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_DeInit(void)
+{
+  /* Enable DAC reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
+  /* Release DAC from reset state */
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
+}
+
+/*******************************************************************************
+* Function Name  : DAC_Init
+* Description    : Initializes the DAC peripheral according to the specified 
+*                  parameters in the DAC_InitStruct.
+* Input          : - DAC_Channel: the selected DAC channel. 
+*                    This parameter can be one of the following values:
+*                       - DAC_Channel_1: DAC Channel1 selected
+*                       - DAC_Channel_2: DAC Channel2 selected
+*                  - DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
+*                    contains the configuration information for the specified
+*                    DAC channel.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_Init(u32 DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
+{
+  u32 tmpreg1 = 0, tmpreg2 = 0;
+
+  /* Check the DAC parameters */
+  assert_param(IS_DAC_TRIGGER(DAC_InitStruct-&gt;DAC_Trigger));
+  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct-&gt;DAC_WaveGeneration));
+  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude));
+  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct-&gt;DAC_OutputBuffer));
+
+/*---------------------------- DAC CR Configuration --------------------------*/
+  /* Get the DAC CR value */
+  tmpreg1 = DAC-&gt;CR;
+  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
+  tmpreg1 &amp;= ~(CR_CLEAR_Mask &lt;&lt; DAC_Channel);
+  /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
+     mask/amplitude for wave genration */
+  /* Set TSELx and TENx bits according to DAC_Trigger value */
+  /* Set WAVEx bits according to DAC_WaveGeneration value */
+  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
+  /* Set BOFFx bit according to DAC_OutputBuffer value */   
+  tmpreg2 = (DAC_InitStruct-&gt;DAC_Trigger | DAC_InitStruct-&gt;DAC_WaveGeneration |
+             DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct-&gt;DAC_OutputBuffer);
+  /* Calculate CR register value depending on DAC_Channel */
+  tmpreg1 |= tmpreg2 &lt;&lt; DAC_Channel;
+  /* Write to DAC CR */
+  DAC-&gt;CR = tmpreg1;
+}
+
+/*******************************************************************************
+* Function Name  : DAC_StructInit
+* Description    : Fills each DAC_InitStruct member with its default value.
+* Input          : - DAC_InitStruct : pointer to a DAC_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
+{
+/*--------------- Reset DAC init structure parameters values -----------------*/
+  /* Initialize the DAC_Trigger member */
+  DAC_InitStruct-&gt;DAC_Trigger = DAC_Trigger_None;
+
+  /* Initialize the DAC_WaveGeneration member */
+  DAC_InitStruct-&gt;DAC_WaveGeneration = DAC_WaveGeneration_None;
+
+  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
+  DAC_InitStruct-&gt;DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
+
+  /* Initialize the DAC_OutputBuffer member */
+  DAC_InitStruct-&gt;DAC_OutputBuffer = DAC_OutputBuffer_Enable;
+}
+
+/*******************************************************************************
+* Function Name  : DAC_Cmd
+* Description    : Enables or disables the specified DAC channel.
+* Input            - DAC_Channel: the selected DAC channel. 
+*                    This parameter can be one of the following values:
+*                       - DAC_Channel_1: DAC Channel1 selected
+*                       - DAC_Channel_2: DAC Channel2 selected
+*                  - NewState: new state of the DAC channel. 
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_Cmd(u32 DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel */
+    DAC-&gt;CR |= CR_EN_Set &lt;&lt; DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected DAC channel */
+    DAC-&gt;CR &amp;= ~(CR_EN_Set &lt;&lt; DAC_Channel);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DAC_DMACmd
+* Description    : Enables or disables the specified DAC channel DMA request.
+* Input            - DAC_Channel: the selected DAC channel. 
+*                    This parameter can be one of the following values:
+*                       - DAC_Channel_1: DAC Channel1 selected
+*                       - DAC_Channel_2: DAC Channel2 selected
+*                  - NewState: new state of the selected DAC channel DMA request.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_DMACmd(u32 DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DAC channel DMA request */
+    DAC-&gt;CR |= CR_DMAEN_Set &lt;&lt; DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected DAC channel DMA request */
+    DAC-&gt;CR &amp;= ~(CR_DMAEN_Set &lt;&lt; DAC_Channel);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DAC_SoftwareTriggerCmd
+* Description    : Enables or disables the selected DAC channel software trigger.
+* Input            - DAC_Channel: the selected DAC channel. 
+*                    This parameter can be one of the following values:
+*                       - DAC_Channel_1: DAC Channel1 selected
+*                       - DAC_Channel_2: DAC Channel2 selected
+*                  - NewState: new state of the selected DAC channel software trigger.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_SoftwareTriggerCmd(u32 DAC_Channel, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for the selected DAC channel */
+    DAC-&gt;SWTRIGR |= SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4);
+  }
+  else
+  {
+    /* Disable software trigger for the selected DAC channel */
+    DAC-&gt;SWTRIGR &amp;= ~(SWTRIGR_SWTRIG_Set &lt;&lt; (DAC_Channel &gt;&gt; 4));
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DAC_DualSoftwareTriggerCmd
+* Description    : Enables or disables simultaneously the two DAC channels software
+*                  triggers.
+* Input            - NewState: new state of the DAC channels software triggers.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable software trigger for both DAC channels */
+    DAC-&gt;SWTRIGR |= DUAL_SWTRIG_Set ;
+  }
+  else
+  {
+    /* Disable software trigger for both DAC channels */
+    DAC-&gt;SWTRIGR &amp;= DUAL_SWTRIG_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DAC_WaveGenerationCmd
+* Description    : Enables or disables the selected DAC channel wave generation.
+* Input            - DAC_Channel: the selected DAC channel. 
+*                    This parameter can be one of the following values:
+*                       - DAC_Channel_1: DAC Channel1 selected
+*                       - DAC_Channel_2: DAC Channel2 selected
+*                  - DAC_Wave: Specifies the wave type to enable or disable.
+*                    This parameter can be one of the following values:
+*                       - DAC_Wave_Noise: noise wave generation
+*                       - DAC_Wave_Triangle: triangle wave generation
+*                  - NewState: new state of the selected DAC channel wave generation.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_WaveGenerationCmd(u32 DAC_Channel, u32 DAC_Wave, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+  assert_param(IS_DAC_WAVE(DAC_Wave)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected wave generation for the selected DAC channel */
+    DAC-&gt;CR |= DAC_Wave &lt;&lt; DAC_Channel;
+  }
+  else
+  {
+    /* Disable the selected wave generation for the selected DAC channel */
+    DAC-&gt;CR &amp;= ~(DAC_Wave &lt;&lt; DAC_Channel);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DAC_SetChannel1Data
+* Description    : Set the specified data holding register value for DAC channel1.
+* Input          : - DAC_Align: Specifies the data alignement for DAC channel1.
+*                    This parameter can be one of the following values:
+*                       - DAC_Align_8b_R: 8bit right data alignement selected
+*                       - DAC_Align_12b_L: 12bit left data alignement selected
+*                       - DAC_Align_12b_R: 12bit right data alignement selected
+*                  - Data : Data to be loaded in the selected data holding 
+*                    register.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_SetChannel1Data(u32 DAC_Align, u16 Data)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+
+  /* Set the DAC channel1 selected data holding register */
+  *((vu32 *)(DAC_BASE + DHR12R1_Offset + DAC_Align)) = (u32)Data;
+}
+
+/*******************************************************************************
+* Function Name  : DAC_SetChannel2Data
+* Description    : Set the specified data holding register value for DAC channel2.
+* Input          : - DAC_Align: Specifies the data alignement for DAC channel2.
+*                    This parameter can be one of the following values:
+*                       - DAC_Align_8b_R: 8bit right data alignement selected
+*                       - DAC_Align_12b_L: 12bit left data alignement selected
+*                       - DAC_Align_12b_R: 12bit right data alignement selected
+*                  - Data : Data to be loaded in the selected data holding 
+*                    register.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_SetChannel2Data(u32 DAC_Align, u16 Data)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data));
+
+  /* Set the DAC channel2 selected data holding register */
+  *((vu32 *)(DAC_BASE + DHR12R2_Offset + DAC_Align)) = (u32)Data;
+}
+
+/*******************************************************************************
+* Function Name  : DAC_SetDualChannelData
+* Description    : Set the specified data holding register value for dual channel
+*                  DAC.
+* Input          : - DAC_Align: Specifies the data alignement for dual channel DAC.
+*                    This parameter can be one of the following values:
+*                       - DAC_Align_8b_R: 8bit right data alignement selected
+*                       - DAC_Align_12b_L: 12bit left data alignement selected
+*                       - DAC_Align_12b_R: 12bit right data alignement selected
+*                  - Data2: Data for DAC Channel2 to be loaded in the selected data 
+*                    holding register.
+*                  - Data1: Data for DAC Channel1 to be loaded in the selected data 
+*                    holding register.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DAC_SetDualChannelData(u32 DAC_Align, u16 Data2, u16 Data1)
+{
+  u32 data = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DAC_ALIGN(DAC_Align));
+  assert_param(IS_DAC_DATA(Data1));
+  assert_param(IS_DAC_DATA(Data2));
+  
+  /* Calculate and set dual DAC data holding register value */
+  if (DAC_Align == DAC_Align_8b_R)
+  {
+    data = ((u32)Data2 &lt;&lt; 8) | Data1; 
+  }
+  else
+  {
+    data = ((u32)Data2 &lt;&lt; 16) | Data1;
+  }
+
+  /* Set the dual DAC selected data holding register */
+  *((vu32 *)(DAC_BASE + DHR12RD_Offset + DAC_Align)) = data;
+}
+
+/*******************************************************************************
+* Function Name  : DAC_GetDataOutputValue
+* Description    : Returns the last data output value of the selected DAC cahnnel.
+* Input            - DAC_Channel: the selected DAC channel. 
+*                    This parameter can be one of the following values:
+*                       - DAC_Channel_1: DAC Channel1 selected
+*                       - DAC_Channel_2: DAC Channel2 selected
+* Output         : None
+* Return         : The selected DAC channel data output value.
+*******************************************************************************/
+u16 DAC_GetDataOutputValue(u32 DAC_Channel)
+{
+  /* Check the parameters */
+  assert_param(IS_DAC_CHANNEL(DAC_Channel));
+
+  /* Returns the DAC channel data output register value */
+  return (u16) (*(vu32*)(DAC_BASE + DOR_Offset + ((u32)DAC_Channel &gt;&gt; 2)));
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dbgmcu.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,97 +1,97 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dbgmcu.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the DBGMCU firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_dbgmcu.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define IDCODE_DEVID_Mask    ((u32)0x00000FFF)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : DBGMCU_GetREVID
-* Description    : Returns the device revision identifier.
-* Input          : None
-* Output         : None
-* Return         : Device revision identifier
-*******************************************************************************/
-u32 DBGMCU_GetREVID(void)
-{
-   return(DBGMCU-&gt;IDCODE &gt;&gt; 16);
-}
-
-/*******************************************************************************
-* Function Name  : DBGMCU_GetDEVID
-* Description    : Returns the device identifier.
-* Input          : None
-* Output         : None
-* Return         : Device identifier
-*******************************************************************************/
-u32 DBGMCU_GetDEVID(void)
-{
-   return(DBGMCU-&gt;IDCODE &amp; IDCODE_DEVID_Mask);
-}
-
-/*******************************************************************************
-* Function Name  : DBGMCU_Config
-* Description    : Configures the specified peripheral and low power mode behavior
-*                  when the MCU under Debug mode.
-* Input          : - DBGMCU_Periph: specifies the peripheral and low power mode.
-*                    This parameter can be any combination of the following values:
-*                       - DBGMCU_SLEEP: Keep debugger connection during SLEEP mode              
-*                       - DBGMCU_STOP: Keep debugger connection during STOP mode               
-*                       - DBGMCU_STANDBY: Keep debugger connection during STANDBY mode            
-*                       - DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted          
-*                       - DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted          
-*                       - DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted          
-*                       - DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted          
-*                       - DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted          
-*                       - DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted          
-*                       - DBGMCU_CAN_STOP: Debug CAN stopped when Core is halted           
-*                       - DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped
-*                                                    when Core is halted
-*                       - DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped
-*                                                    when Core is halted
-*                       - DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted          
-*                       - DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted          
-*                       - DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted          
-*                       - DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted          
-*                  - NewState: new state of the specified peripheral in Debug mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DBGMCU_Config(u32 DBGMCU_Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    DBGMCU-&gt;CR |= DBGMCU_Periph;
-  }
-  else
-  {
-    DBGMCU-&gt;CR &amp;= ~DBGMCU_Periph;
-  }
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_dbgmcu.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the DBGMCU firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_dbgmcu.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define IDCODE_DEVID_Mask    ((u32)0x00000FFF)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : DBGMCU_GetREVID
+* Description    : Returns the device revision identifier.
+* Input          : None
+* Output         : None
+* Return         : Device revision identifier
+*******************************************************************************/
+u32 DBGMCU_GetREVID(void)
+{
+   return(DBGMCU-&gt;IDCODE &gt;&gt; 16);
+}
+
+/*******************************************************************************
+* Function Name  : DBGMCU_GetDEVID
+* Description    : Returns the device identifier.
+* Input          : None
+* Output         : None
+* Return         : Device identifier
+*******************************************************************************/
+u32 DBGMCU_GetDEVID(void)
+{
+   return(DBGMCU-&gt;IDCODE &amp; IDCODE_DEVID_Mask);
+}
+
+/*******************************************************************************
+* Function Name  : DBGMCU_Config
+* Description    : Configures the specified peripheral and low power mode behavior
+*                  when the MCU under Debug mode.
+* Input          : - DBGMCU_Periph: specifies the peripheral and low power mode.
+*                    This parameter can be any combination of the following values:
+*                       - DBGMCU_SLEEP: Keep debugger connection during SLEEP mode              
+*                       - DBGMCU_STOP: Keep debugger connection during STOP mode               
+*                       - DBGMCU_STANDBY: Keep debugger connection during STANDBY mode            
+*                       - DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted          
+*                       - DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted          
+*                       - DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted          
+*                       - DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted          
+*                       - DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted          
+*                       - DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted          
+*                       - DBGMCU_CAN_STOP: Debug CAN stopped when Core is halted           
+*                       - DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped
+*                                                    when Core is halted
+*                       - DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped
+*                                                    when Core is halted
+*                       - DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted          
+*                       - DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted          
+*                       - DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted          
+*                       - DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted          
+*                  - NewState: new state of the specified peripheral in Debug mode.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DBGMCU_Config(u32 DBGMCU_Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    DBGMCU-&gt;CR |= DBGMCU_Periph;
+  }
+  else
+  {
+    DBGMCU-&gt;CR &amp;= ~DBGMCU_Periph;
+  }
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_dma.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,678 +1,678 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_dma.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the DMA firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_dma.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* DMA ENABLE mask */
-#define CCR_ENABLE_Set          ((u32)0x00000001)
-#define CCR_ENABLE_Reset        ((u32)0xFFFFFFFE)
-
-/* DMA1 Channelx interrupt pending bit masks */
-#define DMA1_Channel1_IT_Mask    ((u32)0x0000000F)
-#define DMA1_Channel2_IT_Mask    ((u32)0x000000F0)
-#define DMA1_Channel3_IT_Mask    ((u32)0x00000F00)
-#define DMA1_Channel4_IT_Mask    ((u32)0x0000F000)
-#define DMA1_Channel5_IT_Mask    ((u32)0x000F0000)
-#define DMA1_Channel6_IT_Mask    ((u32)0x00F00000)
-#define DMA1_Channel7_IT_Mask    ((u32)0x0F000000)
-
-/* DMA2 Channelx interrupt pending bit masks */
-#define DMA2_Channel1_IT_Mask    ((u32)0x0000000F)
-#define DMA2_Channel2_IT_Mask    ((u32)0x000000F0)
-#define DMA2_Channel3_IT_Mask    ((u32)0x00000F00)
-#define DMA2_Channel4_IT_Mask    ((u32)0x0000F000)
-#define DMA2_Channel5_IT_Mask    ((u32)0x000F0000)
-
-/* DMA2 FLAG mask */
-#define FLAG_Mask                ((u32)0x10000000)
-
-/* DMA registers Masks */
-#define CCR_CLEAR_Mask           ((u32)0xFFFF800F)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : DMA_DeInit
-* Description    : Deinitializes the DMAy Channelx registers to their default reset
-*                  values.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-
-  /* Disable the selected DMAy Channelx */
-  DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
-
-  /* Reset DMAy Channelx control register */
-  DMAy_Channelx-&gt;CCR  = 0;
-  
-  /* Reset DMAy Channelx remaining bytes register */
-  DMAy_Channelx-&gt;CNDTR = 0;
-  
-  /* Reset DMAy Channelx peripheral address register */
-  DMAy_Channelx-&gt;CPAR  = 0;
-  
-  /* Reset DMAy Channelx memory address register */
-  DMAy_Channelx-&gt;CMAR = 0;
-
-  switch (*(u32*)&amp;DMAy_Channelx)
-  {
-    case DMA1_Channel1_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel1 */
-      DMA1-&gt;IFCR |= DMA1_Channel1_IT_Mask;
-      break;
-
-    case DMA1_Channel2_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel2 */
-      DMA1-&gt;IFCR |= DMA1_Channel2_IT_Mask;
-      break;
-
-    case DMA1_Channel3_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel3 */
-      DMA1-&gt;IFCR |= DMA1_Channel3_IT_Mask;
-      break;
-
-    case DMA1_Channel4_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel4 */
-      DMA1-&gt;IFCR |= DMA1_Channel4_IT_Mask;
-      break;
-
-    case DMA1_Channel5_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel5 */
-      DMA1-&gt;IFCR |= DMA1_Channel5_IT_Mask;
-      break;
-
-    case DMA1_Channel6_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel6 */
-      DMA1-&gt;IFCR |= DMA1_Channel6_IT_Mask;
-      break;
-
-    case DMA1_Channel7_BASE:
-      /* Reset interrupt pending bits for DMA1 Channel7 */
-      DMA1-&gt;IFCR |= DMA1_Channel7_IT_Mask;
-      break;
-
-    case DMA2_Channel1_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel1 */
-      DMA2-&gt;IFCR |= DMA2_Channel1_IT_Mask;
-      break;
-
-    case DMA2_Channel2_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel2 */
-      DMA2-&gt;IFCR |= DMA2_Channel2_IT_Mask;
-      break;
-
-    case DMA2_Channel3_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel3 */
-      DMA2-&gt;IFCR |= DMA2_Channel3_IT_Mask;
-      break;
-
-    case DMA2_Channel4_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel4 */
-      DMA2-&gt;IFCR |= DMA2_Channel4_IT_Mask;
-      break;
-
-    case DMA2_Channel5_BASE:
-      /* Reset interrupt pending bits for DMA2 Channel5 */
-      DMA2-&gt;IFCR |= DMA2_Channel5_IT_Mask;
-      break;
-      
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_Init
-* Description    : Initializes the DMAy Channelx according to the specified
-*                  parameters in the DMA_InitStruct.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-*                  - DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    DMA Channel.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_DMA_DIR(DMA_InitStruct-&gt;DMA_DIR));
-  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct-&gt;DMA_BufferSize));
-  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct-&gt;DMA_PeripheralInc));
-  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct-&gt;DMA_MemoryInc));   
-  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct-&gt;DMA_PeripheralDataSize));
-  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct-&gt;DMA_MemoryDataSize));
-  assert_param(IS_DMA_MODE(DMA_InitStruct-&gt;DMA_Mode));
-  assert_param(IS_DMA_PRIORITY(DMA_InitStruct-&gt;DMA_Priority));
-  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct-&gt;DMA_M2M));
-
-/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
-  /* Get the DMAy_Channelx CCR value */
-  tmpreg = DMAy_Channelx-&gt;CCR;
-  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
-  tmpreg &amp;= CCR_CLEAR_Mask;
-  /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
-  /* Set DIR bit according to DMA_DIR value */
-  /* Set CIRC bit according to DMA_Mode value */
-  /* Set PINC bit according to DMA_PeripheralInc value */
-  /* Set MINC bit according to DMA_MemoryInc value */
-  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
-  /* Set MSIZE bits according to DMA_MemoryDataSize value */
-  /* Set PL bits according to DMA_Priority value */
-  /* Set the MEM2MEM bit according to DMA_M2M value */
-  tmpreg |= DMA_InitStruct-&gt;DMA_DIR | DMA_InitStruct-&gt;DMA_Mode |
-            DMA_InitStruct-&gt;DMA_PeripheralInc | DMA_InitStruct-&gt;DMA_MemoryInc |
-            DMA_InitStruct-&gt;DMA_PeripheralDataSize | DMA_InitStruct-&gt;DMA_MemoryDataSize |
-            DMA_InitStruct-&gt;DMA_Priority | DMA_InitStruct-&gt;DMA_M2M;
-  /* Write to DMAy Channelx CCR */
-  DMAy_Channelx-&gt;CCR = tmpreg;
-
-/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
-  /* Write to DMAy Channelx CNDTR */
-  DMAy_Channelx-&gt;CNDTR = DMA_InitStruct-&gt;DMA_BufferSize;
-
-/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
-  /* Write to DMAy Channelx CPAR */
-  DMAy_Channelx-&gt;CPAR = DMA_InitStruct-&gt;DMA_PeripheralBaseAddr;
-
-/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
-  /* Write to DMAy Channelx CMAR */
-  DMAy_Channelx-&gt;CMAR = DMA_InitStruct-&gt;DMA_MemoryBaseAddr;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_StructInit
-* Description    : Fills each DMA_InitStruct member with its default value.
-* Input          : - DMA_InitStruct : pointer to a DMA_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
-{
-/*-------------- Reset DMA init structure parameters values ------------------*/
-  /* Initialize the DMA_PeripheralBaseAddr member */
-  DMA_InitStruct-&gt;DMA_PeripheralBaseAddr = 0;
-
-  /* Initialize the DMA_MemoryBaseAddr member */
-  DMA_InitStruct-&gt;DMA_MemoryBaseAddr = 0;
-
-  /* Initialize the DMA_DIR member */
-  DMA_InitStruct-&gt;DMA_DIR = DMA_DIR_PeripheralSRC;
-
-  /* Initialize the DMA_BufferSize member */
-  DMA_InitStruct-&gt;DMA_BufferSize = 0;
-
-  /* Initialize the DMA_PeripheralInc member */
-  DMA_InitStruct-&gt;DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-
-  /* Initialize the DMA_MemoryInc member */
-  DMA_InitStruct-&gt;DMA_MemoryInc = DMA_MemoryInc_Disable;
-
-  /* Initialize the DMA_PeripheralDataSize member */
-  DMA_InitStruct-&gt;DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
-
-  /* Initialize the DMA_MemoryDataSize member */
-  DMA_InitStruct-&gt;DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
-
-  /* Initialize the DMA_Mode member */
-  DMA_InitStruct-&gt;DMA_Mode = DMA_Mode_Normal;
-
-  /* Initialize the DMA_Priority member */
-  DMA_InitStruct-&gt;DMA_Priority = DMA_Priority_Low;
-
-  /* Initialize the DMA_M2M member */
-  DMA_InitStruct-&gt;DMA_M2M = DMA_M2M_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_Cmd
-* Description    : Enables or disables the specified DMAy Channelx.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-*                  - NewState: new state of the DMAy Channelx. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DMAy Channelx */
-    DMAy_Channelx-&gt;CCR |= CCR_ENABLE_Set;
-  }
-  else
-  {
-    /* Disable the selected DMAy Channelx */
-    DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_ITConfig
-* Description    : Enables or disables the specified DMAy Channelx interrupts.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-*                  - DMA_IT: specifies the DMA interrupts sources to be enabled
-*                    or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - DMA_IT_TC:  Transfer complete interrupt mask
-*                       - DMA_IT_HT:  Half transfer interrupt mask
-*                       - DMA_IT_TE:  Transfer error interrupt mask
-*                  - NewState: new state of the specified DMA interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, u32 DMA_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DMA interrupts */
-    DMAy_Channelx-&gt;CCR |= DMA_IT;
-  }
-  else
-  {
-    /* Disable the selected DMA interrupts */
-    DMAy_Channelx-&gt;CCR &amp;= ~DMA_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_GetCurrDataCounter
-* Description    : Returns the number of remaining data units in the current
-*                  DMAy Channelx transfer.
-* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
-*                    DMA Channel.
-* Output         : None
-* Return         : The number of remaining data units in the current DMAy Channelx
-*                  transfer.
-*******************************************************************************/
-u16 DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-
-  /* Return the number of remaining data units for DMAy Channelx */
-  return ((u16)(DMAy_Channelx-&gt;CNDTR));
-}
-
-/*******************************************************************************
-* Function Name  : DMA_GetFlagStatus
-* Description    : Checks whether the specified DMAy Channelx flag is set or not.
-* Input          : - DMA_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
-*                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
-*                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
-*                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
-*                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
-*                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
-*                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
-*                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
-*                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
-*                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
-*                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
-*                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
-*                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
-*                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
-*                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
-*                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
-*                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
-*                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
-*                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
-*                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
-*                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
-*                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
-*                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
-*                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
-*                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
-*                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
-*                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
-*                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
-*                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
-*                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
-*                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
-*                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
-*                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
-*                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
-*                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
-*                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
-*                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
-*                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
-*                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
-*                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
-*                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
-*                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
-*                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
-*                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
-*                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
-*                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
-*                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
-*                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
-* Output         : None
-* Return         : The new state of DMA_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus DMA_GetFlagStatus(u32 DMA_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
-
-  /* Calculate the used DMA */
-  if ((DMA_FLAG &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Get DMA2 ISR register value */
-    tmpreg = DMA2-&gt;ISR ;
-  }
-  else
-  {
-    /* Get DMA1 ISR register value */
-    tmpreg = DMA1-&gt;ISR ;
-  }
-
-  /* Check the status of the specified DMA flag */
-  if ((tmpreg &amp; DMA_FLAG) != (u32)RESET)
-  {
-    /* DMA_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DMA_FLAG is reset */
-    bitstatus = RESET;
-  }
-  
-  /* Return the DMA_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_ClearFlag
-* Description    : Clears the DMAy Channelx's pending flags.
-* Input          : - DMA_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination (for the same DMA) of 
-*                    the following values:
-*                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
-*                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
-*                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
-*                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
-*                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
-*                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
-*                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
-*                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
-*                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
-*                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
-*                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
-*                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
-*                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
-*                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
-*                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
-*                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
-*                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
-*                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
-*                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
-*                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
-*                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
-*                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
-*                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
-*                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
-*                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
-*                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
-*                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
-*                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
-*                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
-*                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
-*                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
-*                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
-*                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
-*                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
-*                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
-*                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
-*                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
-*                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
-*                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
-*                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
-*                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
-*                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
-*                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
-*                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
-*                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
-*                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
-*                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
-*                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_ClearFlag(u32 DMA_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
-
-  /* Calculate the used DMA */
-  if ((DMA_FLAG &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Clear the selected DMA flags */
-    DMA2-&gt;IFCR = DMA_FLAG;
-  }
-  else
-  {
-    /* Clear the selected DMA flags */
-    DMA1-&gt;IFCR = DMA_FLAG;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : DMA_GetITStatus
-* Description    : Checks whether the specified DMAy Channelx interrupt has 
-*                  occurred or not.
-* Input          : - DMA_IT: specifies the DMA interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
-*                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
-*                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
-*                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
-*                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
-*                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
-*                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
-*                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
-*                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
-*                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
-*                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
-*                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
-*                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
-*                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
-*                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
-*                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
-*                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
-*                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
-*                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
-*                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
-*                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
-*                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
-*                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
-*                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
-*                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
-*                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
-*                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
-*                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
-*                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
-*                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
-*                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
-*                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
-*                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
-*                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
-*                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
-*                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
-*                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
-*                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
-*                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
-*                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
-*                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
-*                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
-*                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
-*                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
-*                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
-*                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
-*                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
-*                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
-* Output         : None
-* Return         : The new state of DMA_IT (SET or RESET).
-*******************************************************************************/
-ITStatus DMA_GetITStatus(u32 DMA_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_GET_IT(DMA_IT));
-
-  /* Calculate the used DMA */
-  if ((DMA_IT &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Get DMA2 ISR register value */
-    tmpreg = DMA2-&gt;ISR ;
-  }
-  else
-  {
-    /* Get DMA1 ISR register value */
-    tmpreg = DMA1-&gt;ISR ;
-  }
-
-  /* Check the status of the specified DMA interrupt */
-  if ((tmpreg &amp; DMA_IT) != (u32)RESET)
-  {
-    /* DMA_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DMA_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the DMA_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : DMA_ClearITPendingBit
-* Description    : Clears the DMAy Channelx&#146;s interrupt pending bits.
-* Input          : - DMA_IT: specifies the DMA interrupt pending bit to clear.
-*                    This parameter can be any combination (for the same DMA) of
-*                    the following values:
-*                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
-*                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
-*                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
-*                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
-*                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
-*                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
-*                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
-*                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
-*                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
-*                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
-*                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
-*                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
-*                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
-*                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
-*                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
-*                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
-*                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
-*                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
-*                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
-*                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
-*                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
-*                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
-*                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
-*                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
-*                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
-*                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
-*                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
-*                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
-*                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
-*                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
-*                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
-*                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
-*                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
-*                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
-*                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
-*                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
-*                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
-*                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
-*                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
-*                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
-*                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
-*                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
-*                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
-*                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
-*                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
-*                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
-*                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
-*                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void DMA_ClearITPendingBit(u32 DMA_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
-
-  /* Calculate the used DMA */
-  if ((DMA_IT &amp; FLAG_Mask) != (u32)RESET)
-  {
-    /* Clear the selected DMA interrupt pending bits */
-    DMA2-&gt;IFCR = DMA_IT;
-  }
-  else
-  {
-    /* Clear the selected DMA interrupt pending bits */
-    DMA1-&gt;IFCR = DMA_IT;
-  }
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
-
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_dma.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the DMA firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_dma.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* DMA ENABLE mask */
+#define CCR_ENABLE_Set          ((u32)0x00000001)
+#define CCR_ENABLE_Reset        ((u32)0xFFFFFFFE)
+
+/* DMA1 Channelx interrupt pending bit masks */
+#define DMA1_Channel1_IT_Mask    ((u32)0x0000000F)
+#define DMA1_Channel2_IT_Mask    ((u32)0x000000F0)
+#define DMA1_Channel3_IT_Mask    ((u32)0x00000F00)
+#define DMA1_Channel4_IT_Mask    ((u32)0x0000F000)
+#define DMA1_Channel5_IT_Mask    ((u32)0x000F0000)
+#define DMA1_Channel6_IT_Mask    ((u32)0x00F00000)
+#define DMA1_Channel7_IT_Mask    ((u32)0x0F000000)
+
+/* DMA2 Channelx interrupt pending bit masks */
+#define DMA2_Channel1_IT_Mask    ((u32)0x0000000F)
+#define DMA2_Channel2_IT_Mask    ((u32)0x000000F0)
+#define DMA2_Channel3_IT_Mask    ((u32)0x00000F00)
+#define DMA2_Channel4_IT_Mask    ((u32)0x0000F000)
+#define DMA2_Channel5_IT_Mask    ((u32)0x000F0000)
+
+/* DMA2 FLAG mask */
+#define FLAG_Mask                ((u32)0x10000000)
+
+/* DMA registers Masks */
+#define CCR_CLEAR_Mask           ((u32)0xFFFF800F)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : DMA_DeInit
+* Description    : Deinitializes the DMAy Channelx registers to their default reset
+*                  values.
+* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and
+*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
+*                    DMA Channel.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+
+  /* Disable the selected DMAy Channelx */
+  DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
+
+  /* Reset DMAy Channelx control register */
+  DMAy_Channelx-&gt;CCR  = 0;
+  
+  /* Reset DMAy Channelx remaining bytes register */
+  DMAy_Channelx-&gt;CNDTR = 0;
+  
+  /* Reset DMAy Channelx peripheral address register */
+  DMAy_Channelx-&gt;CPAR  = 0;
+  
+  /* Reset DMAy Channelx memory address register */
+  DMAy_Channelx-&gt;CMAR = 0;
+
+  switch (*(u32*)&amp;DMAy_Channelx)
+  {
+    case DMA1_Channel1_BASE:
+      /* Reset interrupt pending bits for DMA1 Channel1 */
+      DMA1-&gt;IFCR |= DMA1_Channel1_IT_Mask;
+      break;
+
+    case DMA1_Channel2_BASE:
+      /* Reset interrupt pending bits for DMA1 Channel2 */
+      DMA1-&gt;IFCR |= DMA1_Channel2_IT_Mask;
+      break;
+
+    case DMA1_Channel3_BASE:
+      /* Reset interrupt pending bits for DMA1 Channel3 */
+      DMA1-&gt;IFCR |= DMA1_Channel3_IT_Mask;
+      break;
+
+    case DMA1_Channel4_BASE:
+      /* Reset interrupt pending bits for DMA1 Channel4 */
+      DMA1-&gt;IFCR |= DMA1_Channel4_IT_Mask;
+      break;
+
+    case DMA1_Channel5_BASE:
+      /* Reset interrupt pending bits for DMA1 Channel5 */
+      DMA1-&gt;IFCR |= DMA1_Channel5_IT_Mask;
+      break;
+
+    case DMA1_Channel6_BASE:
+      /* Reset interrupt pending bits for DMA1 Channel6 */
+      DMA1-&gt;IFCR |= DMA1_Channel6_IT_Mask;
+      break;
+
+    case DMA1_Channel7_BASE:
+      /* Reset interrupt pending bits for DMA1 Channel7 */
+      DMA1-&gt;IFCR |= DMA1_Channel7_IT_Mask;
+      break;
+
+    case DMA2_Channel1_BASE:
+      /* Reset interrupt pending bits for DMA2 Channel1 */
+      DMA2-&gt;IFCR |= DMA2_Channel1_IT_Mask;
+      break;
+
+    case DMA2_Channel2_BASE:
+      /* Reset interrupt pending bits for DMA2 Channel2 */
+      DMA2-&gt;IFCR |= DMA2_Channel2_IT_Mask;
+      break;
+
+    case DMA2_Channel3_BASE:
+      /* Reset interrupt pending bits for DMA2 Channel3 */
+      DMA2-&gt;IFCR |= DMA2_Channel3_IT_Mask;
+      break;
+
+    case DMA2_Channel4_BASE:
+      /* Reset interrupt pending bits for DMA2 Channel4 */
+      DMA2-&gt;IFCR |= DMA2_Channel4_IT_Mask;
+      break;
+
+    case DMA2_Channel5_BASE:
+      /* Reset interrupt pending bits for DMA2 Channel5 */
+      DMA2-&gt;IFCR |= DMA2_Channel5_IT_Mask;
+      break;
+      
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DMA_Init
+* Description    : Initializes the DMAy Channelx according to the specified
+*                  parameters in the DMA_InitStruct.
+* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
+*                    DMA Channel.
+*                  - DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
+*                    contains the configuration information for the specified
+*                    DMA Channel.
+* Output         : None
+* Return         : None
+******************************************************************************/
+void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_DMA_DIR(DMA_InitStruct-&gt;DMA_DIR));
+  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct-&gt;DMA_BufferSize));
+  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct-&gt;DMA_PeripheralInc));
+  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct-&gt;DMA_MemoryInc));   
+  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct-&gt;DMA_PeripheralDataSize));
+  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct-&gt;DMA_MemoryDataSize));
+  assert_param(IS_DMA_MODE(DMA_InitStruct-&gt;DMA_Mode));
+  assert_param(IS_DMA_PRIORITY(DMA_InitStruct-&gt;DMA_Priority));
+  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct-&gt;DMA_M2M));
+
+/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
+  /* Get the DMAy_Channelx CCR value */
+  tmpreg = DMAy_Channelx-&gt;CCR;
+  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
+  tmpreg &amp;= CCR_CLEAR_Mask;
+  /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
+  /* Set DIR bit according to DMA_DIR value */
+  /* Set CIRC bit according to DMA_Mode value */
+  /* Set PINC bit according to DMA_PeripheralInc value */
+  /* Set MINC bit according to DMA_MemoryInc value */
+  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
+  /* Set MSIZE bits according to DMA_MemoryDataSize value */
+  /* Set PL bits according to DMA_Priority value */
+  /* Set the MEM2MEM bit according to DMA_M2M value */
+  tmpreg |= DMA_InitStruct-&gt;DMA_DIR | DMA_InitStruct-&gt;DMA_Mode |
+            DMA_InitStruct-&gt;DMA_PeripheralInc | DMA_InitStruct-&gt;DMA_MemoryInc |
+            DMA_InitStruct-&gt;DMA_PeripheralDataSize | DMA_InitStruct-&gt;DMA_MemoryDataSize |
+            DMA_InitStruct-&gt;DMA_Priority | DMA_InitStruct-&gt;DMA_M2M;
+  /* Write to DMAy Channelx CCR */
+  DMAy_Channelx-&gt;CCR = tmpreg;
+
+/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
+  /* Write to DMAy Channelx CNDTR */
+  DMAy_Channelx-&gt;CNDTR = DMA_InitStruct-&gt;DMA_BufferSize;
+
+/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
+  /* Write to DMAy Channelx CPAR */
+  DMAy_Channelx-&gt;CPAR = DMA_InitStruct-&gt;DMA_PeripheralBaseAddr;
+
+/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
+  /* Write to DMAy Channelx CMAR */
+  DMAy_Channelx-&gt;CMAR = DMA_InitStruct-&gt;DMA_MemoryBaseAddr;
+}
+
+/*******************************************************************************
+* Function Name  : DMA_StructInit
+* Description    : Fills each DMA_InitStruct member with its default value.
+* Input          : - DMA_InitStruct : pointer to a DMA_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
+{
+/*-------------- Reset DMA init structure parameters values ------------------*/
+  /* Initialize the DMA_PeripheralBaseAddr member */
+  DMA_InitStruct-&gt;DMA_PeripheralBaseAddr = 0;
+
+  /* Initialize the DMA_MemoryBaseAddr member */
+  DMA_InitStruct-&gt;DMA_MemoryBaseAddr = 0;
+
+  /* Initialize the DMA_DIR member */
+  DMA_InitStruct-&gt;DMA_DIR = DMA_DIR_PeripheralSRC;
+
+  /* Initialize the DMA_BufferSize member */
+  DMA_InitStruct-&gt;DMA_BufferSize = 0;
+
+  /* Initialize the DMA_PeripheralInc member */
+  DMA_InitStruct-&gt;DMA_PeripheralInc = DMA_PeripheralInc_Disable;
+
+  /* Initialize the DMA_MemoryInc member */
+  DMA_InitStruct-&gt;DMA_MemoryInc = DMA_MemoryInc_Disable;
+
+  /* Initialize the DMA_PeripheralDataSize member */
+  DMA_InitStruct-&gt;DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
+
+  /* Initialize the DMA_MemoryDataSize member */
+  DMA_InitStruct-&gt;DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
+
+  /* Initialize the DMA_Mode member */
+  DMA_InitStruct-&gt;DMA_Mode = DMA_Mode_Normal;
+
+  /* Initialize the DMA_Priority member */
+  DMA_InitStruct-&gt;DMA_Priority = DMA_Priority_Low;
+
+  /* Initialize the DMA_M2M member */
+  DMA_InitStruct-&gt;DMA_M2M = DMA_M2M_Disable;
+}
+
+/*******************************************************************************
+* Function Name  : DMA_Cmd
+* Description    : Enables or disables the specified DMAy Channelx.
+* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
+*                    DMA Channel.
+*                  - NewState: new state of the DMAy Channelx. 
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMAy Channelx */
+    DMAy_Channelx-&gt;CCR |= CCR_ENABLE_Set;
+  }
+  else
+  {
+    /* Disable the selected DMAy Channelx */
+    DMAy_Channelx-&gt;CCR &amp;= CCR_ENABLE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DMA_ITConfig
+* Description    : Enables or disables the specified DMAy Channelx interrupts.
+* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
+*                    DMA Channel.
+*                  - DMA_IT: specifies the DMA interrupts sources to be enabled
+*                    or disabled. 
+*                    This parameter can be any combination of the following values:
+*                       - DMA_IT_TC:  Transfer complete interrupt mask
+*                       - DMA_IT_HT:  Half transfer interrupt mask
+*                       - DMA_IT_TE:  Transfer error interrupt mask
+*                  - NewState: new state of the specified DMA interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, u32 DMA_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected DMA interrupts */
+    DMAy_Channelx-&gt;CCR |= DMA_IT;
+  }
+  else
+  {
+    /* Disable the selected DMA interrupts */
+    DMAy_Channelx-&gt;CCR &amp;= ~DMA_IT;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DMA_GetCurrDataCounter
+* Description    : Returns the number of remaining data units in the current
+*                  DMAy Channelx transfer.
+* Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
+*                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
+*                    DMA Channel.
+* Output         : None
+* Return         : The number of remaining data units in the current DMAy Channelx
+*                  transfer.
+*******************************************************************************/
+u16 DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
+
+  /* Return the number of remaining data units for DMAy Channelx */
+  return ((u16)(DMAy_Channelx-&gt;CNDTR));
+}
+
+/*******************************************************************************
+* Function Name  : DMA_GetFlagStatus
+* Description    : Checks whether the specified DMAy Channelx flag is set or not.
+* Input          : - DMA_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
+*                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
+*                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
+*                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
+*                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
+*                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
+*                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
+*                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
+*                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
+*                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
+*                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
+*                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
+*                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
+*                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
+*                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
+*                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
+*                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
+*                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
+*                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
+*                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
+*                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
+*                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
+*                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
+*                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
+*                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
+*                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
+*                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
+*                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
+*                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
+*                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
+*                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
+*                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
+*                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
+*                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
+*                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
+*                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
+*                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
+*                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
+*                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
+*                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
+*                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
+*                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
+*                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
+*                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
+*                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
+*                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
+*                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
+*                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
+* Output         : None
+* Return         : The new state of DMA_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus DMA_GetFlagStatus(u32 DMA_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
+
+  /* Calculate the used DMA */
+  if ((DMA_FLAG &amp; FLAG_Mask) != (u32)RESET)
+  {
+    /* Get DMA2 ISR register value */
+    tmpreg = DMA2-&gt;ISR ;
+  }
+  else
+  {
+    /* Get DMA1 ISR register value */
+    tmpreg = DMA1-&gt;ISR ;
+  }
+
+  /* Check the status of the specified DMA flag */
+  if ((tmpreg &amp; DMA_FLAG) != (u32)RESET)
+  {
+    /* DMA_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMA_FLAG is reset */
+    bitstatus = RESET;
+  }
+  
+  /* Return the DMA_FLAG status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : DMA_ClearFlag
+* Description    : Clears the DMAy Channelx's pending flags.
+* Input          : - DMA_FLAG: specifies the flag to clear.
+*                    This parameter can be any combination (for the same DMA) of 
+*                    the following values:
+*                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
+*                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
+*                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
+*                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
+*                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
+*                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
+*                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
+*                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
+*                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
+*                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
+*                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
+*                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
+*                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
+*                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
+*                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
+*                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
+*                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
+*                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
+*                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
+*                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
+*                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
+*                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
+*                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
+*                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
+*                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
+*                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
+*                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
+*                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
+*                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
+*                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
+*                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
+*                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
+*                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
+*                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
+*                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
+*                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
+*                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
+*                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
+*                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
+*                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
+*                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
+*                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
+*                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
+*                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
+*                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
+*                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
+*                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
+*                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA_ClearFlag(u32 DMA_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
+
+  /* Calculate the used DMA */
+  if ((DMA_FLAG &amp; FLAG_Mask) != (u32)RESET)
+  {
+    /* Clear the selected DMA flags */
+    DMA2-&gt;IFCR = DMA_FLAG;
+  }
+  else
+  {
+    /* Clear the selected DMA flags */
+    DMA1-&gt;IFCR = DMA_FLAG;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : DMA_GetITStatus
+* Description    : Checks whether the specified DMAy Channelx interrupt has 
+*                  occurred or not.
+* Input          : - DMA_IT: specifies the DMA interrupt source to check. 
+*                    This parameter can be one of the following values:
+*                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
+*                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
+*                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
+*                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
+*                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
+*                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
+*                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
+*                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
+*                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
+*                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
+*                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
+*                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
+*                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
+*                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
+*                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
+*                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
+*                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
+*                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
+*                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
+*                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
+*                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
+*                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
+*                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
+*                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
+*                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
+*                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
+*                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
+*                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
+*                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
+*                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
+*                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
+*                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
+*                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
+*                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
+*                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
+*                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
+*                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
+*                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
+*                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
+*                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
+*                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
+*                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
+*                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
+*                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
+*                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
+*                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
+*                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
+*                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
+* Output         : None
+* Return         : The new state of DMA_IT (SET or RESET).
+*******************************************************************************/
+ITStatus DMA_GetITStatus(u32 DMA_IT)
+{
+  ITStatus bitstatus = RESET;
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_DMA_GET_IT(DMA_IT));
+
+  /* Calculate the used DMA */
+  if ((DMA_IT &amp; FLAG_Mask) != (u32)RESET)
+  {
+    /* Get DMA2 ISR register value */
+    tmpreg = DMA2-&gt;ISR ;
+  }
+  else
+  {
+    /* Get DMA1 ISR register value */
+    tmpreg = DMA1-&gt;ISR ;
+  }
+
+  /* Check the status of the specified DMA interrupt */
+  if ((tmpreg &amp; DMA_IT) != (u32)RESET)
+  {
+    /* DMA_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* DMA_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the DMA_IT status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : DMA_ClearITPendingBit
+* Description    : Clears the DMAy Channelx's interrupt pending bits.
+* Input          : - DMA_IT: specifies the DMA interrupt pending bit to clear.
+*                    This parameter can be any combination (for the same DMA) of
+*                    the following values:
+*                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
+*                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
+*                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
+*                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
+*                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
+*                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
+*                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
+*                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
+*                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
+*                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
+*                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
+*                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
+*                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
+*                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
+*                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
+*                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
+*                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
+*                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
+*                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
+*                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
+*                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
+*                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
+*                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
+*                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
+*                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
+*                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
+*                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
+*                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
+*                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
+*                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
+*                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
+*                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
+*                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
+*                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
+*                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
+*                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
+*                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
+*                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
+*                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
+*                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
+*                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
+*                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
+*                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
+*                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
+*                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
+*                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
+*                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
+*                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void DMA_ClearITPendingBit(u32 DMA_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_DMA_CLEAR_IT(DMA_IT));
+
+  /* Calculate the used DMA */
+  if ((DMA_IT &amp; FLAG_Mask) != (u32)RESET)
+  {
+    /* Clear the selected DMA interrupt pending bits */
+    DMA2-&gt;IFCR = DMA_IT;
+  }
+  else
+  {
+    /* Clear the selected DMA interrupt pending bits */
+    DMA1-&gt;IFCR = DMA_IT;
+  }
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_exti.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,219 +1,219 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_exti.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the EXTI firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_exti.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define EXTI_LineNone    ((u32)0x00000)  /* No interrupt selected */
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : EXTI_DeInit
-* Description    : Deinitializes the EXTI peripheral registers to their default 
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_DeInit(void)
-{
-  EXTI-&gt;IMR = 0x00000000;
-  EXTI-&gt;EMR = 0x00000000;
-  EXTI-&gt;RTSR = 0x00000000; 
-  EXTI-&gt;FTSR = 0x00000000; 
-  EXTI-&gt;PR = 0x0007FFFF;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_Init
-* Description    : Initializes the EXTI peripheral according to the specified
-*                  parameters in the EXTI_InitStruct.
-* Input          : - EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
-*                    that contains the configuration information for the EXTI
-*                    peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_MODE(EXTI_InitStruct-&gt;EXTI_Mode));
-  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct-&gt;EXTI_Trigger));
-  assert_param(IS_EXTI_LINE(EXTI_InitStruct-&gt;EXTI_Line));  
-  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct-&gt;EXTI_LineCmd));
-     
-  if (EXTI_InitStruct-&gt;EXTI_LineCmd != DISABLE)
-  {
-    /* Clear EXTI line configuration */
-    EXTI-&gt;IMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    EXTI-&gt;EMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    
-    *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Mode)|= EXTI_InitStruct-&gt;EXTI_Line;
-
-    /* Clear Rising Falling edge configuration */
-    EXTI-&gt;RTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    EXTI-&gt;FTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-    
-    /* Select the trigger for the selected external interrupts */
-    if (EXTI_InitStruct-&gt;EXTI_Trigger == EXTI_Trigger_Rising_Falling)
-    {
-      /* Rising Falling edge */
-      EXTI-&gt;RTSR |= EXTI_InitStruct-&gt;EXTI_Line;
-      EXTI-&gt;FTSR |= EXTI_InitStruct-&gt;EXTI_Line;
-    }
-    else
-    {
-      *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Trigger)|= EXTI_InitStruct-&gt;EXTI_Line;
-    }
-  }
-  else
-  {
-    /* Disable the selected external lines */
-    *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Mode)&amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_StructInit
-* Description    : Fills each EXTI_InitStruct member with its reset value.
-* Input          : - EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
-{
-  EXTI_InitStruct-&gt;EXTI_Line = EXTI_LineNone;
-  EXTI_InitStruct-&gt;EXTI_Mode = EXTI_Mode_Interrupt;
-  EXTI_InitStruct-&gt;EXTI_Trigger = EXTI_Trigger_Falling;
-  EXTI_InitStruct-&gt;EXTI_LineCmd = DISABLE;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_GenerateSWInterrupt
-* Description    : Generates a Software interrupt.
-* Input          : - EXTI_Line: specifies the EXTI lines to be enabled or
-*                    disabled.
-*                    This parameter can be any combination of EXTI_Linex where 
-*                    x can be (0..18).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_GenerateSWInterrupt(u32 EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI-&gt;SWIER |= EXTI_Line;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_GetFlagStatus
-* Description    : Checks whether the specified EXTI line flag is set or not.
-* Input          : - EXTI_Line: specifies the EXTI line flag to check.
-*                    This parameter can be:
-*                       - EXTI_Linex: External interrupt line x where x(0..18)
-* Output         : None
-* Return         : The new state of EXTI_Line (SET or RESET).
-*******************************************************************************/
-FlagStatus EXTI_GetFlagStatus(u32 EXTI_Line)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
-  
-  if ((EXTI-&gt;PR &amp; EXTI_Line) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_ClearFlag
-* Description    : Clears the EXTI&#146;s line pending flags.
-* Input          : - EXTI_Line: specifies the EXTI lines flags to clear.
-*                    This parameter can be any combination of EXTI_Linex where 
-*                    x can be (0..18).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_ClearFlag(u32 EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI-&gt;PR = EXTI_Line;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_GetITStatus
-* Description    : Checks whether the specified EXTI line is asserted or not.
-* Input          : - EXTI_Line: specifies the EXTI line to check.
-*                    This parameter can be:
-*                       - EXTI_Linex: External interrupt line x where x(0..18)
-* Output         : None
-* Return         : The new state of EXTI_Line (SET or RESET).
-*******************************************************************************/
-ITStatus EXTI_GetITStatus(u32 EXTI_Line)
-{
-  ITStatus bitstatus = RESET;
-  u32 enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
-  
-  enablestatus =  EXTI-&gt;IMR &amp; EXTI_Line;
-
-  if (((EXTI-&gt;PR &amp; EXTI_Line) != (u32)RESET) &amp;&amp; (enablestatus != (u32)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : EXTI_ClearITPendingBit
-* Description    : Clears the EXTI&#146;s line pending bits.
-* Input          : - EXTI_Line: specifies the EXTI lines to clear.
-*                    This parameter can be any combination of EXTI_Linex where 
-*                    x can be (0..18).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void EXTI_ClearITPendingBit(u32 EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI-&gt;PR = EXTI_Line;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_exti.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the EXTI firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_exti.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define EXTI_LineNone    ((u32)0x00000)  /* No interrupt selected */
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : EXTI_DeInit
+* Description    : Deinitializes the EXTI peripheral registers to their default 
+*                  reset values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI_DeInit(void)
+{
+  EXTI-&gt;IMR = 0x00000000;
+  EXTI-&gt;EMR = 0x00000000;
+  EXTI-&gt;RTSR = 0x00000000; 
+  EXTI-&gt;FTSR = 0x00000000; 
+  EXTI-&gt;PR = 0x0007FFFF;
+}
+
+/*******************************************************************************
+* Function Name  : EXTI_Init
+* Description    : Initializes the EXTI peripheral according to the specified
+*                  parameters in the EXTI_InitStruct.
+* Input          : - EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
+*                    that contains the configuration information for the EXTI
+*                    peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_MODE(EXTI_InitStruct-&gt;EXTI_Mode));
+  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct-&gt;EXTI_Trigger));
+  assert_param(IS_EXTI_LINE(EXTI_InitStruct-&gt;EXTI_Line));  
+  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct-&gt;EXTI_LineCmd));
+     
+  if (EXTI_InitStruct-&gt;EXTI_LineCmd != DISABLE)
+  {
+    /* Clear EXTI line configuration */
+    EXTI-&gt;IMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    EXTI-&gt;EMR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    
+    *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Mode)|= EXTI_InitStruct-&gt;EXTI_Line;
+
+    /* Clear Rising Falling edge configuration */
+    EXTI-&gt;RTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    EXTI-&gt;FTSR &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+    
+    /* Select the trigger for the selected external interrupts */
+    if (EXTI_InitStruct-&gt;EXTI_Trigger == EXTI_Trigger_Rising_Falling)
+    {
+      /* Rising Falling edge */
+      EXTI-&gt;RTSR |= EXTI_InitStruct-&gt;EXTI_Line;
+      EXTI-&gt;FTSR |= EXTI_InitStruct-&gt;EXTI_Line;
+    }
+    else
+    {
+      *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Trigger)|= EXTI_InitStruct-&gt;EXTI_Line;
+    }
+  }
+  else
+  {
+    /* Disable the selected external lines */
+    *(vu32 *)(EXTI_BASE + (u32)EXTI_InitStruct-&gt;EXTI_Mode)&amp;= ~EXTI_InitStruct-&gt;EXTI_Line;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : EXTI_StructInit
+* Description    : Fills each EXTI_InitStruct member with its reset value.
+* Input          : - EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
+{
+  EXTI_InitStruct-&gt;EXTI_Line = EXTI_LineNone;
+  EXTI_InitStruct-&gt;EXTI_Mode = EXTI_Mode_Interrupt;
+  EXTI_InitStruct-&gt;EXTI_Trigger = EXTI_Trigger_Falling;
+  EXTI_InitStruct-&gt;EXTI_LineCmd = DISABLE;
+}
+
+/*******************************************************************************
+* Function Name  : EXTI_GenerateSWInterrupt
+* Description    : Generates a Software interrupt.
+* Input          : - EXTI_Line: specifies the EXTI lines to be enabled or
+*                    disabled.
+*                    This parameter can be any combination of EXTI_Linex where 
+*                    x can be (0..18).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI_GenerateSWInterrupt(u32 EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI-&gt;SWIER |= EXTI_Line;
+}
+
+/*******************************************************************************
+* Function Name  : EXTI_GetFlagStatus
+* Description    : Checks whether the specified EXTI line flag is set or not.
+* Input          : - EXTI_Line: specifies the EXTI line flag to check.
+*                    This parameter can be:
+*                       - EXTI_Linex: External interrupt line x where x(0..18)
+* Output         : None
+* Return         : The new state of EXTI_Line (SET or RESET).
+*******************************************************************************/
+FlagStatus EXTI_GetFlagStatus(u32 EXTI_Line)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+  
+  if ((EXTI-&gt;PR &amp; EXTI_Line) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : EXTI_ClearFlag
+* Description    : Clears the EXTI's line pending flags.
+* Input          : - EXTI_Line: specifies the EXTI lines flags to clear.
+*                    This parameter can be any combination of EXTI_Linex where 
+*                    x can be (0..18).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI_ClearFlag(u32 EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI-&gt;PR = EXTI_Line;
+}
+
+/*******************************************************************************
+* Function Name  : EXTI_GetITStatus
+* Description    : Checks whether the specified EXTI line is asserted or not.
+* Input          : - EXTI_Line: specifies the EXTI line to check.
+*                    This parameter can be:
+*                       - EXTI_Linex: External interrupt line x where x(0..18)
+* Output         : None
+* Return         : The new state of EXTI_Line (SET or RESET).
+*******************************************************************************/
+ITStatus EXTI_GetITStatus(u32 EXTI_Line)
+{
+  ITStatus bitstatus = RESET;
+  u32 enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
+  
+  enablestatus =  EXTI-&gt;IMR &amp; EXTI_Line;
+
+  if (((EXTI-&gt;PR &amp; EXTI_Line) != (u32)RESET) &amp;&amp; (enablestatus != (u32)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : EXTI_ClearITPendingBit
+* Description    : Clears the EXTI's line pending bits.
+* Input          : - EXTI_Line: specifies the EXTI lines to clear.
+*                    This parameter can be any combination of EXTI_Linex where 
+*                    x can be (0..18).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void EXTI_ClearITPendingBit(u32 EXTI_Line)
+{
+  /* Check the parameters */
+  assert_param(IS_EXTI_LINE(EXTI_Line));
+  
+  EXTI-&gt;PR = EXTI_Line;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_flash.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,911 +1,911 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_flash.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the FLASH firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_flash.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* Flash Access Control Register bits */
-#define ACR_LATENCY_Mask         ((u32)0x00000038)
-#define ACR_HLFCYA_Mask          ((u32)0xFFFFFFF7)
-#define ACR_PRFTBE_Mask          ((u32)0xFFFFFFEF)
-
-#ifdef _FLASH_PROG
-/* Flash Access Control Register bits */
-#define ACR_PRFTBS_Mask          ((u32)0x00000020) 
-
-/* Flash Control Register bits */
-#define CR_PG_Set                ((u32)0x00000001)
-#define CR_PG_Reset              ((u32)0x00001FFE) 
-
-#define CR_PER_Set               ((u32)0x00000002)
-#define CR_PER_Reset             ((u32)0x00001FFD)
-
-#define CR_MER_Set               ((u32)0x00000004)
-#define CR_MER_Reset             ((u32)0x00001FFB)
-
-#define CR_OPTPG_Set             ((u32)0x00000010)
-#define CR_OPTPG_Reset           ((u32)0x00001FEF)
-
-#define CR_OPTER_Set             ((u32)0x00000020)
-#define CR_OPTER_Reset           ((u32)0x00001FDF)
-
-#define CR_STRT_Set              ((u32)0x00000040)
-							 
-#define CR_LOCK_Set              ((u32)0x00000080)
-
-/* FLASH Mask */
-#define RDPRT_Mask               ((u32)0x00000002)
-#define WRP0_Mask                ((u32)0x000000FF)
-#define WRP1_Mask                ((u32)0x0000FF00)
-#define WRP2_Mask                ((u32)0x00FF0000)
-#define WRP3_Mask                ((u32)0xFF000000)
-
-/* FLASH Keys */
-#define RDP_Key                  ((u16)0x00A5)
-#define FLASH_KEY1               ((u32)0x45670123)
-#define FLASH_KEY2               ((u32)0xCDEF89AB)
-
-/* Delay definition */   
-#define EraseTimeout             ((u32)0x00000FFF)
-#define ProgramTimeout           ((u32)0x0000000F)
-#endif
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-#ifdef _FLASH_PROG
-static void delay(void);
-#endif
-
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-* Function Name  : FLASH_SetLatency
-* Description    : Sets the code latency value.
-* Input          : - FLASH_Latency: specifies the FLASH Latency value.
-*                    This parameter can be one of the following values:
-*                       - FLASH_Latency_0: FLASH Zero Latency cycle
-*                       - FLASH_Latency_1: FLASH One Latency cycle
-*                       - FLASH_Latency_2: FLASH Two Latency cycles
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_SetLatency(u32 FLASH_Latency)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
-  
-  /* Sets the Latency value */
-  FLASH-&gt;ACR &amp;= ACR_LATENCY_Mask;
-  FLASH-&gt;ACR |= FLASH_Latency;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_HalfCycleAccessCmd
-* Description    : Enables or disables the Half cycle flash access.
-* Input          : - FLASH_HalfCycle: specifies the FLASH Half cycle Access mode.
-*                    This parameter can be one of the following values:
-*                       - FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
-*                       - FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
-  
-  /* Enable or disable the Half cycle access */
-  FLASH-&gt;ACR &amp;= ACR_HLFCYA_Mask;
-  FLASH-&gt;ACR |= FLASH_HalfCycleAccess;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_PrefetchBufferCmd
-* Description    : Enables or disables the Prefetch Buffer.
-* Input          : - FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
-*                    This parameter can be one of the following values:
-*                       - FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
-*                       - FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
-  
-  /* Enable or disable the Prefetch Buffer */
-  FLASH-&gt;ACR &amp;= ACR_PRFTBE_Mask;
-  FLASH-&gt;ACR |= FLASH_PrefetchBuffer;
-}
-
-#ifdef _FLASH_PROG
-/*******************************************************************************
-* Function Name  : FLASH_Unlock
-* Description    : Unlocks the FLASH Program Erase Controller.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_Unlock(void)
-{
-  /* Authorize the FPEC Access */
-  FLASH-&gt;KEYR = FLASH_KEY1;
-  FLASH-&gt;KEYR = FLASH_KEY2;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_Lock
-* Description    : Locks the FLASH Program Erase Controller.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_Lock(void)
-{
-  /* Set the Lock Bit to lock the FPEC and the FCR */
-  FLASH-&gt;CR |= CR_LOCK_Set;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ErasePage
-* Description    : Erases a specified FLASH page.
-* Input          : - Page_Address: The page address to be erased.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_ErasePage(u32 Page_Address)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Page_Address));
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  { 
-    /* if the previous operation is completed, proceed to erase the page */
-    FLASH-&gt;CR|= CR_PER_Set;
-    FLASH-&gt;AR = Page_Address; 
-    FLASH-&gt;CR|= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the erase operation is completed, disable the PER Bit */
-      FLASH-&gt;CR &amp;= CR_PER_Reset;
-    }
-  }
-  /* Return the Erase Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_EraseAllPages
-* Description    : Erases all FLASH pages.
-* Input          : None
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_EraseAllPages(void)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to erase all pages */
-     FLASH-&gt;CR |= CR_MER_Set;
-     FLASH-&gt;CR |= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the erase operation is completed, disable the MER Bit */
-      FLASH-&gt;CR &amp;= CR_MER_Reset;
-    }
-  }	   
-  /* Return the Erase Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_EraseOptionBytes
-* Description    : Erases the FLASH option bytes.
-* Input          : None
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_EraseOptionBytes(void)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorize the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-    
-    /* if the previous operation is completed, proceed to erase the option bytes */
-    FLASH-&gt;CR |= CR_OPTER_Set;
-    FLASH-&gt;CR |= CR_STRT_Set;
-
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-    
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the erase operation is completed, disable the OPTER Bit */
-      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
-       
-      /* Enable the Option Bytes Programming operation */
-      FLASH-&gt;CR |= CR_OPTPG_Set;
-
-      /* Enable the readout access */
-      OB-&gt;RDP= RDP_Key; 
-
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
- 
-      if(status != FLASH_BUSY)
-      {
-        /* if the program operation is completed, disable the OPTPG Bit */
-        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-      }
-    }
-    else
-    {
-      if (status != FLASH_BUSY)
-      {
-        /* Disable the OPTPG Bit */
-        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-      }
-    }  
-  }
-  /* Return the erase status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ProgramWord
-* Description    : Programs a word at a specified address.
-* Input          : - Address: specifies the address to be programmed.
-*                  - Data: specifies the data to be programmed.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT. 
-*******************************************************************************/
-FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Address));
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to program the new first 
-    half word */
-    FLASH-&gt;CR |= CR_PG_Set;
-  
-    *(vu16*)Address = (u16)Data;
-
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
- 
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new second 
-      half word */
-      *(vu16*)(Address + 2) = Data &gt;&gt; 16;
-    
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-        
-      if(status != FLASH_BUSY)
-      {
-        /* Disable the PG Bit */
-        FLASH-&gt;CR &amp;= CR_PG_Reset;
-      }
-    }
-    else
-    {
-      if (status != FLASH_BUSY)
-      {
-        /* Disable the PG Bit */
-        FLASH-&gt;CR &amp;= CR_PG_Reset;
-      }
-     }
-  }
-  /* Return the Program Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ProgramHalfWord
-* Description    : Programs a half word at a specified address.
-* Input          : - Address: specifies the address to be programmed.
-*                  - Data: specifies the data to be programmed.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT. 
-*******************************************************************************/
-FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Address));
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to program the new data */
-    FLASH-&gt;CR |= CR_PG_Set;
-  
-    *(vu16*)Address = Data;
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the PG Bit */
-      FLASH-&gt;CR &amp;= CR_PG_Reset;
-    }
-  } 
-  /* Return the Program Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ProgramOptionByteData
-* Description    : Programs a half word at a specified Option Byte Data address.
-* Input          : - Address: specifies the address to be programmed.
-*                    This parameter can be 0x1FFFF804 or 0x1FFFF806. 
-*                  - Data: specifies the data to be programmed.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT. 
-*******************************************************************************/
-FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_OB_DATA_ADDRESS(Address));
-
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorize the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-
-    /* Enables the Option Bytes Programming operation */
-    FLASH-&gt;CR |= CR_OPTPG_Set; 
-    *(vu16*)Address = Data;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-    }
-  }    
-  /* Return the Option Byte Data Program Status */
-  return status;      
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_EnableWriteProtection
-* Description    : Write protects the desired pages
-* Input          : - FLASH_Pages: specifies the address of the pages to be 
-*                    write protected. This parameter can be:
-*                    - For STM32F10Xxx Medium-density devices (FLASH page size equal to 1 KB)
-*                       - A value between FLASH_WRProt_Pages0to3 and 
-*                         FLASH_WRProt_Pages124to127
-*                    - For STM32F10Xxx High-density devices (FLASH page size equal to 2 KB) 
-*                       - A value between FLASH_WRProt_Pages0to1 and
-*                         FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255 
-*                       - FLASH_WRProt_AllPages
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
-{
-  u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
-  
-  FLASH_Status status = FLASH_COMPLETE;
-  
-  /* Check the parameters */
-  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
-  
-  FLASH_Pages = (u32)(~FLASH_Pages);
-  WRP0_Data = (vu16)(FLASH_Pages &amp; WRP0_Mask);
-  WRP1_Data = (vu16)((FLASH_Pages &amp; WRP1_Mask) &gt;&gt; 8);
-  WRP2_Data = (vu16)((FLASH_Pages &amp; WRP2_Mask) &gt;&gt; 16);
-  WRP3_Data = (vu16)((FLASH_Pages &amp; WRP3_Mask) &gt;&gt; 24);
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorizes the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-    FLASH-&gt;CR |= CR_OPTPG_Set;
-
-    if(WRP0_Data != 0xFF)
-    {
-      OB-&gt;WRP0 = WRP0_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-    if((status == FLASH_COMPLETE) &amp;&amp; (WRP1_Data != 0xFF))
-    {
-      OB-&gt;WRP1 = WRP1_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-
-    if((status == FLASH_COMPLETE) &amp;&amp; (WRP2_Data != 0xFF))
-    {
-      OB-&gt;WRP2 = WRP2_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-    
-    if((status == FLASH_COMPLETE)&amp;&amp; (WRP3_Data != 0xFF))
-    {
-      OB-&gt;WRP3 = WRP3_Data;
-     
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-          
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-    }
-  } 
-  /* Return the write protection operation Status */
-  return status;       
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ReadOutProtection
-* Description    : Enables or disables the read out protection.
-*                  If the user has already programmed the other option bytes before 
-*                  calling this function, he must re-program them since this 
-*                  function erases all option bytes.
-* Input          : - Newstate: new state of the ReadOut Protection.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorizes the small information block programming */
-    FLASH-&gt;OPTKEYR = FLASH_KEY1;
-    FLASH-&gt;OPTKEYR = FLASH_KEY2;
-
-    FLASH-&gt;CR |= CR_OPTER_Set;
-    FLASH-&gt;CR |= CR_STRT_Set;
-
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the erase operation is completed, disable the OPTER Bit */
-      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
-
-      /* Enable the Option Bytes Programming operation */
-      FLASH-&gt;CR |= CR_OPTPG_Set; 
-
-      if(NewState != DISABLE)
-      {
-        OB-&gt;RDP = 0x00;
-      }
-      else
-      {
-        OB-&gt;RDP = RDP_Key;  
-      }
-
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(EraseTimeout); 
-    
-      if(status != FLASH_BUSY)
-      {
-        /* if the program operation is completed, disable the OPTPG Bit */
-        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-      }
-    }
-    else 
-    {
-      if(status != FLASH_BUSY)
-      {
-        /* Disable the OPTER Bit */
-        FLASH-&gt;CR &amp;= CR_OPTER_Reset;
-      }
-    }
-  }
-  /* Return the protection operation Status */
-  return status;      
-}
-  	
-/*******************************************************************************
-* Function Name  : FLASH_UserOptionByteConfig
-* Description    : Programs the FLASH User Option Byte: IWDG_SW / RST_STOP /
-*                  RST_STDBY.
-* Input          : - OB_IWDG: Selects the IWDG mode
-*                     This parameter can be one of the following values:
-*                     - OB_IWDG_SW: Software IWDG selected
-*                     - OB_IWDG_HW: Hardware IWDG selected
-*                  - OB_STOP: Reset event when entering STOP mode.
-*                     This parameter can be one of the following values:
-*                     - OB_STOP_NoRST: No reset generated when entering in STOP
-*                     - OB_STOP_RST: Reset generated when entering in STOP
-*                  - OB_STDBY: Reset event when entering Standby mode.
-*                    This parameter can be one of the following values:
-*                     - OB_STDBY_NoRST: No reset generated when entering in STANDBY
-*                     - OB_STDBY_RST: Reset generated when entering in STANDBY
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
-{
-  FLASH_Status status = FLASH_COMPLETE; 
-
-  /* Check the parameters */
-  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
-  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
-  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
-
-  /* Authorize the small information block programming */
-  FLASH-&gt;OPTKEYR = FLASH_KEY1;
-  FLASH-&gt;OPTKEYR = FLASH_KEY2;
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {  
-    /* Enable the Option Bytes Programming operation */
-    FLASH-&gt;CR |= CR_OPTPG_Set; 
-           
-    OB-&gt;USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
-  
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-    if(status != FLASH_BUSY)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
-    }
-  }    
-  /* Return the Option Byte program Status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetUserOptionByte
-* Description    : Returns the FLASH User Option Bytes values.
-* Input          : None
-* Output         : None
-* Return         : The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
-*                  and RST_STDBY(Bit2).
-*******************************************************************************/
-u32 FLASH_GetUserOptionByte(void)
-{
-  /* Return the User Option Byte */
-  return (u32)(FLASH-&gt;OBR &gt;&gt; 2);
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetWriteProtectionOptionByte
-* Description    : Returns the FLASH Write Protection Option Bytes Register value.
-* Input          : None
-* Output         : None
-* Return         : The FLASH Write Protection  Option Bytes Register value
-*******************************************************************************/
-u32 FLASH_GetWriteProtectionOptionByte(void)
-{
-  /* Return the Falsh write protection Register value */
-  return (u32)(FLASH-&gt;WRPR);
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetReadOutProtectionStatus
-* Description    : Checks whether the FLASH Read Out Protection Status is set 
-*                  or not.
-* Input          : None
-* Output         : None
-* Return         : FLASH ReadOut Protection Status(SET or RESET)
-*******************************************************************************/
-FlagStatus FLASH_GetReadOutProtectionStatus(void)
-{
-  FlagStatus readoutstatus = RESET;
-
-  if ((FLASH-&gt;OBR &amp; RDPRT_Mask) != (u32)RESET)
-  {
-    readoutstatus = SET;
-  }
-  else
-  {
-    readoutstatus = RESET;
-  }
-  return readoutstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetPrefetchBufferStatus
-* Description    : Checks whether the FLASH Prefetch Buffer status is set or not.
-* Input          : None
-* Output         : None
-* Return         : FLASH Prefetch Buffer Status (SET or RESET).
-*******************************************************************************/
-FlagStatus FLASH_GetPrefetchBufferStatus(void)
-{
-  FlagStatus bitstatus = RESET;
-  
-  if ((FLASH-&gt;ACR &amp; ACR_PRFTBS_Mask) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
-  return bitstatus; 
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ITConfig
-* Description    : Enables or disables the specified FLASH interrupts.
-* Input          : - FLASH_IT: specifies the FLASH interrupt sources to be 
-*                    enabled or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - FLASH_IT_ERROR: FLASH Error Interrupt
-*                       - FLASH_IT_EOP: FLASH end of operation Interrupt
-* Output         : None
-* Return         : None 
-*******************************************************************************/
-void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_IT(FLASH_IT)); 
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if(NewState != DISABLE)
-  {
-    /* Enable the interrupt sources */
-    FLASH-&gt;CR |= FLASH_IT;
-  }
-  else
-  {
-    /* Disable the interrupt sources */
-    FLASH-&gt;CR &amp;= ~(u32)FLASH_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetFlagStatus
-* Description    : Checks whether the specified FLASH flag is set or not.
-* Input          : - FLASH_FLAG: specifies the FLASH flag to check.
-*                     This parameter can be one of the following values:
-*                    - FLASH_FLAG_BSY: FLASH Busy flag           
-*                    - FLASH_FLAG_PGERR: FLASH Program error flag       
-*                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
-*                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
-*                    - FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
-* Output         : None
-* Return         : The new state of FLASH_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
-
-  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
-  {
-    if((FLASH-&gt;OBR &amp; FLASH_FLAG_OPTERR) != (u32)RESET)
-    {
-      bitstatus = SET;
-    }
-    else
-    {
-      bitstatus = RESET;
-    }
-  }
-  else
-  {
-   if((FLASH-&gt;SR &amp; FLASH_FLAG) != (u32)RESET)
-    {
-      bitstatus = SET;
-    }
-    else
-    {
-      bitstatus = RESET;
-    }
-  }
-  /* Return the new state of FLASH_FLAG (SET or RESET) */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_ClearFlag
-* Description    : Clears the FLASH&#146;s pending flags.
-* Input          : - FLASH_FLAG: specifies the FLASH flags to clear.
-*                    This parameter can be any combination of the following values:
-*                    - FLASH_FLAG_BSY: FLASH Busy flag           
-*                    - FLASH_FLAG_PGERR: FLASH Program error flag       
-*                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
-*                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FLASH_ClearFlag(u16 FLASH_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
-  
-  /* Clear the flags */
-  FLASH-&gt;SR = FLASH_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_GetStatus
-* Description    : Returns the FLASH Status.
-* Input          : None
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP or FLASH_COMPLETE
-*******************************************************************************/
-FLASH_Status FLASH_GetStatus(void)
-{
-  FLASH_Status flashstatus = FLASH_COMPLETE;
-  
-  if((FLASH-&gt;SR &amp; FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
-  {
-    flashstatus = FLASH_BUSY;
-  }
-  else 
-  {  
-    if(FLASH-&gt;SR &amp; FLASH_FLAG_PGERR)
-    { 
-      flashstatus = FLASH_ERROR_PG;
-    }
-    else 
-    {
-      if(FLASH-&gt;SR &amp; FLASH_FLAG_WRPRTERR)
-      {
-        flashstatus = FLASH_ERROR_WRP;
-      }
-      else
-      {
-        flashstatus = FLASH_COMPLETE;
-      }
-    }
-  }
-  /* Return the Flash Status */
-  return flashstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FLASH_WaitForLastOperation
-* Description    : Waits for a Flash operation to complete or a TIMEOUT to occur.
-* Input          : - Timeout: FLASH progamming Timeout
-* Output         : None
-* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
-*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
-*                  FLASH_TIMEOUT.
-*******************************************************************************/
-FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
-{ 
-  FLASH_Status status = FLASH_COMPLETE;
-   
-  /* Check for the Flash Status */
-  status = FLASH_GetStatus();
-
-  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
-  while((status == FLASH_BUSY) &amp;&amp; (Timeout != 0x00))
-  {
-    delay();
-    status = FLASH_GetStatus();
-    Timeout--;
-  }
-
-  if(Timeout == 0x00 )
-  {
-    status = FLASH_TIMEOUT;
-  }
-
-  /* Return the operation status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : delay
-* Description    : Inserts a time delay.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void delay(void)
-{
-  vu32 i = 0;
-
-  for(i = 0xFF; i != 0; i--)
-  {
-  }
-}
-#endif
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_flash.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the FLASH firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_flash.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Flash Access Control Register bits */
+#define ACR_LATENCY_Mask         ((u32)0x00000038)
+#define ACR_HLFCYA_Mask          ((u32)0xFFFFFFF7)
+#define ACR_PRFTBE_Mask          ((u32)0xFFFFFFEF)
+
+#ifdef _FLASH_PROG
+/* Flash Access Control Register bits */
+#define ACR_PRFTBS_Mask          ((u32)0x00000020) 
+
+/* Flash Control Register bits */
+#define CR_PG_Set                ((u32)0x00000001)
+#define CR_PG_Reset              ((u32)0x00001FFE) 
+
+#define CR_PER_Set               ((u32)0x00000002)
+#define CR_PER_Reset             ((u32)0x00001FFD)
+
+#define CR_MER_Set               ((u32)0x00000004)
+#define CR_MER_Reset             ((u32)0x00001FFB)
+
+#define CR_OPTPG_Set             ((u32)0x00000010)
+#define CR_OPTPG_Reset           ((u32)0x00001FEF)
+
+#define CR_OPTER_Set             ((u32)0x00000020)
+#define CR_OPTER_Reset           ((u32)0x00001FDF)
+
+#define CR_STRT_Set              ((u32)0x00000040)
+							 
+#define CR_LOCK_Set              ((u32)0x00000080)
+
+/* FLASH Mask */
+#define RDPRT_Mask               ((u32)0x00000002)
+#define WRP0_Mask                ((u32)0x000000FF)
+#define WRP1_Mask                ((u32)0x0000FF00)
+#define WRP2_Mask                ((u32)0x00FF0000)
+#define WRP3_Mask                ((u32)0xFF000000)
+
+/* FLASH Keys */
+#define RDP_Key                  ((u16)0x00A5)
+#define FLASH_KEY1               ((u32)0x45670123)
+#define FLASH_KEY2               ((u32)0xCDEF89AB)
+
+/* Delay definition */   
+#define EraseTimeout             ((u32)0x00000FFF)
+#define ProgramTimeout           ((u32)0x0000000F)
+#endif
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+#ifdef _FLASH_PROG
+static void delay(void);
+#endif
+
+/* Private functions ---------------------------------------------------------*/
+/*******************************************************************************
+* Function Name  : FLASH_SetLatency
+* Description    : Sets the code latency value.
+* Input          : - FLASH_Latency: specifies the FLASH Latency value.
+*                    This parameter can be one of the following values:
+*                       - FLASH_Latency_0: FLASH Zero Latency cycle
+*                       - FLASH_Latency_1: FLASH One Latency cycle
+*                       - FLASH_Latency_2: FLASH Two Latency cycles
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FLASH_SetLatency(u32 FLASH_Latency)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
+  
+  /* Sets the Latency value */
+  FLASH-&gt;ACR &amp;= ACR_LATENCY_Mask;
+  FLASH-&gt;ACR |= FLASH_Latency;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_HalfCycleAccessCmd
+* Description    : Enables or disables the Half cycle flash access.
+* Input          : - FLASH_HalfCycle: specifies the FLASH Half cycle Access mode.
+*                    This parameter can be one of the following values:
+*                       - FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
+*                       - FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
+  
+  /* Enable or disable the Half cycle access */
+  FLASH-&gt;ACR &amp;= ACR_HLFCYA_Mask;
+  FLASH-&gt;ACR |= FLASH_HalfCycleAccess;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_PrefetchBufferCmd
+* Description    : Enables or disables the Prefetch Buffer.
+* Input          : - FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
+*                    This parameter can be one of the following values:
+*                       - FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
+*                       - FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
+  
+  /* Enable or disable the Prefetch Buffer */
+  FLASH-&gt;ACR &amp;= ACR_PRFTBE_Mask;
+  FLASH-&gt;ACR |= FLASH_PrefetchBuffer;
+}
+
+#ifdef _FLASH_PROG
+/*******************************************************************************
+* Function Name  : FLASH_Unlock
+* Description    : Unlocks the FLASH Program Erase Controller.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FLASH_Unlock(void)
+{
+  /* Authorize the FPEC Access */
+  FLASH-&gt;KEYR = FLASH_KEY1;
+  FLASH-&gt;KEYR = FLASH_KEY2;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_Lock
+* Description    : Locks the FLASH Program Erase Controller.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FLASH_Lock(void)
+{
+  /* Set the Lock Bit to lock the FPEC and the FCR */
+  FLASH-&gt;CR |= CR_LOCK_Set;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_ErasePage
+* Description    : Erases a specified FLASH page.
+* Input          : - Page_Address: The page address to be erased.
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT.
+*******************************************************************************/
+FLASH_Status FLASH_ErasePage(u32 Page_Address)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Page_Address));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  { 
+    /* if the previous operation is completed, proceed to erase the page */
+    FLASH-&gt;CR|= CR_PER_Set;
+    FLASH-&gt;AR = Page_Address; 
+    FLASH-&gt;CR|= CR_STRT_Set;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+
+    if(status != FLASH_BUSY)
+    {
+      /* if the erase operation is completed, disable the PER Bit */
+      FLASH-&gt;CR &amp;= CR_PER_Reset;
+    }
+  }
+  /* Return the Erase Status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_EraseAllPages
+* Description    : Erases all FLASH pages.
+* Input          : None
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT.
+*******************************************************************************/
+FLASH_Status FLASH_EraseAllPages(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to erase all pages */
+     FLASH-&gt;CR |= CR_MER_Set;
+     FLASH-&gt;CR |= CR_STRT_Set;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+
+    if(status != FLASH_BUSY)
+    {
+      /* if the erase operation is completed, disable the MER Bit */
+      FLASH-&gt;CR &amp;= CR_MER_Reset;
+    }
+  }	   
+  /* Return the Erase Status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_EraseOptionBytes
+* Description    : Erases the FLASH option bytes.
+* Input          : None
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT.
+*******************************************************************************/
+FLASH_Status FLASH_EraseOptionBytes(void)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorize the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+    
+    /* if the previous operation is completed, proceed to erase the option bytes */
+    FLASH-&gt;CR |= CR_OPTER_Set;
+    FLASH-&gt;CR |= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+    
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the erase operation is completed, disable the OPTER Bit */
+      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
+       
+      /* Enable the Option Bytes Programming operation */
+      FLASH-&gt;CR |= CR_OPTPG_Set;
+
+      /* Enable the readout access */
+      OB-&gt;RDP= RDP_Key; 
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+ 
+      if(status != FLASH_BUSY)
+      {
+        /* if the program operation is completed, disable the OPTPG Bit */
+        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+      }
+    }
+    else
+    {
+      if (status != FLASH_BUSY)
+      {
+        /* Disable the OPTPG Bit */
+        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+      }
+    }  
+  }
+  /* Return the erase status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_ProgramWord
+* Description    : Programs a word at a specified address.
+* Input          : - Address: specifies the address to be programmed.
+*                  - Data: specifies the data to be programmed.
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT. 
+*******************************************************************************/
+FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new first 
+    half word */
+    FLASH-&gt;CR |= CR_PG_Set;
+  
+    *(vu16*)Address = (u16)Data;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+ 
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the previous operation is completed, proceed to program the new second 
+      half word */
+      *(vu16*)(Address + 2) = Data &gt;&gt; 16;
+    
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+        
+      if(status != FLASH_BUSY)
+      {
+        /* Disable the PG Bit */
+        FLASH-&gt;CR &amp;= CR_PG_Reset;
+      }
+    }
+    else
+    {
+      if (status != FLASH_BUSY)
+      {
+        /* Disable the PG Bit */
+        FLASH-&gt;CR &amp;= CR_PG_Reset;
+      }
+     }
+  }
+  /* Return the Program Status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_ProgramHalfWord
+* Description    : Programs a half word at a specified address.
+* Input          : - Address: specifies the address to be programmed.
+*                  - Data: specifies the data to be programmed.
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT. 
+*******************************************************************************/
+FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_ADDRESS(Address));
+
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* if the previous operation is completed, proceed to program the new data */
+    FLASH-&gt;CR |= CR_PG_Set;
+  
+    *(vu16*)Address = Data;
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+    if(status != FLASH_BUSY)
+    {
+      /* if the program operation is completed, disable the PG Bit */
+      FLASH-&gt;CR &amp;= CR_PG_Reset;
+    }
+  } 
+  /* Return the Program Status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_ProgramOptionByteData
+* Description    : Programs a half word at a specified Option Byte Data address.
+* Input          : - Address: specifies the address to be programmed.
+*                    This parameter can be 0x1FFFF804 or 0x1FFFF806. 
+*                  - Data: specifies the data to be programmed.
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT. 
+*******************************************************************************/
+FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_OB_DATA_ADDRESS(Address));
+
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorize the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+
+    /* Enables the Option Bytes Programming operation */
+    FLASH-&gt;CR |= CR_OPTPG_Set; 
+    *(vu16*)Address = Data;
+    
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+    if(status != FLASH_BUSY)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+    }
+  }    
+  /* Return the Option Byte Data Program Status */
+  return status;      
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_EnableWriteProtection
+* Description    : Write protects the desired pages
+* Input          : - FLASH_Pages: specifies the address of the pages to be 
+*                    write protected. This parameter can be:
+*                    - For STM32F10Xxx Medium-density devices (FLASH page size equal to 1 KB)
+*                       - A value between FLASH_WRProt_Pages0to3 and 
+*                         FLASH_WRProt_Pages124to127
+*                    - For STM32F10Xxx High-density devices (FLASH page size equal to 2 KB) 
+*                       - A value between FLASH_WRProt_Pages0to1 and
+*                         FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255 
+*                       - FLASH_WRProt_AllPages
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT.
+*******************************************************************************/
+FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
+{
+  u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
+  
+  FLASH_Status status = FLASH_COMPLETE;
+  
+  /* Check the parameters */
+  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
+  
+  FLASH_Pages = (u32)(~FLASH_Pages);
+  WRP0_Data = (vu16)(FLASH_Pages &amp; WRP0_Mask);
+  WRP1_Data = (vu16)((FLASH_Pages &amp; WRP1_Mask) &gt;&gt; 8);
+  WRP2_Data = (vu16)((FLASH_Pages &amp; WRP2_Mask) &gt;&gt; 16);
+  WRP3_Data = (vu16)((FLASH_Pages &amp; WRP3_Mask) &gt;&gt; 24);
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorizes the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+    FLASH-&gt;CR |= CR_OPTPG_Set;
+
+    if(WRP0_Data != 0xFF)
+    {
+      OB-&gt;WRP0 = WRP0_Data;
+      
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+    if((status == FLASH_COMPLETE) &amp;&amp; (WRP1_Data != 0xFF))
+    {
+      OB-&gt;WRP1 = WRP1_Data;
+      
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+
+    if((status == FLASH_COMPLETE) &amp;&amp; (WRP2_Data != 0xFF))
+    {
+      OB-&gt;WRP2 = WRP2_Data;
+      
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+    
+    if((status == FLASH_COMPLETE)&amp;&amp; (WRP3_Data != 0xFF))
+    {
+      OB-&gt;WRP3 = WRP3_Data;
+     
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(ProgramTimeout);
+    }
+          
+    if(status != FLASH_BUSY)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+    }
+  } 
+  /* Return the write protection operation Status */
+  return status;       
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_ReadOutProtection
+* Description    : Enables or disables the read out protection.
+*                  If the user has already programmed the other option bytes before 
+*                  calling this function, he must re-program them since this 
+*                  function erases all option bytes.
+* Input          : - Newstate: new state of the ReadOut Protection.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT.
+*******************************************************************************/
+FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
+{
+  FLASH_Status status = FLASH_COMPLETE;
+
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  status = FLASH_WaitForLastOperation(EraseTimeout);
+
+  if(status == FLASH_COMPLETE)
+  {
+    /* Authorizes the small information block programming */
+    FLASH-&gt;OPTKEYR = FLASH_KEY1;
+    FLASH-&gt;OPTKEYR = FLASH_KEY2;
+
+    FLASH-&gt;CR |= CR_OPTER_Set;
+    FLASH-&gt;CR |= CR_STRT_Set;
+
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(EraseTimeout);
+
+    if(status == FLASH_COMPLETE)
+    {
+      /* if the erase operation is completed, disable the OPTER Bit */
+      FLASH-&gt;CR &amp;= CR_OPTER_Reset;
+
+      /* Enable the Option Bytes Programming operation */
+      FLASH-&gt;CR |= CR_OPTPG_Set; 
+
+      if(NewState != DISABLE)
+      {
+        OB-&gt;RDP = 0x00;
+      }
+      else
+      {
+        OB-&gt;RDP = RDP_Key;  
+      }
+
+      /* Wait for last operation to be completed */
+      status = FLASH_WaitForLastOperation(EraseTimeout); 
+    
+      if(status != FLASH_BUSY)
+      {
+        /* if the program operation is completed, disable the OPTPG Bit */
+        FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+      }
+    }
+    else 
+    {
+      if(status != FLASH_BUSY)
+      {
+        /* Disable the OPTER Bit */
+        FLASH-&gt;CR &amp;= CR_OPTER_Reset;
+      }
+    }
+  }
+  /* Return the protection operation Status */
+  return status;      
+}
+  	
+/*******************************************************************************
+* Function Name  : FLASH_UserOptionByteConfig
+* Description    : Programs the FLASH User Option Byte: IWDG_SW / RST_STOP /
+*                  RST_STDBY.
+* Input          : - OB_IWDG: Selects the IWDG mode
+*                     This parameter can be one of the following values:
+*                     - OB_IWDG_SW: Software IWDG selected
+*                     - OB_IWDG_HW: Hardware IWDG selected
+*                  - OB_STOP: Reset event when entering STOP mode.
+*                     This parameter can be one of the following values:
+*                     - OB_STOP_NoRST: No reset generated when entering in STOP
+*                     - OB_STOP_RST: Reset generated when entering in STOP
+*                  - OB_STDBY: Reset event when entering Standby mode.
+*                    This parameter can be one of the following values:
+*                     - OB_STDBY_NoRST: No reset generated when entering in STANDBY
+*                     - OB_STDBY_RST: Reset generated when entering in STANDBY
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT.
+*******************************************************************************/
+FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
+{
+  FLASH_Status status = FLASH_COMPLETE; 
+
+  /* Check the parameters */
+  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
+  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
+  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
+
+  /* Authorize the small information block programming */
+  FLASH-&gt;OPTKEYR = FLASH_KEY1;
+  FLASH-&gt;OPTKEYR = FLASH_KEY2;
+  
+  /* Wait for last operation to be completed */
+  status = FLASH_WaitForLastOperation(ProgramTimeout);
+  
+  if(status == FLASH_COMPLETE)
+  {  
+    /* Enable the Option Bytes Programming operation */
+    FLASH-&gt;CR |= CR_OPTPG_Set; 
+           
+    OB-&gt;USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
+  
+    /* Wait for last operation to be completed */
+    status = FLASH_WaitForLastOperation(ProgramTimeout);
+
+    if(status != FLASH_BUSY)
+    {
+      /* if the program operation is completed, disable the OPTPG Bit */
+      FLASH-&gt;CR &amp;= CR_OPTPG_Reset;
+    }
+  }    
+  /* Return the Option Byte program Status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_GetUserOptionByte
+* Description    : Returns the FLASH User Option Bytes values.
+* Input          : None
+* Output         : None
+* Return         : The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
+*                  and RST_STDBY(Bit2).
+*******************************************************************************/
+u32 FLASH_GetUserOptionByte(void)
+{
+  /* Return the User Option Byte */
+  return (u32)(FLASH-&gt;OBR &gt;&gt; 2);
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_GetWriteProtectionOptionByte
+* Description    : Returns the FLASH Write Protection Option Bytes Register value.
+* Input          : None
+* Output         : None
+* Return         : The FLASH Write Protection  Option Bytes Register value
+*******************************************************************************/
+u32 FLASH_GetWriteProtectionOptionByte(void)
+{
+  /* Return the Falsh write protection Register value */
+  return (u32)(FLASH-&gt;WRPR);
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_GetReadOutProtectionStatus
+* Description    : Checks whether the FLASH Read Out Protection Status is set 
+*                  or not.
+* Input          : None
+* Output         : None
+* Return         : FLASH ReadOut Protection Status(SET or RESET)
+*******************************************************************************/
+FlagStatus FLASH_GetReadOutProtectionStatus(void)
+{
+  FlagStatus readoutstatus = RESET;
+
+  if ((FLASH-&gt;OBR &amp; RDPRT_Mask) != (u32)RESET)
+  {
+    readoutstatus = SET;
+  }
+  else
+  {
+    readoutstatus = RESET;
+  }
+  return readoutstatus;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_GetPrefetchBufferStatus
+* Description    : Checks whether the FLASH Prefetch Buffer status is set or not.
+* Input          : None
+* Output         : None
+* Return         : FLASH Prefetch Buffer Status (SET or RESET).
+*******************************************************************************/
+FlagStatus FLASH_GetPrefetchBufferStatus(void)
+{
+  FlagStatus bitstatus = RESET;
+  
+  if ((FLASH-&gt;ACR &amp; ACR_PRFTBS_Mask) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
+  return bitstatus; 
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_ITConfig
+* Description    : Enables or disables the specified FLASH interrupts.
+* Input          : - FLASH_IT: specifies the FLASH interrupt sources to be 
+*                    enabled or disabled.
+*                    This parameter can be any combination of the following values:
+*                       - FLASH_IT_ERROR: FLASH Error Interrupt
+*                       - FLASH_IT_EOP: FLASH end of operation Interrupt
+* Output         : None
+* Return         : None 
+*******************************************************************************/
+void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_IT(FLASH_IT)); 
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if(NewState != DISABLE)
+  {
+    /* Enable the interrupt sources */
+    FLASH-&gt;CR |= FLASH_IT;
+  }
+  else
+  {
+    /* Disable the interrupt sources */
+    FLASH-&gt;CR &amp;= ~(u32)FLASH_IT;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_GetFlagStatus
+* Description    : Checks whether the specified FLASH flag is set or not.
+* Input          : - FLASH_FLAG: specifies the FLASH flag to check.
+*                     This parameter can be one of the following values:
+*                    - FLASH_FLAG_BSY: FLASH Busy flag           
+*                    - FLASH_FLAG_PGERR: FLASH Program error flag       
+*                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
+*                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
+*                    - FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
+* Output         : None
+* Return         : The new state of FLASH_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
+
+  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
+  {
+    if((FLASH-&gt;OBR &amp; FLASH_FLAG_OPTERR) != (u32)RESET)
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+  else
+  {
+   if((FLASH-&gt;SR &amp; FLASH_FLAG) != (u32)RESET)
+    {
+      bitstatus = SET;
+    }
+    else
+    {
+      bitstatus = RESET;
+    }
+  }
+  /* Return the new state of FLASH_FLAG (SET or RESET) */
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_ClearFlag
+* Description    : Clears the FLASH's pending flags.
+* Input          : - FLASH_FLAG: specifies the FLASH flags to clear.
+*                    This parameter can be any combination of the following values:
+*                    - FLASH_FLAG_BSY: FLASH Busy flag           
+*                    - FLASH_FLAG_PGERR: FLASH Program error flag       
+*                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
+*                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FLASH_ClearFlag(u16 FLASH_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
+  
+  /* Clear the flags */
+  FLASH-&gt;SR = FLASH_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_GetStatus
+* Description    : Returns the FLASH Status.
+* Input          : None
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP or FLASH_COMPLETE
+*******************************************************************************/
+FLASH_Status FLASH_GetStatus(void)
+{
+  FLASH_Status flashstatus = FLASH_COMPLETE;
+  
+  if((FLASH-&gt;SR &amp; FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
+  {
+    flashstatus = FLASH_BUSY;
+  }
+  else 
+  {  
+    if(FLASH-&gt;SR &amp; FLASH_FLAG_PGERR)
+    { 
+      flashstatus = FLASH_ERROR_PG;
+    }
+    else 
+    {
+      if(FLASH-&gt;SR &amp; FLASH_FLAG_WRPRTERR)
+      {
+        flashstatus = FLASH_ERROR_WRP;
+      }
+      else
+      {
+        flashstatus = FLASH_COMPLETE;
+      }
+    }
+  }
+  /* Return the Flash Status */
+  return flashstatus;
+}
+
+/*******************************************************************************
+* Function Name  : FLASH_WaitForLastOperation
+* Description    : Waits for a Flash operation to complete or a TIMEOUT to occur.
+* Input          : - Timeout: FLASH progamming Timeout
+* Output         : None
+* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
+*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
+*                  FLASH_TIMEOUT.
+*******************************************************************************/
+FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
+{ 
+  FLASH_Status status = FLASH_COMPLETE;
+   
+  /* Check for the Flash Status */
+  status = FLASH_GetStatus();
+
+  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
+  while((status == FLASH_BUSY) &amp;&amp; (Timeout != 0x00))
+  {
+    delay();
+    status = FLASH_GetStatus();
+    Timeout--;
+  }
+
+  if(Timeout == 0x00 )
+  {
+    status = FLASH_TIMEOUT;
+  }
+
+  /* Return the operation status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : delay
+* Description    : Inserts a time delay.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void delay(void)
+{
+  vu32 i = 0;
+
+  for(i = 0xFF; i != 0; i--)
+  {
+  }
+}
+#endif
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_fsmc.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,857 +1,857 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_fsmc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the FSMC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_fsmc.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* --------------------- FSMC registers bit mask ---------------------------- */
-/* FSMC BCRx Mask */
-#define BCR_MBKEN_Set                       ((u32)0x00000001)
-#define BCR_MBKEN_Reset                     ((u32)0x000FFFFE)
-#define BCR_FACCEN_Set                      ((u32)0x00000040)
-
-/* FSMC PCRx Mask */
-#define PCR_PBKEN_Set                       ((u32)0x00000004)
-#define PCR_PBKEN_Reset                     ((u32)0x000FFFFB)
-#define PCR_ECCEN_Set                       ((u32)0x00000040)
-#define PCR_ECCEN_Reset                     ((u32)0x000FFFBF)
-#define PCR_MemoryType_NAND                 ((u32)0x00000008)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMDeInit
-* Description    : Deinitializes the FSMC NOR/SRAM Banks registers to their default 
-*                  reset values.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
-*                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
-*                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
-*                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMDeInit(u32 FSMC_Bank)
-{
-  /* Check the parameter */
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
-  
-  /* FSMC_Bank1_NORSRAM1 */
-  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
-  {
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030DB;    
-  }
-  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
-  else
-  {   
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030D2; 
-  }
-
-  FSMC_Bank1-&gt;BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
-  FSMC_Bank1E-&gt;BWTR[FSMC_Bank] = 0x0FFFFFFF;  
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDDeInit
-* Description    : Deinitializes the FSMC NAND Banks registers to their default 
-*                  reset values.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDDeInit(u32 FSMC_Bank)
-{
-  /* Check the parameter */
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* Set the FSMC_Bank2 registers to their reset values */
-    FSMC_Bank2-&gt;PCR2 = 0x00000018;
-    FSMC_Bank2-&gt;SR2 = 0x00000040;
-    FSMC_Bank2-&gt;PMEM2 = 0xFCFCFCFC;
-    FSMC_Bank2-&gt;PATT2 = 0xFCFCFCFC;  
-  }
-  /* FSMC_Bank3_NAND */  
-  else
-  {
-    /* Set the FSMC_Bank3 registers to their reset values */
-    FSMC_Bank3-&gt;PCR3 = 0x00000018;
-    FSMC_Bank3-&gt;SR3 = 0x00000040;
-    FSMC_Bank3-&gt;PMEM3 = 0xFCFCFCFC;
-    FSMC_Bank3-&gt;PATT3 = 0xFCFCFCFC; 
-  }  
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDDeInit
-* Description    : Deinitializes the FSMC PCCARD Bank registers to their default 
-*                  reset values.
-* Input          : None                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDDeInit(void)
-{
-  /* Set the FSMC_Bank4 registers to their reset values */
-  FSMC_Bank4-&gt;PCR4 = 0x00000018; 
-  FSMC_Bank4-&gt;SR4 = 0x00000000;	
-  FSMC_Bank4-&gt;PMEM4 = 0xFCFCFCFC;
-  FSMC_Bank4-&gt;PATT4 = 0xFCFCFCFC;
-  FSMC_Bank4-&gt;PIO4 = 0xFCFCFCFC;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMInit
-* Description    : Initializes the FSMC NOR/SRAM Banks according to the 
-*                  specified parameters in the FSMC_NORSRAMInitStruct.
-* Input          : - FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
-*                  structure that contains the configuration information for 
-*                  the FSMC NOR/SRAM specified Banks.                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct-&gt;FSMC_Bank));
-  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux));
-  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType));
-  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth));
-  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode));
-  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity));
-  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode));
-  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive));
-  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation));
-  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal));
-  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode));
-  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst));  
-  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime));
-  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime));
-  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime));
-  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration));
-  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision));
-  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency));
-  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode)); 
-  
-  /* Bank1 NOR/SRAM control register configuration */ 
-  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
-            (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode |
-            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst;
-
-  if(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType == FSMC_MemoryType_NOR)
-  {
-    FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] |= (u32)BCR_FACCEN_Set;
-  }
-
-  /* Bank1 NOR/SRAM timing register configuration */
-  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank+1] = 
-            (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration &lt;&lt; 16) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
-            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
-             FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode;
-            
-
-    
-  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
-  if(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
-  {
-    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime));
-    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime));
-    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime));
-    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision));
-    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency));
-    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode));
-
-    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
-              (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime |
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4 )|
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
-              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
-               FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode;
-  }
-  else
-  {
-    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 0x0FFFFFFF;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDInit
-* Description    : Initializes the FSMC NAND Banks according to the specified 
-*                  parameters in the FSMC_NANDInitStruct.
-* Input          : - FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
-*                    structure that contains the configuration information for 
-*                    the FSMC NAND specified Banks.                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
-{
-  u32 tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
-    
-  /* Check the parameters */
-  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct-&gt;FSMC_Bank));
-  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct-&gt;FSMC_Waitfeature));
-  assert_param( IS_FSMC_DATA_WIDTH(FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth));
-  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct-&gt;FSMC_ECC));
-  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize));
-  assert_param( IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping));
-  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime));
-  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime));
-
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-  
-  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
-  tmppcr = (u32)FSMC_NANDInitStruct-&gt;FSMC_Waitfeature |
-            PCR_MemoryType_NAND |
-            FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth |
-            FSMC_NANDInitStruct-&gt;FSMC_ECC |
-            FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize |
-            FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping |
-            (FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9 )|
-            (FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
-            
-  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
-  tmppmem = (u32)FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
-            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
-            
-  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
-  tmppatt = (u32)FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
-            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);
-  
-  if(FSMC_NANDInitStruct-&gt;FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* FSMC_Bank2_NAND registers configuration */
-    FSMC_Bank2-&gt;PCR2 = tmppcr;
-    FSMC_Bank2-&gt;PMEM2 = tmppmem;
-    FSMC_Bank2-&gt;PATT2 = tmppatt;
-  }
-  else
-  {
-    /* FSMC_Bank3_NAND registers configuration */
-    FSMC_Bank3-&gt;PCR3 = tmppcr;
-    FSMC_Bank3-&gt;PMEM3 = tmppmem;
-    FSMC_Bank3-&gt;PATT3 = tmppatt;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDInit
-* Description    : Initializes the FSMC PCCARD Bank according to the specified 
-*                  parameters in the FSMC_PCCARDInitStruct.
-* Input          : - FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
-*                    structure that contains the configuration information for 
-*                    the FSMC PCCARD Bank.                       
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature));
-  assert_param(IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping));
-  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime));
-  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime));
-
- 
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-  
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
-  
-  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
-  FSMC_Bank4-&gt;PCR4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature |
-                     FSMC_MemoryDataWidth_16b |  
-                     FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9) |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
-            
-  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
-  FSMC_Bank4-&gt;PMEM4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
-            
-  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
-  FSMC_Bank4-&gt;PATT4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);	
-            
-  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
-  FSMC_Bank4-&gt;PIO4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
-                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);             
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMStructInit
-* Description    : Fills each FSMC_NORSRAMInitStruct member with its default value.
-* Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
-{  
-  /* Reset NOR/SRAM Init structure parameters values */
-  FSMC_NORSRAMInitStruct-&gt;FSMC_Bank = FSMC_Bank1_NORSRAM1;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType = FSMC_MemoryType_SRAM;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode = FSMC_WrapMode_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation = FSMC_WriteOperation_Enable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal = FSMC_WaitSignal_Enable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst = FSMC_WriteBurst_Disable;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A; 
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
-  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDStructInit
-* Description    : Fills each FSMC_NANDInitStruct member with its default value.
-* Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NANDInitTypeDef 
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
-{ 
-  /* Reset NAND Init structure parameters values */
-  FSMC_NANDInitStruct-&gt;FSMC_Bank = FSMC_Bank2_NAND;
-  FSMC_NANDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
-  FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
-  FSMC_NANDInitStruct-&gt;FSMC_ECC = FSMC_ECC_Disable;
-  FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
-  FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
-  FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
-  FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	  
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDStructInit
-* Description    : Fills each FSMC_PCCARDInitStruct member with its default value.
-* Input          : - FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
-{
-  /* Reset PCCARD Init structure parameters values */
-  FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
-  FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
-  FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NORSRAMCmd
-* Description    : Enables or disables the specified NOR/SRAM Memory Bank.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
-*                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
-*                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
-*                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
-*                : - NewState: new state of the FSMC_Bank.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
-  }
-  else
-  {
-    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
-    FSMC_Bank1-&gt;BTCR[FSMC_Bank] &amp;= BCR_MBKEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDCmd
-* Description    : Enables or disables the specified NAND Memory Bank.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                : - NewState: new state of the FSMC_Bank.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 |= PCR_PBKEN_Set;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 |= PCR_PBKEN_Set;
-    }
-  }
-  else
-  {
-    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 &amp;= PCR_PBKEN_Reset;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 &amp;= PCR_PBKEN_Reset;
-    }
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_PCCARDCmd
-* Description    : Enables or disables the PCCARD Memory Bank.
-* Input          : - NewState: new state of the PCCARD Memory Bank.  
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_PCCARDCmd(FunctionalState NewState)
-{
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
-    FSMC_Bank4-&gt;PCR4 |= PCR_PBKEN_Set;
-  }
-  else
-  {
-    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
-    FSMC_Bank4-&gt;PCR4 &amp;= PCR_PBKEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_NANDECCCmd
-* Description    : Enables or disables the FSMC NAND ECC feature.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                : - NewState: new state of the FSMC NAND ECC feature.  
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 |= PCR_ECCEN_Set;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 |= PCR_ECCEN_Set;
-    }
-  }
-  else
-  {
-    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;PCR2 &amp;= PCR_ECCEN_Reset;
-    }
-    else
-    {
-      FSMC_Bank3-&gt;PCR3 &amp;= PCR_ECCEN_Reset;
-    }
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_GetECC
-* Description    : Returns the error correction code register value.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-* Output         : None
-* Return         : The Error Correction Code (ECC) value.
-*******************************************************************************/
-u32 FSMC_GetECC(u32 FSMC_Bank)
-{
-  u32 eccval = 0x00000000;
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* Get the ECCR2 register value */
-    eccval = FSMC_Bank2-&gt;ECCR2;
-  }
-  else
-  {
-    /* Get the ECCR3 register value */
-    eccval = FSMC_Bank3-&gt;ECCR3;
-  }
-  /* Return the error correction code value */
-  return(eccval);
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_ITConfig
-* Description    : Enables or disables the specified FSMC interrupts.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_IT: specifies the FSMC interrupt sources to be
-*                    enabled or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
-*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
-*                  - NewState: new state of the specified FSMC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_IT(FSMC_IT));	
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected FSMC_Bank2 interrupts */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2-&gt;SR2 |= FSMC_IT;
-    }
-    /* Enable the selected FSMC_Bank3 interrupts */
-    else if (FSMC_Bank == FSMC_Bank3_NAND)
-    {
-      FSMC_Bank3-&gt;SR3 |= FSMC_IT;
-    }
-    /* Enable the selected FSMC_Bank4 interrupts */
-    else
-    {
-      FSMC_Bank4-&gt;SR4 |= FSMC_IT;    
-    }
-  }
-  else
-  {
-    /* Disable the selected FSMC_Bank2 interrupts */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      
-      FSMC_Bank2-&gt;SR2 &amp;= (u32)~FSMC_IT;
-    }
-    /* Disable the selected FSMC_Bank3 interrupts */
-    else if (FSMC_Bank == FSMC_Bank3_NAND)
-    {
-      FSMC_Bank3-&gt;SR3 &amp;= (u32)~FSMC_IT;
-    }
-    /* Disable the selected FSMC_Bank4 interrupts */
-    else
-    {
-      FSMC_Bank4-&gt;SR4 &amp;= (u32)~FSMC_IT;    
-    }
-  }
-}
-                  
-/*******************************************************************************
-* Function Name  : FSMC_GetFlagStatus
-* Description    : Checks whether the specified FSMC flag is set or not.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
-*                       - FSMC_FLAG_Level: Level detection Flag.
-*                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
-*                       - FSMC_FLAG_FEMPT: Fifo empty Flag. 
-* Output         : None
-* Return         : The new state of FSMC_FLAG (SET or RESET).
-*******************************************************************************/                   
-FlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  u32 tmpsr = 0x00000000;
-  
-  /* Check the parameters */
-  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    tmpsr = FSMC_Bank2-&gt;SR2;
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    tmpsr = FSMC_Bank3-&gt;SR3;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    tmpsr = FSMC_Bank4-&gt;SR4;
-  } 
-  
-  /* Get the flag status */
-  if ((tmpsr &amp; FSMC_FLAG) != (u16)RESET )
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_ClearFlag
-* Description    : Clears the FSMC&#146;s pending flags.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination of the following values:
-*                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
-*                       - FSMC_FLAG_Level: Level detection Flag.
-*                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
-* Output         : None
-* Return         : None
-*******************************************************************************/                   
-void FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG)
-{
- /* Check the parameters */
-  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
-    
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    FSMC_Bank2-&gt;SR2 &amp;= ~FSMC_FLAG; 
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    FSMC_Bank3-&gt;SR3 &amp;= ~FSMC_FLAG;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    FSMC_Bank4-&gt;SR4 &amp;= ~FSMC_FLAG;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_GetITStatus
-* Description    : Checks whether the specified FSMC interrupt has occurred or not.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_IT: specifies the FSMC interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
-*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt. 
-* Output         : None
-* Return         : The new state of FSMC_IT (SET or RESET).
-*******************************************************************************/ 
-ITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
-  
-  /* Check the parameters */
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_GET_IT(FSMC_IT));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    tmpsr = FSMC_Bank2-&gt;SR2;
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    tmpsr = FSMC_Bank3-&gt;SR3;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    tmpsr = FSMC_Bank4-&gt;SR4;
-  } 
-  
-  itstatus = tmpsr &amp; FSMC_IT;
-  
-  itenable = tmpsr &amp; (FSMC_IT &gt;&gt; 3);
-
-  if ((itstatus != (u32)RESET)  &amp;&amp; (itenable != (u32)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus; 
-}
-
-/*******************************************************************************
-* Function Name  : FSMC_ClearITPendingBit
-* Description    : Clears the FSMC&#146;s interrupt pending bits.
-* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
-*                    This parameter can be one of the following values:
-*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
-*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
-*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-*                  - FSMC_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
-*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_IT(FSMC_IT));
-    
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    FSMC_Bank2-&gt;SR2 &amp;= ~(FSMC_IT &gt;&gt; 3); 
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    FSMC_Bank3-&gt;SR3 &amp;= ~(FSMC_IT &gt;&gt; 3);
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    FSMC_Bank4-&gt;SR4 &amp;= ~(FSMC_IT &gt;&gt; 3);
-  }
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_fsmc.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the FSMC firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_fsmc.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* --------------------- FSMC registers bit mask ---------------------------- */
+/* FSMC BCRx Mask */
+#define BCR_MBKEN_Set                       ((u32)0x00000001)
+#define BCR_MBKEN_Reset                     ((u32)0x000FFFFE)
+#define BCR_FACCEN_Set                      ((u32)0x00000040)
+
+/* FSMC PCRx Mask */
+#define PCR_PBKEN_Set                       ((u32)0x00000004)
+#define PCR_PBKEN_Reset                     ((u32)0x000FFFFB)
+#define PCR_ECCEN_Set                       ((u32)0x00000040)
+#define PCR_ECCEN_Reset                     ((u32)0x000FFFBF)
+#define PCR_MemoryType_NAND                 ((u32)0x00000008)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : FSMC_NORSRAMDeInit
+* Description    : Deinitializes the FSMC NOR/SRAM Banks registers to their default 
+*                  reset values.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
+*                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
+*                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
+*                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4                       
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NORSRAMDeInit(u32 FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+  
+  /* FSMC_Bank1_NORSRAM1 */
+  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
+  {
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030DB;    
+  }
+  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
+  else
+  {   
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] = 0x000030D2; 
+  }
+
+  FSMC_Bank1-&gt;BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
+  FSMC_Bank1E-&gt;BWTR[FSMC_Bank] = 0x0FFFFFFF;  
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NANDDeInit
+* Description    : Deinitializes the FSMC NAND Banks registers to their default 
+*                  reset values.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND                       
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NANDDeInit(u32 FSMC_Bank)
+{
+  /* Check the parameter */
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Set the FSMC_Bank2 registers to their reset values */
+    FSMC_Bank2-&gt;PCR2 = 0x00000018;
+    FSMC_Bank2-&gt;SR2 = 0x00000040;
+    FSMC_Bank2-&gt;PMEM2 = 0xFCFCFCFC;
+    FSMC_Bank2-&gt;PATT2 = 0xFCFCFCFC;  
+  }
+  /* FSMC_Bank3_NAND */  
+  else
+  {
+    /* Set the FSMC_Bank3 registers to their reset values */
+    FSMC_Bank3-&gt;PCR3 = 0x00000018;
+    FSMC_Bank3-&gt;SR3 = 0x00000040;
+    FSMC_Bank3-&gt;PMEM3 = 0xFCFCFCFC;
+    FSMC_Bank3-&gt;PATT3 = 0xFCFCFCFC; 
+  }  
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_PCCARDDeInit
+* Description    : Deinitializes the FSMC PCCARD Bank registers to their default 
+*                  reset values.
+* Input          : None                       
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_PCCARDDeInit(void)
+{
+  /* Set the FSMC_Bank4 registers to their reset values */
+  FSMC_Bank4-&gt;PCR4 = 0x00000018; 
+  FSMC_Bank4-&gt;SR4 = 0x00000000;	
+  FSMC_Bank4-&gt;PMEM4 = 0xFCFCFCFC;
+  FSMC_Bank4-&gt;PATT4 = 0xFCFCFCFC;
+  FSMC_Bank4-&gt;PIO4 = 0xFCFCFCFC;
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NORSRAMInit
+* Description    : Initializes the FSMC NOR/SRAM Banks according to the 
+*                  specified parameters in the FSMC_NORSRAMInitStruct.
+* Input          : - FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
+*                  structure that contains the configuration information for 
+*                  the FSMC NOR/SRAM specified Banks.                       
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct-&gt;FSMC_Bank));
+  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux));
+  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType));
+  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth));
+  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode));
+  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity));
+  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode));
+  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive));
+  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation));
+  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal));
+  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode));
+  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst));  
+  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime));
+  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime));
+  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime));
+  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration));
+  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision));
+  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency));
+  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode)); 
+  
+  /* Bank1 NOR/SRAM control register configuration */ 
+  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
+            (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode |
+            FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst;
+
+  if(FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType == FSMC_MemoryType_NOR)
+  {
+    FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] |= (u32)BCR_FACCEN_Set;
+  }
+
+  /* Bank1 NOR/SRAM timing register configuration */
+  FSMC_Bank1-&gt;BTCR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank+1] = 
+            (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration &lt;&lt; 16) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
+            (FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
+             FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode;
+            
+
+    
+  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
+  if(FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
+  {
+    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime));
+    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime));
+    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime));
+    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision));
+    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency));
+    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode));
+
+    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 
+              (u32)FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime |
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime &lt;&lt; 4 )|
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime &lt;&lt; 8) |
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision &lt;&lt; 20) |
+              (FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency &lt;&lt; 24) |
+               FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode;
+  }
+  else
+  {
+    FSMC_Bank1E-&gt;BWTR[FSMC_NORSRAMInitStruct-&gt;FSMC_Bank] = 0x0FFFFFFF;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NANDInit
+* Description    : Initializes the FSMC NAND Banks according to the specified 
+*                  parameters in the FSMC_NANDInitStruct.
+* Input          : - FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
+*                    structure that contains the configuration information for 
+*                    the FSMC NAND specified Banks.                       
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{
+  u32 tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
+    
+  /* Check the parameters */
+  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct-&gt;FSMC_Bank));
+  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct-&gt;FSMC_Waitfeature));
+  assert_param( IS_FSMC_DATA_WIDTH(FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth));
+  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct-&gt;FSMC_ECC));
+  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize));
+  assert_param( IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping));
+  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime));
+  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime));
+
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  
+  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
+  tmppcr = (u32)FSMC_NANDInitStruct-&gt;FSMC_Waitfeature |
+            PCR_MemoryType_NAND |
+            FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth |
+            FSMC_NANDInitStruct-&gt;FSMC_ECC |
+            FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize |
+            FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping |
+            (FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9 )|
+            (FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
+            
+  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
+  tmppmem = (u32)FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
+            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+            (FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
+            
+  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
+  tmppatt = (u32)FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
+            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+            (FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);
+  
+  if(FSMC_NANDInitStruct-&gt;FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* FSMC_Bank2_NAND registers configuration */
+    FSMC_Bank2-&gt;PCR2 = tmppcr;
+    FSMC_Bank2-&gt;PMEM2 = tmppmem;
+    FSMC_Bank2-&gt;PATT2 = tmppatt;
+  }
+  else
+  {
+    /* FSMC_Bank3_NAND registers configuration */
+    FSMC_Bank3-&gt;PCR3 = tmppcr;
+    FSMC_Bank3-&gt;PMEM3 = tmppmem;
+    FSMC_Bank3-&gt;PATT3 = tmppatt;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_PCCARDInit
+* Description    : Initializes the FSMC PCCARD Bank according to the specified 
+*                  parameters in the FSMC_PCCARDInitStruct.
+* Input          : - FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
+*                    structure that contains the configuration information for 
+*                    the FSMC PCCARD Bank.                       
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature));
+  assert_param(IS_FSMC_ADDRESS_LOW_MAPPING(FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping));
+  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime));
+  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime));
+
+ 
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+
+  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime));
+  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime));
+  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime));
+  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime));
+  
+  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
+  FSMC_Bank4-&gt;PCR4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature |
+                     FSMC_MemoryDataWidth_16b |  
+                     FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping |
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime &lt;&lt; 9) |
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime &lt;&lt; 13);
+            
+  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
+  FSMC_Bank4-&gt;PMEM4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24); 
+            
+  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
+  FSMC_Bank4-&gt;PATT4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+                      (FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);	
+            
+  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
+  FSMC_Bank4-&gt;PIO4 = (u32)FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime |
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime &lt;&lt; 8) |
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime &lt;&lt; 16)|
+                     (FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime &lt;&lt; 24);             
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NORSRAMStructInit
+* Description    : Fills each FSMC_NORSRAMInitStruct member with its default value.
+* Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
+*                    structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
+{  
+  /* Reset NOR/SRAM Init structure parameters values */
+  FSMC_NORSRAMInitStruct-&gt;FSMC_Bank = FSMC_Bank1_NORSRAM1;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryType = FSMC_MemoryType_SRAM;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WrapMode = FSMC_WrapMode_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteOperation = FSMC_WriteOperation_Enable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WaitSignal = FSMC_WaitSignal_Enable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteBurst = FSMC_WriteBurst_Disable;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_ReadWriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A; 
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressSetupTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AddressHoldTime = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataSetupTime = 0xFF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_BusTurnAroundDuration = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_CLKDivision = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_DataLatency = 0xF;
+  FSMC_NORSRAMInitStruct-&gt;FSMC_WriteTimingStruct-&gt;FSMC_AccessMode = FSMC_AccessMode_A;
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NANDStructInit
+* Description    : Fills each FSMC_NANDInitStruct member with its default value.
+* Input          : - FSMC_NORSRAMInitStruct: pointer to a FSMC_NANDInitTypeDef 
+*                    structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
+{ 
+  /* Reset NAND Init structure parameters values */
+  FSMC_NANDInitStruct-&gt;FSMC_Bank = FSMC_Bank2_NAND;
+  FSMC_NANDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_NANDInitStruct-&gt;FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
+  FSMC_NANDInitStruct-&gt;FSMC_ECC = FSMC_ECC_Disable;
+  FSMC_NANDInitStruct-&gt;FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
+  FSMC_NANDInitStruct-&gt;FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
+  FSMC_NANDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
+  FSMC_NANDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_NANDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	  
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_PCCARDStructInit
+* Description    : Fills each FSMC_PCCARDInitStruct member with its default value.
+* Input          : - FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
+*                    structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
+{
+  /* Reset PCCARD Init structure parameters values */
+  FSMC_PCCARDInitStruct-&gt;FSMC_Waitfeature = FSMC_Waitfeature_Disable;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AddressLowMapping = FSMC_AddressLowMapping_Direct;
+  FSMC_PCCARDInitStruct-&gt;FSMC_TCLRSetupTime = 0x0;
+  FSMC_PCCARDInitStruct-&gt;FSMC_TARSetupTime = 0x0;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_CommonSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_AttributeSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;	
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_SetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_WaitSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HoldSetupTime = 0xFC;
+  FSMC_PCCARDInitStruct-&gt;FSMC_IOSpaceTimingStruct-&gt;FSMC_HiZSetupTime = 0xFC;
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NORSRAMCmd
+* Description    : Enables or disables the specified NOR/SRAM Memory Bank.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
+*                       - FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
+*                       - FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
+*                       - FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
+*                : - NewState: new state of the FSMC_Bank.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
+  }
+  else
+  {
+    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
+    FSMC_Bank1-&gt;BTCR[FSMC_Bank] &amp;= BCR_MBKEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NANDCmd
+* Description    : Enables or disables the specified NAND Memory Bank.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+*                : - NewState: new state of the FSMC_Bank.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 |= PCR_PBKEN_Set;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 |= PCR_PBKEN_Set;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 &amp;= PCR_PBKEN_Reset;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 &amp;= PCR_PBKEN_Reset;
+    }
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_PCCARDCmd
+* Description    : Enables or disables the PCCARD Memory Bank.
+* Input          : - NewState: new state of the PCCARD Memory Bank.  
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_PCCARDCmd(FunctionalState NewState)
+{
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
+    FSMC_Bank4-&gt;PCR4 |= PCR_PBKEN_Set;
+  }
+  else
+  {
+    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
+    FSMC_Bank4-&gt;PCR4 &amp;= PCR_PBKEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_NANDECCCmd
+* Description    : Enables or disables the FSMC NAND ECC feature.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+*                : - NewState: new state of the FSMC NAND ECC feature.  
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 |= PCR_ECCEN_Set;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 |= PCR_ECCEN_Set;
+    }
+  }
+  else
+  {
+    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;PCR2 &amp;= PCR_ECCEN_Reset;
+    }
+    else
+    {
+      FSMC_Bank3-&gt;PCR3 &amp;= PCR_ECCEN_Reset;
+    }
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_GetECC
+* Description    : Returns the error correction code register value.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+* Output         : None
+* Return         : The Error Correction Code (ECC) value.
+*******************************************************************************/
+u32 FSMC_GetECC(u32 FSMC_Bank)
+{
+  u32 eccval = 0x00000000;
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    /* Get the ECCR2 register value */
+    eccval = FSMC_Bank2-&gt;ECCR2;
+  }
+  else
+  {
+    /* Get the ECCR3 register value */
+    eccval = FSMC_Bank3-&gt;ECCR3;
+  }
+  /* Return the error correction code value */
+  return(eccval);
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_ITConfig
+* Description    : Enables or disables the specified FSMC interrupts.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+*                  - FSMC_IT: specifies the FSMC interrupt sources to be
+*                    enabled or disabled.
+*                    This parameter can be any combination of the following values:
+*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
+*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
+*                  - NewState: new state of the specified FSMC interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState)
+{
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));	
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      FSMC_Bank2-&gt;SR2 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3-&gt;SR3 |= FSMC_IT;
+    }
+    /* Enable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4-&gt;SR4 |= FSMC_IT;    
+    }
+  }
+  else
+  {
+    /* Disable the selected FSMC_Bank2 interrupts */
+    if(FSMC_Bank == FSMC_Bank2_NAND)
+    {
+      
+      FSMC_Bank2-&gt;SR2 &amp;= (u32)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank3 interrupts */
+    else if (FSMC_Bank == FSMC_Bank3_NAND)
+    {
+      FSMC_Bank3-&gt;SR3 &amp;= (u32)~FSMC_IT;
+    }
+    /* Disable the selected FSMC_Bank4 interrupts */
+    else
+    {
+      FSMC_Bank4-&gt;SR4 &amp;= (u32)~FSMC_IT;    
+    }
+  }
+}
+                  
+/*******************************************************************************
+* Function Name  : FSMC_GetFlagStatus
+* Description    : Checks whether the specified FSMC flag is set or not.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+*                  - FSMC_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
+*                       - FSMC_FLAG_Level: Level detection Flag.
+*                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
+*                       - FSMC_FLAG_FEMPT: Fifo empty Flag. 
+* Output         : None
+* Return         : The new state of FSMC_FLAG (SET or RESET).
+*******************************************************************************/                   
+FlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  u32 tmpsr = 0x00000000;
+  
+  /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2-&gt;SR2;
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3-&gt;SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4-&gt;SR4;
+  } 
+  
+  /* Get the flag status */
+  if ((tmpsr &amp; FSMC_FLAG) != (u16)RESET )
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_ClearFlag
+* Description    : Clears the FSMC's pending flags.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+*                  - FSMC_FLAG: specifies the flag to clear.
+*                    This parameter can be any combination of the following values:
+*                       - FSMC_FLAG_RisingEdge: Rising egde detection Flag.
+*                       - FSMC_FLAG_Level: Level detection Flag.
+*                       - FSMC_FLAG_FallingEdge: Falling egde detection Flag.
+* Output         : None
+* Return         : None
+*******************************************************************************/                   
+void FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG)
+{
+ /* Check the parameters */
+  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
+    
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2-&gt;SR2 &amp;= ~FSMC_FLAG; 
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3-&gt;SR3 &amp;= ~FSMC_FLAG;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4-&gt;SR4 &amp;= ~FSMC_FLAG;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_GetITStatus
+* Description    : Checks whether the specified FSMC interrupt has occurred or not.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+*                  - FSMC_IT: specifies the FSMC interrupt source to check.
+*                    This parameter can be one of the following values:
+*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
+*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt. 
+* Output         : None
+* Return         : The new state of FSMC_IT (SET or RESET).
+*******************************************************************************/ 
+ITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT)
+{
+  ITStatus bitstatus = RESET;
+  u32 tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
+  
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_GET_IT(FSMC_IT));
+  
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    tmpsr = FSMC_Bank2-&gt;SR2;
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    tmpsr = FSMC_Bank3-&gt;SR3;
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    tmpsr = FSMC_Bank4-&gt;SR4;
+  } 
+  
+  itstatus = tmpsr &amp; FSMC_IT;
+  
+  itenable = tmpsr &amp; (FSMC_IT &gt;&gt; 3);
+
+  if ((itstatus != (u32)RESET)  &amp;&amp; (itenable != (u32)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus; 
+}
+
+/*******************************************************************************
+* Function Name  : FSMC_ClearITPendingBit
+* Description    : Clears the FSMC's interrupt pending bits.
+* Input          : - FSMC_Bank: specifies the FSMC Bank to be used
+*                    This parameter can be one of the following values:
+*                       - FSMC_Bank2_NAND: FSMC Bank2 NAND 
+*                       - FSMC_Bank3_NAND: FSMC Bank3 NAND
+*                       - FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
+*                  - FSMC_IT: specifies the interrupt pending bit to clear.
+*                    This parameter can be any combination of the following values:
+*                       - FSMC_IT_RisingEdge: Rising edge detection interrupt. 
+*                       - FSMC_IT_Level: Level edge detection interrupt.                                  
+*                       - FSMC_IT_FallingEdge: Falling edge detection interrupt.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
+  assert_param(IS_FSMC_IT(FSMC_IT));
+    
+  if(FSMC_Bank == FSMC_Bank2_NAND)
+  {
+    FSMC_Bank2-&gt;SR2 &amp;= ~(FSMC_IT &gt;&gt; 3); 
+  }  
+  else if(FSMC_Bank == FSMC_Bank3_NAND)
+  {
+    FSMC_Bank3-&gt;SR3 &amp;= ~(FSMC_IT &gt;&gt; 3);
+  }
+  /* FSMC_Bank4_PCCARD*/
+  else
+  {
+    FSMC_Bank4-&gt;SR4 &amp;= ~(FSMC_IT &gt;&gt; 3);
+  }
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_gpio.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,583 +1,583 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_gpio.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the GPIO firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_gpio.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ------------ RCC registers bit address in the alias region ----------- */
-#define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
-
-/* --- EVENTCR Register ---*/
-/* Alias word address of EVOE bit */
-#define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
-#define EVOE_BitNumber              ((u8)0x07)
-#define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
-
-#define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
-#define LSB_MASK                    ((u16)0xFFFF)
-#define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
-#define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
-#define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
-#define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : GPIO_DeInit
-* Description    : Deinitializes the GPIOx peripheral registers to their default
-*                  reset values.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_DeInit(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  switch (*(u32*)&amp;GPIOx)
-  {
-    case GPIOA_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
-      break;
-
-    case GPIOB_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
-      break;
-
-    case GPIOC_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
-      break;
-
-    case GPIOD_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
-      break;
-      
-    case GPIOE_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
-      break; 
-
-    case GPIOF_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
-      break;
-
-    case GPIOG_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
-      break;                       
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_AFIODeInit
-* Description    : Deinitializes the Alternate Functions (remap, event control
-*                  and EXTI configuration) registers to their default reset
-*                  values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_AFIODeInit(void)
-{
-  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
-  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_Init
-* Description    : Initializes the GPIOx peripheral according to the specified
-*                  parameters in the GPIO_InitStruct.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
-*                    contains the configuration information for the specified GPIO
-*                    peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
-{
-  u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
-  u32 tmpreg = 0x00, pinmask = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));
-  assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin));  
-  
-/*---------------------------- GPIO Mode Configuration -----------------------*/
-  currentmode = ((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)0x0F);
-
-  if ((((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)0x10)) != 0x00)
-  { 
-    /* Check the parameters */
-    assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));
-    /* Output mode */
-    currentmode |= (u32)GPIO_InitStruct-&gt;GPIO_Speed;
-  }
-
-/*---------------------------- GPIO CRL Configuration ------------------------*/
-  /* Configure the eight low port pins */
-  if (((u32)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((u32)0x00FF)) != 0x00)
-  {
-    tmpreg = GPIOx-&gt;CRL;
-
-    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
-    {
-      pos = ((u32)0x01) &lt;&lt; pinpos;
-      /* Get the port pins position */
-      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;
-
-      if (currentpin == pos)
-      {
-        pos = pinpos &lt;&lt; 2;
-        /* Clear the corresponding low control register bits */
-        pinmask = ((u32)0x0F) &lt;&lt; pos;
-        tmpreg &amp;= ~pinmask;
-
-        /* Write the mode configuration in the corresponding bits */
-        tmpreg |= (currentmode &lt;&lt; pos);
-
-        /* Reset the corresponding ODR bit */
-        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
-        {
-          GPIOx-&gt;BRR = (((u32)0x01) &lt;&lt; pinpos);
-        }
-        else
-        {
-          /* Set the corresponding ODR bit */
-          if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
-          {
-            GPIOx-&gt;BSRR = (((u32)0x01) &lt;&lt; pinpos);
-          }
-        }
-      }
-    }
-    GPIOx-&gt;CRL = tmpreg;
-  }
-
-/*---------------------------- GPIO CRH Configuration ------------------------*/
-  /* Configure the eight high port pins */
-  if (GPIO_InitStruct-&gt;GPIO_Pin &gt; 0x00FF)
-  {
-    tmpreg = GPIOx-&gt;CRH;
-    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
-    {
-      pos = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
-      /* Get the port pins position */
-      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);
-      if (currentpin == pos)
-      {
-        pos = pinpos &lt;&lt; 2;
-        /* Clear the corresponding high control register bits */
-        pinmask = ((u32)0x0F) &lt;&lt; pos;
-        tmpreg &amp;= ~pinmask;
-
-        /* Write the mode configuration in the corresponding bits */
-        tmpreg |= (currentmode &lt;&lt; pos);
-
-        /* Reset the corresponding ODR bit */
-        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
-        {
-          GPIOx-&gt;BRR = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
-        }
-        /* Set the corresponding ODR bit */
-        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
-        {
-          GPIOx-&gt;BSRR = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
-        }
-      }
-    }
-    GPIOx-&gt;CRH = tmpreg;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_StructInit
-* Description    : Fills each GPIO_InitStruct member with its default value.
-* Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
-{
-  /* Reset GPIO init structure parameters values */
-  GPIO_InitStruct-&gt;GPIO_Pin  = GPIO_Pin_All;
-  GPIO_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
-  GPIO_InitStruct-&gt;GPIO_Mode = GPIO_Mode_IN_FLOATING;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadInputDataBit
-* Description    : Reads the specified input port pin.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                : - GPIO_Pin:  specifies the port bit to read.
-*                    This parameter can be GPIO_Pin_x where x can be (0..15).
-* Output         : None
-* Return         : The input port pin value.
-*******************************************************************************/
-u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  u8 bitstatus = 0x00;
-  
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
-  
-  if ((GPIOx-&gt;IDR &amp; GPIO_Pin) != (u32)Bit_RESET)
-  {
-    bitstatus = (u8)Bit_SET;
-  }
-  else
-  {
-    bitstatus = (u8)Bit_RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadInputData
-* Description    : Reads the specified GPIO input data port.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-* Output         : None
-* Return         : GPIO input data port value.
-*******************************************************************************/
-u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  return ((u16)GPIOx-&gt;IDR);
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadOutputDataBit
-* Description    : Reads the specified output data port bit.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                : - GPIO_Pin:  specifies the port bit to read.
-*                    This parameter can be GPIO_Pin_x where x can be (0..15).
-* Output         : None
-* Return         : The output port pin value.
-*******************************************************************************/
-u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  u8 bitstatus = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
-  
-  if ((GPIOx-&gt;ODR &amp; GPIO_Pin) != (u32)Bit_RESET)
-  {
-    bitstatus = (u8)Bit_SET;
-  }
-  else
-  {
-    bitstatus = (u8)Bit_RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ReadOutputData
-* Description    : Reads the specified GPIO output data port.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-* Output         : None
-* Return         : GPIO output data port value.
-*******************************************************************************/
-u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-    
-  return ((u16)GPIOx-&gt;ODR);
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_SetBits
-* Description    : Sets the selected data port bits.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bits to be written.
-*                    This parameter can be any combination of GPIO_Pin_x where 
-*                    x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  GPIOx-&gt;BSRR = GPIO_Pin;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_ResetBits
-* Description    : Clears the selected data port bits.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bits to be written.
-*                    This parameter can be any combination of GPIO_Pin_x where 
-*                    x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  GPIOx-&gt;BRR = GPIO_Pin;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_WriteBit
-* Description    : Sets or clears the selected data port bit.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bit to be written.
-*                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
-*                  - BitVal: specifies the value to be written to the selected bit.
-*                    This parameter can be one of the BitAction enum values:
-*                       - Bit_RESET: to clear the port pin
-*                       - Bit_SET: to set the port pin
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
-  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
-  
-  if (BitVal != Bit_RESET)
-  {
-    GPIOx-&gt;BSRR = GPIO_Pin;
-  }
-  else
-  {
-    GPIOx-&gt;BRR = GPIO_Pin;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_Write
-* Description    : Writes data to the specified GPIO data port.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - PortVal: specifies the value to be written to the port output
-*                    data register.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  GPIOx-&gt;ODR = PortVal;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_PinLockConfig
-* Description    : Locks GPIO Pins configuration registers.
-* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
-*                  - GPIO_Pin: specifies the port bit to be written.
-*                    This parameter can be any combination of GPIO_Pin_x where 
-*                    x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
-{
-  u32 tmp = 0x00010000;
-  
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  tmp |= GPIO_Pin;
-  /* Set LCKK bit */
-  GPIOx-&gt;LCKR = tmp;
-  /* Reset LCKK bit */
-  GPIOx-&gt;LCKR =  GPIO_Pin;
-  /* Set LCKK bit */
-  GPIOx-&gt;LCKR = tmp;
-  /* Read LCKK bit*/
-  tmp = GPIOx-&gt;LCKR;
-  /* Read LCKK bit*/
-  tmp = GPIOx-&gt;LCKR;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_EventOutputConfig
-* Description    : Selects the GPIO pin used as Event output.
-* Input          : - GPIO_PortSource: selects the GPIO port to be used as source
-*                    for Event output.
-*                    This parameter can be GPIO_PortSourceGPIOx where x can be
-*                    (A..E).
-*                  - GPIO_PinSource: specifies the pin for the Event output.
-*                    This parameter can be GPIO_PinSourcex where x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
-{
-  u32 tmpreg = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
-  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
-    
-  tmpreg = AFIO-&gt;EVCR;
-  /* Clear the PORT[6:4] and PIN[3:0] bits */
-  tmpreg &amp;= EVCR_PORTPINCONFIG_MASK;
-  tmpreg |= (u32)GPIO_PortSource &lt;&lt; 0x04;
-  tmpreg |= GPIO_PinSource;
-
-  AFIO-&gt;EVCR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_EventOutputCmd
-* Description    : Enables or disables the Event Output.
-* Input          : - NewState: new state of the Event output.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_EventOutputCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_PinRemapConfig
-* Description    : Changes the mapping of the specified pin.
-* Input          : - GPIO_Remap: selects the pin to remap.
-*                    This parameter can be one of the following values:
-*                       - GPIO_Remap_SPI1
-*                       - GPIO_Remap_I2C1
-*                       - GPIO_Remap_USART1
-*                       - GPIO_Remap_USART2
-*                       - GPIO_PartialRemap_USART3
-*                       - GPIO_FullRemap_USART3
-*                       - GPIO_PartialRemap_TIM1
-*                       - GPIO_FullRemap_TIM1
-*                       - GPIO_PartialRemap1_TIM2
-*                       - GPIO_PartialRemap2_TIM2
-*                       - GPIO_FullRemap_TIM2
-*                       - GPIO_PartialRemap_TIM3
-*                       - GPIO_FullRemap_TIM3
-*                       - GPIO_Remap_TIM4
-*                       - GPIO_Remap1_CAN
-*                       - GPIO_Remap2_CAN
-*                       - GPIO_Remap_PD01
-*                       - GPIO_Remap_TIM5CH4_LSI
-*                       - GPIO_Remap_ADC1_ETRGINJ
-*                       - GPIO_Remap_ADC1_ETRGREG
-*                       - GPIO_Remap_ADC2_ETRGINJ
-*                       - GPIO_Remap_ADC2_ETRGREG
-*                       - GPIO_Remap_SWJ_NoJTRST
-*                       - GPIO_Remap_SWJ_JTAGDisable
-*                       - GPIO_Remap_SWJ_Disable
-*                  - NewState: new state of the port pin remapping.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
-{
-  u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_REMAP(GPIO_Remap));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));  
-  
-  tmpreg = AFIO-&gt;MAPR;
-
-  tmpmask = (GPIO_Remap &amp; DBGAFR_POSITION_MASK) &gt;&gt; 0x10;
-  tmp = GPIO_Remap &amp; LSB_MASK;
-
-  if ((GPIO_Remap &amp; (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
-  {
-    tmpreg &amp;= DBGAFR_SWJCFG_MASK;
-    AFIO-&gt;MAPR &amp;= DBGAFR_SWJCFG_MASK;
-  }
-  else if ((GPIO_Remap &amp; DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
-  {
-    tmp1 = ((u32)0x03) &lt;&lt; tmpmask;
-    tmpreg &amp;= ~tmp1;
-    tmpreg |= ~DBGAFR_SWJCFG_MASK;
-  }
-  else
-  {
-    tmpreg &amp;= ~(tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
-    tmpreg |= ~DBGAFR_SWJCFG_MASK;
-  }
-
-  if (NewState != DISABLE)
-  {
-    tmpreg |= (tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
-  }
-
-  AFIO-&gt;MAPR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : GPIO_EXTILineConfig
-* Description    : Selects the GPIO pin used as EXTI Line.
-* Input          : - GPIO_PortSource: selects the GPIO port to be used as
-*                    source for EXTI lines.
-*                    This parameter can be GPIO_PortSourceGPIOx where x can be
-*                    (A..G).
-*                  - GPIO_PinSource: specifies the EXTI line to be configured.
-*                   This parameter can be GPIO_PinSourcex where x can be (0..15).
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
-{
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
-  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
-  
-  tmp = ((u32)0x0F) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (u8)0x03));
-
-  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] &amp;= ~tmp;
-  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] |= (((u32)GPIO_PortSource) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (u8)0x03)));
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_gpio.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the GPIO firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_gpio.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ------------ RCC registers bit address in the alias region ----------- */
+#define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
+
+/* --- EVENTCR Register ---*/
+/* Alias word address of EVOE bit */
+#define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
+#define EVOE_BitNumber              ((u8)0x07)
+#define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
+
+#define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
+#define LSB_MASK                    ((u16)0xFFFF)
+#define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
+#define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
+#define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
+#define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : GPIO_DeInit
+* Description    : Deinitializes the GPIOx peripheral registers to their default
+*                  reset values.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_DeInit(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  
+  switch (*(u32*)&amp;GPIOx)
+  {
+    case GPIOA_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
+      break;
+
+    case GPIOB_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
+      break;
+
+    case GPIOC_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
+      break;
+
+    case GPIOD_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
+      break;
+      
+    case GPIOE_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
+      break; 
+
+    case GPIOF_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
+      break;
+
+    case GPIOG_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
+      break;                       
+
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_AFIODeInit
+* Description    : Deinitializes the Alternate Functions (remap, event control
+*                  and EXTI configuration) registers to their default reset
+*                  values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_AFIODeInit(void)
+{
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
+  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_Init
+* Description    : Initializes the GPIOx peripheral according to the specified
+*                  parameters in the GPIO_InitStruct.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
+*                    contains the configuration information for the specified GPIO
+*                    peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
+  u32 tmpreg = 0x00, pinmask = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));
+  assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin));  
+  
+/*---------------------------- GPIO Mode Configuration -----------------------*/
+  currentmode = ((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)0x0F);
+
+  if ((((u32)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((u32)0x10)) != 0x00)
+  { 
+    /* Check the parameters */
+    assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));
+    /* Output mode */
+    currentmode |= (u32)GPIO_InitStruct-&gt;GPIO_Speed;
+  }
+
+/*---------------------------- GPIO CRL Configuration ------------------------*/
+  /* Configure the eight low port pins */
+  if (((u32)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((u32)0x00FF)) != 0x00)
+  {
+    tmpreg = GPIOx-&gt;CRL;
+
+    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
+    {
+      pos = ((u32)0x01) &lt;&lt; pinpos;
+      /* Get the port pins position */
+      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;
+
+      if (currentpin == pos)
+      {
+        pos = pinpos &lt;&lt; 2;
+        /* Clear the corresponding low control register bits */
+        pinmask = ((u32)0x0F) &lt;&lt; pos;
+        tmpreg &amp;= ~pinmask;
+
+        /* Write the mode configuration in the corresponding bits */
+        tmpreg |= (currentmode &lt;&lt; pos);
+
+        /* Reset the corresponding ODR bit */
+        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
+        {
+          GPIOx-&gt;BRR = (((u32)0x01) &lt;&lt; pinpos);
+        }
+        else
+        {
+          /* Set the corresponding ODR bit */
+          if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
+          {
+            GPIOx-&gt;BSRR = (((u32)0x01) &lt;&lt; pinpos);
+          }
+        }
+      }
+    }
+    GPIOx-&gt;CRL = tmpreg;
+  }
+
+/*---------------------------- GPIO CRH Configuration ------------------------*/
+  /* Configure the eight high port pins */
+  if (GPIO_InitStruct-&gt;GPIO_Pin &gt; 0x00FF)
+  {
+    tmpreg = GPIOx-&gt;CRH;
+    for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++)
+    {
+      pos = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
+      /* Get the port pins position */
+      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);
+      if (currentpin == pos)
+      {
+        pos = pinpos &lt;&lt; 2;
+        /* Clear the corresponding high control register bits */
+        pinmask = ((u32)0x0F) &lt;&lt; pos;
+        tmpreg &amp;= ~pinmask;
+
+        /* Write the mode configuration in the corresponding bits */
+        tmpreg |= (currentmode &lt;&lt; pos);
+
+        /* Reset the corresponding ODR bit */
+        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)
+        {
+          GPIOx-&gt;BRR = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
+        }
+        /* Set the corresponding ODR bit */
+        if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)
+        {
+          GPIOx-&gt;BSRR = (((u32)0x01) &lt;&lt; (pinpos + 0x08));
+        }
+      }
+    }
+    GPIOx-&gt;CRH = tmpreg;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_StructInit
+* Description    : Fills each GPIO_InitStruct member with its default value.
+* Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
+{
+  /* Reset GPIO init structure parameters values */
+  GPIO_InitStruct-&gt;GPIO_Pin  = GPIO_Pin_All;
+  GPIO_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
+  GPIO_InitStruct-&gt;GPIO_Mode = GPIO_Mode_IN_FLOATING;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_ReadInputDataBit
+* Description    : Reads the specified input port pin.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                : - GPIO_Pin:  specifies the port bit to read.
+*                    This parameter can be GPIO_Pin_x where x can be (0..15).
+* Output         : None
+* Return         : The input port pin value.
+*******************************************************************************/
+u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
+{
+  u8 bitstatus = 0x00;
+  
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
+  
+  if ((GPIOx-&gt;IDR &amp; GPIO_Pin) != (u32)Bit_RESET)
+  {
+    bitstatus = (u8)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (u8)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_ReadInputData
+* Description    : Reads the specified GPIO input data port.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+* Output         : None
+* Return         : GPIO input data port value.
+*******************************************************************************/
+u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  
+  return ((u16)GPIOx-&gt;IDR);
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_ReadOutputDataBit
+* Description    : Reads the specified output data port bit.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                : - GPIO_Pin:  specifies the port bit to read.
+*                    This parameter can be GPIO_Pin_x where x can be (0..15).
+* Output         : None
+* Return         : The output port pin value.
+*******************************************************************************/
+u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
+{
+  u8 bitstatus = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
+  
+  if ((GPIOx-&gt;ODR &amp; GPIO_Pin) != (u32)Bit_RESET)
+  {
+    bitstatus = (u8)Bit_SET;
+  }
+  else
+  {
+    bitstatus = (u8)Bit_RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_ReadOutputData
+* Description    : Reads the specified GPIO output data port.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+* Output         : None
+* Return         : GPIO output data port value.
+*******************************************************************************/
+u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+    
+  return ((u16)GPIOx-&gt;ODR);
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_SetBits
+* Description    : Sets the selected data port bits.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                  - GPIO_Pin: specifies the port bits to be written.
+*                    This parameter can be any combination of GPIO_Pin_x where 
+*                    x can be (0..15).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+  
+  GPIOx-&gt;BSRR = GPIO_Pin;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_ResetBits
+* Description    : Clears the selected data port bits.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                  - GPIO_Pin: specifies the port bits to be written.
+*                    This parameter can be any combination of GPIO_Pin_x where 
+*                    x can be (0..15).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+  
+  GPIOx-&gt;BRR = GPIO_Pin;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_WriteBit
+* Description    : Sets or clears the selected data port bit.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                  - GPIO_Pin: specifies the port bit to be written.
+*                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
+*                  - BitVal: specifies the value to be written to the selected bit.
+*                    This parameter can be one of the BitAction enum values:
+*                       - Bit_RESET: to clear the port pin
+*                       - Bit_SET: to set the port pin
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
+  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
+  
+  if (BitVal != Bit_RESET)
+  {
+    GPIOx-&gt;BSRR = GPIO_Pin;
+  }
+  else
+  {
+    GPIOx-&gt;BRR = GPIO_Pin;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_Write
+* Description    : Writes data to the specified GPIO data port.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                  - PortVal: specifies the value to be written to the port output
+*                    data register.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
+{
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  
+  GPIOx-&gt;ODR = PortVal;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_PinLockConfig
+* Description    : Locks GPIO Pins configuration registers.
+* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
+*                  - GPIO_Pin: specifies the port bit to be written.
+*                    This parameter can be any combination of GPIO_Pin_x where 
+*                    x can be (0..15).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
+{
+  u32 tmp = 0x00010000;
+  
+  /* Check the parameters */
+  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
+  assert_param(IS_GPIO_PIN(GPIO_Pin));
+  
+  tmp |= GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx-&gt;LCKR = tmp;
+  /* Reset LCKK bit */
+  GPIOx-&gt;LCKR =  GPIO_Pin;
+  /* Set LCKK bit */
+  GPIOx-&gt;LCKR = tmp;
+  /* Read LCKK bit*/
+  tmp = GPIOx-&gt;LCKR;
+  /* Read LCKK bit*/
+  tmp = GPIOx-&gt;LCKR;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_EventOutputConfig
+* Description    : Selects the GPIO pin used as Event output.
+* Input          : - GPIO_PortSource: selects the GPIO port to be used as source
+*                    for Event output.
+*                    This parameter can be GPIO_PortSourceGPIOx where x can be
+*                    (A..E).
+*                  - GPIO_PinSource: specifies the pin for the Event output.
+*                    This parameter can be GPIO_PinSourcex where x can be (0..15).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
+{
+  u32 tmpreg = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
+  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
+    
+  tmpreg = AFIO-&gt;EVCR;
+  /* Clear the PORT[6:4] and PIN[3:0] bits */
+  tmpreg &amp;= EVCR_PORTPINCONFIG_MASK;
+  tmpreg |= (u32)GPIO_PortSource &lt;&lt; 0x04;
+  tmpreg |= GPIO_PinSource;
+
+  AFIO-&gt;EVCR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_EventOutputCmd
+* Description    : Enables or disables the Event Output.
+* Input          : - NewState: new state of the Event output.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_EventOutputCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_PinRemapConfig
+* Description    : Changes the mapping of the specified pin.
+* Input          : - GPIO_Remap: selects the pin to remap.
+*                    This parameter can be one of the following values:
+*                       - GPIO_Remap_SPI1
+*                       - GPIO_Remap_I2C1
+*                       - GPIO_Remap_USART1
+*                       - GPIO_Remap_USART2
+*                       - GPIO_PartialRemap_USART3
+*                       - GPIO_FullRemap_USART3
+*                       - GPIO_PartialRemap_TIM1
+*                       - GPIO_FullRemap_TIM1
+*                       - GPIO_PartialRemap1_TIM2
+*                       - GPIO_PartialRemap2_TIM2
+*                       - GPIO_FullRemap_TIM2
+*                       - GPIO_PartialRemap_TIM3
+*                       - GPIO_FullRemap_TIM3
+*                       - GPIO_Remap_TIM4
+*                       - GPIO_Remap1_CAN
+*                       - GPIO_Remap2_CAN
+*                       - GPIO_Remap_PD01
+*                       - GPIO_Remap_TIM5CH4_LSI
+*                       - GPIO_Remap_ADC1_ETRGINJ
+*                       - GPIO_Remap_ADC1_ETRGREG
+*                       - GPIO_Remap_ADC2_ETRGINJ
+*                       - GPIO_Remap_ADC2_ETRGREG
+*                       - GPIO_Remap_SWJ_NoJTRST
+*                       - GPIO_Remap_SWJ_JTAGDisable
+*                       - GPIO_Remap_SWJ_Disable
+*                  - NewState: new state of the port pin remapping.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
+{
+  u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_REMAP(GPIO_Remap));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));  
+  
+  tmpreg = AFIO-&gt;MAPR;
+
+  tmpmask = (GPIO_Remap &amp; DBGAFR_POSITION_MASK) &gt;&gt; 0x10;
+  tmp = GPIO_Remap &amp; LSB_MASK;
+
+  if ((GPIO_Remap &amp; (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
+  {
+    tmpreg &amp;= DBGAFR_SWJCFG_MASK;
+    AFIO-&gt;MAPR &amp;= DBGAFR_SWJCFG_MASK;
+  }
+  else if ((GPIO_Remap &amp; DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
+  {
+    tmp1 = ((u32)0x03) &lt;&lt; tmpmask;
+    tmpreg &amp;= ~tmp1;
+    tmpreg |= ~DBGAFR_SWJCFG_MASK;
+  }
+  else
+  {
+    tmpreg &amp;= ~(tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
+    tmpreg |= ~DBGAFR_SWJCFG_MASK;
+  }
+
+  if (NewState != DISABLE)
+  {
+    tmpreg |= (tmp &lt;&lt; ((GPIO_Remap &gt;&gt; 0x15)*0x10));
+  }
+
+  AFIO-&gt;MAPR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : GPIO_EXTILineConfig
+* Description    : Selects the GPIO pin used as EXTI Line.
+* Input          : - GPIO_PortSource: selects the GPIO port to be used as
+*                    source for EXTI lines.
+*                    This parameter can be GPIO_PortSourceGPIOx where x can be
+*                    (A..G).
+*                  - GPIO_PinSource: specifies the EXTI line to be configured.
+*                   This parameter can be GPIO_PinSourcex where x can be (0..15).
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
+{
+  u32 tmp = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
+  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
+  
+  tmp = ((u32)0x0F) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (u8)0x03));
+
+  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] &amp;= ~tmp;
+  AFIO-&gt;EXTICR[GPIO_PinSource &gt;&gt; 0x02] |= (((u32)GPIO_PortSource) &lt;&lt; (0x04 * (GPIO_PinSource &amp; (u8)0x03)));
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_i2c.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,1216 +1,1216 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_i2c.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the I2C firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_i2c.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-	 
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* I2C SPE mask */
-#define CR1_PE_Set              ((u16)0x0001)
-#define CR1_PE_Reset            ((u16)0xFFFE)
-
-/* I2C START mask */
-#define CR1_START_Set           ((u16)0x0100)
-#define CR1_START_Reset         ((u16)0xFEFF)
-
-/* I2C STOP mask */
-#define CR1_STOP_Set            ((u16)0x0200)
-#define CR1_STOP_Reset          ((u16)0xFDFF)
-
-/* I2C ACK mask */
-#define CR1_ACK_Set             ((u16)0x0400)
-#define CR1_ACK_Reset           ((u16)0xFBFF)
-
-/* I2C ENGC mask */
-#define CR1_ENGC_Set            ((u16)0x0040)
-#define CR1_ENGC_Reset          ((u16)0xFFBF)
-
-/* I2C SWRST mask */
-#define CR1_SWRST_Set           ((u16)0x8000)
-#define CR1_SWRST_Reset         ((u16)0x7FFF)
-
-/* I2C PEC mask */
-#define CR1_PEC_Set             ((u16)0x1000)
-#define CR1_PEC_Reset           ((u16)0xEFFF)
-
-/* I2C ENPEC mask */
-#define CR1_ENPEC_Set           ((u16)0x0020)
-#define CR1_ENPEC_Reset         ((u16)0xFFDF)
-
-/* I2C ENARP mask */
-#define CR1_ENARP_Set           ((u16)0x0010)
-#define CR1_ENARP_Reset         ((u16)0xFFEF)
-
-/* I2C NOSTRETCH mask */
-#define CR1_NOSTRETCH_Set       ((u16)0x0080)
-#define CR1_NOSTRETCH_Reset     ((u16)0xFF7F)
-
-/* I2C registers Masks */
-#define CR1_CLEAR_Mask          ((u16)0xFBF5)
-
-/* I2C DMAEN mask */
-#define CR2_DMAEN_Set           ((u16)0x0800)
-#define CR2_DMAEN_Reset         ((u16)0xF7FF)
-
-/* I2C LAST mask */
-#define CR2_LAST_Set            ((u16)0x1000)
-#define CR2_LAST_Reset          ((u16)0xEFFF)
-
-/* I2C FREQ mask */
-#define CR2_FREQ_Reset          ((u16)0xFFC0)
-
-/* I2C ADD0 mask */
-#define OAR1_ADD0_Set           ((u16)0x0001)
-#define OAR1_ADD0_Reset         ((u16)0xFFFE)
-
-/* I2C ENDUAL mask */
-#define OAR2_ENDUAL_Set         ((u16)0x0001)
-#define OAR2_ENDUAL_Reset       ((u16)0xFFFE)
-
-/* I2C ADD2 mask */
-#define OAR2_ADD2_Reset         ((u16)0xFF01)
-
-/* I2C F/S mask */
-#define CCR_FS_Set              ((u16)0x8000)
-
-/* I2C CCR mask */
-#define CCR_CCR_Set             ((u16)0x0FFF)
-
-/* I2C FLAG mask */
-#define FLAG_Mask               ((u32)0x00FFFFFF)
-
-/* I2C Interrupt Enable mask */
-#define ITEN_Mask               ((u32)0x07000000)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : I2C_DeInit
-* Description    : Deinitializes the I2Cx peripheral registers to their default
-*                  reset values.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DeInit(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  switch (*(u32*)&amp;I2Cx)
-  {
-    case I2C1_BASE:
-      /* Enable I2C1 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
-      /* Release I2C1 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
-      break;
-
-    case I2C2_BASE:
-      /* Enable I2C2 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
-      /* Release I2C2 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
-      break;
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_Init
-* Description    : Initializes the I2Cx peripheral according to the specified 
-*                  parameters in the I2C_InitStruct.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    I2C peripheral.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
-{
-  u16 tmpreg = 0, freqrange = 0;
-  u16 result = 0x04;
-  u32 pclk1 = 8000000;
-  RCC_ClocksTypeDef  rcc_clocks;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_MODE(I2C_InitStruct-&gt;I2C_Mode));
-  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct-&gt;I2C_DutyCycle));
-  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct-&gt;I2C_OwnAddress1));
-  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct-&gt;I2C_Ack));
-  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct-&gt;I2C_AcknowledgedAddress));
-  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct-&gt;I2C_ClockSpeed));
-
-/*---------------------------- I2Cx CR2 Configuration ------------------------*/
-  /* Get the I2Cx CR2 value */
-  tmpreg = I2Cx-&gt;CR2;
-  /* Clear frequency FREQ[5:0] bits */
-  tmpreg &amp;= CR2_FREQ_Reset;
-  /* Get pclk1 frequency value */
-  RCC_GetClocksFreq(&amp;rcc_clocks);
-  pclk1 = rcc_clocks.PCLK1_Frequency;
-  /* Set frequency bits depending on pclk1 value */
-  freqrange = (u16)(pclk1 / 1000000);
-  tmpreg |= freqrange;
-  /* Write to I2Cx CR2 */
-  I2Cx-&gt;CR2 = tmpreg;
-
-/*---------------------------- I2Cx CCR Configuration ------------------------*/
-  /* Disable the selected I2C peripheral to configure TRISE */
-  I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
-
-  /* Reset tmpreg value */
-  /* Clear F/S, DUTY and CCR[11:0] bits */
-  tmpreg = 0;
-
-  /* Configure speed in standard mode */
-  if (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 100000)
-  {
-    /* Standard mode speed calculate */
-    result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;&lt; 1));
-    /* Test if CCR value is under 0x4*/
-    if (result &lt; 0x04)
-    {
-      /* Set minimum allowed value */
-      result = 0x04;  
-    }
-    /* Set speed value for standard mode */
-    tmpreg |= result;	  
-    /* Set Maximum Rise Time for standard mode */
-    I2Cx-&gt;TRISE = freqrange + 1; 
-  }
-  /* Configure speed in fast mode */
-  else /*(I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 400000)*/
-  {
-    if (I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_2)
-    {
-      /* Fast mode speed calculate: Tlow/Thigh = 2 */
-      result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 3));
-    }
-    else /*I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_16_9*/
-    {
-      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
-      result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 25));
-      /* Set DUTY bit */
-      result |= I2C_DutyCycle_16_9;
-    }
-    /* Test if CCR value is under 0x1*/
-    if ((result &amp; CCR_CCR_Set) == 0)
-    {
-      /* Set minimum allowed value */
-      result |= (u16)0x0001;  
-    }
-    /* Set speed value and set F/S bit for fast mode */
-    tmpreg |= result | CCR_FS_Set;
-    /* Set Maximum Rise Time for fast mode */
-    I2Cx-&gt;TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
-  }
-  /* Write to I2Cx CCR */
-  I2Cx-&gt;CCR = tmpreg;
-
-  /* Enable the selected I2C peripheral */
-  I2Cx-&gt;CR1 |= CR1_PE_Set;
-
-/*---------------------------- I2Cx CR1 Configuration ------------------------*/
-  /* Get the I2Cx CR1 value */
-  tmpreg = I2Cx-&gt;CR1;
-  /* Clear ACK, SMBTYPE and  SMBUS bits */
-  tmpreg &amp;= CR1_CLEAR_Mask;
-  /* Configure I2Cx: mode and acknowledgement */
-  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
-  /* Set ACK bit according to I2C_Ack value */
-  tmpreg |= (u16)((u32)I2C_InitStruct-&gt;I2C_Mode | I2C_InitStruct-&gt;I2C_Ack);
-  /* Write to I2Cx CR1 */
-  I2Cx-&gt;CR1 = tmpreg;
-
-/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
-  /* Set I2Cx Own Address1 and acknowledged address */
-  I2Cx-&gt;OAR1 = (I2C_InitStruct-&gt;I2C_AcknowledgedAddress | I2C_InitStruct-&gt;I2C_OwnAddress1);
-}
-
-/*******************************************************************************
-* Function Name  : I2C_StructInit
-* Description    : Fills each I2C_InitStruct member with its default value.
-* Input          : - I2C_InitStruct: pointer to an I2C_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
-{
-/*---------------- Reset I2C init structure parameters values ----------------*/
-  /* Initialize the I2C_Mode member */
-  I2C_InitStruct-&gt;I2C_Mode = I2C_Mode_I2C;
-
-  /* Initialize the I2C_DutyCycle member */
-  I2C_InitStruct-&gt;I2C_DutyCycle = I2C_DutyCycle_2;
-
-  /* Initialize the I2C_OwnAddress1 member */
-  I2C_InitStruct-&gt;I2C_OwnAddress1 = 0;
-
-  /* Initialize the I2C_Ack member */
-  I2C_InitStruct-&gt;I2C_Ack = I2C_Ack_Disable;
-
-  /* Initialize the I2C_AcknowledgedAddress member */
-  I2C_InitStruct-&gt;I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
-
-  /* initialize the I2C_ClockSpeed member */
-  I2C_InitStruct-&gt;I2C_ClockSpeed = 5000;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_Cmd
-* Description    : Enables or disables the specified I2C peripheral.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx peripheral. This parameter
-*                    can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C peripheral */
-    I2Cx-&gt;CR1 |= CR1_PE_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C peripheral */
-    I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_DMACmd
-* Description    : Enables or disables the specified I2C DMA requests.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C DMA transfer.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C DMA requests */
-    I2Cx-&gt;CR2 |= CR2_DMAEN_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C DMA requests */
-    I2Cx-&gt;CR2 &amp;= CR2_DMAEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_DMALastTransferCmd
-* Description    : Specifies that the next DMA transfer is the last one.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C DMA last transfer.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Next DMA transfer is the last transfer */
-    I2Cx-&gt;CR2 |= CR2_LAST_Set;
-  }
-  else
-  {
-    /* Next DMA transfer is not the last transfer */
-    I2Cx-&gt;CR2 &amp;= CR2_LAST_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GenerateSTART
-* Description    : Generates I2Cx communication START condition.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C START condition generation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Generate a START condition */
-    I2Cx-&gt;CR1 |= CR1_START_Set;
-  }
-  else
-  {
-    /* Disable the START condition generation */
-    I2Cx-&gt;CR1 &amp;= CR1_START_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GenerateSTOP
-* Description    : Generates I2Cx communication STOP condition.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C STOP condition generation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Generate a STOP condition */
-    I2Cx-&gt;CR1 |= CR1_STOP_Set;
-  }
-  else
-  {
-    /* Disable the STOP condition generation */
-    I2Cx-&gt;CR1 &amp;= CR1_STOP_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_AcknowledgeConfig
-* Description    : Enables or disables the specified I2C acknowledge feature.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C Acknowledgement.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the acknowledgement */
-    I2Cx-&gt;CR1 |= CR1_ACK_Set;
-  }
-  else
-  {
-    /* Disable the acknowledgement */
-    I2Cx-&gt;CR1 &amp;= CR1_ACK_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_OwnAddress2Config
-* Description    : Configures the specified I2C own address2.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - Address: specifies the 7bit I2C own address2.
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
-{
-  u16 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Get the old register value */
-  tmpreg = I2Cx-&gt;OAR2;
-  /* Reset I2Cx Own address2 bit [7:1] */
-  tmpreg &amp;= OAR2_ADD2_Reset;
-  /* Set I2Cx Own address2 */
-  tmpreg |= (u16)(Address &amp; (u16)0x00FE);
-  /* Store the new register value */
-  I2Cx-&gt;OAR2 = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_DualAddressCmd
-* Description    : Enables or disables the specified I2C dual addressing mode.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C dual addressing mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable dual addressing mode */
-    I2Cx-&gt;OAR2 |= OAR2_ENDUAL_Set;
-  }
-  else
-  {
-    /* Disable dual addressing mode */
-    I2Cx-&gt;OAR2 &amp;= OAR2_ENDUAL_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GeneralCallCmd
-* Description    : Enables or disables the specified I2C general call feature.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C General call.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable generall call */
-    I2Cx-&gt;CR1 |= CR1_ENGC_Set;
-  }
-  else
-  {
-    /* Disable generall call */
-    I2Cx-&gt;CR1 &amp;= CR1_ENGC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ITConfig
-* Description    : Enables or disables the specified I2C interrupts.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_IT: specifies the I2C interrupts sources to be enabled
-*                    or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - I2C_IT_BUF: Buffer interrupt mask
-*                       - I2C_IT_EVT: Event interrupt mask
-*                       - I2C_IT_ERR: Error interrupt mask
-*                  - NewState: new state of the specified I2C interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C interrupts */
-    I2Cx-&gt;CR2 |= I2C_IT;
-  }
-  else
-  {
-    /* Disable the selected I2C interrupts */
-    I2Cx-&gt;CR2 &amp;= (u16)~I2C_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_SendData
-* Description    : Sends a data byte through the I2Cx peripheral.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - Data: Byte to be transmitted..
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Write in the DR register the data to be sent */
-  I2Cx-&gt;DR = Data;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ReceiveData
-* Description    : Returns the most recent received data by the I2Cx peripheral.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : The value of the received data.
-*******************************************************************************/
-u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Return the data in the DR register */
-  return (u8)I2Cx-&gt;DR;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_Send7bitAddress
-* Description    : Transmits the address byte to select the slave device.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - Address: specifies the slave address which will be transmitted
-*                  - I2C_Direction: specifies whether the I2C device will be a
-*                    Transmitter or a Receiver. 
-*                    This parameter can be one of the following values
-*                       - I2C_Direction_Transmitter: Transmitter mode
-*                       - I2C_Direction_Receiver: Receiver mode
-* Output         : None
-* Return         : None.
-*******************************************************************************/
-void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_DIRECTION(I2C_Direction));
-
-  /* Test on the direction to set/reset the read/write bit */
-  if (I2C_Direction != I2C_Direction_Transmitter)
-  {
-    /* Set the address bit0 for read */
-    Address |= OAR1_ADD0_Set;
-  }
-  else
-  {
-    /* Reset the address bit0 for write */
-    Address &amp;= OAR1_ADD0_Reset;
-  }
-  /* Send the address */
-  I2Cx-&gt;DR = Address;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ReadRegister
-* Description    : Reads the specified I2C register and returns its value.
-* Input1         : - I2C_Register: specifies the register to read.
-*                    This parameter can be one of the following values:
-*                       - I2C_Register_CR1:  CR1 register.
-*                       - I2C_Register_CR2:   CR2 register.
-*                       - I2C_Register_OAR1:  OAR1 register.
-*                       - I2C_Register_OAR2:  OAR2 register.
-*                       - I2C_Register_DR:    DR register.
-*                       - I2C_Register_SR1:   SR1 register.
-*                       - I2C_Register_SR2:   SR2 register.
-*                       - I2C_Register_CCR:   CCR register.
-*                       - I2C_Register_TRISE: TRISE register.
-* Output         : None
-* Return         : The value of the read register.
-*******************************************************************************/
-u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_REGISTER(I2C_Register));
-
-  /* Return the selected register value */
-  return (*(vu16 *)(*((vu32 *)&amp;I2Cx) + I2C_Register));
-}
-
-/*******************************************************************************
-* Function Name  : I2C_SoftwareResetCmd
-* Description    : Enables or disables the specified I2C software reset.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C software reset.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Peripheral under reset */
-    I2Cx-&gt;CR1 |= CR1_SWRST_Set;
-  }
-  else
-  {
-    /* Peripheral not under reset */
-    I2Cx-&gt;CR1 &amp;= CR1_SWRST_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_SMBusAlertConfig
-* Description    : Drives the SMBusAlert pin high or low for the specified I2C.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_SMBusAlert: specifies SMBAlert pin level. 
-*                    This parameter can be one of the following values:
-*                       - I2C_SMBusAlert_Low: SMBAlert pin driven low
-*                       - I2C_SMBusAlert_High: SMBAlert pin driven high
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
-
-  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
-  {
-    /* Drive the SMBusAlert pin Low */
-    I2Cx-&gt;CR1 |= I2C_SMBusAlert_Low;
-  }
-  else
-  {
-    /* Drive the SMBusAlert pin High  */
-    I2Cx-&gt;CR1 &amp;= I2C_SMBusAlert_High;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_TransmitPEC
-* Description    : Enables or disables the specified I2C PEC transfer.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2C PEC transmission.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C PEC transmission */
-    I2Cx-&gt;CR1 |= CR1_PEC_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C PEC transmission */
-    I2Cx-&gt;CR1 &amp;= CR1_PEC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_PECPositionConfig
-* Description    : Selects the specified I2C PEC position.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_PECPosition: specifies the PEC position. 
-*                    This parameter can be one of the following values:
-*                       - I2C_PECPosition_Next: indicates that the next
-*                         byte is PEC
-*                       - I2C_PECPosition_Current: indicates that current
-*                         byte is PEC
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
-
-  if (I2C_PECPosition == I2C_PECPosition_Next)
-  {
-    /* Next byte in shift register is PEC */
-    I2Cx-&gt;CR1 |= I2C_PECPosition_Next;
-  }
-  else
-  {
-    /* Current byte in shift register is PEC */
-    I2Cx-&gt;CR1 &amp;= I2C_PECPosition_Current;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_CalculatePEC
-* Description    : Enables or disables the PEC value calculation of the
-*                  transfered bytes.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx PEC value calculation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C PEC calculation */
-    I2Cx-&gt;CR1 |= CR1_ENPEC_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C PEC calculation */
-    I2Cx-&gt;CR1 &amp;= CR1_ENPEC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetPEC
-* Description    : Returns the PEC value for the specified I2C.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : The PEC value.
-*******************************************************************************/
-u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Return the selected I2C PEC value */
-  return ((I2Cx-&gt;SR2) &gt;&gt; 8);
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ARPCmd
-* Description    : Enables or disables the specified I2C ARP.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx ARP. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C ARP */
-    I2Cx-&gt;CR1 |= CR1_ENARP_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C ARP */
-    I2Cx-&gt;CR1 &amp;= CR1_ENARP_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_StretchClockCmd
-* Description    : Enables or disables the specified I2C Clock stretching.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - NewState: new state of the I2Cx Clock stretching.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState == DISABLE)
-  {
-    /* Enable the selected I2C Clock stretching */
-    I2Cx-&gt;CR1 |= CR1_NOSTRETCH_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C Clock stretching */
-    I2Cx-&gt;CR1 &amp;= CR1_NOSTRETCH_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_FastModeDutyCycleConfig
-* Description    : Selects the specified I2C fast mode duty cycle.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_DutyCycle: specifies the fast mode duty cycle.
-*                    This parameter can be one of the following values:
-*                       - I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
-*                       - I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
-
-  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
-  {
-    /* I2C fast mode Tlow/Thigh=2 */
-    I2Cx-&gt;CCR &amp;= I2C_DutyCycle_2;
-  }
-  else
-  {
-    /* I2C fast mode Tlow/Thigh=16/9 */
-    I2Cx-&gt;CCR |= I2C_DutyCycle_16_9;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetLastEvent
-* Description    : Returns the last I2Cx Event.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-* Output         : None
-* Return         : The last event
-*******************************************************************************/
-u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
-{
-  u32 lastevent = 0;
-  u32 flag1 = 0, flag2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Read the I2Cx status register */
-  flag1 = I2Cx-&gt;SR1;
-  flag2 = I2Cx-&gt;SR2;
-  flag2 = flag2 &lt;&lt; 16;
-
-  /* Get the last event value from I2C status register */
-  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
-
-  /* Return status */
-  return lastevent;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_CheckEvent
-* Description    : Checks whether the last I2Cx Event is equal to the one passed
-*                  as parameter.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_EVENT: specifies the event to be checked. 
-*                    This parameter can be one of the following values:
-*                       - I2C_EVENT_SLAVE_ADDRESS_MATCHED   : EV1
-*                       - I2C_EVENT_SLAVE_BYTE_RECEIVED     : EV2
-*                       - I2C_EVENT_SLAVE_BYTE_TRANSMITTED  : EV3
-*                       - I2C_EVENT_SLAVE_ACK_FAILURE       : EV3-2
-*                       - I2C_EVENT_MASTER_MODE_SELECT      : EV5
-*                       - I2C_EVENT_MASTER_MODE_SELECTED    : EV6
-*                       - I2C_EVENT_MASTER_BYTE_RECEIVED    : EV7
-*                       - I2C_EVENT_MASTER_BYTE_TRANSMITTED : EV8
-*                       - I2C_EVENT_MASTER_MODE_ADDRESS10   : EV9
-*                       - I2C_EVENT_SLAVE_STOP_DETECTED     : EV4
-* Output         : None
-* Return         : An ErrorStatus enumuration value:
-*                       - SUCCESS: Last event is equal to the I2C_EVENT
-*                       - ERROR: Last event is different from the I2C_EVENT
-*******************************************************************************/
-ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
-{
-  u32 lastevent = 0;
-  u32 flag1 = 0, flag2 = 0;
-  ErrorStatus status = ERROR;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_EVENT(I2C_EVENT));
-
-  /* Read the I2Cx status register */
-  flag1 = I2Cx-&gt;SR1;
-  flag2 = I2Cx-&gt;SR2;
-  flag2 = flag2 &lt;&lt; 16;
-
-  /* Get the last event value from I2C status register */
-  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
-
-  /* Check whether the last event is equal to I2C_EVENT */
-  if (lastevent == I2C_EVENT )
-  {
-    /* SUCCESS: last event is equal to I2C_EVENT */
-    status = SUCCESS;
-  }
-  else
-  {
-    /* ERROR: last event is different from I2C_EVENT */
-    status = ERROR;
-  }
-
-  /* Return status */
-  return status;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetFlagStatus
-* Description    : Checks whether the specified I2C flag is set or not.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_FLAG: specifies the flag to check. 
-*                    This parameter can be one of the following values:
-*                       - I2C_FLAG_DUALF: Dual flag (Slave mode)
-*                       - I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
-*                       - I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
-*                       - I2C_FLAG_GENCALL: General call header flag (Slave mode)
-*                       - I2C_FLAG_TRA: Transmitter/Receiver flag
-*                       - I2C_FLAG_BUSY: Bus busy flag
-*                       - I2C_FLAG_MSL: Master/Slave flag
-*                       - I2C_FLAG_SMBALERT: SMBus Alert flag
-*                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
-*                       - I2C_FLAG_PECERR: PEC error in reception flag
-*                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
-*                       - I2C_FLAG_AF: Acknowledge failure flag
-*                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
-*                       - I2C_FLAG_BERR: Bus error flag
-*                       - I2C_FLAG_TXE: Data register empty flag (Transmitter)
-*                       - I2C_FLAG_RXNE: Data register not empty (Receiver) flag
-*                       - I2C_FLAG_STOPF: Stop detection flag (Slave mode)
-*                       - I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
-*                       - I2C_FLAG_BTF: Byte transfer finished flag
-*                       - I2C_FLAG_ADDR: Address sent flag (Master mode) &#147;ADSL&#148;
-*                                        Address matched flag (Slave mode)&#148;ENDAD&#148;
-*                       - I2C_FLAG_SB: Start bit flag (Master mode)
-* Output         : None
-* Return         : The new state of I2C_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  u32 i2creg = 0, i2cxbase = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
-
-  /* Get the I2Cx peripheral base address */
-  i2cxbase = (*(u32*)&amp;(I2Cx));
-  
-  /* Read flag register index */
-  i2creg = I2C_FLAG &gt;&gt; 28;
-  
-  /* Get bit[23:0] of the flag */
-  I2C_FLAG &amp;= FLAG_Mask;
-  
-  if(i2creg != 0)
-  {
-    /* Get the I2Cx SR1 register address */
-    i2cxbase += 0x14;
-  }
-  else
-  {
-    /* Flag in I2Cx SR2 Register */
-    I2C_FLAG = (u32)(I2C_FLAG &gt;&gt; 16);
-    /* Get the I2Cx SR2 register address */
-    i2cxbase += 0x18;
-  }
-  
-  if(((*(vu32 *)i2cxbase) &amp; I2C_FLAG) != (u32)RESET)
-  {
-    /* I2C_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* I2C_FLAG is reset */
-    bitstatus = RESET;
-  }
-  
-  /* Return the I2C_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ClearFlag
-* Description    : Clears the I2Cx's pending flags.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_FLAG: specifies the flag to clear. 
-*                    This parameter can be any combination of the following
-*                    values:
-*                       - I2C_FLAG_SMBALERT: SMBus Alert flag
-*                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
-*                       - I2C_FLAG_PECERR: PEC error in reception flag
-*                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
-*                       - I2C_FLAG_AF: Acknowledge failure flag
-*                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
-*                       - I2C_FLAG_BERR: Bus error flag
-*                       
-*                  Notes: 
-*                        - STOPF (STOP detection) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetFlagStatus()) followed by a write operation 
-*                          to I2C_CR1 register (I2C_Cmd() to re-enable the 
-*                          I2C peripheral). 
-*                        - ADD10 (10-bit header sent) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 
-*                          (I2C_GetFlagStatus()) followed by writing the
-*                          second byte of the address in DR register.
-*                        - BTF (Byte Transfer Finished) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetFlagStatus()) followed by a read/write to 
-*                          I2C_DR register (I2C_SendData()).
-*                        - ADDR (Address sent) is cleared by software sequence: 
-*                          a read operation to I2C_SR1 register 
-*                          (I2C_GetFlagStatus()) followed by a read operation to 
-*                          I2C_SR2 register ((void)(I2Cx-&gt;SR2)).
-*                        - SB (Start Bit) is cleared software sequence: a read 
-*                          operation to I2C_SR1 register (I2C_GetFlagStatus()) 
-*                          followed by a write operation to I2C_DR reigister 
-*                          (I2C_SendData()). 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
-{
-  u32 flagpos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
-
-  /* Get the I2C flag position */
-  flagpos = I2C_FLAG &amp; FLAG_Mask;
-
-  /* Clear the selected I2C flag */
-  I2Cx-&gt;SR1 = (u16)~flagpos;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_GetITStatus
-* Description    : Checks whether the specified I2C interrupt has occurred or not.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_IT: specifies the interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - I2C_IT_SMBALERT: SMBus Alert flag
-*                       - I2C_IT_TIMEOUT: Timeout or Tlow error flag
-*                       - I2C_IT_PECERR: PEC error in reception flag
-*                       - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
-*                       - I2C_IT_AF: Acknowledge failure flag
-*                       - I2C_IT_ARLO: Arbitration lost flag (Master mode)
-*                       - I2C_IT_BERR: Bus error flag
-*                       - I2C_IT_TXE: Data register empty flag (Transmitter)
-*                       - I2C_IT_RXNE: Data register not empty (Receiver) flag
-*                       - I2C_IT_STOPF: Stop detection flag (Slave mode)
-*                       - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
-*                       - I2C_IT_BTF: Byte transfer finished flag
-*                       - I2C_IT_ADDR: Address sent flag (Master mode) &#147;ADSL&#148;
-*                                      Address matched flag (Slave mode)&#148;ENDAD&#148;
-*                       - I2C_IT_SB: Start bit flag (Master mode)
-* Output         : None
-* Return         : The new state of I2C_IT (SET or RESET).
-*******************************************************************************/
-ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
-{
-  ITStatus bitstatus = RESET;
-  u32 enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_GET_IT(I2C_IT));
-
-  /* Check if the interrupt source is enabled or not */
-  enablestatus = (u32)(((I2C_IT &amp; ITEN_Mask) &gt;&gt; 16) &amp; (I2Cx-&gt;CR2)) ;  
-
-  /* Get bit[23:0] of the flag */
-  I2C_IT &amp;= FLAG_Mask;
-
-  /* Check the status of the specified I2C flag */
-  if (((I2Cx-&gt;SR1 &amp; I2C_IT) != (u32)RESET) &amp;&amp; enablestatus)
-  {
-    /* I2C_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* I2C_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the I2C_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : I2C_ClearITPendingBit
-* Description    : Clears the I2Cx&#146;s interrupt pending bits.
-* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-*                  - I2C_IT: specifies the interrupt pending bit to clear. 
-*                    This parameter can be any combination of the following 
-*                    values:
-*                       - I2C_IT_SMBALERT: SMBus Alert interrupt
-*                       - I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
-*                       - I2C_IT_PECERR: PEC error in reception  interrupt
-*                       - I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
-*                       - I2C_IT_AF: Acknowledge failure interrupt
-*                       - I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
-*                       - I2C_IT_BERR: Bus error interrupt
-*                       
-*                  Notes:
-*                        - STOPF (STOP detection) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetITStatus()) followed by a write operation to 
-*                          I2C_CR1 register (I2C_Cmd() to re-enable the I2C 
-*                          peripheral). 
-*                        - ADD10 (10-bit header sent) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 
-*                          (I2C_GetITStatus()) followed by writing the second 
-*                          byte of the address in I2C_DR register.
-*                        - BTF (Byte Transfer Finished) is cleared by software 
-*                          sequence: a read operation to I2C_SR1 register 
-*                          (I2C_GetITStatus()) followed by a read/write to 
-*                          I2C_DR register (I2C_SendData()).
-*                        - ADDR (Address sent) is cleared by software sequence: 
-*                          a read operation to I2C_SR1 register (I2C_GetITStatus()) 
-*                          followed by a read operation to I2C_SR2 register 
-*                          ((void)(I2Cx-&gt;SR2)).
-*                        - SB (Start Bit) is cleared by software sequence: a 
-*                          read operation to I2C_SR1 register (I2C_GetITStatus()) 
-*                          followed by a write operation to I2C_DR reigister 
-*                          (I2C_SendData()). 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
-{
-  u32 flagpos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
-
-  /* Get the I2C flag position */
-  flagpos = I2C_IT &amp; FLAG_Mask;
-
-  /* Clear the selected I2C flag */
-  I2Cx-&gt;SR1 = (u16)~flagpos;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_i2c.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the I2C firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_i2c.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+	 
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* I2C SPE mask */
+#define CR1_PE_Set              ((u16)0x0001)
+#define CR1_PE_Reset            ((u16)0xFFFE)
+
+/* I2C START mask */
+#define CR1_START_Set           ((u16)0x0100)
+#define CR1_START_Reset         ((u16)0xFEFF)
+
+/* I2C STOP mask */
+#define CR1_STOP_Set            ((u16)0x0200)
+#define CR1_STOP_Reset          ((u16)0xFDFF)
+
+/* I2C ACK mask */
+#define CR1_ACK_Set             ((u16)0x0400)
+#define CR1_ACK_Reset           ((u16)0xFBFF)
+
+/* I2C ENGC mask */
+#define CR1_ENGC_Set            ((u16)0x0040)
+#define CR1_ENGC_Reset          ((u16)0xFFBF)
+
+/* I2C SWRST mask */
+#define CR1_SWRST_Set           ((u16)0x8000)
+#define CR1_SWRST_Reset         ((u16)0x7FFF)
+
+/* I2C PEC mask */
+#define CR1_PEC_Set             ((u16)0x1000)
+#define CR1_PEC_Reset           ((u16)0xEFFF)
+
+/* I2C ENPEC mask */
+#define CR1_ENPEC_Set           ((u16)0x0020)
+#define CR1_ENPEC_Reset         ((u16)0xFFDF)
+
+/* I2C ENARP mask */
+#define CR1_ENARP_Set           ((u16)0x0010)
+#define CR1_ENARP_Reset         ((u16)0xFFEF)
+
+/* I2C NOSTRETCH mask */
+#define CR1_NOSTRETCH_Set       ((u16)0x0080)
+#define CR1_NOSTRETCH_Reset     ((u16)0xFF7F)
+
+/* I2C registers Masks */
+#define CR1_CLEAR_Mask          ((u16)0xFBF5)
+
+/* I2C DMAEN mask */
+#define CR2_DMAEN_Set           ((u16)0x0800)
+#define CR2_DMAEN_Reset         ((u16)0xF7FF)
+
+/* I2C LAST mask */
+#define CR2_LAST_Set            ((u16)0x1000)
+#define CR2_LAST_Reset          ((u16)0xEFFF)
+
+/* I2C FREQ mask */
+#define CR2_FREQ_Reset          ((u16)0xFFC0)
+
+/* I2C ADD0 mask */
+#define OAR1_ADD0_Set           ((u16)0x0001)
+#define OAR1_ADD0_Reset         ((u16)0xFFFE)
+
+/* I2C ENDUAL mask */
+#define OAR2_ENDUAL_Set         ((u16)0x0001)
+#define OAR2_ENDUAL_Reset       ((u16)0xFFFE)
+
+/* I2C ADD2 mask */
+#define OAR2_ADD2_Reset         ((u16)0xFF01)
+
+/* I2C F/S mask */
+#define CCR_FS_Set              ((u16)0x8000)
+
+/* I2C CCR mask */
+#define CCR_CCR_Set             ((u16)0x0FFF)
+
+/* I2C FLAG mask */
+#define FLAG_Mask               ((u32)0x00FFFFFF)
+
+/* I2C Interrupt Enable mask */
+#define ITEN_Mask               ((u32)0x07000000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : I2C_DeInit
+* Description    : Deinitializes the I2Cx peripheral registers to their default
+*                  reset values.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_DeInit(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  switch (*(u32*)&amp;I2Cx)
+  {
+    case I2C1_BASE:
+      /* Enable I2C1 reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
+      /* Release I2C1 from reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
+      break;
+
+    case I2C2_BASE:
+      /* Enable I2C2 reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
+      /* Release I2C2 from reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
+      break;
+
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_Init
+* Description    : Initializes the I2Cx peripheral according to the specified 
+*                  parameters in the I2C_InitStruct.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
+*                    contains the configuration information for the specified
+*                    I2C peripheral.
+* Output         : None
+* Return         : None
+******************************************************************************/
+void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
+{
+  u16 tmpreg = 0, freqrange = 0;
+  u16 result = 0x04;
+  u32 pclk1 = 8000000;
+  RCC_ClocksTypeDef  rcc_clocks;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_MODE(I2C_InitStruct-&gt;I2C_Mode));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct-&gt;I2C_DutyCycle));
+  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct-&gt;I2C_OwnAddress1));
+  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct-&gt;I2C_Ack));
+  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct-&gt;I2C_AcknowledgedAddress));
+  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct-&gt;I2C_ClockSpeed));
+
+/*---------------------------- I2Cx CR2 Configuration ------------------------*/
+  /* Get the I2Cx CR2 value */
+  tmpreg = I2Cx-&gt;CR2;
+  /* Clear frequency FREQ[5:0] bits */
+  tmpreg &amp;= CR2_FREQ_Reset;
+  /* Get pclk1 frequency value */
+  RCC_GetClocksFreq(&amp;rcc_clocks);
+  pclk1 = rcc_clocks.PCLK1_Frequency;
+  /* Set frequency bits depending on pclk1 value */
+  freqrange = (u16)(pclk1 / 1000000);
+  tmpreg |= freqrange;
+  /* Write to I2Cx CR2 */
+  I2Cx-&gt;CR2 = tmpreg;
+
+/*---------------------------- I2Cx CCR Configuration ------------------------*/
+  /* Disable the selected I2C peripheral to configure TRISE */
+  I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
+
+  /* Reset tmpreg value */
+  /* Clear F/S, DUTY and CCR[11:0] bits */
+  tmpreg = 0;
+
+  /* Configure speed in standard mode */
+  if (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 100000)
+  {
+    /* Standard mode speed calculate */
+    result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed &lt;&lt; 1));
+    /* Test if CCR value is under 0x4*/
+    if (result &lt; 0x04)
+    {
+      /* Set minimum allowed value */
+      result = 0x04;  
+    }
+    /* Set speed value for standard mode */
+    tmpreg |= result;	  
+    /* Set Maximum Rise Time for standard mode */
+    I2Cx-&gt;TRISE = freqrange + 1; 
+  }
+  /* Configure speed in fast mode */
+  else /*(I2C_InitStruct-&gt;I2C_ClockSpeed &lt;= 400000)*/
+  {
+    if (I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_2)
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 2 */
+      result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 3));
+    }
+    else /*I2C_InitStruct-&gt;I2C_DutyCycle == I2C_DutyCycle_16_9*/
+    {
+      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
+      result = (u16)(pclk1 / (I2C_InitStruct-&gt;I2C_ClockSpeed * 25));
+      /* Set DUTY bit */
+      result |= I2C_DutyCycle_16_9;
+    }
+    /* Test if CCR value is under 0x1*/
+    if ((result &amp; CCR_CCR_Set) == 0)
+    {
+      /* Set minimum allowed value */
+      result |= (u16)0x0001;  
+    }
+    /* Set speed value and set F/S bit for fast mode */
+    tmpreg |= result | CCR_FS_Set;
+    /* Set Maximum Rise Time for fast mode */
+    I2Cx-&gt;TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
+  }
+  /* Write to I2Cx CCR */
+  I2Cx-&gt;CCR = tmpreg;
+
+  /* Enable the selected I2C peripheral */
+  I2Cx-&gt;CR1 |= CR1_PE_Set;
+
+/*---------------------------- I2Cx CR1 Configuration ------------------------*/
+  /* Get the I2Cx CR1 value */
+  tmpreg = I2Cx-&gt;CR1;
+  /* Clear ACK, SMBTYPE and  SMBUS bits */
+  tmpreg &amp;= CR1_CLEAR_Mask;
+  /* Configure I2Cx: mode and acknowledgement */
+  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
+  /* Set ACK bit according to I2C_Ack value */
+  tmpreg |= (u16)((u32)I2C_InitStruct-&gt;I2C_Mode | I2C_InitStruct-&gt;I2C_Ack);
+  /* Write to I2Cx CR1 */
+  I2Cx-&gt;CR1 = tmpreg;
+
+/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
+  /* Set I2Cx Own Address1 and acknowledged address */
+  I2Cx-&gt;OAR1 = (I2C_InitStruct-&gt;I2C_AcknowledgedAddress | I2C_InitStruct-&gt;I2C_OwnAddress1);
+}
+
+/*******************************************************************************
+* Function Name  : I2C_StructInit
+* Description    : Fills each I2C_InitStruct member with its default value.
+* Input          : - I2C_InitStruct: pointer to an I2C_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
+{
+/*---------------- Reset I2C init structure parameters values ----------------*/
+  /* Initialize the I2C_Mode member */
+  I2C_InitStruct-&gt;I2C_Mode = I2C_Mode_I2C;
+
+  /* Initialize the I2C_DutyCycle member */
+  I2C_InitStruct-&gt;I2C_DutyCycle = I2C_DutyCycle_2;
+
+  /* Initialize the I2C_OwnAddress1 member */
+  I2C_InitStruct-&gt;I2C_OwnAddress1 = 0;
+
+  /* Initialize the I2C_Ack member */
+  I2C_InitStruct-&gt;I2C_Ack = I2C_Ack_Disable;
+
+  /* Initialize the I2C_AcknowledgedAddress member */
+  I2C_InitStruct-&gt;I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
+
+  /* initialize the I2C_ClockSpeed member */
+  I2C_InitStruct-&gt;I2C_ClockSpeed = 5000;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_Cmd
+* Description    : Enables or disables the specified I2C peripheral.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2Cx peripheral. This parameter
+*                    can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C peripheral */
+    I2Cx-&gt;CR1 |= CR1_PE_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C peripheral */
+    I2Cx-&gt;CR1 &amp;= CR1_PE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_DMACmd
+* Description    : Enables or disables the specified I2C DMA requests.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C DMA transfer.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C DMA requests */
+    I2Cx-&gt;CR2 |= CR2_DMAEN_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C DMA requests */
+    I2Cx-&gt;CR2 &amp;= CR2_DMAEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_DMALastTransferCmd
+* Description    : Specifies that the next DMA transfer is the last one.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C DMA last transfer.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Next DMA transfer is the last transfer */
+    I2Cx-&gt;CR2 |= CR2_LAST_Set;
+  }
+  else
+  {
+    /* Next DMA transfer is not the last transfer */
+    I2Cx-&gt;CR2 &amp;= CR2_LAST_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_GenerateSTART
+* Description    : Generates I2Cx communication START condition.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C START condition generation.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None.
+*******************************************************************************/
+void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Generate a START condition */
+    I2Cx-&gt;CR1 |= CR1_START_Set;
+  }
+  else
+  {
+    /* Disable the START condition generation */
+    I2Cx-&gt;CR1 &amp;= CR1_START_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_GenerateSTOP
+* Description    : Generates I2Cx communication STOP condition.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C STOP condition generation.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None.
+*******************************************************************************/
+void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Generate a STOP condition */
+    I2Cx-&gt;CR1 |= CR1_STOP_Set;
+  }
+  else
+  {
+    /* Disable the STOP condition generation */
+    I2Cx-&gt;CR1 &amp;= CR1_STOP_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_AcknowledgeConfig
+* Description    : Enables or disables the specified I2C acknowledge feature.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C Acknowledgement.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None.
+*******************************************************************************/
+void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the acknowledgement */
+    I2Cx-&gt;CR1 |= CR1_ACK_Set;
+  }
+  else
+  {
+    /* Disable the acknowledgement */
+    I2Cx-&gt;CR1 &amp;= CR1_ACK_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_OwnAddress2Config
+* Description    : Configures the specified I2C own address2.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - Address: specifies the 7bit I2C own address2.
+* Output         : None
+* Return         : None.
+*******************************************************************************/
+void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
+{
+  u16 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Get the old register value */
+  tmpreg = I2Cx-&gt;OAR2;
+  /* Reset I2Cx Own address2 bit [7:1] */
+  tmpreg &amp;= OAR2_ADD2_Reset;
+  /* Set I2Cx Own address2 */
+  tmpreg |= (u16)(Address &amp; (u16)0x00FE);
+  /* Store the new register value */
+  I2Cx-&gt;OAR2 = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_DualAddressCmd
+* Description    : Enables or disables the specified I2C dual addressing mode.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C dual addressing mode.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable dual addressing mode */
+    I2Cx-&gt;OAR2 |= OAR2_ENDUAL_Set;
+  }
+  else
+  {
+    /* Disable dual addressing mode */
+    I2Cx-&gt;OAR2 &amp;= OAR2_ENDUAL_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_GeneralCallCmd
+* Description    : Enables or disables the specified I2C general call feature.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C General call.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable generall call */
+    I2Cx-&gt;CR1 |= CR1_ENGC_Set;
+  }
+  else
+  {
+    /* Disable generall call */
+    I2Cx-&gt;CR1 &amp;= CR1_ENGC_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_ITConfig
+* Description    : Enables or disables the specified I2C interrupts.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_IT: specifies the I2C interrupts sources to be enabled
+*                    or disabled. 
+*                    This parameter can be any combination of the following values:
+*                       - I2C_IT_BUF: Buffer interrupt mask
+*                       - I2C_IT_EVT: Event interrupt mask
+*                       - I2C_IT_ERR: Error interrupt mask
+*                  - NewState: new state of the specified I2C interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C interrupts */
+    I2Cx-&gt;CR2 |= I2C_IT;
+  }
+  else
+  {
+    /* Disable the selected I2C interrupts */
+    I2Cx-&gt;CR2 &amp;= (u16)~I2C_IT;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_SendData
+* Description    : Sends a data byte through the I2Cx peripheral.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - Data: Byte to be transmitted..
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Write in the DR register the data to be sent */
+  I2Cx-&gt;DR = Data;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_ReceiveData
+* Description    : Returns the most recent received data by the I2Cx peripheral.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+* Output         : None
+* Return         : The value of the received data.
+*******************************************************************************/
+u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Return the data in the DR register */
+  return (u8)I2Cx-&gt;DR;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_Send7bitAddress
+* Description    : Transmits the address byte to select the slave device.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - Address: specifies the slave address which will be transmitted
+*                  - I2C_Direction: specifies whether the I2C device will be a
+*                    Transmitter or a Receiver. 
+*                    This parameter can be one of the following values
+*                       - I2C_Direction_Transmitter: Transmitter mode
+*                       - I2C_Direction_Receiver: Receiver mode
+* Output         : None
+* Return         : None.
+*******************************************************************************/
+void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DIRECTION(I2C_Direction));
+
+  /* Test on the direction to set/reset the read/write bit */
+  if (I2C_Direction != I2C_Direction_Transmitter)
+  {
+    /* Set the address bit0 for read */
+    Address |= OAR1_ADD0_Set;
+  }
+  else
+  {
+    /* Reset the address bit0 for write */
+    Address &amp;= OAR1_ADD0_Reset;
+  }
+  /* Send the address */
+  I2Cx-&gt;DR = Address;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_ReadRegister
+* Description    : Reads the specified I2C register and returns its value.
+* Input1         : - I2C_Register: specifies the register to read.
+*                    This parameter can be one of the following values:
+*                       - I2C_Register_CR1:  CR1 register.
+*                       - I2C_Register_CR2:   CR2 register.
+*                       - I2C_Register_OAR1:  OAR1 register.
+*                       - I2C_Register_OAR2:  OAR2 register.
+*                       - I2C_Register_DR:    DR register.
+*                       - I2C_Register_SR1:   SR1 register.
+*                       - I2C_Register_SR2:   SR2 register.
+*                       - I2C_Register_CCR:   CCR register.
+*                       - I2C_Register_TRISE: TRISE register.
+* Output         : None
+* Return         : The value of the read register.
+*******************************************************************************/
+u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_REGISTER(I2C_Register));
+
+  /* Return the selected register value */
+  return (*(vu16 *)(*((vu32 *)&amp;I2Cx) + I2C_Register));
+}
+
+/*******************************************************************************
+* Function Name  : I2C_SoftwareResetCmd
+* Description    : Enables or disables the specified I2C software reset.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C software reset.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Peripheral under reset */
+    I2Cx-&gt;CR1 |= CR1_SWRST_Set;
+  }
+  else
+  {
+    /* Peripheral not under reset */
+    I2Cx-&gt;CR1 &amp;= CR1_SWRST_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_SMBusAlertConfig
+* Description    : Drives the SMBusAlert pin high or low for the specified I2C.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_SMBusAlert: specifies SMBAlert pin level. 
+*                    This parameter can be one of the following values:
+*                       - I2C_SMBusAlert_Low: SMBAlert pin driven low
+*                       - I2C_SMBusAlert_High: SMBAlert pin driven high
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
+
+  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
+  {
+    /* Drive the SMBusAlert pin Low */
+    I2Cx-&gt;CR1 |= I2C_SMBusAlert_Low;
+  }
+  else
+  {
+    /* Drive the SMBusAlert pin High  */
+    I2Cx-&gt;CR1 &amp;= I2C_SMBusAlert_High;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_TransmitPEC
+* Description    : Enables or disables the specified I2C PEC transfer.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2C PEC transmission.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC transmission */
+    I2Cx-&gt;CR1 |= CR1_PEC_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC transmission */
+    I2Cx-&gt;CR1 &amp;= CR1_PEC_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_PECPositionConfig
+* Description    : Selects the specified I2C PEC position.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_PECPosition: specifies the PEC position. 
+*                    This parameter can be one of the following values:
+*                       - I2C_PECPosition_Next: indicates that the next
+*                         byte is PEC
+*                       - I2C_PECPosition_Current: indicates that current
+*                         byte is PEC
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
+
+  if (I2C_PECPosition == I2C_PECPosition_Next)
+  {
+    /* Next byte in shift register is PEC */
+    I2Cx-&gt;CR1 |= I2C_PECPosition_Next;
+  }
+  else
+  {
+    /* Current byte in shift register is PEC */
+    I2Cx-&gt;CR1 &amp;= I2C_PECPosition_Current;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_CalculatePEC
+* Description    : Enables or disables the PEC value calculation of the
+*                  transfered bytes.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2Cx PEC value calculation.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C PEC calculation */
+    I2Cx-&gt;CR1 |= CR1_ENPEC_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C PEC calculation */
+    I2Cx-&gt;CR1 &amp;= CR1_ENPEC_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_GetPEC
+* Description    : Returns the PEC value for the specified I2C.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+* Output         : None
+* Return         : The PEC value.
+*******************************************************************************/
+u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Return the selected I2C PEC value */
+  return ((I2Cx-&gt;SR2) &gt;&gt; 8);
+}
+
+/*******************************************************************************
+* Function Name  : I2C_ARPCmd
+* Description    : Enables or disables the specified I2C ARP.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2Cx ARP. 
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected I2C ARP */
+    I2Cx-&gt;CR1 |= CR1_ENARP_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C ARP */
+    I2Cx-&gt;CR1 &amp;= CR1_ENARP_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_StretchClockCmd
+* Description    : Enables or disables the specified I2C Clock stretching.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - NewState: new state of the I2Cx Clock stretching.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState == DISABLE)
+  {
+    /* Enable the selected I2C Clock stretching */
+    I2Cx-&gt;CR1 |= CR1_NOSTRETCH_Set;
+  }
+  else
+  {
+    /* Disable the selected I2C Clock stretching */
+    I2Cx-&gt;CR1 &amp;= CR1_NOSTRETCH_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_FastModeDutyCycleConfig
+* Description    : Selects the specified I2C fast mode duty cycle.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_DutyCycle: specifies the fast mode duty cycle.
+*                    This parameter can be one of the following values:
+*                       - I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
+*                       - I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
+{
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
+
+  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
+  {
+    /* I2C fast mode Tlow/Thigh=2 */
+    I2Cx-&gt;CCR &amp;= I2C_DutyCycle_2;
+  }
+  else
+  {
+    /* I2C fast mode Tlow/Thigh=16/9 */
+    I2Cx-&gt;CCR |= I2C_DutyCycle_16_9;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2C_GetLastEvent
+* Description    : Returns the last I2Cx Event.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+* Output         : None
+* Return         : The last event
+*******************************************************************************/
+u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
+{
+  u32 lastevent = 0;
+  u32 flag1 = 0, flag2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+
+  /* Read the I2Cx status register */
+  flag1 = I2Cx-&gt;SR1;
+  flag2 = I2Cx-&gt;SR2;
+  flag2 = flag2 &lt;&lt; 16;
+
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
+
+  /* Return status */
+  return lastevent;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_CheckEvent
+* Description    : Checks whether the last I2Cx Event is equal to the one passed
+*                  as parameter.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_EVENT: specifies the event to be checked. 
+*                    This parameter can be one of the following values:
+*                       - I2C_EVENT_SLAVE_ADDRESS_MATCHED   : EV1
+*                       - I2C_EVENT_SLAVE_BYTE_RECEIVED     : EV2
+*                       - I2C_EVENT_SLAVE_BYTE_TRANSMITTED  : EV3
+*                       - I2C_EVENT_SLAVE_ACK_FAILURE       : EV3-2
+*                       - I2C_EVENT_MASTER_MODE_SELECT      : EV5
+*                       - I2C_EVENT_MASTER_MODE_SELECTED    : EV6
+*                       - I2C_EVENT_MASTER_BYTE_RECEIVED    : EV7
+*                       - I2C_EVENT_MASTER_BYTE_TRANSMITTED : EV8
+*                       - I2C_EVENT_MASTER_MODE_ADDRESS10   : EV9
+*                       - I2C_EVENT_SLAVE_STOP_DETECTED     : EV4
+* Output         : None
+* Return         : An ErrorStatus enumuration value:
+*                       - SUCCESS: Last event is equal to the I2C_EVENT
+*                       - ERROR: Last event is different from the I2C_EVENT
+*******************************************************************************/
+ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
+{
+  u32 lastevent = 0;
+  u32 flag1 = 0, flag2 = 0;
+  ErrorStatus status = ERROR;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_EVENT(I2C_EVENT));
+
+  /* Read the I2Cx status register */
+  flag1 = I2Cx-&gt;SR1;
+  flag2 = I2Cx-&gt;SR2;
+  flag2 = flag2 &lt;&lt; 16;
+
+  /* Get the last event value from I2C status register */
+  lastevent = (flag1 | flag2) &amp; FLAG_Mask;
+
+  /* Check whether the last event is equal to I2C_EVENT */
+  if (lastevent == I2C_EVENT )
+  {
+    /* SUCCESS: last event is equal to I2C_EVENT */
+    status = SUCCESS;
+  }
+  else
+  {
+    /* ERROR: last event is different from I2C_EVENT */
+    status = ERROR;
+  }
+
+  /* Return status */
+  return status;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_GetFlagStatus
+* Description    : Checks whether the specified I2C flag is set or not.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_FLAG: specifies the flag to check. 
+*                    This parameter can be one of the following values:
+*                       - I2C_FLAG_DUALF: Dual flag (Slave mode)
+*                       - I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
+*                       - I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
+*                       - I2C_FLAG_GENCALL: General call header flag (Slave mode)
+*                       - I2C_FLAG_TRA: Transmitter/Receiver flag
+*                       - I2C_FLAG_BUSY: Bus busy flag
+*                       - I2C_FLAG_MSL: Master/Slave flag
+*                       - I2C_FLAG_SMBALERT: SMBus Alert flag
+*                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+*                       - I2C_FLAG_PECERR: PEC error in reception flag
+*                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+*                       - I2C_FLAG_AF: Acknowledge failure flag
+*                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+*                       - I2C_FLAG_BERR: Bus error flag
+*                       - I2C_FLAG_TXE: Data register empty flag (Transmitter)
+*                       - I2C_FLAG_RXNE: Data register not empty (Receiver) flag
+*                       - I2C_FLAG_STOPF: Stop detection flag (Slave mode)
+*                       - I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
+*                       - I2C_FLAG_BTF: Byte transfer finished flag
+*                       - I2C_FLAG_ADDR: Address sent flag (Master mode) 'ADSL'
+*                                        Address matched flag (Slave mode)'ENDAD'
+*                       - I2C_FLAG_SB: Start bit flag (Master mode)
+* Output         : None
+* Return         : The new state of I2C_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  u32 i2creg = 0, i2cxbase = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
+
+  /* Get the I2Cx peripheral base address */
+  i2cxbase = (*(u32*)&amp;(I2Cx));
+  
+  /* Read flag register index */
+  i2creg = I2C_FLAG &gt;&gt; 28;
+  
+  /* Get bit[23:0] of the flag */
+  I2C_FLAG &amp;= FLAG_Mask;
+  
+  if(i2creg != 0)
+  {
+    /* Get the I2Cx SR1 register address */
+    i2cxbase += 0x14;
+  }
+  else
+  {
+    /* Flag in I2Cx SR2 Register */
+    I2C_FLAG = (u32)(I2C_FLAG &gt;&gt; 16);
+    /* Get the I2Cx SR2 register address */
+    i2cxbase += 0x18;
+  }
+  
+  if(((*(vu32 *)i2cxbase) &amp; I2C_FLAG) != (u32)RESET)
+  {
+    /* I2C_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_FLAG is reset */
+    bitstatus = RESET;
+  }
+  
+  /* Return the I2C_FLAG status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_ClearFlag
+* Description    : Clears the I2Cx's pending flags.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_FLAG: specifies the flag to clear. 
+*                    This parameter can be any combination of the following
+*                    values:
+*                       - I2C_FLAG_SMBALERT: SMBus Alert flag
+*                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
+*                       - I2C_FLAG_PECERR: PEC error in reception flag
+*                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+*                       - I2C_FLAG_AF: Acknowledge failure flag
+*                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+*                       - I2C_FLAG_BERR: Bus error flag
+*                       
+*                  Notes: 
+*                        - STOPF (STOP detection) is cleared by software 
+*                          sequence: a read operation to I2C_SR1 register 
+*                          (I2C_GetFlagStatus()) followed by a write operation 
+*                          to I2C_CR1 register (I2C_Cmd() to re-enable the 
+*                          I2C peripheral). 
+*                        - ADD10 (10-bit header sent) is cleared by software 
+*                          sequence: a read operation to I2C_SR1 
+*                          (I2C_GetFlagStatus()) followed by writing the
+*                          second byte of the address in DR register.
+*                        - BTF (Byte Transfer Finished) is cleared by software 
+*                          sequence: a read operation to I2C_SR1 register 
+*                          (I2C_GetFlagStatus()) followed by a read/write to 
+*                          I2C_DR register (I2C_SendData()).
+*                        - ADDR (Address sent) is cleared by software sequence: 
+*                          a read operation to I2C_SR1 register 
+*                          (I2C_GetFlagStatus()) followed by a read operation to 
+*                          I2C_SR2 register ((void)(I2Cx-&gt;SR2)).
+*                        - SB (Start Bit) is cleared software sequence: a read 
+*                          operation to I2C_SR1 register (I2C_GetFlagStatus()) 
+*                          followed by a write operation to I2C_DR reigister 
+*                          (I2C_SendData()). 
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
+{
+  u32 flagpos = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
+
+  /* Get the I2C flag position */
+  flagpos = I2C_FLAG &amp; FLAG_Mask;
+
+  /* Clear the selected I2C flag */
+  I2Cx-&gt;SR1 = (u16)~flagpos;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_GetITStatus
+* Description    : Checks whether the specified I2C interrupt has occurred or not.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_IT: specifies the interrupt source to check. 
+*                    This parameter can be one of the following values:
+*                       - I2C_IT_SMBALERT: SMBus Alert flag
+*                       - I2C_IT_TIMEOUT: Timeout or Tlow error flag
+*                       - I2C_IT_PECERR: PEC error in reception flag
+*                       - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
+*                       - I2C_IT_AF: Acknowledge failure flag
+*                       - I2C_IT_ARLO: Arbitration lost flag (Master mode)
+*                       - I2C_IT_BERR: Bus error flag
+*                       - I2C_IT_TXE: Data register empty flag (Transmitter)
+*                       - I2C_IT_RXNE: Data register not empty (Receiver) flag
+*                       - I2C_IT_STOPF: Stop detection flag (Slave mode)
+*                       - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
+*                       - I2C_IT_BTF: Byte transfer finished flag
+*                       - I2C_IT_ADDR: Address sent flag (Master mode) 'ADSL'
+*                                      Address matched flag (Slave mode)'ENDAD'
+*                       - I2C_IT_SB: Start bit flag (Master mode)
+* Output         : None
+* Return         : The new state of I2C_IT (SET or RESET).
+*******************************************************************************/
+ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
+{
+  ITStatus bitstatus = RESET;
+  u32 enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_GET_IT(I2C_IT));
+
+  /* Check if the interrupt source is enabled or not */
+  enablestatus = (u32)(((I2C_IT &amp; ITEN_Mask) &gt;&gt; 16) &amp; (I2Cx-&gt;CR2)) ;  
+
+  /* Get bit[23:0] of the flag */
+  I2C_IT &amp;= FLAG_Mask;
+
+  /* Check the status of the specified I2C flag */
+  if (((I2Cx-&gt;SR1 &amp; I2C_IT) != (u32)RESET) &amp;&amp; enablestatus)
+  {
+    /* I2C_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* I2C_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the I2C_IT status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : I2C_ClearITPendingBit
+* Description    : Clears the I2Cx's interrupt pending bits.
+* Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
+*                  - I2C_IT: specifies the interrupt pending bit to clear. 
+*                    This parameter can be any combination of the following 
+*                    values:
+*                       - I2C_IT_SMBALERT: SMBus Alert interrupt
+*                       - I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
+*                       - I2C_IT_PECERR: PEC error in reception  interrupt
+*                       - I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
+*                       - I2C_IT_AF: Acknowledge failure interrupt
+*                       - I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
+*                       - I2C_IT_BERR: Bus error interrupt
+*                       
+*                  Notes:
+*                        - STOPF (STOP detection) is cleared by software 
+*                          sequence: a read operation to I2C_SR1 register 
+*                          (I2C_GetITStatus()) followed by a write operation to 
+*                          I2C_CR1 register (I2C_Cmd() to re-enable the I2C 
+*                          peripheral). 
+*                        - ADD10 (10-bit header sent) is cleared by software 
+*                          sequence: a read operation to I2C_SR1 
+*                          (I2C_GetITStatus()) followed by writing the second 
+*                          byte of the address in I2C_DR register.
+*                        - BTF (Byte Transfer Finished) is cleared by software 
+*                          sequence: a read operation to I2C_SR1 register 
+*                          (I2C_GetITStatus()) followed by a read/write to 
+*                          I2C_DR register (I2C_SendData()).
+*                        - ADDR (Address sent) is cleared by software sequence: 
+*                          a read operation to I2C_SR1 register (I2C_GetITStatus()) 
+*                          followed by a read operation to I2C_SR2 register 
+*                          ((void)(I2Cx-&gt;SR2)).
+*                        - SB (Start Bit) is cleared by software sequence: a 
+*                          read operation to I2C_SR1 register (I2C_GetITStatus()) 
+*                          followed by a write operation to I2C_DR reigister 
+*                          (I2C_SendData()). 
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
+{
+  u32 flagpos = 0;
+
+  /* Check the parameters */
+  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
+  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
+
+  /* Get the I2C flag position */
+  flagpos = I2C_IT &amp; FLAG_Mask;
+
+  /* Clear the selected I2C flag */
+  I2Cx-&gt;SR1 = (u16)~flagpos;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_iwdg.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,148 +1,148 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_iwdg.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the IWDG firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_iwdg.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ---------------------- IWDG registers bit mask ------------------------ */
-/* KR register bit mask */
-#define KR_KEY_Reload    ((u16)0xAAAA)
-#define KR_KEY_Enable    ((u16)0xCCCC)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : IWDG_WriteAccessCmd
-* Description    : Enables or disables write access to IWDG_PR and IWDG_RLR
-*                  registers.
-* Input          : - IWDG_WriteAccess: new state of write access to IWDG_PR and
-*                    IWDG_RLR registers.
-*                    This parameter can be one of the following values:
-*                       - IWDG_WriteAccess_Enable: Enable write access to 
-*                         IWDG_PR and IWDG_RLR registers
-*                       - IWDG_WriteAccess_Disable: Disable write access to
-*                         IWDG_PR and IWDG_RLR registers
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_WriteAccessCmd(u16 IWDG_WriteAccess)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
-
-  IWDG-&gt;KR = IWDG_WriteAccess;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_SetPrescaler
-* Description    : Sets IWDG Prescaler value.
-* Input          : - IWDG_Prescaler: specifies the IWDG Prescaler value.
-*                    This parameter can be one of the following values:
-*                       - IWDG_Prescaler_4: IWDG prescaler set to 4
-*                       - IWDG_Prescaler_8: IWDG prescaler set to 8
-*                       - IWDG_Prescaler_16: IWDG prescaler set to 16
-*                       - IWDG_Prescaler_32: IWDG prescaler set to 32
-*                       - IWDG_Prescaler_64: IWDG prescaler set to 64
-*                       - IWDG_Prescaler_128: IWDG prescaler set to 128
-*                       - IWDG_Prescaler_256: IWDG prescaler set to 256
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_SetPrescaler(u8 IWDG_Prescaler)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
-
-  IWDG-&gt;PR = IWDG_Prescaler;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_SetReload
-* Description    : Sets IWDG Reload value.
-* Input          : - Reload: specifies the IWDG Reload value.
-*                    This parameter must be a number between 0 and 0x0FFF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_SetReload(u16 Reload)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_RELOAD(Reload));
-
-  IWDG-&gt;RLR = Reload;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_ReloadCounter
-* Description    : Reloads IWDG counter with value defined in the reload register
-*                  (write access to IWDG_PR and IWDG_RLR registers disabled).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_ReloadCounter(void)
-{
-  IWDG-&gt;KR = KR_KEY_Reload;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_Enable
-* Description    : Enables IWDG (write access to IWDG_PR and IWDG_RLR registers
-*                  disabled).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void IWDG_Enable(void)
-{
-  IWDG-&gt;KR = KR_KEY_Enable;
-}
-
-/*******************************************************************************
-* Function Name  : IWDG_GetFlagStatus
-* Description    : Checks whether the specified IWDG flag is set or not.
-* Input          : - IWDG_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - IWDG_FLAG_PVU: Prescaler Value Update on going
-*                       - IWDG_FLAG_RVU: Reload Value Update on going
-* Output         : None
-* Return         : The new state of IWDG_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus IWDG_GetFlagStatus(u16 IWDG_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
-
-  if ((IWDG-&gt;SR &amp; IWDG_FLAG) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_iwdg.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the IWDG firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_iwdg.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ---------------------- IWDG registers bit mask ------------------------ */
+/* KR register bit mask */
+#define KR_KEY_Reload    ((u16)0xAAAA)
+#define KR_KEY_Enable    ((u16)0xCCCC)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : IWDG_WriteAccessCmd
+* Description    : Enables or disables write access to IWDG_PR and IWDG_RLR
+*                  registers.
+* Input          : - IWDG_WriteAccess: new state of write access to IWDG_PR and
+*                    IWDG_RLR registers.
+*                    This parameter can be one of the following values:
+*                       - IWDG_WriteAccess_Enable: Enable write access to 
+*                         IWDG_PR and IWDG_RLR registers
+*                       - IWDG_WriteAccess_Disable: Disable write access to
+*                         IWDG_PR and IWDG_RLR registers
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void IWDG_WriteAccessCmd(u16 IWDG_WriteAccess)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
+
+  IWDG-&gt;KR = IWDG_WriteAccess;
+}
+
+/*******************************************************************************
+* Function Name  : IWDG_SetPrescaler
+* Description    : Sets IWDG Prescaler value.
+* Input          : - IWDG_Prescaler: specifies the IWDG Prescaler value.
+*                    This parameter can be one of the following values:
+*                       - IWDG_Prescaler_4: IWDG prescaler set to 4
+*                       - IWDG_Prescaler_8: IWDG prescaler set to 8
+*                       - IWDG_Prescaler_16: IWDG prescaler set to 16
+*                       - IWDG_Prescaler_32: IWDG prescaler set to 32
+*                       - IWDG_Prescaler_64: IWDG prescaler set to 64
+*                       - IWDG_Prescaler_128: IWDG prescaler set to 128
+*                       - IWDG_Prescaler_256: IWDG prescaler set to 256
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void IWDG_SetPrescaler(u8 IWDG_Prescaler)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
+
+  IWDG-&gt;PR = IWDG_Prescaler;
+}
+
+/*******************************************************************************
+* Function Name  : IWDG_SetReload
+* Description    : Sets IWDG Reload value.
+* Input          : - Reload: specifies the IWDG Reload value.
+*                    This parameter must be a number between 0 and 0x0FFF.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void IWDG_SetReload(u16 Reload)
+{
+  /* Check the parameters */
+  assert_param(IS_IWDG_RELOAD(Reload));
+
+  IWDG-&gt;RLR = Reload;
+}
+
+/*******************************************************************************
+* Function Name  : IWDG_ReloadCounter
+* Description    : Reloads IWDG counter with value defined in the reload register
+*                  (write access to IWDG_PR and IWDG_RLR registers disabled).
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void IWDG_ReloadCounter(void)
+{
+  IWDG-&gt;KR = KR_KEY_Reload;
+}
+
+/*******************************************************************************
+* Function Name  : IWDG_Enable
+* Description    : Enables IWDG (write access to IWDG_PR and IWDG_RLR registers
+*                  disabled).
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void IWDG_Enable(void)
+{
+  IWDG-&gt;KR = KR_KEY_Enable;
+}
+
+/*******************************************************************************
+* Function Name  : IWDG_GetFlagStatus
+* Description    : Checks whether the specified IWDG flag is set or not.
+* Input          : - IWDG_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - IWDG_FLAG_PVU: Prescaler Value Update on going
+*                       - IWDG_FLAG_RVU: Reload Value Update on going
+* Output         : None
+* Return         : The new state of IWDG_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus IWDG_GetFlagStatus(u16 IWDG_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
+
+  if ((IWDG-&gt;SR &amp; IWDG_FLAG) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_lib.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,303 +1,303 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_lib.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all peripherals pointers initialization.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-#define EXT
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_lib.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-#ifdef DEBUG
-/*******************************************************************************
-* Function Name  : debug
-* Description    : This function initialize peripherals pointers.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void debug(void)
-{
-
-/************************************* ADC ************************************/
-#ifdef _ADC1
-  ADC1 = (ADC_TypeDef *)  ADC1_BASE;
-#endif /*_ADC1 */
-
-#ifdef _ADC2
-  ADC2 = (ADC_TypeDef *)  ADC2_BASE;
-#endif /*_ADC2 */
-
-#ifdef _ADC3
-  ADC3 = (ADC_TypeDef *)  ADC3_BASE;
-#endif /*_ADC3 */
-
-/************************************* BKP ************************************/
-#ifdef _BKP
-  BKP = (BKP_TypeDef *)  BKP_BASE;
-#endif /*_BKP */
-
-/************************************* CAN ************************************/
-#ifdef _CAN
-  CAN = (CAN_TypeDef *)  CAN_BASE;
-#endif /*_CAN */
-
-/************************************* CRC ************************************/
-#ifdef _CRC
-  CRC = (CRC_TypeDef *)  CRC_BASE;
-#endif /*_CRC */
-
-/************************************* DAC ************************************/
-#ifdef _DAC
-  DAC = (DAC_TypeDef *)  DAC_BASE;
-#endif /*_DAC */
-
-/************************************* DBGMCU**********************************/
-#ifdef _DBGMCU
-  DBGMCU = (DBGMCU_TypeDef *)  DBGMCU_BASE;
-#endif /*_DBGMCU */
-
-/************************************* DMA ************************************/
-#ifdef _DMA
-  DMA1 = (DMA_TypeDef *)  DMA1_BASE;
-  DMA2 = (DMA_TypeDef *)  DMA2_BASE;
-#endif /*_DMA */
-
-#ifdef _DMA1_Channel1
-  DMA1_Channel1 = (DMA_Channel_TypeDef *)  DMA1_Channel1_BASE;
-#endif /*_DMA1_Channel1 */
-
-#ifdef _DMA1_Channel2
-  DMA1_Channel2 = (DMA_Channel_TypeDef *)  DMA1_Channel2_BASE;
-#endif /*_DMA1_Channel2 */
-
-#ifdef _DMA1_Channel3
-  DMA1_Channel3 = (DMA_Channel_TypeDef *)  DMA1_Channel3_BASE;
-#endif /*_DMA1_Channel3 */
-
-#ifdef _DMA1_Channel4
-  DMA1_Channel4 = (DMA_Channel_TypeDef *)  DMA1_Channel4_BASE;
-#endif /*_DMA1_Channel4 */
-
-#ifdef _DMA1_Channel5
-  DMA1_Channel5 = (DMA_Channel_TypeDef *)  DMA1_Channel5_BASE;
-#endif /*_DMA1_Channel5 */
-
-#ifdef _DMA1_Channel6
-  DMA1_Channel6 = (DMA_Channel_TypeDef *)  DMA1_Channel6_BASE;
-#endif /*_DMA1_Channel6 */
-
-#ifdef _DMA1_Channel7
-  DMA1_Channel7 = (DMA_Channel_TypeDef *)  DMA1_Channel7_BASE;
-#endif /*_DMA1_Channel7 */
-
-#ifdef _DMA2_Channel1
-  DMA2_Channel1 = (DMA_Channel_TypeDef *)  DMA2_Channel1_BASE;
-#endif /*_DMA2_Channel1 */
-
-#ifdef _DMA2_Channel2
-  DMA2_Channel2 = (DMA_Channel_TypeDef *)  DMA2_Channel2_BASE;
-#endif /*_DMA2_Channel2 */
-
-#ifdef _DMA2_Channel3
-  DMA2_Channel3 = (DMA_Channel_TypeDef *)  DMA2_Channel3_BASE;
-#endif /*_DMA2_Channel3 */
-
-#ifdef _DMA2_Channel4
-  DMA2_Channel4 = (DMA_Channel_TypeDef *)  DMA2_Channel4_BASE;
-#endif /*_DMA2_Channel4 */
-
-#ifdef _DMA2_Channel5
-  DMA2_Channel5 = (DMA_Channel_TypeDef *)  DMA2_Channel5_BASE;
-#endif /*_DMA2_Channel5 */
-
-/************************************* EXTI ***********************************/
-#ifdef _EXTI
-  EXTI = (EXTI_TypeDef *)  EXTI_BASE;
-#endif /*_EXTI */
-
-/************************************* FLASH and Option Bytes *****************/
-#ifdef _FLASH
-  FLASH = (FLASH_TypeDef *)  FLASH_R_BASE;
-  OB = (OB_TypeDef *)        OB_BASE;
-#endif /*_FLASH */
-
-/************************************* FSMC ***********************************/
-#ifdef _FSMC
-  FSMC_Bank1 = (FSMC_Bank1_TypeDef *)    FSMC_Bank1_R_BASE;
-  FSMC_Bank1E = (FSMC_Bank1E_TypeDef *)  FSMC_Bank1E_R_BASE;  
-  FSMC_Bank2 = (FSMC_Bank2_TypeDef *)    FSMC_Bank2_R_BASE; 
-  FSMC_Bank3 = (FSMC_Bank3_TypeDef *)    FSMC_Bank3_R_BASE;
-  FSMC_Bank4 = (FSMC_Bank4_TypeDef *)    FSMC_Bank4_R_BASE;
-#endif /*_FSMC */
-
-/************************************* GPIO ***********************************/
-#ifdef _GPIOA
-  GPIOA = (GPIO_TypeDef *)  GPIOA_BASE;
-#endif /*_GPIOA */
-
-#ifdef _GPIOB
-  GPIOB = (GPIO_TypeDef *)  GPIOB_BASE;
-#endif /*_GPIOB */
-
-#ifdef _GPIOC
-  GPIOC = (GPIO_TypeDef *)  GPIOC_BASE;
-#endif /*_GPIOC */
-
-#ifdef _GPIOD
-  GPIOD = (GPIO_TypeDef *)  GPIOD_BASE;
-#endif /*_GPIOD */
-
-#ifdef _GPIOE
-  GPIOE = (GPIO_TypeDef *)  GPIOE_BASE;
-#endif /*_GPIOE */
-
-#ifdef _GPIOF
-  GPIOF = (GPIO_TypeDef *)  GPIOF_BASE;
-#endif /*_GPIOF */
-
-#ifdef _GPIOG
-  GPIOG = (GPIO_TypeDef *)  GPIOG_BASE;
-#endif /*_GPIOG */
-
-#ifdef _AFIO
-  AFIO = (AFIO_TypeDef *)  AFIO_BASE;
-#endif /*_AFIO */
-
-/************************************* I2C ************************************/
-#ifdef _I2C1
-  I2C1 = (I2C_TypeDef *)  I2C1_BASE;
-#endif /*_I2C1 */
-
-#ifdef _I2C2
-  I2C2 = (I2C_TypeDef *)  I2C2_BASE;
-#endif /*_I2C2 */
-
-/************************************* IWDG ***********************************/
-#ifdef _IWDG
-  IWDG = (IWDG_TypeDef *) IWDG_BASE;
-#endif /*_IWDG */
-
-/************************************* NVIC ***********************************/
-#ifdef _NVIC
-  NVIC = (NVIC_TypeDef *)  NVIC_BASE;
-  SCB = (SCB_TypeDef *)  SCB_BASE;
-#endif /*_NVIC */
-
-/************************************* PWR ************************************/
-#ifdef _PWR
-  PWR = (PWR_TypeDef *)  PWR_BASE;
-#endif /*_PWR */
-
-/************************************* RCC ************************************/
-#ifdef _RCC
-  RCC = (RCC_TypeDef *)  RCC_BASE;
-#endif /*_RCC */
-
-/************************************* RTC ************************************/
-#ifdef _RTC
-  RTC = (RTC_TypeDef *)  RTC_BASE;
-#endif /*_RTC */
-
-/************************************* SDIO ***********************************/
-#ifdef _SDIO
-  SDIO = (SDIO_TypeDef *)  SDIO_BASE;
-#endif /*_SDIO */
-
-/************************************* SPI ************************************/
-#ifdef _SPI1
-  SPI1 = (SPI_TypeDef *)  SPI1_BASE;
-#endif /*_SPI1 */
-
-#ifdef _SPI2
-  SPI2 = (SPI_TypeDef *)  SPI2_BASE;
-#endif /*_SPI2 */
-
-#ifdef _SPI3
-  SPI3 = (SPI_TypeDef *)  SPI3_BASE;
-#endif /*_SPI3 */
-
-/************************************* SysTick ********************************/
-#ifdef _SysTick
-  SysTick = (SysTick_TypeDef *)  SysTick_BASE;
-#endif /*_SysTick */
-
-/************************************* TIM ************************************/
-#ifdef _TIM1
-  TIM1 = (TIM_TypeDef *)  TIM1_BASE;
-#endif /*_TIM1 */
-
-#ifdef _TIM2
-  TIM2 = (TIM_TypeDef *)  TIM2_BASE;
-#endif /*_TIM2 */
-
-#ifdef _TIM3
-  TIM3 = (TIM_TypeDef *)  TIM3_BASE;
-#endif /*_TIM3 */
-
-#ifdef _TIM4
-  TIM4 = (TIM_TypeDef *)  TIM4_BASE;
-#endif /*_TIM4 */
-
-#ifdef _TIM5
-  TIM5 = (TIM_TypeDef *)  TIM5_BASE;
-#endif /*_TIM5 */
-
-#ifdef _TIM6
-  TIM6 = (TIM_TypeDef *)  TIM6_BASE;
-#endif /*_TIM6 */
-
-#ifdef _TIM7
-  TIM7 = (TIM_TypeDef *)  TIM7_BASE;
-#endif /*_TIM7 */
-
-#ifdef _TIM8
-  TIM8 = (TIM_TypeDef *)  TIM8_BASE;
-#endif /*_TIM8 */
-
-/************************************* USART **********************************/
-#ifdef _USART1
-  USART1 = (USART_TypeDef *) USART1_BASE;
-#endif /*_USART1 */
-
-#ifdef _USART2
-  USART2 = (USART_TypeDef *) USART2_BASE;
-#endif /*_USART2 */
-
-#ifdef _USART3
-  USART3 = (USART_TypeDef *) USART3_BASE;
-#endif /*_USART3 */
-
-#ifdef _UART4
-  UART4 = (USART_TypeDef *) UART4_BASE;
-#endif /*_UART4 */
-
-#ifdef _UART5
-  UART5 = (USART_TypeDef *) UART5_BASE;
-#endif /*_UART5 */
-
-/************************************* WWDG ***********************************/
-#ifdef _WWDG
-  WWDG = (WWDG_TypeDef *)  WWDG_BASE;
-#endif /*_WWDG */
-}
-#endif  /* DEBUG*/
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_lib.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all peripherals pointers initialization.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+#define EXT
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_lib.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+#ifdef DEBUG
+/*******************************************************************************
+* Function Name  : debug
+* Description    : This function initialize peripherals pointers.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void debug(void)
+{
+
+/************************************* ADC ************************************/
+#ifdef _ADC1
+  ADC1 = (ADC_TypeDef *)  ADC1_BASE;
+#endif /*_ADC1 */
+
+#ifdef _ADC2
+  ADC2 = (ADC_TypeDef *)  ADC2_BASE;
+#endif /*_ADC2 */
+
+#ifdef _ADC3
+  ADC3 = (ADC_TypeDef *)  ADC3_BASE;
+#endif /*_ADC3 */
+
+/************************************* BKP ************************************/
+#ifdef _BKP
+  BKP = (BKP_TypeDef *)  BKP_BASE;
+#endif /*_BKP */
+
+/************************************* CAN ************************************/
+#ifdef _CAN
+  CAN = (CAN_TypeDef *)  CAN_BASE;
+#endif /*_CAN */
+
+/************************************* CRC ************************************/
+#ifdef _CRC
+  CRC = (CRC_TypeDef *)  CRC_BASE;
+#endif /*_CRC */
+
+/************************************* DAC ************************************/
+#ifdef _DAC
+  DAC = (DAC_TypeDef *)  DAC_BASE;
+#endif /*_DAC */
+
+/************************************* DBGMCU**********************************/
+#ifdef _DBGMCU
+  DBGMCU = (DBGMCU_TypeDef *)  DBGMCU_BASE;
+#endif /*_DBGMCU */
+
+/************************************* DMA ************************************/
+#ifdef _DMA
+  DMA1 = (DMA_TypeDef *)  DMA1_BASE;
+  DMA2 = (DMA_TypeDef *)  DMA2_BASE;
+#endif /*_DMA */
+
+#ifdef _DMA1_Channel1
+  DMA1_Channel1 = (DMA_Channel_TypeDef *)  DMA1_Channel1_BASE;
+#endif /*_DMA1_Channel1 */
+
+#ifdef _DMA1_Channel2
+  DMA1_Channel2 = (DMA_Channel_TypeDef *)  DMA1_Channel2_BASE;
+#endif /*_DMA1_Channel2 */
+
+#ifdef _DMA1_Channel3
+  DMA1_Channel3 = (DMA_Channel_TypeDef *)  DMA1_Channel3_BASE;
+#endif /*_DMA1_Channel3 */
+
+#ifdef _DMA1_Channel4
+  DMA1_Channel4 = (DMA_Channel_TypeDef *)  DMA1_Channel4_BASE;
+#endif /*_DMA1_Channel4 */
+
+#ifdef _DMA1_Channel5
+  DMA1_Channel5 = (DMA_Channel_TypeDef *)  DMA1_Channel5_BASE;
+#endif /*_DMA1_Channel5 */
+
+#ifdef _DMA1_Channel6
+  DMA1_Channel6 = (DMA_Channel_TypeDef *)  DMA1_Channel6_BASE;
+#endif /*_DMA1_Channel6 */
+
+#ifdef _DMA1_Channel7
+  DMA1_Channel7 = (DMA_Channel_TypeDef *)  DMA1_Channel7_BASE;
+#endif /*_DMA1_Channel7 */
+
+#ifdef _DMA2_Channel1
+  DMA2_Channel1 = (DMA_Channel_TypeDef *)  DMA2_Channel1_BASE;
+#endif /*_DMA2_Channel1 */
+
+#ifdef _DMA2_Channel2
+  DMA2_Channel2 = (DMA_Channel_TypeDef *)  DMA2_Channel2_BASE;
+#endif /*_DMA2_Channel2 */
+
+#ifdef _DMA2_Channel3
+  DMA2_Channel3 = (DMA_Channel_TypeDef *)  DMA2_Channel3_BASE;
+#endif /*_DMA2_Channel3 */
+
+#ifdef _DMA2_Channel4
+  DMA2_Channel4 = (DMA_Channel_TypeDef *)  DMA2_Channel4_BASE;
+#endif /*_DMA2_Channel4 */
+
+#ifdef _DMA2_Channel5
+  DMA2_Channel5 = (DMA_Channel_TypeDef *)  DMA2_Channel5_BASE;
+#endif /*_DMA2_Channel5 */
+
+/************************************* EXTI ***********************************/
+#ifdef _EXTI
+  EXTI = (EXTI_TypeDef *)  EXTI_BASE;
+#endif /*_EXTI */
+
+/************************************* FLASH and Option Bytes *****************/
+#ifdef _FLASH
+  FLASH = (FLASH_TypeDef *)  FLASH_R_BASE;
+  OB = (OB_TypeDef *)        OB_BASE;
+#endif /*_FLASH */
+
+/************************************* FSMC ***********************************/
+#ifdef _FSMC
+  FSMC_Bank1 = (FSMC_Bank1_TypeDef *)    FSMC_Bank1_R_BASE;
+  FSMC_Bank1E = (FSMC_Bank1E_TypeDef *)  FSMC_Bank1E_R_BASE;  
+  FSMC_Bank2 = (FSMC_Bank2_TypeDef *)    FSMC_Bank2_R_BASE; 
+  FSMC_Bank3 = (FSMC_Bank3_TypeDef *)    FSMC_Bank3_R_BASE;
+  FSMC_Bank4 = (FSMC_Bank4_TypeDef *)    FSMC_Bank4_R_BASE;
+#endif /*_FSMC */
+
+/************************************* GPIO ***********************************/
+#ifdef _GPIOA
+  GPIOA = (GPIO_TypeDef *)  GPIOA_BASE;
+#endif /*_GPIOA */
+
+#ifdef _GPIOB
+  GPIOB = (GPIO_TypeDef *)  GPIOB_BASE;
+#endif /*_GPIOB */
+
+#ifdef _GPIOC
+  GPIOC = (GPIO_TypeDef *)  GPIOC_BASE;
+#endif /*_GPIOC */
+
+#ifdef _GPIOD
+  GPIOD = (GPIO_TypeDef *)  GPIOD_BASE;
+#endif /*_GPIOD */
+
+#ifdef _GPIOE
+  GPIOE = (GPIO_TypeDef *)  GPIOE_BASE;
+#endif /*_GPIOE */
+
+#ifdef _GPIOF
+  GPIOF = (GPIO_TypeDef *)  GPIOF_BASE;
+#endif /*_GPIOF */
+
+#ifdef _GPIOG
+  GPIOG = (GPIO_TypeDef *)  GPIOG_BASE;
+#endif /*_GPIOG */
+
+#ifdef _AFIO
+  AFIO = (AFIO_TypeDef *)  AFIO_BASE;
+#endif /*_AFIO */
+
+/************************************* I2C ************************************/
+#ifdef _I2C1
+  I2C1 = (I2C_TypeDef *)  I2C1_BASE;
+#endif /*_I2C1 */
+
+#ifdef _I2C2
+  I2C2 = (I2C_TypeDef *)  I2C2_BASE;
+#endif /*_I2C2 */
+
+/************************************* IWDG ***********************************/
+#ifdef _IWDG
+  IWDG = (IWDG_TypeDef *) IWDG_BASE;
+#endif /*_IWDG */
+
+/************************************* NVIC ***********************************/
+#ifdef _NVIC
+  NVIC = (NVIC_TypeDef *)  NVIC_BASE;
+  SCB = (SCB_TypeDef *)  SCB_BASE;
+#endif /*_NVIC */
+
+/************************************* PWR ************************************/
+#ifdef _PWR
+  PWR = (PWR_TypeDef *)  PWR_BASE;
+#endif /*_PWR */
+
+/************************************* RCC ************************************/
+#ifdef _RCC
+  RCC = (RCC_TypeDef *)  RCC_BASE;
+#endif /*_RCC */
+
+/************************************* RTC ************************************/
+#ifdef _RTC
+  RTC = (RTC_TypeDef *)  RTC_BASE;
+#endif /*_RTC */
+
+/************************************* SDIO ***********************************/
+#ifdef _SDIO
+  SDIO = (SDIO_TypeDef *)  SDIO_BASE;
+#endif /*_SDIO */
+
+/************************************* SPI ************************************/
+#ifdef _SPI1
+  SPI1 = (SPI_TypeDef *)  SPI1_BASE;
+#endif /*_SPI1 */
+
+#ifdef _SPI2
+  SPI2 = (SPI_TypeDef *)  SPI2_BASE;
+#endif /*_SPI2 */
+
+#ifdef _SPI3
+  SPI3 = (SPI_TypeDef *)  SPI3_BASE;
+#endif /*_SPI3 */
+
+/************************************* SysTick ********************************/
+#ifdef _SysTick
+  SysTick = (SysTick_TypeDef *)  SysTick_BASE;
+#endif /*_SysTick */
+
+/************************************* TIM ************************************/
+#ifdef _TIM1
+  TIM1 = (TIM_TypeDef *)  TIM1_BASE;
+#endif /*_TIM1 */
+
+#ifdef _TIM2
+  TIM2 = (TIM_TypeDef *)  TIM2_BASE;
+#endif /*_TIM2 */
+
+#ifdef _TIM3
+  TIM3 = (TIM_TypeDef *)  TIM3_BASE;
+#endif /*_TIM3 */
+
+#ifdef _TIM4
+  TIM4 = (TIM_TypeDef *)  TIM4_BASE;
+#endif /*_TIM4 */
+
+#ifdef _TIM5
+  TIM5 = (TIM_TypeDef *)  TIM5_BASE;
+#endif /*_TIM5 */
+
+#ifdef _TIM6
+  TIM6 = (TIM_TypeDef *)  TIM6_BASE;
+#endif /*_TIM6 */
+
+#ifdef _TIM7
+  TIM7 = (TIM_TypeDef *)  TIM7_BASE;
+#endif /*_TIM7 */
+
+#ifdef _TIM8
+  TIM8 = (TIM_TypeDef *)  TIM8_BASE;
+#endif /*_TIM8 */
+
+/************************************* USART **********************************/
+#ifdef _USART1
+  USART1 = (USART_TypeDef *) USART1_BASE;
+#endif /*_USART1 */
+
+#ifdef _USART2
+  USART2 = (USART_TypeDef *) USART2_BASE;
+#endif /*_USART2 */
+
+#ifdef _USART3
+  USART3 = (USART_TypeDef *) USART3_BASE;
+#endif /*_USART3 */
+
+#ifdef _UART4
+  UART4 = (USART_TypeDef *) UART4_BASE;
+#endif /*_UART4 */
+
+#ifdef _UART5
+  UART5 = (USART_TypeDef *) UART5_BASE;
+#endif /*_UART5 */
+
+/************************************* WWDG ***********************************/
+#ifdef _WWDG
+  WWDG = (WWDG_TypeDef *)  WWDG_BASE;
+#endif /*_WWDG */
+}
+#endif  /* DEBUG*/
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_nvic.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,751 +1,751 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_nvic.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the NVIC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_nvic.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : NVIC_DeInit
-* Description    : Deinitializes the NVIC peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_DeInit(void)
-{
-  u32 index = 0;
-  
-  NVIC-&gt;ICER[0] = 0xFFFFFFFF;
-  NVIC-&gt;ICER[1] = 0x0FFFFFFF;
-  NVIC-&gt;ICPR[0] = 0xFFFFFFFF;
-  NVIC-&gt;ICPR[1] = 0x0FFFFFFF;
-  
-  for(index = 0; index &lt; 0x0F; index++)
-  {
-     NVIC-&gt;IPR[index] = 0x00000000;
-  } 
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SCBDeInit
-* Description    : Deinitializes the SCB peripheral registers to their default 
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SCBDeInit(void)
-{
-  u32 index = 0x00;
-  
-  SCB-&gt;ICSR = 0x0A000000;
-  SCB-&gt;VTOR = 0x00000000;
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK;
-  SCB-&gt;SCR = 0x00000000;
-  SCB-&gt;CCR = 0x00000000;
-  for(index = 0; index &lt; 0x03; index++)
-  {
-     SCB-&gt;SHPR[index] = 0;
-  }
-  SCB-&gt;SHCSR = 0x00000000;
-  SCB-&gt;CFSR = 0xFFFFFFFF;
-  SCB-&gt;HFSR = 0xFFFFFFFF;
-  SCB-&gt;DFSR = 0xFFFFFFFF;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_PriorityGroupConfig
-* Description    : Configures the priority grouping: pre-emption priority
-*                  and subpriority.
-* Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
-*                    length. This parameter can be one of the following values:
-*                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
-*                         4 bits for subpriority
-*                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
-*                         3 bits for subpriority
-*                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
-*                         2 bits for subpriority
-*                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
-*                         1 bits for subpriority
-*                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
-*                         0 bits for subpriority
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
-  
-  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_Init
-* Description    : Initializes the NVIC peripheral according to the specified
-*                  parameters in the NVIC_InitStruct.
-* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
-*                    that contains the configuration information for the
-*                    specified NVIC peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
-{
-  u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
-  u32 tmppre = 0, tmpsub = 0x0F;
-
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct-&gt;NVIC_IRQChannelCmd));
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct-&gt;NVIC_IRQChannel));
-  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority));  
-  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority));
-    
-  if (NVIC_InitStruct-&gt;NVIC_IRQChannelCmd != DISABLE)
-  {
-    /* Compute the Corresponding IRQ Priority --------------------------------*/    
-    tmppriority = (0x700 - (SCB-&gt;AIRCR &amp; (u32)0x700))&gt;&gt; 0x08;
-    tmppre = (0x4 - tmppriority);
-    tmpsub = tmpsub &gt;&gt; tmppriority;
-    
-    tmppriority = (u32)NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority &lt;&lt; tmppre;
-    tmppriority |=  NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority &amp; tmpsub;
-
-    tmppriority = tmppriority &lt;&lt; 0x04;
-    tmppriority = ((u32)tmppriority) &lt;&lt; ((NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x03) * 0x08);
-    
-    tmpreg = NVIC-&gt;IPR[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x02)];
-    tmpmask = (u32)0xFF &lt;&lt; ((NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x03) * 0x08);
-    tmpreg &amp;= ~tmpmask;
-    tmppriority &amp;= tmpmask;  
-    tmpreg |= tmppriority;
-
-    NVIC-&gt;IPR[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x02)] = tmpreg;
-    
-    /* Enable the Selected IRQ Channels --------------------------------------*/
-    NVIC-&gt;ISER[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05)] =
-      (u32)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x1F);
-  }
-  else
-  {
-    /* Disable the Selected IRQ Channels -------------------------------------*/
-    NVIC-&gt;ICER[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05)] =
-      (u32)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x1F);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_StructInit
-* Description    : Fills each NVIC_InitStruct member with its default value.
-* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
-*                    will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
-{
-  /* NVIC_InitStruct members default value */
-  NVIC_InitStruct-&gt;NVIC_IRQChannel = 0x00;
-  NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority = 0x00;
-  NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority = 0x00;
-  NVIC_InitStruct-&gt;NVIC_IRQChannelCmd = DISABLE;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SETPRIMASK
-* Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SETPRIMASK(void)
-{
-  __SETPRIMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_RESETPRIMASK
-* Description    : Disables the PRIMASK priority.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_RESETPRIMASK(void)
-{
-  __RESETPRIMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SETFAULTMASK
-* Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SETFAULTMASK(void)
-{
-  __SETFAULTMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_RESETFAULTMASK
-* Description    : Disables the FAULTMASK priority.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_RESETFAULTMASK(void)
-{
-  __RESETFAULTMASK();
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_BASEPRICONFIG
-* Description    : The execution priority can be changed from 15 (lowest 
-                   configurable priority) to 1. Writing a zero  value will disable 
-*                  the mask of execution priority.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_BASEPRICONFIG(u32 NewPriority)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_BASE_PRI(NewPriority));
-  
-  __BASEPRICONFIG(NewPriority &lt;&lt; 0x04);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetBASEPRI
-* Description    : Returns the BASEPRI mask value.
-* Input          : None
-* Output         : None
-* Return         : BASEPRI register value
-*******************************************************************************/
-u32 NVIC_GetBASEPRI(void)
-{
-  return (__GetBASEPRI());
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetCurrentPendingIRQChannel
-* Description    : Returns the current pending IRQ channel identifier.
-* Input          : None
-* Output         : None
-* Return         : Pending IRQ Channel Identifier.
-*******************************************************************************/
-u16 NVIC_GetCurrentPendingIRQChannel(void)
-{
-  return ((u16)((SCB-&gt;ICSR &amp; (u32)0x003FF000) &gt;&gt; 0x0C));
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetIRQChannelPendingBitStatus
-* Description    : Checks whether the specified IRQ Channel pending bit is set
-*                  or not.
-* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
-* Output         : None
-* Return         : The new state of IRQ Channel pending bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
-{
-  ITStatus pendingirqstatus = RESET;
-  u32 tmp = 0x00;
-  
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  tmp = ((u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F));
-
-  if (((NVIC-&gt;ISPR[(NVIC_IRQChannel &gt;&gt; 0x05)]) &amp; tmp) == tmp)
-  {
-    pendingirqstatus = SET;
-  }
-  else
-  {
-    pendingirqstatus = RESET;
-  }
-  return pendingirqstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SetIRQChannelPendingBit
-* Description    : Sets the NVIC&#146;s interrupt pending bit.
-* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_ClearIRQChannelPendingBit
-* Description    : Clears the NVIC&#146;s interrupt pending bit.
-* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  NVIC-&gt;ICPR[(NVIC_IRQChannel &gt;&gt; 0x05)] = (u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetCurrentActiveHandler
-* Description    : Returns the current active Handler (IRQ Channel and
-*                  SystemHandler) identifier.
-* Input          : None
-* Output         : None
-* Return         : Active Handler Identifier.
-*******************************************************************************/
-u16 NVIC_GetCurrentActiveHandler(void)
-{
-  return ((u16)(SCB-&gt;ICSR &amp; (u32)0x3FF));
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetIRQChannelActiveBitStatus
-* Description    : Checks whether the specified IRQ Channel active bit is set
-*                  or not.
-* Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
-* Output         : None
-* Return         : The new state of IRQ Channel active bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
-{
-  ITStatus activeirqstatus = RESET;
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
-  
-  tmp = ((u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F));
-
-  if (((NVIC-&gt;IABR[(NVIC_IRQChannel &gt;&gt; 0x05)]) &amp; tmp) == tmp )
-  {
-    activeirqstatus = SET;
-  }
-  else
-  {
-    activeirqstatus = RESET;
-  }
-  return activeirqstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetCPUID
-* Description    : Returns the ID number, the version number and the implementation
-*                  details of the Cortex-M3 core.
-* Input          : None
-* Output         : None
-* Return         : CPU ID.
-*******************************************************************************/
-u32 NVIC_GetCPUID(void)
-{
-  return (SCB-&gt;CPUID);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SetVectorTable
-* Description    : Sets the vector table location and Offset.
-* Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
-*                    FLASH memory.
-*                    This parameter can be one of the following values:
-*                       - NVIC_VectTab_RAM
-*                       - NVIC_VectTab_FLASH
-*                  - Offset: Vector Table base offset field. 
-*                            This value must be a multiple of 0x100.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
-{ 
-  /* Check the parameters */
-  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
-  assert_param(IS_NVIC_OFFSET(Offset));  
-   
-  SCB-&gt;VTOR = NVIC_VectTab | (Offset &amp; (u32)0x1FFFFF80);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GenerateSystemReset
-* Description    : Generates a system reset.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_GenerateSystemReset(void)
-{
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GenerateCoreReset
-* Description    : Generates a Core (Core + NVIC) reset.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_GenerateCoreReset(void)
-{
-  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SystemLPConfig
-* Description    : Selects the condition for the system to enter low power mode.
-* Input          : - LowPowerMode: Specifies the new mode for the system to enter
-*                    low power mode.
-*                    This parameter can be one of the following values:
-*                       - NVIC_LP_SEVONPEND
-*                       - NVIC_LP_SLEEPDEEP
-*                       - NVIC_LP_SLEEPONEXIT
-*                  - NewState: new state of LP condition.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_NVIC_LP(LowPowerMode));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));  
-  
-  if (NewState != DISABLE)
-  {
-    SCB-&gt;SCR |= LowPowerMode;
-  }
-  else
-  {
-    SCB-&gt;SCR &amp;= (u32)(~(u32)LowPowerMode);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SystemHandlerConfig
-* Description    : Enables or disables the specified System Handlers.
-* Input          : - SystemHandler: specifies the system handler to be enabled
-*                    or disabled.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                  - NewState: new state of  specified System Handlers.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
-{
-  u32 tmpreg = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-  
-  tmpreg =  (u32)0x01 &lt;&lt; (SystemHandler &amp; (u32)0x1F);
-
-  if (NewState != DISABLE)
-  {
-    SCB-&gt;SHCSR |= tmpreg;
-  }
-  else
-  {
-    SCB-&gt;SHCSR &amp;= ~tmpreg;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SystemHandlerPriorityConfig
-* Description    : Configures the specified System Handlers priority.
-* Input          : - SystemHandler: specifies the system handler to be
-*                    enabled or disabled.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                       - SystemHandler_SVCall
-*                       - SystemHandler_DebugMonitor
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-*                  - SystemHandlerPreemptionPriority: new priority group of the
-*                    specified system handlers.
-*                  - SystemHandlerSubPriority: new sub priority of the specified
-*                    system handlers.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
-                                      u8 SystemHandlerSubPriority)
-{
-  u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
-  u32 tmppriority = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
-  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
-  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
-    
-  tmppriority = (0x700 - (SCB-&gt;AIRCR &amp; (u32)0x700))&gt;&gt; 0x08;
-  tmp1 = (0x4 - tmppriority);
-  tmp2 = tmp2 &gt;&gt; tmppriority;
-    
-  tmppriority = (u32)SystemHandlerPreemptionPriority &lt;&lt; tmp1;
-  tmppriority |=  SystemHandlerSubPriority &amp; tmp2;
-
-  tmppriority = tmppriority &lt;&lt; 0x04;
-  tmp1 = SystemHandler &amp; (u32)0xC0;
-  tmp1 = tmp1 &gt;&gt; 0x06; 
-  tmp2 = (SystemHandler &gt;&gt; 0x08) &amp; (u32)0x03;
-  tmppriority = tmppriority &lt;&lt; (tmp2 * 0x08);
-  handlermask = (u32)0xFF &lt;&lt; (tmp2 * 0x08);
-  
-  SCB-&gt;SHPR[tmp1] &amp;= ~handlermask;
-  SCB-&gt;SHPR[tmp1] |= tmppriority;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetSystemHandlerPendingBitStatus
-* Description    : Checks whether the specified System handlers pending bit is
-*                  set or not.
-* Input          : - SystemHandler: specifies the system handler pending bit to
-*                    check.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_SVCall
-* Output         : None
-* Return         : The new state of System Handler pending bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
-{
-  ITStatus bitstatus  = RESET;
-  u32 tmp = 0x00, tmppos = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
-  
-  tmppos = (SystemHandler &gt;&gt; 0x0A);
-  tmppos &amp;= (u32)0x0F;
-
-  tmppos = (u32)0x01 &lt;&lt; tmppos;
-
-  tmp = SCB-&gt;SHCSR &amp; tmppos;
-
-  if (tmp == tmppos)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_SetSystemHandlerPendingBit
-* Description    : Sets System Handler pending bit.
-* Input          : - SystemHandler: specifies the system handler pending bit
-*                    to be set.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_NMI
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
-{
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
-  
-  /* Get the System Handler pending bit position */
-  tmp = SystemHandler &amp; (u32)0x1F;
-  /* Set the corresponding System Handler pending bit */
-  SCB-&gt;ICSR |= ((u32)0x01 &lt;&lt; tmp);
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_ClearSystemHandlerPendingBit
-* Description    : Clears System Handler pending bit.
-* Input          : - SystemHandler: specifies the system handler pending bit to
-*                    be clear.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
-{
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
-  
-  /* Get the System Handler pending bit position */
-  tmp = SystemHandler &amp; (u32)0x1F;
-  /* Clear the corresponding System Handler pending bit */
-  SCB-&gt;ICSR |= ((u32)0x01 &lt;&lt; (tmp - 0x01));
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetSystemHandlerActiveBitStatus
-* Description    : Checks whether the specified System handlers active bit is
-*                  set or not.
-* Input          : - SystemHandler: specifies the system handler active bit to
-*                    check.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                       - SystemHandler_SVCall
-*                       - SystemHandler_DebugMonitor
-*                       - SystemHandler_PSV
-*                       - SystemHandler_SysTick
-* Output         : None
-* Return         : The new state of System Handler active bit(SET or RESET).
-*******************************************************************************/
-ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
-{
-  ITStatus bitstatus  = RESET;
-
-  u32 tmp = 0x00, tmppos = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
-  
-  tmppos = (SystemHandler &gt;&gt; 0x0E) &amp; (u32)0x0F;
-
-  tmppos = (u32)0x01 &lt;&lt; tmppos;
-
-  tmp = SCB-&gt;SHCSR &amp; tmppos;
-
-  if (tmp == tmppos)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetFaultHandlerSources
-* Description    : Returns the system fault handlers sources.
-* Input          : - SystemHandler: specifies the system handler to get its fault
-*                    sources.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_HardFault
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-*                       - SystemHandler_UsageFault
-*                       - SystemHandler_DebugMonitor
-* Output         : None
-* Return         : Source of the fault handler.
-*******************************************************************************/
-u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
-{
-  u32 faultsources = 0x00;
-  u32 tmpreg = 0x00, tmppos = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
-  
-  tmpreg = (SystemHandler &gt;&gt; 0x12) &amp; (u32)0x03;
-  tmppos = (SystemHandler &gt;&gt; 0x14) &amp; (u32)0x03;
-
-  if (tmpreg == 0x00)
-  {
-    faultsources = SCB-&gt;HFSR;
-  }
-  else if (tmpreg == 0x01)
-  {
-    faultsources = SCB-&gt;CFSR &gt;&gt; (tmppos * 0x08);
-    if (tmppos != 0x02)
-    {
-      faultsources &amp;= (u32)0x0F;
-    }
-    else
-    {
-      faultsources &amp;= (u32)0xFF;
-    }
-  }
-  else
-  {
-    faultsources = SCB-&gt;DFSR;
-  }
-  return faultsources;
-}
-
-/*******************************************************************************
-* Function Name  : NVIC_GetFaultAddress
-* Description    : Returns the address of the location that generated a fault
-*                  handler.
-* Input          : - SystemHandler: specifies the system handler to get its
-*                    fault address.
-*                    This parameter can be one of the following values:
-*                       - SystemHandler_MemoryManage
-*                       - SystemHandler_BusFault
-* Output         : None
-* Return         : Fault address.
-*******************************************************************************/
-u32 NVIC_GetFaultAddress(u32 SystemHandler)
-{
-  u32 faultaddress = 0x00;
-  u32 tmp = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
-  
-  tmp = (SystemHandler &gt;&gt; 0x16) &amp; (u32)0x01;
-
-  if (tmp == 0x00)
-  {
-    faultaddress = SCB-&gt;MMFAR;
-  }
-  else
-  {
-    faultaddress = SCB-&gt;BFAR;
-  }
-  return faultaddress;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_nvic.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the NVIC firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_nvic.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : NVIC_DeInit
+* Description    : Deinitializes the NVIC peripheral registers to their default
+*                  reset values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_DeInit(void)
+{
+  u32 index = 0;
+  
+  NVIC-&gt;ICER[0] = 0xFFFFFFFF;
+  NVIC-&gt;ICER[1] = 0x0FFFFFFF;
+  NVIC-&gt;ICPR[0] = 0xFFFFFFFF;
+  NVIC-&gt;ICPR[1] = 0x0FFFFFFF;
+  
+  for(index = 0; index &lt; 0x0F; index++)
+  {
+     NVIC-&gt;IPR[index] = 0x00000000;
+  } 
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SCBDeInit
+* Description    : Deinitializes the SCB peripheral registers to their default 
+*                  reset values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SCBDeInit(void)
+{
+  u32 index = 0x00;
+  
+  SCB-&gt;ICSR = 0x0A000000;
+  SCB-&gt;VTOR = 0x00000000;
+  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK;
+  SCB-&gt;SCR = 0x00000000;
+  SCB-&gt;CCR = 0x00000000;
+  for(index = 0; index &lt; 0x03; index++)
+  {
+     SCB-&gt;SHPR[index] = 0;
+  }
+  SCB-&gt;SHCSR = 0x00000000;
+  SCB-&gt;CFSR = 0xFFFFFFFF;
+  SCB-&gt;HFSR = 0xFFFFFFFF;
+  SCB-&gt;DFSR = 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_PriorityGroupConfig
+* Description    : Configures the priority grouping: pre-emption priority
+*                  and subpriority.
+* Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
+*                    length. This parameter can be one of the following values:
+*                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
+*                         4 bits for subpriority
+*                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
+*                         3 bits for subpriority
+*                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
+*                         2 bits for subpriority
+*                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
+*                         1 bits for subpriority
+*                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
+*                         0 bits for subpriority
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
+  
+  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
+  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_Init
+* Description    : Initializes the NVIC peripheral according to the specified
+*                  parameters in the NVIC_InitStruct.
+* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
+*                    that contains the configuration information for the
+*                    specified NVIC peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
+{
+  u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
+  u32 tmppre = 0, tmpsub = 0x0F;
+
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct-&gt;NVIC_IRQChannelCmd));
+  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct-&gt;NVIC_IRQChannel));
+  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority));  
+  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority));
+    
+  if (NVIC_InitStruct-&gt;NVIC_IRQChannelCmd != DISABLE)
+  {
+    /* Compute the Corresponding IRQ Priority --------------------------------*/    
+    tmppriority = (0x700 - (SCB-&gt;AIRCR &amp; (u32)0x700))&gt;&gt; 0x08;
+    tmppre = (0x4 - tmppriority);
+    tmpsub = tmpsub &gt;&gt; tmppriority;
+    
+    tmppriority = (u32)NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority &lt;&lt; tmppre;
+    tmppriority |=  NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority &amp; tmpsub;
+
+    tmppriority = tmppriority &lt;&lt; 0x04;
+    tmppriority = ((u32)tmppriority) &lt;&lt; ((NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x03) * 0x08);
+    
+    tmpreg = NVIC-&gt;IPR[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x02)];
+    tmpmask = (u32)0xFF &lt;&lt; ((NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x03) * 0x08);
+    tmpreg &amp;= ~tmpmask;
+    tmppriority &amp;= tmpmask;  
+    tmpreg |= tmppriority;
+
+    NVIC-&gt;IPR[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x02)] = tmpreg;
+    
+    /* Enable the Selected IRQ Channels --------------------------------------*/
+    NVIC-&gt;ISER[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05)] =
+      (u32)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x1F);
+  }
+  else
+  {
+    /* Disable the Selected IRQ Channels -------------------------------------*/
+    NVIC-&gt;ICER[(NVIC_InitStruct-&gt;NVIC_IRQChannel &gt;&gt; 0x05)] =
+      (u32)0x01 &lt;&lt; (NVIC_InitStruct-&gt;NVIC_IRQChannel &amp; (u8)0x1F);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_StructInit
+* Description    : Fills each NVIC_InitStruct member with its default value.
+* Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
+*                    will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
+{
+  /* NVIC_InitStruct members default value */
+  NVIC_InitStruct-&gt;NVIC_IRQChannel = 0x00;
+  NVIC_InitStruct-&gt;NVIC_IRQChannelPreemptionPriority = 0x00;
+  NVIC_InitStruct-&gt;NVIC_IRQChannelSubPriority = 0x00;
+  NVIC_InitStruct-&gt;NVIC_IRQChannelCmd = DISABLE;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SETPRIMASK
+* Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SETPRIMASK(void)
+{
+  __SETPRIMASK();
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_RESETPRIMASK
+* Description    : Disables the PRIMASK priority.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_RESETPRIMASK(void)
+{
+  __RESETPRIMASK();
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SETFAULTMASK
+* Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SETFAULTMASK(void)
+{
+  __SETFAULTMASK();
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_RESETFAULTMASK
+* Description    : Disables the FAULTMASK priority.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_RESETFAULTMASK(void)
+{
+  __RESETFAULTMASK();
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_BASEPRICONFIG
+* Description    : The execution priority can be changed from 15 (lowest 
+                   configurable priority) to 1. Writing a zero  value will disable 
+*                  the mask of execution priority.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_BASEPRICONFIG(u32 NewPriority)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_BASE_PRI(NewPriority));
+  
+  __BASEPRICONFIG(NewPriority &lt;&lt; 0x04);
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetBASEPRI
+* Description    : Returns the BASEPRI mask value.
+* Input          : None
+* Output         : None
+* Return         : BASEPRI register value
+*******************************************************************************/
+u32 NVIC_GetBASEPRI(void)
+{
+  return (__GetBASEPRI());
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetCurrentPendingIRQChannel
+* Description    : Returns the current pending IRQ channel identifier.
+* Input          : None
+* Output         : None
+* Return         : Pending IRQ Channel Identifier.
+*******************************************************************************/
+u16 NVIC_GetCurrentPendingIRQChannel(void)
+{
+  return ((u16)((SCB-&gt;ICSR &amp; (u32)0x003FF000) &gt;&gt; 0x0C));
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetIRQChannelPendingBitStatus
+* Description    : Checks whether the specified IRQ Channel pending bit is set
+*                  or not.
+* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
+* Output         : None
+* Return         : The new state of IRQ Channel pending bit(SET or RESET).
+*******************************************************************************/
+ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
+{
+  ITStatus pendingirqstatus = RESET;
+  u32 tmp = 0x00;
+  
+  /* Check the parameters */
+  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
+  
+  tmp = ((u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F));
+
+  if (((NVIC-&gt;ISPR[(NVIC_IRQChannel &gt;&gt; 0x05)]) &amp; tmp) == tmp)
+  {
+    pendingirqstatus = SET;
+  }
+  else
+  {
+    pendingirqstatus = RESET;
+  }
+  return pendingirqstatus;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SetIRQChannelPendingBit
+* Description    : Sets the NVIC's interrupt pending bit.
+* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
+  
+  *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_ClearIRQChannelPendingBit
+* Description    : Clears the NVIC's interrupt pending bit.
+* Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
+  
+  NVIC-&gt;ICPR[(NVIC_IRQChannel &gt;&gt; 0x05)] = (u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F);
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetCurrentActiveHandler
+* Description    : Returns the current active Handler (IRQ Channel and
+*                  SystemHandler) identifier.
+* Input          : None
+* Output         : None
+* Return         : Active Handler Identifier.
+*******************************************************************************/
+u16 NVIC_GetCurrentActiveHandler(void)
+{
+  return ((u16)(SCB-&gt;ICSR &amp; (u32)0x3FF));
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetIRQChannelActiveBitStatus
+* Description    : Checks whether the specified IRQ Channel active bit is set
+*                  or not.
+* Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
+* Output         : None
+* Return         : The new state of IRQ Channel active bit(SET or RESET).
+*******************************************************************************/
+ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
+{
+  ITStatus activeirqstatus = RESET;
+  u32 tmp = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
+  
+  tmp = ((u32)0x01 &lt;&lt; (NVIC_IRQChannel &amp; (u32)0x1F));
+
+  if (((NVIC-&gt;IABR[(NVIC_IRQChannel &gt;&gt; 0x05)]) &amp; tmp) == tmp )
+  {
+    activeirqstatus = SET;
+  }
+  else
+  {
+    activeirqstatus = RESET;
+  }
+  return activeirqstatus;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetCPUID
+* Description    : Returns the ID number, the version number and the implementation
+*                  details of the Cortex-M3 core.
+* Input          : None
+* Output         : None
+* Return         : CPU ID.
+*******************************************************************************/
+u32 NVIC_GetCPUID(void)
+{
+  return (SCB-&gt;CPUID);
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SetVectorTable
+* Description    : Sets the vector table location and Offset.
+* Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
+*                    FLASH memory.
+*                    This parameter can be one of the following values:
+*                       - NVIC_VectTab_RAM
+*                       - NVIC_VectTab_FLASH
+*                  - Offset: Vector Table base offset field. 
+*                            This value must be a multiple of 0x100.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
+{ 
+  /* Check the parameters */
+  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
+  assert_param(IS_NVIC_OFFSET(Offset));  
+   
+  SCB-&gt;VTOR = NVIC_VectTab | (Offset &amp; (u32)0x1FFFFF80);
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GenerateSystemReset
+* Description    : Generates a system reset.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_GenerateSystemReset(void)
+{
+  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GenerateCoreReset
+* Description    : Generates a Core (Core + NVIC) reset.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_GenerateCoreReset(void)
+{
+  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SystemLPConfig
+* Description    : Selects the condition for the system to enter low power mode.
+* Input          : - LowPowerMode: Specifies the new mode for the system to enter
+*                    low power mode.
+*                    This parameter can be one of the following values:
+*                       - NVIC_LP_SEVONPEND
+*                       - NVIC_LP_SLEEPDEEP
+*                       - NVIC_LP_SLEEPONEXIT
+*                  - NewState: new state of LP condition.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_NVIC_LP(LowPowerMode));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));  
+  
+  if (NewState != DISABLE)
+  {
+    SCB-&gt;SCR |= LowPowerMode;
+  }
+  else
+  {
+    SCB-&gt;SCR &amp;= (u32)(~(u32)LowPowerMode);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SystemHandlerConfig
+* Description    : Enables or disables the specified System Handlers.
+* Input          : - SystemHandler: specifies the system handler to be enabled
+*                    or disabled.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_MemoryManage
+*                       - SystemHandler_BusFault
+*                       - SystemHandler_UsageFault
+*                  - NewState: new state of  specified System Handlers.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
+{
+  u32 tmpreg = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
+  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
+  
+  tmpreg =  (u32)0x01 &lt;&lt; (SystemHandler &amp; (u32)0x1F);
+
+  if (NewState != DISABLE)
+  {
+    SCB-&gt;SHCSR |= tmpreg;
+  }
+  else
+  {
+    SCB-&gt;SHCSR &amp;= ~tmpreg;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SystemHandlerPriorityConfig
+* Description    : Configures the specified System Handlers priority.
+* Input          : - SystemHandler: specifies the system handler to be
+*                    enabled or disabled.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_MemoryManage
+*                       - SystemHandler_BusFault
+*                       - SystemHandler_UsageFault
+*                       - SystemHandler_SVCall
+*                       - SystemHandler_DebugMonitor
+*                       - SystemHandler_PSV
+*                       - SystemHandler_SysTick
+*                  - SystemHandlerPreemptionPriority: new priority group of the
+*                    specified system handlers.
+*                  - SystemHandlerSubPriority: new sub priority of the specified
+*                    system handlers.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
+                                      u8 SystemHandlerSubPriority)
+{
+  u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
+  u32 tmppriority = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
+  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
+  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
+    
+  tmppriority = (0x700 - (SCB-&gt;AIRCR &amp; (u32)0x700))&gt;&gt; 0x08;
+  tmp1 = (0x4 - tmppriority);
+  tmp2 = tmp2 &gt;&gt; tmppriority;
+    
+  tmppriority = (u32)SystemHandlerPreemptionPriority &lt;&lt; tmp1;
+  tmppriority |=  SystemHandlerSubPriority &amp; tmp2;
+
+  tmppriority = tmppriority &lt;&lt; 0x04;
+  tmp1 = SystemHandler &amp; (u32)0xC0;
+  tmp1 = tmp1 &gt;&gt; 0x06; 
+  tmp2 = (SystemHandler &gt;&gt; 0x08) &amp; (u32)0x03;
+  tmppriority = tmppriority &lt;&lt; (tmp2 * 0x08);
+  handlermask = (u32)0xFF &lt;&lt; (tmp2 * 0x08);
+  
+  SCB-&gt;SHPR[tmp1] &amp;= ~handlermask;
+  SCB-&gt;SHPR[tmp1] |= tmppriority;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetSystemHandlerPendingBitStatus
+* Description    : Checks whether the specified System handlers pending bit is
+*                  set or not.
+* Input          : - SystemHandler: specifies the system handler pending bit to
+*                    check.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_MemoryManage
+*                       - SystemHandler_BusFault
+*                       - SystemHandler_SVCall
+* Output         : None
+* Return         : The new state of System Handler pending bit(SET or RESET).
+*******************************************************************************/
+ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
+{
+  ITStatus bitstatus  = RESET;
+  u32 tmp = 0x00, tmppos = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
+  
+  tmppos = (SystemHandler &gt;&gt; 0x0A);
+  tmppos &amp;= (u32)0x0F;
+
+  tmppos = (u32)0x01 &lt;&lt; tmppos;
+
+  tmp = SCB-&gt;SHCSR &amp; tmppos;
+
+  if (tmp == tmppos)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_SetSystemHandlerPendingBit
+* Description    : Sets System Handler pending bit.
+* Input          : - SystemHandler: specifies the system handler pending bit
+*                    to be set.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_NMI
+*                       - SystemHandler_PSV
+*                       - SystemHandler_SysTick
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
+{
+  u32 tmp = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
+  
+  /* Get the System Handler pending bit position */
+  tmp = SystemHandler &amp; (u32)0x1F;
+  /* Set the corresponding System Handler pending bit */
+  SCB-&gt;ICSR |= ((u32)0x01 &lt;&lt; tmp);
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_ClearSystemHandlerPendingBit
+* Description    : Clears System Handler pending bit.
+* Input          : - SystemHandler: specifies the system handler pending bit to
+*                    be clear.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_PSV
+*                       - SystemHandler_SysTick
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
+{
+  u32 tmp = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
+  
+  /* Get the System Handler pending bit position */
+  tmp = SystemHandler &amp; (u32)0x1F;
+  /* Clear the corresponding System Handler pending bit */
+  SCB-&gt;ICSR |= ((u32)0x01 &lt;&lt; (tmp - 0x01));
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetSystemHandlerActiveBitStatus
+* Description    : Checks whether the specified System handlers active bit is
+*                  set or not.
+* Input          : - SystemHandler: specifies the system handler active bit to
+*                    check.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_MemoryManage
+*                       - SystemHandler_BusFault
+*                       - SystemHandler_UsageFault
+*                       - SystemHandler_SVCall
+*                       - SystemHandler_DebugMonitor
+*                       - SystemHandler_PSV
+*                       - SystemHandler_SysTick
+* Output         : None
+* Return         : The new state of System Handler active bit(SET or RESET).
+*******************************************************************************/
+ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
+{
+  ITStatus bitstatus  = RESET;
+
+  u32 tmp = 0x00, tmppos = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
+  
+  tmppos = (SystemHandler &gt;&gt; 0x0E) &amp; (u32)0x0F;
+
+  tmppos = (u32)0x01 &lt;&lt; tmppos;
+
+  tmp = SCB-&gt;SHCSR &amp; tmppos;
+
+  if (tmp == tmppos)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetFaultHandlerSources
+* Description    : Returns the system fault handlers sources.
+* Input          : - SystemHandler: specifies the system handler to get its fault
+*                    sources.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_HardFault
+*                       - SystemHandler_MemoryManage
+*                       - SystemHandler_BusFault
+*                       - SystemHandler_UsageFault
+*                       - SystemHandler_DebugMonitor
+* Output         : None
+* Return         : Source of the fault handler.
+*******************************************************************************/
+u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
+{
+  u32 faultsources = 0x00;
+  u32 tmpreg = 0x00, tmppos = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
+  
+  tmpreg = (SystemHandler &gt;&gt; 0x12) &amp; (u32)0x03;
+  tmppos = (SystemHandler &gt;&gt; 0x14) &amp; (u32)0x03;
+
+  if (tmpreg == 0x00)
+  {
+    faultsources = SCB-&gt;HFSR;
+  }
+  else if (tmpreg == 0x01)
+  {
+    faultsources = SCB-&gt;CFSR &gt;&gt; (tmppos * 0x08);
+    if (tmppos != 0x02)
+    {
+      faultsources &amp;= (u32)0x0F;
+    }
+    else
+    {
+      faultsources &amp;= (u32)0xFF;
+    }
+  }
+  else
+  {
+    faultsources = SCB-&gt;DFSR;
+  }
+  return faultsources;
+}
+
+/*******************************************************************************
+* Function Name  : NVIC_GetFaultAddress
+* Description    : Returns the address of the location that generated a fault
+*                  handler.
+* Input          : - SystemHandler: specifies the system handler to get its
+*                    fault address.
+*                    This parameter can be one of the following values:
+*                       - SystemHandler_MemoryManage
+*                       - SystemHandler_BusFault
+* Output         : None
+* Return         : Fault address.
+*******************************************************************************/
+u32 NVIC_GetFaultAddress(u32 SystemHandler)
+{
+  u32 faultaddress = 0x00;
+  u32 tmp = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
+  
+  tmp = (SystemHandler &gt;&gt; 0x16) &amp; (u32)0x01;
+
+  if (tmp == 0x00)
+  {
+    faultaddress = SCB-&gt;MMFAR;
+  }
+  else
+  {
+    faultaddress = SCB-&gt;BFAR;
+  }
+  return faultaddress;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_pwr.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,280 +1,280 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_pwr.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the PWR firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_pwr.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* --------- PWR registers bit address in the alias region ---------- */
-#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-/* Alias word address of DBP bit */
-#define CR_OFFSET                (PWR_OFFSET + 0x00)
-#define DBP_BitNumber            0x08
-#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
-
-/* Alias word address of PVDE bit */
-#define PVDE_BitNumber           0x04
-#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
-
-/* --- CSR Register ---*/
-/* Alias word address of EWUP bit */
-#define CSR_OFFSET               (PWR_OFFSET + 0x04)
-#define EWUP_BitNumber           0x08
-#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
-
-/* ------------------ PWR registers bit mask ------------------------ */
-/* CR register bit mask */
-#define CR_PDDS_Set              ((u32)0x00000002)
-#define CR_DS_Mask               ((u32)0xFFFFFFFC)
-#define CR_CWUF_Set              ((u32)0x00000004)
-#define CR_PLS_Mask              ((u32)0xFFFFFF1F)
-
-/* --------- Cortex System Control register bit mask ---------------- */
-/* Cortex System Control register address */
-#define SCB_SysCtrl              ((u32)0xE000ED10)
-/* SLEEPDEEP bit mask */
-#define SysCtrl_SLEEPDEEP_Set    ((u32)0x00000004)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : PWR_DeInit
-* Description    : Deinitializes the PWR peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_DeInit(void)
-{
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : PWR_BackupAccessCmd
-* Description    : Enables or disables access to the RTC and backup registers.
-* Input          : - NewState: new state of the access to the RTC and backup
-*                    registers. This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_BackupAccessCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_DBP_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_PVDCmd
-* Description    : Enables or disables the Power Voltage Detector(PVD).
-* Input          : - NewState: new state of the PVD.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_PVDCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_PVDE_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_PVDLevelConfig
-* Description    : Configures the voltage threshold detected by the Power Voltage
-*                  Detector(PVD).
-* Input          : - PWR_PVDLevel: specifies the PVD detection level
-*                    This parameter can be one of the following values:
-*                       - PWR_PVDLevel_2V2: PVD detection level set to 2.2V
-*                       - PWR_PVDLevel_2V3: PVD detection level set to 2.3V
-*                       - PWR_PVDLevel_2V4: PVD detection level set to 2.4V
-*                       - PWR_PVDLevel_2V5: PVD detection level set to 2.5V
-*                       - PWR_PVDLevel_2V6: PVD detection level set to 2.6V
-*                       - PWR_PVDLevel_2V7: PVD detection level set to 2.7V
-*                       - PWR_PVDLevel_2V8: PVD detection level set to 2.8V
-*                       - PWR_PVDLevel_2V9: PVD detection level set to 2.9V
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_PVDLevelConfig(u32 PWR_PVDLevel)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
-
-  tmpreg = PWR-&gt;CR;
-
-  /* Clear PLS[7:5] bits */
-  tmpreg &amp;= CR_PLS_Mask;
-
-  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
-  tmpreg |= PWR_PVDLevel;
-
-  /* Store the new value */
-  PWR-&gt;CR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_WakeUpPinCmd
-* Description    : Enables or disables the WakeUp Pin functionality.
-* Input          : - NewState: new state of the WakeUp Pin functionality.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_WakeUpPinCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CSR_EWUP_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_EnterSTOPMode
-* Description    : Enters STOP mode.
-* Input          : - PWR_Regulator: specifies the regulator state in STOP mode.
-*                    This parameter can be one of the following values:
-*                       - PWR_Regulator_ON: STOP mode with regulator ON
-*                       - PWR_Regulator_LowPower: STOP mode with
-*                         regulator in low power mode
-*                  - PWR_STOPEntry: specifies if STOP mode in entered with WFI or 
-*                    WFE instruction.
-*                    This parameter can be one of the following values:
-*                       - PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
-*                       - PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
-  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
-  
-  /* Select the regulator state in STOP mode ---------------------------------*/
-  tmpreg = PWR-&gt;CR;
-
-  /* Clear PDDS and LPDS bits */
-  tmpreg &amp;= CR_DS_Mask;
-
-  /* Set LPDS bit according to PWR_Regulator value */
-  tmpreg |= PWR_Regulator;
-
-  /* Store the new value */
-  PWR-&gt;CR = tmpreg;
-
-  /* Set SLEEPDEEP bit of Cortex System Control Register */
-  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
-  
-  /* Select STOP mode entry --------------------------------------------------*/
-  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
-  {   
-    /* Request Wait For Interrupt */
-    __WFI();
-  }
-  else
-  {
-    /* Request Wait For Event */
-    __WFE();
-  }
-}
-
-/*******************************************************************************
-* Function Name  : PWR_EnterSTANDBYMode
-* Description    : Enters STANDBY mode.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_EnterSTANDBYMode(void)
-{
-  /* Clear Wake-up flag */
-  PWR-&gt;CR |= CR_CWUF_Set;
-
-  /* Select STANDBY mode */
-  PWR-&gt;CR |= CR_PDDS_Set;
-
-  /* Set SLEEPDEEP bit of Cortex System Control Register */
-  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
-
-  /* Request Wait For Interrupt */
-  __WFI();
-}
-
-/*******************************************************************************
-* Function Name  : PWR_GetFlagStatus
-* Description    : Checks whether the specified PWR flag is set or not.
-* Input          : - PWR_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - PWR_FLAG_WU: Wake Up flag
-*                       - PWR_FLAG_SB: StandBy flag
-*                       - PWR_FLAG_PVDO: PVD Output
-* Output         : None
-* Return         : The new state of PWR_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus PWR_GetFlagStatus(u32 PWR_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
-  
-  if ((PWR-&gt;CSR &amp; PWR_FLAG) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : PWR_ClearFlag
-* Description    : Clears the PWR's pending flags.
-* Input          : - PWR_FLAG: specifies the flag to clear.
-*                    This parameter can be one of the following values:
-*                       - PWR_FLAG_WU: Wake Up flag
-*                       - PWR_FLAG_SB: StandBy flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void PWR_ClearFlag(u32 PWR_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
-         
-  PWR-&gt;CR |=  PWR_FLAG &lt;&lt; 2;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_pwr.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the PWR firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_pwr.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* --------- PWR registers bit address in the alias region ---------- */
+#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+/* Alias word address of DBP bit */
+#define CR_OFFSET                (PWR_OFFSET + 0x00)
+#define DBP_BitNumber            0x08
+#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
+
+/* Alias word address of PVDE bit */
+#define PVDE_BitNumber           0x04
+#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
+
+/* --- CSR Register ---*/
+/* Alias word address of EWUP bit */
+#define CSR_OFFSET               (PWR_OFFSET + 0x04)
+#define EWUP_BitNumber           0x08
+#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
+
+/* ------------------ PWR registers bit mask ------------------------ */
+/* CR register bit mask */
+#define CR_PDDS_Set              ((u32)0x00000002)
+#define CR_DS_Mask               ((u32)0xFFFFFFFC)
+#define CR_CWUF_Set              ((u32)0x00000004)
+#define CR_PLS_Mask              ((u32)0xFFFFFF1F)
+
+/* --------- Cortex System Control register bit mask ---------------- */
+/* Cortex System Control register address */
+#define SCB_SysCtrl              ((u32)0xE000ED10)
+/* SLEEPDEEP bit mask */
+#define SysCtrl_SLEEPDEEP_Set    ((u32)0x00000004)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : PWR_DeInit
+* Description    : Deinitializes the PWR peripheral registers to their default
+*                  reset values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
+}
+
+/*******************************************************************************
+* Function Name  : PWR_BackupAccessCmd
+* Description    : Enables or disables access to the RTC and backup registers.
+* Input          : - NewState: new state of the access to the RTC and backup
+*                    registers. This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_BackupAccessCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CR_DBP_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : PWR_PVDCmd
+* Description    : Enables or disables the Power Voltage Detector(PVD).
+* Input          : - NewState: new state of the PVD.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_PVDCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CR_PVDE_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : PWR_PVDLevelConfig
+* Description    : Configures the voltage threshold detected by the Power Voltage
+*                  Detector(PVD).
+* Input          : - PWR_PVDLevel: specifies the PVD detection level
+*                    This parameter can be one of the following values:
+*                       - PWR_PVDLevel_2V2: PVD detection level set to 2.2V
+*                       - PWR_PVDLevel_2V3: PVD detection level set to 2.3V
+*                       - PWR_PVDLevel_2V4: PVD detection level set to 2.4V
+*                       - PWR_PVDLevel_2V5: PVD detection level set to 2.5V
+*                       - PWR_PVDLevel_2V6: PVD detection level set to 2.6V
+*                       - PWR_PVDLevel_2V7: PVD detection level set to 2.7V
+*                       - PWR_PVDLevel_2V8: PVD detection level set to 2.8V
+*                       - PWR_PVDLevel_2V9: PVD detection level set to 2.9V
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_PVDLevelConfig(u32 PWR_PVDLevel)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
+
+  tmpreg = PWR-&gt;CR;
+
+  /* Clear PLS[7:5] bits */
+  tmpreg &amp;= CR_PLS_Mask;
+
+  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
+  tmpreg |= PWR_PVDLevel;
+
+  /* Store the new value */
+  PWR-&gt;CR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : PWR_WakeUpPinCmd
+* Description    : Enables or disables the WakeUp Pin functionality.
+* Input          : - NewState: new state of the WakeUp Pin functionality.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_WakeUpPinCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CSR_EWUP_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : PWR_EnterSTOPMode
+* Description    : Enters STOP mode.
+* Input          : - PWR_Regulator: specifies the regulator state in STOP mode.
+*                    This parameter can be one of the following values:
+*                       - PWR_Regulator_ON: STOP mode with regulator ON
+*                       - PWR_Regulator_LowPower: STOP mode with
+*                         regulator in low power mode
+*                  - PWR_STOPEntry: specifies if STOP mode in entered with WFI or 
+*                    WFE instruction.
+*                    This parameter can be one of the following values:
+*                       - PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
+*                       - PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
+  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
+  
+  /* Select the regulator state in STOP mode ---------------------------------*/
+  tmpreg = PWR-&gt;CR;
+
+  /* Clear PDDS and LPDS bits */
+  tmpreg &amp;= CR_DS_Mask;
+
+  /* Set LPDS bit according to PWR_Regulator value */
+  tmpreg |= PWR_Regulator;
+
+  /* Store the new value */
+  PWR-&gt;CR = tmpreg;
+
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
+  
+  /* Select STOP mode entry --------------------------------------------------*/
+  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
+  {   
+    /* Request Wait For Interrupt */
+    __WFI();
+  }
+  else
+  {
+    /* Request Wait For Event */
+    __WFE();
+  }
+}
+
+/*******************************************************************************
+* Function Name  : PWR_EnterSTANDBYMode
+* Description    : Enters STANDBY mode.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_EnterSTANDBYMode(void)
+{
+  /* Clear Wake-up flag */
+  PWR-&gt;CR |= CR_CWUF_Set;
+
+  /* Select STANDBY mode */
+  PWR-&gt;CR |= CR_PDDS_Set;
+
+  /* Set SLEEPDEEP bit of Cortex System Control Register */
+  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
+
+  /* Request Wait For Interrupt */
+  __WFI();
+}
+
+/*******************************************************************************
+* Function Name  : PWR_GetFlagStatus
+* Description    : Checks whether the specified PWR flag is set or not.
+* Input          : - PWR_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - PWR_FLAG_WU: Wake Up flag
+*                       - PWR_FLAG_SB: StandBy flag
+*                       - PWR_FLAG_PVDO: PVD Output
+* Output         : None
+* Return         : The new state of PWR_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus PWR_GetFlagStatus(u32 PWR_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
+  
+  if ((PWR-&gt;CSR &amp; PWR_FLAG) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : PWR_ClearFlag
+* Description    : Clears the PWR's pending flags.
+* Input          : - PWR_FLAG: specifies the flag to clear.
+*                    This parameter can be one of the following values:
+*                       - PWR_FLAG_WU: Wake Up flag
+*                       - PWR_FLAG_SB: StandBy flag
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void PWR_ClearFlag(u32 PWR_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
+         
+  PWR-&gt;CR |=  PWR_FLAG &lt;&lt; 2;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rcc.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,1105 +1,1105 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_rcc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the RCC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ------------ RCC registers bit address in the alias region ----------- */
-#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-/* Alias word address of HSION bit */
-#define CR_OFFSET                 (RCC_OFFSET + 0x00)
-#define HSION_BitNumber           0x00
-#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
-
-/* Alias word address of PLLON bit */
-#define PLLON_BitNumber           0x18
-#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
-
-/* Alias word address of CSSON bit */
-#define CSSON_BitNumber           0x13
-#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
-
-/* --- CFGR Register ---*/
-/* Alias word address of USBPRE bit */
-#define CFGR_OFFSET               (RCC_OFFSET + 0x04)
-#define USBPRE_BitNumber          0x16
-#define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
-
-/* --- BDCR Register ---*/
-/* Alias word address of RTCEN bit */
-#define BDCR_OFFSET               (RCC_OFFSET + 0x20)
-#define RTCEN_BitNumber           0x0F
-#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
-
-/* Alias word address of BDRST bit */
-#define BDRST_BitNumber           0x10
-#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
-
-/* --- CSR Register ---*/
-/* Alias word address of LSION bit */
-#define CSR_OFFSET                (RCC_OFFSET + 0x24)
-#define LSION_BitNumber           0x00
-#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
-
-/* ---------------------- RCC registers bit mask ------------------------ */
-/* CR register bit mask */
-#define CR_HSEBYP_Reset           ((u32)0xFFFBFFFF)
-#define CR_HSEBYP_Set             ((u32)0x00040000)
-#define CR_HSEON_Reset            ((u32)0xFFFEFFFF)
-#define CR_HSEON_Set              ((u32)0x00010000)
-#define CR_HSITRIM_Mask           ((u32)0xFFFFFF07)
-
-/* CFGR register bit mask */
-#define CFGR_PLL_Mask             ((u32)0xFFC0FFFF)
-#define CFGR_PLLMull_Mask         ((u32)0x003C0000)
-#define CFGR_PLLSRC_Mask          ((u32)0x00010000)
-#define CFGR_PLLXTPRE_Mask        ((u32)0x00020000)
-#define CFGR_SWS_Mask             ((u32)0x0000000C)
-#define CFGR_SW_Mask              ((u32)0xFFFFFFFC)
-#define CFGR_HPRE_Reset_Mask      ((u32)0xFFFFFF0F)
-#define CFGR_HPRE_Set_Mask        ((u32)0x000000F0)
-#define CFGR_PPRE1_Reset_Mask     ((u32)0xFFFFF8FF)
-#define CFGR_PPRE1_Set_Mask       ((u32)0x00000700)
-#define CFGR_PPRE2_Reset_Mask     ((u32)0xFFFFC7FF)
-#define CFGR_PPRE2_Set_Mask       ((u32)0x00003800)
-#define CFGR_ADCPRE_Reset_Mask    ((u32)0xFFFF3FFF)
-#define CFGR_ADCPRE_Set_Mask      ((u32)0x0000C000)
-
-/* CSR register bit mask */
-#define CSR_RMVF_Set              ((u32)0x01000000)
-
-/* RCC Flag Mask */
-#define FLAG_Mask                 ((u8)0x1F)
-
-/* Typical Value of the HSI in Hz */
-#define HSI_Value                 ((u32)8000000)
-
-/* CIR register byte 2 (Bits[15:8]) base address */
-#define CIR_BYTE2_ADDRESS         ((u32)0x40021009)
-/* CIR register byte 3 (Bits[23:16]) base address */
-#define CIR_BYTE3_ADDRESS         ((u32)0x4002100A)
-
-/* CFGR register byte 4 (Bits[31:24]) base address */
-#define CFGR_BYTE4_ADDRESS        ((u32)0x40021007)
-
-/* BDCR register base address */
-#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
-
-#ifndef HSEStartUp_TimeOut
-/* Time out for HSE start up */
-#define HSEStartUp_TimeOut        ((u16)0x0500)
-#endif
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-static uc8 APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
-static uc8 ADCPrescTable[4] = {2, 4, 6, 8};
-
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : RCC_DeInit
-* Description    : Resets the RCC clock configuration to the default reset state.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_DeInit(void)
-{
-  /* Set HSION bit */
-  RCC-&gt;CR |= (u32)0x00000001;
-
-  /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
-  RCC-&gt;CFGR &amp;= (u32)0xF8FF0000;
-  
-  /* Reset HSEON, CSSON and PLLON bits */
-  RCC-&gt;CR &amp;= (u32)0xFEF6FFFF;
-
-  /* Reset HSEBYP bit */
-  RCC-&gt;CR &amp;= (u32)0xFFFBFFFF;
-
-  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
-  RCC-&gt;CFGR &amp;= (u32)0xFF80FFFF;
-
-  /* Disable all interrupts */
-  RCC-&gt;CIR = 0x00000000;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_HSEConfig
-* Description    : Configures the External High Speed oscillator (HSE).
-*                  HSE can not be stopped if it is used directly or through the 
-*                  PLL as system clock.
-* Input          : - RCC_HSE: specifies the new state of the HSE.
-*                    This parameter can be one of the following values:
-*                       - RCC_HSE_OFF: HSE oscillator OFF
-*                       - RCC_HSE_ON: HSE oscillator ON
-*                       - RCC_HSE_Bypass: HSE oscillator bypassed with external
-*                         clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_HSEConfig(u32 RCC_HSE)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_HSE(RCC_HSE));
-
-  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
-  /* Reset HSEON bit */
-  RCC-&gt;CR &amp;= CR_HSEON_Reset;
-
-  /* Reset HSEBYP bit */
-  RCC-&gt;CR &amp;= CR_HSEBYP_Reset;
-
-  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
-  switch(RCC_HSE)
-  {
-    case RCC_HSE_ON:
-      /* Set HSEON bit */
-      RCC-&gt;CR |= CR_HSEON_Set;
-      break;
-      
-    case RCC_HSE_Bypass:
-      /* Set HSEBYP and HSEON bits */
-      RCC-&gt;CR |= CR_HSEBYP_Set | CR_HSEON_Set;
-      break;            
-      
-    default:
-      break;      
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_WaitForHSEStartUp
-* Description    : Waits for HSE start-up.
-* Input          : None
-* Output         : None
-* Return         : An ErrorStatus enumuration value:
-*                         - SUCCESS: HSE oscillator is stable and ready to use
-*                         - ERROR: HSE oscillator not yet ready
-*******************************************************************************/
-ErrorStatus RCC_WaitForHSEStartUp(void)
-{
-  vu32 StartUpCounter = 0;
-  ErrorStatus status = ERROR;
-  FlagStatus HSEStatus = RESET;
-  
-  /* Wait till HSE is ready and if Time out is reached exit */
-  do
-  {
-    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
-    StartUpCounter++;  
-  } while((HSEStatus == RESET) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
-
-
-  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
-  {
-    status = SUCCESS;
-  }
-  else
-  {
-    status = ERROR;
-  }  
-
-  return (status);
-}
-
-/*******************************************************************************
-* Function Name  : RCC_AdjustHSICalibrationValue
-* Description    : Adjusts the Internal High Speed oscillator (HSI) calibration
-*                  value.
-* Input          : - HSICalibrationValue: specifies the calibration trimming value.
-*                    This parameter must be a number between 0 and 0x1F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
-
-  tmpreg = RCC-&gt;CR;
-
-  /* Clear HSITRIM[4:0] bits */
-  tmpreg &amp;= CR_HSITRIM_Mask;
-
-  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
-  tmpreg |= (u32)HSICalibrationValue &lt;&lt; 3;
-
-  /* Store the new value */
-  RCC-&gt;CR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_HSICmd
-* Description    : Enables or disables the Internal High Speed oscillator (HSI).
-*                  HSI can not be stopped if it is used directly or through the 
-*                  PLL as system clock.
-* Input          : - NewState: new state of the HSI.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_HSICmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_HSION_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PLLConfig
-* Description    : Configures the PLL clock source and multiplication factor.
-*                  This function must be used only when the PLL is disabled.
-* Input          : - RCC_PLLSource: specifies the PLL entry clock source.
-*                    This parameter can be one of the following values:
-*                       - RCC_PLLSource_HSI_Div2: HSI oscillator clock divided
-*                         by 2 selected as PLL clock entry
-*                       - RCC_PLLSource_HSE_Div1: HSE oscillator clock selected
-*                         as PLL clock entry
-*                       - RCC_PLLSource_HSE_Div2: HSE oscillator clock divided
-*                         by 2 selected as PLL clock entry
-*                  - RCC_PLLMul: specifies the PLL multiplication factor.
-*                    This parameter can be RCC_PLLMul_x where x:[2,16]
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
-  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
-  tmpreg &amp;= CFGR_PLL_Mask;
-
-  /* Set the PLL configuration bits */
-  tmpreg |= RCC_PLLSource | RCC_PLLMul;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PLLCmd
-* Description    : Enables or disables the PLL.
-*                  The PLL can not be disabled if it is used as system clock.
-* Input          : - NewState: new state of the PLL.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PLLCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_PLLON_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_SYSCLKConfig
-* Description    : Configures the system clock (SYSCLK).
-* Input          : - RCC_SYSCLKSource: specifies the clock source used as system
-*                    clock. This parameter can be one of the following values:
-*                       - RCC_SYSCLKSource_HSI: HSI selected as system clock
-*                       - RCC_SYSCLKSource_HSE: HSE selected as system clock
-*                       - RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear SW[1:0] bits */
-  tmpreg &amp;= CFGR_SW_Mask;
-
-  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
-  tmpreg |= RCC_SYSCLKSource;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetSYSCLKSource
-* Description    : Returns the clock source used as system clock.
-* Input          : None
-* Output         : None
-* Return         : The clock source used as system clock. The returned value can
-*                  be one of the following:
-*                       - 0x00: HSI used as system clock
-*                       - 0x04: HSE used as system clock
-*                       - 0x08: PLL used as system clock
-*******************************************************************************/
-u8 RCC_GetSYSCLKSource(void)
-{
-  return ((u8)(RCC-&gt;CFGR &amp; CFGR_SWS_Mask));
-}
-
-/*******************************************************************************
-* Function Name  : RCC_HCLKConfig
-* Description    : Configures the AHB clock (HCLK).
-* Input          : - RCC_SYSCLK: defines the AHB clock divider. This clock is
-*                    derived from the system clock (SYSCLK).
-*                    This parameter can be one of the following values:
-*                       - RCC_SYSCLK_Div1: AHB clock = SYSCLK
-*                       - RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
-*                       - RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
-*                       - RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
-*                       - RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
-*                       - RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
-*                       - RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
-*                       - RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
-*                       - RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_HCLKConfig(u32 RCC_SYSCLK)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear HPRE[3:0] bits */
-  tmpreg &amp;= CFGR_HPRE_Reset_Mask;
-
-  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
-  tmpreg |= RCC_SYSCLK;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PCLK1Config
-* Description    : Configures the Low Speed APB clock (PCLK1).
-* Input          : - RCC_HCLK: defines the APB1 clock divider. This clock is
-*                    derived from the AHB clock (HCLK).
-*                    This parameter can be one of the following values:
-*                       - RCC_HCLK_Div1: APB1 clock = HCLK
-*                       - RCC_HCLK_Div2: APB1 clock = HCLK/2
-*                       - RCC_HCLK_Div4: APB1 clock = HCLK/4
-*                       - RCC_HCLK_Div8: APB1 clock = HCLK/8
-*                       - RCC_HCLK_Div16: APB1 clock = HCLK/16
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PCLK1Config(u32 RCC_HCLK)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PCLK(RCC_HCLK));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear PPRE1[2:0] bits */
-  tmpreg &amp;= CFGR_PPRE1_Reset_Mask;
-
-  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
-  tmpreg |= RCC_HCLK;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_PCLK2Config
-* Description    : Configures the High Speed APB clock (PCLK2).
-* Input          : - RCC_HCLK: defines the APB2 clock divider. This clock is
-*                    derived from the AHB clock (HCLK).
-*                    This parameter can be one of the following values:
-*                       - RCC_HCLK_Div1: APB2 clock = HCLK
-*                       - RCC_HCLK_Div2: APB2 clock = HCLK/2
-*                       - RCC_HCLK_Div4: APB2 clock = HCLK/4
-*                       - RCC_HCLK_Div8: APB2 clock = HCLK/8
-*                       - RCC_HCLK_Div16: APB2 clock = HCLK/16
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_PCLK2Config(u32 RCC_HCLK)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PCLK(RCC_HCLK));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear PPRE2[2:0] bits */
-  tmpreg &amp;= CFGR_PPRE2_Reset_Mask;
-
-  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
-  tmpreg |= RCC_HCLK &lt;&lt; 3;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ITConfig
-* Description    : Enables or disables the specified RCC interrupts.
-* Input          : - RCC_IT: specifies the RCC interrupt sources to be enabled
-*                    or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_IT_LSIRDY: LSI ready interrupt
-*                       - RCC_IT_LSERDY: LSE ready interrupt
-*                       - RCC_IT_HSIRDY: HSI ready interrupt
-*                       - RCC_IT_HSERDY: HSE ready interrupt
-*                       - RCC_IT_PLLRDY: PLL ready interrupt
-*                  - NewState: new state of the specified RCC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_IT(RCC_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
-    *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
-  }
-  else
-  {
-    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
-    *(vu8 *) CIR_BYTE2_ADDRESS &amp;= (u8)~RCC_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_USBCLKConfig
-* Description    : Configures the USB clock (USBCLK).
-* Input          : - RCC_USBCLKSource: specifies the USB clock source. This clock
-*                    is derived from the PLL output.
-*                    This parameter can be one of the following values:
-*                       - RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5
-*                         selected as USB clock source
-*                       - RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB
-*                         clock source
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
-
-  *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ADCCLKConfig
-* Description    : Configures the ADC clock (ADCCLK).
-* Input          : - RCC_PCLK2: defines the ADC clock divider. This clock is
-*                    derived from the APB2 clock (PCLK2).
-*                    This parameter can be one of the following values:
-*                       - RCC_PCLK2_Div2: ADC clock = PCLK2/2
-*                       - RCC_PCLK2_Div4: ADC clock = PCLK2/4
-*                       - RCC_PCLK2_Div6: ADC clock = PCLK2/6
-*                       - RCC_PCLK2_Div8: ADC clock = PCLK2/8
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ADCCLKConfig(u32 RCC_PCLK2)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
-
-  tmpreg = RCC-&gt;CFGR;
-
-  /* Clear ADCPRE[1:0] bits */
-  tmpreg &amp;= CFGR_ADCPRE_Reset_Mask;
-
-  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
-  tmpreg |= RCC_PCLK2;
-
-  /* Store the new value */
-  RCC-&gt;CFGR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_LSEConfig
-* Description    : Configures the External Low Speed oscillator (LSE).
-* Input          : - RCC_LSE: specifies the new state of the LSE.
-*                    This parameter can be one of the following values:
-*                       - RCC_LSE_OFF: LSE oscillator OFF
-*                       - RCC_LSE_ON: LSE oscillator ON
-*                       - RCC_LSE_Bypass: LSE oscillator bypassed with external
-*                         clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_LSEConfig(u8 RCC_LSE)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_LSE(RCC_LSE));
-
-  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
-  /* Reset LSEON bit */
-  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
-
-  /* Reset LSEBYP bit */
-  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
-
-  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
-  switch(RCC_LSE)
-  {
-    case RCC_LSE_ON:
-      /* Set LSEON bit */
-      *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
-      break;
-      
-    case RCC_LSE_Bypass:
-      /* Set LSEBYP and LSEON bits */
-      *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
-      break;            
-      
-    default:
-      break;      
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_LSICmd
-* Description    : Enables or disables the Internal Low Speed oscillator (LSI).
-*                  LSI can not be disabled if the IWDG is running.
-* Input          : - NewState: new state of the LSI.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_LSICmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CSR_LSION_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_RTCCLKConfig
-* Description    : Configures the RTC clock (RTCCLK).
-*                  Once the RTC clock is selected it can&#146;t be changed unless the
-*                  Backup domain is reset.
-* Input          : - RCC_RTCCLKSource: specifies the RTC clock source.
-*                    This parameter can be one of the following values:
-*                       - RCC_RTCCLKSource_LSE: LSE selected as RTC clock
-*                       - RCC_RTCCLKSource_LSI: LSI selected as RTC clock
-*                       - RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128
-*                         selected as RTC clock
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
-
-  /* Select the RTC clock source */
-  RCC-&gt;BDCR |= RCC_RTCCLKSource;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_RTCCLKCmd
-* Description    : Enables or disables the RTC clock.
-*                  This function must be used only after the RTC clock was
-*                  selected using the RCC_RTCCLKConfig function.
-* Input          : - NewState: new state of the RTC clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_RTCCLKCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetClocksFreq
-* Description    : Returns the frequencies of different on chip clocks.
-* Input          : - RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which
-*                    will hold the clocks frequencies.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
-{
-  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
-
-  /* Get SYSCLK source -------------------------------------------------------*/
-  tmp = RCC-&gt;CFGR &amp; CFGR_SWS_Mask;
-
-  switch (tmp)
-  {
-    case 0x00:  /* HSI used as system clock */
-      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
-      break;
-
-    case 0x04:  /* HSE used as system clock */
-      RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value;
-      break;
-
-    case 0x08:  /* PLL used as system clock */
-      /* Get PLL clock source and multiplication factor ----------------------*/
-      pllmull = RCC-&gt;CFGR &amp; CFGR_PLLMull_Mask;
-      pllmull = ( pllmull &gt;&gt; 18) + 2;
-
-      pllsource = RCC-&gt;CFGR &amp; CFGR_PLLSRC_Mask;
-
-      if (pllsource == 0x00)
-      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
-        RCC_Clocks-&gt;SYSCLK_Frequency = (HSI_Value &gt;&gt; 1) * pllmull;
-      }
-      else
-      {/* HSE selected as PLL clock entry */
-
-        if ((RCC-&gt;CFGR &amp; CFGR_PLLXTPRE_Mask) != (u32)RESET)
-        {/* HSE oscillator clock divided by 2 */
-
-          RCC_Clocks-&gt;SYSCLK_Frequency = (HSE_Value &gt;&gt; 1) * pllmull;
-        }
-        else
-        {
-          RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value * pllmull;
-        }
-      }
-      break;
-
-    default:
-      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
-      break;
-  }
-
-  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
-  /* Get HCLK prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_HPRE_Set_Mask;
-  tmp = tmp &gt;&gt; 4;
-  presc = APBAHBPrescTable[tmp];
-
-  /* HCLK clock frequency */
-  RCC_Clocks-&gt;HCLK_Frequency = RCC_Clocks-&gt;SYSCLK_Frequency &gt;&gt; presc;
-
-  /* Get PCLK1 prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE1_Set_Mask;
-  tmp = tmp &gt;&gt; 8;
-  presc = APBAHBPrescTable[tmp];
-
-  /* PCLK1 clock frequency */
-  RCC_Clocks-&gt;PCLK1_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
-
-  /* Get PCLK2 prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE2_Set_Mask;
-  tmp = tmp &gt;&gt; 11;
-  presc = APBAHBPrescTable[tmp];
-
-  /* PCLK2 clock frequency */
-  RCC_Clocks-&gt;PCLK2_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
-
-  /* Get ADCCLK prescaler */
-  tmp = RCC-&gt;CFGR &amp; CFGR_ADCPRE_Set_Mask;
-  tmp = tmp &gt;&gt; 14;
-  presc = ADCPrescTable[tmp];
-
-  /* ADCCLK clock frequency */
-  RCC_Clocks-&gt;ADCCLK_Frequency = RCC_Clocks-&gt;PCLK2_Frequency / presc;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_AHBPeriphClockCmd
-* Description    : Enables or disables the AHB peripheral clock.
-* Input          : - RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_AHBPeriph_DMA1
-*                       - RCC_AHBPeriph_DMA2
-*                       - RCC_AHBPeriph_SRAM
-*                       - RCC_AHBPeriph_FLITF
-*                       - RCC_AHBPeriph_CRC
-*                       - RCC_AHBPeriph_FSMC
-*                       - RCC_AHBPeriph_SDIO
-*                    SRAM and FLITF clock can be disabled only during sleep mode.
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;AHBENR |= RCC_AHBPeriph;
-  }
-  else
-  {
-    RCC-&gt;AHBENR &amp;= ~RCC_AHBPeriph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB2PeriphClockCmd
-* Description    : Enables or disables the High Speed APB (APB2) peripheral clock.
-* Input          : - RCC_APB2Periph: specifies the APB2 peripheral to gates its
-*                    clock.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
-*                         RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
-*                         RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
-*                         RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
-*                         RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
-*                         RCC_APB2Periph_ALL
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB2ENR |= RCC_APB2Periph;
-  }
-  else
-  {
-    RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB1PeriphClockCmd
-* Description    : Enables or disables the Low Speed APB (APB1) peripheral clock.
-* Input          : - RCC_APB1Periph: specifies the APB1 peripheral to gates its
-*                    clock.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
-*                         RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
-*                         RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
-*                         RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
-*                         RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
-*                         RCC_APB1Periph_USB, RCC_APB1Periph_CAN, RCC_APB1Periph_BKP,
-*                         RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_ALL
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB1ENR |= RCC_APB1Periph;
-  }
-  else
-  {
-    RCC-&gt;APB1ENR &amp;= ~RCC_APB1Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB2PeriphResetCmd
-* Description    : Forces or releases High Speed APB (APB2) peripheral reset.
-* Input          : - RCC_APB2Periph: specifies the APB2 peripheral to reset.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
-*                         RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
-*                         RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
-*                         RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
-*                         RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
-*                         RCC_APB2Periph_ALL
-*                  - NewState: new state of the specified peripheral reset.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB2RSTR |= RCC_APB2Periph;
-  }
-  else
-  {
-    RCC-&gt;APB2RSTR &amp;= ~RCC_APB2Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_APB1PeriphResetCmd
-* Description    : Forces or releases Low Speed APB (APB1) peripheral reset.
-* Input          : - RCC_APB1Periph: specifies the APB1 peripheral to reset.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
-*                         RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
-*                         RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
-*                         RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
-*                         RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
-*                         RCC_APB1Periph_USB, RCC_APB1Periph_CAN, RCC_APB1Periph_BKP,
-*                         RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_ALL
-*                  - NewState: new state of the specified peripheral clock.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC-&gt;APB1RSTR |= RCC_APB1Periph;
-  }
-  else
-  {
-    RCC-&gt;APB1RSTR &amp;= ~RCC_APB1Periph;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RCC_BackupResetCmd
-* Description    : Forces or releases the Backup domain reset.
-* Input          : - NewState: new state of the Backup domain reset.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_BackupResetCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ClockSecuritySystemCmd
-* Description    : Enables or disables the Clock Security System.
-* Input          : - NewState: new state of the Clock Security System..
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(vu32 *) CR_CSSON_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_MCOConfig
-* Description    : Selects the clock source to output on MCO pin.
-* Input          : - RCC_MCO: specifies the clock source to output.
-*                    This parameter can be one of the following values:
-*                       - RCC_MCO_NoClock: No clock selected
-*                       - RCC_MCO_SYSCLK: System clock selected
-*                       - RCC_MCO_HSI: HSI oscillator clock selected
-*                       - RCC_MCO_HSE: HSE oscillator clock selected
-*                       - RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_MCOConfig(u8 RCC_MCO)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_MCO(RCC_MCO));
-
-  /* Perform Byte access to MCO[2:0] bits to select the MCO source */
-  *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetFlagStatus
-* Description    : Checks whether the specified RCC flag is set or not.
-* Input          : - RCC_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - RCC_FLAG_HSIRDY: HSI oscillator clock ready
-*                       - RCC_FLAG_HSERDY: HSE oscillator clock ready
-*                       - RCC_FLAG_PLLRDY: PLL clock ready
-*                       - RCC_FLAG_LSERDY: LSE oscillator clock ready
-*                       - RCC_FLAG_LSIRDY: LSI oscillator clock ready
-*                       - RCC_FLAG_PINRST: Pin reset
-*                       - RCC_FLAG_PORRST: POR/PDR reset
-*                       - RCC_FLAG_SFTRST: Software reset
-*                       - RCC_FLAG_IWDGRST: Independent Watchdog reset
-*                       - RCC_FLAG_WWDGRST: Window Watchdog reset
-*                       - RCC_FLAG_LPWRRST: Low Power reset
-* Output         : None
-* Return         : The new state of RCC_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
-{
-  u32 tmp = 0;
-  u32 statusreg = 0;
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_FLAG(RCC_FLAG));
-
-  /* Get the RCC register index */
-  tmp = RCC_FLAG &gt;&gt; 5;
-
-  if (tmp == 1)               /* The flag to check is in CR register */
-  {
-    statusreg = RCC-&gt;CR;
-  }
-  else if (tmp == 2)          /* The flag to check is in BDCR register */
-  {
-    statusreg = RCC-&gt;BDCR;
-  }
-  else                       /* The flag to check is in CSR register */
-  {
-    statusreg = RCC-&gt;CSR;
-  }
-
-  /* Get the flag position */
-  tmp = RCC_FLAG &amp; FLAG_Mask;
-
-  if ((statusreg &amp; ((u32)1 &lt;&lt; tmp)) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ClearFlag
-* Description    : Clears the RCC reset flags.
-*                  The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,
-*                  RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST,
-*                  RCC_FLAG_LPWRRST
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ClearFlag(void)
-{
-  /* Set RMVF bit to clear the reset flags */
-  RCC-&gt;CSR |= CSR_RMVF_Set;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_GetITStatus
-* Description    : Checks whether the specified RCC interrupt has occurred or not.
-* Input          : - RCC_IT: specifies the RCC interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - RCC_IT_LSIRDY: LSI ready interrupt
-*                       - RCC_IT_LSERDY: LSE ready interrupt
-*                       - RCC_IT_HSIRDY: HSI ready interrupt
-*                       - RCC_IT_HSERDY: HSE ready interrupt
-*                       - RCC_IT_PLLRDY: PLL ready interrupt
-*                       - RCC_IT_CSS: Clock Security System interrupt
-* Output         : None
-* Return         : The new state of RCC_IT (SET or RESET).
-*******************************************************************************/
-ITStatus RCC_GetITStatus(u8 RCC_IT)
-{
-  ITStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_GET_IT(RCC_IT));
-
-  /* Check the status of the specified RCC interrupt */
-  if ((RCC-&gt;CIR &amp; RCC_IT) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the RCC_IT status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RCC_ClearITPendingBit
-* Description    : Clears the RCC&#146;s interrupt pending bits.
-* Input          : - RCC_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - RCC_IT_LSIRDY: LSI ready interrupt
-*                       - RCC_IT_LSERDY: LSE ready interrupt
-*                       - RCC_IT_HSIRDY: HSI ready interrupt
-*                       - RCC_IT_HSERDY: HSE ready interrupt
-*                       - RCC_IT_PLLRDY: PLL ready interrupt
-*                       - RCC_IT_CSS: Clock Security System interrupt
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_ClearITPendingBit(u8 RCC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
-
-  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
-     pending bits */
-  *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_rcc.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the RCC firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ------------ RCC registers bit address in the alias region ----------- */
+#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
+
+/* --- CR Register ---*/
+/* Alias word address of HSION bit */
+#define CR_OFFSET                 (RCC_OFFSET + 0x00)
+#define HSION_BitNumber           0x00
+#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
+
+/* Alias word address of PLLON bit */
+#define PLLON_BitNumber           0x18
+#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
+
+/* Alias word address of CSSON bit */
+#define CSSON_BitNumber           0x13
+#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
+
+/* --- CFGR Register ---*/
+/* Alias word address of USBPRE bit */
+#define CFGR_OFFSET               (RCC_OFFSET + 0x04)
+#define USBPRE_BitNumber          0x16
+#define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
+
+/* --- BDCR Register ---*/
+/* Alias word address of RTCEN bit */
+#define BDCR_OFFSET               (RCC_OFFSET + 0x20)
+#define RTCEN_BitNumber           0x0F
+#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
+
+/* Alias word address of BDRST bit */
+#define BDRST_BitNumber           0x10
+#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
+
+/* --- CSR Register ---*/
+/* Alias word address of LSION bit */
+#define CSR_OFFSET                (RCC_OFFSET + 0x24)
+#define LSION_BitNumber           0x00
+#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
+
+/* ---------------------- RCC registers bit mask ------------------------ */
+/* CR register bit mask */
+#define CR_HSEBYP_Reset           ((u32)0xFFFBFFFF)
+#define CR_HSEBYP_Set             ((u32)0x00040000)
+#define CR_HSEON_Reset            ((u32)0xFFFEFFFF)
+#define CR_HSEON_Set              ((u32)0x00010000)
+#define CR_HSITRIM_Mask           ((u32)0xFFFFFF07)
+
+/* CFGR register bit mask */
+#define CFGR_PLL_Mask             ((u32)0xFFC0FFFF)
+#define CFGR_PLLMull_Mask         ((u32)0x003C0000)
+#define CFGR_PLLSRC_Mask          ((u32)0x00010000)
+#define CFGR_PLLXTPRE_Mask        ((u32)0x00020000)
+#define CFGR_SWS_Mask             ((u32)0x0000000C)
+#define CFGR_SW_Mask              ((u32)0xFFFFFFFC)
+#define CFGR_HPRE_Reset_Mask      ((u32)0xFFFFFF0F)
+#define CFGR_HPRE_Set_Mask        ((u32)0x000000F0)
+#define CFGR_PPRE1_Reset_Mask     ((u32)0xFFFFF8FF)
+#define CFGR_PPRE1_Set_Mask       ((u32)0x00000700)
+#define CFGR_PPRE2_Reset_Mask     ((u32)0xFFFFC7FF)
+#define CFGR_PPRE2_Set_Mask       ((u32)0x00003800)
+#define CFGR_ADCPRE_Reset_Mask    ((u32)0xFFFF3FFF)
+#define CFGR_ADCPRE_Set_Mask      ((u32)0x0000C000)
+
+/* CSR register bit mask */
+#define CSR_RMVF_Set              ((u32)0x01000000)
+
+/* RCC Flag Mask */
+#define FLAG_Mask                 ((u8)0x1F)
+
+/* Typical Value of the HSI in Hz */
+#define HSI_Value                 ((u32)8000000)
+
+/* CIR register byte 2 (Bits[15:8]) base address */
+#define CIR_BYTE2_ADDRESS         ((u32)0x40021009)
+/* CIR register byte 3 (Bits[23:16]) base address */
+#define CIR_BYTE3_ADDRESS         ((u32)0x4002100A)
+
+/* CFGR register byte 4 (Bits[31:24]) base address */
+#define CFGR_BYTE4_ADDRESS        ((u32)0x40021007)
+
+/* BDCR register base address */
+#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
+
+#ifndef HSEStartUp_TimeOut
+/* Time out for HSE start up */
+#define HSEStartUp_TimeOut        ((u16)0x0500)
+#endif
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+static uc8 APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
+static uc8 ADCPrescTable[4] = {2, 4, 6, 8};
+
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : RCC_DeInit
+* Description    : Resets the RCC clock configuration to the default reset state.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_DeInit(void)
+{
+  /* Set HSION bit */
+  RCC-&gt;CR |= (u32)0x00000001;
+
+  /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
+  RCC-&gt;CFGR &amp;= (u32)0xF8FF0000;
+  
+  /* Reset HSEON, CSSON and PLLON bits */
+  RCC-&gt;CR &amp;= (u32)0xFEF6FFFF;
+
+  /* Reset HSEBYP bit */
+  RCC-&gt;CR &amp;= (u32)0xFFFBFFFF;
+
+  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
+  RCC-&gt;CFGR &amp;= (u32)0xFF80FFFF;
+
+  /* Disable all interrupts */
+  RCC-&gt;CIR = 0x00000000;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_HSEConfig
+* Description    : Configures the External High Speed oscillator (HSE).
+*                  HSE can not be stopped if it is used directly or through the 
+*                  PLL as system clock.
+* Input          : - RCC_HSE: specifies the new state of the HSE.
+*                    This parameter can be one of the following values:
+*                       - RCC_HSE_OFF: HSE oscillator OFF
+*                       - RCC_HSE_ON: HSE oscillator ON
+*                       - RCC_HSE_Bypass: HSE oscillator bypassed with external
+*                         clock
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_HSEConfig(u32 RCC_HSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_HSE(RCC_HSE));
+
+  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
+  /* Reset HSEON bit */
+  RCC-&gt;CR &amp;= CR_HSEON_Reset;
+
+  /* Reset HSEBYP bit */
+  RCC-&gt;CR &amp;= CR_HSEBYP_Reset;
+
+  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
+  switch(RCC_HSE)
+  {
+    case RCC_HSE_ON:
+      /* Set HSEON bit */
+      RCC-&gt;CR |= CR_HSEON_Set;
+      break;
+      
+    case RCC_HSE_Bypass:
+      /* Set HSEBYP and HSEON bits */
+      RCC-&gt;CR |= CR_HSEBYP_Set | CR_HSEON_Set;
+      break;            
+      
+    default:
+      break;      
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_WaitForHSEStartUp
+* Description    : Waits for HSE start-up.
+* Input          : None
+* Output         : None
+* Return         : An ErrorStatus enumuration value:
+*                         - SUCCESS: HSE oscillator is stable and ready to use
+*                         - ERROR: HSE oscillator not yet ready
+*******************************************************************************/
+ErrorStatus RCC_WaitForHSEStartUp(void)
+{
+  vu32 StartUpCounter = 0;
+  ErrorStatus status = ERROR;
+  FlagStatus HSEStatus = RESET;
+  
+  /* Wait till HSE is ready and if Time out is reached exit */
+  do
+  {
+    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
+    StartUpCounter++;  
+  } while((HSEStatus == RESET) &amp;&amp; (StartUpCounter != HSEStartUp_TimeOut));
+
+
+  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
+  {
+    status = SUCCESS;
+  }
+  else
+  {
+    status = ERROR;
+  }  
+
+  return (status);
+}
+
+/*******************************************************************************
+* Function Name  : RCC_AdjustHSICalibrationValue
+* Description    : Adjusts the Internal High Speed oscillator (HSI) calibration
+*                  value.
+* Input          : - HSICalibrationValue: specifies the calibration trimming value.
+*                    This parameter must be a number between 0 and 0x1F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
+
+  tmpreg = RCC-&gt;CR;
+
+  /* Clear HSITRIM[4:0] bits */
+  tmpreg &amp;= CR_HSITRIM_Mask;
+
+  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
+  tmpreg |= (u32)HSICalibrationValue &lt;&lt; 3;
+
+  /* Store the new value */
+  RCC-&gt;CR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_HSICmd
+* Description    : Enables or disables the Internal High Speed oscillator (HSI).
+*                  HSI can not be stopped if it is used directly or through the 
+*                  PLL as system clock.
+* Input          : - NewState: new state of the HSI.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_HSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CR_HSION_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_PLLConfig
+* Description    : Configures the PLL clock source and multiplication factor.
+*                  This function must be used only when the PLL is disabled.
+* Input          : - RCC_PLLSource: specifies the PLL entry clock source.
+*                    This parameter can be one of the following values:
+*                       - RCC_PLLSource_HSI_Div2: HSI oscillator clock divided
+*                         by 2 selected as PLL clock entry
+*                       - RCC_PLLSource_HSE_Div1: HSE oscillator clock selected
+*                         as PLL clock entry
+*                       - RCC_PLLSource_HSE_Div2: HSE oscillator clock divided
+*                         by 2 selected as PLL clock entry
+*                  - RCC_PLLMul: specifies the PLL multiplication factor.
+*                    This parameter can be RCC_PLLMul_x where x:[2,16]
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
+  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
+
+  tmpreg = RCC-&gt;CFGR;
+
+  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
+  tmpreg &amp;= CFGR_PLL_Mask;
+
+  /* Set the PLL configuration bits */
+  tmpreg |= RCC_PLLSource | RCC_PLLMul;
+
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_PLLCmd
+* Description    : Enables or disables the PLL.
+*                  The PLL can not be disabled if it is used as system clock.
+* Input          : - NewState: new state of the PLL.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_PLLCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CR_PLLON_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_SYSCLKConfig
+* Description    : Configures the system clock (SYSCLK).
+* Input          : - RCC_SYSCLKSource: specifies the clock source used as system
+*                    clock. This parameter can be one of the following values:
+*                       - RCC_SYSCLKSource_HSI: HSI selected as system clock
+*                       - RCC_SYSCLKSource_HSE: HSE selected as system clock
+*                       - RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
+
+  tmpreg = RCC-&gt;CFGR;
+
+  /* Clear SW[1:0] bits */
+  tmpreg &amp;= CFGR_SW_Mask;
+
+  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
+  tmpreg |= RCC_SYSCLKSource;
+
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_GetSYSCLKSource
+* Description    : Returns the clock source used as system clock.
+* Input          : None
+* Output         : None
+* Return         : The clock source used as system clock. The returned value can
+*                  be one of the following:
+*                       - 0x00: HSI used as system clock
+*                       - 0x04: HSE used as system clock
+*                       - 0x08: PLL used as system clock
+*******************************************************************************/
+u8 RCC_GetSYSCLKSource(void)
+{
+  return ((u8)(RCC-&gt;CFGR &amp; CFGR_SWS_Mask));
+}
+
+/*******************************************************************************
+* Function Name  : RCC_HCLKConfig
+* Description    : Configures the AHB clock (HCLK).
+* Input          : - RCC_SYSCLK: defines the AHB clock divider. This clock is
+*                    derived from the system clock (SYSCLK).
+*                    This parameter can be one of the following values:
+*                       - RCC_SYSCLK_Div1: AHB clock = SYSCLK
+*                       - RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
+*                       - RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
+*                       - RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
+*                       - RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
+*                       - RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
+*                       - RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
+*                       - RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
+*                       - RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_HCLKConfig(u32 RCC_SYSCLK)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
+
+  tmpreg = RCC-&gt;CFGR;
+
+  /* Clear HPRE[3:0] bits */
+  tmpreg &amp;= CFGR_HPRE_Reset_Mask;
+
+  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
+  tmpreg |= RCC_SYSCLK;
+
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_PCLK1Config
+* Description    : Configures the Low Speed APB clock (PCLK1).
+* Input          : - RCC_HCLK: defines the APB1 clock divider. This clock is
+*                    derived from the AHB clock (HCLK).
+*                    This parameter can be one of the following values:
+*                       - RCC_HCLK_Div1: APB1 clock = HCLK
+*                       - RCC_HCLK_Div2: APB1 clock = HCLK/2
+*                       - RCC_HCLK_Div4: APB1 clock = HCLK/4
+*                       - RCC_HCLK_Div8: APB1 clock = HCLK/8
+*                       - RCC_HCLK_Div16: APB1 clock = HCLK/16
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_PCLK1Config(u32 RCC_HCLK)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+
+  tmpreg = RCC-&gt;CFGR;
+
+  /* Clear PPRE1[2:0] bits */
+  tmpreg &amp;= CFGR_PPRE1_Reset_Mask;
+
+  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK;
+
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_PCLK2Config
+* Description    : Configures the High Speed APB clock (PCLK2).
+* Input          : - RCC_HCLK: defines the APB2 clock divider. This clock is
+*                    derived from the AHB clock (HCLK).
+*                    This parameter can be one of the following values:
+*                       - RCC_HCLK_Div1: APB2 clock = HCLK
+*                       - RCC_HCLK_Div2: APB2 clock = HCLK/2
+*                       - RCC_HCLK_Div4: APB2 clock = HCLK/4
+*                       - RCC_HCLK_Div8: APB2 clock = HCLK/8
+*                       - RCC_HCLK_Div16: APB2 clock = HCLK/16
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_PCLK2Config(u32 RCC_HCLK)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_PCLK(RCC_HCLK));
+
+  tmpreg = RCC-&gt;CFGR;
+
+  /* Clear PPRE2[2:0] bits */
+  tmpreg &amp;= CFGR_PPRE2_Reset_Mask;
+
+  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
+  tmpreg |= RCC_HCLK &lt;&lt; 3;
+
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_ITConfig
+* Description    : Enables or disables the specified RCC interrupts.
+* Input          : - RCC_IT: specifies the RCC interrupt sources to be enabled
+*                    or disabled.
+*                    This parameter can be any combination of the following values:
+*                       - RCC_IT_LSIRDY: LSI ready interrupt
+*                       - RCC_IT_LSERDY: LSE ready interrupt
+*                       - RCC_IT_HSIRDY: HSI ready interrupt
+*                       - RCC_IT_HSERDY: HSE ready interrupt
+*                       - RCC_IT_PLLRDY: PLL ready interrupt
+*                  - NewState: new state of the specified RCC interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_IT(RCC_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
+    *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
+  }
+  else
+  {
+    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
+    *(vu8 *) CIR_BYTE2_ADDRESS &amp;= (u8)~RCC_IT;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_USBCLKConfig
+* Description    : Configures the USB clock (USBCLK).
+* Input          : - RCC_USBCLKSource: specifies the USB clock source. This clock
+*                    is derived from the PLL output.
+*                    This parameter can be one of the following values:
+*                       - RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5
+*                         selected as USB clock source
+*                       - RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB
+*                         clock source
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
+
+  *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_ADCCLKConfig
+* Description    : Configures the ADC clock (ADCCLK).
+* Input          : - RCC_PCLK2: defines the ADC clock divider. This clock is
+*                    derived from the APB2 clock (PCLK2).
+*                    This parameter can be one of the following values:
+*                       - RCC_PCLK2_Div2: ADC clock = PCLK2/2
+*                       - RCC_PCLK2_Div4: ADC clock = PCLK2/4
+*                       - RCC_PCLK2_Div6: ADC clock = PCLK2/6
+*                       - RCC_PCLK2_Div8: ADC clock = PCLK2/8
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_ADCCLKConfig(u32 RCC_PCLK2)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
+
+  tmpreg = RCC-&gt;CFGR;
+
+  /* Clear ADCPRE[1:0] bits */
+  tmpreg &amp;= CFGR_ADCPRE_Reset_Mask;
+
+  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
+  tmpreg |= RCC_PCLK2;
+
+  /* Store the new value */
+  RCC-&gt;CFGR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_LSEConfig
+* Description    : Configures the External Low Speed oscillator (LSE).
+* Input          : - RCC_LSE: specifies the new state of the LSE.
+*                    This parameter can be one of the following values:
+*                       - RCC_LSE_OFF: LSE oscillator OFF
+*                       - RCC_LSE_ON: LSE oscillator ON
+*                       - RCC_LSE_Bypass: LSE oscillator bypassed with external
+*                         clock
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_LSEConfig(u8 RCC_LSE)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_LSE(RCC_LSE));
+
+  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
+  /* Reset LSEON bit */
+  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
+
+  /* Reset LSEBYP bit */
+  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
+
+  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
+  switch(RCC_LSE)
+  {
+    case RCC_LSE_ON:
+      /* Set LSEON bit */
+      *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
+      break;
+      
+    case RCC_LSE_Bypass:
+      /* Set LSEBYP and LSEON bits */
+      *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
+      break;            
+      
+    default:
+      break;      
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_LSICmd
+* Description    : Enables or disables the Internal Low Speed oscillator (LSI).
+*                  LSI can not be disabled if the IWDG is running.
+* Input          : - NewState: new state of the LSI.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_LSICmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CSR_LSION_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_RTCCLKConfig
+* Description    : Configures the RTC clock (RTCCLK).
+*                  Once the RTC clock is selected it can't be changed unless the
+*                  Backup domain is reset.
+* Input          : - RCC_RTCCLKSource: specifies the RTC clock source.
+*                    This parameter can be one of the following values:
+*                       - RCC_RTCCLKSource_LSE: LSE selected as RTC clock
+*                       - RCC_RTCCLKSource_LSI: LSI selected as RTC clock
+*                       - RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128
+*                         selected as RTC clock
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
+
+  /* Select the RTC clock source */
+  RCC-&gt;BDCR |= RCC_RTCCLKSource;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_RTCCLKCmd
+* Description    : Enables or disables the RTC clock.
+*                  This function must be used only after the RTC clock was
+*                  selected using the RCC_RTCCLKConfig function.
+* Input          : - NewState: new state of the RTC clock.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_RTCCLKCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_GetClocksFreq
+* Description    : Returns the frequencies of different on chip clocks.
+* Input          : - RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which
+*                    will hold the clocks frequencies.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
+{
+  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
+
+  /* Get SYSCLK source -------------------------------------------------------*/
+  tmp = RCC-&gt;CFGR &amp; CFGR_SWS_Mask;
+
+  switch (tmp)
+  {
+    case 0x00:  /* HSI used as system clock */
+      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
+      break;
+
+    case 0x04:  /* HSE used as system clock */
+      RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value;
+      break;
+
+    case 0x08:  /* PLL used as system clock */
+      /* Get PLL clock source and multiplication factor ----------------------*/
+      pllmull = RCC-&gt;CFGR &amp; CFGR_PLLMull_Mask;
+      pllmull = ( pllmull &gt;&gt; 18) + 2;
+
+      pllsource = RCC-&gt;CFGR &amp; CFGR_PLLSRC_Mask;
+
+      if (pllsource == 0x00)
+      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
+        RCC_Clocks-&gt;SYSCLK_Frequency = (HSI_Value &gt;&gt; 1) * pllmull;
+      }
+      else
+      {/* HSE selected as PLL clock entry */
+
+        if ((RCC-&gt;CFGR &amp; CFGR_PLLXTPRE_Mask) != (u32)RESET)
+        {/* HSE oscillator clock divided by 2 */
+
+          RCC_Clocks-&gt;SYSCLK_Frequency = (HSE_Value &gt;&gt; 1) * pllmull;
+        }
+        else
+        {
+          RCC_Clocks-&gt;SYSCLK_Frequency = HSE_Value * pllmull;
+        }
+      }
+      break;
+
+    default:
+      RCC_Clocks-&gt;SYSCLK_Frequency = HSI_Value;
+      break;
+  }
+
+  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
+  /* Get HCLK prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_HPRE_Set_Mask;
+  tmp = tmp &gt;&gt; 4;
+  presc = APBAHBPrescTable[tmp];
+
+  /* HCLK clock frequency */
+  RCC_Clocks-&gt;HCLK_Frequency = RCC_Clocks-&gt;SYSCLK_Frequency &gt;&gt; presc;
+
+  /* Get PCLK1 prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE1_Set_Mask;
+  tmp = tmp &gt;&gt; 8;
+  presc = APBAHBPrescTable[tmp];
+
+  /* PCLK1 clock frequency */
+  RCC_Clocks-&gt;PCLK1_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
+
+  /* Get PCLK2 prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_PPRE2_Set_Mask;
+  tmp = tmp &gt;&gt; 11;
+  presc = APBAHBPrescTable[tmp];
+
+  /* PCLK2 clock frequency */
+  RCC_Clocks-&gt;PCLK2_Frequency = RCC_Clocks-&gt;HCLK_Frequency &gt;&gt; presc;
+
+  /* Get ADCCLK prescaler */
+  tmp = RCC-&gt;CFGR &amp; CFGR_ADCPRE_Set_Mask;
+  tmp = tmp &gt;&gt; 14;
+  presc = ADCPrescTable[tmp];
+
+  /* ADCCLK clock frequency */
+  RCC_Clocks-&gt;ADCCLK_Frequency = RCC_Clocks-&gt;PCLK2_Frequency / presc;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_AHBPeriphClockCmd
+* Description    : Enables or disables the AHB peripheral clock.
+* Input          : - RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
+*                    This parameter can be any combination of the following values:
+*                       - RCC_AHBPeriph_DMA1
+*                       - RCC_AHBPeriph_DMA2
+*                       - RCC_AHBPeriph_SRAM
+*                       - RCC_AHBPeriph_FLITF
+*                       - RCC_AHBPeriph_CRC
+*                       - RCC_AHBPeriph_FSMC
+*                       - RCC_AHBPeriph_SDIO
+*                    SRAM and FLITF clock can be disabled only during sleep mode.
+*                  - NewState: new state of the specified peripheral clock.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;AHBENR |= RCC_AHBPeriph;
+  }
+  else
+  {
+    RCC-&gt;AHBENR &amp;= ~RCC_AHBPeriph;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_APB2PeriphClockCmd
+* Description    : Enables or disables the High Speed APB (APB2) peripheral clock.
+* Input          : - RCC_APB2Periph: specifies the APB2 peripheral to gates its
+*                    clock.
+*                    This parameter can be any combination of the following values:
+*                       - RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
+*                         RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
+*                         RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
+*                         RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
+*                         RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
+*                         RCC_APB2Periph_ALL
+*                  - NewState: new state of the specified peripheral clock.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB2ENR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_APB1PeriphClockCmd
+* Description    : Enables or disables the Low Speed APB (APB1) peripheral clock.
+* Input          : - RCC_APB1Periph: specifies the APB1 peripheral to gates its
+*                    clock.
+*                    This parameter can be any combination of the following values:
+*                       - RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
+*                         RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
+*                         RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
+*                         RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
+*                         RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
+*                         RCC_APB1Periph_USB, RCC_APB1Periph_CAN, RCC_APB1Periph_BKP,
+*                         RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_ALL
+*                  - NewState: new state of the specified peripheral clock.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB1ENR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC-&gt;APB1ENR &amp;= ~RCC_APB1Periph;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_APB2PeriphResetCmd
+* Description    : Forces or releases High Speed APB (APB2) peripheral reset.
+* Input          : - RCC_APB2Periph: specifies the APB2 peripheral to reset.
+*                    This parameter can be any combination of the following values:
+*                       - RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
+*                         RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
+*                         RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
+*                         RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
+*                         RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
+*                         RCC_APB2Periph_ALL
+*                  - NewState: new state of the specified peripheral reset.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB2RSTR |= RCC_APB2Periph;
+  }
+  else
+  {
+    RCC-&gt;APB2RSTR &amp;= ~RCC_APB2Periph;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_APB1PeriphResetCmd
+* Description    : Forces or releases Low Speed APB (APB1) peripheral reset.
+* Input          : - RCC_APB1Periph: specifies the APB1 peripheral to reset.
+*                    This parameter can be any combination of the following values:
+*                       - RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
+*                         RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
+*                         RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
+*                         RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
+*                         RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
+*                         RCC_APB1Periph_USB, RCC_APB1Periph_CAN, RCC_APB1Periph_BKP,
+*                         RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_ALL
+*                  - NewState: new state of the specified peripheral clock.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    RCC-&gt;APB1RSTR |= RCC_APB1Periph;
+  }
+  else
+  {
+    RCC-&gt;APB1RSTR &amp;= ~RCC_APB1Periph;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RCC_BackupResetCmd
+* Description    : Forces or releases the Backup domain reset.
+* Input          : - NewState: new state of the Backup domain reset.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_BackupResetCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_ClockSecuritySystemCmd
+* Description    : Enables or disables the Clock Security System.
+* Input          : - NewState: new state of the Clock Security System..
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  *(vu32 *) CR_CSSON_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_MCOConfig
+* Description    : Selects the clock source to output on MCO pin.
+* Input          : - RCC_MCO: specifies the clock source to output.
+*                    This parameter can be one of the following values:
+*                       - RCC_MCO_NoClock: No clock selected
+*                       - RCC_MCO_SYSCLK: System clock selected
+*                       - RCC_MCO_HSI: HSI oscillator clock selected
+*                       - RCC_MCO_HSE: HSE oscillator clock selected
+*                       - RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_MCOConfig(u8 RCC_MCO)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_MCO(RCC_MCO));
+
+  /* Perform Byte access to MCO[2:0] bits to select the MCO source */
+  *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_GetFlagStatus
+* Description    : Checks whether the specified RCC flag is set or not.
+* Input          : - RCC_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - RCC_FLAG_HSIRDY: HSI oscillator clock ready
+*                       - RCC_FLAG_HSERDY: HSE oscillator clock ready
+*                       - RCC_FLAG_PLLRDY: PLL clock ready
+*                       - RCC_FLAG_LSERDY: LSE oscillator clock ready
+*                       - RCC_FLAG_LSIRDY: LSI oscillator clock ready
+*                       - RCC_FLAG_PINRST: Pin reset
+*                       - RCC_FLAG_PORRST: POR/PDR reset
+*                       - RCC_FLAG_SFTRST: Software reset
+*                       - RCC_FLAG_IWDGRST: Independent Watchdog reset
+*                       - RCC_FLAG_WWDGRST: Window Watchdog reset
+*                       - RCC_FLAG_LPWRRST: Low Power reset
+* Output         : None
+* Return         : The new state of RCC_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
+{
+  u32 tmp = 0;
+  u32 statusreg = 0;
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_FLAG(RCC_FLAG));
+
+  /* Get the RCC register index */
+  tmp = RCC_FLAG &gt;&gt; 5;
+
+  if (tmp == 1)               /* The flag to check is in CR register */
+  {
+    statusreg = RCC-&gt;CR;
+  }
+  else if (tmp == 2)          /* The flag to check is in BDCR register */
+  {
+    statusreg = RCC-&gt;BDCR;
+  }
+  else                       /* The flag to check is in CSR register */
+  {
+    statusreg = RCC-&gt;CSR;
+  }
+
+  /* Get the flag position */
+  tmp = RCC_FLAG &amp; FLAG_Mask;
+
+  if ((statusreg &amp; ((u32)1 &lt;&lt; tmp)) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the flag status */
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_ClearFlag
+* Description    : Clears the RCC reset flags.
+*                  The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,
+*                  RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST,
+*                  RCC_FLAG_LPWRRST
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_ClearFlag(void)
+{
+  /* Set RMVF bit to clear the reset flags */
+  RCC-&gt;CSR |= CSR_RMVF_Set;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_GetITStatus
+* Description    : Checks whether the specified RCC interrupt has occurred or not.
+* Input          : - RCC_IT: specifies the RCC interrupt source to check.
+*                    This parameter can be one of the following values:
+*                       - RCC_IT_LSIRDY: LSI ready interrupt
+*                       - RCC_IT_LSERDY: LSE ready interrupt
+*                       - RCC_IT_HSIRDY: HSI ready interrupt
+*                       - RCC_IT_HSERDY: HSE ready interrupt
+*                       - RCC_IT_PLLRDY: PLL ready interrupt
+*                       - RCC_IT_CSS: Clock Security System interrupt
+* Output         : None
+* Return         : The new state of RCC_IT (SET or RESET).
+*******************************************************************************/
+ITStatus RCC_GetITStatus(u8 RCC_IT)
+{
+  ITStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_RCC_GET_IT(RCC_IT));
+
+  /* Check the status of the specified RCC interrupt */
+  if ((RCC-&gt;CIR &amp; RCC_IT) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+
+  /* Return the RCC_IT status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : RCC_ClearITPendingBit
+* Description    : Clears the RCC's interrupt pending bits.
+* Input          : - RCC_IT: specifies the interrupt pending bit to clear.
+*                    This parameter can be any combination of the following values:
+*                       - RCC_IT_LSIRDY: LSI ready interrupt
+*                       - RCC_IT_LSERDY: LSE ready interrupt
+*                       - RCC_IT_HSIRDY: HSI ready interrupt
+*                       - RCC_IT_HSERDY: HSE ready interrupt
+*                       - RCC_IT_PLLRDY: PLL ready interrupt
+*                       - RCC_IT_CSS: Clock Security System interrupt
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RCC_ClearITPendingBit(u8 RCC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
+
+  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
+     pending bits */
+  *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_rtc.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,320 +1,320 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_rtc.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the RTC firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_rtc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-#define CRL_CNF_Set      ((u16)0x0010)      /* Configuration Flag Enable Mask */
-#define CRL_CNF_Reset    ((u16)0xFFEF)      /* Configuration Flag Disable Mask */
-#define RTC_LSB_Mask     ((u32)0x0000FFFF)  /* RTC LSB Mask */
-#define PRLH_MSB_Mask    ((u32)0x000F0000)  /* RTC Prescaler MSB Mask */
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : RTC_ITConfig
-* Description    : Enables or disables the specified RTC interrupts.
-* Input          : - RTC_IT: specifies the RTC interrupts sources to be enabled
-*                    or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - RTC_IT_OW: Overflow interrupt
-*                       - RTC_IT_ALR: Alarm interrupt
-*                       - RTC_IT_SEC: Second interrupt
-*                  - NewState: new state of the specified RTC interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ITConfig(u16 RTC_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_IT(RTC_IT));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    RTC-&gt;CRH |= RTC_IT;
-  }
-  else
-  {
-    RTC-&gt;CRH &amp;= (u16)~RTC_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RTC_EnterConfigMode
-* Description    : Enters the RTC configuration mode.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_EnterConfigMode(void)
-{
-  /* Set the CNF flag to enter in the Configuration Mode */
-  RTC-&gt;CRL |= CRL_CNF_Set;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_ExitConfigMode
-* Description    : Exits from the RTC configuration mode.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ExitConfigMode(void)
-{
-  /* Reset the CNF flag to exit from the Configuration Mode */
-  RTC-&gt;CRL &amp;= CRL_CNF_Reset;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetCounter
-* Description    : Gets the RTC counter value.
-* Input          : None
-* Output         : None
-* Return         : RTC counter value.
-*******************************************************************************/
-u32 RTC_GetCounter(void)
-{
-  u16 tmp = 0;
-  tmp = RTC-&gt;CNTL;
-
-  return (((u32)RTC-&gt;CNTH &lt;&lt; 16 ) | tmp) ;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_SetCounter
-* Description    : Sets the RTC counter value.
-* Input          : - CounterValue: RTC counter new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_SetCounter(u32 CounterValue)
-{ 
-  RTC_EnterConfigMode();
-
-  /* Set RTC COUNTER MSB word */
-  RTC-&gt;CNTH = CounterValue &gt;&gt; 16;
-  /* Set RTC COUNTER LSB word */
-  RTC-&gt;CNTL = (CounterValue &amp; RTC_LSB_Mask);
-
-  RTC_ExitConfigMode();
-}
-
-/*******************************************************************************
-* Function Name  : RTC_SetPrescaler
-* Description    : Sets the RTC prescaler value.
-* Input          : - PrescalerValue: RTC prescaler new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_SetPrescaler(u32 PrescalerValue)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_PRESCALER(PrescalerValue));
-  
-  RTC_EnterConfigMode();
-
-  /* Set RTC PRESCALER MSB word */
-  RTC-&gt;PRLH = (PrescalerValue &amp; PRLH_MSB_Mask) &gt;&gt; 16;
-  /* Set RTC PRESCALER LSB word */
-  RTC-&gt;PRLL = (PrescalerValue &amp; RTC_LSB_Mask);
-
-  RTC_ExitConfigMode();
-}
-
-/*******************************************************************************
-* Function Name  : RTC_SetAlarm
-* Description    : Sets the RTC alarm value.
-* Input          : - AlarmValue: RTC alarm new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_SetAlarm(u32 AlarmValue)
-{  
-  RTC_EnterConfigMode();
-
-  /* Set the ALARM MSB word */
-  RTC-&gt;ALRH = AlarmValue &gt;&gt; 16;
-  /* Set the ALARM LSB word */
-  RTC-&gt;ALRL = (AlarmValue &amp; RTC_LSB_Mask);
-
-  RTC_ExitConfigMode();
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetDivider
-* Description    : Gets the RTC divider value.
-* Input          : None
-* Output         : None
-* Return         : RTC Divider value.
-*******************************************************************************/
-u32 RTC_GetDivider(void)
-{
-  u32 tmp = 0x00;
-
-  tmp = ((u32)RTC-&gt;DIVH &amp; (u32)0x000F) &lt;&lt; 16;
-  tmp |= RTC-&gt;DIVL;
-
-  return tmp;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_WaitForLastTask
-* Description    : Waits until last write operation on RTC registers has finished.
-*                  This function must be called before any write to RTC registers.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_WaitForLastTask(void)
-{
-  /* Loop until RTOFF flag is set */
-  while ((RTC-&gt;CRL &amp; RTC_FLAG_RTOFF) == (u16)RESET)
-  {
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RTC_WaitForSynchro
-* Description    : Waits until the RTC registers (RTC_CNT, RTC_ALR and RTC_PRL)
-*                  are synchronized with RTC APB clock.
-*                  This function must be called before any read operation after
-*                  an APB reset or an APB clock stop.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_WaitForSynchro(void)
-{
-  /* Clear RSF flag */
-  RTC-&gt;CRL &amp;= (u16)~RTC_FLAG_RSF;
-
-  /* Loop until RSF flag is set */
-  while ((RTC-&gt;CRL &amp; RTC_FLAG_RSF) == (u16)RESET)
-  {
-  }
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetFlagStatus
-* Description    : Checks whether the specified RTC flag is set or not.
-* Input          : - RTC_FLAG: specifies the flag to check.
-*                    This parameter can be one the following values:
-*                       - RTC_FLAG_RTOFF: RTC Operation OFF flag
-*                       - RTC_FLAG_RSF: Registers Synchronized flag
-*                       - RTC_FLAG_OW: Overflow flag
-*                       - RTC_FLAG_ALR: Alarm flag
-*                       - RTC_FLAG_SEC: Second flag
-* Output         : None
-* Return         : The new state of RTC_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus RTC_GetFlagStatus(u16 RTC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
-  
-  if ((RTC-&gt;CRL &amp; RTC_FLAG) != (u16)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_ClearFlag
-* Description    : Clears the RTC&#146;s pending flags.
-* Input          : - RTC_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination of the following values:
-*                       - RTC_FLAG_RSF: Registers Synchronized flag. This flag
-*                         is cleared only after an APB reset or an APB Clock stop.
-*                       - RTC_FLAG_OW: Overflow flag
-*                       - RTC_FLAG_ALR: Alarm flag
-*                       - RTC_FLAG_SEC: Second flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ClearFlag(u16 RTC_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
-    
-  /* Clear the coressponding RTC flag */
-  RTC-&gt;CRL &amp;= (u16)~RTC_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_GetITStatus
-* Description    : Checks whether the specified RTC interrupt has occured or not.
-* Input          : - RTC_IT: specifies the RTC interrupts sources to check.
-*                    This parameter can be one of the following values:
-*                       - RTC_IT_OW: Overflow interrupt
-*                       - RTC_IT_ALR: Alarm interrupt
-*                       - RTC_IT_SEC: Second interrupt
-* Output         : None
-* Return         : The new state of the RTC_IT (SET or RESET).
-*******************************************************************************/
-ITStatus RTC_GetITStatus(u16 RTC_IT)
-{
-  ITStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_RTC_GET_IT(RTC_IT)); 
-  
-  bitstatus = (ITStatus)(RTC-&gt;CRL &amp; RTC_IT);
-
-  if (((RTC-&gt;CRH &amp; RTC_IT) != (u16)RESET) &amp;&amp; (bitstatus != (u16)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : RTC_ClearITPendingBit
-* Description    : Clears the RTC&#146;s interrupt pending bits.
-* Input          : - RTC_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - RTC_IT_OW: Overflow interrupt
-*                       - RTC_IT_ALR: Alarm interrupt
-*                       - RTC_IT_SEC: Second interrupt
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RTC_ClearITPendingBit(u16 RTC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_IT(RTC_IT));  
-  
-  /* Clear the coressponding RTC pending bit */
-  RTC-&gt;CRL &amp;= (u16)~RTC_IT;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_rtc.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the RTC firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_rtc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+#define CRL_CNF_Set      ((u16)0x0010)      /* Configuration Flag Enable Mask */
+#define CRL_CNF_Reset    ((u16)0xFFEF)      /* Configuration Flag Disable Mask */
+#define RTC_LSB_Mask     ((u32)0x0000FFFF)  /* RTC LSB Mask */
+#define PRLH_MSB_Mask    ((u32)0x000F0000)  /* RTC Prescaler MSB Mask */
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : RTC_ITConfig
+* Description    : Enables or disables the specified RTC interrupts.
+* Input          : - RTC_IT: specifies the RTC interrupts sources to be enabled
+*                    or disabled.
+*                    This parameter can be any combination of the following values:
+*                       - RTC_IT_OW: Overflow interrupt
+*                       - RTC_IT_ALR: Alarm interrupt
+*                       - RTC_IT_SEC: Second interrupt
+*                  - NewState: new state of the specified RTC interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_ITConfig(u16 RTC_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_IT(RTC_IT));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    RTC-&gt;CRH |= RTC_IT;
+  }
+  else
+  {
+    RTC-&gt;CRH &amp;= (u16)~RTC_IT;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RTC_EnterConfigMode
+* Description    : Enters the RTC configuration mode.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_EnterConfigMode(void)
+{
+  /* Set the CNF flag to enter in the Configuration Mode */
+  RTC-&gt;CRL |= CRL_CNF_Set;
+}
+
+/*******************************************************************************
+* Function Name  : RTC_ExitConfigMode
+* Description    : Exits from the RTC configuration mode.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_ExitConfigMode(void)
+{
+  /* Reset the CNF flag to exit from the Configuration Mode */
+  RTC-&gt;CRL &amp;= CRL_CNF_Reset;
+}
+
+/*******************************************************************************
+* Function Name  : RTC_GetCounter
+* Description    : Gets the RTC counter value.
+* Input          : None
+* Output         : None
+* Return         : RTC counter value.
+*******************************************************************************/
+u32 RTC_GetCounter(void)
+{
+  u16 tmp = 0;
+  tmp = RTC-&gt;CNTL;
+
+  return (((u32)RTC-&gt;CNTH &lt;&lt; 16 ) | tmp) ;
+}
+
+/*******************************************************************************
+* Function Name  : RTC_SetCounter
+* Description    : Sets the RTC counter value.
+* Input          : - CounterValue: RTC counter new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_SetCounter(u32 CounterValue)
+{ 
+  RTC_EnterConfigMode();
+
+  /* Set RTC COUNTER MSB word */
+  RTC-&gt;CNTH = CounterValue &gt;&gt; 16;
+  /* Set RTC COUNTER LSB word */
+  RTC-&gt;CNTL = (CounterValue &amp; RTC_LSB_Mask);
+
+  RTC_ExitConfigMode();
+}
+
+/*******************************************************************************
+* Function Name  : RTC_SetPrescaler
+* Description    : Sets the RTC prescaler value.
+* Input          : - PrescalerValue: RTC prescaler new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_SetPrescaler(u32 PrescalerValue)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_PRESCALER(PrescalerValue));
+  
+  RTC_EnterConfigMode();
+
+  /* Set RTC PRESCALER MSB word */
+  RTC-&gt;PRLH = (PrescalerValue &amp; PRLH_MSB_Mask) &gt;&gt; 16;
+  /* Set RTC PRESCALER LSB word */
+  RTC-&gt;PRLL = (PrescalerValue &amp; RTC_LSB_Mask);
+
+  RTC_ExitConfigMode();
+}
+
+/*******************************************************************************
+* Function Name  : RTC_SetAlarm
+* Description    : Sets the RTC alarm value.
+* Input          : - AlarmValue: RTC alarm new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_SetAlarm(u32 AlarmValue)
+{  
+  RTC_EnterConfigMode();
+
+  /* Set the ALARM MSB word */
+  RTC-&gt;ALRH = AlarmValue &gt;&gt; 16;
+  /* Set the ALARM LSB word */
+  RTC-&gt;ALRL = (AlarmValue &amp; RTC_LSB_Mask);
+
+  RTC_ExitConfigMode();
+}
+
+/*******************************************************************************
+* Function Name  : RTC_GetDivider
+* Description    : Gets the RTC divider value.
+* Input          : None
+* Output         : None
+* Return         : RTC Divider value.
+*******************************************************************************/
+u32 RTC_GetDivider(void)
+{
+  u32 tmp = 0x00;
+
+  tmp = ((u32)RTC-&gt;DIVH &amp; (u32)0x000F) &lt;&lt; 16;
+  tmp |= RTC-&gt;DIVL;
+
+  return tmp;
+}
+
+/*******************************************************************************
+* Function Name  : RTC_WaitForLastTask
+* Description    : Waits until last write operation on RTC registers has finished.
+*                  This function must be called before any write to RTC registers.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_WaitForLastTask(void)
+{
+  /* Loop until RTOFF flag is set */
+  while ((RTC-&gt;CRL &amp; RTC_FLAG_RTOFF) == (u16)RESET)
+  {
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RTC_WaitForSynchro
+* Description    : Waits until the RTC registers (RTC_CNT, RTC_ALR and RTC_PRL)
+*                  are synchronized with RTC APB clock.
+*                  This function must be called before any read operation after
+*                  an APB reset or an APB clock stop.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_WaitForSynchro(void)
+{
+  /* Clear RSF flag */
+  RTC-&gt;CRL &amp;= (u16)~RTC_FLAG_RSF;
+
+  /* Loop until RSF flag is set */
+  while ((RTC-&gt;CRL &amp; RTC_FLAG_RSF) == (u16)RESET)
+  {
+  }
+}
+
+/*******************************************************************************
+* Function Name  : RTC_GetFlagStatus
+* Description    : Checks whether the specified RTC flag is set or not.
+* Input          : - RTC_FLAG: specifies the flag to check.
+*                    This parameter can be one the following values:
+*                       - RTC_FLAG_RTOFF: RTC Operation OFF flag
+*                       - RTC_FLAG_RSF: Registers Synchronized flag
+*                       - RTC_FLAG_OW: Overflow flag
+*                       - RTC_FLAG_ALR: Alarm flag
+*                       - RTC_FLAG_SEC: Second flag
+* Output         : None
+* Return         : The new state of RTC_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus RTC_GetFlagStatus(u16 RTC_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
+  
+  if ((RTC-&gt;CRL &amp; RTC_FLAG) != (u16)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : RTC_ClearFlag
+* Description    : Clears the RTC's pending flags.
+* Input          : - RTC_FLAG: specifies the flag to clear.
+*                    This parameter can be any combination of the following values:
+*                       - RTC_FLAG_RSF: Registers Synchronized flag. This flag
+*                         is cleared only after an APB reset or an APB Clock stop.
+*                       - RTC_FLAG_OW: Overflow flag
+*                       - RTC_FLAG_ALR: Alarm flag
+*                       - RTC_FLAG_SEC: Second flag
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_ClearFlag(u16 RTC_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
+    
+  /* Clear the coressponding RTC flag */
+  RTC-&gt;CRL &amp;= (u16)~RTC_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : RTC_GetITStatus
+* Description    : Checks whether the specified RTC interrupt has occured or not.
+* Input          : - RTC_IT: specifies the RTC interrupts sources to check.
+*                    This parameter can be one of the following values:
+*                       - RTC_IT_OW: Overflow interrupt
+*                       - RTC_IT_ALR: Alarm interrupt
+*                       - RTC_IT_SEC: Second interrupt
+* Output         : None
+* Return         : The new state of the RTC_IT (SET or RESET).
+*******************************************************************************/
+ITStatus RTC_GetITStatus(u16 RTC_IT)
+{
+  ITStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_RTC_GET_IT(RTC_IT)); 
+  
+  bitstatus = (ITStatus)(RTC-&gt;CRL &amp; RTC_IT);
+
+  if (((RTC-&gt;CRH &amp; RTC_IT) != (u16)RESET) &amp;&amp; (bitstatus != (u16)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : RTC_ClearITPendingBit
+* Description    : Clears the RTC's interrupt pending bits.
+* Input          : - RTC_IT: specifies the interrupt pending bit to clear.
+*                    This parameter can be any combination of the following values:
+*                       - RTC_IT_OW: Overflow interrupt
+*                       - RTC_IT_ALR: Alarm interrupt
+*                       - RTC_IT_SEC: Second interrupt
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void RTC_ClearITPendingBit(u16 RTC_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_RTC_IT(RTC_IT));  
+  
+  /* Clear the coressponding RTC pending bit */
+  RTC-&gt;CRL &amp;= (u16)~RTC_IT;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_sdio.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,832 +1,832 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_sdio.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the SDIO firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_sdio.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* ------------ SDIO registers bit address in the alias region ----------- */
-#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
-
-/* --- CLKCR Register ---*/
-/* Alias word address of CLKEN bit */
-#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
-#define CLKEN_BitNumber           0x08
-#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
-
-/* --- CMD Register ---*/
-/* Alias word address of SDIOSUSPEND bit */
-#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
-#define SDIOSUSPEND_BitNumber     0x0B
-#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
-
-/* Alias word address of ENCMDCOMPL bit */
-#define ENCMDCOMPL_BitNumber      0x0C
-#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
-
-/* Alias word address of NIEN bit */
-#define NIEN_BitNumber            0x0D
-#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
-
-/* Alias word address of ATACMD bit */
-#define ATACMD_BitNumber          0x0E
-#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
-
-/* --- DCTRL Register ---*/
-/* Alias word address of DMAEN bit */
-#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
-#define DMAEN_BitNumber           0x03
-#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
-
-/* Alias word address of RWSTART bit */
-#define RWSTART_BitNumber         0x08
-#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
-
-/* Alias word address of RWSTOP bit */
-#define RWSTOP_BitNumber          0x09
-#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
-
-/* Alias word address of RWMOD bit */
-#define RWMOD_BitNumber           0x0A
-#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
-
-/* Alias word address of SDIOEN bit */
-#define SDIOEN_BitNumber          0x0B
-#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
-
-
-/* ---------------------- SDIO registers bit mask ------------------------ */
-/* --- CLKCR Register ---*/
-/* CLKCR register clear mask */
-#define CLKCR_CLEAR_MASK         ((u32)0xFFFF8100) 
-
-/* --- PWRCTRL Register ---*/
-/* SDIO PWRCTRL Mask */
-#define PWR_PWRCTRL_MASK         ((u32)0xFFFFFFFC)
-
-/* --- DCTRL Register ---*/
-/* SDIO DCTRL Clear Mask */
-#define DCTRL_CLEAR_MASK         ((u32)0xFFFFFF08)
-
-/* --- CMD Register ---*/
-/* CMD Register clear mask */
-#define CMD_CLEAR_MASK           ((u32)0xFFFFF800)
-
-/* SDIO RESP Registers Address */
-#define SDIO_RESP_ADDR           ((u32)(SDIO_BASE + 0x14))
-
-/* Private define ------------------------------------------------------------*/
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : SDIO_DeInit
-* Description    : Deinitializes the SDIO peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DeInit(void)
-{
-  SDIO-&gt;POWER = 0x00000000;
-  SDIO-&gt;CLKCR = 0x00000000;
-  SDIO-&gt;ARG = 0x00000000;
-  SDIO-&gt;CMD = 0x00000000;
-  SDIO-&gt;DTIMER = 0x00000000;
-  SDIO-&gt;DLEN = 0x00000000;
-  SDIO-&gt;DCTRL = 0x00000000;
-  SDIO-&gt;ICR = 0x00C007FF;
-  SDIO-&gt;MASK = 0x00000000;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_Init
-* Description    : Initializes the SDIO peripheral according to the specified 
-*                  parameters in the SDIO_InitStruct.
-* Input          : SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
-*                  that contains the configuration information for the SDIO 
-*                  peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
-{
-  u32 tmpreg = 0;
-    
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct-&gt;SDIO_ClockEdge));
-  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct-&gt;SDIO_ClockBypass));
-  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct-&gt;SDIO_ClockPowerSave));
-  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct-&gt;SDIO_BusWide));
-  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct-&gt;SDIO_HardwareFlowControl)); 
-   
-/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
-  /* Get the SDIO CLKCR value */
-  tmpreg = SDIO-&gt;CLKCR;
-  
-  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
-  tmpreg &amp;= CLKCR_CLEAR_MASK;
-  
-  /* Set CLKDIV bits according to SDIO_ClockDiv value */
-  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
-  /* Set BYPASS bit according to SDIO_ClockBypass value */
-  /* Set WIDBUS bits according to SDIO_BusWide value */
-  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
-  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
-  tmpreg |= (SDIO_InitStruct-&gt;SDIO_ClockDiv  | SDIO_InitStruct-&gt;SDIO_ClockPowerSave |
-             SDIO_InitStruct-&gt;SDIO_ClockBypass | SDIO_InitStruct-&gt;SDIO_BusWide |
-             SDIO_InitStruct-&gt;SDIO_ClockEdge | SDIO_InitStruct-&gt;SDIO_HardwareFlowControl); 
-  
-  /* Write to SDIO CLKCR */
-  SDIO-&gt;CLKCR = tmpreg;             
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_StructInit
-* Description    : Fills each SDIO_InitStruct member with its default value.
-* Input          : SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
-*                  will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
-{
-  /* SDIO_InitStruct members default value */
-  SDIO_InitStruct-&gt;SDIO_ClockDiv = 0x00;
-  SDIO_InitStruct-&gt;SDIO_ClockEdge = SDIO_ClockEdge_Rising;
-  SDIO_InitStruct-&gt;SDIO_ClockBypass = SDIO_ClockBypass_Disable;
-  SDIO_InitStruct-&gt;SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
-  SDIO_InitStruct-&gt;SDIO_BusWide = SDIO_BusWide_1b;
-  SDIO_InitStruct-&gt;SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ClockCmd
-* Description    : Enables or disables the SDIO Clock.
-* Input          : NewState: new state of the SDIO Clock.
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_ClockCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CLKCR_CLKEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SetPowerState
-* Description    : Sets the power status of the controller.
-* Input          : SDIO_PowerState: new state of the Power state. 
-*                  This parameter can be one of the following values:
-*                   - SDIO_PowerState_OFF
-*                   - SDIO_PowerState_ON
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SetPowerState(u32 SDIO_PowerState)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
-  
-  SDIO-&gt;POWER &amp;= PWR_PWRCTRL_MASK;
-  SDIO-&gt;POWER |= SDIO_PowerState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetPowerState
-* Description    : Gets the power status of the controller.
-* Input          : None
-* Output         : None
-* Return         : Power status of the controller. The returned value can
-*                  be one of the following:
-*                       - 0x00: Power OFF
-*                       - 0x02: Power UP
-*                       - 0x03: Power ON 
-*******************************************************************************/
-u32 SDIO_GetPowerState(void)
-{
-  return (SDIO-&gt;POWER &amp; (~PWR_PWRCTRL_MASK));
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ITConfig
-* Description    : Enables or disables the SDIO interrupts.
-* Input          : - SDIO_IT: specifies the SDIO interrupt sources to be 
-*                    enabled or disabled.
-*                    This parameter can be one or a combination of the following
-*                    values:
-*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
-*                                          failed) interrupt    
-*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
-*                                          failed) interrupt    
-*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
-*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
-*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
-*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
-*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
-*                                          passed) interrupt     
-*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
-*                                          interrupt     
-*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
-*                                          zero) interrupt     
-*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
-*                                          signals in wide bus mode interrupt    
-*                      - SDIO_IT_DBCKEND:  Data block sent/received (CRC check 
-*                                          passed) interrupt    
-*                      - SDIO_IT_CMDACT:   Command transfer in progress interrupt     
-*                      - SDIO_IT_TXACT:    Data transmit in progress interrupt       
-*                      - SDIO_IT_RXACT:    Data receive in progress interrupt      
-*                      - SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt    
-*                      - SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt   
-*                      - SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt     
-*                      - SDIO_IT_RXFIFOF:  Receive FIFO full interrupt     
-*                      - SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt      
-*                      - SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt     
-*                      - SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt      
-*                      - SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt      
-*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
-*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
-*                                          received for CMD61 interrupt
-*                  - NewState: new state of the specified SDIO interrupts.
-*                  This parameter can be: ENABLE or DISABLE.  
-* Output         : None
-* Return         : None 
-*******************************************************************************/
-void SDIO_ITConfig(u32 SDIO_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_IT(SDIO_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the SDIO interrupts */
-    SDIO-&gt;MASK |= SDIO_IT;
-  }
-  else
-  {
-    /* Disable the SDIO interrupts */
-    SDIO-&gt;MASK &amp;= ~SDIO_IT;
-  } 
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_DMACmd
-* Description    : Enables or disables the SDIO DMA request.
-* Input          : NewState: new state of the selected SDIO DMA request.
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DMACmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_DMAEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SendCommand
-* Description    : Initializes the SDIO Command according to the specified 
-*                  parameters in the SDIO_CmdInitStruct and send the command.
-* Input          : SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
-*                  structure that contains the configuration information 
-*                  for the SDIO command.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
-{
-  u32 tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct-&gt;SDIO_CmdIndex));
-  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct-&gt;SDIO_Response));
-  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct-&gt;SDIO_Wait));
-  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct-&gt;SDIO_CPSM));
-  
-/*---------------------------- SDIO ARG Configuration ------------------------*/
-  /* Set the SDIO Argument value */
-  SDIO-&gt;ARG = SDIO_CmdInitStruct-&gt;SDIO_Argument;
-  
-/*---------------------------- SDIO CMD Configuration ------------------------*/  
-  /* Get the SDIO CMD value */
-  tmpreg = SDIO-&gt;CMD;
-
-  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
-  tmpreg &amp;= CMD_CLEAR_MASK;
-  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
-  /* Set WAITRESP bits according to SDIO_Response value */
-  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
-  /* Set CPSMEN bits according to SDIO_CPSM value */
-  tmpreg |= (u32)SDIO_CmdInitStruct-&gt;SDIO_CmdIndex | SDIO_CmdInitStruct-&gt;SDIO_Response
-           | SDIO_CmdInitStruct-&gt;SDIO_Wait | SDIO_CmdInitStruct-&gt;SDIO_CPSM;
-  
-  /* Write to SDIO CMD */
-  SDIO-&gt;CMD = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_CmdStructInit
-* Description    : Fills each SDIO_CmdInitStruct member with its default value.
-* Input          : SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
-*                  structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
-{
-  /* SDIO_CmdInitStruct members default value */
-  SDIO_CmdInitStruct-&gt;SDIO_Argument = 0x00;
-  SDIO_CmdInitStruct-&gt;SDIO_CmdIndex = 0x00;
-  SDIO_CmdInitStruct-&gt;SDIO_Response = SDIO_Response_No;
-  SDIO_CmdInitStruct-&gt;SDIO_Wait = SDIO_Wait_No;
-  SDIO_CmdInitStruct-&gt;SDIO_CPSM = SDIO_CPSM_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetCommandResponse
-* Description    : Returns command index of last command for which response 
-*                  received.
-* Input          : None
-* Output         : None
-* Return         : Returns the command index of the last command response received.
-*******************************************************************************/
-u8 SDIO_GetCommandResponse(void)
-{
-  return (u8)(SDIO-&gt;RESPCMD);
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetResponse
-* Description    : Returns response received from the card for the last command.
-* Input          : - SDIO_RESP: Specifies the SDIO response register. 
-*                     This parameter can be one of the following values:
-*                       - SDIO_RESP1: Response Register 1
-*                       - SDIO_RESP2: Response Register 2
-*                       - SDIO_RESP3: Response Register 3
-*                       - SDIO_RESP4: Response Register 4                       
-* Output         : None
-* Return         : The Corresponding response register value.
-*******************************************************************************/
-u32 SDIO_GetResponse(u32 SDIO_RESP)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_RESP(SDIO_RESP));
-  
-  return (*(vu32 *)(SDIO_RESP_ADDR + SDIO_RESP)); 
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_DataConfig
-* Description    : Initializes the SDIO data path according to the specified 
-*                  parameters in the SDIO_DataInitStruct.
-* Input          : SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef 
-*                  structure that contains the configuration information 
-*                  for the SDIO command.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
-{
-  u32 tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct-&gt;SDIO_DataLength));
-  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct-&gt;SDIO_DataBlockSize));
-  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct-&gt;SDIO_TransferDir));
-  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct-&gt;SDIO_TransferMode));
-  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct-&gt;SDIO_DPSM));
-
-/*---------------------------- SDIO DTIMER Configuration ---------------------*/
-  /* Set the SDIO Data TimeOut value */
-  SDIO-&gt;DTIMER = SDIO_DataInitStruct-&gt;SDIO_DataTimeOut;
-    
-/*---------------------------- SDIO DLEN Configuration -----------------------*/
-  /* Set the SDIO DataLength value */
-  SDIO-&gt;DLEN = SDIO_DataInitStruct-&gt;SDIO_DataLength;
-  
-/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
-  /* Get the SDIO DCTRL value */
-  tmpreg = SDIO-&gt;DCTRL;
-
-  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
-  tmpreg &amp;= DCTRL_CLEAR_MASK;
-  /* Set DEN bit according to SDIO_DPSM value */
-  /* Set DTMODE bit according to SDIO_TransferMode value */
-  /* Set DTDIR bit according to SDIO_TransferDir value */
-  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
-  tmpreg |= (u32)SDIO_DataInitStruct-&gt;SDIO_DataBlockSize | SDIO_DataInitStruct-&gt;SDIO_TransferDir
-           | SDIO_DataInitStruct-&gt;SDIO_TransferMode | SDIO_DataInitStruct-&gt;SDIO_DPSM;
-  
-  /* Write to SDIO DCTRL */
-  SDIO-&gt;DCTRL = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_DataStructInit
-* Description    : Fills each SDIO_DataInitStruct member with its default value.
-* Input          : SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef 
-*                  structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
-{
-  /* SDIO_DataInitStruct members default value */
-  SDIO_DataInitStruct-&gt;SDIO_DataTimeOut = 0xFFFFFFFF;
-  SDIO_DataInitStruct-&gt;SDIO_DataLength = 0x00;
-  SDIO_DataInitStruct-&gt;SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
-  SDIO_DataInitStruct-&gt;SDIO_TransferDir = SDIO_TransferDir_ToCard;
-  SDIO_DataInitStruct-&gt;SDIO_TransferMode = SDIO_TransferMode_Block;  
-  SDIO_DataInitStruct-&gt;SDIO_DPSM = SDIO_DPSM_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetDataCounter
-* Description    : Returns number of remaining data bytes to be transferred.
-* Input          : None
-* Output         : None
-* Return         : Number of remaining data bytes to be transferred
-*******************************************************************************/
-u32 SDIO_GetDataCounter(void)
-{ 
-  return SDIO-&gt;DCOUNT;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ReadData
-* Description    : Read one data word from Rx FIFO.
-* Input          : None
-* Output         : None
-* Return         : Data received
-*******************************************************************************/
-u32 SDIO_ReadData(void)
-{ 
-  return SDIO-&gt;FIFO;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_WriteData
-* Description    : Write one data word to Tx FIFO.
-* Input          : Data: 32-bit data word to write.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_WriteData(u32 Data)
-{ 
-  SDIO-&gt;FIFO = Data;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetFIFOCount
-* Description    : Returns the number of words left to be written to or read
-*                  from FIFO.	
-* Input          : None
-* Output         : None
-* Return         : Remaining number of words.
-*******************************************************************************/
-u32 SDIO_GetFIFOCount(void)
-{ 
-  return SDIO-&gt;FIFOCNT;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_StartSDIOReadWait
-* Description    : Starts the SD I/O Read Wait operation.	
-* Input          : NewState: new state of the Start SDIO Read Wait operation. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_StartSDIOReadWait(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_RWSTART_BB = (u32) NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_StopSDIOReadWait
-* Description    : Stops the SD I/O Read Wait operation.	
-* Input          : NewState: new state of the Stop SDIO Read Wait operation. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_StopSDIOReadWait(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_RWSTOP_BB = (u32) NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SetSDIOReadWaitMode
-* Description    : Sets one of the two options of inserting read wait interval.	
-* Input          : SDIOReadWaitMode: SD I/O Read Wait operation mode.
-*                  This parametre can be:
-*                    - SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
-*                    - SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SetSDIOReadWaitMode(u32 SDIO_ReadWaitMode)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
-  
-  *(vu32 *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SetSDIOOperation
-* Description    : Enables or disables the SD I/O Mode Operation.	
-* Input          : NewState: new state of SDIO specific operation. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SetSDIOOperation(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) DCTRL_SDIOEN_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SendSDIOSuspendCmd
-* Description    : Enables or disables the SD I/O Mode suspend command sending.
-* Input          : NewState: new state of the SD I/O Mode suspend command.
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_SDIOSUSPEND_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_CommandCompletionCmd
-* Description    : Enables or disables the command completion signal.
-* Input          : NewState: new state of command completion signal. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_CommandCompletionCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_ENCMDCOMPL_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_CEATAITCmd
-* Description    : Enables or disables the CE-ATA interrupt.
-* Input          : NewState: new state of CE-ATA interrupt. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_CEATAITCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_NIEN_BB = (u32)((~((u32)NewState)) &amp; ((u32)0x1));
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_SendCEATACmd
-* Description    : Sends CE-ATA command (CMD61).
-* Input          : NewState: new state of CE-ATA command. 
-*                  This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_SendCEATACmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(vu32 *) CMD_ATACMD_BB = (u32)NewState;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetFlagStatus
-* Description    : Checks whether the specified SDIO flag is set or not.	
-* Input          : SDIO_FLAG: specifies the flag to check. 
-*                  This parameter can be one of the following values:
-*                     - SDIO_FLAG_CCRCFAIL: Command response received (CRC check
-*                                           failed)    
-*                     - SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check 
-*                                           failed)    
-*                     - SDIO_FLAG_CTIMEOUT: Command response timeout    
-*                     - SDIO_FLAG_DTIMEOUT: Data timeou   
-*                     - SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error   
-*                     - SDIO_FLAG_RXOVERR:  Received FIFO overrun error    
-*                     - SDIO_FLAG_CMDREND:  Command response received (CRC check 
-*                                           passed)    
-*                     - SDIO_FLAG_CMDSENT:  Command sent (no response required)    
-*                     - SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is
-*                                           zero)    
-*                     - SDIO_FLAG_STBITERR: Start bit not detected on all data 
-*                                           signals in wide bus mode   
-*                     - SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check 
-*                                           passed)    
-*                     - SDIO_FLAG_CMDACT:   Command transfer in progress     
-*                     - SDIO_FLAG_TXACT:    Data transmit in progress      
-*                     - SDIO_FLAG_RXACT:    Data receive in progress      
-*                     - SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty   
-*                     - SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full   
-*                     - SDIO_FLAG_TXFIFOF:  Transmit FIFO full    
-*                     - SDIO_FLAG_RXFIFOF:  Receive FIFO full     
-*                     - SDIO_FLAG_TXFIFOE:  Transmit FIFO empty    
-*                     - SDIO_FLAG_RXFIFOE:  Receive FIFO empty    
-*                     - SDIO_FLAG_TXDAVL:   Data available in transmit FIFO     
-*                     - SDIO_FLAG_RXDAVL:   Data available in receive FIFO     
-*                     - SDIO_FLAG_SDIOIT:   SD I/O interrupt received     
-*                     - SDIO_FLAG_CEATAEND: CE-ATA command completion signal 
-*                                           received for CMD61    
-* Output         : None
-* Return         : The new state of SDIO_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus SDIO_GetFlagStatus(u32 SDIO_FLAG)
-{ 
-  FlagStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
-  
-  if ((SDIO-&gt;STA &amp; SDIO_FLAG) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ClearFlag
-* Description    : Clears the SDIO's pending flags.	
-* Input          : SDIO_FLAG: specifies the flag to clear.  
-*                  This parameter can be one or a combination of the following
-*                  values:
-*                     - SDIO_FLAG_CCRCFAIL: Command response received (CRC check
-*                                           failed)    
-*                     - SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check 
-*                                           failed)    
-*                     - SDIO_FLAG_CTIMEOUT: Command response timeout    
-*                     - SDIO_FLAG_DTIMEOUT: Data timeou   
-*                     - SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error   
-*                     - SDIO_FLAG_RXOVERR:  Received FIFO overrun error    
-*                     - SDIO_FLAG_CMDREND:  Command response received (CRC check 
-*                                           passed)    
-*                     - SDIO_FLAG_CMDSENT:  Command sent (no response required)    
-*                     - SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is
-*                                           zero)    
-*                     - SDIO_FLAG_STBITERR: Start bit not detected on all data 
-*                                           signals in wide bus mode   
-*                     - SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check 
-*                                           passed)         
-*                     - SDIO_FLAG_SDIOIT:   SD I/O interrupt received     
-*                     - SDIO_FLAG_CEATAEND: CE-ATA command completion signal 
-*                                           received for CMD61    
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_ClearFlag(u32 SDIO_FLAG)
-{ 
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
-   
-  SDIO-&gt;ICR = SDIO_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_GetITStatus
-* Description    : Checks whether the specified SDIO interrupt has occurred or not.	
-* Input          : SDIO_IT: specifies the SDIO interrupt source to check. 
-*                  This parameter can be one of the following values:
-*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
-*                                          failed) interrupt    
-*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
-*                                          failed) interrupt    
-*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
-*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
-*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
-*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
-*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
-*                                          passed) interrupt     
-*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
-*                                          interrupt     
-*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
-*                                          zero) interrupt     
-*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
-*                                          signals in wide bus mode interrupt    
-*                      - SDIO_IT_DBCKEND:  Data block sent/received (CRC check 
-*                                          passed) interrupt    
-*                      - SDIO_IT_CMDACT:   Command transfer in progress interrupt     
-*                      - SDIO_IT_TXACT:    Data transmit in progress interrupt       
-*                      - SDIO_IT_RXACT:    Data receive in progress interrupt      
-*                      - SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt    
-*                      - SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt   
-*                      - SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt     
-*                      - SDIO_IT_RXFIFOF:  Receive FIFO full interrupt     
-*                      - SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt      
-*                      - SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt     
-*                      - SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt      
-*                      - SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt      
-*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
-*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
-*                                          received for CMD61 interrupt
-* Output         : None
-* Return         : The new state of SDIO_IT (SET or RESET).
-*******************************************************************************/
-ITStatus SDIO_GetITStatus(u32 SDIO_IT)
-{ 
-  ITStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_GET_IT(SDIO_IT));
-
-  if ((SDIO-&gt;STA &amp; SDIO_IT) != (u32)RESET)  
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SDIO_ClearITPendingBit
-* Description    : Clears the SDIO&#146;s interrupt pending bits.	
-* Input          : SDIO_IT: specifies the interrupt pending bit to clear. 
-*                   This parameter can be one or a combination of the following
-*                   values:
-*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
-*                                          failed) interrupt    
-*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
-*                                          failed) interrupt    
-*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
-*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
-*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
-*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
-*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
-*                                          passed) interrupt     
-*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
-*                                          interrupt     
-*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
-*                                          zero) interrupt     
-*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
-*                                          signals in wide bus mode interrupt          
-*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
-*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
-*                                          received for CMD61 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SDIO_ClearITPendingBit(u32 SDIO_IT)
-{ 
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
-   
-  SDIO-&gt;ICR = SDIO_IT;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_sdio.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the SDIO firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_sdio.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* ------------ SDIO registers bit address in the alias region ----------- */
+#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
+
+/* --- CLKCR Register ---*/
+/* Alias word address of CLKEN bit */
+#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
+#define CLKEN_BitNumber           0x08
+#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
+
+/* --- CMD Register ---*/
+/* Alias word address of SDIOSUSPEND bit */
+#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
+#define SDIOSUSPEND_BitNumber     0x0B
+#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
+
+/* Alias word address of ENCMDCOMPL bit */
+#define ENCMDCOMPL_BitNumber      0x0C
+#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
+
+/* Alias word address of NIEN bit */
+#define NIEN_BitNumber            0x0D
+#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
+
+/* Alias word address of ATACMD bit */
+#define ATACMD_BitNumber          0x0E
+#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
+
+/* --- DCTRL Register ---*/
+/* Alias word address of DMAEN bit */
+#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
+#define DMAEN_BitNumber           0x03
+#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
+
+/* Alias word address of RWSTART bit */
+#define RWSTART_BitNumber         0x08
+#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
+
+/* Alias word address of RWSTOP bit */
+#define RWSTOP_BitNumber          0x09
+#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
+
+/* Alias word address of RWMOD bit */
+#define RWMOD_BitNumber           0x0A
+#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
+
+/* Alias word address of SDIOEN bit */
+#define SDIOEN_BitNumber          0x0B
+#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
+
+
+/* ---------------------- SDIO registers bit mask ------------------------ */
+/* --- CLKCR Register ---*/
+/* CLKCR register clear mask */
+#define CLKCR_CLEAR_MASK         ((u32)0xFFFF8100) 
+
+/* --- PWRCTRL Register ---*/
+/* SDIO PWRCTRL Mask */
+#define PWR_PWRCTRL_MASK         ((u32)0xFFFFFFFC)
+
+/* --- DCTRL Register ---*/
+/* SDIO DCTRL Clear Mask */
+#define DCTRL_CLEAR_MASK         ((u32)0xFFFFFF08)
+
+/* --- CMD Register ---*/
+/* CMD Register clear mask */
+#define CMD_CLEAR_MASK           ((u32)0xFFFFF800)
+
+/* SDIO RESP Registers Address */
+#define SDIO_RESP_ADDR           ((u32)(SDIO_BASE + 0x14))
+
+/* Private define ------------------------------------------------------------*/
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : SDIO_DeInit
+* Description    : Deinitializes the SDIO peripheral registers to their default
+*                  reset values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_DeInit(void)
+{
+  SDIO-&gt;POWER = 0x00000000;
+  SDIO-&gt;CLKCR = 0x00000000;
+  SDIO-&gt;ARG = 0x00000000;
+  SDIO-&gt;CMD = 0x00000000;
+  SDIO-&gt;DTIMER = 0x00000000;
+  SDIO-&gt;DLEN = 0x00000000;
+  SDIO-&gt;DCTRL = 0x00000000;
+  SDIO-&gt;ICR = 0x00C007FF;
+  SDIO-&gt;MASK = 0x00000000;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_Init
+* Description    : Initializes the SDIO peripheral according to the specified 
+*                  parameters in the SDIO_InitStruct.
+* Input          : SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
+*                  that contains the configuration information for the SDIO 
+*                  peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  u32 tmpreg = 0;
+    
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct-&gt;SDIO_ClockEdge));
+  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct-&gt;SDIO_ClockBypass));
+  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct-&gt;SDIO_ClockPowerSave));
+  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct-&gt;SDIO_BusWide));
+  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct-&gt;SDIO_HardwareFlowControl)); 
+   
+/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
+  /* Get the SDIO CLKCR value */
+  tmpreg = SDIO-&gt;CLKCR;
+  
+  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
+  tmpreg &amp;= CLKCR_CLEAR_MASK;
+  
+  /* Set CLKDIV bits according to SDIO_ClockDiv value */
+  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
+  /* Set BYPASS bit according to SDIO_ClockBypass value */
+  /* Set WIDBUS bits according to SDIO_BusWide value */
+  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
+  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
+  tmpreg |= (SDIO_InitStruct-&gt;SDIO_ClockDiv  | SDIO_InitStruct-&gt;SDIO_ClockPowerSave |
+             SDIO_InitStruct-&gt;SDIO_ClockBypass | SDIO_InitStruct-&gt;SDIO_BusWide |
+             SDIO_InitStruct-&gt;SDIO_ClockEdge | SDIO_InitStruct-&gt;SDIO_HardwareFlowControl); 
+  
+  /* Write to SDIO CLKCR */
+  SDIO-&gt;CLKCR = tmpreg;             
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_StructInit
+* Description    : Fills each SDIO_InitStruct member with its default value.
+* Input          : SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
+*                  will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
+{
+  /* SDIO_InitStruct members default value */
+  SDIO_InitStruct-&gt;SDIO_ClockDiv = 0x00;
+  SDIO_InitStruct-&gt;SDIO_ClockEdge = SDIO_ClockEdge_Rising;
+  SDIO_InitStruct-&gt;SDIO_ClockBypass = SDIO_ClockBypass_Disable;
+  SDIO_InitStruct-&gt;SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
+  SDIO_InitStruct-&gt;SDIO_BusWide = SDIO_BusWide_1b;
+  SDIO_InitStruct-&gt;SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_ClockCmd
+* Description    : Enables or disables the SDIO Clock.
+* Input          : NewState: new state of the SDIO Clock.
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_ClockCmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) CLKCR_CLKEN_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_SetPowerState
+* Description    : Sets the power status of the controller.
+* Input          : SDIO_PowerState: new state of the Power state. 
+*                  This parameter can be one of the following values:
+*                   - SDIO_PowerState_OFF
+*                   - SDIO_PowerState_ON
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_SetPowerState(u32 SDIO_PowerState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
+  
+  SDIO-&gt;POWER &amp;= PWR_PWRCTRL_MASK;
+  SDIO-&gt;POWER |= SDIO_PowerState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_GetPowerState
+* Description    : Gets the power status of the controller.
+* Input          : None
+* Output         : None
+* Return         : Power status of the controller. The returned value can
+*                  be one of the following:
+*                       - 0x00: Power OFF
+*                       - 0x02: Power UP
+*                       - 0x03: Power ON 
+*******************************************************************************/
+u32 SDIO_GetPowerState(void)
+{
+  return (SDIO-&gt;POWER &amp; (~PWR_PWRCTRL_MASK));
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_ITConfig
+* Description    : Enables or disables the SDIO interrupts.
+* Input          : - SDIO_IT: specifies the SDIO interrupt sources to be 
+*                    enabled or disabled.
+*                    This parameter can be one or a combination of the following
+*                    values:
+*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
+*                                          failed) interrupt    
+*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
+*                                          failed) interrupt    
+*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
+*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
+*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
+*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
+*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
+*                                          passed) interrupt     
+*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
+*                                          interrupt     
+*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
+*                                          zero) interrupt     
+*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
+*                                          signals in wide bus mode interrupt    
+*                      - SDIO_IT_DBCKEND:  Data block sent/received (CRC check 
+*                                          passed) interrupt    
+*                      - SDIO_IT_CMDACT:   Command transfer in progress interrupt     
+*                      - SDIO_IT_TXACT:    Data transmit in progress interrupt       
+*                      - SDIO_IT_RXACT:    Data receive in progress interrupt      
+*                      - SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt    
+*                      - SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt   
+*                      - SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt     
+*                      - SDIO_IT_RXFIFOF:  Receive FIFO full interrupt     
+*                      - SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt      
+*                      - SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt     
+*                      - SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt      
+*                      - SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt      
+*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
+*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
+*                                          received for CMD61 interrupt
+*                  - NewState: new state of the specified SDIO interrupts.
+*                  This parameter can be: ENABLE or DISABLE.  
+* Output         : None
+* Return         : None 
+*******************************************************************************/
+void SDIO_ITConfig(u32 SDIO_IT, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_IT(SDIO_IT));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the SDIO interrupts */
+    SDIO-&gt;MASK |= SDIO_IT;
+  }
+  else
+  {
+    /* Disable the SDIO interrupts */
+    SDIO-&gt;MASK &amp;= ~SDIO_IT;
+  } 
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_DMACmd
+* Description    : Enables or disables the SDIO DMA request.
+* Input          : NewState: new state of the selected SDIO DMA request.
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_DMACmd(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) DCTRL_DMAEN_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_SendCommand
+* Description    : Initializes the SDIO Command according to the specified 
+*                  parameters in the SDIO_CmdInitStruct and send the command.
+* Input          : SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
+*                  structure that contains the configuration information 
+*                  for the SDIO command.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
+{
+  u32 tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct-&gt;SDIO_CmdIndex));
+  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct-&gt;SDIO_Response));
+  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct-&gt;SDIO_Wait));
+  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct-&gt;SDIO_CPSM));
+  
+/*---------------------------- SDIO ARG Configuration ------------------------*/
+  /* Set the SDIO Argument value */
+  SDIO-&gt;ARG = SDIO_CmdInitStruct-&gt;SDIO_Argument;
+  
+/*---------------------------- SDIO CMD Configuration ------------------------*/  
+  /* Get the SDIO CMD value */
+  tmpreg = SDIO-&gt;CMD;
+
+  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
+  tmpreg &amp;= CMD_CLEAR_MASK;
+  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
+  /* Set WAITRESP bits according to SDIO_Response value */
+  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
+  /* Set CPSMEN bits according to SDIO_CPSM value */
+  tmpreg |= (u32)SDIO_CmdInitStruct-&gt;SDIO_CmdIndex | SDIO_CmdInitStruct-&gt;SDIO_Response
+           | SDIO_CmdInitStruct-&gt;SDIO_Wait | SDIO_CmdInitStruct-&gt;SDIO_CPSM;
+  
+  /* Write to SDIO CMD */
+  SDIO-&gt;CMD = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_CmdStructInit
+* Description    : Fills each SDIO_CmdInitStruct member with its default value.
+* Input          : SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
+*                  structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
+{
+  /* SDIO_CmdInitStruct members default value */
+  SDIO_CmdInitStruct-&gt;SDIO_Argument = 0x00;
+  SDIO_CmdInitStruct-&gt;SDIO_CmdIndex = 0x00;
+  SDIO_CmdInitStruct-&gt;SDIO_Response = SDIO_Response_No;
+  SDIO_CmdInitStruct-&gt;SDIO_Wait = SDIO_Wait_No;
+  SDIO_CmdInitStruct-&gt;SDIO_CPSM = SDIO_CPSM_Disable;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_GetCommandResponse
+* Description    : Returns command index of last command for which response 
+*                  received.
+* Input          : None
+* Output         : None
+* Return         : Returns the command index of the last command response received.
+*******************************************************************************/
+u8 SDIO_GetCommandResponse(void)
+{
+  return (u8)(SDIO-&gt;RESPCMD);
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_GetResponse
+* Description    : Returns response received from the card for the last command.
+* Input          : - SDIO_RESP: Specifies the SDIO response register. 
+*                     This parameter can be one of the following values:
+*                       - SDIO_RESP1: Response Register 1
+*                       - SDIO_RESP2: Response Register 2
+*                       - SDIO_RESP3: Response Register 3
+*                       - SDIO_RESP4: Response Register 4                       
+* Output         : None
+* Return         : The Corresponding response register value.
+*******************************************************************************/
+u32 SDIO_GetResponse(u32 SDIO_RESP)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_RESP(SDIO_RESP));
+  
+  return (*(vu32 *)(SDIO_RESP_ADDR + SDIO_RESP)); 
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_DataConfig
+* Description    : Initializes the SDIO data path according to the specified 
+*                  parameters in the SDIO_DataInitStruct.
+* Input          : SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef 
+*                  structure that contains the configuration information 
+*                  for the SDIO command.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  u32 tmpreg = 0;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct-&gt;SDIO_DataLength));
+  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct-&gt;SDIO_DataBlockSize));
+  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct-&gt;SDIO_TransferDir));
+  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct-&gt;SDIO_TransferMode));
+  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct-&gt;SDIO_DPSM));
+
+/*---------------------------- SDIO DTIMER Configuration ---------------------*/
+  /* Set the SDIO Data TimeOut value */
+  SDIO-&gt;DTIMER = SDIO_DataInitStruct-&gt;SDIO_DataTimeOut;
+    
+/*---------------------------- SDIO DLEN Configuration -----------------------*/
+  /* Set the SDIO DataLength value */
+  SDIO-&gt;DLEN = SDIO_DataInitStruct-&gt;SDIO_DataLength;
+  
+/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
+  /* Get the SDIO DCTRL value */
+  tmpreg = SDIO-&gt;DCTRL;
+
+  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
+  tmpreg &amp;= DCTRL_CLEAR_MASK;
+  /* Set DEN bit according to SDIO_DPSM value */
+  /* Set DTMODE bit according to SDIO_TransferMode value */
+  /* Set DTDIR bit according to SDIO_TransferDir value */
+  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
+  tmpreg |= (u32)SDIO_DataInitStruct-&gt;SDIO_DataBlockSize | SDIO_DataInitStruct-&gt;SDIO_TransferDir
+           | SDIO_DataInitStruct-&gt;SDIO_TransferMode | SDIO_DataInitStruct-&gt;SDIO_DPSM;
+  
+  /* Write to SDIO DCTRL */
+  SDIO-&gt;DCTRL = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_DataStructInit
+* Description    : Fills each SDIO_DataInitStruct member with its default value.
+* Input          : SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef 
+*                  structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
+{
+  /* SDIO_DataInitStruct members default value */
+  SDIO_DataInitStruct-&gt;SDIO_DataTimeOut = 0xFFFFFFFF;
+  SDIO_DataInitStruct-&gt;SDIO_DataLength = 0x00;
+  SDIO_DataInitStruct-&gt;SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
+  SDIO_DataInitStruct-&gt;SDIO_TransferDir = SDIO_TransferDir_ToCard;
+  SDIO_DataInitStruct-&gt;SDIO_TransferMode = SDIO_TransferMode_Block;  
+  SDIO_DataInitStruct-&gt;SDIO_DPSM = SDIO_DPSM_Disable;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_GetDataCounter
+* Description    : Returns number of remaining data bytes to be transferred.
+* Input          : None
+* Output         : None
+* Return         : Number of remaining data bytes to be transferred
+*******************************************************************************/
+u32 SDIO_GetDataCounter(void)
+{ 
+  return SDIO-&gt;DCOUNT;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_ReadData
+* Description    : Read one data word from Rx FIFO.
+* Input          : None
+* Output         : None
+* Return         : Data received
+*******************************************************************************/
+u32 SDIO_ReadData(void)
+{ 
+  return SDIO-&gt;FIFO;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_WriteData
+* Description    : Write one data word to Tx FIFO.
+* Input          : Data: 32-bit data word to write.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_WriteData(u32 Data)
+{ 
+  SDIO-&gt;FIFO = Data;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_GetFIFOCount
+* Description    : Returns the number of words left to be written to or read
+*                  from FIFO.	
+* Input          : None
+* Output         : None
+* Return         : Remaining number of words.
+*******************************************************************************/
+u32 SDIO_GetFIFOCount(void)
+{ 
+  return SDIO-&gt;FIFOCNT;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_StartSDIOReadWait
+* Description    : Starts the SD I/O Read Wait operation.	
+* Input          : NewState: new state of the Start SDIO Read Wait operation. 
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_StartSDIOReadWait(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) DCTRL_RWSTART_BB = (u32) NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_StopSDIOReadWait
+* Description    : Stops the SD I/O Read Wait operation.	
+* Input          : NewState: new state of the Stop SDIO Read Wait operation. 
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_StopSDIOReadWait(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) DCTRL_RWSTOP_BB = (u32) NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_SetSDIOReadWaitMode
+* Description    : Sets one of the two options of inserting read wait interval.	
+* Input          : SDIOReadWaitMode: SD I/O Read Wait operation mode.
+*                  This parametre can be:
+*                    - SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
+*                    - SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_SetSDIOReadWaitMode(u32 SDIO_ReadWaitMode)
+{
+  /* Check the parameters */
+  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
+  
+  *(vu32 *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_SetSDIOOperation
+* Description    : Enables or disables the SD I/O Mode Operation.	
+* Input          : NewState: new state of SDIO specific operation. 
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_SetSDIOOperation(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) DCTRL_SDIOEN_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_SendSDIOSuspendCmd
+* Description    : Enables or disables the SD I/O Mode suspend command sending.
+* Input          : NewState: new state of the SD I/O Mode suspend command.
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) CMD_SDIOSUSPEND_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_CommandCompletionCmd
+* Description    : Enables or disables the command completion signal.
+* Input          : NewState: new state of command completion signal. 
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_CommandCompletionCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) CMD_ENCMDCOMPL_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_CEATAITCmd
+* Description    : Enables or disables the CE-ATA interrupt.
+* Input          : NewState: new state of CE-ATA interrupt. 
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_CEATAITCmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) CMD_NIEN_BB = (u32)((~((u32)NewState)) &amp; ((u32)0x1));
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_SendCEATACmd
+* Description    : Sends CE-ATA command (CMD61).
+* Input          : NewState: new state of CE-ATA command. 
+*                  This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_SendCEATACmd(FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  *(vu32 *) CMD_ATACMD_BB = (u32)NewState;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_GetFlagStatus
+* Description    : Checks whether the specified SDIO flag is set or not.	
+* Input          : SDIO_FLAG: specifies the flag to check. 
+*                  This parameter can be one of the following values:
+*                     - SDIO_FLAG_CCRCFAIL: Command response received (CRC check
+*                                           failed)    
+*                     - SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check 
+*                                           failed)    
+*                     - SDIO_FLAG_CTIMEOUT: Command response timeout    
+*                     - SDIO_FLAG_DTIMEOUT: Data timeou   
+*                     - SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error   
+*                     - SDIO_FLAG_RXOVERR:  Received FIFO overrun error    
+*                     - SDIO_FLAG_CMDREND:  Command response received (CRC check 
+*                                           passed)    
+*                     - SDIO_FLAG_CMDSENT:  Command sent (no response required)    
+*                     - SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is
+*                                           zero)    
+*                     - SDIO_FLAG_STBITERR: Start bit not detected on all data 
+*                                           signals in wide bus mode   
+*                     - SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check 
+*                                           passed)    
+*                     - SDIO_FLAG_CMDACT:   Command transfer in progress     
+*                     - SDIO_FLAG_TXACT:    Data transmit in progress      
+*                     - SDIO_FLAG_RXACT:    Data receive in progress      
+*                     - SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty   
+*                     - SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full   
+*                     - SDIO_FLAG_TXFIFOF:  Transmit FIFO full    
+*                     - SDIO_FLAG_RXFIFOF:  Receive FIFO full     
+*                     - SDIO_FLAG_TXFIFOE:  Transmit FIFO empty    
+*                     - SDIO_FLAG_RXFIFOE:  Receive FIFO empty    
+*                     - SDIO_FLAG_TXDAVL:   Data available in transmit FIFO     
+*                     - SDIO_FLAG_RXDAVL:   Data available in receive FIFO     
+*                     - SDIO_FLAG_SDIOIT:   SD I/O interrupt received     
+*                     - SDIO_FLAG_CEATAEND: CE-ATA command completion signal 
+*                                           received for CMD61    
+* Output         : None
+* Return         : The new state of SDIO_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus SDIO_GetFlagStatus(u32 SDIO_FLAG)
+{ 
+  FlagStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
+  
+  if ((SDIO-&gt;STA &amp; SDIO_FLAG) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_ClearFlag
+* Description    : Clears the SDIO's pending flags.	
+* Input          : SDIO_FLAG: specifies the flag to clear.  
+*                  This parameter can be one or a combination of the following
+*                  values:
+*                     - SDIO_FLAG_CCRCFAIL: Command response received (CRC check
+*                                           failed)    
+*                     - SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check 
+*                                           failed)    
+*                     - SDIO_FLAG_CTIMEOUT: Command response timeout    
+*                     - SDIO_FLAG_DTIMEOUT: Data timeou   
+*                     - SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error   
+*                     - SDIO_FLAG_RXOVERR:  Received FIFO overrun error    
+*                     - SDIO_FLAG_CMDREND:  Command response received (CRC check 
+*                                           passed)    
+*                     - SDIO_FLAG_CMDSENT:  Command sent (no response required)    
+*                     - SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is
+*                                           zero)    
+*                     - SDIO_FLAG_STBITERR: Start bit not detected on all data 
+*                                           signals in wide bus mode   
+*                     - SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check 
+*                                           passed)         
+*                     - SDIO_FLAG_SDIOIT:   SD I/O interrupt received     
+*                     - SDIO_FLAG_CEATAEND: CE-ATA command completion signal 
+*                                           received for CMD61    
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_ClearFlag(u32 SDIO_FLAG)
+{ 
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
+   
+  SDIO-&gt;ICR = SDIO_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_GetITStatus
+* Description    : Checks whether the specified SDIO interrupt has occurred or not.	
+* Input          : SDIO_IT: specifies the SDIO interrupt source to check. 
+*                  This parameter can be one of the following values:
+*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
+*                                          failed) interrupt    
+*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
+*                                          failed) interrupt    
+*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
+*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
+*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
+*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
+*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
+*                                          passed) interrupt     
+*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
+*                                          interrupt     
+*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
+*                                          zero) interrupt     
+*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
+*                                          signals in wide bus mode interrupt    
+*                      - SDIO_IT_DBCKEND:  Data block sent/received (CRC check 
+*                                          passed) interrupt    
+*                      - SDIO_IT_CMDACT:   Command transfer in progress interrupt     
+*                      - SDIO_IT_TXACT:    Data transmit in progress interrupt       
+*                      - SDIO_IT_RXACT:    Data receive in progress interrupt      
+*                      - SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt    
+*                      - SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt   
+*                      - SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt     
+*                      - SDIO_IT_RXFIFOF:  Receive FIFO full interrupt     
+*                      - SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt      
+*                      - SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt     
+*                      - SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt      
+*                      - SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt      
+*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
+*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
+*                                          received for CMD61 interrupt
+* Output         : None
+* Return         : The new state of SDIO_IT (SET or RESET).
+*******************************************************************************/
+ITStatus SDIO_GetITStatus(u32 SDIO_IT)
+{ 
+  ITStatus bitstatus = RESET;
+  
+  /* Check the parameters */
+  assert_param(IS_SDIO_GET_IT(SDIO_IT));
+
+  if ((SDIO-&gt;STA &amp; SDIO_IT) != (u32)RESET)  
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : SDIO_ClearITPendingBit
+* Description    : Clears the SDIO's interrupt pending bits.	
+* Input          : SDIO_IT: specifies the interrupt pending bit to clear. 
+*                   This parameter can be one or a combination of the following
+*                   values:
+*                      - SDIO_IT_CCRCFAIL: Command response received (CRC check
+*                                          failed) interrupt    
+*                      - SDIO_IT_DCRCFAIL: Data block sent/received (CRC check 
+*                                          failed) interrupt    
+*                      - SDIO_IT_CTIMEOUT: Command response timeout interrupt    
+*                      - SDIO_IT_DTIMEOUT: Data timeout interrupt    
+*                      - SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt    
+*                      - SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt     
+*                      - SDIO_IT_CMDREND:  Command response received (CRC check 
+*                                          passed) interrupt     
+*                      - SDIO_IT_CMDSENT:  Command sent (no response required) 
+*                                          interrupt     
+*                      - SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is 
+*                                          zero) interrupt     
+*                      - SDIO_IT_STBITERR: Start bit not detected on all data 
+*                                          signals in wide bus mode interrupt          
+*                      - SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt      
+*                      - SDIO_IT_CEATAEND: CE-ATA command completion signal 
+*                                          received for CMD61 
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SDIO_ClearITPendingBit(u32 SDIO_IT)
+{ 
+  /* Check the parameters */
+  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
+   
+  SDIO-&gt;ICR = SDIO_IT;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_spi.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,863 +1,863 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_spi.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the SPI firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_spi.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* SPI SPE mask */
-#define CR1_SPE_Set          ((u16)0x0040)
-#define CR1_SPE_Reset        ((u16)0xFFBF)
-
-/* I2S I2SE mask */
-#define I2SCFGR_I2SE_Set     ((u16)0x0400)
-#define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
-
-/* SPI CRCNext mask */
-#define CR1_CRCNext_Set      ((u16)0x1000)
-
-/* SPI CRCEN mask */
-#define CR1_CRCEN_Set        ((u16)0x2000)
-#define CR1_CRCEN_Reset      ((u16)0xDFFF)
-
-/* SPI SSOE mask */
-#define CR2_SSOE_Set         ((u16)0x0004)
-#define CR2_SSOE_Reset       ((u16)0xFFFB)
-
-/* SPI registers Masks */
-#define CR1_CLEAR_Mask       ((u16)0x3040)
-#define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
-
-/* SPI or I2S mode selection masks */
-#define SPI_Mode_Select      ((u16)0xF7FF)
-#define I2S_Mode_Select      ((u16)0x0800) 
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_DeInit
-* Description    : Deinitializes the SPIx peripheral registers to their default
-*                  reset values (Affects also the I2Ss).
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  switch (*(u32*)&amp;SPIx)
-  {
-    case SPI1_BASE:
-      /* Enable SPI1 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
-      /* Release SPI1 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
-      break;
-
-    case SPI2_BASE:
-      /* Enable SPI2 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
-      /* Release SPI2 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
-      break;
-
-    case SPI3_BASE:
-      /* Enable SPI3 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
-      /* Release SPI3 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
-      break;
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_Init
-* Description    : Initializes the SPIx peripheral according to the specified 
-*                  parameters in the SPI_InitStruct.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    SPI peripheral.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
-{
-  u16 tmpreg = 0;
-  
-  /* check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));   
-  
-  /* Check the SPI parameters */
-  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct-&gt;SPI_Direction));
-  assert_param(IS_SPI_MODE(SPI_InitStruct-&gt;SPI_Mode));
-  assert_param(IS_SPI_DATASIZE(SPI_InitStruct-&gt;SPI_DataSize));
-  assert_param(IS_SPI_CPOL(SPI_InitStruct-&gt;SPI_CPOL));
-  assert_param(IS_SPI_CPHA(SPI_InitStruct-&gt;SPI_CPHA));
-  assert_param(IS_SPI_NSS(SPI_InitStruct-&gt;SPI_NSS));
-  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct-&gt;SPI_BaudRatePrescaler));
-  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct-&gt;SPI_FirstBit));
-  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct-&gt;SPI_CRCPolynomial));
-
-/*---------------------------- SPIx CR1 Configuration ------------------------*/
-  /* Get the SPIx CR1 value */
-  tmpreg = SPIx-&gt;CR1;
-  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
-  tmpreg &amp;= CR1_CLEAR_Mask;
-  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
-     master/salve mode, CPOL and CPHA */
-  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
-  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
-  /* Set LSBFirst bit according to SPI_FirstBit value */
-  /* Set BR bits according to SPI_BaudRatePrescaler value */
-  /* Set CPOL bit according to SPI_CPOL value */
-  /* Set CPHA bit according to SPI_CPHA value */
-  tmpreg |= (u16)((u32)SPI_InitStruct-&gt;SPI_Direction | SPI_InitStruct-&gt;SPI_Mode |
-                  SPI_InitStruct-&gt;SPI_DataSize | SPI_InitStruct-&gt;SPI_CPOL |  
-                  SPI_InitStruct-&gt;SPI_CPHA | SPI_InitStruct-&gt;SPI_NSS |  
-                  SPI_InitStruct-&gt;SPI_BaudRatePrescaler | SPI_InitStruct-&gt;SPI_FirstBit);
-  /* Write to SPIx CR1 */
-  SPIx-&gt;CR1 = tmpreg;
-  
-  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
-  SPIx-&gt;I2SCFGR &amp;= SPI_Mode_Select;		
-
-/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
-  /* Write to SPIx CRCPOLY */
-  SPIx-&gt;CRCPR = SPI_InitStruct-&gt;SPI_CRCPolynomial;
-}
-
-/*******************************************************************************
-* Function Name  : I2S_Init
-* Description    : Initializes the SPIx peripheral according to the specified 
-*                  parameters in the I2S_InitStruct.
-* Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
-*                     (configured in I2S mode).
-*                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
-*                    contains the configuration information for the specified
-*                    SPI peripheral configured in I2S mode.
-* Output         : None
-* Return         : None
-******************************************************************************/
-void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
-{
-  u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
-  u32 tmp = 0;
-  RCC_ClocksTypeDef RCC_Clocks;
-   
-  /* Check the I2S parameters */
-  assert_param(IS_SPI_23_PERIPH(SPIx));
-  assert_param(IS_I2S_MODE(I2S_InitStruct-&gt;I2S_Mode));
-  assert_param(IS_I2S_STANDARD(I2S_InitStruct-&gt;I2S_Standard));
-  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct-&gt;I2S_DataFormat));
-  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct-&gt;I2S_MCLKOutput));
-  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct-&gt;I2S_AudioFreq));
-  assert_param(IS_I2S_CPOL(I2S_InitStruct-&gt;I2S_CPOL));  
-
-/*----------------------- SPIx I2SCFGR &amp; I2SPR Configuration -----------------*/
-
-  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
-  SPIx-&gt;I2SCFGR &amp;= I2SCFGR_CLEAR_Mask; 
-  SPIx-&gt;I2SPR = 0x0002;
-  
-  /* Get the I2SCFGR register value */
-  tmpreg = SPIx-&gt;I2SCFGR;
-  
-  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
-  if(I2S_InitStruct-&gt;I2S_AudioFreq == I2S_AudioFreq_Default)
-  {
-    i2sodd = (u16)0;
-    i2sdiv = (u16)2;   
-  }
-  /* If the requested audio frequency is not the default, compute the prescaler */
-  else
-  {
-    /* Check the frame length (For the Prescaler computing) */
-    if(I2S_InitStruct-&gt;I2S_DataFormat == I2S_DataFormat_16b)
-    {
-      /* Packet length is 16 bits */
-      packetlength = 1;
-    }
-    else
-    {
-      /* Packet length is 32 bits */
-      packetlength = 2;
-    }
-    /* Get System Clock frequency */
-    RCC_GetClocksFreq(&amp;RCC_Clocks);
-    
-    /* Compute the Real divider depending on the MCLK output state with a flaoting point */
-    if(I2S_InitStruct-&gt;I2S_MCLKOutput == I2S_MCLKOutput_Enable)
-    {
-      /* MCLK output is enabled */
-      tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
-    }
-    else
-    {
-      /* MCLK output is disabled */
-      tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
-    }
-    
-    /* Remove the flaoting point */
-    tmp = tmp/10;  
-      
-    /* Check the parity of the divider */
-    i2sodd = (u16)(tmp &amp; (u16)0x0001);
-   
-    /* Compute the i2sdiv prescaler */
-    i2sdiv = (u16)((tmp - i2sodd) / 2);
-   
-    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
-    i2sodd = (u16) (i2sodd &lt;&lt; 8);
-  }
-  
-  /* Test if the divider is 1 or 0 */
-  if ((i2sdiv &lt; 2) || (i2sdiv &gt; 0xFF))
-  {
-    /* Set the default values */
-    i2sdiv = 2;
-    i2sodd = 0;
-  }
-
-  /* Write to SPIx I2SPR register the computed value */
-  SPIx-&gt;I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct-&gt;I2S_MCLKOutput);  
- 
-  /* Configure the I2S with the SPI_InitStruct values */
-  tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct-&gt;I2S_Mode | \
-                  I2S_InitStruct-&gt;I2S_Standard | I2S_InitStruct-&gt;I2S_DataFormat | \
-                  I2S_InitStruct-&gt;I2S_CPOL);
- 
-  /* Write to SPIx I2SCFGR */  
-  SPIx-&gt;I2SCFGR = tmpreg;                                    
-}
-
-/*******************************************************************************
-* Function Name  : SPI_StructInit
-* Description    : Fills each SPI_InitStruct member with its default value.
-* Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
-{
-/*--------------- Reset SPI init structure parameters values -----------------*/
-  /* Initialize the SPI_Direction member */
-  SPI_InitStruct-&gt;SPI_Direction = SPI_Direction_2Lines_FullDuplex;
-
-  /* initialize the SPI_Mode member */
-  SPI_InitStruct-&gt;SPI_Mode = SPI_Mode_Slave;
-
-  /* initialize the SPI_DataSize member */
-  SPI_InitStruct-&gt;SPI_DataSize = SPI_DataSize_8b;
-
-  /* Initialize the SPI_CPOL member */
-  SPI_InitStruct-&gt;SPI_CPOL = SPI_CPOL_Low;
-
-  /* Initialize the SPI_CPHA member */
-  SPI_InitStruct-&gt;SPI_CPHA = SPI_CPHA_1Edge;
-
-  /* Initialize the SPI_NSS member */
-  SPI_InitStruct-&gt;SPI_NSS = SPI_NSS_Hard;
-
-  /* Initialize the SPI_BaudRatePrescaler member */
-  SPI_InitStruct-&gt;SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
-
-  /* Initialize the SPI_FirstBit member */
-  SPI_InitStruct-&gt;SPI_FirstBit = SPI_FirstBit_MSB;
-
-  /* Initialize the SPI_CRCPolynomial member */
-  SPI_InitStruct-&gt;SPI_CRCPolynomial = 7;
-}
-
-/*******************************************************************************
-* Function Name  : I2S_StructInit
-* Description    : Fills each I2S_InitStruct member with its default value.
-* Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
-{
-/*--------------- Reset I2S init structure parameters values -----------------*/
-  /* Initialize the I2S_Mode member */
-  I2S_InitStruct-&gt;I2S_Mode = I2S_Mode_SlaveTx;
-  
-  /* Initialize the I2S_Standard member */
-  I2S_InitStruct-&gt;I2S_Standard = I2S_Standard_Phillips;
-  
-  /* Initialize the I2S_DataFormat member */
-  I2S_InitStruct-&gt;I2S_DataFormat = I2S_DataFormat_16b;
-  
-  /* Initialize the I2S_MCLKOutput member */
-  I2S_InitStruct-&gt;I2S_MCLKOutput = I2S_MCLKOutput_Disable;
-  
-  /* Initialize the I2S_AudioFreq member */
-  I2S_InitStruct-&gt;I2S_AudioFreq = I2S_AudioFreq_Default;
-  
-  /* Initialize the I2S_CPOL member */
-  I2S_InitStruct-&gt;I2S_CPOL = I2S_CPOL_Low;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_Cmd
-* Description    : Enables or disables the specified SPI peripheral.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx peripheral. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI peripheral */
-    SPIx-&gt;CR1 |= CR1_SPE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI peripheral */
-    SPIx-&gt;CR1 &amp;= CR1_SPE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : I2S_Cmd
-* Description    : Enables or disables the specified SPI peripheral (in I2S mode).
-* Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx peripheral. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_23_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI peripheral (in I2S mode) */
-    SPIx-&gt;I2SCFGR |= I2SCFGR_I2SE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI peripheral (in I2S mode) */
-    SPIx-&gt;I2SCFGR &amp;= I2SCFGR_I2SE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ITConfig
-* Description    : Enables or disables the specified SPI/I2S interrupts.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
-*                    enabled or disabled. 
-*                    This parameter can be one of the following values:
-*                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
-*                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
-*                       - SPI_I2S_IT_ERR: Error interrupt mask
-*                  - NewState: new state of the specified SPI/I2S interrupt.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
-{
-  u16 itpos = 0, itmask = 0 ;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
-
-  /* Get the SPI/I2S IT index */
-  itpos = SPI_I2S_IT &gt;&gt; 4;
-  /* Set the IT mask */
-  itmask = (u16)((u16)1 &lt;&lt; itpos);
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI/I2S interrupt */
-    SPIx-&gt;CR2 |= itmask;
-  }
-  else
-  {
-    /* Disable the selected SPI/I2S interrupt */
-    SPIx-&gt;CR2 &amp;= (u16)~itmask;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_DMACmd
-* Description    : Enables or disables the SPIx/I2Sx DMA interface.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
-*                    to be enabled or disabled. 
-*                    This parameter can be any combination of the following values:
-*                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
-*                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
-*                  - NewState: new state of the selected SPI/I2S DMA transfer 
-*                    request.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI/I2S DMA requests */
-    SPIx-&gt;CR2 |= SPI_I2S_DMAReq;
-  }
-  else
-  {
-    /* Disable the selected SPI/I2S DMA requests */
-    SPIx-&gt;CR2 &amp;= (u16)~SPI_I2S_DMAReq;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_SendData
-* Description    : Transmits a Data through the SPIx/I2Sx peripheral.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - Data : Data to be transmitted..
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Write in the DR register the data to be sent */
-  SPIx-&gt;DR = Data;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ReceiveData
-* Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-* Output         : None
-* Return         : The value of the received data.
-*******************************************************************************/
-u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Return the data in the DR register */
-  return SPIx-&gt;DR;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_NSSInternalSoftwareConfig
-* Description    : Configures internally by software the NSS pin for the selected 
-*                  SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
-*                    This parameter can be one of the following values:
-*                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
-*                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
-
-  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
-  {
-    /* Set NSS pin internally by software */
-    SPIx-&gt;CR1 |= SPI_NSSInternalSoft_Set;
-  }
-  else
-  {
-    /* Reset NSS pin internally by software */
-    SPIx-&gt;CR1 &amp;= SPI_NSSInternalSoft_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_SSOutputCmd
-* Description    : Enables or disables the SS output for the selected SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx SS output. 
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI SS output */
-    SPIx-&gt;CR2 |= CR2_SSOE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI SS output */
-    SPIx-&gt;CR2 &amp;= CR2_SSOE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_DataSizeConfig
-* Description    : Configures the data size for the selected SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_DataSize: specifies the SPI data size.
-*                    This parameter can be one of the following values:
-*                       - SPI_DataSize_16b: Set data frame format to 16bit
-*                       - SPI_DataSize_8b: Set data frame format to 8bit
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
-
-  /* Clear DFF bit */
-  SPIx-&gt;CR1 &amp;= (u16)~SPI_DataSize_16b;
-  /* Set new DFF bit value */
-  SPIx-&gt;CR1 |= SPI_DataSize;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_TransmitCRC
-* Description    : Transmit the SPIx CRC value.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_TransmitCRC(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Enable the selected SPI CRC transmission */
-  SPIx-&gt;CR1 |= CR1_CRCNext_Set;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_CalculateCRC
-* Description    : Enables or disables the CRC value calculation of the
-*                  transfered bytes.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - NewState: new state of the SPIx CRC value calculation.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI CRC calculation */
-    SPIx-&gt;CR1 |= CR1_CRCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI CRC calculation */
-    SPIx-&gt;CR1 &amp;= CR1_CRCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_GetCRC
-* Description    : Returns the transmit or the receive CRC register value for
-*                  the specified SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_CRC: specifies the CRC register to be read.
-*                    This parameter can be one of the following values:
-*                       - SPI_CRC_Tx: Selects Tx CRC register
-*                       - SPI_CRC_Rx: Selects Rx CRC register
-* Output         : None
-* Return         : The selected CRC register value..
-*******************************************************************************/
-u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
-{
-  u16 crcreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_CRC(SPI_CRC));
-
-  if (SPI_CRC != SPI_CRC_Rx)
-  {
-    /* Get the Tx CRC register */
-    crcreg = SPIx-&gt;TXCRCR;
-  }
-  else
-  {
-    /* Get the Rx CRC register */
-    crcreg = SPIx-&gt;RXCRCR;
-  }
-
-  /* Return the selected CRC register */
-  return crcreg;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_GetCRCPolynomial
-* Description    : Returns the CRC Polynomial register value for the specified SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-* Output         : None
-* Return         : The CRC Polynomial register value.
-*******************************************************************************/
-u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Return the CRC polynomial register */
-  return SPIx-&gt;CRCPR;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_BiDirectionalLineConfig
-* Description    : Selects the data transfer direction in bi-directional mode
-*                  for the specified SPI.
-* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-*                  - SPI_Direction: specifies the data transfer direction in
-*                    bi-directional mode. 
-*                    This parameter can be one of the following values:
-*                       - SPI_Direction_Tx: Selects Tx transmission direction
-*                       - SPI_Direction_Rx: Selects Rx receive direction
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_DIRECTION(SPI_Direction));
-
-  if (SPI_Direction == SPI_Direction_Tx)
-  {
-    /* Set the Tx only mode */
-    SPIx-&gt;CR1 |= SPI_Direction_Tx;
-  }
-  else
-  {
-    /* Set the Rx only mode */
-    SPIx-&gt;CR1 &amp;= SPI_Direction_Rx;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_GetFlagStatus
-* Description    : Checks whether the specified SPI/I2S flag is set or not.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
-*                    This parameter can be one of the following values:
-*                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
-*                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
-*                       - SPI_I2S_FLAG_BSY: Busy flag.
-*                       - SPI_I2S_FLAG_OVR: Overrun flag.
-*                       - SPI_FLAG_MODF: Mode Fault flag.
-*                       - SPI_FLAG_CRCERR: CRC Error flag.
-*                       - I2S_FLAG_UDR: Underrun Error flag.
-*                       - I2S_FLAG_CHSIDE: Channel Side flag.
-* Output         : None
-* Return         : The new state of SPI_I2S_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
-
-  /* Check the status of the specified SPI/I2S flag */
-  if ((SPIx-&gt;SR &amp; SPI_I2S_FLAG) != (u16)RESET)
-  {
-    /* SPI_I2S_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SPI_I2S_FLAG is reset */
-    bitstatus = RESET;
-  }
-  /* Return the SPI_I2S_FLAG status */
-  return  bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ClearFlag
-* Description    : Clears the SPIx CRC Error (CRCERR) flag.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                  - SPI_I2S_FLAG: specifies the SPI flag to clear. 
-*                    This function clears only CRCERR flag.                                           
-*                  Notes:
-*                       - OVR (OverRun error) flag is cleared by software 
-*                         sequence: a read operation to SPI_DR register 
-*                         (SPI_I2S_ReceiveData()) followed by a read operation 
-*                         to SPI_SR register (SPI_I2S_GetFlagStatus()).                           
-*                       - UDR (UnderRun error) flag is cleared by a read 
-*                         operation to SPI_SR register (SPI_I2S_GetFlagStatus()).                             
-*                       - MODF (Mode Fault) flag is cleared by software sequence: 
-*                         a read/write operation to SPI_SR register 
-*                         (SPI_I2S_GetFlagStatus()) followed by a write 
-*                         operation to SPI_CR1 register (SPI_Cmd() to enable 
-*                         the SPI).   
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
-    
-    /* Clear the selected SPI CRC Error (CRCERR) flag */
-    SPIx-&gt;SR = (u16)~SPI_I2S_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_GetITStatus
-* Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                         - 2 or 3 in I2S mode
-*                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
-*                    This parameter can be one of the following values:
-*                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
-*                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
-*                       - SPI_I2S_IT_OVR: Overrun interrupt.
-*                       - SPI_IT_MODF: Mode Fault interrupt.
-*                       - SPI_IT_CRCERR: CRC Error interrupt.
-*                       - I2S_IT_UDR: Underrun Error interrupt.
-* Output         : None
-* Return         : The new state of SPI_I2S_IT (SET or RESET).
-*******************************************************************************/
-ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
-{
-  ITStatus bitstatus = RESET;
-  u16 itpos = 0, itmask = 0, enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
-
-  /* Get the SPI/I2S IT index */
-  itpos = (u16)((u16)0x01 &lt;&lt; (SPI_I2S_IT &amp; (u8)0x0F));
-
-  /* Get the SPI/I2S IT mask */
-  itmask = SPI_I2S_IT &gt;&gt; 4;
-  /* Set the IT mask */
-  itmask = (u16)((u16)0x01 &lt;&lt; itmask);
-  /* Get the SPI_I2S_IT enable bit status */
-  enablestatus = (SPIx-&gt;CR2 &amp; itmask) ;
-
-  /* Check the status of the specified SPI/I2S interrupt */
-  if (((SPIx-&gt;SR &amp; itpos) != (u16)RESET) &amp;&amp; enablestatus)
-  {
-    /* SPI_I2S_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SPI_I2S_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the SPI_I2S_IT status */
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : SPI_I2S_ClearITPendingBit
-* Description    : Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
-* Input          : - SPIx: where x can be :
-*                         - 1, 2 or 3 in SPI mode 
-*                  - SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
-*                    This function clears only CRCERR intetrrupt pending bit.   
-*                  Notes:
-*                       - OVR (OverRun Error) interrupt pending bit is cleared 
-*                         by software sequence: a read operation to SPI_DR 
-*                         register (SPI_I2S_ReceiveData()) followed by a read 
-*                         operation to SPI_SR register (SPI_I2S_GetITStatus()).
-*                       - UDR (UnderRun Error) interrupt pending bit is cleared 
-*                         by a read operation to SPI_SR register 
-*                         (SPI_I2S_GetITStatus()).                           
-*                       - MODF (Mode Fault) interrupt pending bit is cleared by 
-*                         software sequence: a read/write operation to SPI_SR 
-*                         register (SPI_I2S_GetITStatus()) followed by a write 
-*                         operation to SPI_CR1 register (SPI_Cmd() to enable the 
-*                         SPI).   
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
-{
-  u16 itpos = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
-
-  /* Get the SPI IT index */
-  itpos = (u16)((u16)0x01 &lt;&lt; (SPI_I2S_IT &amp; (u8)0x0F));
-  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
-  SPIx-&gt;SR = (u16)~itpos;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_spi.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the SPI firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_spi.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* SPI SPE mask */
+#define CR1_SPE_Set          ((u16)0x0040)
+#define CR1_SPE_Reset        ((u16)0xFFBF)
+
+/* I2S I2SE mask */
+#define I2SCFGR_I2SE_Set     ((u16)0x0400)
+#define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
+
+/* SPI CRCNext mask */
+#define CR1_CRCNext_Set      ((u16)0x1000)
+
+/* SPI CRCEN mask */
+#define CR1_CRCEN_Set        ((u16)0x2000)
+#define CR1_CRCEN_Reset      ((u16)0xDFFF)
+
+/* SPI SSOE mask */
+#define CR2_SSOE_Set         ((u16)0x0004)
+#define CR2_SSOE_Reset       ((u16)0xFFFB)
+
+/* SPI registers Masks */
+#define CR1_CLEAR_Mask       ((u16)0x3040)
+#define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
+
+/* SPI or I2S mode selection masks */
+#define SPI_Mode_Select      ((u16)0xF7FF)
+#define I2S_Mode_Select      ((u16)0x0800) 
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_DeInit
+* Description    : Deinitializes the SPIx peripheral registers to their default
+*                  reset values (Affects also the I2Ss).
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  switch (*(u32*)&amp;SPIx)
+  {
+    case SPI1_BASE:
+      /* Enable SPI1 reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
+      /* Release SPI1 from reset state */
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
+      break;
+
+    case SPI2_BASE:
+      /* Enable SPI2 reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
+      /* Release SPI2 from reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
+      break;
+
+    case SPI3_BASE:
+      /* Enable SPI3 reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
+      /* Release SPI3 from reset state */
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
+      break;
+
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_Init
+* Description    : Initializes the SPIx peripheral according to the specified 
+*                  parameters in the SPI_InitStruct.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
+*                    contains the configuration information for the specified
+*                    SPI peripheral.
+* Output         : None
+* Return         : None
+******************************************************************************/
+void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
+{
+  u16 tmpreg = 0;
+  
+  /* check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));   
+  
+  /* Check the SPI parameters */
+  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct-&gt;SPI_Direction));
+  assert_param(IS_SPI_MODE(SPI_InitStruct-&gt;SPI_Mode));
+  assert_param(IS_SPI_DATASIZE(SPI_InitStruct-&gt;SPI_DataSize));
+  assert_param(IS_SPI_CPOL(SPI_InitStruct-&gt;SPI_CPOL));
+  assert_param(IS_SPI_CPHA(SPI_InitStruct-&gt;SPI_CPHA));
+  assert_param(IS_SPI_NSS(SPI_InitStruct-&gt;SPI_NSS));
+  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct-&gt;SPI_BaudRatePrescaler));
+  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct-&gt;SPI_FirstBit));
+  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct-&gt;SPI_CRCPolynomial));
+
+/*---------------------------- SPIx CR1 Configuration ------------------------*/
+  /* Get the SPIx CR1 value */
+  tmpreg = SPIx-&gt;CR1;
+  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
+  tmpreg &amp;= CR1_CLEAR_Mask;
+  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
+     master/salve mode, CPOL and CPHA */
+  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
+  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
+  /* Set LSBFirst bit according to SPI_FirstBit value */
+  /* Set BR bits according to SPI_BaudRatePrescaler value */
+  /* Set CPOL bit according to SPI_CPOL value */
+  /* Set CPHA bit according to SPI_CPHA value */
+  tmpreg |= (u16)((u32)SPI_InitStruct-&gt;SPI_Direction | SPI_InitStruct-&gt;SPI_Mode |
+                  SPI_InitStruct-&gt;SPI_DataSize | SPI_InitStruct-&gt;SPI_CPOL |  
+                  SPI_InitStruct-&gt;SPI_CPHA | SPI_InitStruct-&gt;SPI_NSS |  
+                  SPI_InitStruct-&gt;SPI_BaudRatePrescaler | SPI_InitStruct-&gt;SPI_FirstBit);
+  /* Write to SPIx CR1 */
+  SPIx-&gt;CR1 = tmpreg;
+  
+  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
+  SPIx-&gt;I2SCFGR &amp;= SPI_Mode_Select;		
+
+/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
+  /* Write to SPIx CRCPOLY */
+  SPIx-&gt;CRCPR = SPI_InitStruct-&gt;SPI_CRCPolynomial;
+}
+
+/*******************************************************************************
+* Function Name  : I2S_Init
+* Description    : Initializes the SPIx peripheral according to the specified 
+*                  parameters in the I2S_InitStruct.
+* Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
+*                     (configured in I2S mode).
+*                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
+*                    contains the configuration information for the specified
+*                    SPI peripheral configured in I2S mode.
+* Output         : None
+* Return         : None
+******************************************************************************/
+void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
+{
+  u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
+  u32 tmp = 0;
+  RCC_ClocksTypeDef RCC_Clocks;
+   
+  /* Check the I2S parameters */
+  assert_param(IS_SPI_23_PERIPH(SPIx));
+  assert_param(IS_I2S_MODE(I2S_InitStruct-&gt;I2S_Mode));
+  assert_param(IS_I2S_STANDARD(I2S_InitStruct-&gt;I2S_Standard));
+  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct-&gt;I2S_DataFormat));
+  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct-&gt;I2S_MCLKOutput));
+  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct-&gt;I2S_AudioFreq));
+  assert_param(IS_I2S_CPOL(I2S_InitStruct-&gt;I2S_CPOL));  
+
+/*----------------------- SPIx I2SCFGR &amp; I2SPR Configuration -----------------*/
+
+  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
+  SPIx-&gt;I2SCFGR &amp;= I2SCFGR_CLEAR_Mask; 
+  SPIx-&gt;I2SPR = 0x0002;
+  
+  /* Get the I2SCFGR register value */
+  tmpreg = SPIx-&gt;I2SCFGR;
+  
+  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
+  if(I2S_InitStruct-&gt;I2S_AudioFreq == I2S_AudioFreq_Default)
+  {
+    i2sodd = (u16)0;
+    i2sdiv = (u16)2;   
+  }
+  /* If the requested audio frequency is not the default, compute the prescaler */
+  else
+  {
+    /* Check the frame length (For the Prescaler computing) */
+    if(I2S_InitStruct-&gt;I2S_DataFormat == I2S_DataFormat_16b)
+    {
+      /* Packet length is 16 bits */
+      packetlength = 1;
+    }
+    else
+    {
+      /* Packet length is 32 bits */
+      packetlength = 2;
+    }
+    /* Get System Clock frequency */
+    RCC_GetClocksFreq(&amp;RCC_Clocks);
+    
+    /* Compute the Real divider depending on the MCLK output state with a flaoting point */
+    if(I2S_InitStruct-&gt;I2S_MCLKOutput == I2S_MCLKOutput_Enable)
+    {
+      /* MCLK output is enabled */
+      tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
+    }
+    else
+    {
+      /* MCLK output is disabled */
+      tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct-&gt;I2S_AudioFreq)) + 5);
+    }
+    
+    /* Remove the flaoting point */
+    tmp = tmp/10;  
+      
+    /* Check the parity of the divider */
+    i2sodd = (u16)(tmp &amp; (u16)0x0001);
+   
+    /* Compute the i2sdiv prescaler */
+    i2sdiv = (u16)((tmp - i2sodd) / 2);
+   
+    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
+    i2sodd = (u16) (i2sodd &lt;&lt; 8);
+  }
+  
+  /* Test if the divider is 1 or 0 */
+  if ((i2sdiv &lt; 2) || (i2sdiv &gt; 0xFF))
+  {
+    /* Set the default values */
+    i2sdiv = 2;
+    i2sodd = 0;
+  }
+
+  /* Write to SPIx I2SPR register the computed value */
+  SPIx-&gt;I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct-&gt;I2S_MCLKOutput);  
+ 
+  /* Configure the I2S with the SPI_InitStruct values */
+  tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct-&gt;I2S_Mode | \
+                  I2S_InitStruct-&gt;I2S_Standard | I2S_InitStruct-&gt;I2S_DataFormat | \
+                  I2S_InitStruct-&gt;I2S_CPOL);
+ 
+  /* Write to SPIx I2SCFGR */  
+  SPIx-&gt;I2SCFGR = tmpreg;                                    
+}
+
+/*******************************************************************************
+* Function Name  : SPI_StructInit
+* Description    : Fills each SPI_InitStruct member with its default value.
+* Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
+{
+/*--------------- Reset SPI init structure parameters values -----------------*/
+  /* Initialize the SPI_Direction member */
+  SPI_InitStruct-&gt;SPI_Direction = SPI_Direction_2Lines_FullDuplex;
+
+  /* initialize the SPI_Mode member */
+  SPI_InitStruct-&gt;SPI_Mode = SPI_Mode_Slave;
+
+  /* initialize the SPI_DataSize member */
+  SPI_InitStruct-&gt;SPI_DataSize = SPI_DataSize_8b;
+
+  /* Initialize the SPI_CPOL member */
+  SPI_InitStruct-&gt;SPI_CPOL = SPI_CPOL_Low;
+
+  /* Initialize the SPI_CPHA member */
+  SPI_InitStruct-&gt;SPI_CPHA = SPI_CPHA_1Edge;
+
+  /* Initialize the SPI_NSS member */
+  SPI_InitStruct-&gt;SPI_NSS = SPI_NSS_Hard;
+
+  /* Initialize the SPI_BaudRatePrescaler member */
+  SPI_InitStruct-&gt;SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
+
+  /* Initialize the SPI_FirstBit member */
+  SPI_InitStruct-&gt;SPI_FirstBit = SPI_FirstBit_MSB;
+
+  /* Initialize the SPI_CRCPolynomial member */
+  SPI_InitStruct-&gt;SPI_CRCPolynomial = 7;
+}
+
+/*******************************************************************************
+* Function Name  : I2S_StructInit
+* Description    : Fills each I2S_InitStruct member with its default value.
+* Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
+{
+/*--------------- Reset I2S init structure parameters values -----------------*/
+  /* Initialize the I2S_Mode member */
+  I2S_InitStruct-&gt;I2S_Mode = I2S_Mode_SlaveTx;
+  
+  /* Initialize the I2S_Standard member */
+  I2S_InitStruct-&gt;I2S_Standard = I2S_Standard_Phillips;
+  
+  /* Initialize the I2S_DataFormat member */
+  I2S_InitStruct-&gt;I2S_DataFormat = I2S_DataFormat_16b;
+  
+  /* Initialize the I2S_MCLKOutput member */
+  I2S_InitStruct-&gt;I2S_MCLKOutput = I2S_MCLKOutput_Disable;
+  
+  /* Initialize the I2S_AudioFreq member */
+  I2S_InitStruct-&gt;I2S_AudioFreq = I2S_AudioFreq_Default;
+  
+  /* Initialize the I2S_CPOL member */
+  I2S_InitStruct-&gt;I2S_CPOL = I2S_CPOL_Low;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_Cmd
+* Description    : Enables or disables the specified SPI peripheral.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - NewState: new state of the SPIx peripheral. 
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral */
+    SPIx-&gt;CR1 |= CR1_SPE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral */
+    SPIx-&gt;CR1 &amp;= CR1_SPE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : I2S_Cmd
+* Description    : Enables or disables the specified SPI peripheral (in I2S mode).
+* Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
+*                  - NewState: new state of the SPIx peripheral. 
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_23_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI peripheral (in I2S mode) */
+    SPIx-&gt;I2SCFGR |= I2SCFGR_I2SE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI peripheral (in I2S mode) */
+    SPIx-&gt;I2SCFGR &amp;= I2SCFGR_I2SE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_ITConfig
+* Description    : Enables or disables the specified SPI/I2S interrupts.
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                         - 2 or 3 in I2S mode
+*                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
+*                    enabled or disabled. 
+*                    This parameter can be one of the following values:
+*                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
+*                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
+*                       - SPI_I2S_IT_ERR: Error interrupt mask
+*                  - NewState: new state of the specified SPI/I2S interrupt.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
+{
+  u16 itpos = 0, itmask = 0 ;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
+
+  /* Get the SPI/I2S IT index */
+  itpos = SPI_I2S_IT &gt;&gt; 4;
+  /* Set the IT mask */
+  itmask = (u16)((u16)1 &lt;&lt; itpos);
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI/I2S interrupt */
+    SPIx-&gt;CR2 |= itmask;
+  }
+  else
+  {
+    /* Disable the selected SPI/I2S interrupt */
+    SPIx-&gt;CR2 &amp;= (u16)~itmask;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_DMACmd
+* Description    : Enables or disables the SPIx/I2Sx DMA interface.
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                         - 2 or 3 in I2S mode
+*                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
+*                    to be enabled or disabled. 
+*                    This parameter can be any combination of the following values:
+*                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
+*                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
+*                  - NewState: new state of the selected SPI/I2S DMA transfer 
+*                    request.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI/I2S DMA requests */
+    SPIx-&gt;CR2 |= SPI_I2S_DMAReq;
+  }
+  else
+  {
+    /* Disable the selected SPI/I2S DMA requests */
+    SPIx-&gt;CR2 &amp;= (u16)~SPI_I2S_DMAReq;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_SendData
+* Description    : Transmits a Data through the SPIx/I2Sx peripheral.
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                         - 2 or 3 in I2S mode
+*                  - Data : Data to be transmitted..
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Write in the DR register the data to be sent */
+  SPIx-&gt;DR = Data;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_ReceiveData
+* Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                         - 2 or 3 in I2S mode
+* Output         : None
+* Return         : The value of the received data.
+*******************************************************************************/
+u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Return the data in the DR register */
+  return SPIx-&gt;DR;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_NSSInternalSoftwareConfig
+* Description    : Configures internally by software the NSS pin for the selected 
+*                  SPI.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
+*                    This parameter can be one of the following values:
+*                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
+*                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
+
+  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
+  {
+    /* Set NSS pin internally by software */
+    SPIx-&gt;CR1 |= SPI_NSSInternalSoft_Set;
+  }
+  else
+  {
+    /* Reset NSS pin internally by software */
+    SPIx-&gt;CR1 &amp;= SPI_NSSInternalSoft_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_SSOutputCmd
+* Description    : Enables or disables the SS output for the selected SPI.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - NewState: new state of the SPIx SS output. 
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI SS output */
+    SPIx-&gt;CR2 |= CR2_SSOE_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI SS output */
+    SPIx-&gt;CR2 &amp;= CR2_SSOE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_DataSizeConfig
+* Description    : Configures the data size for the selected SPI.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - SPI_DataSize: specifies the SPI data size.
+*                    This parameter can be one of the following values:
+*                       - SPI_DataSize_16b: Set data frame format to 16bit
+*                       - SPI_DataSize_8b: Set data frame format to 8bit
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
+
+  /* Clear DFF bit */
+  SPIx-&gt;CR1 &amp;= (u16)~SPI_DataSize_16b;
+  /* Set new DFF bit value */
+  SPIx-&gt;CR1 |= SPI_DataSize;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_TransmitCRC
+* Description    : Transmit the SPIx CRC value.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_TransmitCRC(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Enable the selected SPI CRC transmission */
+  SPIx-&gt;CR1 |= CR1_CRCNext_Set;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_CalculateCRC
+* Description    : Enables or disables the CRC value calculation of the
+*                  transfered bytes.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - NewState: new state of the SPIx CRC value calculation.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected SPI CRC calculation */
+    SPIx-&gt;CR1 |= CR1_CRCEN_Set;
+  }
+  else
+  {
+    /* Disable the selected SPI CRC calculation */
+    SPIx-&gt;CR1 &amp;= CR1_CRCEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_GetCRC
+* Description    : Returns the transmit or the receive CRC register value for
+*                  the specified SPI.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - SPI_CRC: specifies the CRC register to be read.
+*                    This parameter can be one of the following values:
+*                       - SPI_CRC_Tx: Selects Tx CRC register
+*                       - SPI_CRC_Rx: Selects Rx CRC register
+* Output         : None
+* Return         : The selected CRC register value..
+*******************************************************************************/
+u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
+{
+  u16 crcreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_CRC(SPI_CRC));
+
+  if (SPI_CRC != SPI_CRC_Rx)
+  {
+    /* Get the Tx CRC register */
+    crcreg = SPIx-&gt;TXCRCR;
+  }
+  else
+  {
+    /* Get the Rx CRC register */
+    crcreg = SPIx-&gt;RXCRCR;
+  }
+
+  /* Return the selected CRC register */
+  return crcreg;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_GetCRCPolynomial
+* Description    : Returns the CRC Polynomial register value for the specified SPI.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+* Output         : None
+* Return         : The CRC Polynomial register value.
+*******************************************************************************/
+u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  
+  /* Return the CRC polynomial register */
+  return SPIx-&gt;CRCPR;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_BiDirectionalLineConfig
+* Description    : Selects the data transfer direction in bi-directional mode
+*                  for the specified SPI.
+* Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
+*                  - SPI_Direction: specifies the data transfer direction in
+*                    bi-directional mode. 
+*                    This parameter can be one of the following values:
+*                       - SPI_Direction_Tx: Selects Tx transmission direction
+*                       - SPI_Direction_Rx: Selects Rx receive direction
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_DIRECTION(SPI_Direction));
+
+  if (SPI_Direction == SPI_Direction_Tx)
+  {
+    /* Set the Tx only mode */
+    SPIx-&gt;CR1 |= SPI_Direction_Tx;
+  }
+  else
+  {
+    /* Set the Rx only mode */
+    SPIx-&gt;CR1 &amp;= SPI_Direction_Rx;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_GetFlagStatus
+* Description    : Checks whether the specified SPI/I2S flag is set or not.
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                         - 2 or 3 in I2S mode
+*                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
+*                    This parameter can be one of the following values:
+*                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
+*                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
+*                       - SPI_I2S_FLAG_BSY: Busy flag.
+*                       - SPI_I2S_FLAG_OVR: Overrun flag.
+*                       - SPI_FLAG_MODF: Mode Fault flag.
+*                       - SPI_FLAG_CRCERR: CRC Error flag.
+*                       - I2S_FLAG_UDR: Underrun Error flag.
+*                       - I2S_FLAG_CHSIDE: Channel Side flag.
+* Output         : None
+* Return         : The new state of SPI_I2S_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
+
+  /* Check the status of the specified SPI/I2S flag */
+  if ((SPIx-&gt;SR &amp; SPI_I2S_FLAG) != (u16)RESET)
+  {
+    /* SPI_I2S_FLAG is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_FLAG is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_FLAG status */
+  return  bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_ClearFlag
+* Description    : Clears the SPIx CRC Error (CRCERR) flag.
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                  - SPI_I2S_FLAG: specifies the SPI flag to clear. 
+*                    This function clears only CRCERR flag.                                           
+*                  Notes:
+*                       - OVR (OverRun error) flag is cleared by software 
+*                         sequence: a read operation to SPI_DR register 
+*                         (SPI_I2S_ReceiveData()) followed by a read operation 
+*                         to SPI_SR register (SPI_I2S_GetFlagStatus()).                           
+*                       - UDR (UnderRun error) flag is cleared by a read 
+*                         operation to SPI_SR register (SPI_I2S_GetFlagStatus()).                             
+*                       - MODF (Mode Fault) flag is cleared by software sequence: 
+*                         a read/write operation to SPI_SR register 
+*                         (SPI_I2S_GetFlagStatus()) followed by a write 
+*                         operation to SPI_CR1 register (SPI_Cmd() to enable 
+*                         the SPI).   
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
+    
+    /* Clear the selected SPI CRC Error (CRCERR) flag */
+    SPIx-&gt;SR = (u16)~SPI_I2S_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_GetITStatus
+* Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                         - 2 or 3 in I2S mode
+*                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
+*                    This parameter can be one of the following values:
+*                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
+*                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
+*                       - SPI_I2S_IT_OVR: Overrun interrupt.
+*                       - SPI_IT_MODF: Mode Fault interrupt.
+*                       - SPI_IT_CRCERR: CRC Error interrupt.
+*                       - I2S_IT_UDR: Underrun Error interrupt.
+* Output         : None
+* Return         : The new state of SPI_I2S_IT (SET or RESET).
+*******************************************************************************/
+ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
+{
+  ITStatus bitstatus = RESET;
+  u16 itpos = 0, itmask = 0, enablestatus = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
+
+  /* Get the SPI/I2S IT index */
+  itpos = (u16)((u16)0x01 &lt;&lt; (SPI_I2S_IT &amp; (u8)0x0F));
+
+  /* Get the SPI/I2S IT mask */
+  itmask = SPI_I2S_IT &gt;&gt; 4;
+  /* Set the IT mask */
+  itmask = (u16)((u16)0x01 &lt;&lt; itmask);
+  /* Get the SPI_I2S_IT enable bit status */
+  enablestatus = (SPIx-&gt;CR2 &amp; itmask) ;
+
+  /* Check the status of the specified SPI/I2S interrupt */
+  if (((SPIx-&gt;SR &amp; itpos) != (u16)RESET) &amp;&amp; enablestatus)
+  {
+    /* SPI_I2S_IT is set */
+    bitstatus = SET;
+  }
+  else
+  {
+    /* SPI_I2S_IT is reset */
+    bitstatus = RESET;
+  }
+  /* Return the SPI_I2S_IT status */
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_I2S_ClearITPendingBit
+* Description    : Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
+* Input          : - SPIx: where x can be :
+*                         - 1, 2 or 3 in SPI mode 
+*                  - SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
+*                    This function clears only CRCERR intetrrupt pending bit.   
+*                  Notes:
+*                       - OVR (OverRun Error) interrupt pending bit is cleared 
+*                         by software sequence: a read operation to SPI_DR 
+*                         register (SPI_I2S_ReceiveData()) followed by a read 
+*                         operation to SPI_SR register (SPI_I2S_GetITStatus()).
+*                       - UDR (UnderRun Error) interrupt pending bit is cleared 
+*                         by a read operation to SPI_SR register 
+*                         (SPI_I2S_GetITStatus()).                           
+*                       - MODF (Mode Fault) interrupt pending bit is cleared by 
+*                         software sequence: a read/write operation to SPI_SR 
+*                         register (SPI_I2S_GetITStatus()) followed by a write 
+*                         operation to SPI_CR1 register (SPI_Cmd() to enable the 
+*                         SPI).   
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
+{
+  u16 itpos = 0;
+
+  /* Check the parameters */
+  assert_param(IS_SPI_ALL_PERIPH(SPIx));
+  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
+
+  /* Get the SPI IT index */
+  itpos = (u16)((u16)0x01 &lt;&lt; (SPI_I2S_IT &amp; (u8)0x0F));
+  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
+  SPIx-&gt;SR = (u16)~itpos;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_systick.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,181 +1,181 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_systick.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the SysTick firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_systick.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ---------------------- SysTick registers bit mask -------------------- */
-/* CTRL TICKINT Mask */
-#define CTRL_TICKINT_Set      ((u32)0x00000002)
-#define CTRL_TICKINT_Reset    ((u32)0xFFFFFFFD)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : SysTick_CLKSourceConfig
-* Description    : Configures the SysTick clock source.
-* Input          : - SysTick_CLKSource: specifies the SysTick clock source.
-*                    This parameter can be one of the following values:
-*                       - SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8
-*                         selected as SysTick clock source.
-*                       - SysTick_CLKSource_HCLK: AHB clock selected as
-*                         SysTick clock source.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_CLKSourceConfig(u32 SysTick_CLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
-
-  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
-  {
-    SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK;
-  }
-  else
-  {
-    SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_SetReload
-* Description    : Sets SysTick Reload value.
-* Input          : - Reload: SysTick Reload new value.
-*                    This parameter must be a number between 1 and 0xFFFFFF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_SetReload(u32 Reload)
-{
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_RELOAD(Reload));
-
-  SysTick-&gt;LOAD = Reload;
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_CounterCmd
-* Description    : Enables or disables the SysTick counter.
-* Input          : - SysTick_Counter: new state of the SysTick counter.
-*                    This parameter can be one of the following values:
-*                       - SysTick_Counter_Disable: Disable counter
-*                       - SysTick_Counter_Enable: Enable counter
-*                       - SysTick_Counter_Clear: Clear counter value to 0
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_CounterCmd(u32 SysTick_Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_COUNTER(SysTick_Counter));
-
-  if (SysTick_Counter == SysTick_Counter_Enable)
-  {
-    SysTick-&gt;CTRL |= SysTick_Counter_Enable;
-  }
-  else if (SysTick_Counter == SysTick_Counter_Disable) 
-  {
-    SysTick-&gt;CTRL &amp;= SysTick_Counter_Disable;
-  }
-  else /* SysTick_Counter == SysTick_Counter_Clear */
-  {
-    SysTick-&gt;VAL = SysTick_Counter_Clear;
-  }    
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_ITConfig
-* Description    : Enables or disables the SysTick Interrupt.
-* Input          : - NewState: new state of the SysTick Interrupt.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void SysTick_ITConfig(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    SysTick-&gt;CTRL |= CTRL_TICKINT_Set;
-  }
-  else
-  {
-    SysTick-&gt;CTRL &amp;= CTRL_TICKINT_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_GetCounter
-* Description    : Gets SysTick counter value.
-* Input          : None
-* Output         : None
-* Return         : SysTick current value
-*******************************************************************************/
-u32 SysTick_GetCounter(void)
-{
-  return(SysTick-&gt;VAL);
-}
-
-/*******************************************************************************
-* Function Name  : SysTick_GetFlagStatus
-* Description    : Checks whether the specified SysTick flag is set or not.
-* Input          : - SysTick_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - SysTick_FLAG_COUNT
-*                       - SysTick_FLAG_SKEW
-*                       - SysTick_FLAG_NOREF
-* Output         : None
-* Return         : None
-*******************************************************************************/
-FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)
-{
-  u32 statusreg = 0, tmp = 0 ;
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_SYSTICK_FLAG(SysTick_FLAG));
-
-  /* Get the SysTick register index */
-  tmp = SysTick_FLAG &gt;&gt; 3;
-
-  if (tmp == 2) /* The flag to check is in CTRL register */
-  {
-    statusreg = SysTick-&gt;CTRL;
-  }
-  else          /* The flag to check is in CALIB register */
-  {
-    statusreg = SysTick-&gt;CALIB;
-  }
-
-  if ((statusreg &amp; ((u32)1 &lt;&lt; SysTick_FLAG)) != (u32)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_systick.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the SysTick firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_systick.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ---------------------- SysTick registers bit mask -------------------- */
+/* CTRL TICKINT Mask */
+#define CTRL_TICKINT_Set      ((u32)0x00000002)
+#define CTRL_TICKINT_Reset    ((u32)0xFFFFFFFD)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : SysTick_CLKSourceConfig
+* Description    : Configures the SysTick clock source.
+* Input          : - SysTick_CLKSource: specifies the SysTick clock source.
+*                    This parameter can be one of the following values:
+*                       - SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8
+*                         selected as SysTick clock source.
+*                       - SysTick_CLKSource_HCLK: AHB clock selected as
+*                         SysTick clock source.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SysTick_CLKSourceConfig(u32 SysTick_CLKSource)
+{
+  /* Check the parameters */
+  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
+
+  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
+  {
+    SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK;
+  }
+  else
+  {
+    SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SysTick_SetReload
+* Description    : Sets SysTick Reload value.
+* Input          : - Reload: SysTick Reload new value.
+*                    This parameter must be a number between 1 and 0xFFFFFF.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SysTick_SetReload(u32 Reload)
+{
+  /* Check the parameters */
+  assert_param(IS_SYSTICK_RELOAD(Reload));
+
+  SysTick-&gt;LOAD = Reload;
+}
+
+/*******************************************************************************
+* Function Name  : SysTick_CounterCmd
+* Description    : Enables or disables the SysTick counter.
+* Input          : - SysTick_Counter: new state of the SysTick counter.
+*                    This parameter can be one of the following values:
+*                       - SysTick_Counter_Disable: Disable counter
+*                       - SysTick_Counter_Enable: Enable counter
+*                       - SysTick_Counter_Clear: Clear counter value to 0
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SysTick_CounterCmd(u32 SysTick_Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_SYSTICK_COUNTER(SysTick_Counter));
+
+  if (SysTick_Counter == SysTick_Counter_Enable)
+  {
+    SysTick-&gt;CTRL |= SysTick_Counter_Enable;
+  }
+  else if (SysTick_Counter == SysTick_Counter_Disable) 
+  {
+    SysTick-&gt;CTRL &amp;= SysTick_Counter_Disable;
+  }
+  else /* SysTick_Counter == SysTick_Counter_Clear */
+  {
+    SysTick-&gt;VAL = SysTick_Counter_Clear;
+  }    
+}
+
+/*******************************************************************************
+* Function Name  : SysTick_ITConfig
+* Description    : Enables or disables the SysTick Interrupt.
+* Input          : - NewState: new state of the SysTick Interrupt.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void SysTick_ITConfig(FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    SysTick-&gt;CTRL |= CTRL_TICKINT_Set;
+  }
+  else
+  {
+    SysTick-&gt;CTRL &amp;= CTRL_TICKINT_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SysTick_GetCounter
+* Description    : Gets SysTick counter value.
+* Input          : None
+* Output         : None
+* Return         : SysTick current value
+*******************************************************************************/
+u32 SysTick_GetCounter(void)
+{
+  return(SysTick-&gt;VAL);
+}
+
+/*******************************************************************************
+* Function Name  : SysTick_GetFlagStatus
+* Description    : Checks whether the specified SysTick flag is set or not.
+* Input          : - SysTick_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - SysTick_FLAG_COUNT
+*                       - SysTick_FLAG_SKEW
+*                       - SysTick_FLAG_NOREF
+* Output         : None
+* Return         : None
+*******************************************************************************/
+FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)
+{
+  u32 statusreg = 0, tmp = 0 ;
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_SYSTICK_FLAG(SysTick_FLAG));
+
+  /* Get the SysTick register index */
+  tmp = SysTick_FLAG &gt;&gt; 3;
+
+  if (tmp == 2) /* The flag to check is in CTRL register */
+  {
+    statusreg = SysTick-&gt;CTRL;
+  }
+  else          /* The flag to check is in CALIB register */
+  {
+    statusreg = SysTick-&gt;CALIB;
+  }
+
+  if ((statusreg &amp; ((u32)1 &lt;&lt; SysTick_FLAG)) != (u32)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_tim.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,3219 +1,3219 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_tim.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the TIM firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_tim.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ---------------------- TIM registers bit mask ------------------------ */
-#define CR1_CEN_Set                 ((u16)0x0001)
-#define CR1_CEN_Reset               ((u16)0x03FE)
-#define CR1_UDIS_Set                ((u16)0x0002)
-#define CR1_UDIS_Reset              ((u16)0x03FD)
-#define CR1_URS_Set                 ((u16)0x0004)
-#define CR1_URS_Reset               ((u16)0x03FB)
-#define CR1_OPM_Reset               ((u16)0x03F7)
-#define CR1_CounterMode_Mask        ((u16)0x038F)
-#define CR1_ARPE_Set                ((u16)0x0080)
-#define CR1_ARPE_Reset              ((u16)0x037F)
-#define CR1_CKD_Mask                ((u16)0x00FF)
-
-#define CR2_CCPC_Set                ((u16)0x0001)
-#define CR2_CCPC_Reset              ((u16)0xFFFE)
-#define CR2_CCUS_Set                ((u16)0x0004)
-#define CR2_CCUS_Reset              ((u16)0xFFFB)
-#define CR2_CCDS_Set                ((u16)0x0008)
-#define CR2_CCDS_Reset              ((u16)0xFFF7)
-#define CR2_MMS_Mask                ((u16)0xFF8F)
-#define CR2_TI1S_Set                ((u16)0x0080)
-#define CR2_TI1S_Reset              ((u16)0xFF7F)
-#define CR2_OIS1_Reset              ((u16)0x7EFF)
-#define CR2_OIS1N_Reset             ((u16)0x7DFF)
-#define CR2_OIS2_Reset              ((u16)0x7BFF)
-#define CR2_OIS2N_Reset             ((u16)0x77FF)
-#define CR2_OIS3_Reset              ((u16)0x6FFF)
-#define CR2_OIS3N_Reset             ((u16)0x5FFF)
-#define CR2_OIS4_Reset              ((u16)0x3FFF)
-
-#define SMCR_SMS_Mask               ((u16)0xFFF8)
-#define SMCR_ETR_Mask               ((u16)0x00FF)
-#define SMCR_TS_Mask                ((u16)0xFF8F)
-#define SMCR_MSM_Reset              ((u16)0xFF7F)
-#define SMCR_ECE_Set                ((u16)0x4000)
-
-#define CCMR_CC13S_Mask             ((u16)0xFFFC)
-#define CCMR_CC24S_Mask             ((u16)0xFCFF)
-#define CCMR_TI13Direct_Set         ((u16)0x0001)
-#define CCMR_TI24Direct_Set         ((u16)0x0100)
-#define CCMR_OC13FE_Reset           ((u16)0xFFFB)
-#define CCMR_OC24FE_Reset           ((u16)0xFBFF)
-#define CCMR_OC13PE_Reset           ((u16)0xFFF7)
-#define CCMR_OC24PE_Reset           ((u16)0xF7FF)
-#define CCMR_OC13M_Mask             ((u16)0xFF8F)
-#define CCMR_OC24M_Mask             ((u16)0x8FFF) 
-
-#define CCMR_OC13CE_Reset           ((u16)0xFF7F)
-#define CCMR_OC24CE_Reset           ((u16)0x7FFF)
-
-#define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
-#define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
-#define CCMR_IC13F_Mask             ((u16)0xFF0F)
-#define CCMR_IC24F_Mask             ((u16)0x0FFF)
-
-#define CCMR_Offset                 ((u16)0x0018)
-#define CCER_CCE_Set                ((u16)0x0001)
-#define	CCER_CCNE_Set               ((u16)0x0004)
-
-#define CCER_CC1P_Reset             ((u16)0xFFFD)
-#define CCER_CC2P_Reset             ((u16)0xFFDF)
-#define CCER_CC3P_Reset             ((u16)0xFDFF)
-#define CCER_CC4P_Reset             ((u16)0xDFFF)
-
-#define CCER_CC1NP_Reset            ((u16)0xFFF7)
-#define CCER_CC2NP_Reset            ((u16)0xFF7F)
-#define CCER_CC3NP_Reset            ((u16)0xF7FF)
-
-#define CCER_CC1E_Set               ((u16)0x0001)
-#define CCER_CC1E_Reset             ((u16)0xFFFE)
-
-#define CCER_CC1NE_Reset            ((u16)0xFFFB)
-
-#define CCER_CC2E_Set               ((u16)0x0010)
-#define CCER_CC2E_Reset             ((u16)0xFFEF)
-
-#define CCER_CC2NE_Reset            ((u16)0xFFBF)
-
-#define CCER_CC3E_Set               ((u16)0x0100)
-#define CCER_CC3E_Reset             ((u16)0xFEFF)
-
-#define CCER_CC3NE_Reset            ((u16)0xFBFF)
-
-#define CCER_CC4E_Set               ((u16)0x1000)
-#define CCER_CC4E_Reset             ((u16)0xEFFF)
-
-#define BDTR_MOE_Set                ((u16)0x8000)
-#define BDTR_MOE_Reset              ((u16)0x7FFF)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter);
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-/*******************************************************************************
-* Function Name  : TIM_DeInit
-* Description    : Deinitializes the TIMx peripheral registers to their default
-*                  reset values.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_DeInit(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
- 
-  switch (*(u32*)&amp;TIMx)
-  {
-    case TIM1_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
-      break; 
-      
-    case TIM2_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
-      break;
- 
-    case TIM3_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
-      break;
- 
-    case TIM4_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
-      break;
-      
-    case TIM5_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
-      break;
-      
-    case TIM6_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
-      break;
-      
-    case TIM7_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
-      break;
-      
-    case TIM8_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
-      break; 
-      
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_TimeBaseInit
-* Description    : Initializes the TIMx Time Base Unit peripheral according to 
-*                  the specified parameters in the TIM_TimeBaseInitStruct.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
-*                   structure that contains the configuration information for
-*                   the specified TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&gt;TIM_CounterMode));
-  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision));
-
-  /* Select the Counter Mode and set the clock division */
-  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask &amp; CR1_CounterMode_Mask;
-  TIMx-&gt;CR1 |= (u32)TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision |
-                TIM_TimeBaseInitStruct-&gt;TIM_CounterMode;
-  /* Set the Autoreload value */
-  TIMx-&gt;ARR = TIM_TimeBaseInitStruct-&gt;TIM_Period ;
-
-  /* Set the Prescaler value */
-  TIMx-&gt;PSC = TIM_TimeBaseInitStruct-&gt;TIM_Prescaler;
-
-  /* Generate an update event to reload the Prescaler value immediatly */
-  TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;
-    
-  if (((*(u32*)&amp;TIMx) == TIM1_BASE) || ((*(u32*)&amp;TIMx) == TIM8_BASE))  
-  {
-    /* Set the Repetition Counter value */
-    TIMx-&gt;RCR = TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter;
-  }        
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1Init
-* Description    : Initializes the TIMx Channel1 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 1: Reset the CC1E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR1 register value */
-  tmpccmrx = TIMx-&gt;CCMR1;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC13M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC1P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= TIM_OCInitStruct-&gt;TIM_OCPolarity;
-  
-  /* Set the Output State */
-  tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputState;
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR1 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &amp;= CCER_CC1NP_Reset;
-
-    /* Set the Output N Polarity */
-    tmpccer |= TIM_OCInitStruct-&gt;TIM_OCNPolarity;
-
-    /* Reset the Output N State */
-    tmpccer &amp;= CCER_CC1NE_Reset;
-    
-    /* Set the Output N State */
-    tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputNState;
-
-    /* Reset the Ouput Compare and Output Compare N IDLE State */
-    tmpcr2 &amp;= CR2_OIS1_Reset;
-    tmpcr2 &amp;= CR2_OIS1N_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCIdleState;
-
-    /* Set the Output N Idle state */
-    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCNIdleState;
-  }
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2Init
-* Description    : Initializes the TIMx Channel2 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
-  
-  /* Get the TIMx CCER register value */  
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR1 register value */
-  tmpccmrx = TIMx-&gt;CCMR1;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC24M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= (u16)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC2P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 4);
-  
-  /* Set the Output State */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 4);
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR2 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &amp;= CCER_CC2NP_Reset;
-
-    /* Set the Output N Polarity */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 4);
-
-    /* Reset the Output N State */
-    tmpccer &amp;= CCER_CC2NE_Reset;
-    
-    /* Set the Output N State */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 4);
-
-    /* Reset the Ouput Compare and Output Compare N IDLE State */
-    tmpcr2 &amp;= CR2_OIS2_Reset;
-    tmpcr2 &amp;= CR2_OIS2N_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 2);
-
-    /* Set the Output N Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 2);
-  }
-
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3Init
-* Description    : Initializes the TIMx Channel3 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR2 register value */
-  tmpccmrx = TIMx-&gt;CCMR2;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC13M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC3P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 8);
-  
-  /* Set the Output State */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 8);
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR3 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &amp;= CCER_CC3NP_Reset;
-
-    /* Set the Output N Polarity */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 8);
-
-    /* Reset the Output N State */
-    tmpccer &amp;= CCER_CC3NE_Reset;
-    
-    /* Set the Output N State */
-    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 8);
-
-    /* Reset the Ouput Compare and Output Compare N IDLE State */
-    tmpcr2 &amp;= CR2_OIS3_Reset;
-    tmpcr2 &amp;= CR2_OIS3N_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 4);
-
-    /* Set the Output N Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 4);
-  }
-
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR2 */
-  TIMx-&gt;CCMR2 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4Init
-* Description    : Initializes the TIMx Channel4 according to the specified
-*                  parameters in the TIM_OCInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
-
-  /* Disable the Channel 2: Reset the CC4E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx-&gt;CR2;
-  
-  /* Get the TIMx CCMR2 register value */
-  tmpccmrx = TIMx-&gt;CCMR2;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &amp;= CCMR_OC24M_Mask;
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= (u16)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
-  
-  /* Reset the Output Polarity level */
-  tmpccer &amp;= CCER_CC4P_Reset;
-
-  /* Set the Output Compare Polarity */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 12);
-  
-  /* Set the Output State */
-  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 12);
-  
-  /* Set the Capture Compare Register value */
-  TIMx-&gt;CCR4 = TIM_OCInitStruct-&gt;TIM_Pulse;
-  
-  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
-  {
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
-
-    /* Reset the Ouput Compare IDLE State */
-    tmpcr2 &amp;= CR2_OIS4_Reset;
-
-    /* Set the Output Idle state */
-    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 6);
-  }
-
-  /* Write to TIMx CR2 */
-  TIMx-&gt;CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR2 */  
-  TIMx-&gt;CCMR2 = tmpccmrx;
-  
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ICInit
-* Description    : Initializes the TIM peripheral according to the specified
-*                  parameters in the TIM_ICInitStruct.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct-&gt;TIM_Channel));
-  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct-&gt;TIM_ICPolarity));
-  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct-&gt;TIM_ICSelection));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct-&gt;TIM_ICPrescaler));
-  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct-&gt;TIM_ICFilter));
-  
-  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
-  {
-    /* TI1 Configuration */
-    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_2)
-  {
-    /* TI2 Configuration */
-    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_3)
-  {
-    /* TI3 Configuration */
-    TI3_Config(TIMx,  TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else
-  {
-    /* TI4 Configuration */
-    TI4_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
-               TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_PWMIConfig
-* Description    : Configures the TIM peripheral according to the specified
-*                  parameters in the TIM_ICInitStruct to measure an external PWM
-*                  signal.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
-*                    that contains the configuration information for the specified
-*                    TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  u16 icoppositepolarity = TIM_ICPolarity_Rising;
-  u16 icoppositeselection = TIM_ICSelection_DirectTI;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Select the Opposite Input Polarity */
-  if (TIM_ICInitStruct-&gt;TIM_ICPolarity == TIM_ICPolarity_Rising)
-  {
-    icoppositepolarity = TIM_ICPolarity_Falling;
-  }
-  else
-  {
-    icoppositepolarity = TIM_ICPolarity_Rising;
-  }
-
-  /* Select the Opposite Input */
-  if (TIM_ICInitStruct-&gt;TIM_ICSelection == TIM_ICSelection_DirectTI)
-  {
-    icoppositeselection = TIM_ICSelection_IndirectTI;
-  }
-  else
-  {
-    icoppositeselection = TIM_ICSelection_DirectTI;
-  }
-
-  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
-  {
-    /* TI1 Configuration */
-    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-
-    /* TI2 Configuration */
-    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-  else
-  { 
-    /* TI2 Configuration */
-    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
-               TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-
-    /* TI1 Configuration */
-    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
-
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_BDTRConfig
-* Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
-*                  the OSSR State and the AOE(automatic output enable).
-* Input          :- TIMx: where x can be  1 or 8 to select the TIM 
-*                 - TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef
-*                    structure that contains the BDTR Register configuration
-*                    information for the TIM peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSRState));
-  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSIState));
-  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct-&gt;TIM_LOCKLevel));
-  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct-&gt;TIM_Break));
-  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct-&gt;TIM_BreakPolarity));
-  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput));
-
-  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
-     the OSSI State, the dead time value and the Automatic Output Enable Bit */
-
-  TIMx-&gt;BDTR = (u32)TIM_BDTRInitStruct-&gt;TIM_OSSRState | TIM_BDTRInitStruct-&gt;TIM_OSSIState |
-             TIM_BDTRInitStruct-&gt;TIM_LOCKLevel | TIM_BDTRInitStruct-&gt;TIM_DeadTime |
-             TIM_BDTRInitStruct-&gt;TIM_Break | TIM_BDTRInitStruct-&gt;TIM_BreakPolarity |
-             TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput;
-
-}
-
-/*******************************************************************************
-* Function Name  : TIM_TimeBaseStructInit
-* Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
-* Input          : - TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
-{
-  /* Set the default configuration */
-  TIM_TimeBaseInitStruct-&gt;TIM_Period = 0xFFFF;
-  TIM_TimeBaseInitStruct-&gt;TIM_Prescaler = 0x0000;
-  TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision = TIM_CKD_DIV1;
-  TIM_TimeBaseInitStruct-&gt;TIM_CounterMode = TIM_CounterMode_Up;
-  TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter = 0x0000;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OCStructInit
-* Description    : Fills each TIM_OCInitStruct member with its default value.
-* Input          : - TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  /* Set the default configuration */
-  TIM_OCInitStruct-&gt;TIM_OCMode = TIM_OCMode_Timing;
-  TIM_OCInitStruct-&gt;TIM_OutputState = TIM_OutputState_Disable;
-  TIM_OCInitStruct-&gt;TIM_OutputNState = TIM_OutputNState_Disable;
-  TIM_OCInitStruct-&gt;TIM_Pulse = 0x0000;
-  TIM_OCInitStruct-&gt;TIM_OCPolarity = TIM_OCPolarity_High;
-  TIM_OCInitStruct-&gt;TIM_OCNPolarity = TIM_OCPolarity_High;
-  TIM_OCInitStruct-&gt;TIM_OCIdleState = TIM_OCIdleState_Reset;
-  TIM_OCInitStruct-&gt;TIM_OCNIdleState = TIM_OCNIdleState_Reset;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ICStructInit
-* Description    : Fills each TIM_ICInitStruct member with its default value.
-* Input          : - TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  /* Set the default configuration */
-  TIM_ICInitStruct-&gt;TIM_Channel = TIM_Channel_1;
-  TIM_ICInitStruct-&gt;TIM_ICPolarity = TIM_ICPolarity_Rising;
-  TIM_ICInitStruct-&gt;TIM_ICSelection = TIM_ICSelection_DirectTI;
-  TIM_ICInitStruct-&gt;TIM_ICPrescaler = TIM_ICPSC_DIV1;
-  TIM_ICInitStruct-&gt;TIM_ICFilter = 0x00;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_BDTRStructInit
-* Description    : Fills each TIM_BDTRInitStruct member with its default value.
-* Input          : - TIM_BDTRInitStruct : pointer to a TIM_BDTRInitTypeDef
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
-{
-  /* Set the default configuration */
-  TIM_BDTRInitStruct-&gt;TIM_OSSRState = TIM_OSSRState_Disable;
-  TIM_BDTRInitStruct-&gt;TIM_OSSIState = TIM_OSSIState_Disable;
-  TIM_BDTRInitStruct-&gt;TIM_LOCKLevel = TIM_LOCKLevel_OFF;
-  TIM_BDTRInitStruct-&gt;TIM_DeadTime = 0x00;
-  TIM_BDTRInitStruct-&gt;TIM_Break = TIM_Break_Disable;
-  TIM_BDTRInitStruct-&gt;TIM_BreakPolarity = TIM_BreakPolarity_Low;
-  TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_Cmd
-* Description    : Enables or disables the specified TIM peripheral.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
-*                  - NewState: new state of the TIMx peripheral.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the TIM Counter */
-    TIMx-&gt;CR1 |= CR1_CEN_Set;
-  }
-  else
-  {
-    /* Disable the TIM Counter */
-    TIMx-&gt;CR1 &amp;= CR1_CEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CtrlPWMOutputs
-* Description    : Enables or disables the TIM peripheral Main Outputs.
-* Input          :- TIMx: where x can be 1 or 8 to select the TIMx peripheral.
-*                 - NewState: new state of the TIM peripheral Main Outputs.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the TIM Main Output */
-    TIMx-&gt;BDTR |= BDTR_MOE_Set;
-  }
-  else
-  {
-    /* Disable the TIM Main Output */
-    TIMx-&gt;BDTR &amp;= BDTR_MOE_Reset;
-  }  
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ITConfig
-* Description    : Enables or disables the specified TIM interrupts.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
-*                  - TIM_IT: specifies the TIM interrupts sources to be enabled
-*                    or disabled.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_IT_Update: TIM update Interrupt source
-*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-*                       - TIM_IT_COM: TIM Commutation Interrupt source
-*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
-*                       - TIM_IT_Break: TIM Break Interrupt source
-*                  - NewState: new state of the TIM interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_IT(TIM_IT));
-  assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the Interrupt sources */
-    TIMx-&gt;DIER |= TIM_IT;
-  }
-  else
-  {
-    /* Disable the Interrupt sources */
-    TIMx-&gt;DIER &amp;= (u16)~TIM_IT;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GenerateEvent
-* Description    : Configures the TIMx event to be generate by software.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_EventSource: specifies the event source.
-*                    This parameter can be one or more of the following values:	   
-*                       - TIM_EventSource_Update: Timer update Event source
-*                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
-*                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
-*                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
-*                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
-*                       - TIM_EventSource_Trigger: Timer Trigger Event source
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
-  assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
-
-  /* Set the event sources */
-  TIMx-&gt;EGR = TIM_EventSource;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_DMAConfig
-* Description    : Configures the TIMx&#146;s DMA interface.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_DMABase: DMA Base address.
-*                    This parameter can be one of the following values:
-*                       - TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
-*                         TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
-*                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
-*                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
-*                         TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
-*                         TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
-*                         TIM_DMABase_DCR.
-*                   - TIM_DMABurstLength: DMA Burst length.
-*                     This parameter can be one value between:
-*                     TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
-  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
-
-  /* Set the DMA Base and the DMA Burst Length */
-  TIMx-&gt;DCR = TIM_DMABase | TIM_DMABurstLength;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_DMACmd
-* Description    : Enables or disables the TIMx&#146;s DMA Requests.
-* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral. 
-*                  - TIM_DMASources: specifies the DMA Request sources.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_DMA_Update: TIM update Interrupt source
-*                       - TIM_DMA_CC1: TIM Capture Compare 1 DMA source
-*                       - TIM_DMA_CC2: TIM Capture Compare 2 DMA source
-*                       - TIM_DMA_CC3: TIM Capture Compare 3 DMA source
-*                       - TIM_DMA_CC4: TIM Capture Compare 4 DMA source
-*                       - TIM_DMA_COM: TIM Commutation DMA source
-*                       - TIM_DMA_Trigger: TIM Trigger DMA source
-*                  - NewState: new state of the DMA Request sources.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
-  assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the DMA sources */
-    TIMx-&gt;DIER |= TIM_DMASource; 
-  }
-  else
-  {
-    /* Disable the DMA sources */
-    TIMx-&gt;DIER &amp;= (u16)~TIM_DMASource;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_InternalClockConfig
-* Description    : Configures the TIMx interrnal Clock
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Disable slave mode to clock the prescaler directly with the internal clock */
-  TIMx-&gt;SMCR &amp;=  SMCR_SMS_Mask;
-}
-/*******************************************************************************
-* Function Name  : TIM_ITRxExternalClockConfig
-* Description    : Configures the TIMx Internal Trigger as External Clock
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ITRSource: Trigger source.
-*                    This parameter can be one of the following values:
-*                       - TIM_TS_ITR0: Internal Trigger 0
-*                       - TIM_TS_ITR1: Internal Trigger 1
-*                       - TIM_TS_ITR2: Internal Trigger 2
-*                       - TIM_TS_ITR3: Internal Trigger 3
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
-
-  /* Select the Internal Trigger */
-  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
-
-  /* Select the External clock mode1 */
-  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
-}
-/*******************************************************************************
-* Function Name  : TIM_TIxExternalClockConfig
-* Description    : Configures the TIMx Trigger as External Clock
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_TIxExternalCLKSource: Trigger source.
-*                    This parameter can be one of the following values:
-*                       - TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
-*                       - TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
-*                       - TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
-*                  - TIM_ICPolarity: specifies the TIx Polarity.
-*                    This parameter can be:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                   - ICFilter : specifies the filter value.
-*                     This parameter must be a value between 0x0 and 0xF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
-                                u16 TIM_ICPolarity, u16 ICFilter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
-  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
-  assert_param(IS_TIM_IC_FILTER(ICFilter));
-
-  /* Configure the Timer Input Clock Source */
-  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
-  {
-    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
-  }
-  else
-  {
-    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
-  }
-
-  /* Select the Trigger source */
-  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
-
-  /* Select the External clock mode1 */
-  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ETRClockMode1Config
-* Description    : Configures the External clock Mode1
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPSC_OFF
-*                       - TIM_ExtTRGPSC_DIV2
-*                       - TIM_ExtTRGPSC_DIV4
-*                       - TIM_ExtTRGPSC_DIV8.
-*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPolarity_Inverted
-*                       - TIM_ExtTRGPolarity_NonInverted
-*                  - ExtTRGFilter: External Trigger Filter.
-*                    This parameter must be a value between 0x00 and 0x0F
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
-                             u16 ExtTRGFilter)
-{
-  u16 tmpsmcr = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-
-  /* Configure the ETR Clock source */
-  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
-  
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Reset the SMS Bits */
-  tmpsmcr &amp;= SMCR_SMS_Mask;
-  /* Select the External clock mode1 */
-  tmpsmcr |= TIM_SlaveMode_External1;
-
-  /* Select the Trigger selection : ETRF */
-  tmpsmcr &amp;= SMCR_TS_Mask;
-  tmpsmcr |= TIM_TS_ETRF;
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ETRClockMode2Config
-* Description    : Configures the External clock Mode2
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPSC_OFF
-*                       - TIM_ExtTRGPSC_DIV2
-*                       - TIM_ExtTRGPSC_DIV4
-*                       - TIM_ExtTRGPSC_DIV8
-*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
-*                    It can be one of the following values:
-*                       - TIM_ExtTRGPolarity_Inverted
-*                       - TIM_ExtTRGPolarity_NonInverted
-*                  - ExtTRGFilter: External Trigger Filter.
-*                    This parameter must be a value between 0x00 and 0x0F
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
-                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-
-  /* Configure the ETR Clock source */
-  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
-
-  /* Enable the External clock mode2 */
-  TIMx-&gt;SMCR |= SMCR_ECE_Set;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ETRConfig
-* Description    : Configures the TIMx External Trigger (ETR).
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-*                    This parameter can be one of the following values:
-*                       - TIM_ExtTRGPSC_OFF
-*                       - TIM_ExtTRGPSC_DIV2
-*                       - TIM_ExtTRGPSC_DIV4
-*                       - TIM_ExtTRGPSC_DIV8
-*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ExtTRGPolarity_Inverted
-*                       - TIM_ExtTRGPolarity_NonInverted
-*                  - ExtTRGFilter: External Trigger Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
-                   u16 ExtTRGFilter)
-{
-  u16 tmpsmcr = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Reset the ETR Bits */
-  tmpsmcr &amp;= SMCR_ETR_Mask;
-
-  /* Set the Prescaler, the Filter value and the Polarity */
-  tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter &lt;&lt; 8);
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_PrescalerConfig
-* Description    : Configures the TIMx Prescaler.
-* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral.
-*                  - Prescaler: specifies the Prescaler Register value
-*                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
-*                    This parameter can be one of the following values:
-*                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
-*                         the update event.
-*                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
-*                         immediatly.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
-
-  /* Set the Prescaler value */
-  TIMx-&gt;PSC = Prescaler;
-
-  /* Set or reset the UG Bit */
-  TIMx-&gt;EGR = TIM_PSCReloadMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CounterModeConfig
-* Description    : Specifies the TIMx Counter Mode to be used.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_CounterMode: specifies the Counter Mode to be used
-*                    This parameter can be one of the following values:
-*                       - TIM_CounterMode_Up: TIM Up Counting Mode
-*                       - TIM_CounterMode_Down: TIM Down Counting Mode
-*                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
-*                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
-*                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
-{
-  u16 tmpcr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
-
-  tmpcr1 = TIMx-&gt;CR1;
-
-  /* Reset the CMS and DIR Bits */
-  tmpcr1 &amp;= CR1_CounterMode_Mask;
-
-  /* Set the Counter Mode */
-  tmpcr1 |= TIM_CounterMode;
-
-  /* Write to TIMx CR1 register */
-  TIMx-&gt;CR1 = tmpcr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectInputTrigger
-* Description    : Selects the Input Trigger source
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_InputTriggerSource: The Input Trigger source.
-*                    This parameter can be one of the following values:
-*                       - TIM_TS_ITR0: Internal Trigger 0
-*                       - TIM_TS_ITR1: Internal Trigger 1
-*                       - TIM_TS_ITR2: Internal Trigger 2
-*                       - TIM_TS_ITR3: Internal Trigger 3
-*                       - TIM_TS_TI1F_ED: TI1 Edge Detector
-*                       - TIM_TS_TI1FP1: Filtered Timer Input 1
-*                       - TIM_TS_TI2FP2: Filtered Timer Input 2
-*                       - TIM_TS_ETRF: External Trigger input
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
-{
-  u16 tmpsmcr = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
-
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Reset the TS Bits */
-  tmpsmcr &amp;= SMCR_TS_Mask;
-
-  /* Set the Input Trigger source */
-  tmpsmcr |= TIM_InputTriggerSource;
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_EncoderInterfaceConfig
-* Description    : Configures the TIMx Encoder Interface.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
-*                    This parameter can be one of the following values:
-*                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
-*                         depending on TI2FP2 level.
-*                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
-*                         depending on TI1FP1 level.
-*                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
-*                         TI2FP2 edges depending on the level of the other input.
-*                  - TIM_IC1Polarity: specifies the IC1 Polarity
-*                    This parmeter can be one of the following values:
-*                        - TIM_ICPolarity_Falling: IC Falling edge.
-*                        - TIM_ICPolarity_Rising: IC Rising edge.
-*                  - TIM_IC2Polarity: specifies the IC2 Polarity
-*                    This parmeter can be one of the following values:
-*                        - TIM_ICPolarity_Falling: IC Falling edge.
-*                        - TIM_ICPolarity_Rising: IC Rising edge.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
-                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
-{
-  u16 tmpsmcr = 0;
-  u16 tmpccmr1 = 0;
-  u16 tmpccer = 0;
-    
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
-  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
-  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
-
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx-&gt;SMCR;
-
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set the encoder Mode */
-  tmpsmcr &amp;= SMCR_SMS_Mask;
-  tmpsmcr |= TIM_EncoderMode;
-
-  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
-  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_CC24S_Mask;
-  tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
-
-  /* Set the TI1 and the TI2 Polarities */
-  tmpccer &amp;= CCER_CC1P_Reset &amp; CCER_CC2P_Reset;
-  tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity &lt;&lt; 4));
-
-  /* Write to TIMx SMCR */
-  TIMx-&gt;SMCR = tmpsmcr;
-
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-
-  /* Write to TIMx CCER */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC1Config
-* Description    : Forces the TIMx output 1 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC1REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC1REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1M Bits */
-  tmpccmr1 &amp;= CCMR_OC13M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr1 |= TIM_ForcedAction;
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC2Config
-* Description    : Forces the TIMx output 2 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC2REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC2REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2M Bits */
-  tmpccmr1 &amp;= CCMR_OC24M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr1 |= (u16)(TIM_ForcedAction &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC3Config
-* Description    : Forces the TIMx output 3 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC3REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC3REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC1M Bits */
-  tmpccmr2 &amp;= CCMR_OC13M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr2 |= TIM_ForcedAction;
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ForcedOC4Config
-* Description    : Forces the TIMx output 4 waveform to active or inactive level.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ForcedAction: specifies the forced Action to be set to
-*                    the output waveform.
-*                    This parameter can be one of the following values:
-*                       - TIM_ForcedAction_Active: Force active level on OC4REF
-*                       - TIM_ForcedAction_InActive: Force inactive level on
-*                         OC4REF.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC2M Bits */
-  tmpccmr2 &amp;= CCMR_OC24M_Mask;
-
-  /* Configure The Forced output Mode */
-  tmpccmr2 |= (u16)(TIM_ForcedAction &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ARRPreloadConfig
-* Description    : Enables or disables TIMx peripheral Preload register on ARR.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - NewState: new state of the TIMx peripheral Preload register
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the ARR Preload Bit */
-    TIMx-&gt;CR1 |= CR1_ARPE_Set;
-  }
-  else
-  {
-    /* Reset the ARR Preload Bit */
-    TIMx-&gt;CR1 &amp;= CR1_ARPE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectCOM
-* Description    : Selects the TIM peripheral Commutation event.
-* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
-*                 - NewState: new state of the Commutation event.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the COM Bit */
-    TIMx-&gt;CR2 |= CR2_CCUS_Set;
-  }
-  else
-  {
-    /* Reset the COM Bit */
-    TIMx-&gt;CR2 &amp;= CR2_CCUS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectCCDMA
-* Description    : Selects the TIMx peripheral Capture Compare DMA source.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - NewState: new state of the Capture Compare DMA source
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the CCDS Bit */
-    TIMx-&gt;CR2 |= CR2_CCDS_Set;
-  }
-  else
-  {
-    /* Reset the CCDS Bit */
-    TIMx-&gt;CR2 &amp;= CR2_CCDS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CCPreloadControl
-* Description    : Sets or Resets the TIM peripheral Capture Compare Preload 
-*                  Control bit.
-* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
-*                 - NewState: new state of the Capture Compare Preload Control bit
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the CCPC Bit */
-    TIMx-&gt;CR2 |= CR2_CCPC_Set;
-  }
-  else
-  {
-    /* Reset the CCPC Bit */
-    TIMx-&gt;CR2 &amp;= CR2_CCPC_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1PE Bit */
-  tmpccmr1 &amp;= CCMR_OC13PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr1 |= TIM_OCPreload;
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2PE Bit */
-  tmpccmr1 &amp;= CCMR_OC24PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr1 |= (u16)(TIM_OCPreload &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC3PE Bit */
-  tmpccmr2 &amp;= CCMR_OC13PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr2 |= TIM_OCPreload;
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4PreloadConfig
-* Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
-*                    register
-*                    This parameter can be one of the following values:
-*                       - TIM_OCPreload_Enable
-*                       - TIM_OCPreload_Disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC4PE Bit */
-  tmpccmr2 &amp;= CCMR_OC24PE_Reset;
-
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr2 |= (u16)(TIM_OCPreload &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1FastConfig
-* Description    : Configures the TIMx Output Compare 1 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1FE Bit */
-  tmpccmr1 &amp;= CCMR_OC13FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr1 |= TIM_OCFast;
-
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2FastConfig
-* Description    : Configures the TIMx Output Compare 2 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2FE Bit */
-  tmpccmr1 &amp;= CCMR_OC24FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr1 |= (u16)(TIM_OCFast &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3FastConfig
-* Description    : Configures the TIMx Output Compare 3 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR2 register value */
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC3FE Bit */
-  tmpccmr2 &amp;= CCMR_OC13FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr2 |= TIM_OCFast;
-
-  /* Write to TIMx CCMR2 */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4FastConfig
-* Description    : Configures the TIMx Output Compare 4 Fast feature.
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCFast_Enable: TIM output compare fast enable
-*                       - TIM_OCFast_Disable: TIM output compare fast disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-
-  /* Get the TIMx CCMR2 register value */
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC4FE Bit */
-  tmpccmr2 &amp;= CCMR_OC24FE_Reset;
-
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr2 |= (u16)(TIM_OCFast &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC1Ref
-* Description    : Clears or safeguards the OCREF1 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC1CE Bit */
-  tmpccmr1 &amp;= CCMR_OC13CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr1 |= TIM_OCClear;
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC2Ref
-* Description    : Clears or safeguards the OCREF2 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-
-  /* Reset the OC2CE Bit */
-  tmpccmr1 &amp;= CCMR_OC24CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr1 |= (u16)(TIM_OCClear &lt;&lt; 8);
-
-  /* Write to TIMx CCMR1 register */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC3Ref
-* Description    : Clears or safeguards the OCREF3 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC3CE Bit */
-  tmpccmr2 &amp;= CCMR_OC13CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr2 |= TIM_OCClear;
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearOC4Ref
-* Description    : Clears or safeguards the OCREF4 signal on an external event
-* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-*                    This parameter can be one of the following values:
-*                       - TIM_OCClear_Enable: TIM Output clear enable
-*                       - TIM_OCClear_Disable: TIM Output clear disable
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
-{
-  u16 tmpccmr2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-
-  /* Reset the OC4CE Bit */
-  tmpccmr2 &amp;= CCMR_OC24CE_Reset;
-
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr2 |= (u16)(TIM_OCClear &lt;&lt; 8);
-
-  /* Write to TIMx CCMR2 register */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1PolarityConfig
-* Description    : Configures the TIMx channel 1 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC1 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC1P Bit */
-  tmpccer &amp;= CCER_CC1P_Reset;
-  tmpccer |= TIM_OCPolarity;
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC1NPolarityConfig
-* Description    : Configures the TIMx Channel 1N polarity.
-* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                  - TIM_OCNPolarity: specifies the OC1N Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCNPolarity_High: Output Compare active high
-*                       - TIM_OCNPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-   
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC1NP Bit */
-  tmpccer &amp;= CCER_CC1NP_Reset;
-  tmpccer |= TIM_OCNPolarity;
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2PolarityConfig
-* Description    : Configures the TIMx channel 2 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC2 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC2P Bit */
-  tmpccer &amp;= CCER_CC2P_Reset;
-  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 4);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC2NPolarityConfig
-* Description    : Configures the TIMx Channel 2N polarity.
-* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                  - TIM_OCNPolarity: specifies the OC2N Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCNPolarity_High: Output Compare active high
-*                       - TIM_OCNPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-  
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC2NP Bit */
-  tmpccer &amp;= CCER_CC2NP_Reset;
-  tmpccer |= (u16)(TIM_OCNPolarity &lt;&lt; 4);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3PolarityConfig
-* Description    : Configures the TIMx channel 3 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC3 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC3P Bit */
-  tmpccer &amp;= CCER_CC3P_Reset;
-  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 8);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC3NPolarityConfig
-* Description    : Configures the TIMx Channel 3N polarity.
-* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                  - TIM_OCNPolarity: specifies the OC3N Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCNPolarity_High: Output Compare active high
-*                       - TIM_OCNPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
-{
-  u16 tmpccer = 0;
- 
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-    
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC3NP Bit */
-  tmpccer &amp;= CCER_CC3NP_Reset;
-  tmpccer |= (u16)(TIM_OCNPolarity &lt;&lt; 8);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_OC4PolarityConfig
-* Description    : Configures the TIMx channel 4 polarity.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_OCPolarity: specifies the OC4 Polarity
-*                    This parmeter can be one of the following values:
-*                       - TIM_OCPolarity_High: Output Compare active high
-*                       - TIM_OCPolarity_Low: Output Compare active low
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
-{
-  u16 tmpccer = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Set or Reset the CC4P Bit */
-  tmpccer &amp;= CCER_CC4P_Reset;
-  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 12);
-
-  /* Write to TIMx CCER register */
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CCxCmd
-* Description    : Enables or disables the TIM Capture Compare Channel x.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
-*                    peripheral.
-*                  - TIM_Channel: specifies the TIM Channel
-*                    This parmeter can be one of the following values:
-*                       - TIM_Channel_1: TIM Channel 1
-*                       - TIM_Channel_2: TIM Channel 2
-*                       - TIM_Channel_3: TIM Channel 3
-*                       - TIM_Channel_4: TIM Channel 4
-*                 - TIM_CCx: specifies the TIM Channel CCxE bit new state.
-*                   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_CCX(TIM_CCx));
-
-  /* Reset the CCxE Bit */
-  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCE_Set &lt;&lt; TIM_Channel)));
-
-  /* Set or reset the CCxE Bit */ 
-  TIMx-&gt;CCER |=  (u16)(TIM_CCx &lt;&lt; TIM_Channel);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_CCxNCmd
-* Description    : Enables or disables the TIM Capture Compare Channel xN.
-* Input          :- TIMx: where x can be 1 or 8 to select the TIM peripheral.
-*                 - TIM_Channel: specifies the TIM Channel
-*                    This parmeter can be one of the following values:
-*                       - TIM_Channel_1: TIM Channel 1
-*                       - TIM_Channel_2: TIM Channel 2
-*                       - TIM_Channel_3: TIM Channel 3
-*                 - TIM_CCx: specifies the TIM Channel CCxNE bit new state.
-*                   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_18_PERIPH(TIMx));
-  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_CCXN(TIM_CCxN));
-
-  /* Reset the CCxNE Bit */
-  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCNE_Set &lt;&lt; TIM_Channel)));
-
-  /* Set or reset the CCxNE Bit */ 
-  TIMx-&gt;CCER |=  (u16)(TIM_CCxN &lt;&lt; TIM_Channel);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectOCxM
-* Description    : Selects the TIM Ouput Compare Mode.
-*                  This function disables the selected channel before changing 
-*                  the Ouput Compare Mode. User has to enable this channel using
-*                  TIM_CCxCmd and TIM_CCxNCmd functions.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
-*                    peripheral.
-*                  - TIM_Channel: specifies the TIM Channel
-*                    This parmeter can be one of the following values:
-*                       - TIM_Channel_1: TIM Channel 1
-*                       - TIM_Channel_2: TIM Channel 2
-*                       - TIM_Channel_3: TIM Channel 3
-*                       - TIM_Channel_4: TIM Channel 4
-*                  - TIM_OCMode: specifies the TIM Output Compare Mode.
-*                    This paramter can be one of the following values:
-*                       - TIM_OCMode_Timing
-*                       - TIM_OCMode_Active
-*                       - TIM_OCMode_Toggle
-*                       - TIM_OCMode_PWM1
-*                       - TIM_OCMode_PWM2
-*                       - TIM_ForcedAction_Active
-*                       - TIM_ForcedAction_InActive
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_OCM(TIM_OCMode));
-  
-  /* Disable the Channel: Reset the CCxE Bit */
-  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCE_Set &lt;&lt; TIM_Channel)));
-
-  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
-  {
-    /* Reset the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + (TIM_Channel&gt;&gt;1))) &amp;= CCMR_OC13M_Mask;
-   
-    /* Configure the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + (TIM_Channel&gt;&gt;1))) |= TIM_OCMode;
-
-  }
-  else
-  {
-    /* Reset the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)&gt;&gt; 1))) &amp;= CCMR_OC24M_Mask;
-    
-    /* Configure the OCxM bits in the CCMRx register */
-    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)&gt;&gt; 1))) |= (u16)(TIM_OCMode &lt;&lt; 8);
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_UpdateDisableConfig
-* Description    : Enables or Disables the TIMx Update event.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - NewState: new state of the TIMx UDIS bit
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the Update Disable Bit */
-    TIMx-&gt;CR1 |= CR1_UDIS_Set;
-  }
-  else
-  {
-    /* Reset the Update Disable Bit */
-    TIMx-&gt;CR1 &amp;= CR1_UDIS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_UpdateRequestConfig
-* Description    : Configures the TIMx Update Request Interrupt source.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_UpdateSource: specifies the Update source.
-*                    This parameter can be one of the following values:
-*                       - TIM_UpdateSource_Regular
-*                       - TIM_UpdateSource_Global
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
-
-  if (TIM_UpdateSource != TIM_UpdateSource_Global)
-  {
-    /* Set the URS Bit */
-    TIMx-&gt;CR1 |= CR1_URS_Set;
-  }
-  else
-  {
-    /* Reset the URS Bit */
-    TIMx-&gt;CR1 &amp;= CR1_URS_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectHallSensor
-* Description    : Enables or disables the TIMx&#146;s Hall sensor interface.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-*                  - NewState: new state of the TIMx Hall sensor interface.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Set the TI1S Bit */
-    TIMx-&gt;CR2 |= CR2_TI1S_Set;
-  }
-  else
-  {
-    /* Reset the TI1S Bit */
-    TIMx-&gt;CR2 &amp;= CR2_TI1S_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectOnePulseMode
-* Description    : Selects the TIMx&#146;s One Pulse Mode.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_OPMode: specifies the OPM Mode to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_OPMode_Single
-*                       - TIM_OPMode_Repetitive
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
-
-  /* Reset the OPM Bit */
-  TIMx-&gt;CR1 &amp;= CR1_OPM_Reset;
-
-  /* Configure the OPM Mode */
-  TIMx-&gt;CR1 |= TIM_OPMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectOutputTrigger
-* Description    : Selects the TIMx Trigger Output Mode.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_TRGOSource: specifies the Trigger Output source.
-*                    This paramter can be as follow:
-*                      1/ For TIM1 to TIM8:
-*                       - TIM_TRGOSource_Reset 
-*                       - TIM_TRGOSource_Enable
-*                       - TIM_TRGOSource_Update
-*                      2/ These parameters are available for all TIMx except 
-*                         TIM6 and TIM7:
-*                       - TIM_TRGOSource_OC1
-*                       - TIM_TRGOSource_OC1Ref
-*                       - TIM_TRGOSource_OC2Ref
-*                       - TIM_TRGOSource_OC3Ref
-*                       - TIM_TRGOSource_OC4Ref
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
-  assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
-
-  /* Reset the MMS Bits */
-  TIMx-&gt;CR2 &amp;= CR2_MMS_Mask;
-
-  /* Select the TRGO source */
-  TIMx-&gt;CR2 |=  TIM_TRGOSource;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectSlaveMode
-* Description    : Selects the TIMx Slave Mode.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_SlaveMode: specifies the Timer Slave Mode.
-*                    This paramter can be one of the following values:
-*                       - TIM_SlaveMode_Reset
-*                       - TIM_SlaveMode_Gated
-*                       - TIM_SlaveMode_Trigger
-*                       - TIM_SlaveMode_External1
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
-
-  /* Reset the SMS Bits */
-  TIMx-&gt;SMCR &amp;= SMCR_SMS_Mask;
-
-  /* Select the Slave Mode */
-  TIMx-&gt;SMCR |= TIM_SlaveMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SelectMasterSlaveMode
-* Description    : Sets or Resets the TIMx Master/Slave Mode.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
-*                    This paramter can be one of the following values:
-*                       - TIM_MasterSlaveMode_Enable: synchronization between the
-*                         current timer and its slaves (through TRGO).
-*                       - TIM_MasterSlaveMode_Disable: No action
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
-
-  /* Reset the MSM Bit */
-  TIMx-&gt;SMCR &amp;= SMCR_MSM_Reset;
-  
-  /* Set or Reset the MSM Bit */
-  TIMx-&gt;SMCR |= TIM_MasterSlaveMode;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCounter
-* Description    : Sets the TIMx Counter Register value
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - Counter: specifies the Counter register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Set the Counter Register value */
-  TIMx-&gt;CNT = Counter;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetAutoreload
-* Description    : Sets the TIMx Autoreload Register value
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - Autoreload: specifies the Autoreload register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Set the Autoreload Register value */
-  TIMx-&gt;ARR = Autoreload;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare1
-* Description    : Sets the TIMx Capture Compare1 Register value
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - Compare1: specifies the Capture Compare1 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare1 Register value */
-  TIMx-&gt;CCR1 = Compare1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare2
-* Description    : Sets the TIMx Capture Compare2 Register value
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-*                  - Compare2: specifies the Capture Compare2 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare2 Register value */
-  TIMx-&gt;CCR2 = Compare2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare3
-* Description    : Sets the TIMx Capture Compare3 Register value
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-*                  - Compare3: specifies the Capture Compare3 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare3 Register value */
-  TIMx-&gt;CCR3 = Compare3;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetCompare4
-* Description    : Sets the TIMx Capture Compare4 Register value
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-*                  - Compare4: specifies the Capture Compare4 register new value.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Set the Capture Compare4 Register value */
-  TIMx-&gt;CCR4 = Compare4;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC1Prescaler
-* Description    : Sets the TIMx Input Capture 1 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture1 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPSC_DIV1: no prescaler
-*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC1PSC Bits */
-  TIMx-&gt;CCMR1 &amp;= CCMR_IC13PSC_Mask;
-
-  /* Set the IC1PSC value */
-  TIMx-&gt;CCMR1 |= TIM_ICPSC;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC2Prescaler
-* Description    : Sets the TIMx Input Capture 2 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture2 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPSC_DIV1: no prescaler
-*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC2PSC Bits */
-  TIMx-&gt;CCMR1 &amp;= CCMR_IC24PSC_Mask;
-
-  /* Set the IC2PSC value */
-  TIMx-&gt;CCMR1 |= (u16)(TIM_ICPSC &lt;&lt; 8);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC3Prescaler
-* Description    : Sets the TIMx Input Capture 3 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture3 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPSC_DIV1: no prescaler
-*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC3PSC Bits */
-  TIMx-&gt;CCMR2 &amp;= CCMR_IC13PSC_Mask;
-
-  /* Set the IC3PSC value */
-  TIMx-&gt;CCMR2 |= TIM_ICPSC;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetIC4Prescaler
-* Description    : Sets the TIMx Input Capture 4 prescaler.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPSC: specifies the Input Capture4 prescaler
-*                    new value.
-*                    This parameter can be one of the following values:
-*                      - TIM_ICPSC_DIV1: no prescaler
-*                      - TIM_ICPSC_DIV2: capture is done once every 2 events
-*                      - TIM_ICPSC_DIV4: capture is done once every 4 events
-*                      - TIM_ICPSC_DIV8: capture is done once every 8 events
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-
-  /* Reset the IC4PSC Bits */
-  TIMx-&gt;CCMR2 &amp;= CCMR_IC24PSC_Mask;
-
-  /* Set the IC4PSC value */
-  TIMx-&gt;CCMR2 |= (u16)(TIM_ICPSC &lt;&lt; 8);
-}
-
-/*******************************************************************************
-* Function Name  : TIM_SetClockDivision
-* Description    : Sets the TIMx Clock Division value.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_CKD: specifies the clock division value.
-*                    This parameter can be one of the following value:
-*                       - TIM_CKD_DIV1: TDTS = Tck_tim
-*                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
-*                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
-
-  /* Reset the CKD Bits */
-  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask;
-
-  /* Set the CKD value */
-  TIMx-&gt;CR1 |= TIM_CKD;
-}
-/*******************************************************************************
-* Function Name  : TIM_GetCapture1
-* Description    : Gets the TIMx Input Capture 1 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 1 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Get the Capture 1 Register value */
-  return TIMx-&gt;CCR1;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCapture2
-* Description    : Gets the TIMx Input Capture 2 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 2 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Get the Capture 2 Register value */
-  return TIMx-&gt;CCR2;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCapture3
-* Description    : Gets the TIMx Input Capture 3 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 3 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
-
-  /* Get the Capture 3 Register value */
-  return TIMx-&gt;CCR3;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCapture4
-* Description    : Gets the TIMx Input Capture 4 value.
-* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                   peripheral.
-* Output         : None
-* Return         : Capture Compare 4 Register value.
-*******************************************************************************/
-u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_123458_PERIPH(TIMx));
-
-  /* Get the Capture 4 Register value */
-  return TIMx-&gt;CCR4;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetCounter
-* Description    : Gets the TIMx Counter value.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-* Output         : None
-* Return         : Counter Register value.
-*******************************************************************************/
-u16 TIM_GetCounter(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Get the Counter Register value */
-  return TIMx-&gt;CNT;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetPrescaler
-* Description    : Gets the TIMx Prescaler value.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-* Output         : None
-* Return         : Prescaler Register value.
-*******************************************************************************/
-u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-
-  /* Get the Prescaler Register value */
-  return TIMx-&gt;PSC;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetFlagStatus
-* Description    : Checks whether the specified TIM flag is set or not.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - TIM_FLAG_Update: TIM update Flag
-*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
-*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
-*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
-*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
-*                       - TIM_FLAG_COM: TIM Commutation Flag
-*                       - TIM_FLAG_Trigger: TIM Trigger Flag
-*                       - TIM_FLAG_Break: TIM Break Flag
-*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
-*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
-*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
-*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
-* Output         : None
-* Return         : The new state of TIM_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
-{ 
-  ITStatus bitstatus = RESET;  
-
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
-  assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
-  
-  if ((TIMx-&gt;SR &amp; TIM_FLAG) != (u16)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearFlag
-* Description    : Clears the TIMx's pending flags.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_FLAG: specifies the flag bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_FLAG_Update: TIM update Flag
-*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
-*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
-*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
-*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
-*                       - TIM_FLAG_COM: TIM Commutation Flag
-*                       - TIM_FLAG_Trigger: TIM Trigger Flag
-*                       - TIM_FLAG_Break: TIM Break Flag
-*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
-*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
-*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
-*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
-   
-  /* Clear the flags */
-  TIMx-&gt;SR = (u16)~TIM_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_GetITStatus
-* Description    : Checks whether the TIM interrupt has occurred or not.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_IT: specifies the TIM interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - TIM_IT_Update: TIM update Interrupt source
-*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-*                       - TIM_IT_COM: TIM Commutation Interrupt
-*                         source
-*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
-*                       - TIM_IT_Break: TIM Break Interrupt source
-* Output         : None
-* Return         : The new state of the TIM_IT(SET or RESET).
-*******************************************************************************/
-ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
-{
-  ITStatus bitstatus = RESET;  
-  u16 itstatus = 0x0, itenable = 0x0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_GET_IT(TIM_IT));
-  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
-   
-  itstatus = TIMx-&gt;SR &amp; TIM_IT;
-  
-  itenable = TIMx-&gt;DIER &amp; TIM_IT;
-
-  if ((itstatus != (u16)RESET) &amp;&amp; (itenable != (u16)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : TIM_ClearITPendingBit
-* Description    : Clears the TIMx's interrupt pending bits.
-* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
-*                  - TIM_IT: specifies the pending bit to clear.
-*                    This parameter can be any combination of the following values:
-*                       - TIM_IT_Update: TIM1 update Interrupt source
-*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-*                       - TIM_IT_COM: TIM Commutation Interrupt
-*                         source
-*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
-*                       - TIM_IT_Break: TIM Break Interrupt source
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
-
-  /* Clear the IT pending Bit */
-  TIMx-&gt;SR = (u16)~TIM_IT;
-}
-
-/*******************************************************************************
-* Function Name  : TI1_Config
-* Description    : Configure the TI1 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
-*                         be connected to IC1.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
-*                         be connected to IC2.
-*                       - TIM_ICSelection_TRC: TIM Input 1 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr1 = 0, tmpccer = 0;
-
-  /* Disable the Channel 1: Reset the CC1E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-  tmpccer = TIMx-&gt;CCER;
-
-  /* Select the Input and set the filter */
-  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
-  tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter &lt;&lt; 4);
-
-  /* Select the Polarity and set the CC1E Bit */
-  tmpccer &amp;= CCER_CC1P_Reset;
-  tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
-
-  /* Write to TIMx CCMR1 and CCER registers */
-  TIMx-&gt;CCMR1 = tmpccmr1;
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TI2_Config
-* Description    : Configure the TI2 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
-*                         be connected to IC2.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
-*                         be connected to IC1.
-*                       - TIM_ICSelection_TRC: TIM Input 2 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
-
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
-
-  tmpccmr1 = TIMx-&gt;CCMR1;
-  tmpccer = TIMx-&gt;CCER;
-  tmp = (u16)(TIM_ICPolarity &lt;&lt; 4);
-
-  /* Select the Input and set the filter */
-  tmpccmr1 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
-  tmpccmr1 |= (u16)(TIM_ICFilter &lt;&lt; 12);
-  tmpccmr1 |= (u16)(TIM_ICSelection &lt;&lt; 8);
-
-  /* Select the Polarity and set the CC2E Bit */
-  tmpccer &amp;= CCER_CC2P_Reset;
-  tmpccer |=  tmp | CCER_CC2E_Set;
-
-  /* Write to TIMx CCMR1 and CCER registers */
-  TIMx-&gt;CCMR1 = tmpccmr1 ;
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TI3_Config
-* Description    : Configure the TI3 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
-*                         be connected to IC3.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
-*                         be connected to IC4.
-*                       - TIM_ICSelection_TRC: TIM Input 3 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
-
-  /* Disable the Channel 3: Reset the CC3E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-  tmpccer = TIMx-&gt;CCER;
-  tmp = (u16)(TIM_ICPolarity &lt;&lt; 8);
-
-  /* Select the Input and set the filter */
-  tmpccmr2 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
-  tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter &lt;&lt; 4);
-
-  /* Select the Polarity and set the CC3E Bit */
-  tmpccer &amp;= CCER_CC3P_Reset;
-  tmpccer |= tmp | CCER_CC3E_Set;
-
-  /* Write to TIMx CCMR2 and CCER registers */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-  TIMx-&gt;CCER = tmpccer;
-}
-
-/*******************************************************************************
-* Function Name  : TI4_Config
-* Description    : Configure the TI1 as Input.
-* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
-*                    peripheral.
-*                  - TIM_ICPolarity : The Input Polarity.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICPolarity_Rising
-*                       - TIM_ICPolarity_Falling
-*                  - TIM_ICSelection: specifies the input to be used.
-*                    This parameter can be one of the following values:
-*                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
-*                         be connected to IC4.
-*                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
-*                         be connected to IC3.
-*                       - TIM_ICSelection_TRC: TIM Input 4 is selected to be
-*                         connected to TRC.
-*                  - TIM_ICFilter: Specifies the Input Capture Filter.
-*                    This parameter must be a value between 0x00 and 0x0F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
-                       u16 TIM_ICFilter)
-{
-  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
-
-  /* Disable the Channel 4: Reset the CC4E Bit */
-  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
-
-  tmpccmr2 = TIMx-&gt;CCMR2;
-  tmpccer = TIMx-&gt;CCER;
-  tmp = (u16)(TIM_ICPolarity &lt;&lt; 12);
-
-  /* Select the Input and set the filter */
-  tmpccmr2 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
-  tmpccmr2 |= (u16)(TIM_ICSelection &lt;&lt; 8) | (u16)(TIM_ICFilter &lt;&lt; 12);
-
-  /* Select the Polarity and set the CC4E Bit */
-  tmpccer &amp;= CCER_CC4P_Reset;
-  tmpccer |= tmp | CCER_CC4E_Set;
-
-  /* Write to TIMx CCMR2 and CCER registers */
-  TIMx-&gt;CCMR2 = tmpccmr2;
-  TIMx-&gt;CCER = tmpccer ;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_tim.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the TIM firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_tim.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ---------------------- TIM registers bit mask ------------------------ */
+#define CR1_CEN_Set                 ((u16)0x0001)
+#define CR1_CEN_Reset               ((u16)0x03FE)
+#define CR1_UDIS_Set                ((u16)0x0002)
+#define CR1_UDIS_Reset              ((u16)0x03FD)
+#define CR1_URS_Set                 ((u16)0x0004)
+#define CR1_URS_Reset               ((u16)0x03FB)
+#define CR1_OPM_Reset               ((u16)0x03F7)
+#define CR1_CounterMode_Mask        ((u16)0x038F)
+#define CR1_ARPE_Set                ((u16)0x0080)
+#define CR1_ARPE_Reset              ((u16)0x037F)
+#define CR1_CKD_Mask                ((u16)0x00FF)
+
+#define CR2_CCPC_Set                ((u16)0x0001)
+#define CR2_CCPC_Reset              ((u16)0xFFFE)
+#define CR2_CCUS_Set                ((u16)0x0004)
+#define CR2_CCUS_Reset              ((u16)0xFFFB)
+#define CR2_CCDS_Set                ((u16)0x0008)
+#define CR2_CCDS_Reset              ((u16)0xFFF7)
+#define CR2_MMS_Mask                ((u16)0xFF8F)
+#define CR2_TI1S_Set                ((u16)0x0080)
+#define CR2_TI1S_Reset              ((u16)0xFF7F)
+#define CR2_OIS1_Reset              ((u16)0x7EFF)
+#define CR2_OIS1N_Reset             ((u16)0x7DFF)
+#define CR2_OIS2_Reset              ((u16)0x7BFF)
+#define CR2_OIS2N_Reset             ((u16)0x77FF)
+#define CR2_OIS3_Reset              ((u16)0x6FFF)
+#define CR2_OIS3N_Reset             ((u16)0x5FFF)
+#define CR2_OIS4_Reset              ((u16)0x3FFF)
+
+#define SMCR_SMS_Mask               ((u16)0xFFF8)
+#define SMCR_ETR_Mask               ((u16)0x00FF)
+#define SMCR_TS_Mask                ((u16)0xFF8F)
+#define SMCR_MSM_Reset              ((u16)0xFF7F)
+#define SMCR_ECE_Set                ((u16)0x4000)
+
+#define CCMR_CC13S_Mask             ((u16)0xFFFC)
+#define CCMR_CC24S_Mask             ((u16)0xFCFF)
+#define CCMR_TI13Direct_Set         ((u16)0x0001)
+#define CCMR_TI24Direct_Set         ((u16)0x0100)
+#define CCMR_OC13FE_Reset           ((u16)0xFFFB)
+#define CCMR_OC24FE_Reset           ((u16)0xFBFF)
+#define CCMR_OC13PE_Reset           ((u16)0xFFF7)
+#define CCMR_OC24PE_Reset           ((u16)0xF7FF)
+#define CCMR_OC13M_Mask             ((u16)0xFF8F)
+#define CCMR_OC24M_Mask             ((u16)0x8FFF) 
+
+#define CCMR_OC13CE_Reset           ((u16)0xFF7F)
+#define CCMR_OC24CE_Reset           ((u16)0x7FFF)
+
+#define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
+#define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
+#define CCMR_IC13F_Mask             ((u16)0xFF0F)
+#define CCMR_IC24F_Mask             ((u16)0x0FFF)
+
+#define CCMR_Offset                 ((u16)0x0018)
+#define CCER_CCE_Set                ((u16)0x0001)
+#define	CCER_CCNE_Set               ((u16)0x0004)
+
+#define CCER_CC1P_Reset             ((u16)0xFFFD)
+#define CCER_CC2P_Reset             ((u16)0xFFDF)
+#define CCER_CC3P_Reset             ((u16)0xFDFF)
+#define CCER_CC4P_Reset             ((u16)0xDFFF)
+
+#define CCER_CC1NP_Reset            ((u16)0xFFF7)
+#define CCER_CC2NP_Reset            ((u16)0xFF7F)
+#define CCER_CC3NP_Reset            ((u16)0xF7FF)
+
+#define CCER_CC1E_Set               ((u16)0x0001)
+#define CCER_CC1E_Reset             ((u16)0xFFFE)
+
+#define CCER_CC1NE_Reset            ((u16)0xFFFB)
+
+#define CCER_CC2E_Set               ((u16)0x0010)
+#define CCER_CC2E_Reset             ((u16)0xFFEF)
+
+#define CCER_CC2NE_Reset            ((u16)0xFFBF)
+
+#define CCER_CC3E_Set               ((u16)0x0100)
+#define CCER_CC3E_Reset             ((u16)0xFEFF)
+
+#define CCER_CC3NE_Reset            ((u16)0xFBFF)
+
+#define CCER_CC4E_Set               ((u16)0x1000)
+#define CCER_CC4E_Reset             ((u16)0xEFFF)
+
+#define BDTR_MOE_Set                ((u16)0x8000)
+#define BDTR_MOE_Reset              ((u16)0x7FFF)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter);
+static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter);
+static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter);
+static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter);
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+/*******************************************************************************
+* Function Name  : TIM_DeInit
+* Description    : Deinitializes the TIMx peripheral registers to their default
+*                  reset values.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_DeInit(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
+ 
+  switch (*(u32*)&amp;TIMx)
+  {
+    case TIM1_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
+      break; 
+      
+    case TIM2_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
+      break;
+ 
+    case TIM3_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
+      break;
+ 
+    case TIM4_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
+      break;
+      
+    case TIM5_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
+      break;
+      
+    case TIM6_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
+      break;
+      
+    case TIM7_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
+      break;
+      
+    case TIM8_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
+      break; 
+      
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_TimeBaseInit
+* Description    : Initializes the TIMx Time Base Unit peripheral according to 
+*                  the specified parameters in the TIM_TimeBaseInitStruct.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
+*                   structure that contains the configuration information for
+*                   the specified TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct-&gt;TIM_CounterMode));
+  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision));
+
+  /* Select the Counter Mode and set the clock division */
+  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask &amp; CR1_CounterMode_Mask;
+  TIMx-&gt;CR1 |= (u32)TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision |
+                TIM_TimeBaseInitStruct-&gt;TIM_CounterMode;
+  /* Set the Autoreload value */
+  TIMx-&gt;ARR = TIM_TimeBaseInitStruct-&gt;TIM_Period ;
+
+  /* Set the Prescaler value */
+  TIMx-&gt;PSC = TIM_TimeBaseInitStruct-&gt;TIM_Prescaler;
+
+  /* Generate an update event to reload the Prescaler value immediatly */
+  TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;
+    
+  if (((*(u32*)&amp;TIMx) == TIM1_BASE) || ((*(u32*)&amp;TIMx) == TIM8_BASE))  
+  {
+    /* Set the Repetition Counter value */
+    TIMx-&gt;RCR = TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter;
+  }        
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC1Init
+* Description    : Initializes the TIMx Channel1 according to the specified
+*                  parameters in the TIM_OCInitStruct.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+*                    that contains the configuration information for the specified
+*                    TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+
+  /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx-&gt;CCMR1;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC13M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC1P_Reset;
+
+  /* Set the Output Compare Polarity */
+  tmpccer |= TIM_OCInitStruct-&gt;TIM_OCPolarity;
+  
+  /* Set the Output State */
+  tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputState;
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR1 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &amp;= CCER_CC1NP_Reset;
+
+    /* Set the Output N Polarity */
+    tmpccer |= TIM_OCInitStruct-&gt;TIM_OCNPolarity;
+
+    /* Reset the Output N State */
+    tmpccer &amp;= CCER_CC1NE_Reset;
+    
+    /* Set the Output N State */
+    tmpccer |= TIM_OCInitStruct-&gt;TIM_OutputNState;
+
+    /* Reset the Ouput Compare and Output Compare N IDLE State */
+    tmpcr2 &amp;= CR2_OIS1_Reset;
+    tmpcr2 &amp;= CR2_OIS1N_Reset;
+
+    /* Set the Output Idle state */
+    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCIdleState;
+
+    /* Set the Output N Idle state */
+    tmpcr2 |= TIM_OCInitStruct-&gt;TIM_OCNIdleState;
+  }
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC2Init
+* Description    : Initializes the TIMx Channel2 according to the specified
+*                  parameters in the TIM_OCInitStruct.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+*                    that contains the configuration information for the specified
+*                    TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
+  
+  /* Get the TIMx CCER register value */  
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR1 register value */
+  tmpccmrx = TIMx-&gt;CCMR1;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC24M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (u16)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC2P_Reset;
+
+  /* Set the Output Compare Polarity */
+  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 4);
+  
+  /* Set the Output State */
+  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 4);
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR2 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &amp;= CCER_CC2NP_Reset;
+
+    /* Set the Output N Polarity */
+    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 4);
+
+    /* Reset the Output N State */
+    tmpccer &amp;= CCER_CC2NE_Reset;
+    
+    /* Set the Output N State */
+    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 4);
+
+    /* Reset the Ouput Compare and Output Compare N IDLE State */
+    tmpcr2 &amp;= CR2_OIS2_Reset;
+    tmpcr2 &amp;= CR2_OIS2N_Reset;
+
+    /* Set the Output Idle state */
+    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 2);
+
+    /* Set the Output N Idle state */
+    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 2);
+  }
+
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC3Init
+* Description    : Initializes the TIMx Channel3 according to the specified
+*                  parameters in the TIM_OCInitStruct.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+*                    that contains the configuration information for the specified
+*                    TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx-&gt;CCMR2;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC13M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= TIM_OCInitStruct-&gt;TIM_OCMode;
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC3P_Reset;
+
+  /* Set the Output Compare Polarity */
+  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 8);
+  
+  /* Set the Output State */
+  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 8);
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR3 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct-&gt;TIM_OutputNState));
+    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct-&gt;TIM_OCNPolarity));
+    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCNIdleState));
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+    
+    /* Reset the Output N Polarity level */
+    tmpccer &amp;= CCER_CC3NP_Reset;
+
+    /* Set the Output N Polarity */
+    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNPolarity &lt;&lt; 8);
+
+    /* Reset the Output N State */
+    tmpccer &amp;= CCER_CC3NE_Reset;
+    
+    /* Set the Output N State */
+    tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputNState &lt;&lt; 8);
+
+    /* Reset the Ouput Compare and Output Compare N IDLE State */
+    tmpcr2 &amp;= CR2_OIS3_Reset;
+    tmpcr2 &amp;= CR2_OIS3N_Reset;
+
+    /* Set the Output Idle state */
+    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 4);
+
+    /* Set the Output N Idle state */
+    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCNIdleState &lt;&lt; 4);
+  }
+
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR2 */
+  TIMx-&gt;CCMR2 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC4Init
+* Description    : Initializes the TIMx Channel4 according to the specified
+*                  parameters in the TIM_OCInitStruct.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
+*                    that contains the configuration information for the specified
+*                    TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
+   
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct-&gt;TIM_OCMode));
+  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct-&gt;TIM_OutputState));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct-&gt;TIM_OCPolarity));   
+
+  /* Disable the Channel 2: Reset the CC4E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
+  
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Get the TIMx CR2 register value */
+  tmpcr2 =  TIMx-&gt;CR2;
+  
+  /* Get the TIMx CCMR2 register value */
+  tmpccmrx = TIMx-&gt;CCMR2;
+    
+  /* Reset the Output Compare Mode Bits */
+  tmpccmrx &amp;= CCMR_OC24M_Mask;
+  
+  /* Select the Output Compare Mode */
+  tmpccmrx |= (u16)(TIM_OCInitStruct-&gt;TIM_OCMode &lt;&lt; 8);
+  
+  /* Reset the Output Polarity level */
+  tmpccer &amp;= CCER_CC4P_Reset;
+
+  /* Set the Output Compare Polarity */
+  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OCPolarity &lt;&lt; 12);
+  
+  /* Set the Output State */
+  tmpccer |= (u16)(TIM_OCInitStruct-&gt;TIM_OutputState &lt;&lt; 12);
+  
+  /* Set the Capture Compare Register value */
+  TIMx-&gt;CCR4 = TIM_OCInitStruct-&gt;TIM_Pulse;
+  
+  if((*(u32*)&amp;TIMx == TIM1_BASE) || (*(u32*)&amp;TIMx == TIM8_BASE))
+  {
+    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct-&gt;TIM_OCIdleState));
+
+    /* Reset the Ouput Compare IDLE State */
+    tmpcr2 &amp;= CR2_OIS4_Reset;
+
+    /* Set the Output Idle state */
+    tmpcr2 |= (u16)(TIM_OCInitStruct-&gt;TIM_OCIdleState &lt;&lt; 6);
+  }
+
+  /* Write to TIMx CR2 */
+  TIMx-&gt;CR2 = tmpcr2;
+  
+  /* Write to TIMx CCMR2 */  
+  TIMx-&gt;CCMR2 = tmpccmrx;
+  
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ICInit
+* Description    : Initializes the TIM peripheral according to the specified
+*                  parameters in the TIM_ICInitStruct.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
+*                    that contains the configuration information for the specified
+*                    TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct-&gt;TIM_Channel));
+  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct-&gt;TIM_ICPolarity));
+  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct-&gt;TIM_ICSelection));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct-&gt;TIM_ICPrescaler));
+  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct-&gt;TIM_ICFilter));
+  
+  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
+  {
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_2)
+  {
+    /* TI2 Configuration */
+    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_3)
+  {
+    /* TI3 Configuration */
+    TI3_Config(TIMx,  TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else
+  {
+    /* TI4 Configuration */
+    TI4_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity,
+               TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_PWMIConfig
+* Description    : Configures the TIM peripheral according to the specified
+*                  parameters in the TIM_ICInitStruct to measure an external PWM
+*                  signal.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
+*                    that contains the configuration information for the specified
+*                    TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  u16 icoppositepolarity = TIM_ICPolarity_Rising;
+  u16 icoppositeselection = TIM_ICSelection_DirectTI;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Select the Opposite Input Polarity */
+  if (TIM_ICInitStruct-&gt;TIM_ICPolarity == TIM_ICPolarity_Rising)
+  {
+    icoppositepolarity = TIM_ICPolarity_Falling;
+  }
+  else
+  {
+    icoppositepolarity = TIM_ICPolarity_Rising;
+  }
+
+  /* Select the Opposite Input */
+  if (TIM_ICInitStruct-&gt;TIM_ICSelection == TIM_ICSelection_DirectTI)
+  {
+    icoppositeselection = TIM_ICSelection_IndirectTI;
+  }
+  else
+  {
+    icoppositeselection = TIM_ICSelection_DirectTI;
+  }
+
+  if (TIM_ICInitStruct-&gt;TIM_Channel == TIM_Channel_1)
+  {
+    /* TI1 Configuration */
+    TI1_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+
+    /* TI2 Configuration */
+    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+  else
+  { 
+    /* TI2 Configuration */
+    TI2_Config(TIMx, TIM_ICInitStruct-&gt;TIM_ICPolarity, TIM_ICInitStruct-&gt;TIM_ICSelection,
+               TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+
+    /* TI1 Configuration */
+    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct-&gt;TIM_ICFilter);
+
+    /* Set the Input Capture Prescaler value */
+    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct-&gt;TIM_ICPrescaler);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_BDTRConfig
+* Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
+*                  the OSSR State and the AOE(automatic output enable).
+* Input          :- TIMx: where x can be  1 or 8 to select the TIM 
+*                 - TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef
+*                    structure that contains the BDTR Register configuration
+*                    information for the TIM peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSRState));
+  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct-&gt;TIM_OSSIState));
+  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct-&gt;TIM_LOCKLevel));
+  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct-&gt;TIM_Break));
+  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct-&gt;TIM_BreakPolarity));
+  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput));
+
+  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
+     the OSSI State, the dead time value and the Automatic Output Enable Bit */
+
+  TIMx-&gt;BDTR = (u32)TIM_BDTRInitStruct-&gt;TIM_OSSRState | TIM_BDTRInitStruct-&gt;TIM_OSSIState |
+             TIM_BDTRInitStruct-&gt;TIM_LOCKLevel | TIM_BDTRInitStruct-&gt;TIM_DeadTime |
+             TIM_BDTRInitStruct-&gt;TIM_Break | TIM_BDTRInitStruct-&gt;TIM_BreakPolarity |
+             TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput;
+
+}
+
+/*******************************************************************************
+* Function Name  : TIM_TimeBaseStructInit
+* Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
+* Input          : - TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
+*                    structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
+{
+  /* Set the default configuration */
+  TIM_TimeBaseInitStruct-&gt;TIM_Period = 0xFFFF;
+  TIM_TimeBaseInitStruct-&gt;TIM_Prescaler = 0x0000;
+  TIM_TimeBaseInitStruct-&gt;TIM_ClockDivision = TIM_CKD_DIV1;
+  TIM_TimeBaseInitStruct-&gt;TIM_CounterMode = TIM_CounterMode_Up;
+  TIM_TimeBaseInitStruct-&gt;TIM_RepetitionCounter = 0x0000;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OCStructInit
+* Description    : Fills each TIM_OCInitStruct member with its default value.
+* Input          : - TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
+{
+  /* Set the default configuration */
+  TIM_OCInitStruct-&gt;TIM_OCMode = TIM_OCMode_Timing;
+  TIM_OCInitStruct-&gt;TIM_OutputState = TIM_OutputState_Disable;
+  TIM_OCInitStruct-&gt;TIM_OutputNState = TIM_OutputNState_Disable;
+  TIM_OCInitStruct-&gt;TIM_Pulse = 0x0000;
+  TIM_OCInitStruct-&gt;TIM_OCPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct-&gt;TIM_OCNPolarity = TIM_OCPolarity_High;
+  TIM_OCInitStruct-&gt;TIM_OCIdleState = TIM_OCIdleState_Reset;
+  TIM_OCInitStruct-&gt;TIM_OCNIdleState = TIM_OCNIdleState_Reset;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ICStructInit
+* Description    : Fills each TIM_ICInitStruct member with its default value.
+* Input          : - TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
+{
+  /* Set the default configuration */
+  TIM_ICInitStruct-&gt;TIM_Channel = TIM_Channel_1;
+  TIM_ICInitStruct-&gt;TIM_ICPolarity = TIM_ICPolarity_Rising;
+  TIM_ICInitStruct-&gt;TIM_ICSelection = TIM_ICSelection_DirectTI;
+  TIM_ICInitStruct-&gt;TIM_ICPrescaler = TIM_ICPSC_DIV1;
+  TIM_ICInitStruct-&gt;TIM_ICFilter = 0x00;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_BDTRStructInit
+* Description    : Fills each TIM_BDTRInitStruct member with its default value.
+* Input          : - TIM_BDTRInitStruct : pointer to a TIM_BDTRInitTypeDef
+*                    structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
+{
+  /* Set the default configuration */
+  TIM_BDTRInitStruct-&gt;TIM_OSSRState = TIM_OSSRState_Disable;
+  TIM_BDTRInitStruct-&gt;TIM_OSSIState = TIM_OSSIState_Disable;
+  TIM_BDTRInitStruct-&gt;TIM_LOCKLevel = TIM_LOCKLevel_OFF;
+  TIM_BDTRInitStruct-&gt;TIM_DeadTime = 0x00;
+  TIM_BDTRInitStruct-&gt;TIM_Break = TIM_Break_Disable;
+  TIM_BDTRInitStruct-&gt;TIM_BreakPolarity = TIM_BreakPolarity_Low;
+  TIM_BDTRInitStruct-&gt;TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_Cmd
+* Description    : Enables or disables the specified TIM peripheral.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
+*                  - NewState: new state of the TIMx peripheral.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Counter */
+    TIMx-&gt;CR1 |= CR1_CEN_Set;
+  }
+  else
+  {
+    /* Disable the TIM Counter */
+    TIMx-&gt;CR1 &amp;= CR1_CEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_CtrlPWMOutputs
+* Description    : Enables or disables the TIM peripheral Main Outputs.
+* Input          :- TIMx: where x can be 1 or 8 to select the TIMx peripheral.
+*                 - NewState: new state of the TIM peripheral Main Outputs.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the TIM Main Output */
+    TIMx-&gt;BDTR |= BDTR_MOE_Set;
+  }
+  else
+  {
+    /* Disable the TIM Main Output */
+    TIMx-&gt;BDTR &amp;= BDTR_MOE_Reset;
+  }  
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ITConfig
+* Description    : Enables or disables the specified TIM interrupts.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
+*                  - TIM_IT: specifies the TIM interrupts sources to be enabled
+*                    or disabled.
+*                    This parameter can be any combination of the following values:
+*                       - TIM_IT_Update: TIM update Interrupt source
+*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+*                       - TIM_IT_COM: TIM Commutation Interrupt source
+*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
+*                       - TIM_IT_Break: TIM Break Interrupt source
+*                  - NewState: new state of the TIM interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_IT(TIM_IT));
+  assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the Interrupt sources */
+    TIMx-&gt;DIER |= TIM_IT;
+  }
+  else
+  {
+    /* Disable the Interrupt sources */
+    TIMx-&gt;DIER &amp;= (u16)~TIM_IT;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GenerateEvent
+* Description    : Configures the TIMx event to be generate by software.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_EventSource: specifies the event source.
+*                    This parameter can be one or more of the following values:	   
+*                       - TIM_EventSource_Update: Timer update Event source
+*                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
+*                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
+*                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
+*                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
+*                       - TIM_EventSource_Trigger: Timer Trigger Event source
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
+  assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
+
+  /* Set the event sources */
+  TIMx-&gt;EGR = TIM_EventSource;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_DMAConfig
+* Description    : Configures the TIMx's DMA interface.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_DMABase: DMA Base address.
+*                    This parameter can be one of the following values:
+*                       - TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
+*                         TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
+*                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
+*                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
+*                         TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
+*                         TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
+*                         TIM_DMABase_DCR.
+*                   - TIM_DMABurstLength: DMA Burst length.
+*                     This parameter can be one value between:
+*                     TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
+  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
+
+  /* Set the DMA Base and the DMA Burst Length */
+  TIMx-&gt;DCR = TIM_DMABase | TIM_DMABurstLength;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_DMACmd
+* Description    : Enables or disables the TIMx's DMA Requests.
+* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral. 
+*                  - TIM_DMASources: specifies the DMA Request sources.
+*                    This parameter can be any combination of the following values:
+*                       - TIM_DMA_Update: TIM update Interrupt source
+*                       - TIM_DMA_CC1: TIM Capture Compare 1 DMA source
+*                       - TIM_DMA_CC2: TIM Capture Compare 2 DMA source
+*                       - TIM_DMA_CC3: TIM Capture Compare 3 DMA source
+*                       - TIM_DMA_CC4: TIM Capture Compare 4 DMA source
+*                       - TIM_DMA_COM: TIM Commutation DMA source
+*                       - TIM_DMA_Trigger: TIM Trigger DMA source
+*                  - NewState: new state of the DMA Request sources.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
+  assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA sources */
+    TIMx-&gt;DIER |= TIM_DMASource; 
+  }
+  else
+  {
+    /* Disable the DMA sources */
+    TIMx-&gt;DIER &amp;= (u16)~TIM_DMASource;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_InternalClockConfig
+* Description    : Configures the TIMx interrnal Clock
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Disable slave mode to clock the prescaler directly with the internal clock */
+  TIMx-&gt;SMCR &amp;=  SMCR_SMS_Mask;
+}
+/*******************************************************************************
+* Function Name  : TIM_ITRxExternalClockConfig
+* Description    : Configures the TIMx Internal Trigger as External Clock
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ITRSource: Trigger source.
+*                    This parameter can be one of the following values:
+*                       - TIM_TS_ITR0: Internal Trigger 0
+*                       - TIM_TS_ITR1: Internal Trigger 1
+*                       - TIM_TS_ITR2: Internal Trigger 2
+*                       - TIM_TS_ITR3: Internal Trigger 3
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
+
+  /* Select the Internal Trigger */
+  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
+
+  /* Select the External clock mode1 */
+  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
+}
+/*******************************************************************************
+* Function Name  : TIM_TIxExternalClockConfig
+* Description    : Configures the TIMx Trigger as External Clock
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_TIxExternalCLKSource: Trigger source.
+*                    This parameter can be one of the following values:
+*                       - TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
+*                       - TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
+*                       - TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
+*                  - TIM_ICPolarity: specifies the TIx Polarity.
+*                    This parameter can be:
+*                       - TIM_ICPolarity_Rising
+*                       - TIM_ICPolarity_Falling
+*                   - ICFilter : specifies the filter value.
+*                     This parameter must be a value between 0x0 and 0xF.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
+                                u16 TIM_ICPolarity, u16 ICFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
+  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
+  assert_param(IS_TIM_IC_FILTER(ICFilter));
+
+  /* Configure the Timer Input Clock Source */
+  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
+  {
+    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+  else
+  {
+    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
+  }
+
+  /* Select the Trigger source */
+  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
+
+  /* Select the External clock mode1 */
+  TIMx-&gt;SMCR |= TIM_SlaveMode_External1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ETRClockMode1Config
+* Description    : Configures the External clock Mode1
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+*                    It can be one of the following values:
+*                       - TIM_ExtTRGPSC_OFF
+*                       - TIM_ExtTRGPSC_DIV2
+*                       - TIM_ExtTRGPSC_DIV4
+*                       - TIM_ExtTRGPSC_DIV8.
+*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
+*                    It can be one of the following values:
+*                       - TIM_ExtTRGPolarity_Inverted
+*                       - TIM_ExtTRGPolarity_NonInverted
+*                  - ExtTRGFilter: External Trigger Filter.
+*                    This parameter must be a value between 0x00 and 0x0F
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
+                             u16 ExtTRGFilter)
+{
+  u16 tmpsmcr = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+  
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx-&gt;SMCR;
+
+  /* Reset the SMS Bits */
+  tmpsmcr &amp;= SMCR_SMS_Mask;
+  /* Select the External clock mode1 */
+  tmpsmcr |= TIM_SlaveMode_External1;
+
+  /* Select the Trigger selection : ETRF */
+  tmpsmcr &amp;= SMCR_TS_Mask;
+  tmpsmcr |= TIM_TS_ETRF;
+
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ETRClockMode2Config
+* Description    : Configures the External clock Mode2
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+*                    It can be one of the following values:
+*                       - TIM_ExtTRGPSC_OFF
+*                       - TIM_ExtTRGPSC_DIV2
+*                       - TIM_ExtTRGPSC_DIV4
+*                       - TIM_ExtTRGPSC_DIV8
+*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
+*                    It can be one of the following values:
+*                       - TIM_ExtTRGPolarity_Inverted
+*                       - TIM_ExtTRGPolarity_NonInverted
+*                  - ExtTRGFilter: External Trigger Filter.
+*                    This parameter must be a value between 0x00 and 0x0F
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
+                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+
+  /* Configure the ETR Clock source */
+  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
+
+  /* Enable the External clock mode2 */
+  TIMx-&gt;SMCR |= SMCR_ECE_Set;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ETRConfig
+* Description    : Configures the TIMx External Trigger (ETR).
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
+*                    This parameter can be one of the following values:
+*                       - TIM_ExtTRGPSC_OFF
+*                       - TIM_ExtTRGPSC_DIV2
+*                       - TIM_ExtTRGPSC_DIV4
+*                       - TIM_ExtTRGPSC_DIV8
+*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
+*                    This parameter can be one of the following values:
+*                       - TIM_ExtTRGPolarity_Inverted
+*                       - TIM_ExtTRGPolarity_NonInverted
+*                  - ExtTRGFilter: External Trigger Filter.
+*                    This parameter must be a value between 0x00 and 0x0F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
+                   u16 ExtTRGFilter)
+{
+  u16 tmpsmcr = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
+  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
+  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
+
+  tmpsmcr = TIMx-&gt;SMCR;
+
+  /* Reset the ETR Bits */
+  tmpsmcr &amp;= SMCR_ETR_Mask;
+
+  /* Set the Prescaler, the Filter value and the Polarity */
+  tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter &lt;&lt; 8);
+
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_PrescalerConfig
+* Description    : Configures the TIMx Prescaler.
+* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral.
+*                  - Prescaler: specifies the Prescaler Register value
+*                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
+*                    This parameter can be one of the following values:
+*                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
+*                         the update event.
+*                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
+*                         immediatly.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
+
+  /* Set the Prescaler value */
+  TIMx-&gt;PSC = Prescaler;
+
+  /* Set or reset the UG Bit */
+  TIMx-&gt;EGR = TIM_PSCReloadMode;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_CounterModeConfig
+* Description    : Specifies the TIMx Counter Mode to be used.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_CounterMode: specifies the Counter Mode to be used
+*                    This parameter can be one of the following values:
+*                       - TIM_CounterMode_Up: TIM Up Counting Mode
+*                       - TIM_CounterMode_Down: TIM Down Counting Mode
+*                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
+*                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
+*                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
+{
+  u16 tmpcr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
+
+  tmpcr1 = TIMx-&gt;CR1;
+
+  /* Reset the CMS and DIR Bits */
+  tmpcr1 &amp;= CR1_CounterMode_Mask;
+
+  /* Set the Counter Mode */
+  tmpcr1 |= TIM_CounterMode;
+
+  /* Write to TIMx CR1 register */
+  TIMx-&gt;CR1 = tmpcr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectInputTrigger
+* Description    : Selects the Input Trigger source
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_InputTriggerSource: The Input Trigger source.
+*                    This parameter can be one of the following values:
+*                       - TIM_TS_ITR0: Internal Trigger 0
+*                       - TIM_TS_ITR1: Internal Trigger 1
+*                       - TIM_TS_ITR2: Internal Trigger 2
+*                       - TIM_TS_ITR3: Internal Trigger 3
+*                       - TIM_TS_TI1F_ED: TI1 Edge Detector
+*                       - TIM_TS_TI1FP1: Filtered Timer Input 1
+*                       - TIM_TS_TI2FP2: Filtered Timer Input 2
+*                       - TIM_TS_ETRF: External Trigger input
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
+{
+  u16 tmpsmcr = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
+
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx-&gt;SMCR;
+
+  /* Reset the TS Bits */
+  tmpsmcr &amp;= SMCR_TS_Mask;
+
+  /* Set the Input Trigger source */
+  tmpsmcr |= TIM_InputTriggerSource;
+
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_EncoderInterfaceConfig
+* Description    : Configures the TIMx Encoder Interface.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
+*                    This parameter can be one of the following values:
+*                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
+*                         depending on TI2FP2 level.
+*                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
+*                         depending on TI1FP1 level.
+*                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
+*                         TI2FP2 edges depending on the level of the other input.
+*                  - TIM_IC1Polarity: specifies the IC1 Polarity
+*                    This parmeter can be one of the following values:
+*                        - TIM_ICPolarity_Falling: IC Falling edge.
+*                        - TIM_ICPolarity_Rising: IC Rising edge.
+*                  - TIM_IC2Polarity: specifies the IC2 Polarity
+*                    This parmeter can be one of the following values:
+*                        - TIM_ICPolarity_Falling: IC Falling edge.
+*                        - TIM_ICPolarity_Rising: IC Rising edge.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
+                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
+{
+  u16 tmpsmcr = 0;
+  u16 tmpccmr1 = 0;
+  u16 tmpccer = 0;
+    
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
+  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
+
+  /* Get the TIMx SMCR register value */
+  tmpsmcr = TIMx-&gt;SMCR;
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Get the TIMx CCER register value */
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set the encoder Mode */
+  tmpsmcr &amp;= SMCR_SMS_Mask;
+  tmpsmcr |= TIM_EncoderMode;
+
+  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
+  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_CC24S_Mask;
+  tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
+
+  /* Set the TI1 and the TI2 Polarities */
+  tmpccer &amp;= CCER_CC1P_Reset &amp; CCER_CC2P_Reset;
+  tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity &lt;&lt; 4));
+
+  /* Write to TIMx SMCR */
+  TIMx-&gt;SMCR = tmpsmcr;
+
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+
+  /* Write to TIMx CCER */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ForcedOC1Config
+* Description    : Forces the TIMx output 1 waveform to active or inactive level.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ForcedAction: specifies the forced Action to be set to
+*                    the output waveform.
+*                    This parameter can be one of the following values:
+*                       - TIM_ForcedAction_Active: Force active level on OC1REF
+*                       - TIM_ForcedAction_InActive: Force inactive level on
+*                         OC1REF.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC1M Bits */
+  tmpccmr1 &amp;= CCMR_OC13M_Mask;
+
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= TIM_ForcedAction;
+
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ForcedOC2Config
+* Description    : Forces the TIMx output 2 waveform to active or inactive level.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ForcedAction: specifies the forced Action to be set to
+*                    the output waveform.
+*                    This parameter can be one of the following values:
+*                       - TIM_ForcedAction_Active: Force active level on OC2REF
+*                       - TIM_ForcedAction_InActive: Force inactive level on
+*                         OC2REF.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC2M Bits */
+  tmpccmr1 &amp;= CCMR_OC24M_Mask;
+
+  /* Configure The Forced output Mode */
+  tmpccmr1 |= (u16)(TIM_ForcedAction &lt;&lt; 8);
+
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ForcedOC3Config
+* Description    : Forces the TIMx output 3 waveform to active or inactive level.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ForcedAction: specifies the forced Action to be set to
+*                    the output waveform.
+*                    This parameter can be one of the following values:
+*                       - TIM_ForcedAction_Active: Force active level on OC3REF
+*                       - TIM_ForcedAction_InActive: Force inactive level on
+*                         OC3REF.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC1M Bits */
+  tmpccmr2 &amp;= CCMR_OC13M_Mask;
+
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= TIM_ForcedAction;
+
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ForcedOC4Config
+* Description    : Forces the TIMx output 4 waveform to active or inactive level.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ForcedAction: specifies the forced Action to be set to
+*                    the output waveform.
+*                    This parameter can be one of the following values:
+*                       - TIM_ForcedAction_Active: Force active level on OC4REF
+*                       - TIM_ForcedAction_InActive: Force inactive level on
+*                         OC4REF.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC2M Bits */
+  tmpccmr2 &amp;= CCMR_OC24M_Mask;
+
+  /* Configure The Forced output Mode */
+  tmpccmr2 |= (u16)(TIM_ForcedAction &lt;&lt; 8);
+
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ARRPreloadConfig
+* Description    : Enables or disables TIMx peripheral Preload register on ARR.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - NewState: new state of the TIMx peripheral Preload register
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the ARR Preload Bit */
+    TIMx-&gt;CR1 |= CR1_ARPE_Set;
+  }
+  else
+  {
+    /* Reset the ARR Preload Bit */
+    TIMx-&gt;CR1 &amp;= CR1_ARPE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectCOM
+* Description    : Selects the TIM peripheral Commutation event.
+* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
+*                 - NewState: new state of the Commutation event.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the COM Bit */
+    TIMx-&gt;CR2 |= CR2_CCUS_Set;
+  }
+  else
+  {
+    /* Reset the COM Bit */
+    TIMx-&gt;CR2 &amp;= CR2_CCUS_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectCCDMA
+* Description    : Selects the TIMx peripheral Capture Compare DMA source.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - NewState: new state of the Capture Compare DMA source
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the CCDS Bit */
+    TIMx-&gt;CR2 |= CR2_CCDS_Set;
+  }
+  else
+  {
+    /* Reset the CCDS Bit */
+    TIMx-&gt;CR2 &amp;= CR2_CCDS_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_CCPreloadControl
+* Description    : Sets or Resets the TIM peripheral Capture Compare Preload 
+*                  Control bit.
+* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
+*                 - NewState: new state of the Capture Compare Preload Control bit
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
+{ 
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the CCPC Bit */
+    TIMx-&gt;CR2 |= CR2_CCPC_Set;
+  }
+  else
+  {
+    /* Reset the CCPC Bit */
+    TIMx-&gt;CR2 &amp;= CR2_CCPC_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC1PreloadConfig
+* Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
+*                    register
+*                    This parameter can be one of the following values:
+*                       - TIM_OCPreload_Enable
+*                       - TIM_OCPreload_Disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC1PE Bit */
+  tmpccmr1 &amp;= CCMR_OC13PE_Reset;
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= TIM_OCPreload;
+
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC2PreloadConfig
+* Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
+*                    register
+*                    This parameter can be one of the following values:
+*                       - TIM_OCPreload_Enable
+*                       - TIM_OCPreload_Disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC2PE Bit */
+  tmpccmr1 &amp;= CCMR_OC24PE_Reset;
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr1 |= (u16)(TIM_OCPreload &lt;&lt; 8);
+
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC3PreloadConfig
+* Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
+*                    register
+*                    This parameter can be one of the following values:
+*                       - TIM_OCPreload_Enable
+*                       - TIM_OCPreload_Disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC3PE Bit */
+  tmpccmr2 &amp;= CCMR_OC13PE_Reset;
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= TIM_OCPreload;
+
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC4PreloadConfig
+* Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
+*                    register
+*                    This parameter can be one of the following values:
+*                       - TIM_OCPreload_Enable
+*                       - TIM_OCPreload_Disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
+
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC4PE Bit */
+  tmpccmr2 &amp;= CCMR_OC24PE_Reset;
+
+  /* Enable or Disable the Output Compare Preload feature */
+  tmpccmr2 |= (u16)(TIM_OCPreload &lt;&lt; 8);
+
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC1FastConfig
+* Description    : Configures the TIMx Output Compare 1 Fast feature.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCFast_Enable: TIM output compare fast enable
+*                       - TIM_OCFast_Disable: TIM output compare fast disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC1FE Bit */
+  tmpccmr1 &amp;= CCMR_OC13FE_Reset;
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= TIM_OCFast;
+
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC2FastConfig
+* Description    : Configures the TIMx Output Compare 2 Fast feature.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCFast_Enable: TIM output compare fast enable
+*                       - TIM_OCFast_Disable: TIM output compare fast disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR1 register value */
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC2FE Bit */
+  tmpccmr1 &amp;= CCMR_OC24FE_Reset;
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr1 |= (u16)(TIM_OCFast &lt;&lt; 8);
+
+  /* Write to TIMx CCMR1 */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC3FastConfig
+* Description    : Configures the TIMx Output Compare 3 Fast feature.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCFast_Enable: TIM output compare fast enable
+*                       - TIM_OCFast_Disable: TIM output compare fast disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC3FE Bit */
+  tmpccmr2 &amp;= CCMR_OC13FE_Reset;
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= TIM_OCFast;
+
+  /* Write to TIMx CCMR2 */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC4FastConfig
+* Description    : Configures the TIMx Output Compare 4 Fast feature.
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCFast_Enable: TIM output compare fast enable
+*                       - TIM_OCFast_Disable: TIM output compare fast disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
+
+  /* Get the TIMx CCMR2 register value */
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC4FE Bit */
+  tmpccmr2 &amp;= CCMR_OC24FE_Reset;
+
+  /* Enable or Disable the Output Compare Fast Bit */
+  tmpccmr2 |= (u16)(TIM_OCFast &lt;&lt; 8);
+
+  /* Write to TIMx CCMR2 */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ClearOC1Ref
+* Description    : Clears or safeguards the OCREF1 signal on an external event
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCClear_Enable: TIM Output clear enable
+*                       - TIM_OCClear_Disable: TIM Output clear disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC1CE Bit */
+  tmpccmr1 &amp;= CCMR_OC13CE_Reset;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= TIM_OCClear;
+
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ClearOC2Ref
+* Description    : Clears or safeguards the OCREF2 signal on an external event
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCClear_Enable: TIM Output clear enable
+*                       - TIM_OCClear_Disable: TIM Output clear disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
+{
+  u16 tmpccmr1 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+
+  /* Reset the OC2CE Bit */
+  tmpccmr1 &amp;= CCMR_OC24CE_Reset;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr1 |= (u16)(TIM_OCClear &lt;&lt; 8);
+
+  /* Write to TIMx CCMR1 register */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ClearOC3Ref
+* Description    : Clears or safeguards the OCREF3 signal on an external event
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCClear_Enable: TIM Output clear enable
+*                       - TIM_OCClear_Disable: TIM Output clear disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC3CE Bit */
+  tmpccmr2 &amp;= CCMR_OC13CE_Reset;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= TIM_OCClear;
+
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ClearOC4Ref
+* Description    : Clears or safeguards the OCREF4 signal on an external event
+* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
+*                    This parameter can be one of the following values:
+*                       - TIM_OCClear_Enable: TIM Output clear enable
+*                       - TIM_OCClear_Disable: TIM Output clear disable
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
+{
+  u16 tmpccmr2 = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
+
+  tmpccmr2 = TIMx-&gt;CCMR2;
+
+  /* Reset the OC4CE Bit */
+  tmpccmr2 &amp;= CCMR_OC24CE_Reset;
+
+  /* Enable or Disable the Output Compare Clear Bit */
+  tmpccmr2 |= (u16)(TIM_OCClear &lt;&lt; 8);
+
+  /* Write to TIMx CCMR2 register */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC1PolarityConfig
+* Description    : Configures the TIMx channel 1 polarity.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPolarity: specifies the OC1 Polarity
+*                    This parmeter can be one of the following values:
+*                       - TIM_OCPolarity_High: Output Compare active high
+*                       - TIM_OCPolarity_Low: Output Compare active low
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
+{
+  u16 tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set or Reset the CC1P Bit */
+  tmpccer &amp;= CCER_CC1P_Reset;
+  tmpccer |= TIM_OCPolarity;
+
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC1NPolarityConfig
+* Description    : Configures the TIMx Channel 1N polarity.
+* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
+*                  - TIM_OCNPolarity: specifies the OC1N Polarity
+*                    This parmeter can be one of the following values:
+*                       - TIM_OCNPolarity_High: Output Compare active high
+*                       - TIM_OCNPolarity_Low: Output Compare active low
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
+{
+  u16 tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+   
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set or Reset the CC1NP Bit */
+  tmpccer &amp;= CCER_CC1NP_Reset;
+  tmpccer |= TIM_OCNPolarity;
+
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC2PolarityConfig
+* Description    : Configures the TIMx channel 2 polarity.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPolarity: specifies the OC2 Polarity
+*                    This parmeter can be one of the following values:
+*                       - TIM_OCPolarity_High: Output Compare active high
+*                       - TIM_OCPolarity_Low: Output Compare active low
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
+{
+  u16 tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set or Reset the CC2P Bit */
+  tmpccer &amp;= CCER_CC2P_Reset;
+  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 4);
+
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC2NPolarityConfig
+* Description    : Configures the TIMx Channel 2N polarity.
+* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
+*                  - TIM_OCNPolarity: specifies the OC2N Polarity
+*                    This parmeter can be one of the following values:
+*                       - TIM_OCNPolarity_High: Output Compare active high
+*                       - TIM_OCNPolarity_Low: Output Compare active low
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
+{
+  u16 tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+  
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set or Reset the CC2NP Bit */
+  tmpccer &amp;= CCER_CC2NP_Reset;
+  tmpccer |= (u16)(TIM_OCNPolarity &lt;&lt; 4);
+
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC3PolarityConfig
+* Description    : Configures the TIMx channel 3 polarity.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPolarity: specifies the OC3 Polarity
+*                    This parmeter can be one of the following values:
+*                       - TIM_OCPolarity_High: Output Compare active high
+*                       - TIM_OCPolarity_Low: Output Compare active low
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
+{
+  u16 tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set or Reset the CC3P Bit */
+  tmpccer &amp;= CCER_CC3P_Reset;
+  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 8);
+
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC3NPolarityConfig
+* Description    : Configures the TIMx Channel 3N polarity.
+* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
+*                  - TIM_OCNPolarity: specifies the OC3N Polarity
+*                    This parmeter can be one of the following values:
+*                       - TIM_OCNPolarity_High: Output Compare active high
+*                       - TIM_OCNPolarity_Low: Output Compare active low
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
+{
+  u16 tmpccer = 0;
+ 
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
+    
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set or Reset the CC3NP Bit */
+  tmpccer &amp;= CCER_CC3NP_Reset;
+  tmpccer |= (u16)(TIM_OCNPolarity &lt;&lt; 8);
+
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_OC4PolarityConfig
+* Description    : Configures the TIMx channel 4 polarity.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_OCPolarity: specifies the OC4 Polarity
+*                    This parmeter can be one of the following values:
+*                       - TIM_OCPolarity_High: Output Compare active high
+*                       - TIM_OCPolarity_Low: Output Compare active low
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
+{
+  u16 tmpccer = 0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
+
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Set or Reset the CC4P Bit */
+  tmpccer &amp;= CCER_CC4P_Reset;
+  tmpccer |= (u16)(TIM_OCPolarity &lt;&lt; 12);
+
+  /* Write to TIMx CCER register */
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_CCxCmd
+* Description    : Enables or disables the TIM Capture Compare Channel x.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
+*                    peripheral.
+*                  - TIM_Channel: specifies the TIM Channel
+*                    This parmeter can be one of the following values:
+*                       - TIM_Channel_1: TIM Channel 1
+*                       - TIM_Channel_2: TIM Channel 2
+*                       - TIM_Channel_3: TIM Channel 3
+*                       - TIM_Channel_4: TIM Channel 4
+*                 - TIM_CCx: specifies the TIM Channel CCxE bit new state.
+*                   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCX(TIM_CCx));
+
+  /* Reset the CCxE Bit */
+  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCE_Set &lt;&lt; TIM_Channel)));
+
+  /* Set or reset the CCxE Bit */ 
+  TIMx-&gt;CCER |=  (u16)(TIM_CCx &lt;&lt; TIM_Channel);
+}
+
+/*******************************************************************************
+* Function Name  : TIM_CCxNCmd
+* Description    : Enables or disables the TIM Capture Compare Channel xN.
+* Input          :- TIMx: where x can be 1 or 8 to select the TIM peripheral.
+*                 - TIM_Channel: specifies the TIM Channel
+*                    This parmeter can be one of the following values:
+*                       - TIM_Channel_1: TIM Channel 1
+*                       - TIM_Channel_2: TIM Channel 2
+*                       - TIM_Channel_3: TIM Channel 3
+*                 - TIM_CCx: specifies the TIM Channel CCxNE bit new state.
+*                   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_18_PERIPH(TIMx));
+  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_CCXN(TIM_CCxN));
+
+  /* Reset the CCxNE Bit */
+  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCNE_Set &lt;&lt; TIM_Channel)));
+
+  /* Set or reset the CCxNE Bit */ 
+  TIMx-&gt;CCER |=  (u16)(TIM_CCxN &lt;&lt; TIM_Channel);
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectOCxM
+* Description    : Selects the TIM Ouput Compare Mode.
+*                  This function disables the selected channel before changing 
+*                  the Ouput Compare Mode. User has to enable this channel using
+*                  TIM_CCxCmd and TIM_CCxNCmd functions.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
+*                    peripheral.
+*                  - TIM_Channel: specifies the TIM Channel
+*                    This parmeter can be one of the following values:
+*                       - TIM_Channel_1: TIM Channel 1
+*                       - TIM_Channel_2: TIM Channel 2
+*                       - TIM_Channel_3: TIM Channel 3
+*                       - TIM_Channel_4: TIM Channel 4
+*                  - TIM_OCMode: specifies the TIM Output Compare Mode.
+*                    This paramter can be one of the following values:
+*                       - TIM_OCMode_Timing
+*                       - TIM_OCMode_Active
+*                       - TIM_OCMode_Toggle
+*                       - TIM_OCMode_PWM1
+*                       - TIM_OCMode_PWM2
+*                       - TIM_ForcedAction_Active
+*                       - TIM_ForcedAction_InActive
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CHANNEL(TIM_Channel));
+  assert_param(IS_TIM_OCM(TIM_OCMode));
+  
+  /* Disable the Channel: Reset the CCxE Bit */
+  TIMx-&gt;CCER &amp;= (u16)(~((u16)(CCER_CCE_Set &lt;&lt; TIM_Channel)));
+
+  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
+  {
+    /* Reset the OCxM bits in the CCMRx register */
+    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + (TIM_Channel&gt;&gt;1))) &amp;= CCMR_OC13M_Mask;
+   
+    /* Configure the OCxM bits in the CCMRx register */
+    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + (TIM_Channel&gt;&gt;1))) |= TIM_OCMode;
+
+  }
+  else
+  {
+    /* Reset the OCxM bits in the CCMRx register */
+    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)&gt;&gt; 1))) &amp;= CCMR_OC24M_Mask;
+    
+    /* Configure the OCxM bits in the CCMRx register */
+    *((vu32 *)((*(u32*)&amp;TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)&gt;&gt; 1))) |= (u16)(TIM_OCMode &lt;&lt; 8);
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_UpdateDisableConfig
+* Description    : Enables or Disables the TIMx Update event.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - NewState: new state of the TIMx UDIS bit
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the Update Disable Bit */
+    TIMx-&gt;CR1 |= CR1_UDIS_Set;
+  }
+  else
+  {
+    /* Reset the Update Disable Bit */
+    TIMx-&gt;CR1 &amp;= CR1_UDIS_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_UpdateRequestConfig
+* Description    : Configures the TIMx Update Request Interrupt source.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_UpdateSource: specifies the Update source.
+*                    This parameter can be one of the following values:
+*                       - TIM_UpdateSource_Regular
+*                       - TIM_UpdateSource_Global
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
+
+  if (TIM_UpdateSource != TIM_UpdateSource_Global)
+  {
+    /* Set the URS Bit */
+    TIMx-&gt;CR1 |= CR1_URS_Set;
+  }
+  else
+  {
+    /* Reset the URS Bit */
+    TIMx-&gt;CR1 &amp;= CR1_URS_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectHallSensor
+* Description    : Enables or disables the TIMx's Hall sensor interface.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
+*                  - NewState: new state of the TIMx Hall sensor interface.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Set the TI1S Bit */
+    TIMx-&gt;CR2 |= CR2_TI1S_Set;
+  }
+  else
+  {
+    /* Reset the TI1S Bit */
+    TIMx-&gt;CR2 &amp;= CR2_TI1S_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectOnePulseMode
+* Description    : Selects the TIMx's One Pulse Mode.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_OPMode: specifies the OPM Mode to be used.
+*                    This parameter can be one of the following values:
+*                       - TIM_OPMode_Single
+*                       - TIM_OPMode_Repetitive
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
+
+  /* Reset the OPM Bit */
+  TIMx-&gt;CR1 &amp;= CR1_OPM_Reset;
+
+  /* Configure the OPM Mode */
+  TIMx-&gt;CR1 |= TIM_OPMode;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectOutputTrigger
+* Description    : Selects the TIMx Trigger Output Mode.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_TRGOSource: specifies the Trigger Output source.
+*                    This paramter can be as follow:
+*                      1/ For TIM1 to TIM8:
+*                       - TIM_TRGOSource_Reset 
+*                       - TIM_TRGOSource_Enable
+*                       - TIM_TRGOSource_Update
+*                      2/ These parameters are available for all TIMx except 
+*                         TIM6 and TIM7:
+*                       - TIM_TRGOSource_OC1
+*                       - TIM_TRGOSource_OC1Ref
+*                       - TIM_TRGOSource_OC2Ref
+*                       - TIM_TRGOSource_OC3Ref
+*                       - TIM_TRGOSource_OC4Ref
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
+  assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
+
+  /* Reset the MMS Bits */
+  TIMx-&gt;CR2 &amp;= CR2_MMS_Mask;
+
+  /* Select the TRGO source */
+  TIMx-&gt;CR2 |=  TIM_TRGOSource;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectSlaveMode
+* Description    : Selects the TIMx Slave Mode.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_SlaveMode: specifies the Timer Slave Mode.
+*                    This paramter can be one of the following values:
+*                       - TIM_SlaveMode_Reset
+*                       - TIM_SlaveMode_Gated
+*                       - TIM_SlaveMode_Trigger
+*                       - TIM_SlaveMode_External1
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
+
+  /* Reset the SMS Bits */
+  TIMx-&gt;SMCR &amp;= SMCR_SMS_Mask;
+
+  /* Select the Slave Mode */
+  TIMx-&gt;SMCR |= TIM_SlaveMode;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SelectMasterSlaveMode
+* Description    : Sets or Resets the TIMx Master/Slave Mode.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
+*                    This paramter can be one of the following values:
+*                       - TIM_MasterSlaveMode_Enable: synchronization between the
+*                         current timer and its slaves (through TRGO).
+*                       - TIM_MasterSlaveMode_Disable: No action
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
+
+  /* Reset the MSM Bit */
+  TIMx-&gt;SMCR &amp;= SMCR_MSM_Reset;
+  
+  /* Set or Reset the MSM Bit */
+  TIMx-&gt;SMCR |= TIM_MasterSlaveMode;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetCounter
+* Description    : Sets the TIMx Counter Register value
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - Counter: specifies the Counter register new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Set the Counter Register value */
+  TIMx-&gt;CNT = Counter;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetAutoreload
+* Description    : Sets the TIMx Autoreload Register value
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - Autoreload: specifies the Autoreload register new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Set the Autoreload Register value */
+  TIMx-&gt;ARR = Autoreload;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetCompare1
+* Description    : Sets the TIMx Capture Compare1 Register value
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - Compare1: specifies the Capture Compare1 register new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Set the Capture Compare1 Register value */
+  TIMx-&gt;CCR1 = Compare1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetCompare2
+* Description    : Sets the TIMx Capture Compare2 Register value
+* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                   peripheral.
+*                  - Compare2: specifies the Capture Compare2 register new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Set the Capture Compare2 Register value */
+  TIMx-&gt;CCR2 = Compare2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetCompare3
+* Description    : Sets the TIMx Capture Compare3 Register value
+* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                   peripheral.
+*                  - Compare3: specifies the Capture Compare3 register new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Set the Capture Compare3 Register value */
+  TIMx-&gt;CCR3 = Compare3;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetCompare4
+* Description    : Sets the TIMx Capture Compare4 Register value
+* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                   peripheral.
+*                  - Compare4: specifies the Capture Compare4 register new value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Set the Capture Compare4 Register value */
+  TIMx-&gt;CCR4 = Compare4;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetIC1Prescaler
+* Description    : Sets the TIMx Input Capture 1 prescaler.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPSC: specifies the Input Capture1 prescaler
+*                    new value.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICPSC_DIV1: no prescaler
+*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
+*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
+*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC1PSC Bits */
+  TIMx-&gt;CCMR1 &amp;= CCMR_IC13PSC_Mask;
+
+  /* Set the IC1PSC value */
+  TIMx-&gt;CCMR1 |= TIM_ICPSC;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetIC2Prescaler
+* Description    : Sets the TIMx Input Capture 2 prescaler.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPSC: specifies the Input Capture2 prescaler
+*                    new value.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICPSC_DIV1: no prescaler
+*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
+*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
+*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC2PSC Bits */
+  TIMx-&gt;CCMR1 &amp;= CCMR_IC24PSC_Mask;
+
+  /* Set the IC2PSC value */
+  TIMx-&gt;CCMR1 |= (u16)(TIM_ICPSC &lt;&lt; 8);
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetIC3Prescaler
+* Description    : Sets the TIMx Input Capture 3 prescaler.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPSC: specifies the Input Capture3 prescaler
+*                    new value.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICPSC_DIV1: no prescaler
+*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
+*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
+*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC3PSC Bits */
+  TIMx-&gt;CCMR2 &amp;= CCMR_IC13PSC_Mask;
+
+  /* Set the IC3PSC value */
+  TIMx-&gt;CCMR2 |= TIM_ICPSC;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetIC4Prescaler
+* Description    : Sets the TIMx Input Capture 4 prescaler.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPSC: specifies the Input Capture4 prescaler
+*                    new value.
+*                    This parameter can be one of the following values:
+*                      - TIM_ICPSC_DIV1: no prescaler
+*                      - TIM_ICPSC_DIV2: capture is done once every 2 events
+*                      - TIM_ICPSC_DIV4: capture is done once every 4 events
+*                      - TIM_ICPSC_DIV8: capture is done once every 8 events
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
+
+  /* Reset the IC4PSC Bits */
+  TIMx-&gt;CCMR2 &amp;= CCMR_IC24PSC_Mask;
+
+  /* Set the IC4PSC value */
+  TIMx-&gt;CCMR2 |= (u16)(TIM_ICPSC &lt;&lt; 8);
+}
+
+/*******************************************************************************
+* Function Name  : TIM_SetClockDivision
+* Description    : Sets the TIMx Clock Division value.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_CKD: specifies the clock division value.
+*                    This parameter can be one of the following value:
+*                       - TIM_CKD_DIV1: TDTS = Tck_tim
+*                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
+*                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
+
+  /* Reset the CKD Bits */
+  TIMx-&gt;CR1 &amp;= CR1_CKD_Mask;
+
+  /* Set the CKD value */
+  TIMx-&gt;CR1 |= TIM_CKD;
+}
+/*******************************************************************************
+* Function Name  : TIM_GetCapture1
+* Description    : Gets the TIMx Input Capture 1 value.
+* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                   peripheral.
+* Output         : None
+* Return         : Capture Compare 1 Register value.
+*******************************************************************************/
+u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Get the Capture 1 Register value */
+  return TIMx-&gt;CCR1;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GetCapture2
+* Description    : Gets the TIMx Input Capture 2 value.
+* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                   peripheral.
+* Output         : None
+* Return         : Capture Compare 2 Register value.
+*******************************************************************************/
+u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Get the Capture 2 Register value */
+  return TIMx-&gt;CCR2;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GetCapture3
+* Description    : Gets the TIMx Input Capture 3 value.
+* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                   peripheral.
+* Output         : None
+* Return         : Capture Compare 3 Register value.
+*******************************************************************************/
+u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
+
+  /* Get the Capture 3 Register value */
+  return TIMx-&gt;CCR3;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GetCapture4
+* Description    : Gets the TIMx Input Capture 4 value.
+* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                   peripheral.
+* Output         : None
+* Return         : Capture Compare 4 Register value.
+*******************************************************************************/
+u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_123458_PERIPH(TIMx));
+
+  /* Get the Capture 4 Register value */
+  return TIMx-&gt;CCR4;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GetCounter
+* Description    : Gets the TIMx Counter value.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+* Output         : None
+* Return         : Counter Register value.
+*******************************************************************************/
+u16 TIM_GetCounter(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Get the Counter Register value */
+  return TIMx-&gt;CNT;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GetPrescaler
+* Description    : Gets the TIMx Prescaler value.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+* Output         : None
+* Return         : Prescaler Register value.
+*******************************************************************************/
+u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+
+  /* Get the Prescaler Register value */
+  return TIMx-&gt;PSC;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GetFlagStatus
+* Description    : Checks whether the specified TIM flag is set or not.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - TIM_FLAG_Update: TIM update Flag
+*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+*                       - TIM_FLAG_COM: TIM Commutation Flag
+*                       - TIM_FLAG_Trigger: TIM Trigger Flag
+*                       - TIM_FLAG_Break: TIM Break Flag
+*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
+*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
+*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
+*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
+* Output         : None
+* Return         : The new state of TIM_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
+{ 
+  ITStatus bitstatus = RESET;  
+
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
+  assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
+  
+  if ((TIMx-&gt;SR &amp; TIM_FLAG) != (u16)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ClearFlag
+* Description    : Clears the TIMx's pending flags.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_FLAG: specifies the flag bit to clear.
+*                    This parameter can be any combination of the following values:
+*                       - TIM_FLAG_Update: TIM update Flag
+*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
+*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
+*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
+*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
+*                       - TIM_FLAG_COM: TIM Commutation Flag
+*                       - TIM_FLAG_Trigger: TIM Trigger Flag
+*                       - TIM_FLAG_Break: TIM Break Flag
+*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
+*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
+*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
+*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
+{  
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
+   
+  /* Clear the flags */
+  TIMx-&gt;SR = (u16)~TIM_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_GetITStatus
+* Description    : Checks whether the TIM interrupt has occurred or not.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_IT: specifies the TIM interrupt source to check.
+*                    This parameter can be one of the following values:
+*                       - TIM_IT_Update: TIM update Interrupt source
+*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+*                       - TIM_IT_COM: TIM Commutation Interrupt
+*                         source
+*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
+*                       - TIM_IT_Break: TIM Break Interrupt source
+* Output         : None
+* Return         : The new state of the TIM_IT(SET or RESET).
+*******************************************************************************/
+ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
+{
+  ITStatus bitstatus = RESET;  
+  u16 itstatus = 0x0, itenable = 0x0;
+
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_GET_IT(TIM_IT));
+  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
+   
+  itstatus = TIMx-&gt;SR &amp; TIM_IT;
+  
+  itenable = TIMx-&gt;DIER &amp; TIM_IT;
+
+  if ((itstatus != (u16)RESET) &amp;&amp; (itenable != (u16)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : TIM_ClearITPendingBit
+* Description    : Clears the TIMx's interrupt pending bits.
+* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
+*                  - TIM_IT: specifies the pending bit to clear.
+*                    This parameter can be any combination of the following values:
+*                       - TIM_IT_Update: TIM1 update Interrupt source
+*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
+*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
+*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
+*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
+*                       - TIM_IT_COM: TIM Commutation Interrupt
+*                         source
+*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
+*                       - TIM_IT_Break: TIM Break Interrupt source
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
+{
+  /* Check the parameters */
+  assert_param(IS_TIM_ALL_PERIPH(TIMx));
+  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
+
+  /* Clear the IT pending Bit */
+  TIMx-&gt;SR = (u16)~TIM_IT;
+}
+
+/*******************************************************************************
+* Function Name  : TI1_Config
+* Description    : Configure the TI1 as Input.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPolarity : The Input Polarity.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICPolarity_Rising
+*                       - TIM_ICPolarity_Falling
+*                  - TIM_ICSelection: specifies the input to be used.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
+*                         be connected to IC1.
+*                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
+*                         be connected to IC2.
+*                       - TIM_ICSelection_TRC: TIM Input 1 is selected to be
+*                         connected to TRC.
+*                  - TIM_ICFilter: Specifies the Input Capture Filter.
+*                    This parameter must be a value between 0x00 and 0x0F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter)
+{
+  u16 tmpccmr1 = 0, tmpccer = 0;
+
+  /* Disable the Channel 1: Reset the CC1E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC1E_Reset;
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  tmpccer = TIMx-&gt;CCER;
+
+  /* Select the Input and set the filter */
+  tmpccmr1 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
+  tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter &lt;&lt; 4);
+
+  /* Select the Polarity and set the CC1E Bit */
+  tmpccer &amp;= CCER_CC1P_Reset;
+  tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
+
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx-&gt;CCMR1 = tmpccmr1;
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TI2_Config
+* Description    : Configure the TI2 as Input.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPolarity : The Input Polarity.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICPolarity_Rising
+*                       - TIM_ICPolarity_Falling
+*                  - TIM_ICSelection: specifies the input to be used.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
+*                         be connected to IC2.
+*                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
+*                         be connected to IC1.
+*                       - TIM_ICSelection_TRC: TIM Input 2 is selected to be
+*                         connected to TRC.
+*                  - TIM_ICFilter: Specifies the Input Capture Filter.
+*                    This parameter must be a value between 0x00 and 0x0F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter)
+{
+  u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
+
+  /* Disable the Channel 2: Reset the CC2E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC2E_Reset;
+
+  tmpccmr1 = TIMx-&gt;CCMR1;
+  tmpccer = TIMx-&gt;CCER;
+  tmp = (u16)(TIM_ICPolarity &lt;&lt; 4);
+
+  /* Select the Input and set the filter */
+  tmpccmr1 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
+  tmpccmr1 |= (u16)(TIM_ICFilter &lt;&lt; 12);
+  tmpccmr1 |= (u16)(TIM_ICSelection &lt;&lt; 8);
+
+  /* Select the Polarity and set the CC2E Bit */
+  tmpccer &amp;= CCER_CC2P_Reset;
+  tmpccer |=  tmp | CCER_CC2E_Set;
+
+  /* Write to TIMx CCMR1 and CCER registers */
+  TIMx-&gt;CCMR1 = tmpccmr1 ;
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TI3_Config
+* Description    : Configure the TI3 as Input.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPolarity : The Input Polarity.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICPolarity_Rising
+*                       - TIM_ICPolarity_Falling
+*                  - TIM_ICSelection: specifies the input to be used.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
+*                         be connected to IC3.
+*                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
+*                         be connected to IC4.
+*                       - TIM_ICSelection_TRC: TIM Input 3 is selected to be
+*                         connected to TRC.
+*                  - TIM_ICFilter: Specifies the Input Capture Filter.
+*                    This parameter must be a value between 0x00 and 0x0F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter)
+{
+  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+
+  /* Disable the Channel 3: Reset the CC3E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC3E_Reset;
+
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  tmpccer = TIMx-&gt;CCER;
+  tmp = (u16)(TIM_ICPolarity &lt;&lt; 8);
+
+  /* Select the Input and set the filter */
+  tmpccmr2 &amp;= CCMR_CC13S_Mask &amp; CCMR_IC13F_Mask;
+  tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter &lt;&lt; 4);
+
+  /* Select the Polarity and set the CC3E Bit */
+  tmpccer &amp;= CCER_CC3P_Reset;
+  tmpccer |= tmp | CCER_CC3E_Set;
+
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+  TIMx-&gt;CCER = tmpccer;
+}
+
+/*******************************************************************************
+* Function Name  : TI4_Config
+* Description    : Configure the TI1 as Input.
+* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
+*                    peripheral.
+*                  - TIM_ICPolarity : The Input Polarity.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICPolarity_Rising
+*                       - TIM_ICPolarity_Falling
+*                  - TIM_ICSelection: specifies the input to be used.
+*                    This parameter can be one of the following values:
+*                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
+*                         be connected to IC4.
+*                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
+*                         be connected to IC3.
+*                       - TIM_ICSelection_TRC: TIM Input 4 is selected to be
+*                         connected to TRC.
+*                  - TIM_ICFilter: Specifies the Input Capture Filter.
+*                    This parameter must be a value between 0x00 and 0x0F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
+                       u16 TIM_ICFilter)
+{
+  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
+
+  /* Disable the Channel 4: Reset the CC4E Bit */
+  TIMx-&gt;CCER &amp;= CCER_CC4E_Reset;
+
+  tmpccmr2 = TIMx-&gt;CCMR2;
+  tmpccer = TIMx-&gt;CCER;
+  tmp = (u16)(TIM_ICPolarity &lt;&lt; 12);
+
+  /* Select the Input and set the filter */
+  tmpccmr2 &amp;= CCMR_CC24S_Mask &amp; CCMR_IC24F_Mask;
+  tmpccmr2 |= (u16)(TIM_ICSelection &lt;&lt; 8) | (u16)(TIM_ICFilter &lt;&lt; 12);
+
+  /* Select the Polarity and set the CC4E Bit */
+  tmpccer &amp;= CCER_CC4P_Reset;
+  tmpccer |= tmp | CCER_CC4E_Set;
+
+  /* Write to TIMx CCMR2 and CCER registers */
+  TIMx-&gt;CCMR2 = tmpccmr2;
+  TIMx-&gt;CCER = tmpccer ;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_usart.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,1001 +1,1001 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_usart.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the USART firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_usart.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* USART UE Mask */
-#define CR1_UE_Set                ((u16)0x2000)  /* USART Enable Mask */
-#define CR1_UE_Reset              ((u16)0xDFFF)  /* USART Disable Mask */
-
-/* USART WakeUp Method  */
-#define CR1_WAKE_Mask             ((u16)0xF7FF)  /* USART WakeUp Method Mask */
-
-/* USART RWU Mask */
-#define CR1_RWU_Set               ((u16)0x0002)  /* USART mute mode Enable Mask */
-#define CR1_RWU_Reset             ((u16)0xFFFD)  /* USART mute mode Enable Mask */
-
-#define CR1_SBK_Set               ((u16)0x0001)  /* USART Break Character send Mask */
-
-#define CR1_CLEAR_Mask            ((u16)0xE9F3)  /* USART CR1 Mask */
-
-#define CR2_Address_Mask          ((u16)0xFFF0)  /* USART address Mask */
-
-/* USART LIN Mask */
-#define CR2_LINEN_Set              ((u16)0x4000)  /* USART LIN Enable Mask */
-#define CR2_LINEN_Reset            ((u16)0xBFFF)  /* USART LIN Disable Mask */
-
-/* USART LIN Break detection */
-#define CR2_LBDL_Mask             ((u16)0xFFDF)  /* USART LIN Break detection Mask */
-
-#define CR2_STOP_CLEAR_Mask       ((u16)0xCFFF)  /* USART CR2 STOP Bits Mask */
-#define CR2_CLOCK_CLEAR_Mask      ((u16)0xF0FF)  /* USART CR2 Clock Mask */
-
-/* USART SC Mask */
-#define CR3_SCEN_Set              ((u16)0x0020)  /* USART SC Enable Mask */
-#define CR3_SCEN_Reset            ((u16)0xFFDF)  /* USART SC Disable Mask */
-
-/* USART SC NACK Mask */
-#define CR3_NACK_Set              ((u16)0x0010)  /* USART SC NACK Enable Mask */
-#define CR3_NACK_Reset            ((u16)0xFFEF)  /* USART SC NACK Disable Mask */
-
-/* USART Half-Duplex Mask */
-#define CR3_HDSEL_Set             ((u16)0x0008)  /* USART Half-Duplex Enable Mask */
-#define CR3_HDSEL_Reset           ((u16)0xFFF7)  /* USART Half-Duplex Disable Mask */
-
-/* USART IrDA Mask */
-#define CR3_IRLP_Mask             ((u16)0xFFFB)  /* USART IrDA LowPower mode Mask */
-
-#define CR3_CLEAR_Mask            ((u16)0xFCFF)  /* USART CR3 Mask */
-
-/* USART IrDA Mask */
-#define CR3_IREN_Set              ((u16)0x0002)  /* USART IrDA Enable Mask */
-#define CR3_IREN_Reset            ((u16)0xFFFD)  /* USART IrDA Disable Mask */
-
-#define GTPR_LSB_Mask             ((u16)0x00FF)  /* Guard Time Register LSB Mask */
-#define GTPR_MSB_Mask             ((u16)0xFF00)  /* Guard Time Register MSB Mask */
-
-#define IT_Mask                   ((u16)0x001F)  /* USART Interrupt Mask */
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : USART_DeInit
-* Description    : Deinitializes the USARTx peripheral registers to their
-*                  default reset values.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_DeInit(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-
-  switch (*(u32*)&amp;USARTx)
-  {
-    case USART1_BASE:
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
-      break;
-
-    case USART2_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
-      break;
-
-    case USART3_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
-      break;
-    
-    case UART4_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
-      break;
-    
-    case UART5_BASE:
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
-      break;            
-
-    default:
-      break;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_Init
-* Description    : Initializes the USARTx peripheral according to the specified
-*                  parameters in the USART_InitStruct .
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_InitStruct: pointer to a USART_InitTypeDef structure
-*                    that contains the configuration information for the
-*                    specified USART peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
-{
-  u32 tmpreg = 0x00, apbclock = 0x00;
-  u32 integerdivider = 0x00;
-  u32 fractionaldivider = 0x00;
-  u32 usartxbase = 0;
-  RCC_ClocksTypeDef RCC_ClocksStatus;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_BAUDRATE(USART_InitStruct-&gt;USART_BaudRate));  
-  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct-&gt;USART_WordLength));
-  assert_param(IS_USART_STOPBITS(USART_InitStruct-&gt;USART_StopBits));
-  assert_param(IS_USART_PARITY(USART_InitStruct-&gt;USART_Parity));
-  assert_param(IS_USART_MODE(USART_InitStruct-&gt;USART_Mode));
-  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct-&gt;USART_HardwareFlowControl));
-  /* The hardware flow control is available only for USART1, USART2 and USART3 */          
-  assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct-&gt;USART_HardwareFlowControl));
-  
-  usartxbase = (*(u32*)&amp;USARTx);
-
-/*---------------------------- USART CR2 Configuration -----------------------*/
-  tmpreg = USARTx-&gt;CR2;
-  /* Clear STOP[13:12] bits */
-  tmpreg &amp;= CR2_STOP_CLEAR_Mask;
-
-  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
-  /* Set STOP[13:12] bits according to USART_StopBits value */
-  tmpreg |= (u32)USART_InitStruct-&gt;USART_StopBits;
-  
-  /* Write to USART CR2 */
-  USARTx-&gt;CR2 = (u16)tmpreg;
-
-/*---------------------------- USART CR1 Configuration -----------------------*/
-  tmpreg = USARTx-&gt;CR1;
-  /* Clear M, PCE, PS, TE and RE bits */
-  tmpreg &amp;= CR1_CLEAR_Mask;
-
-  /* Configure the USART Word Length, Parity and mode ----------------------- */
-  /* Set the M bits according to USART_WordLength value */
-  /* Set PCE and PS bits according to USART_Parity value */
-  /* Set TE and RE bits according to USART_Mode value */
-  tmpreg |= (u32)USART_InitStruct-&gt;USART_WordLength | USART_InitStruct-&gt;USART_Parity |
-            USART_InitStruct-&gt;USART_Mode;
-
-  /* Write to USART CR1 */
-  USARTx-&gt;CR1 = (u16)tmpreg;
-
-/*---------------------------- USART CR3 Configuration -----------------------*/  
-  tmpreg = USARTx-&gt;CR3;
-  /* Clear CTSE and RTSE bits */
-  tmpreg &amp;= CR3_CLEAR_Mask;
-
-  /* Configure the USART HFC -------------------------------------------------*/
-  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
-  tmpreg |= USART_InitStruct-&gt;USART_HardwareFlowControl;
-
-  /* Write to USART CR3 */
-  USARTx-&gt;CR3 = (u16)tmpreg;
-
-/*---------------------------- USART BRR Configuration -----------------------*/
-  /* Configure the USART Baud Rate -------------------------------------------*/
-  RCC_GetClocksFreq(&amp;RCC_ClocksStatus);
-  if (usartxbase == USART1_BASE)
-  {
-    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
-  }
-  else
-  {
-    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
-  }
-
-  /* Determine the integer part */
-  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct-&gt;USART_BaudRate)));
-  tmpreg = (integerdivider / 0x64) &lt;&lt; 0x04;
-
-  /* Determine the fractional part */
-  fractionaldivider = integerdivider - (0x64 * (tmpreg &gt;&gt; 0x04));
-  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) &amp; ((u8)0x0F);
-
-  /* Write to USART BRR */
-  USARTx-&gt;BRR = (u16)tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : USART_StructInit
-* Description    : Fills each USART_InitStruct member with its default value.
-* Input          : - USART_InitStruct: pointer to a USART_InitTypeDef structure
-*                    which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
-{
-  /* USART_InitStruct members default value */
-  USART_InitStruct-&gt;USART_BaudRate = 9600;
-  USART_InitStruct-&gt;USART_WordLength = USART_WordLength_8b;
-  USART_InitStruct-&gt;USART_StopBits = USART_StopBits_1;
-  USART_InitStruct-&gt;USART_Parity = USART_Parity_No ;
-  USART_InitStruct-&gt;USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
-  USART_InitStruct-&gt;USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClockInit
-* Description    : Initializes the USARTx peripheral Clock according to the 
-*                  specified parameters in the USART_ClockInitStruct .
-* Input          : - USARTx: where x can be 1, 2, 3 to select the USART peripheral.
-*                    Note: The Smart Card mode is not available for UART4 and UART5.
-*                  - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
-*                    structure that contains the configuration information for 
-*                    the specified USART peripheral.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
-{
-  u32 tmpreg = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  assert_param(IS_USART_CLOCK(USART_ClockInitStruct-&gt;USART_Clock));
-  assert_param(IS_USART_CPOL(USART_ClockInitStruct-&gt;USART_CPOL));
-  assert_param(IS_USART_CPHA(USART_ClockInitStruct-&gt;USART_CPHA));
-  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct-&gt;USART_LastBit));              
-  
-/*---------------------------- USART CR2 Configuration -----------------------*/
-  tmpreg = USARTx-&gt;CR2;
-  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
-  tmpreg &amp;= CR2_CLOCK_CLEAR_Mask;
-
-  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
-  /* Set CLKEN bit according to USART_Clock value */
-  /* Set CPOL bit according to USART_CPOL value */
-  /* Set CPHA bit according to USART_CPHA value */
-  /* Set LBCL bit according to USART_LastBit value */
-  tmpreg |= (u32)USART_ClockInitStruct-&gt;USART_Clock | USART_ClockInitStruct-&gt;USART_CPOL | 
-                 USART_ClockInitStruct-&gt;USART_CPHA | USART_ClockInitStruct-&gt;USART_LastBit;
-
-  /* Write to USART CR2 */
-  USARTx-&gt;CR2 = (u16)tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClockStructInit
-* Description    : Fills each USART_ClockInitStruct member with its default value.
-* Input          : - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
-*                    structure which will be initialized.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
-{
-  /* USART_ClockInitStruct members default value */
-  USART_ClockInitStruct-&gt;USART_Clock = USART_Clock_Disable;
-  USART_ClockInitStruct-&gt;USART_CPOL = USART_CPOL_Low;
-  USART_ClockInitStruct-&gt;USART_CPHA = USART_CPHA_1Edge;
-  USART_ClockInitStruct-&gt;USART_LastBit = USART_LastBit_Disable;
-}
-
-/*******************************************************************************
-* Function Name  : USART_Cmd
-* Description    : Enables or disables the specified USART peripheral.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                : - NewState: new state of the USARTx peripheral.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected USART by setting the UE bit in the CR1 register */
-    USARTx-&gt;CR1 |= CR1_UE_Set;
-  }
-  else
-  {
-    /* Disable the selected USART by clearing the UE bit in the CR1 register */
-    USARTx-&gt;CR1 &amp;= CR1_UE_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_ITConfig
-* Description    : Enables or disables the specified USART interrupts.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IT: specifies the USART interrupt sources to be
-*                    enabled or disabled.
-*                    This parameter can be one of the following values:
-*                       - USART_IT_CTS:  CTS change interrupt (not available for
-*                                        UART4 and UART5)
-*                       - USART_IT_LBD:  LIN Break detection interrupt
-*                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
-*                       - USART_IT_TC:   Transmission complete interrupt
-*                       - USART_IT_RXNE: Receive Data register not empty 
-*                                        interrupt
-*                       - USART_IT_IDLE: Idle line detection interrupt
-*                       - USART_IT_PE:   Parity Error interrupt
-*                       - USART_IT_ERR:  Error interrupt(Frame error, noise
-*                                        error, overrun error)
-*                  - NewState: new state of the specified USARTx interrupts.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
-{
-  u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
-  u32 usartxbase = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CONFIG_IT(USART_IT));
-  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  usartxbase = (*(u32*)&amp;(USARTx));
-
-  /* Get the USART register index */
-  usartreg = (((u8)USART_IT) &gt;&gt; 0x05);
-
-  /* Get the interrupt position */
-  itpos = USART_IT &amp; IT_Mask;
-
-  itmask = (((u32)0x01) &lt;&lt; itpos);
-    
-  if (usartreg == 0x01) /* The IT is in CR1 register */
-  {
-    usartxbase += 0x0C;
-  }
-  else if (usartreg == 0x02) /* The IT is in CR2 register */
-  {
-    usartxbase += 0x10;
-  }
-  else /* The IT is in CR3 register */
-  {
-    usartxbase += 0x14; 
-  }
-  if (NewState != DISABLE)
-  {
-    *(vu32*)usartxbase  |= itmask;
-  }
-  else
-  {
-    *(vu32*)usartxbase &amp;= ~itmask;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_DMACmd
-* Description    : Enables or disables the USART&#146;s DMA interface.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3 or UART4.
-*                    Note: The DMA mode is not available for UART5.
-*                  - USART_DMAReq: specifies the DMA request.
-*                    This parameter can be any combination of the following values:
-*                       - USART_DMAReq_Tx: USART DMA transmit request
-*                       - USART_DMAReq_Rx: USART DMA receive request
-*                  - NewState: new state of the DMA Request sources.
-*                   This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_1234_PERIPH(USARTx));
-  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
-       DMAR bits in the USART CR3 register */
-    USARTx-&gt;CR3 |= USART_DMAReq;
-  }
-  else
-  {
-    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
-       DMAR bits in the USART CR3 register */
-    USARTx-&gt;CR3 &amp;= (u16)~USART_DMAReq;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_SetAddress
-* Description    : Sets the address of the USART node.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_Address: Indicates the address of the USART node.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_ADDRESS(USART_Address)); 
-    
-  /* Clear the USART address */
-  USARTx-&gt;CR2 &amp;= CR2_Address_Mask;
-  /* Set the USART address node */
-  USARTx-&gt;CR2 |= USART_Address;
-}
-
-/*******************************************************************************
-* Function Name  : USART_WakeUpConfig
-* Description    : Selects the USART WakeUp method.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_WakeUp: specifies the USART wakeup method.
-*                    This parameter can be one of the following values:
-*                        - USART_WakeUp_IdleLine: WakeUp by an idle line detection
-*                        - USART_WakeUp_AddressMark: WakeUp by an address mark
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_WAKEUP(USART_WakeUp));
-  
-  USARTx-&gt;CR1 &amp;= CR1_WAKE_Mask;
-  USARTx-&gt;CR1 |= USART_WakeUp;
-}
-
-/*******************************************************************************
-* Function Name  : USART_ReceiverWakeUpCmd
-* Description    : Determines if the USART is in mute mode or not.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the USART mute mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
-    USARTx-&gt;CR1 |= CR1_RWU_Set;
-  }
-  else
-  {
-    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
-    USARTx-&gt;CR1 &amp;= CR1_RWU_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_LINBreakDetectLengthConfig
-* Description    : Sets the USART LIN Break detection length.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_LINBreakDetectLength: specifies the LIN break
-*                    detection length.
-*                    This parameter can be one of the following values:
-*                       - USART_LINBreakDetectLength_10b: 10-bit break detection
-*                       - USART_LINBreakDetectLength_11b: 11-bit break detection
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
-  
-  USARTx-&gt;CR2 &amp;= CR2_LBDL_Mask;
-  USARTx-&gt;CR2 |= USART_LINBreakDetectLength;  
-}
-
-/*******************************************************************************
-* Function Name  : USART_LINCmd
-* Description    : Enables or disables the USART&#146;s LIN mode.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the USART LIN mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
-    USARTx-&gt;CR2 |= CR2_LINEN_Set;
-  }
-  else
-  {
-    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
-    USARTx-&gt;CR2 &amp;= CR2_LINEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_SendData
-* Description    : Transmits single data through the USARTx peripheral.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - Data: the data to transmit.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SendData(USART_TypeDef* USARTx, u16 Data)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_DATA(Data)); 
-    
-  /* Transmit Data */
-  USARTx-&gt;DR = (Data &amp; (u16)0x01FF);
-}
-
-/*******************************************************************************
-* Function Name  : USART_ReceiveData
-* Description    : Returns the most recent received data by the USARTx peripheral.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-* Output         : None
-* Return         : The received data.
-*******************************************************************************/
-u16 USART_ReceiveData(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Receive Data */
-  return (u16)(USARTx-&gt;DR &amp; (u16)0x01FF);
-}
-
-/*******************************************************************************
-* Function Name  : USART_SendBreak
-* Description    : Transmits break characters.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SendBreak(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Send break characters */
-  USARTx-&gt;CR1 |= CR1_SBK_Set;
-}
-
-/*******************************************************************************
-* Function Name  : USART_SetGuardTime
-* Description    : Sets the specified USART guard time.
-* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
-*                    peripheral.
-*                  Note: The guard time bits are not available for UART4 and UART5.
-*                  - USART_GuardTime: specifies the guard time.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
-{    
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  
-  /* Clear the USART Guard time */
-  USARTx-&gt;GTPR &amp;= GTPR_LSB_Mask;
-  /* Set the USART guard time */
-  USARTx-&gt;GTPR |= (u16)((u16)USART_GuardTime &lt;&lt; 0x08);
-}
-
-/*******************************************************************************
-* Function Name  : USART_SetPrescaler
-* Description    : Sets the system clock prescaler.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  Note: The function is used for IrDA mode with UART4 and UART5.
-*                  - USART_Prescaler: specifies the prescaler clock.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
-{ 
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Clear the USART prescaler */
-  USARTx-&gt;GTPR &amp;= GTPR_MSB_Mask;
-  /* Set the USART prescaler */
-  USARTx-&gt;GTPR |= USART_Prescaler;
-}
-
-/*******************************************************************************
-* Function Name  : USART_SmartCardCmd
-* Description    : Enables or disables the USART&#146;s Smart Card mode.
-* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
-*                    peripheral. 
-*                    Note: The Smart Card mode is not available for UART4 and UART5.
-*                  - NewState: new state of the Smart Card mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_SCEN_Set;
-  }
-  else
-  {
-    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_SCEN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_SmartCardNACKCmd
-* Description    : Enables or disables NACK transmission.
-* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
-*                    peripheral. 
-*                    Note: The Smart Card mode is not available for UART4 and UART5.
-*                  - NewState: new state of the NACK transmission.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_NACK_Set;
-  }
-  else
-  {
-    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_NACK_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_HalfDuplexCmd
-* Description    : Enables or disables the USART&#146;s Half Duplex communication.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the USART Communication.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_HDSEL_Set;
-  }
-  else
-  {
-    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_HDSEL_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_IrDAConfig
-* Description    : Configures the USART&#146;s IrDA interface.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IrDAMode: specifies the IrDA mode.
-*                    This parameter can be one of the following values:
-*                       - USART_IrDAMode_LowPower
-*                       - USART_IrDAMode_Normal
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
-    
-  USARTx-&gt;CR3 &amp;= CR3_IRLP_Mask;
-  USARTx-&gt;CR3 |= USART_IrDAMode;
-}
-
-/*******************************************************************************
-* Function Name  : USART_IrDACmd
-* Description    : Enables or disables the USART&#146;s IrDA interface.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - NewState: new state of the IrDA mode.
-*                    This parameter can be: ENABLE or DISABLE.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-    
-  if (NewState != DISABLE)
-  {
-    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
-    USARTx-&gt;CR3 |= CR3_IREN_Set;
-  }
-  else
-  {
-    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
-    USARTx-&gt;CR3 &amp;= CR3_IREN_Reset;
-  }
-}
-
-/*******************************************************************************
-* Function Name  : USART_GetFlagStatus
-* Description    : Checks whether the specified USART flag is set or not.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_FLAG: specifies the flag to check.
-*                    This parameter can be one of the following values:
-*                       - USART_FLAG_CTS:  CTS Change flag (not available for 
-*                                          UART4 and UART5)
-*                       - USART_FLAG_LBD:  LIN Break detection flag
-*                       - USART_FLAG_TXE:  Transmit data register empty flag
-*                       - USART_FLAG_TC:   Transmission Complete flag
-*                       - USART_FLAG_RXNE: Receive data register not empty flag
-*                       - USART_FLAG_IDLE: Idle Line detection flag
-*                       - USART_FLAG_ORE:  OverRun Error flag
-*                       - USART_FLAG_NE:   Noise Error flag
-*                       - USART_FLAG_FE:   Framing Error flag
-*                       - USART_FLAG_PE:   Parity Error flag
-* Output         : None
-* Return         : The new state of USART_FLAG (SET or RESET).
-*******************************************************************************/
-FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_FLAG(USART_FLAG));
-  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
-
-  if ((USARTx-&gt;SR &amp; USART_FLAG) != (u16)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClearFlag
-* Description    : Clears the USARTx's pending flags.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_FLAG: specifies the flag to clear.
-*                    This parameter can be any combination of the following values:
-*                       - USART_FLAG_CTS:  CTS Change flag (not available for
-*                                          UART4 and UART5).
-*                       - USART_FLAG_LBD:  LIN Break detection flag.
-*                       - USART_FLAG_TC:   Transmission Complete flag.
-*                       - USART_FLAG_RXNE: Receive data register not empty flag.
-*
-*                  Notes:
-*                        - PE (Parity error), FE (Framing error), NE (Noise error),
-*                          ORE (OverRun error) and IDLE (Idle line detected) 
-*                          flags are cleared by software sequence: a read 
-*                          operation to USART_SR register (USART_GetFlagStatus()) 
-*                          followed by a read operation to USART_DR register 
-*                          (USART_ReceiveData()).
-*                        - RXNE flag can be also cleared by a read to the 
-*                          USART_DR register (USART_ReceiveData()).
-*                        - TC flag can be also cleared by software sequence: a 
-*                          read operation to USART_SR register 
-*                          (USART_GetFlagStatus()) followed by a write operation
-*                          to USART_DR register (USART_SendData()).                                                      
-*                        - TXE flag is cleared only by a write to the USART_DR 
-*                          register (USART_SendData()).                        
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
-  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
-   
-  USARTx-&gt;SR = (u16)~USART_FLAG;
-}
-
-/*******************************************************************************
-* Function Name  : USART_GetITStatus
-* Description    : Checks whether the specified USART interrupt has occurred or not.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IT: specifies the USART interrupt source to check.
-*                    This parameter can be one of the following values:
-*                       - USART_IT_CTS:  CTS change interrupt (not available for 
-*                                        UART4 and UART5)
-*                       - USART_IT_LBD:  LIN Break detection interrupt
-*                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
-*                       - USART_IT_TC:   Transmission complete interrupt
-*                       - USART_IT_RXNE: Receive Data register not empty 
-*                                        interrupt
-*                       - USART_IT_IDLE: Idle line detection interrupt
-*                       - USART_IT_ORE:  OverRun Error interrupt
-*                       - USART_IT_NE:   Noise Error interrupt
-*                       - USART_IT_FE:   Framing Error interrupt
-*                       - USART_IT_PE:   Parity Error interrupt
-* Output         : None
-* Return         : The new state of USART_IT (SET or RESET).
-*******************************************************************************/
-ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
-{
-  u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
-  ITStatus bitstatus = RESET;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_GET_IT(USART_IT));
-  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
-  
-  /* Get the USART register index */
-  usartreg = (((u8)USART_IT) &gt;&gt; 0x05);
-
-  /* Get the interrupt position */
-  itmask = USART_IT &amp; IT_Mask;
-
-  itmask = (u32)0x01 &lt;&lt; itmask;
-  
-  if (usartreg == 0x01) /* The IT  is in CR1 register */
-  {
-    itmask &amp;= USARTx-&gt;CR1;
-  }
-  else if (usartreg == 0x02) /* The IT  is in CR2 register */
-  {
-    itmask &amp;= USARTx-&gt;CR2;
-  }
-  else /* The IT  is in CR3 register */
-  {
-    itmask &amp;= USARTx-&gt;CR3;
-  }
-  
-  bitpos = USART_IT &gt;&gt; 0x08;
-
-  bitpos = (u32)0x01 &lt;&lt; bitpos;
-  bitpos &amp;= USARTx-&gt;SR;
-
-  if ((itmask != (u16)RESET)&amp;&amp;(bitpos != (u16)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  
-  return bitstatus;  
-}
-
-/*******************************************************************************
-* Function Name  : USART_ClearITPendingBit
-* Description    : Clears the USARTx&#146;s interrupt pending bits.
-* Input          : - USARTx: Select the USART or the UART peripheral. 
-*                    This parameter can be one of the following values:
-*                     - USART1, USART2, USART3, UART4 or UART5.
-*                  - USART_IT: specifies the interrupt pending bit to clear.
-*                    This parameter can be one of the following values:
-*                       - USART_IT_CTS:  CTS change interrupt (not available for 
-*                                        UART4 and UART5)
-*                       - USART_IT_LBD:  LIN Break detection interrupt
-*                       - USART_IT_TC:   Transmission complete interrupt. 
-*                       - USART_IT_RXNE: Receive Data register not empty interrupt.
-*                    
-*                  Notes:
-*                        - PE (Parity error), FE (Framing error), NE (Noise error),
-*                          ORE (OverRun error) and IDLE (Idle line detected) 
-*                          pending bits are cleared by software sequence: a read 
-*                          operation to USART_SR register (USART_GetITStatus()) 
-*                          followed by a read operation to USART_DR register 
-*                          (USART_ReceiveData()).
-*                        - RXNE pending bit can be also cleared by a read to the 
-*                          USART_DR register (USART_ReceiveData()).
-*                        - TC pending bit can be also cleared by software 
-*                          sequence: a read operation to USART_SR register 
-*                          (USART_GetITStatus()) followed by a write operation
-*                          to USART_DR register (USART_SendData()).                                                      
-*                        - TXE pending bit is cleared only by a write to the 
-*                          USART_DR register (USART_SendData()).  
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
-{
-  u16 bitpos = 0x00, itmask = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CLEAR_IT(USART_IT));
-  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
-  
-  bitpos = USART_IT &gt;&gt; 0x08;
-
-  itmask = (u16)((u16)0x01 &lt;&lt; bitpos);
-  USARTx-&gt;SR = (u16)~itmask;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_usart.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the USART firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_usart.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* USART UE Mask */
+#define CR1_UE_Set                ((u16)0x2000)  /* USART Enable Mask */
+#define CR1_UE_Reset              ((u16)0xDFFF)  /* USART Disable Mask */
+
+/* USART WakeUp Method  */
+#define CR1_WAKE_Mask             ((u16)0xF7FF)  /* USART WakeUp Method Mask */
+
+/* USART RWU Mask */
+#define CR1_RWU_Set               ((u16)0x0002)  /* USART mute mode Enable Mask */
+#define CR1_RWU_Reset             ((u16)0xFFFD)  /* USART mute mode Enable Mask */
+
+#define CR1_SBK_Set               ((u16)0x0001)  /* USART Break Character send Mask */
+
+#define CR1_CLEAR_Mask            ((u16)0xE9F3)  /* USART CR1 Mask */
+
+#define CR2_Address_Mask          ((u16)0xFFF0)  /* USART address Mask */
+
+/* USART LIN Mask */
+#define CR2_LINEN_Set              ((u16)0x4000)  /* USART LIN Enable Mask */
+#define CR2_LINEN_Reset            ((u16)0xBFFF)  /* USART LIN Disable Mask */
+
+/* USART LIN Break detection */
+#define CR2_LBDL_Mask             ((u16)0xFFDF)  /* USART LIN Break detection Mask */
+
+#define CR2_STOP_CLEAR_Mask       ((u16)0xCFFF)  /* USART CR2 STOP Bits Mask */
+#define CR2_CLOCK_CLEAR_Mask      ((u16)0xF0FF)  /* USART CR2 Clock Mask */
+
+/* USART SC Mask */
+#define CR3_SCEN_Set              ((u16)0x0020)  /* USART SC Enable Mask */
+#define CR3_SCEN_Reset            ((u16)0xFFDF)  /* USART SC Disable Mask */
+
+/* USART SC NACK Mask */
+#define CR3_NACK_Set              ((u16)0x0010)  /* USART SC NACK Enable Mask */
+#define CR3_NACK_Reset            ((u16)0xFFEF)  /* USART SC NACK Disable Mask */
+
+/* USART Half-Duplex Mask */
+#define CR3_HDSEL_Set             ((u16)0x0008)  /* USART Half-Duplex Enable Mask */
+#define CR3_HDSEL_Reset           ((u16)0xFFF7)  /* USART Half-Duplex Disable Mask */
+
+/* USART IrDA Mask */
+#define CR3_IRLP_Mask             ((u16)0xFFFB)  /* USART IrDA LowPower mode Mask */
+
+#define CR3_CLEAR_Mask            ((u16)0xFCFF)  /* USART CR3 Mask */
+
+/* USART IrDA Mask */
+#define CR3_IREN_Set              ((u16)0x0002)  /* USART IrDA Enable Mask */
+#define CR3_IREN_Reset            ((u16)0xFFFD)  /* USART IrDA Disable Mask */
+
+#define GTPR_LSB_Mask             ((u16)0x00FF)  /* Guard Time Register LSB Mask */
+#define GTPR_MSB_Mask             ((u16)0xFF00)  /* Guard Time Register MSB Mask */
+
+#define IT_Mask                   ((u16)0x001F)  /* USART Interrupt Mask */
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : USART_DeInit
+* Description    : Deinitializes the USARTx peripheral registers to their
+*                  default reset values.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_DeInit(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+
+  switch (*(u32*)&amp;USARTx)
+  {
+    case USART1_BASE:
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
+      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
+      break;
+
+    case USART2_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
+      break;
+
+    case USART3_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
+      break;
+    
+    case UART4_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
+      break;
+    
+    case UART5_BASE:
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
+      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
+      break;            
+
+    default:
+      break;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_Init
+* Description    : Initializes the USARTx peripheral according to the specified
+*                  parameters in the USART_InitStruct .
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_InitStruct: pointer to a USART_InitTypeDef structure
+*                    that contains the configuration information for the
+*                    specified USART peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
+{
+  u32 tmpreg = 0x00, apbclock = 0x00;
+  u32 integerdivider = 0x00;
+  u32 fractionaldivider = 0x00;
+  u32 usartxbase = 0;
+  RCC_ClocksTypeDef RCC_ClocksStatus;
+
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_BAUDRATE(USART_InitStruct-&gt;USART_BaudRate));  
+  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct-&gt;USART_WordLength));
+  assert_param(IS_USART_STOPBITS(USART_InitStruct-&gt;USART_StopBits));
+  assert_param(IS_USART_PARITY(USART_InitStruct-&gt;USART_Parity));
+  assert_param(IS_USART_MODE(USART_InitStruct-&gt;USART_Mode));
+  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct-&gt;USART_HardwareFlowControl));
+  /* The hardware flow control is available only for USART1, USART2 and USART3 */          
+  assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct-&gt;USART_HardwareFlowControl));
+  
+  usartxbase = (*(u32*)&amp;USARTx);
+
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx-&gt;CR2;
+  /* Clear STOP[13:12] bits */
+  tmpreg &amp;= CR2_STOP_CLEAR_Mask;
+
+  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
+  /* Set STOP[13:12] bits according to USART_StopBits value */
+  tmpreg |= (u32)USART_InitStruct-&gt;USART_StopBits;
+  
+  /* Write to USART CR2 */
+  USARTx-&gt;CR2 = (u16)tmpreg;
+
+/*---------------------------- USART CR1 Configuration -----------------------*/
+  tmpreg = USARTx-&gt;CR1;
+  /* Clear M, PCE, PS, TE and RE bits */
+  tmpreg &amp;= CR1_CLEAR_Mask;
+
+  /* Configure the USART Word Length, Parity and mode ----------------------- */
+  /* Set the M bits according to USART_WordLength value */
+  /* Set PCE and PS bits according to USART_Parity value */
+  /* Set TE and RE bits according to USART_Mode value */
+  tmpreg |= (u32)USART_InitStruct-&gt;USART_WordLength | USART_InitStruct-&gt;USART_Parity |
+            USART_InitStruct-&gt;USART_Mode;
+
+  /* Write to USART CR1 */
+  USARTx-&gt;CR1 = (u16)tmpreg;
+
+/*---------------------------- USART CR3 Configuration -----------------------*/  
+  tmpreg = USARTx-&gt;CR3;
+  /* Clear CTSE and RTSE bits */
+  tmpreg &amp;= CR3_CLEAR_Mask;
+
+  /* Configure the USART HFC -------------------------------------------------*/
+  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
+  tmpreg |= USART_InitStruct-&gt;USART_HardwareFlowControl;
+
+  /* Write to USART CR3 */
+  USARTx-&gt;CR3 = (u16)tmpreg;
+
+/*---------------------------- USART BRR Configuration -----------------------*/
+  /* Configure the USART Baud Rate -------------------------------------------*/
+  RCC_GetClocksFreq(&amp;RCC_ClocksStatus);
+  if (usartxbase == USART1_BASE)
+  {
+    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
+  }
+  else
+  {
+    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
+  }
+
+  /* Determine the integer part */
+  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct-&gt;USART_BaudRate)));
+  tmpreg = (integerdivider / 0x64) &lt;&lt; 0x04;
+
+  /* Determine the fractional part */
+  fractionaldivider = integerdivider - (0x64 * (tmpreg &gt;&gt; 0x04));
+  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) &amp; ((u8)0x0F);
+
+  /* Write to USART BRR */
+  USARTx-&gt;BRR = (u16)tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : USART_StructInit
+* Description    : Fills each USART_InitStruct member with its default value.
+* Input          : - USART_InitStruct: pointer to a USART_InitTypeDef structure
+*                    which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
+{
+  /* USART_InitStruct members default value */
+  USART_InitStruct-&gt;USART_BaudRate = 9600;
+  USART_InitStruct-&gt;USART_WordLength = USART_WordLength_8b;
+  USART_InitStruct-&gt;USART_StopBits = USART_StopBits_1;
+  USART_InitStruct-&gt;USART_Parity = USART_Parity_No ;
+  USART_InitStruct-&gt;USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
+  USART_InitStruct-&gt;USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
+}
+
+/*******************************************************************************
+* Function Name  : USART_ClockInit
+* Description    : Initializes the USARTx peripheral Clock according to the 
+*                  specified parameters in the USART_ClockInitStruct .
+* Input          : - USARTx: where x can be 1, 2, 3 to select the USART peripheral.
+*                    Note: The Smart Card mode is not available for UART4 and UART5.
+*                  - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
+*                    structure that contains the configuration information for 
+*                    the specified USART peripheral.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  u32 tmpreg = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  assert_param(IS_USART_CLOCK(USART_ClockInitStruct-&gt;USART_Clock));
+  assert_param(IS_USART_CPOL(USART_ClockInitStruct-&gt;USART_CPOL));
+  assert_param(IS_USART_CPHA(USART_ClockInitStruct-&gt;USART_CPHA));
+  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct-&gt;USART_LastBit));              
+  
+/*---------------------------- USART CR2 Configuration -----------------------*/
+  tmpreg = USARTx-&gt;CR2;
+  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
+  tmpreg &amp;= CR2_CLOCK_CLEAR_Mask;
+
+  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
+  /* Set CLKEN bit according to USART_Clock value */
+  /* Set CPOL bit according to USART_CPOL value */
+  /* Set CPHA bit according to USART_CPHA value */
+  /* Set LBCL bit according to USART_LastBit value */
+  tmpreg |= (u32)USART_ClockInitStruct-&gt;USART_Clock | USART_ClockInitStruct-&gt;USART_CPOL | 
+                 USART_ClockInitStruct-&gt;USART_CPHA | USART_ClockInitStruct-&gt;USART_LastBit;
+
+  /* Write to USART CR2 */
+  USARTx-&gt;CR2 = (u16)tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : USART_ClockStructInit
+* Description    : Fills each USART_ClockInitStruct member with its default value.
+* Input          : - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
+*                    structure which will be initialized.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
+{
+  /* USART_ClockInitStruct members default value */
+  USART_ClockInitStruct-&gt;USART_Clock = USART_Clock_Disable;
+  USART_ClockInitStruct-&gt;USART_CPOL = USART_CPOL_Low;
+  USART_ClockInitStruct-&gt;USART_CPHA = USART_CPHA_1Edge;
+  USART_ClockInitStruct-&gt;USART_LastBit = USART_LastBit_Disable;
+}
+
+/*******************************************************************************
+* Function Name  : USART_Cmd
+* Description    : Enables or disables the specified USART peripheral.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                : - NewState: new state of the USARTx peripheral.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the selected USART by setting the UE bit in the CR1 register */
+    USARTx-&gt;CR1 |= CR1_UE_Set;
+  }
+  else
+  {
+    /* Disable the selected USART by clearing the UE bit in the CR1 register */
+    USARTx-&gt;CR1 &amp;= CR1_UE_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_ITConfig
+* Description    : Enables or disables the specified USART interrupts.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_IT: specifies the USART interrupt sources to be
+*                    enabled or disabled.
+*                    This parameter can be one of the following values:
+*                       - USART_IT_CTS:  CTS change interrupt (not available for
+*                                        UART4 and UART5)
+*                       - USART_IT_LBD:  LIN Break detection interrupt
+*                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
+*                       - USART_IT_TC:   Transmission complete interrupt
+*                       - USART_IT_RXNE: Receive Data register not empty 
+*                                        interrupt
+*                       - USART_IT_IDLE: Idle line detection interrupt
+*                       - USART_IT_PE:   Parity Error interrupt
+*                       - USART_IT_ERR:  Error interrupt(Frame error, noise
+*                                        error, overrun error)
+*                  - NewState: new state of the specified USARTx interrupts.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
+{
+  u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
+  u32 usartxbase = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CONFIG_IT(USART_IT));
+  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  usartxbase = (*(u32*)&amp;(USARTx));
+
+  /* Get the USART register index */
+  usartreg = (((u8)USART_IT) &gt;&gt; 0x05);
+
+  /* Get the interrupt position */
+  itpos = USART_IT &amp; IT_Mask;
+
+  itmask = (((u32)0x01) &lt;&lt; itpos);
+    
+  if (usartreg == 0x01) /* The IT is in CR1 register */
+  {
+    usartxbase += 0x0C;
+  }
+  else if (usartreg == 0x02) /* The IT is in CR2 register */
+  {
+    usartxbase += 0x10;
+  }
+  else /* The IT is in CR3 register */
+  {
+    usartxbase += 0x14; 
+  }
+  if (NewState != DISABLE)
+  {
+    *(vu32*)usartxbase  |= itmask;
+  }
+  else
+  {
+    *(vu32*)usartxbase &amp;= ~itmask;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_DMACmd
+* Description    : Enables or disables the USART's DMA interface.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3 or UART4.
+*                    Note: The DMA mode is not available for UART5.
+*                  - USART_DMAReq: specifies the DMA request.
+*                    This parameter can be any combination of the following values:
+*                       - USART_DMAReq_Tx: USART DMA transmit request
+*                       - USART_DMAReq_Rx: USART DMA receive request
+*                  - NewState: new state of the DMA Request sources.
+*                   This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_1234_PERIPH(USARTx));
+  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx-&gt;CR3 |= USART_DMAReq;
+  }
+  else
+  {
+    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
+       DMAR bits in the USART CR3 register */
+    USARTx-&gt;CR3 &amp;= (u16)~USART_DMAReq;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_SetAddress
+* Description    : Sets the address of the USART node.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_Address: Indicates the address of the USART node.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_ADDRESS(USART_Address)); 
+    
+  /* Clear the USART address */
+  USARTx-&gt;CR2 &amp;= CR2_Address_Mask;
+  /* Set the USART address node */
+  USARTx-&gt;CR2 |= USART_Address;
+}
+
+/*******************************************************************************
+* Function Name  : USART_WakeUpConfig
+* Description    : Selects the USART WakeUp method.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_WakeUp: specifies the USART wakeup method.
+*                    This parameter can be one of the following values:
+*                        - USART_WakeUp_IdleLine: WakeUp by an idle line detection
+*                        - USART_WakeUp_AddressMark: WakeUp by an address mark
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_WAKEUP(USART_WakeUp));
+  
+  USARTx-&gt;CR1 &amp;= CR1_WAKE_Mask;
+  USARTx-&gt;CR1 |= USART_WakeUp;
+}
+
+/*******************************************************************************
+* Function Name  : USART_ReceiverWakeUpCmd
+* Description    : Determines if the USART is in mute mode or not.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - NewState: new state of the USART mute mode.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
+    USARTx-&gt;CR1 |= CR1_RWU_Set;
+  }
+  else
+  {
+    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
+    USARTx-&gt;CR1 &amp;= CR1_RWU_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_LINBreakDetectLengthConfig
+* Description    : Sets the USART LIN Break detection length.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_LINBreakDetectLength: specifies the LIN break
+*                    detection length.
+*                    This parameter can be one of the following values:
+*                       - USART_LINBreakDetectLength_10b: 10-bit break detection
+*                       - USART_LINBreakDetectLength_11b: 11-bit break detection
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
+  
+  USARTx-&gt;CR2 &amp;= CR2_LBDL_Mask;
+  USARTx-&gt;CR2 |= USART_LINBreakDetectLength;  
+}
+
+/*******************************************************************************
+* Function Name  : USART_LINCmd
+* Description    : Enables or disables the USART's LIN mode.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - NewState: new state of the USART LIN mode.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
+    USARTx-&gt;CR2 |= CR2_LINEN_Set;
+  }
+  else
+  {
+    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
+    USARTx-&gt;CR2 &amp;= CR2_LINEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_SendData
+* Description    : Transmits single data through the USARTx peripheral.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - Data: the data to transmit.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_SendData(USART_TypeDef* USARTx, u16 Data)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_DATA(Data)); 
+    
+  /* Transmit Data */
+  USARTx-&gt;DR = (Data &amp; (u16)0x01FF);
+}
+
+/*******************************************************************************
+* Function Name  : USART_ReceiveData
+* Description    : Returns the most recent received data by the USARTx peripheral.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+* Output         : None
+* Return         : The received data.
+*******************************************************************************/
+u16 USART_ReceiveData(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Receive Data */
+  return (u16)(USARTx-&gt;DR &amp; (u16)0x01FF);
+}
+
+/*******************************************************************************
+* Function Name  : USART_SendBreak
+* Description    : Transmits break characters.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_SendBreak(USART_TypeDef* USARTx)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Send break characters */
+  USARTx-&gt;CR1 |= CR1_SBK_Set;
+}
+
+/*******************************************************************************
+* Function Name  : USART_SetGuardTime
+* Description    : Sets the specified USART guard time.
+* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
+*                    peripheral.
+*                  Note: The guard time bits are not available for UART4 and UART5.
+*                  - USART_GuardTime: specifies the guard time.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
+{    
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  
+  /* Clear the USART Guard time */
+  USARTx-&gt;GTPR &amp;= GTPR_LSB_Mask;
+  /* Set the USART guard time */
+  USARTx-&gt;GTPR |= (u16)((u16)USART_GuardTime &lt;&lt; 0x08);
+}
+
+/*******************************************************************************
+* Function Name  : USART_SetPrescaler
+* Description    : Sets the system clock prescaler.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  Note: The function is used for IrDA mode with UART4 and UART5.
+*                  - USART_Prescaler: specifies the prescaler clock.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
+{ 
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  
+  /* Clear the USART prescaler */
+  USARTx-&gt;GTPR &amp;= GTPR_MSB_Mask;
+  /* Set the USART prescaler */
+  USARTx-&gt;GTPR |= USART_Prescaler;
+}
+
+/*******************************************************************************
+* Function Name  : USART_SmartCardCmd
+* Description    : Enables or disables the USART's Smart Card mode.
+* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
+*                    peripheral. 
+*                    Note: The Smart Card mode is not available for UART4 and UART5.
+*                  - NewState: new state of the Smart Card mode.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_SCEN_Set;
+  }
+  else
+  {
+    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_SCEN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_SmartCardNACKCmd
+* Description    : Enables or disables NACK transmission.
+* Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
+*                    peripheral. 
+*                    Note: The Smart Card mode is not available for UART4 and UART5.
+*                  - NewState: new state of the NACK transmission.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_123_PERIPH(USARTx));  
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+
+  if (NewState != DISABLE)
+  {
+    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_NACK_Set;
+  }
+  else
+  {
+    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_NACK_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_HalfDuplexCmd
+* Description    : Enables or disables the USART's Half Duplex communication.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - NewState: new state of the USART Communication.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+  
+  if (NewState != DISABLE)
+  {
+    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_HDSEL_Set;
+  }
+  else
+  {
+    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_HDSEL_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_IrDAConfig
+* Description    : Configures the USART's IrDA interface.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_IrDAMode: specifies the IrDA mode.
+*                    This parameter can be one of the following values:
+*                       - USART_IrDAMode_LowPower
+*                       - USART_IrDAMode_Normal
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
+    
+  USARTx-&gt;CR3 &amp;= CR3_IRLP_Mask;
+  USARTx-&gt;CR3 |= USART_IrDAMode;
+}
+
+/*******************************************************************************
+* Function Name  : USART_IrDACmd
+* Description    : Enables or disables the USART's IrDA interface.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - NewState: new state of the IrDA mode.
+*                    This parameter can be: ENABLE or DISABLE.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_FUNCTIONAL_STATE(NewState));
+    
+  if (NewState != DISABLE)
+  {
+    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
+    USARTx-&gt;CR3 |= CR3_IREN_Set;
+  }
+  else
+  {
+    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
+    USARTx-&gt;CR3 &amp;= CR3_IREN_Reset;
+  }
+}
+
+/*******************************************************************************
+* Function Name  : USART_GetFlagStatus
+* Description    : Checks whether the specified USART flag is set or not.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_FLAG: specifies the flag to check.
+*                    This parameter can be one of the following values:
+*                       - USART_FLAG_CTS:  CTS Change flag (not available for 
+*                                          UART4 and UART5)
+*                       - USART_FLAG_LBD:  LIN Break detection flag
+*                       - USART_FLAG_TXE:  Transmit data register empty flag
+*                       - USART_FLAG_TC:   Transmission Complete flag
+*                       - USART_FLAG_RXNE: Receive data register not empty flag
+*                       - USART_FLAG_IDLE: Idle Line detection flag
+*                       - USART_FLAG_ORE:  OverRun Error flag
+*                       - USART_FLAG_NE:   Noise Error flag
+*                       - USART_FLAG_FE:   Framing Error flag
+*                       - USART_FLAG_PE:   Parity Error flag
+* Output         : None
+* Return         : The new state of USART_FLAG (SET or RESET).
+*******************************************************************************/
+FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
+{
+  FlagStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_FLAG(USART_FLAG));
+  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
+
+  if ((USARTx-&gt;SR &amp; USART_FLAG) != (u16)RESET)
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  return bitstatus;
+}
+
+/*******************************************************************************
+* Function Name  : USART_ClearFlag
+* Description    : Clears the USARTx's pending flags.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_FLAG: specifies the flag to clear.
+*                    This parameter can be any combination of the following values:
+*                       - USART_FLAG_CTS:  CTS Change flag (not available for
+*                                          UART4 and UART5).
+*                       - USART_FLAG_LBD:  LIN Break detection flag.
+*                       - USART_FLAG_TC:   Transmission Complete flag.
+*                       - USART_FLAG_RXNE: Receive data register not empty flag.
+*
+*                  Notes:
+*                        - PE (Parity error), FE (Framing error), NE (Noise error),
+*                          ORE (OverRun error) and IDLE (Idle line detected) 
+*                          flags are cleared by software sequence: a read 
+*                          operation to USART_SR register (USART_GetFlagStatus()) 
+*                          followed by a read operation to USART_DR register 
+*                          (USART_ReceiveData()).
+*                        - RXNE flag can be also cleared by a read to the 
+*                          USART_DR register (USART_ReceiveData()).
+*                        - TC flag can be also cleared by software sequence: a 
+*                          read operation to USART_SR register 
+*                          (USART_GetFlagStatus()) followed by a write operation
+*                          to USART_DR register (USART_SendData()).                                                      
+*                        - TXE flag is cleared only by a write to the USART_DR 
+*                          register (USART_SendData()).                        
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
+{
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
+  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
+   
+  USARTx-&gt;SR = (u16)~USART_FLAG;
+}
+
+/*******************************************************************************
+* Function Name  : USART_GetITStatus
+* Description    : Checks whether the specified USART interrupt has occurred or not.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_IT: specifies the USART interrupt source to check.
+*                    This parameter can be one of the following values:
+*                       - USART_IT_CTS:  CTS change interrupt (not available for 
+*                                        UART4 and UART5)
+*                       - USART_IT_LBD:  LIN Break detection interrupt
+*                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
+*                       - USART_IT_TC:   Transmission complete interrupt
+*                       - USART_IT_RXNE: Receive Data register not empty 
+*                                        interrupt
+*                       - USART_IT_IDLE: Idle line detection interrupt
+*                       - USART_IT_ORE:  OverRun Error interrupt
+*                       - USART_IT_NE:   Noise Error interrupt
+*                       - USART_IT_FE:   Framing Error interrupt
+*                       - USART_IT_PE:   Parity Error interrupt
+* Output         : None
+* Return         : The new state of USART_IT (SET or RESET).
+*******************************************************************************/
+ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
+{
+  u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
+  ITStatus bitstatus = RESET;
+
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_GET_IT(USART_IT));
+  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
+  
+  /* Get the USART register index */
+  usartreg = (((u8)USART_IT) &gt;&gt; 0x05);
+
+  /* Get the interrupt position */
+  itmask = USART_IT &amp; IT_Mask;
+
+  itmask = (u32)0x01 &lt;&lt; itmask;
+  
+  if (usartreg == 0x01) /* The IT  is in CR1 register */
+  {
+    itmask &amp;= USARTx-&gt;CR1;
+  }
+  else if (usartreg == 0x02) /* The IT  is in CR2 register */
+  {
+    itmask &amp;= USARTx-&gt;CR2;
+  }
+  else /* The IT  is in CR3 register */
+  {
+    itmask &amp;= USARTx-&gt;CR3;
+  }
+  
+  bitpos = USART_IT &gt;&gt; 0x08;
+
+  bitpos = (u32)0x01 &lt;&lt; bitpos;
+  bitpos &amp;= USARTx-&gt;SR;
+
+  if ((itmask != (u16)RESET)&amp;&amp;(bitpos != (u16)RESET))
+  {
+    bitstatus = SET;
+  }
+  else
+  {
+    bitstatus = RESET;
+  }
+  
+  return bitstatus;  
+}
+
+/*******************************************************************************
+* Function Name  : USART_ClearITPendingBit
+* Description    : Clears the USARTx's interrupt pending bits.
+* Input          : - USARTx: Select the USART or the UART peripheral. 
+*                    This parameter can be one of the following values:
+*                     - USART1, USART2, USART3, UART4 or UART5.
+*                  - USART_IT: specifies the interrupt pending bit to clear.
+*                    This parameter can be one of the following values:
+*                       - USART_IT_CTS:  CTS change interrupt (not available for 
+*                                        UART4 and UART5)
+*                       - USART_IT_LBD:  LIN Break detection interrupt
+*                       - USART_IT_TC:   Transmission complete interrupt. 
+*                       - USART_IT_RXNE: Receive Data register not empty interrupt.
+*                    
+*                  Notes:
+*                        - PE (Parity error), FE (Framing error), NE (Noise error),
+*                          ORE (OverRun error) and IDLE (Idle line detected) 
+*                          pending bits are cleared by software sequence: a read 
+*                          operation to USART_SR register (USART_GetITStatus()) 
+*                          followed by a read operation to USART_DR register 
+*                          (USART_ReceiveData()).
+*                        - RXNE pending bit can be also cleared by a read to the 
+*                          USART_DR register (USART_ReceiveData()).
+*                        - TC pending bit can be also cleared by software 
+*                          sequence: a read operation to USART_SR register 
+*                          (USART_GetITStatus()) followed by a write operation
+*                          to USART_DR register (USART_SendData()).                                                      
+*                        - TXE pending bit is cleared only by a write to the 
+*                          USART_DR register (USART_SendData()).  
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
+{
+  u16 bitpos = 0x00, itmask = 0x00;
+
+  /* Check the parameters */
+  assert_param(IS_USART_ALL_PERIPH(USARTx));
+  assert_param(IS_USART_CLEAR_IT(USART_IT));
+  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
+  
+  bitpos = USART_IT &gt;&gt; 0x08;
+
+  itmask = (u16)((u16)0x01 &lt;&lt; bitpos);
+  USARTx-&gt;SR = (u16)~itmask;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c
===================================================================
--- trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/FWLib/library/src/stm32f10x_wwdg.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,185 +1,185 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : stm32f10x_wwdg.c
-* Author             : MCD Application Team
-* Version            : V2.0.3
-* Date               : 09/22/2008
-* Description        : This file provides all the WWDG firmware functions.
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include &quot;stm32f10x_wwdg.h&quot;
-#include &quot;stm32f10x_rcc.h&quot;
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* ----------- WWDG registers bit address in the alias region ----------- */
-#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
-
-/* Alias word address of EWI bit */
-#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
-#define EWI_BitNumber     0x09
-#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))
-
-/* --------------------- WWDG registers bit mask ------------------------ */
-/* CR register bit mask */
-#define CR_WDGA_Set       ((u32)0x00000080)
-
-/* CFR register bit mask */
-#define CFR_WDGTB_Mask    ((u32)0xFFFFFE7F)
-#define CFR_W_Mask        ((u32)0xFFFFFF80)
-
-#define BIT_Mask          ((u8)0x7F)
-
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : WWDG_DeInit
-* Description    : Deinitializes the WWDG  peripheral registers to their default
-*                  reset values.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_DeInit(void)
-{
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_SetPrescaler
-* Description    : Sets the WWDG Prescaler.
-* Input          : - WWDG_Prescaler: specifies the WWDG Prescaler.
-*                    This parameter can be one of the following values:
-*                       - WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
-*                       - WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
-*                       - WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
-*                       - WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_SetPrescaler(u32 WWDG_Prescaler)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
-
-  /* Clear WDGTB[1:0] bits */
-  tmpreg = WWDG-&gt;CFR &amp; CFR_WDGTB_Mask;
-
-  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
-  tmpreg |= WWDG_Prescaler;
-
-  /* Store the new value */
-  WWDG-&gt;CFR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_SetWindowValue
-* Description    : Sets the WWDG window value.
-* Input          : - WindowValue: specifies the window value to be compared to
-*                    the downcounter.
-*                    This parameter value must be lower than 0x80.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_SetWindowValue(u8 WindowValue)
-{
-  u32 tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
-
-  /* Clear W[6:0] bits */
-  tmpreg = WWDG-&gt;CFR &amp; CFR_W_Mask;
-
-  /* Set W[6:0] bits according to WindowValue value */
-  tmpreg |= WindowValue &amp; BIT_Mask;
-
-  /* Store the new value */
-  WWDG-&gt;CFR = tmpreg;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_EnableIT
-* Description    : Enables the WWDG Early Wakeup interrupt(EWI).
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_EnableIT(void)
-{
-  *(vu32 *) CFR_EWI_BB = (u32)ENABLE;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_SetCounter
-* Description    : Sets the WWDG counter value.
-* Input          : - Counter: specifies the watchdog counter value.
-*                    This parameter must be a number between 0x40 and 0x7F.
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_SetCounter(u8 Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_WWDG_COUNTER(Counter));
-
-  /* Write to T[6:0] bits to configure the counter value, no need to do
-     a read-modify-write; writing a 0 to WDGA bit does nothing */
-  WWDG-&gt;CR = Counter &amp; BIT_Mask;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_Enable
-* Description    : Enables WWDG and load the counter value.
-*                  - Counter: specifies the watchdog counter value.
-*                    This parameter must be a number between 0x40 and 0x7F.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_Enable(u8 Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_WWDG_COUNTER(Counter));
-
-  WWDG-&gt;CR = CR_WDGA_Set | Counter;
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_GetFlagStatus
-* Description    : Checks whether the Early Wakeup interrupt flag is set or not.
-* Input          : None
-* Output         : None
-* Return         : The new state of the Early Wakeup interrupt flag (SET or RESET)
-*******************************************************************************/
-FlagStatus WWDG_GetFlagStatus(void)
-{
-  return (FlagStatus)(WWDG-&gt;SR);
-}
-
-/*******************************************************************************
-* Function Name  : WWDG_ClearFlag
-* Description    : Clears Early Wakeup interrupt flag.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void WWDG_ClearFlag(void)
-{
-  WWDG-&gt;SR = (u32)RESET;
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
+/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
+* File Name          : stm32f10x_wwdg.c
+* Author             : MCD Application Team
+* Version            : V2.0.3
+* Date               : 09/22/2008
+* Description        : This file provides all the WWDG firmware functions.
+********************************************************************************
+* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*******************************************************************************/
+
+/* Includes ------------------------------------------------------------------*/
+#include &quot;stm32f10x_wwdg.h&quot;
+#include &quot;stm32f10x_rcc.h&quot;
+
+/* Private typedef -----------------------------------------------------------*/
+/* Private define ------------------------------------------------------------*/
+/* ----------- WWDG registers bit address in the alias region ----------- */
+#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
+
+/* Alias word address of EWI bit */
+#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
+#define EWI_BitNumber     0x09
+#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))
+
+/* --------------------- WWDG registers bit mask ------------------------ */
+/* CR register bit mask */
+#define CR_WDGA_Set       ((u32)0x00000080)
+
+/* CFR register bit mask */
+#define CFR_WDGTB_Mask    ((u32)0xFFFFFE7F)
+#define CFR_W_Mask        ((u32)0xFFFFFF80)
+
+#define BIT_Mask          ((u8)0x7F)
+
+/* Private macro -------------------------------------------------------------*/
+/* Private variables ---------------------------------------------------------*/
+/* Private function prototypes -----------------------------------------------*/
+/* Private functions ---------------------------------------------------------*/
+
+/*******************************************************************************
+* Function Name  : WWDG_DeInit
+* Description    : Deinitializes the WWDG  peripheral registers to their default
+*                  reset values.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_DeInit(void)
+{
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
+  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_SetPrescaler
+* Description    : Sets the WWDG Prescaler.
+* Input          : - WWDG_Prescaler: specifies the WWDG Prescaler.
+*                    This parameter can be one of the following values:
+*                       - WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
+*                       - WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
+*                       - WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
+*                       - WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_SetPrescaler(u32 WWDG_Prescaler)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
+
+  /* Clear WDGTB[1:0] bits */
+  tmpreg = WWDG-&gt;CFR &amp; CFR_WDGTB_Mask;
+
+  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
+  tmpreg |= WWDG_Prescaler;
+
+  /* Store the new value */
+  WWDG-&gt;CFR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_SetWindowValue
+* Description    : Sets the WWDG window value.
+* Input          : - WindowValue: specifies the window value to be compared to
+*                    the downcounter.
+*                    This parameter value must be lower than 0x80.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_SetWindowValue(u8 WindowValue)
+{
+  u32 tmpreg = 0;
+
+  /* Check the parameters */
+  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
+
+  /* Clear W[6:0] bits */
+  tmpreg = WWDG-&gt;CFR &amp; CFR_W_Mask;
+
+  /* Set W[6:0] bits according to WindowValue value */
+  tmpreg |= WindowValue &amp; BIT_Mask;
+
+  /* Store the new value */
+  WWDG-&gt;CFR = tmpreg;
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_EnableIT
+* Description    : Enables the WWDG Early Wakeup interrupt(EWI).
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_EnableIT(void)
+{
+  *(vu32 *) CFR_EWI_BB = (u32)ENABLE;
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_SetCounter
+* Description    : Sets the WWDG counter value.
+* Input          : - Counter: specifies the watchdog counter value.
+*                    This parameter must be a number between 0x40 and 0x7F.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_SetCounter(u8 Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+
+  /* Write to T[6:0] bits to configure the counter value, no need to do
+     a read-modify-write; writing a 0 to WDGA bit does nothing */
+  WWDG-&gt;CR = Counter &amp; BIT_Mask;
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_Enable
+* Description    : Enables WWDG and load the counter value.
+*                  - Counter: specifies the watchdog counter value.
+*                    This parameter must be a number between 0x40 and 0x7F.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_Enable(u8 Counter)
+{
+  /* Check the parameters */
+  assert_param(IS_WWDG_COUNTER(Counter));
+
+  WWDG-&gt;CR = CR_WDGA_Set | Counter;
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_GetFlagStatus
+* Description    : Checks whether the Early Wakeup interrupt flag is set or not.
+* Input          : None
+* Output         : None
+* Return         : The new state of the Early Wakeup interrupt flag (SET or RESET)
+*******************************************************************************/
+FlagStatus WWDG_GetFlagStatus(void)
+{
+  return (FlagStatus)(WWDG-&gt;SR);
+}
+
+/*******************************************************************************
+* Function Name  : WWDG_ClearFlag
+* Description    : Clears Early Wakeup interrupt flag.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void WWDG_ClearFlag(void)
+{
+  WWDG-&gt;SR = (u32)RESET;
+}
+
+/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

Modified: trunk/src/platform/stm32/conf.py
===================================================================
--- trunk/src/platform/stm32/conf.py	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/conf.py	2009-01-07 20:17:18 UTC (rev 143)
@@ -16,6 +16,9 @@
 specific_files = fwlib_files + &quot; &quot; + &quot; &quot;.join( [ &quot;src/platform/%s/%s&quot; % ( platform, f ) for f in specific_files.split() ] )
 ldscript = &quot;src/platform/%s/%s&quot; % ( platform, ldscript )
 
+if boardname == 'STM3210E-EVAL':
+  cdefs = cdefs + &quot; -DFORSTM3210E_EVAL&quot;
+
 cdefs = cdefs + &quot; -Dgcc&quot;
 
 # Toolset data

Modified: trunk/src/platform/stm32/lua_lcd.c
===================================================================
--- trunk/src/platform/stm32/lua_lcd.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/lua_lcd.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -12,7 +12,7 @@
 
 #include &quot;lcd.h&quot;
 
-#if ELUA_BOARD == STM3210E-EVAL
+#ifdef FORSTM3210E_EVAL
 
 static int lcd_init(lua_State * L)
 {

Modified: trunk/src/platform/stm32/platform.c
===================================================================
--- trunk/src/platform/stm32/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -13,8 +13,9 @@
 #include &quot;elua_uip.h&quot; 
 #include &quot;uip-conf.h&quot;
 #include &quot;platform_conf.h&quot;
+#include &quot;common.h&quot;
 
-// Platform specific includes
+// Platform specific includes
 #include &quot;stm32f10x_lib.h&quot;
 #include &quot;stm32f10x_map.h&quot;
 #include &quot;stm32f10x_type.h&quot;
@@ -28,49 +29,23 @@
 #include &quot;stm32f10x_spi.h&quot;
 #include &quot;stm32f10x_systick.h&quot;
 #include &quot;stm32f10x_flash.h&quot;
-
-#include &quot;systick.h&quot;
 
-#define STM32_USE_PIO
-#define STM32_USE_USART
-
-#define CONSOLE 0
+#include &quot;systick.h&quot;
 
+#define STM32_USE_PIO
+#define STM32_USE_USART
+
 void exit(int ret)
 {
   while(1);
 }
 
-// *****************************************************************************
-// std function
-// TODO: Update to interrupt driven routines.
-
-static void uart_send( int fd, char c )
-{
-  fd = fd;
-    /* Loop until USART1 DR register is empty */ 
-    while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
-    {
-    }
-
-  USART_SendData(USART1, c);
-}
-
-static int uart_recv()
-{
-    /* Loop until the USART1 Receive Data Register is not empty */
-    while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
-    {
-    }
-  return USART_ReceiveData(USART1);
-}
-
 // ****************************************************************************
 // Platform initialization
 
-// forward dcls
-static void RCC_Configuration(void);
-static void NVIC_Configuration(void);
+// forward dcls
+static void RCC_Configuration(void);
+static void NVIC_Configuration(void);
 
 static void timers_init();
 static void uarts_init();
@@ -83,27 +58,27 @@
 { 
   // Set the clocking to run from PLL
   RCC_Configuration();
-
-  // Setup IRQ's
-  NVIC_Configuration();
-
-  // Enable SysTick timer.
-  SysTick_Config();
-
+
+  // Setup IRQ's
+  NVIC_Configuration();
+
+  // Enable SysTick timer.
+  SysTick_Config();
+
 #ifdef STM32_USE_PIO
   // Setup PIO
-  pios_init();
+  pios_init();
 #endif
-
+
 #ifdef STM32_USE_SPI
   // Setup SPIs
-  //spis_init();
+  //spis_init();
 #endif
-
+
 #ifdef STM32_USE_USART
   // Setup UARTs
   uarts_init();
-#endif
+#endif
 
   // Setup timers
   //timers_init();        
@@ -114,162 +89,138 @@
   // Setup ethernet (TCP/IP)
   //eth_init();
 
-  // Set the send/recv functions                          
-  std_set_send_func( uart_send );
-  std_set_get_func( uart_recv );      
-
+  cmn_platform_init();
+  
   // All done
   return PLATFORM_OK;
-} 
-
-// ****************************************************************************
+} 
+
+// ****************************************************************************
 // Clocks
-// Shared by all STM32 devices.
-// TODO: Fix to handle different crystal frequencies and CPU frequencies.
-
-/*******************************************************************************
-* Function Name  : RCC_Configuration
-* Description    : Configures the different system clocks.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void RCC_Configuration(void)
-{
-  ErrorStatus HSEStartUpStatus;
-  /* RCC system reset(for debug purpose) */
-  RCC_DeInit();
-
-  /* Enable HSE */
-  RCC_HSEConfig(RCC_HSE_ON);
-
-  /* Wait till HSE is ready */
-  HSEStartUpStatus = RCC_WaitForHSEStartUp();
-
-  if(HSEStartUpStatus == SUCCESS)
-  {
-    /* Enable Prefetch Buffer */
-    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
-
-    /* Flash 2 wait state */
-    FLASH_SetLatency(FLASH_Latency_2);
- 
-    /* HCLK = SYSCLK */
-    RCC_HCLKConfig(RCC_SYSCLK_Div1); 
-  
-    /* PCLK2 = HCLK */
-    RCC_PCLK2Config(RCC_HCLK_Div1); 
-
-    /* PCLK1 = HCLK/2 */
-    RCC_PCLK1Config(RCC_HCLK_Div2);
-
-    /* PLLCLK = 8MHz * 9 = 72 MHz */
-    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
-
-    /* Enable PLL */ 
-    RCC_PLLCmd(ENABLE);
-
-    /* Wait till PLL is ready */
-    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
-    {
-    }
-
-    /* Select PLL as system clock source */
-    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
-
-    /* Wait till PLL is used as system clock source */
-    while(RCC_GetSYSCLKSource() != 0x08)
-    {
-    }
-  } 
- 
-  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
-}
-
-// ****************************************************************************
-// NVIC
-// Shared by all STM32 devices.
-
-/*******************************************************************************
-* Function Name  : NVIC_Configuration
-* Description    : Configures the nested vectored interrupt controller.
-* Input          : None
-* Output         : None
-* Return         : None
-*******************************************************************************/
-void NVIC_Configuration(void)
-{
-  NVIC_InitTypeDef NVIC_InitStructure;
-
-  NVIC_DeInit();
-
-#ifdef  VECT_TAB_RAM  
-  /* Set the Vector Table base location at 0x20000000 */ 
-  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
-#else  /* VECT_TAB_FLASH  */
-  /* Set the Vector Table base location at 0x08000000 */ 
-  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
-#endif 
-
-  /* Configure the NVIC Preemption Priority Bits */  
-  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
-
-  /* Configure the SysTick handler priority */
-  NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 0, 0);
-}
+// Shared by all STM32 devices.
+// TODO: Fix to handle different crystal frequencies and CPU frequencies.
 
+/*******************************************************************************
+* Function Name  : RCC_Configuration
+* Description    : Configures the different system clocks.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void RCC_Configuration(void)
+{
+  ErrorStatus HSEStartUpStatus;
+  /* RCC system reset(for debug purpose) */
+  RCC_DeInit();
+
+  /* Enable HSE */
+  RCC_HSEConfig(RCC_HSE_ON);
+
+  /* Wait till HSE is ready */
+  HSEStartUpStatus = RCC_WaitForHSEStartUp();
+
+  if(HSEStartUpStatus == SUCCESS)
+  {
+    /* Enable Prefetch Buffer */
+    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
+
+    /* Flash 2 wait state */
+    FLASH_SetLatency(FLASH_Latency_2);
+ 
+    /* HCLK = SYSCLK */
+    RCC_HCLKConfig(RCC_SYSCLK_Div1); 
+  
+    /* PCLK2 = HCLK */
+    RCC_PCLK2Config(RCC_HCLK_Div1); 
+
+    /* PCLK1 = HCLK/2 */
+    RCC_PCLK1Config(RCC_HCLK_Div2);
+
+    /* PLLCLK = 8MHz * 9 = 72 MHz */
+    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
+
+    /* Enable PLL */ 
+    RCC_PLLCmd(ENABLE);
+
+    /* Wait till PLL is ready */
+    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
+    {
+    }
+
+    /* Select PLL as system clock source */
+    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
+
+    /* Wait till PLL is used as system clock source */
+    while(RCC_GetSYSCLKSource() != 0x08)
+    {
+    }
+  } 
+ 
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
+}
+
 // ****************************************************************************
-// PIO
+// NVIC
+// Shared by all STM32 devices.
+
+/*******************************************************************************
+* Function Name  : NVIC_Configuration
+* Description    : Configures the nested vectored interrupt controller.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void NVIC_Configuration(void)
+{
+  NVIC_InitTypeDef NVIC_InitStructure;
+
+  NVIC_DeInit();
+
+#ifdef  VECT_TAB_RAM  
+  /* Set the Vector Table base location at 0x20000000 */ 
+  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
+#else  /* VECT_TAB_FLASH  */
+  /* Set the Vector Table base location at 0x08000000 */ 
+  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
+#endif 
+
+  /* Configure the NVIC Preemption Priority Bits */  
+  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
+
+  /* Configure the SysTick handler priority */
+  NVIC_SystemHandlerPriorityConfig(SystemHandler_SysTick, 0, 0);
+}
+
+// ****************************************************************************
+// PIO
 // This is pretty much common code to all STM32 devices.
 // todo: Needs updates to support different processor lines.
-#ifdef STM32_USE_PIO
-static GPIO_TypeDef * const pio_port[] = { GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG };
-static const u8 pio_port_pins[]        = { 16,    16,    16,    16,    16,    16,    16     };  // Update to reality later
-static const u32 pio_port_clk[]        = { RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB, RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE, RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG };
+#ifdef STM32_USE_PIO
+static GPIO_TypeDef * const pio_port[] = { GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG };
+static const u32 pio_port_clk[]        = { RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB, RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE, RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG };
 
-#define PIOS_COUNT 112
-#define PIOS_PORT_COUNT 7
-
 static void pios_init()
-{
+{
   GPIO_InitTypeDef GPIO_InitStructure;
   int port;
 
-  for( port = 0; port &lt; PIOS_PORT_COUNT; port++ )
-  {
-    // Enable clock to port.
-    RCC_APB2PeriphClockCmd(pio_port_clk[port], ENABLE);
-  
+  for( port = 0; port &lt; NUM_PIO; port++ )
+  {
+    // Enable clock to port.
+    RCC_APB2PeriphClockCmd(pio_port_clk[port], ENABLE);
+  
     // Default all port pins to input and enable port.
-    GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_All;
-    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
-  
+    GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_All;
+    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
+  
     GPIO_Init(pio_port[port], &amp;GPIO_InitStructure);
   }
 }
 
-int platform_pio_has_port( unsigned port )
-{
-  return port &lt; PIOS_PORT_COUNT;
-}
-
-const char* platform_pio_get_prefix( unsigned port )
-{
-  static char c[ 3 ];
-  
-  sprintf( c, &quot;P%c&quot;, ( char )( port + 'A' ) );
-  return c;
-}
-
-int platform_pio_has_pin( unsigned port, unsigned pin )
-{
-  return pin &lt; pio_port_pins[ port ];
-}
-
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
-  pio_type retval = 1;
-  GPIO_InitTypeDef GPIO_InitStructure;
+  pio_type retval = 1;
+  GPIO_InitTypeDef GPIO_InitStructure;
   GPIO_TypeDef * base = pio_port[ port ];
   
   switch( op )
@@ -288,9 +239,9 @@
       
     case PLATFORM_IO_PORT_DIR_INPUT:
       pinmask = GPIO_Pin_All;      
-    case PLATFORM_IO_PIN_DIR_INPUT:
-      GPIO_InitStructure.GPIO_Pin  = pinmask;
-      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
+    case PLATFORM_IO_PIN_DIR_INPUT:
+      GPIO_InitStructure.GPIO_Pin  = pinmask;
+      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     
       GPIO_Init(base, &amp;GPIO_InitStructure);
       break;
@@ -298,14 +249,14 @@
     case PLATFORM_IO_PORT_DIR_OUTPUT:      
       pinmask = GPIO_Pin_All;
     case PLATFORM_IO_PIN_DIR_OUTPUT:
-      GPIO_InitStructure.GPIO_Pin   = pinmask;
-      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
-      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
-    
+      GPIO_InitStructure.GPIO_Pin   = pinmask;
+      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
+      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+    
       GPIO_Init(base, &amp;GPIO_InitStructure);
       break;      
             
-    case PLATFORM_IO_PORT_GET_VALUE:
+    case PLATFORM_IO_PORT_GET_VALUE:
       retval = GPIO_ReadInputData(base);
       break;
       
@@ -314,23 +265,23 @@
       break;
       
     case PLATFORM_IO_PIN_PULLUP:
-      GPIO_InitStructure.GPIO_Pin   = pinmask;
-      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
-    
-      GPIO_Init(base, &amp;GPIO_InitStructure);
-      break;
-    
+      GPIO_InitStructure.GPIO_Pin   = pinmask;
+      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPU;
+    
+      GPIO_Init(base, &amp;GPIO_InitStructure);
+      break;
+    
     case PLATFORM_IO_PIN_PULLDOWN:
-      GPIO_InitStructure.GPIO_Pin   = pinmask;
-      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPD;
-    
+      GPIO_InitStructure.GPIO_Pin   = pinmask;
+      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IPD;
+    
       GPIO_Init(base, &amp;GPIO_InitStructure);
       break;
       
     case PLATFORM_IO_PIN_NOPULL:
-      GPIO_InitStructure.GPIO_Pin   = pinmask;
-      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;
-    
+      GPIO_InitStructure.GPIO_Pin   = pinmask;
+      GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN_FLOATING;
+    
       GPIO_Init(base, &amp;GPIO_InitStructure);
       break;
       
@@ -340,12 +291,12 @@
   }
   return retval;
 }
-#endif
-
+#endif
+
 #ifdef STM32_USE_SPI
 // ****************************************************************************
-// SPI
-// TODO: Just about everything.
+// SPI
+// TODO: Just about everything.
 
 static const u32 spi_base[] = { SSI0_BASE, SSI1_BASE };
 static const u32 spi_sysctl[] = { SYSCTL_PERIPH_SSI0, SYSCTL_PERIPH_SSI1 };
@@ -405,253 +356,202 @@
   id = id;
   is_select = is_select;
 }
-#endif
-
+#endif
+
 #ifdef STM32_USE_USART
 // ****************************************************************************
-// UART
-// TODO: Support timeouts.
+// UART
+// TODO: Support timeouts.
 
-// Different configurations for different processors
-#if ELUA_CPU == STM32F103ZE
-  #define UARTS_COUNT 4 // Ignore UART5 because it spans 2 GPIO ports.
-#else
-#  error &quot;CPU type unknown!&quot;
-#endif
-
 // All possible STM32 uarts defs
-static USART_TypeDef * usart[] =          { USART1, USART2, USART3, UART4 };
-static GPIO_TypeDef * usart_gpio_port[] = { GPIOA, GPIOA, GPIOB, GPIOC };
-static const u16 usart_gpio_tx_pin[] = { GPIO_Pin_9, GPIO_Pin_2, GPIO_Pin_10, GPIO_Pin_10 };
+static USART_TypeDef * usart[] =          { USART1, USART2, USART3, UART4 };
+static GPIO_TypeDef * usart_gpio_port[] = { GPIOA, GPIOA, GPIOB, GPIOC };
+static const u16 usart_gpio_tx_pin[] = { GPIO_Pin_9, GPIO_Pin_2, GPIO_Pin_10, GPIO_Pin_10 };
 static const u16 usart_gpio_rx_pin[] = { GPIO_Pin_10, GPIO_Pin_3, GPIO_Pin_11, GPIO_Pin_11 };
 //static const u32 uart_sysctl[] = { SYSCTL_PERIPH_UART0, SYSCTL_PERIPH_UART1, SYSCTL_PERIPH_UART2 };
 //static const u32 uart_gpio_base[] = { _BASE, GPIO_PORTD_BASE, GPIO_PORTG_BASE };
 //static const u8 uart_gpio_pins[] = { GPIO_PIN_0 | GPIO_PIN_1, GPIO_PIN_2 | GPIO_PIN_3, GPIO_PIN_0 | GPIO_PIN_1 };
-
-static void usart_init(u32 id, USART_InitTypeDef * initVals)
-{
-  /* Configure USART IO */
-  GPIO_InitTypeDef GPIO_InitStructure;
-
-  /* Configure USART Tx Pin as alternate function push-pull */
-  GPIO_InitStructure.GPIO_Pin = usart_gpio_tx_pin[id];
-  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
-  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
-  GPIO_Init(usart_gpio_port[id], &amp;GPIO_InitStructure);
-
-  /* Configure USART Rx Pin as input floating */
-  GPIO_InitStructure.GPIO_Pin = usart_gpio_rx_pin[id];
-  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
-  GPIO_Init(usart_gpio_port[id], &amp;GPIO_InitStructure);
-
-  /* Configure USART */
-  USART_Init(usart[id], initVals);
-  
-  /* Enable USART1 Receive and Transmit interrupts */
-  //USART_ITConfig(usart[id], USART_IT_RXNE, ENABLE);
-  //USART_ITConfig(usart[id], USART_IT_TXE, ENABLE);
-
-  /* Enable the USART1 */
-  USART_Cmd(usart[id], ENABLE);
-}
 
-static void uarts_init()
+static void usart_init(u32 id, USART_InitTypeDef * initVals)
 {
-  USART_InitTypeDef USART_InitStructure;
-
-  // Enable clocks.
-  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
-  
-  // Configure the U(S)ART for 115,200, 8-N-1 operation.
-
-  USART_InitStructure.USART_BaudRate = 115200;
-  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
-  USART_InitStructure.USART_StopBits = USART_StopBits_1;
-  USART_InitStructure.USART_Parity = USART_Parity_No;
-  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
-  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
-
-  usart_init(CONSOLE, &amp;USART_InitStructure);
+  /* Configure USART IO */
+  GPIO_InitTypeDef GPIO_InitStructure;
+
+  /* Configure USART Tx Pin as alternate function push-pull */
+  GPIO_InitStructure.GPIO_Pin = usart_gpio_tx_pin[id];
+  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
+  GPIO_Init(usart_gpio_port[id], &amp;GPIO_InitStructure);
+
+  /* Configure USART Rx Pin as input floating */
+  GPIO_InitStructure.GPIO_Pin = usart_gpio_rx_pin[id];
+  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
+  GPIO_Init(usart_gpio_port[id], &amp;GPIO_InitStructure);
+
+  /* Configure USART */
+  USART_Init(usart[id], initVals);
+  
+  /* Enable USART1 Receive and Transmit interrupts */
+  //USART_ITConfig(usart[id], USART_IT_RXNE, ENABLE);
+  //USART_ITConfig(usart[id], USART_IT_TXE, ENABLE);
+
+  /* Enable the USART1 */
+  USART_Cmd(usart[id], ENABLE);
 }
 
-int platform_uart_exists( unsigned id )
+static void uarts_init()
 {
-  return id &lt; UARTS_COUNT;
+  USART_InitTypeDef USART_InitStructure;
+
+  // Enable clocks.
+  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
+  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
+  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
+  RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
+  
+  // Configure the U(S)ART for 115,200, 8-N-1 operation.
+
+  USART_InitStructure.USART_BaudRate = CON_UART_SPEED;
+  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
+  USART_InitStructure.USART_StopBits = USART_StopBits_1;
+  USART_InitStructure.USART_Parity = USART_Parity_No;
+  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
+  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
+
+  usart_init(CON_UART_ID, &amp;USART_InitStructure);
 }
 
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
-  USART_InitTypeDef USART_InitStructure;
-
-  USART_InitStructure.USART_BaudRate = baud;
-  
-  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
-  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
+  USART_InitTypeDef USART_InitStructure;
+
+  USART_InitStructure.USART_BaudRate = baud;
+  
+  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
+  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
     
   switch( databits )
   {
     case 5:
-    case 6:
-    case 7:
-    case 8:
-      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
-      break;
-    case 9:
-      USART_InitStructure.USART_WordLength = USART_WordLength_9b;
-      break;
-    default:
+    case 6:
+    case 7:
+    case 8:
       USART_InitStructure.USART_WordLength = USART_WordLength_8b;
       break;
-  }
-
-  switch (stopbits)
-  {
-    case PLATFORM_UART_STOPBITS_1:
-      USART_InitStructure.USART_StopBits = USART_StopBits_1;
-      break;
-    case PLATFORM_UART_STOPBITS_2:
-      USART_InitStructure.USART_StopBits = USART_StopBits_2;
-      break;
-    default:
-      USART_InitStructure.USART_StopBits = USART_StopBits_2;
-      break;
+    case 9:
+      USART_InitStructure.USART_WordLength = USART_WordLength_9b;
+      break;
+    default:
+      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
+      break;
+  }
+
+  switch (stopbits)
+  {
+    case PLATFORM_UART_STOPBITS_1:
+      USART_InitStructure.USART_StopBits = USART_StopBits_1;
+      break;
+    case PLATFORM_UART_STOPBITS_2:
+      USART_InitStructure.USART_StopBits = USART_StopBits_2;
+      break;
+    default:
+      USART_InitStructure.USART_StopBits = USART_StopBits_2;
+      break;
   }    
-
-  switch (parity)
-  {
-    case PLATFORM_UART_PARITY_EVEN:
-      USART_InitStructure.USART_Parity = USART_Parity_Even;
-      break;
-    case PLATFORM_UART_PARITY_ODD:
-      USART_InitStructure.USART_Parity = USART_Parity_Odd;
-      break;
-    default:
-      USART_InitStructure.USART_Parity = USART_Parity_No;
-      break;
+
+  switch (parity)
+  {
+    case PLATFORM_UART_PARITY_EVEN:
+      USART_InitStructure.USART_Parity = USART_Parity_Even;
+      break;
+    case PLATFORM_UART_PARITY_ODD:
+      USART_InitStructure.USART_Parity = USART_Parity_Odd;
+      break;
+    default:
+      USART_InitStructure.USART_Parity = USART_Parity_No;
+      break;
   }
-  
-  usart_init(id, &amp;USART_InitStructure);
   
+  usart_init(id, &amp;USART_InitStructure);
+  
   return TRUE;
 }
 
 void platform_uart_send( unsigned id, u8 data )
-{
-  while(USART_GetFlagStatus(usart[id], USART_FLAG_TXE) == RESET)
-  {
+{
+  while(USART_GetFlagStatus(usart[id], USART_FLAG_TXE) == RESET)
+  {
   }
   USART_SendData(usart[id], data);
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
-  timer_data_type tmr_start, tmr_crt;
-  int res;
-  
   if( timeout == 0 )
-  {
-    while(USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET)
-    {
-    }
-//    if (USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET)
-//    {
-//      return -1;
-//    }
-    return USART_ReceiveData(usart[id]);  
-  }
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
   {
-    // Receive char blocking
-    while(USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET)
-    {
-    }
-    return USART_ReceiveData(usart[id]);  
+    if (USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET)
+      return -1;
+    else
+      return USART_ReceiveData(usart[id]);  
   }
-  else
-  {
-    // Receive char blocking
-    while(USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET)
-    {
-    }
-    return USART_ReceiveData(usart[id]);    
-#if 0
-    // Receive char with the specified timeout
-    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START, 0 );
-    while( 1 )
-    {
-      if( ( res = UARTCharGetNonBlocking( base ) ) &gt;= 0 )
-        break;
-      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
-      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
-        break;
-    }
-    return res;
-#endif
-  }
+  // Receive char blocking
+  while(USART_GetFlagStatus(usart[id], USART_FLAG_RXNE) == RESET);
+  return USART_ReceiveData(usart[id]);  
 }
-#endif
-
+#endif
+
 #ifdef STM32_USE_TIMERS
 // ****************************************************************************
 // Timers
 // Same on LM3S8962 and LM3S6965
 
-// All possible LM3S timers defs
+// All possible LM3S timers defs
 static TIM_TypeDef * timer[] = { TIM2, TIM3, TIM4, TIM5};
-#define TIMERS_COUNT			4
 
 static void timers_init()
-{
+{
 #if 0
   unsigned i;
 
-  for( i = 0; i &lt; TIMERS_COUNT; i ++ )
+  for( i = 0; i &lt; NUM_TIMER; i ++ )
   {
 	SysCtlPeripheralEnable(timer_sysctl[ i ]);
     TimerConfigure(timer_base[ i ], TIMER_CFG_32_BIT_PER);
     TimerEnable(timer_base[ i ], TIMER_A);
-  }
+  }
 #endif
 }
-
-static u32 platform_timer_get_clock(unsigned id)
-{
-  RCC_ClocksTypeDef Clocks;
-
-  RCC_GetClocksFreq(&amp;Clocks);
-
-  return Clocks.PCLK1_Frequency / (TIM_GetPrescaler(timer[id]) + 1)
-}
-
-static u32 platform_timer_set_clock(unsigned id, u32 clock)
-{
-  RCC_ClocksTypeDef Clocks;
-  u32 pclk, clkdiv;
-  u64 tmp;
-
-  RCC_GetClocksFreq(&amp;Clocks);
-
-  pclk   = Clocks.PCLK1_Frequency; // Get peripheral bus clock frequency.
-  tmp    = ((u64)pclk &lt;&lt; 16) / clock; // Convert to u32.16 fixed point and calculate prescaler divisor
-  clkdiv = ((tmp &amp; 0x8000) ? (tmp + 0x10000) : tmp) &gt;&gt; 16;  // Round up or down and convert back to u32.0
-  if (clkdiv &gt; 0x10000)  // Saturate to u16 (+1 for a clkdiv value of 1 is a reg value of 0)
-      clkdiv = 0x10000;
-  
-  TIM_PrescalerConfig(timer[id], clkdiv - 1, TIM_PSCReloadMode_Immediate); // Update timer prescaler immediately
-  
-  return pclk / clkdiv; // Return actual clock rate used.
-}
 
-int platform_timer_exists( unsigned id )
+static u32 platform_timer_get_clock(unsigned id)
 {
-  return id &lt; TIMERS_COUNT;
+  RCC_ClocksTypeDef Clocks;
+
+  RCC_GetClocksFreq(&amp;Clocks);
+
+  return Clocks.PCLK1_Frequency / (TIM_GetPrescaler(timer[id]) + 1)
 }
 
-void platform_timer_delay( unsigned id, u32 delay_us )
+static u32 platform_timer_set_clock(unsigned id, u32 clock)
 {
+  RCC_ClocksTypeDef Clocks;
+  u32 pclk, clkdiv;
+  u64 tmp;
+
+  RCC_GetClocksFreq(&amp;Clocks);
+
+  pclk   = Clocks.PCLK1_Frequency; // Get peripheral bus clock frequency.
+  tmp    = ((u64)pclk &lt;&lt; 16) / clock; // Convert to u32.16 fixed point and calculate prescaler divisor
+  clkdiv = ((tmp &amp; 0x8000) ? (tmp + 0x10000) : tmp) &gt;&gt; 16;  // Round up or down and convert back to u32.0
+  if (clkdiv &gt; 0x10000)  // Saturate to u16 (+1 for a clkdiv value of 1 is a reg value of 0)
+      clkdiv = 0x10000;
+  
+  TIM_PrescalerConfig(timer[id], clkdiv - 1, TIM_PSCReloadMode_Immediate); // Update timer prescaler immediately
+  
+  return pclk / clkdiv; // Return actual clock rate used.
+}
+
+void platform_s_timer_delay( unsigned id, u32 delay_us )
+{
   timer_data_type final;
   u32 base = timer_base[ id ];
   
@@ -660,7 +560,7 @@
   while( TimerValueGet( base, TIMER_A ) &gt; final );
 }
       
-u32 platform_timer_op( unsigned id, int op, u32 data )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   u32 base = timer_base[ id ]; 
@@ -693,22 +593,13 @@
   }
   return res;
 }
-
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
+#else
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
-  timer_data_type temp;
-  
-  id = id;
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / SysCtlClockGet();
+  return 0;
 }
-#endif
-
+#endif
+
 #ifdef STM32_USE_PWM
 // ****************************************************************************
 // PWMs
@@ -810,7 +701,7 @@
   
   return res;
 }
-#endif
+#endif
 
 // *****************************************************************************
 // CPU specific functions
@@ -825,33 +716,33 @@
   //IntMasterDisable();
 }
 
-u32 platform_cpu_get_frequency()
-{
-  RCC_ClocksTypeDef clocks;
-
-  RCC_GetClocksFreq(&amp;clocks);
-
+u32 platform_s_cpu_get_frequency()
+{
+  RCC_ClocksTypeDef clocks;
+
+  RCC_GetClocksFreq(&amp;clocks);
+
   return clocks.HCLK_Frequency;
 }
-
-u32 platform_pclk1_get_frequency()
-{
-  RCC_ClocksTypeDef clocks;
-
-  RCC_GetClocksFreq(&amp;clocks);
-
-  return clocks.PCLK1_Frequency;
-}
 
-u32 platform_pclk2_get_frequency()
-{
-  RCC_ClocksTypeDef clocks;
-
-  RCC_GetClocksFreq(&amp;clocks);
-
-  return clocks.PCLK2_Frequency;
-}
-
+u32 platform_pclk1_get_frequency()
+{
+  RCC_ClocksTypeDef clocks;
+
+  RCC_GetClocksFreq(&amp;clocks);
+
+  return clocks.PCLK1_Frequency;
+}
+
+u32 platform_pclk2_get_frequency()
+{
+  RCC_ClocksTypeDef clocks;
+
+  RCC_GetClocksFreq(&amp;clocks);
+
+  return clocks.PCLK2_Frequency;
+}
+
 // ****************************************************************************
 // Ethernet functions
 
@@ -956,7 +847,7 @@
   else
     return 0;
 }
-
+
 #if 0
 void SysTickHandler(void)
 {
@@ -967,7 +858,7 @@
   // of incrementing the timers and taking the appropriate actions.
   platform_eth_force_interrupt();
 }
-#endif
+#endif
 
 void EthernetIntHandler()
 {
@@ -982,31 +873,14 @@
 }
 
 #else  // #ifdef ELUA_UIP
-
+
 #if 0
 void SysTickHandler()
 {
 }
-#endif
+#endif
 
 void EthernetIntHandler()
 {
 }
 #endif // #ifdef ELUA_UIP
-
-// ****************************************************************************
-// Allocator support
-
-extern char end[];
-
-void* platform_get_first_free_ram( unsigned id )
-{
-  return id &gt; 0 ?  NULL : ( void* )end;
-}
-
-#define STACK_SIZE 256
-#define SRAM_SIZE ( 64 * 1024 )
-void* platform_get_last_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )( SRAM_BASE + SRAM_SIZE - STACK_SIZE - 1 );
-}

Modified: trunk/src/platform/stm32/platform_conf.h
===================================================================
--- trunk/src/platform/stm32/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,7 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;type.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -16,19 +17,19 @@
 //#define BUILD_DHCPC
 //#define BUILD_DNS
 #define BUILD_CON_GENERIC
-//#define BUILD_CON_TCP
+//#define BUILD_CON_TCP
 #define EXTENDED_PLATFORM_DATA
 
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define XMODEM_UART_ID        0
+#define CON_UART_ID           0
+#define CON_UART_SPEED        115200
 #define XMODEM_TIMER_ID       0
-#define TERM_UART_ID          0
 #define TERM_TIMER_ID         0
 #define TERM_LINES            25
 #define TERM_COLS             80
-#define TERM_TIMEOUT          0
+#define TERM_TIMEOUT          100000
 
 // *****************************************************************************
 // Auxiliary libraries that will be compiled for this platform
@@ -46,44 +47,77 @@
   { AUXLIB_NET, luaopen_net },\
   { AUXLIB_CPU, luaopen_cpu },\
   { LUA_MATHLIBNAME, luaopen_math }
-#else
-#define LUA_PLATFORM_LIBS\
-  { AUXLIB_PIO, luaopen_pio },\
-  { AUXLIB_PD, luaopen_pd },\
-  { AUXLIB_UART, luaopen_uart },\
-  { AUXLIB_TERM, luaopen_term },\
-  { AUXLIB_PACK, luaopen_pack },\
-  { AUXLIB_BIT, luaopen_bit },\
-  { AUXLIB_CPU, luaopen_cpu },\
-  { AUXLIB_MOD, luaopen_mod },\
-  { LUA_MATHLIBNAME, luaopen_math }
-#endif
+#else
+#define LUA_PLATFORM_LIBS\
+  { AUXLIB_PIO, luaopen_pio },\
+  { AUXLIB_PD, luaopen_pd },\
+  { AUXLIB_UART, luaopen_uart },\
+  { AUXLIB_TERM, luaopen_term },\
+  { AUXLIB_PACK, luaopen_pack },\
+  { AUXLIB_BIT, luaopen_bit },\
+  { AUXLIB_CPU, luaopen_cpu },\
+  { AUXLIB_MOD, luaopen_mod },\
+  { LUA_MATHLIBNAME, luaopen_math }
+#endif
 
 // *****************************************************************************
 // Configuration data
 
 // Static TCP/IP configuration
-#define ELUA_CONF_IPADDR0         192
-#define ELUA_CONF_IPADDR1         168
-#define ELUA_CONF_IPADDR2         1
-#define ELUA_CONF_IPADDR3         13
+#define ELUA_CONF_IPADDR0     192
+#define ELUA_CONF_IPADDR1     168
+#define ELUA_CONF_IPADDR2     1
+#define ELUA_CONF_IPADDR3     13
 
-#define ELUA_CONF_NETMASK0        255
-#define ELUA_CONF_NETMASK1        255
-#define ELUA_CONF_NETMASK2        255
-#define ELUA_CONF_NETMASK3        0
+#define ELUA_CONF_NETMASK0    255
+#define ELUA_CONF_NETMASK1    255
+#define ELUA_CONF_NETMASK2    255
+#define ELUA_CONF_NETMASK3    0
 
-#define ELUA_CONF_DEFGW0          192
-#define ELUA_CONF_DEFGW1          168
-#define ELUA_CONF_DEFGW2          1
-#define ELUA_CONF_DEFGW3          1
+#define ELUA_CONF_DEFGW0      192
+#define ELUA_CONF_DEFGW1      168
+#define ELUA_CONF_DEFGW2      1
+#define ELUA_CONF_DEFGW3      1
 
-#define ELUA_CONF_DNS0            192
-#define ELUA_CONF_DNS1            168
-#define ELUA_CONF_DNS2            1
-#define ELUA_CONF_DNS3            1
+#define ELUA_CONF_DNS0        192
+#define ELUA_CONF_DNS1        168
+#define ELUA_CONF_DNS2        1
+#define ELUA_CONF_DNS3        1
 
 // *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       0
+#define VTMR_FREQ_HZ          4
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               7
+#define NUM_SPI               0
+#define NUM_UART              4
+#define NUM_TIMER             0
+#define NUM_PWM               0
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+u32 platform_s_cpu_get_frequency();
+#define CPU_FREQUENCY         platform_s_cpu_get_frequency()
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            'A'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PIN_ARRAY         { 16, 16, 16, 16, 16, 16, 16 }
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define STACK_SIZE            256
+#define SRAM_SIZE             ( 64 * 1024 )
+#define MEM_START_ADDRESS     { ( void* )end }
+#define MEM_END_ADDRESS       { ( void* )( SRAM_BASE + SRAM_SIZE - STACK_SIZE - 1 ) }
+
+// *****************************************************************************
 // CPU constants that should be exposed to the eLua &quot;cpu&quot; module
 
 #include &quot;stm32f10x_gpio.h&quot;

Modified: trunk/src/platform/stm32/type.h
===================================================================
--- trunk/src/platform/stm32/type.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/stm32/type.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -20,4 +20,7 @@
 typedef unsigned long  DWORD;
 typedef unsigned int   BOOL;
 
+typedef unsigned long long u64;
+typedef signed long long s64;
+
 #endif

Modified: trunk/src/platform/str7/platform.c
===================================================================
--- trunk/src/platform/str7/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/str7/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -11,26 +11,12 @@
 #include &lt;ctype.h&gt;
 #include &lt;stdio.h&gt;
 #include &quot;utils.h&quot;
+#include &quot;common.h&quot;
+#include &quot;platform_conf.h&quot;
 
 // Platform includes
 #include &quot;71x_lib.h&quot;
 
-#define CON_UART      1
-
-// *****************************************************************************
-// std functions
-
-static void uart_send( int fd, char c )
-{
-  fd = fd;
-  platform_uart_send( CON_UART, c );
-}
-
-static int uart_recv()
-{
-  return platform_uart_recv( CON_UART, 0, PLATFORM_UART_INFINITE_TIMEOUT );
-}
-
 // ****************************************************************************
 // Platform initialization
 
@@ -64,43 +50,21 @@
   clock_init();
   
   // Setup UART1 for operation
-  platform_uart_setup( CON_UART, 38400, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
+  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
   
   // Initialize Timer 0 for XMODEM
   platform_timer_op( 0, PLATFORM_TIMER_OP_SET_CLOCK, 39000 ); 
   
-  // Set the send/recv functions                          
-  std_set_send_func( uart_send );
-  std_set_get_func( uart_recv );
-    
+  cmn_platform_init();
+      
   return PLATFORM_OK;
 } 
 
 // ****************************************************************************
 // PIO functions
 
-#define NUM_PORTS   2
+static const GPIO_TypeDef *gpio_periph[ NUM_PIO ] = { GPIO0, GPIO1 };
 
-static const GPIO_TypeDef *gpio_periph[ NUM_PORTS ] = { GPIO0, GPIO1 };
-
-int platform_pio_has_port( unsigned port )
-{
-  return port &lt; 2;
-}
-
-const char* platform_pio_get_prefix( unsigned port )
-{
-  static char c[ 3 ];
-  
-  sprintf( c, &quot;P%d&quot;, port );
-  return c;
-}
-
-int platform_pio_has_pin( unsigned port, unsigned pin )
-{
-  return port &lt; 2 &amp;&amp; pin &lt; 16;
-}
-
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
   GPIO_TypeDef* base = ( GPIO_TypeDef* )gpio_periph[ port ];
@@ -150,17 +114,10 @@
 // ****************************************************************************
 // UART
 
-#define NUM_UARTS   4
+static const u16 uart_rx_pins[ NUM_UART ] = { 0x0001 &lt;&lt; 8, 0x0001 &lt;&lt; 10, 0x0001 &lt;&lt; 13, 0x0001 &lt;&lt; 1 };
+static const u16 uart_tx_pins[ NUM_UART ] = { 0x0001 &lt;&lt; 9, 0x0001 &lt;&lt; 11, 0x0001 &lt;&lt; 14, 0x0001 &lt;&lt; 0 };
+static const UART_TypeDef *uart_periph[ NUM_UART ] = { UART0, UART1, UART2, UART3 };
 
-static const u16 uart_rx_pins[ NUM_UARTS ] = { 0x0001 &lt;&lt; 8, 0x0001 &lt;&lt; 10, 0x0001 &lt;&lt; 13, 0x0001 &lt;&lt; 1 };
-static const u16 uart_tx_pins[ NUM_UARTS ] = { 0x0001 &lt;&lt; 9, 0x0001 &lt;&lt; 11, 0x0001 &lt;&lt; 14, 0x0001 &lt;&lt; 0 };
-static const UART_TypeDef *uart_periph[ NUM_UARTS ] = { UART0, UART1, UART2, UART3 };
-
-int platform_uart_exists( unsigned id )
-{
-  return id &lt; NUM_UARTS;
-}
-
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {      
   UART_TypeDef* pport = ( UART_TypeDef* )uart_periph[ id ];
@@ -223,10 +180,8 @@
   UART_ByteSend( pport, &amp;data );
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
-  timer_data_type tmr_start, tmr_crt;
-  int res;
   UART_TypeDef* pport = ( UART_TypeDef* )uart_periph[ id ];    
   
   if( timeout == 0 )
@@ -237,30 +192,7 @@
     else
       return -1;
   }
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-  {
-    // Wait for dataa
-    return UART_ByteReceive( pport );
-  }
-  else
-  {
-    // Receive char with the specified timeout
-    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START,0 );
-    while( 1 )
-    {
-      if( UART_FlagStatus( pport ) &amp; UART_RxBufNotEmpty  )
-      {
-        res = UART_ByteReceive( pport );
-        break;
-      }
-      else
-        res = -1;
-      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
-      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
-        break;
-    }
-    return res;    
-  }
+  return UART_ByteReceive( pport );
 }
 
 // ****************************************************************************
@@ -268,13 +200,8 @@
 
 #define NUM_TIMERS      4
             
-static const TIM_TypeDef *tim_periph[ NUM_TIMERS ] = { TIM0, TIM1, TIM2, TIM3 };
+static const TIM_TypeDef *tim_periph[ NUM_TIMER ] = { TIM0, TIM1, TIM2, TIM3 };
 
-int platform_timer_exists( unsigned id )
-{
-  return id &lt; NUM_TIMERS;
-}
-
 // Helper: get timer clock
 static u32 platform_timer_get_clock( unsigned id )
 {
@@ -300,7 +227,7 @@
   return baseclk / bestdiv;
 }
 
-void platform_timer_delay( unsigned id, u32 delay_us )
+void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
   TIM_TypeDef* ptimer = ( TIM_TypeDef* )tim_periph[ id ];  
   u32 freq;
@@ -321,7 +248,7 @@
   while( TIM_CounterValue( ptimer ) &lt; final );  
 }
       
-u32 platform_timer_op( unsigned id, int op, u32 data )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   TIM_TypeDef* ptimer = ( TIM_TypeDef* )tim_periph[ id ];  
@@ -362,34 +289,12 @@
   return res;
 }
 
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
-{
-  timer_data_type temp;
-  u32 freq;
-    
-  freq = platform_timer_get_clock( id );
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / freq;
-}
-
 // ****************************************************************************
 // PWM functions
 
-#define PLATFORM_NUM_PWMS               3
-
-static const u16 pwm_pins[ PLATFORM_NUM_PWMS ] = { 1 &lt;&lt; 7, 1 &lt;&lt; 13, 1 &lt;&lt; 2 };
-static const u8 pwm_ports[ PLATFORM_NUM_PWMS ] = { 1, 0, 1 };
+static const u16 pwm_pins[ NUM_PWM ] = { 1 &lt;&lt; 7, 1 &lt;&lt; 13, 1 &lt;&lt; 2 };
+static const u8 pwm_ports[ NUM_PWM ] = { 1, 0, 1 };
  
-int platform_pwm_exists( unsigned id )
-{
-  return id &lt; PLATFORM_NUM_PWMS; 
-}
-
 u32 platform_pwm_setup( unsigned id, u32 frequency, unsigned duty )
 {
   u32 pwmclk = platform_timer_get_clock( id + 1 );
@@ -436,21 +341,3 @@
   
   return res;
 }
-
-// ****************************************************************************
-// Allocator support
-
-extern char end[];
-
-void* platform_get_first_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )end;
-}
-
-#define SRAM_ORIGIN 0x20000000
-#define SRAM_SIZE 0x10000
-
-void* platform_get_last_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 );
-}

Modified: trunk/src/platform/str7/platform_conf.h
===================================================================
--- trunk/src/platform/str7/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/str7/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,7 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;stacks.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -17,9 +18,9 @@
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define XMODEM_UART_ID        1
+#define CON_UART_ID           1
+#define CON_UART_SPEED        38400
 #define XMODEM_TIMER_ID       0
-#define TERM_UART_ID          1
 #define TERM_TIMER_ID         0
 #define TERM_LINES            25
 #define TERM_COLS             80
@@ -38,5 +39,37 @@
   { AUXLIB_PACK, luaopen_pack },\
   { AUXLIB_BIT, luaopen_bit },\
   { LUA_MATHLIBNAME, luaopen_math }    
-  
+
+// *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       0
+#define VTMR_FREQ_HZ          4
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               2
+#define NUM_SPI               0
+#define NUM_UART              4
+#define NUM_TIMER             4
+#define NUM_PWM               3
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+#define CPU_FREQUENCY         0
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            '0'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PINS_PER_PORT     16
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define SRAM_ORIGIN           0x20000000
+#define SRAM_SIZE             0x10000
+#define MEM_START_ADDRESS     { ( void* )end }
+#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }  
+
 #endif // #ifndef __PLATFORM_CONF_H__

Deleted: trunk/src/platform/str9/main.c
===================================================================
--- trunk/src/platform/str9/main.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/str9/main.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -1,239 +0,0 @@
-/********************************************************************
- * Project:    STR9-comStick GNU (UART)
- * File:       main.c
- *
- * System:     ARM9TDMI 32 Bit (STR912FW44X)
- * Compiler:   GCC 4.0.3
- *
- * Date:       2006-12-20
- * Author:     <A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">Applications at Hitex.de</A>
- *
- * Rights:     Hitex Development Tools GmbH
- *             Greschbachstr. 12
- *             D-76229 Karlsruhe
- ********************************************************************
- * Description:
- *
- * This file is part of the GNU Example chain
- * The code is bassed on usage of the STmicro library functions
- * This is a small implementation of UART1 feature echoing external input
- * The application runs in ARM mode with high optimization level.
- *
- ********************************************************************
- * History:
- *
- *    Revision 1.0    2006/12/20      Gn
- *    Initial revision
- ********************************************************************
- * This is a preliminary version.
- *
- * WARRANTY:  HITEX warrants that the media on which the SOFTWARE is
- * furnished is free from defects in materials and workmanship under
- * normal use and service for a period of ninety (90) days. HITEX entire
- * liability and your exclusive remedy shall be the replacement of the
- * SOFTWARE if the media is defective. This Warranty is void if failure
- * of the media resulted from unauthorized modification, accident, abuse,
- * or misapplication.
- *
- * DISCLAIMER:  OTHER THAN THE ABOVE WARRANTY, THE SOFTWARE IS FURNISHED
- * &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND. HITEX DISCLAIMS ALL OTHER WARRANTIES,
- * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * NEITHER HITEX NOR ITS AFFILIATES SHALL BE LIABLE FOR ANY DAMAGES ARISING
- * OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE, INCLUDING DAMAGES FOR
- * LOSS OF PROFITS, BUSINESS INTERRUPTION, OR ANY SPECIAL, INCIDENTAL, INDIRECT
- * OR CONSEQUENTIAL DAMAGES EVEN IF HITEX HAS BEEN ADVISED OF THE POSSIBILITY
- * OF SUCH DAMAGES.
- ********************************************************************/
-
-#include &quot;defines.h&quot;
-
-#define global extern   /* to declare external variables and functions      */
-#include &quot;91x_lib.h&quot;
-
-#include &quot;main.h&quot;
-#define GPIO_Alt1 0x01
-
-#define TxBufferSize   (countof(TxBuffer) - 1)
-#define RxBufferSize   0xFF
-
-/* Private macro -------------------------------------------------------------*/
-#define countof(a)   (sizeof(a) / sizeof(*(a)))
-
-/* Private variables ---------------------------------------------------------*/
-   UART_InitTypeDef UART_InitStructure;
-   u8 TxBuffer[] = &quot;UART1 - <A HREF="https://lists.berlios.de/mailman/listinfo/elua-svn">1,8,N,1 at 115.2k</A> communication without flow control\n\r&quot;;
-   u8 RxBuffer[RxBufferSize];
-   u8 NbrOfDataToTransfer = TxBufferSize;
-   u8 TxCounter = 0;
-   u8 RxCounter = 0;
-
-   GPIO_InitTypeDef  GPIO_InitStructure;
-   TIM_InitTypeDef   TIM_InitStructure;
-
-/* Private function prototypes -----------------------------------------------*/
-   void SCU_Configuration(void);
-   void GPIO_Configuration(void);
-   void UART1_Configuration(void);
-   static void Delay(u32 nCount);
-
-int main (void)
-{
-
-   /* Configure the system clocks */
-   SCU_Configuration();
-   /* Configure the GPIOs */
-   GPIO_Configuration();
-   /* Configure and start the UART1 */
-   UART1_Configuration();
-
-   /* endless loop */
-   while (1)
-   {
-      {
-         if((UART_GetFlagStatus(UART1, UART_FLAG_RxFIFOEmpty) != SET)&amp;&amp;(RxCounter &lt; RxBufferSize))
-            {
-            RxBuffer[0] = UART1-&gt;DR;
-            UART_SendData(UART1, RxBuffer[0]);
-            }
-      }
-
-      /* Turn OFF leds connected to P9.0, P9.1 pins */
-      GPIO_WriteBit(GPIO8, GPIO_Pin_0, Bit_SET);
-
-      /* Insert delay */
-      Delay(0x1FFFF);
-
-      /* Turn ON leds connected to P9.0, P9.1 pins */
-      GPIO_WriteBit(GPIO8, GPIO_Pin_0, Bit_RESET);
-
-      /* Insert delay */
-      Delay(0x1FFFF);
-   }
-}
-
-void SCU_Configuration(void)
-{
-   SCU_MCLKSourceConfig(SCU_MCLK_OSC);
-
-   SCU_PLLFactorsConfig(192,25,2);            /* PLL = 96 MHz */
-   SCU_PLLCmd(ENABLE);                        /* PLL Enabled  */
-
-   SCU_MCLKSourceConfig(SCU_MCLK_PLL);        /* MCLK = PLL   */
-
-   FMI_BankRemapConfig(4, 2, 0, 0x80000); /* Set Flash banks size &amp; address */
-   FMI_Config(FMI_READ_WAIT_STATE_2, FMI_WRITE_WAIT_STATE_0, FMI_PWD_ENABLE,\
-             FMI_LVD_ENABLE, FMI_FREQ_HIGH); /* FMI Waite States */
-
-   /* Enable VIC clock */
-   SCU_AHBPeriphClockConfig(__VIC, ENABLE);
-   SCU_AHBPeriphReset(__VIC, DISABLE);
-
-   /* Set the PCLK Clock to MCLK/2 */
-   SCU_PCLKDivisorConfig(SCU_PCLK_Div1);
-
-    /* Enable the UART0 Clock */
-   SCU_APBPeriphClockConfig(__UART1, ENABLE);
-
-   /* Enable the clock for TIM0 and TIM1 */
-   SCU_APBPeriphClockConfig(__TIM01, ENABLE);
-   SCU_APBPeriphReset(__TIM01, DISABLE);
-
-   SCU_APBPeriphClockConfig(__TIM23, ENABLE);
-   SCU_APBPeriphReset(__TIM23, DISABLE);
-
-
-/* Enable the GPIO3 Clock */
-   SCU_APBPeriphClockConfig(__GPIO3, ENABLE);
-
-   SCU_APBPeriphClockConfig(__GPIO4, ENABLE);  /* Enable the clock for the GPIO4 */
-
-   /* Enable the __GPIO8 */
-   SCU_APBPeriphClockConfig(__GPIO8 ,ENABLE);
-   /* Enable the __GPIO9 */
-   SCU_APBPeriphClockConfig(__GPIO9 ,ENABLE);
-}
-/* GPIO Configuration --------------------------------------------------------*/
-void GPIO_Configuration(void)
-{
-   GPIO_DeInit(GPIO3);
-   GPIO_DeInit(GPIO4);                         /* GPIO4 Deinitialization */
-   GPIO_DeInit(GPIO9);
-   /* IOs */
-   GPIO_InitStructure.GPIO_Direction = GPIO_PinOutput;
-   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
-   GPIO_InitStructure.GPIO_Type = GPIO_Type_PushPull ;
-   GPIO_Init (GPIO4, &amp;GPIO_InitStructure);
-   /* onboard LED */
-   GPIO_InitStructure.GPIO_Direction = GPIO_PinOutput;
-   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
-   GPIO_InitStructure.GPIO_Type = GPIO_Type_PushPull ;
-   GPIO_Init (GPIO9, &amp;GPIO_InitStructure);
-   GPIO_WriteBit(GPIO9, GPIO_Pin_0, Bit_RESET);
-
-/* configure UART1_Rx pin GPIO3.2*/
-   GPIO_InitStructure.GPIO_Direction = GPIO_PinInput;
-   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
-   GPIO_InitStructure.GPIO_Type = GPIO_Type_PushPull ;
-   GPIO_InitStructure.GPIO_IPConnected = GPIO_IPConnected_Enable;
-   GPIO_InitStructure.GPIO_Alternate = GPIO_InputAlt1  ;
-   GPIO_Init (GPIO3, &amp;GPIO_InitStructure);
-
-   /*Gonfigure UART1_Tx pin GPIO3.3*/
-   GPIO_InitStructure.GPIO_Direction = GPIO_PinInput;
-   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
-   GPIO_InitStructure.GPIO_Type = GPIO_Type_PushPull ;
-   GPIO_InitStructure.GPIO_Alternate = GPIO_OutputAlt2  ;
-   GPIO_Init (GPIO3, &amp;GPIO_InitStructure);
-
-}
-
-/* UART1 configuration -------------------------------------------------------*/
-void UART1_Configuration(void)
-  {
-/* UART1 configured as follow:
-        - Word Length = 8 Bits
-        - One Stop Bit
-        - No parity
-        - BaudRate = 115200 baud
-        - no Hardware flow control enabled (RTS and CTS signals)
-        - Receive and transmit enabled
-        - Receive and transmit FIFOs are enabled
-        - Transmit and Receive FIFOs levels have 8 bytes depth
-  */
-   UART_InitStructure.UART_WordLength = UART_WordLength_8D;
-   UART_InitStructure.UART_StopBits = UART_StopBits_1;
-   UART_InitStructure.UART_Parity = UART_Parity_No ;
-   UART_InitStructure.UART_BaudRate = 115200;
-   UART_InitStructure.UART_HardwareFlowControl = UART_HardwareFlowControl_None;
-   UART_InitStructure.UART_Mode = UART_Mode_Tx_Rx;
-   UART_InitStructure.UART_FIFO = UART_FIFO_Enable;//UART_FIFO_Enable;
-   UART_InitStructure.UART_TxFIFOLevel = UART_FIFOLevel_1_2; /* FIFO size 16 bytes, FIFO level 8 bytes */
-   UART_InitStructure.UART_RxFIFOLevel = UART_FIFOLevel_1_2; /* FIFO size 16 bytes, FIFO level 8 bytes */
-
-   UART_DeInit(UART1);
-   UART_Init(UART1, &amp;UART_InitStructure);
-
-   /* Enable the UART0 */
-   UART_Cmd(UART1, ENABLE);
-
-   while(NbrOfDataToTransfer--)
-   {
-      UART_SendData(UART1, TxBuffer[TxCounter++]);
-      while(UART_GetFlagStatus(UART1, UART_FLAG_TxFIFOFull) != RESET);
-   }
-}
-
-/*******************************************************************************
-* Function Name  : Delay
-* Description    : Inserts a delay time.
-* Input          : nCount: specifies the delay time length.
-*******************************************************************************/
-static void Delay(u32 nCount)
-{
-   u32 j = 0;
-
-   for(j = nCount; j != 0; j--);
-}
-/************************************** EOF *********************************/

Modified: trunk/src/platform/str9/platform.c
===================================================================
--- trunk/src/platform/str9/platform.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/str9/platform.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -15,24 +15,12 @@
 #include &quot;91x_gpio.h&quot;
 #include &quot;91x_uart.h&quot;
 #include &quot;91x_tim.h&quot;
+#include &quot;common.h&quot;
+#include &quot;platform_conf.h&quot;
 
 // We define here the UART used by this porting layer
 #define STR9_UART         UART1
 
-// *****************************************************************************
-// std functions
-
-static void uart_send( int fd, char c )
-{
-  fd = fd;
-  platform_uart_send( 0, c );
-}
-
-static int uart_recv()
-{
-  return platform_uart_recv( 0, 0, PLATFORM_UART_INFINITE_TIMEOUT );
-}
-
 // ****************************************************************************
 // Platform initialization
 static const GPIO_TypeDef* port_data[] = { GPIO0, GPIO1, GPIO2, GPIO3, GPIO4, GPIO5, GPIO6, GPIO7, GPIO8, GPIO9 };
@@ -89,7 +77,7 @@
     GPIO_DeInit( ( GPIO_TypeDef* )port_data[ i ] );
   
   // UART setup (only STR9_UART is used in this example)
-  platform_uart_setup( 0, 115200, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
+  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
   
   // Initialize timers
   for( i = 0; i &lt; 4; i ++ )
@@ -103,34 +91,14 @@
     TIM_CounterCmd( base, TIM_START );
   }
   
-  // Set the send/recv functions                          
-  std_set_send_func( uart_send );
-  std_set_get_func( uart_recv );  
-     
+  cmn_platform_init();
+
   return PLATFORM_OK;
 } 
 
 // ****************************************************************************
 // PIO functions
 
-int platform_pio_has_port( unsigned port )
-{
-  return port &lt; 10;
-}
-
-const char* platform_pio_get_prefix( unsigned port )
-{
-  static char c[ 3 ];
-  
-  sprintf( c, &quot;P%d&quot;, port );
-  return c;
-}
-
-int platform_pio_has_pin( unsigned port, unsigned pin )
-{
-  return port &lt; 10 &amp;&amp; pin &lt; 8;
-}
-
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
   GPIO_TypeDef* base = ( GPIO_TypeDef* )port_data[ port ];
@@ -187,11 +155,6 @@
 // ****************************************************************************
 // UART
 
-int platform_uart_exists( unsigned id )
-{
-  return id &lt; 1;
-}
-
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
   UART_InitTypeDef UART_InitStructure;
@@ -259,11 +222,8 @@
   UART_SendData( STR9_UART, data );
 }
 
-int platform_uart_recv( unsigned id, unsigned timer_id, int timeout )
+int platform_s_uart_recv( unsigned id, unsigned timer_id, int timeout )
 {
-  timer_data_type tmr_start, tmr_crt;
-  int res;
-    
   if( timeout == 0 )
   {
     // Return data only if already available
@@ -272,41 +232,13 @@
     else
       return -1;
   }
-  else if( timeout == PLATFORM_UART_INFINITE_TIMEOUT )
-  {
-    // Wait for data
-    while( UART_GetFlagStatus(STR9_UART, UART_FLAG_RxFIFOEmpty) == SET );
-    return UART_ReceiveData( STR9_UART );
-  }
-  else
-  {
-    // Receive char with the specified timeout
-    tmr_start = platform_timer_op( timer_id, PLATFORM_TIMER_OP_START,0 );
-    while( 1 )
-    {
-      if( UART_GetFlagStatus(STR9_UART, UART_FLAG_RxFIFOEmpty) != SET  )
-      {
-        res = UART_ReceiveData( STR9_UART );
-        break;
-      }
-      else
-        res = -1;
-      tmr_crt = platform_timer_op( timer_id, PLATFORM_TIMER_OP_READ, 0 );
-      if( platform_timer_get_diff_us( timer_id, tmr_crt, tmr_start ) &gt;= timeout )
-        break;
-    }
-    return res;    
-  }
+  while( UART_GetFlagStatus(STR9_UART, UART_FLAG_RxFIFOEmpty) == SET );
+  return UART_ReceiveData( STR9_UART );
 }
 
 // ****************************************************************************
 // Timer
 
-int platform_timer_exists( unsigned id )
-{
-  return id &lt; 4;
-}
-
 // Helper: get timer clock
 static u32 platform_timer_get_clock( unsigned id )
 {
@@ -330,7 +262,7 @@
   return baseclk / bestdiv;
 }
 
-void platform_timer_delay( unsigned id, u32 delay_us )
+void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
   TIM_TypeDef* base = ( TIM_TypeDef* )timer_data[ id ];  
   u32 freq;
@@ -351,7 +283,7 @@
   while( TIM_GetCounterValue( base ) &lt; final );  
 }
       
-u32 platform_timer_op( unsigned id, int op, u32 data )
+u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   TIM_TypeDef* base = ( TIM_TypeDef* )timer_data[ id ];  
@@ -387,43 +319,3 @@
   }
   return res;
 }
-
-u32 platform_timer_get_diff_us( unsigned id, timer_data_type end, timer_data_type start )
-{
-  timer_data_type temp;
-  u32 freq;
-    
-  freq = platform_timer_get_clock( id );
-  if( start &lt; end )
-  {
-    temp = end;
-    end = start;
-    start = temp;
-  }
-  return ( ( u64 )( start - end ) * 1000000 ) / freq;
-}
-
-// ****************************************************************************
-// CPU functions
-
-u32 platform_cpu_get_frequency()
-{
-  return SCU_GetMCLKFreqValue() * 1000;
-}
-
-// ****************************************************************************
-// Allocator support
-extern char end[];
-
-void* platform_get_first_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )end;
-}
-
-#define SRAM_ORIGIN 0x40000000
-#define SRAM_SIZE 0x18000
-
-void* platform_get_last_free_ram( unsigned id )
-{
-  return id &gt; 0 ? NULL : ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 );
-}

Modified: trunk/src/platform/str9/platform_conf.h
===================================================================
--- trunk/src/platform/str9/platform_conf.h	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/str9/platform_conf.h	2009-01-07 20:17:18 UTC (rev 143)
@@ -4,6 +4,8 @@
 #define __PLATFORM_CONF_H__
 
 #include &quot;auxmods.h&quot;
+#include &quot;stacks.h&quot;
+#include &quot;type.h&quot;
 
 // *****************************************************************************
 // Define here what components you want for this platform
@@ -17,15 +19,48 @@
 // *****************************************************************************
 // UART/Timer IDs configuration data (used in main.c)
 
-#define XMODEM_UART_ID        0
+#define CON_UART_ID           0
+#define CON_UART_SPEED        115200
 #define XMODEM_TIMER_ID       0
-#define TERM_UART_ID          0
 #define TERM_TIMER_ID         0
 #define TERM_LINES            25
 #define TERM_COLS             80
 #define TERM_TIMEOUT          100000
 
 // *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       0
+#define VTMR_FREQ_HZ          4
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               10
+#define NUM_SPI               0
+#define NUM_UART              1
+#define NUM_TIMER             4
+#define NUM_PWM               0
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+u32 SCU_GetMCLKFreqValue();
+#define CPU_FREQUENCY         ( SCU_GetMCLKFreqValue() * 1000 )
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            '0'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PINS_PER_PORT     8
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+#define SRAM_ORIGIN           0x40000000
+#define SRAM_SIZE             0x18000
+#define MEM_START_ADDRESS     { ( void* )end }
+#define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ) }
+
+// *****************************************************************************
 // Auxiliary libraries that will be compiled for this platform
 
 #define LUA_PLATFORM_LIBS\

Modified: trunk/src/platform/str9/startup912.s
===================================================================
--- trunk/src/platform/str9/startup912.s	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/str9/startup912.s	2009-01-07 20:17:18 UTC (rev 143)
@@ -88,11 +88,13 @@
 # STARTUP EXECUTABLE CODE
 #*************************************************************************
 
-      .text
+      .align 4
       .arm
       .extern main
       .global _startup
 
+      .section .vectors, &quot;a&quot;
+
 _startup:
 
 #*************************************************************************
@@ -130,7 +132,9 @@
 IRQ_Handler:        B       IRQ_Handler       /* should never get here as IRQ is via VIC slot... */
 FIQ_Handler:        B       FIQ_Handler
 
+          .text
 
+
 #*************************************************************************
 # Reset Handler Entry Point
 #*************************************************************************

Modified: trunk/src/platform/str9/str912fw44.lds
===================================================================
--- trunk/src/platform/str9/str912fw44.lds	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/platform/str9/str912fw44.lds	2009-01-07 20:17:18 UTC (rev 143)
@@ -13,6 +13,7 @@
     {
         . = ALIGN(4);
         _sfixed = .;
+        KEEP(*(.vectors))
         *(.text .text.*)        
         *(.rodata .rodata.*)        
         *(.gnu.linkonce.t.*)

Modified: trunk/src/xmodem.c
===================================================================
--- trunk/src/xmodem.c	2009-01-02 11:57:02 UTC (rev 142)
+++ trunk/src/xmodem.c	2009-01-07 20:17:18 UTC (rev 143)
@@ -121,8 +121,8 @@
         xmodem_out_func(ACK);
         // completed transmission normally
         return totalbytes;
-      case CAN:
-        if((c = xmodem_in_func(XMODEM_TIMEOUT_DELAY)) == CAN)
+      case XMODEM_CAN:
+        if((c = xmodem_in_func(XMODEM_TIMEOUT_DELAY)) == XMODEM_CAN)
         {
           xmodem_flush();
           xmodem_out_func(ACK);
@@ -182,9 +182,9 @@
           {
             // Cancel transmission
             xmodem_flush();
-            xmodem_out_func(CAN);
-            xmodem_out_func(CAN);
-            xmodem_out_func(CAN);    
+            xmodem_out_func(XMODEM_CAN);
+            xmodem_out_func(XMODEM_CAN);
+            xmodem_out_func(XMODEM_CAN);    
             return XMODEM_ERROR_OUTOFMEM;   
           }
         }
@@ -210,9 +210,9 @@
         // we are completely out of sync
         // cancel transmission
         xmodem_flush();
-        xmodem_out_func(CAN);
-        xmodem_out_func(CAN);
-        xmodem_out_func(CAN);
+        xmodem_out_func(XMODEM_CAN);
+        xmodem_out_func(XMODEM_CAN);
+        xmodem_out_func(XMODEM_CAN);
         return XMODEM_ERROR_OUTOFSYNC;
       }
     }
@@ -229,9 +229,9 @@
 
   // exceeded retry count
   xmodem_flush();
-  xmodem_out_func(CAN);
-  xmodem_out_func(CAN);
-  xmodem_out_func(CAN);
+  xmodem_out_func(XMODEM_CAN);
+  xmodem_out_func(XMODEM_CAN);
+  xmodem_out_func(XMODEM_CAN);
   return XMODEM_ERROR_RETRYEXCEED;
 }
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000098.html">[Elua-svn] r142 - trunk/src/newlib
</A></li>
	<LI>Next message: <A HREF="000100.html">[Elua-svn] r144 - trunk/src/modules
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-svn">More information about the eLua-svn
mailing list</a><br>
</body></html>
